DCSP from pandas.core.internals import make _ block DCNL DCSP panel _ shape = ( ( len ( placement ) , ) + shape ) DCNL DCSP selector = _ factor _ indexer ( shape &#91; 1 : &#93; , labels ) DCNL DCSP mask = np.zeros ( np.prod ( shape ) , dtype = bool ) DCNL DCSP mask.put ( selector , True ) DCNL DCSP if mask.all ( ) : DCNL DCSP DCSP pvalues = np.empty ( panel _ shape , dtype = values.dtype ) DCNL DCSP else : DCNL DCSP DCSP ( dtype , fill _ value ) = _ maybe _ promote ( values.dtype ) DCNL DCSP DCSP pvalues = np.empty ( panel _ shape , dtype = dtype ) DCNL DCSP DCSP pvalues.fill ( fill _ value ) DCNL DCSP values = values DCNL DCSP for i in range ( len ( placement ) ) : DCNL DCSP DCSP pvalues &#91; i &#93; .flat &#91; mask &#93; = values &#91; : , i &#93; DCNL DCSP return make _ block ( pvalues , placement = placement )
DCSP base _ cmd = &#91; &apos; qemu-img &apos; , &apos; create &apos; , &apos; -f &apos; , &apos; qcow2 &apos; &#93; DCNL DCSP cow _ opts = &#91; &#93; DCNL DCSP if backing _ file : DCNL DCSP DCSP cow _ opts + = &#91; ( &apos; backing _ file = % s &apos; % backing _ file ) &#93; DCNL DCSP DCSP base _ details = images.qemu _ img _ info ( backing _ file ) DCNL DCSP else : DCNL DCSP DCSP base _ details = None DCNL DCSP if ( base _ details and ( base _ details.cluster _ size is not None ) ) : DCNL DCSP DCSP cow _ opts + = &#91; ( &apos; cluster _ size = % s &apos; % base _ details.cluster _ size ) &#93; DCNL DCSP if ( base _ details and base _ details.encryption ) : DCNL DCSP DCSP cow _ opts + = &#91; ( &apos; encryption = % s &apos; % base _ details.encryption ) &#93; DCNL DCSP if ( size is not None ) : DCNL DCSP DCSP cow _ opts + = &#91; ( &apos; size = % s &apos; % size ) &#93; DCNL DCSP if cow _ opts : DCNL DCSP DCSP csv _ opts = &apos; , &apos; .join ( cow _ opts ) DCNL DCSP DCSP cow _ opts = &#91; &apos; -o &apos; , csv _ opts &#93; DCNL DCSP cmd = ( ( base _ cmd + cow _ opts ) + &#91; path &#93; ) DCNL DCSP execute ( * cmd )
DCSP _ env _ reloader.update ( )
DCSP mapping = ( mapping or char _ morse ) DCNL DCSP assert ( sep not in mapping ) DCNL DCSP word _ sep = ( 2 * sep ) DCNL DCSP mapping &#91; &apos; DCSP &apos; &#93; = word _ sep DCNL DCSP suffix = ( msg and ( msg &#91; ( -1 ) &#93; in whitespace ) ) DCNL DCSP msg = ( &apos; DCSP &apos; if word _ sep else &apos; &apos; ) .join ( msg.split ( ) ) DCNL DCSP chars = set ( &apos; &apos;.join ( msg.split ( ) ) ) DCNL DCSP ok = set ( mapping.keys ( ) ) DCNL DCSP msg = translate ( msg , None , &apos; &apos;.join ( ( chars - ok ) ) ) DCNL DCSP morsestring = &#91; &#93; DCNL DCSP words = msg.split ( ) DCNL DCSP for word in words : DCNL DCSP DCSP morseword = &#91; &#93; DCNL DCSP DCSP for letter in word : DCNL DCSP DCSP DCSP morseletter = mapping &#91; letter &#93; DCNL DCSP DCSP DCSP morseword.append ( morseletter ) DCNL DCSP DCSP word = sep.join ( morseword ) DCNL DCSP DCSP morsestring.append ( word ) DCNL DCSP return ( word _ sep.join ( morsestring ) + ( word _ sep if suffix else &apos; &apos; ) )
DCSP class BoolModelChoices ( models.Model , ) : DCNL DCSP DCSP field = models.BooleanField ( choices = ( ( True , u &apos;Yes &apos; ) , ( False , u &apos;No &apos; ) ) ) DCNL DCSP DCSP class Meta : DCNL DCSP DCSP DCSP app _ label = u &apos;django _ tables2 _ test &apos; DCNL DCSP class Table ( tables.Table , ) : DCNL DCSP DCSP class Meta : DCNL DCSP DCSP DCSP model = BoolModelChoices DCNL DCSP table = Table ( &#91; BoolModelChoices ( field = True ) , BoolModelChoices ( field = False ) &#93; ) DCNL DCSP assert ( table.rows &#91; 0 &#93; .get _ cell ( u &apos;field &apos; ) = = u &apos; &lt; span DCSP class = &quot; true &quot; &gt; \ u2714 &lt; / span &gt; &apos; ) DCNL DCSP assert ( table.rows &#91; 1 &#93; .get _ cell ( u &apos;field &apos; ) = = u &apos; &lt; span DCSP class = &quot; false &quot; &gt; \ u2718 &lt; / span &gt; &apos; )
DCSP pass
DCSP if ( keep = = &apos; last &apos; ) : DCNL DCSP DCSP arr = arr &#91; : : ( -1 ) &#93; DCNL DCSP narr = len ( arr ) DCNL DCSP n = min ( n , narr ) DCNL DCSP sdtype = str ( arr.dtype ) DCNL DCSP arr = arr.view ( _ dtype _ map.get ( sdtype , sdtype ) ) DCNL DCSP kth _ val = algos.kth _ smallest ( arr.copy ( ) , ( n - 1 ) ) DCNL DCSP return _ finalize _ nsmallest ( arr , kth _ val , n , keep , narr )
DCSP hashes _ file = join ( partition _ dir , HASH _ FILE ) DCNL DCSP invalidations _ file = join ( partition _ dir , HASH _ INVALIDATIONS _ FILE ) DCNL DCSP if ( not os.path.exists ( hashes _ file ) ) : DCNL DCSP DCSP if os.path.exists ( invalidations _ file ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP with open ( invalidations _ file , &apos; wb &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP DCSP if ( e.errno ! = errno.ENOENT ) : DCNL DCSP DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP return None DCNL DCSP with lock _ path ( partition _ dir ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with open ( hashes _ file , &apos; rb &apos; ) as hashes _ fp : DCNL DCSP DCSP DCSP DCSP pickled _ hashes = hashes _ fp.read ( ) DCNL DCSP DCSP except ( IOError , OSError ) : DCNL DCSP DCSP DCSP hashes = { } DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP hashes = pickle.loads ( pickled _ hashes ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP hashes = None DCNL DCSP DCSP modified = False DCNL DCSP DCSP found _ invalidation _ entry = False DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with open ( invalidations _ file , &apos; rb &apos; ) as inv _ fh : DCNL DCSP DCSP DCSP DCSP for line in inv _ fh : DCNL DCSP DCSP DCSP DCSP DCSP found _ invalidation _ entry = True DCNL DCSP DCSP DCSP DCSP DCSP suffix = line.strip ( ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( hashes is not None ) and ( hashes.get ( suffix , &apos; &apos; ) is not None ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP hashes &#91; suffix &#93; = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP modified = True DCNL DCSP DCSP except ( IOError , OSError ) as e : DCNL DCSP DCSP DCSP if ( e.errno ! = errno.ENOENT ) : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP if modified : DCNL DCSP DCSP DCSP write _ pickle ( hashes , hashes _ file , partition _ dir , PICKLE _ PROTOCOL ) DCNL DCSP DCSP if found _ invalidation _ entry : DCNL DCSP DCSP DCSP with open ( invalidations _ file , &apos; wb &apos; ) as inv _ fh : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP return hashes
DCSP url = &apos; &apos;.join ( &#91; const.PASSPORT _ URL , &apos; ? getapi &amp; tpl = mn &amp; apiver = v3 &apos; , &apos; &amp; tt = &apos; , util.timestamp ( ) , &apos; &amp; class = login &amp; logintype = basicLogin &apos; &#93; ) DCNL DCSP req = net.urlopen ( url , headers = { &apos; Referer &apos; : &apos; &apos; } ) DCNL DCSP if req : DCNL DCSP DCSP return req.headers.get _ all ( &apos; Set-Cookie &apos; ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP return IMPL.cg _ has _ volumes _ filter ( attached _ or _ with _ snapshots )
DCSP return url _ is _ from _ any _ domain ( url , ( &#91; spider.name &#93; + getattr ( spider , &apos; allowed _ domains &apos; , &#91; &#93; ) ) )
DCSP seq = &#91; &#91; K.one , K.zero &#93; , &#91; K.zero &#93; &#93; DCNL DCSP for i in range ( 2 , ( n + 1 ) ) : DCNL DCSP DCSP a = dup _ mul _ ground ( dup _ lshift ( seq &#91; ( -1 ) &#93; , 1 , K ) , K ( ( 3 - ( 2 * i ) ) ) , K ) DCNL DCSP DCSP seq.append ( dup _ sub ( a , seq &#91; ( -2 ) &#93; , K ) ) DCNL DCSP return seq &#91; n &#93;
DCSP if ( &apos; proj _ checks &apos; in params ) : DCNL DCSP DCSP bools = &#91; x &#91; 0 &#93; .get _ visible ( ) for x in params &#91; &apos; proj _ checks &apos; &#93; .lines &#93; DCNL DCSP DCSP for ( bi , ( b , p ) ) in enumerate ( zip ( bools , params &#91; &apos; projs &apos; &#93; ) ) : DCNL DCSP DCSP DCSP if ( ( not b ) and p &#91; &apos; active &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP bools &#91; bi &#93; = True DCNL DCSP else : DCNL DCSP DCSP bools = ( &#91; True &#93; * len ( params &#91; &apos; projs &apos; &#93; ) ) DCNL DCSP compute _ proj = False DCNL DCSP if ( &apos; proj _ bools &apos; not in params ) : DCNL DCSP DCSP compute _ proj = True DCNL DCSP elif ( not np.array _ equal ( bools , params &#91; &apos; proj _ bools &apos; &#93; ) ) : DCNL DCSP DCSP compute _ proj = True DCNL DCSP if ( compute _ proj is True ) : DCNL DCSP DCSP params &#91; &apos; plot _ update _ proj _ callback &apos; &#93; ( params , bools )
DCSP ( img _ h , img _ w ) = output.shape &#91; 1 : 3 &#93; DCNL DCSP start _ idx = restore _ rect ( output , coord , coord , ( img _ h - coord ) , ( coord + width ) , width , dense _ input , start _ idx ) DCNL DCSP start _ idx = restore _ rect ( output , coord , ( ( img _ w - coord ) - width ) , ( img _ h - coord ) , ( img _ w - coord ) , width , dense _ input , start _ idx ) DCNL DCSP start _ idx = restore _ rect ( output , coord , ( coord + width ) , ( coord + width ) , ( ( img _ w - coord ) - width ) , width , dense _ input , start _ idx ) DCNL DCSP start _ idx = restore _ rect ( output , ( ( img _ h - coord ) - width ) , ( coord + width ) , ( img _ h - coord ) , ( ( img _ w - coord ) - width ) , width , dense _ input , start _ idx ) DCNL DCSP return start _ idx
DCSP return builder.fsub ( lc.Constant.real ( val.type , ( -0.0 ) ) , val )
DCSP from sympy.utilities import flatten DCNL DCSP if ( visual in ( 1 , 0 ) ) : DCNL DCSP DCSP visual = bool ( visual ) DCNL DCSP elif ( visual not in ( True , False ) ) : DCNL DCSP DCSP visual = None DCNL DCSP if ( type ( n ) is str ) : DCNL DCSP DCSP if visual : DCNL DCSP DCSP DCSP return n DCNL DCSP DCSP d = { } DCNL DCSP DCSP for li in n.splitlines ( ) : DCNL DCSP DCSP DCSP ( k , v ) = &#91; int ( i ) for i in li.split ( &apos; has &apos; ) &#91; 0 &#93; .split ( &apos; = &apos; ) &#91; 1 &#93; .split ( &apos; * * &apos; ) &#93; DCNL DCSP DCSP DCSP d &#91; k &#93; = v DCNL DCSP DCSP if ( ( visual is not True ) and ( visual is not False ) ) : DCNL DCSP DCSP DCSP return d DCNL DCSP DCSP return smoothness _ p ( d , visual = False ) DCNL DCSP elif ( type ( n ) is not tuple ) : DCNL DCSP DCSP facs = factorint ( n , visual = False ) DCNL DCSP if power : DCNL DCSP DCSP k = ( -1 ) DCNL DCSP else : DCNL DCSP DCSP k = 1 DCNL DCSP if ( type ( n ) is not tuple ) : DCNL DCSP DCSP rv = ( m , sorted ( &#91; ( f , tuple ( ( &#91; M &#93; + list ( smoothness ( ( f + m ) ) ) ) ) ) for ( f , M ) in &#91; i for i in facs.items ( ) &#93; &#93; , key = ( lambda x : ( x &#91; 1 &#93; &#91; k &#93; , x &#91; 0 &#93; ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP rv = n DCNL DCSP if ( ( visual is False ) or ( ( visual is not True ) and ( type ( n ) in &#91; int , Mul &#93; ) ) ) : DCNL DCSP DCSP return rv DCNL DCSP lines = &#91; &#93; DCNL DCSP for dat in rv &#91; 1 &#93; : DCNL DCSP DCSP dat = flatten ( dat ) DCNL DCSP DCSP dat.insert ( 2 , m ) DCNL DCSP DCSP lines.append ( ( &apos; p * * i = % i * * % i DCSP has DCSP p % + i DCSP B = % i , DCSP B-pow = % i &apos; % tuple ( dat ) ) ) DCNL DCSP return &apos; \ n &apos; .join ( lines )
DCSP version _ re = re.compile ( &apos; zlib- ( &#91; 0-9 . &#93; + &#91; 0-9 &#93; ) .tar.gz &apos; ) DCNL DCSP filename = &apos; zlib- % s.tar.gz &apos; DCNL DCSP return download _ library ( dest _ dir , ZLIB _ LOCATION , &apos; zlib &apos; , version _ re , filename , version = version )
DCSP directed = G.is _ directed ( ) DCNL DCSP mapping = { } DCNL DCSP H = nx.DiGraph ( ) DCNL DCSP for ( i , node ) in enumerate ( G ) : DCNL DCSP DCSP mapping &#91; node &#93; = i DCNL DCSP DCSP H.add _ node ( ( &apos; % dA &apos; % i ) , id = node ) DCNL DCSP DCSP H.add _ node ( ( &apos; % dB &apos; % i ) , id = node ) DCNL DCSP DCSP H.add _ edge ( ( &apos; % dA &apos; % i ) , ( &apos; % dB &apos; % i ) , capacity = 1 ) DCNL DCSP edges = &#91; &#93; DCNL DCSP for ( source , target ) in G.edges ( ) : DCNL DCSP DCSP edges.append ( ( ( &apos; % sB &apos; % mapping &#91; source &#93; ) , ( &apos; % sA &apos; % mapping &#91; target &#93; ) ) ) DCNL DCSP DCSP if ( not directed ) : DCNL DCSP DCSP DCSP edges.append ( ( ( &apos; % sB &apos; % mapping &#91; target &#93; ) , ( &apos; % sA &apos; % mapping &#91; source &#93; ) ) ) DCNL DCSP H.add _ edges _ from ( edges , capacity = 1 ) DCNL DCSP H.graph &#91; &apos; mapping &apos; &#93; = mapping DCNL DCSP return H
DCSP info = { } DCNL DCSP with open ( &apos; / proc / meminfo &apos; , &apos; r &apos; ) as f : DCNL DCSP DCSP for line in f : DCNL DCSP DCSP DCSP p = line.split ( ) DCNL DCSP DCSP DCSP info &#91; p &#91; 0 &#93; .strip ( &apos; : &apos; ) .lower ( ) &#93; = ( float ( p &#91; 1 &#93; ) * 1000.0 ) DCNL DCSP return info
DCSP import telegram DCNL DCSP try : DCNL DCSP DCSP chat _ id = config.get ( CONF _ CHAT _ ID ) DCNL DCSP DCSP api _ key = config.get ( CONF _ API _ KEY ) DCNL DCSP DCSP bot = telegram.Bot ( token = api _ key ) DCNL DCSP DCSP username = bot.getMe ( ) &#91; &apos; username &apos; &#93; DCNL DCSP DCSP _ LOGGER.info ( &quot; Telegram DCSP bot DCSP is DCSP &apos; % s &apos; &quot; , username ) DCNL DCSP except urllib.error.HTTPError : DCNL DCSP DCSP _ LOGGER.error ( &apos; Please DCSP check DCSP your DCSP access DCSP token &apos; ) DCNL DCSP DCSP return None DCNL DCSP return TelegramNotificationService ( api _ key , chat _ id )
DCSP return reverse _ url ( handler _ name , &apos; course _ key _ string &apos; , course _ key , kwargs )
DCSP ( lower _ limit , upper _ limit ) = limits DCNL DCSP ( lower _ include , upper _ include ) = inclusive DCNL DCSP am = ma.MaskedArray ( a ) DCNL DCSP if ( lower _ limit is not None ) : DCNL DCSP DCSP if lower _ include : DCNL DCSP DCSP DCSP am = ma.masked _ less ( am , lower _ limit ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP am = ma.masked _ less _ equal ( am , lower _ limit ) DCNL DCSP if ( upper _ limit is not None ) : DCNL DCSP DCSP if upper _ include : DCNL DCSP DCSP DCSP am = ma.masked _ greater ( am , upper _ limit ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP am = ma.masked _ greater _ equal ( am , upper _ limit ) DCNL DCSP if ( am.count ( ) = = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; No DCSP array DCSP values DCSP within DCSP given DCSP limits &apos; ) DCNL DCSP return am
DCSP values = &#91; &#93; DCNL DCSP curdata = &#91; &#93; DCNL DCSP state = 0 DCNL DCSP for char in data : DCNL DCSP DCSP if ( state = = 0 ) : DCNL DCSP DCSP DCSP if ( char = = &apos; , &apos; ) : DCNL DCSP DCSP DCSP DCSP values.append ( &apos; &apos;.join ( curdata ) .strip ( ) ) DCNL DCSP DCSP DCSP DCSP curdata = &#91; &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( char = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP state = 1 DCNL DCSP DCSP DCSP DCSP curdata.append ( char ) DCNL DCSP DCSP elif ( state = = 1 ) : DCNL DCSP DCSP DCSP if ( char = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP DCSP state = 0 DCNL DCSP DCSP DCSP curdata.append ( char ) DCNL DCSP values.append ( &apos; &apos;.join ( curdata ) .strip ( ) ) DCNL DCSP if ( ( state = = 1 ) and config.DEBUG ) : DCNL DCSP DCSP sys.stderr.write ( ( &apos; IVRE : DCSP WARNING : DCSP could DCSP not DCSP parse DCSP Digest DCSP auth DCSP data DCSP &#91; % r &#93; &apos; % data ) ) DCNL DCSP return values
DCSP if ( key not in xmlElement.attributeDictionary ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP word = str ( xmlElement.attributeDictionary &#91; key &#93; ) .strip ( ) DCNL DCSP evaluatedLinkValue = getEvaluatedLinkValue ( word , xmlElement ) DCNL DCSP if ( evaluatedLinkValue . _ _ class _ _ = = list ) : DCNL DCSP DCSP return getPathByList ( evaluatedLinkValue ) DCNL DCSP xmlElementObject = getXMLElementObject ( evaluatedLinkValue ) DCNL DCSP if ( xmlElementObject = = None ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP return xmlElementObject.getPaths ( ) &#91; 0 &#93;
DCSP if isinstance ( value , dict ) : DCNL DCSP DCSP return value DCNL DCSP values = &#91; &#93; DCNL DCSP for value in check _ csv ( option , opt , value ) : DCNL DCSP DCSP if ( value.find ( &apos; = &apos; ) ! = ( -1 ) ) : DCNL DCSP DCSP DCSP values.append ( value.split ( &apos; = &apos; , 1 ) ) DCNL DCSP DCSP elif ( value.find ( &apos; : &apos; ) ! = ( -1 ) ) : DCNL DCSP DCSP DCSP values.append ( value.split ( &apos; : &apos; , 1 ) ) DCNL DCSP if values : DCNL DCSP DCSP return dict ( values ) DCNL DCSP msg = &apos; option DCSP % s : DCSP invalid DCSP named DCSP value DCSP % r , DCSP should DCSP be DCSP &lt; NAME &gt; = &lt; VALUE &gt; DCSP or DCSP &lt; NAME &gt; : &lt; VALUE &gt; &apos; DCNL DCSP raise OptionValueError ( ( msg % ( opt , value ) ) )
DCSP return all ( ( conn.settings _ dict &#91; &apos; SUPPORTS _ TRANSACTIONS &apos; &#93; for conn in connections.all ( ) ) )
DCSP environment = getattr ( request.config , &apos; _ environment &apos; , None ) DCNL DCSP if environment : DCNL DCSP DCSP behave _ version = behave . _ _ version _ _ DCNL DCSP DCSP environment.append ( ( &apos; behave &apos; , behave _ version ) )
DCSP for ch in ( escape + _ special _ characters ) : DCNL DCSP DCSP term = term.replace ( ch , ( escape + ch ) ) DCNL DCSP return term
DCSP parts = idstr.split ( &apos; v &apos; ) DCNL DCSP return parts &#91; 0 &#93;
DCSP if ( ( ( &apos; . _ &apos; + cdn _ url _ query _ encode _ salt ) + &apos; _ . &apos; ) not in embedded _ url &#91; ( -15 ) : &#93; ) : DCNL DCSP DCSP return None DCNL DCSP m = regex _ extract _ base64 _ from _ embedded _ url.search ( embedded _ url ) DCNL DCSP b64 = get _ group ( &apos; b64 &apos; , m ) DCNL DCSP real _ request _ url _ no _ query = embedded _ url &#91; : m.span ( ) &#91; 0 &#93; &#93; DCNL DCSP query _ string _ byte = base64.urlsafe _ b64decode ( b64 ) DCNL DCSP is _ gzipped = get _ group ( &apos; gzip &apos; , m ) DCNL DCSP if is _ gzipped : DCNL DCSP DCSP query _ string _ byte = zlib.decompress ( query _ string _ byte ) DCNL DCSP query _ string = query _ string _ byte.decode ( encoding = &apos; utf-8 &apos; ) DCNL DCSP result = urljoin ( real _ request _ url _ no _ query , ( &apos; ? &apos; + query _ string ) ) DCNL DCSP return result
DCSP data _ home = get _ data _ home ( data _ home = data _ home ) DCNL DCSP cache _ path = _ pkl _ filepath ( data _ home , CACHE _ NAME ) DCNL DCSP twenty _ home = os.path.join ( data _ home , &apos; 20news _ home &apos; ) DCNL DCSP cache = None DCNL DCSP if os.path.exists ( cache _ path ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with open ( cache _ path , &apos; rb &apos; ) as f : DCNL DCSP DCSP DCSP DCSP compressed _ content = f.read ( ) DCNL DCSP DCSP DCSP uncompressed _ content = codecs.decode ( compressed _ content , &apos; zlib _ codec &apos; ) DCNL DCSP DCSP DCSP cache = pickle.loads ( uncompressed _ content ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP print ( 80 * &apos; _ &apos; ) DCNL DCSP DCSP DCSP print &apos; Cache DCSP loading DCSP failed &apos; DCNL DCSP DCSP DCSP print ( 80 * &apos; _ &apos; ) DCNL DCSP DCSP DCSP print e DCNL DCSP if ( cache is None ) : DCNL DCSP DCSP if download _ if _ missing : DCNL DCSP DCSP DCSP logger.info ( &apos; Downloading DCSP 20news DCSP dataset . DCSP This DCSP may DCSP take DCSP a DCSP few DCSP minutes . &apos; ) DCNL DCSP DCSP DCSP cache = download _ 20newsgroups ( target _ dir = twenty _ home , cache _ path = cache _ path ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise IOError ( &apos; 20Newsgroups DCSP dataset DCSP not DCSP found &apos; ) DCNL DCSP if ( subset in ( &apos; train &apos; , &apos; test &apos; ) ) : DCNL DCSP DCSP data = cache &#91; subset &#93; DCNL DCSP elif ( subset = = &apos; all &apos; ) : DCNL DCSP DCSP data _ lst = list ( ) DCNL DCSP DCSP target = list ( ) DCNL DCSP DCSP filenames = list ( ) DCNL DCSP DCSP for subset in ( &apos; train &apos; , &apos; test &apos; ) : DCNL DCSP DCSP DCSP data = cache &#91; subset &#93; DCNL DCSP DCSP DCSP data _ lst.extend ( data.data ) DCNL DCSP DCSP DCSP target.extend ( data.target ) DCNL DCSP DCSP DCSP filenames.extend ( data.filenames ) DCNL DCSP DCSP data.data = data _ lst DCNL DCSP DCSP data.target = np.array ( target ) DCNL DCSP DCSP data.filenames = np.array ( filenames ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &quot; subset DCSP can DCSP only DCSP be DCSP &apos; train &apos; , DCSP &apos; test &apos; DCSP or DCSP &apos; all &apos; , DCSP got DCSP &apos; % s &apos; &quot; % subset ) ) DCNL DCSP data.description = &apos; the DCSP 20 DCSP newsgroups DCSP by DCSP date DCSP dataset &apos; DCNL DCSP if ( &apos; headers &apos; in remove ) : DCNL DCSP DCSP data.data = &#91; strip _ newsgroup _ header ( text ) for text in data.data &#93; DCNL DCSP if ( &apos; footers &apos; in remove ) : DCNL DCSP DCSP data.data = &#91; strip _ newsgroup _ footer ( text ) for text in data.data &#93; DCNL DCSP if ( &apos; quotes &apos; in remove ) : DCNL DCSP DCSP data.data = &#91; strip _ newsgroup _ quoting ( text ) for text in data.data &#93; DCNL DCSP if ( categories is not None ) : DCNL DCSP DCSP labels = &#91; ( data.target _ names.index ( cat ) , cat ) for cat in categories &#93; DCNL DCSP DCSP labels.sort ( ) DCNL DCSP DCSP ( labels , categories ) = zip ( * labels ) DCNL DCSP DCSP mask = np.in1d ( data.target , labels ) DCNL DCSP DCSP data.filenames = data.filenames &#91; mask &#93; DCNL DCSP DCSP data.target = data.target &#91; mask &#93; DCNL DCSP DCSP data.target = np.searchsorted ( labels , data.target ) DCNL DCSP DCSP data.target _ names = list ( categories ) DCNL DCSP DCSP data _ lst = np.array ( data.data , dtype = object ) DCNL DCSP DCSP data _ lst = data _ lst &#91; mask &#93; DCNL DCSP DCSP data.data = data _ lst.tolist ( ) DCNL DCSP if shuffle : DCNL DCSP DCSP random _ state = check _ random _ state ( random _ state ) DCNL DCSP DCSP indices = np.arange ( data.target.shape &#91; 0 &#93; ) DCNL DCSP DCSP random _ state.shuffle ( indices ) DCNL DCSP DCSP data.filenames = data.filenames &#91; indices &#93; DCNL DCSP DCSP data.target = data.target &#91; indices &#93; DCNL DCSP DCSP data _ lst = np.array ( data.data , dtype = object ) DCNL DCSP DCSP data _ lst = data _ lst &#91; indices &#93; DCNL DCSP DCSP data.data = data _ lst.tolist ( ) DCNL DCSP return data
DCSP scope = defined.get _ scope ( ) DCNL DCSP pymodule = defined.get _ module ( ) DCNL DCSP lines = pymodule.lines DCNL DCSP node = defined.get _ ast ( ) DCNL DCSP start _ line = node.lineno DCNL DCSP if ( defined.get _ doc ( ) is None ) : DCNL DCSP DCSP start _ line = node.body &#91; 0 &#93; .lineno DCNL DCSP elif ( len ( node.body ) &gt; 1 ) : DCNL DCSP DCSP start _ line = node.body &#91; 1 &#93; .lineno DCNL DCSP start = lines.get _ line _ start ( start _ line ) DCNL DCSP scope _ start = pymodule.logical _ lines.logical _ line _ in ( scope.start ) DCNL DCSP if ( scope _ start &#91; 1 &#93; &gt; = start _ line ) : DCNL DCSP DCSP start = ( pymodule.source _ code.index ( &apos; : &apos; , start ) + 1 ) DCNL DCSP DCSP while pymodule.source _ code &#91; start &#93; .isspace ( ) : DCNL DCSP DCSP DCSP start + = 1 DCNL DCSP end = min ( ( lines.get _ line _ end ( scope.end ) + 1 ) , len ( pymodule.source _ code ) ) DCNL DCSP return ( start , end )
DCSP def prep ( r ) : DCNL DCSP DCSP tablename = &apos; project _ project &apos; DCNL DCSP DCSP s3.crud _ strings &#91; tablename &#93; .title _ list = T ( &apos; Open DCSP Tasks DCSP for DCSP Project &apos; ) DCNL DCSP DCSP s3.crud _ labels.READ = s3.crud _ labels.UPDATE = T ( &apos; Select &apos; ) DCNL DCSP DCSP s3db.configure ( tablename , deletable = False , listadd = False ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if ( r.interactive and ( not r.component ) ) : DCNL DCSP DCSP DCSP tasklist _ url = URL ( f = &apos; task &apos; , vars = { &apos; project &apos; : &apos; &#91; id &#93; &apos; } ) DCNL DCSP DCSP DCSP s3 _ action _ buttons ( r , deletable = False , read _ url = tasklist _ url , update _ url = tasklist _ url ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP return s3 _ rest _ controller ( module , &apos; project &apos; , hide _ filter = False )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( not conn ) : DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP cc = conn.describe _ cache _ clusters ( name , show _ cache _ node _ info = True ) DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP get DCSP config DCSP for DCSP cache DCSP cluster DCSP { 0 } . &apos; .format ( name ) DCNL DCSP DCSP log.error ( msg ) DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP return { } DCNL DCSP cc = cc &#91; &apos; DescribeCacheClustersResponse &apos; &#93; &#91; &apos; DescribeCacheClustersResult &apos; &#93; DCNL DCSP host = cc &#91; &apos; CacheClusters &apos; &#93; &#91; 0 &#93; &#91; &apos; CacheNodes &apos; &#93; &#91; 0 &#93; &#91; &apos; Endpoint &apos; &#93; &#91; &apos; Address &apos; &#93; DCNL DCSP return host
DCSP if ( get _ configured _ provider ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP if ( get _ dependencies ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP return True
DCSP try : DCNL DCSP DCSP return int ( value ) DCNL DCSP except ( ValueError , TypeError ) : DCNL DCSP DCSP return value
DCSP def _ winsorize1D ( a , low _ limit , up _ limit , low _ include , up _ include ) : DCNL DCSP DCSP n = a.count ( ) DCNL DCSP DCSP idx = a.argsort ( ) DCNL DCSP DCSP if low _ limit : DCNL DCSP DCSP DCSP if low _ include : DCNL DCSP DCSP DCSP DCSP lowidx = int ( ( low _ limit * n ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP lowidx = np.round ( ( low _ limit * n ) ) DCNL DCSP DCSP DCSP a &#91; idx &#91; : lowidx &#93; &#93; = a &#91; idx &#91; lowidx &#93; &#93; DCNL DCSP DCSP if ( up _ limit is not None ) : DCNL DCSP DCSP DCSP if up _ include : DCNL DCSP DCSP DCSP DCSP upidx = ( n - int ( ( n * up _ limit ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP upidx = ( n - np.round ( ( n * up _ limit ) ) ) DCNL DCSP DCSP DCSP a &#91; idx &#91; upidx : &#93; &#93; = a &#91; idx &#91; ( upidx - 1 ) &#93; &#93; DCNL DCSP DCSP return a DCNL DCSP a = ma.array ( a , copy = np.logical _ not ( inplace ) ) DCNL DCSP if ( limits is None ) : DCNL DCSP DCSP return a DCNL DCSP if ( ( not isinstance ( limits , tuple ) ) and isinstance ( limits , float ) ) : DCNL DCSP DCSP limits = ( limits , limits ) DCNL DCSP ( lolim , uplim ) = limits DCNL DCSP errmsg = &apos; The DCSP proportion DCSP to DCSP cut DCSP from DCSP the DCSP % s DCSP should DCSP be DCSP between DCSP 0 . DCSP and DCSP 1 . &apos; DCNL DCSP if ( lolim is not None ) : DCNL DCSP DCSP if ( ( lolim &gt; 1.0 ) or ( lolim &lt; 0 ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( ( errmsg % &apos; beginning &apos; ) + ( &apos; ( got DCSP % s ) &apos; % lolim ) ) ) DCNL DCSP if ( uplim is not None ) : DCNL DCSP DCSP if ( ( uplim &gt; 1.0 ) or ( uplim &lt; 0 ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( ( errmsg % &apos; end &apos; ) + ( &apos; ( got DCSP % s ) &apos; % uplim ) ) ) DCNL DCSP ( loinc , upinc ) = inclusive DCNL DCSP if ( axis is None ) : DCNL DCSP DCSP shp = a.shape DCNL DCSP DCSP return _ winsorize1D ( a.ravel ( ) , lolim , uplim , loinc , upinc ) .reshape ( shp ) DCNL DCSP else : DCNL DCSP DCSP return ma.apply _ along _ axis ( _ winsorize1D , axis , a , lolim , uplim , loinc , upinc )
DCSP if ( not auth ) : DCNL DCSP DCSP return url DCNL DCSP url _ parts = urlparse ( url ) . _ asdict ( ) DCNL DCSP if ( url _ parts &#91; u &apos;auth &apos; &#93; and ( not force ) ) : DCNL DCSP DCSP return url DCNL DCSP url _ parts &#91; u &apos;auth &apos; &#93; = auth DCNL DCSP return Url ( * * url _ parts ) .url
DCSP return DatetimeIndex ( start = start , end = end , periods = periods , freq = freq , tz = tz , normalize = normalize , name = name , closed = closed , * * kwargs )
DCSP pass
DCSP if ( not hasattr ( instance , &apos; cache _ instance &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP sender.cache _ instance ( instance )
DCSP return ( value and ( value &#91; 0 &#93; .upper ( ) + value &#91; 1 : &#93; ) )
DCSP if ( line _ number = = 1 ) : DCNL DCSP DCSP return DCNL DCSP if previous _ logical.startswith ( &apos; @ &apos; ) : DCNL DCSP DCSP return DCNL DCSP if ( logical _ line.startswith ( &apos; def DCSP &apos; ) or logical _ line.startswith ( &apos; class DCSP &apos; ) or logical _ line.startswith ( &apos; @ &apos; ) ) : DCNL DCSP DCSP if ( ( indent _ level &gt; 0 ) and ( blank _ lines ! = 1 ) ) : DCNL DCSP DCSP DCSP return ( 0 , ( &apos; E301 DCSP expected DCSP 1 DCSP blank DCSP line , DCSP found DCSP % d &apos; % blank _ lines ) ) DCNL DCSP DCSP if ( ( indent _ level = = 0 ) and ( blank _ lines ! = 2 ) ) : DCNL DCSP DCSP DCSP return ( 0 , ( &apos; E302 DCSP expected DCSP 2 DCSP blank DCSP lines , DCSP found DCSP % d &apos; % blank _ lines ) ) DCNL DCSP if ( blank _ lines &gt; 2 ) : DCNL DCSP DCSP return ( 0 , ( &apos; E303 DCSP too DCSP many DCSP blank DCSP lines DCSP ( % d ) &apos; % blank _ lines ) )
DCSP hosts = &#91; Host ( ip , dev _ id , hass , config ) for ( dev _ id , ip ) in config &#91; const.CONF _ HOSTS &#93; .items ( ) &#93; DCNL DCSP interval = ( timedelta ( seconds = ( len ( hosts ) * config &#91; CONF _ PING _ COUNT &#93; ) ) + DEFAULT _ SCAN _ INTERVAL ) DCNL DCSP _ LOGGER.info ( &apos; Started DCSP ping DCSP tracker DCSP with DCSP interval = % s DCSP on DCSP hosts : DCSP % s &apos; , interval , &apos; , &apos; .join ( &#91; host.ip _ address for host in hosts &#93; ) ) DCNL DCSP def update ( now ) : DCNL DCSP DCSP &apos; Update DCSP all DCSP the DCSP hosts DCSP on DCSP every DCSP interval DCSP time . &apos; DCNL DCSP DCSP for host in hosts : DCNL DCSP DCSP DCSP host.update ( see ) DCNL DCSP DCSP track _ point _ in _ utc _ time ( hass , update , ( now + interval ) ) DCNL DCSP DCSP return True DCNL DCSP return update ( util.dt.utcnow ( ) )
DCSP Z = np.asarray ( Z , order = &apos; c &apos; ) DCNL DCSP is _ valid _ linkage ( Z , throw = True , name = &apos; Z &apos; ) DCNL DCSP return ( Z &#91; 1 : , 2 &#93; &gt; = Z &#91; : ( -1 ) , 2 &#93; ) .all ( )
DCSP if ( hasattr ( trigger _ type , &apos; parameters _ schema &apos; ) and ( not trigger _ type &#91; &apos; parameters _ schema &apos; &#93; ) ) : DCNL DCSP DCSP trigger _ dict = { &apos; name &apos; : trigger _ type.name , &apos; pack &apos; : trigger _ type.pack , &apos; type &apos; : trigger _ type.get _ reference ( ) .ref } DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return create _ or _ update _ trigger _ db ( trigger = trigger _ dict ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP LOG.exception ( &apos; Validation DCSP failed DCSP for DCSP Trigger = % s . &apos; , trigger _ dict ) DCNL DCSP DCSP DCSP raise TriggerTypeRegistrationException ( ( &apos; Unable DCSP to DCSP create DCSP Trigger DCSP for DCSP TriggerType = % s . &apos; % trigger _ type.name ) ) DCNL DCSP else : DCNL DCSP DCSP LOG.debug ( ( &quot; Won &apos;t DCSP create DCSP Trigger DCSP object DCSP as DCSP TriggerType DCSP % s DCSP expects DCSP &quot; + &apos; parameters . &apos; ) , trigger _ type ) DCNL DCSP DCSP return None
DCSP if ( not f ) : DCNL DCSP DCSP return K.zero DCNL DCSP else : DCNL DCSP DCSP return f &#91; 0 &#93; &#91; 1 &#93;
DCSP success = 1 DCNL DCSP name = os.path.basename ( fullname ) DCNL DCSP if ( ddir is not None ) : DCNL DCSP DCSP dfile = os.path.join ( ddir , name ) DCNL DCSP else : DCNL DCSP DCSP dfile = None DCNL DCSP if ( rx is not None ) : DCNL DCSP DCSP mo = rx.search ( fullname ) DCNL DCSP DCSP if mo : DCNL DCSP DCSP DCSP return success DCNL DCSP if os.path.isfile ( fullname ) : DCNL DCSP DCSP ( head , tail ) = ( name &#91; : ( -3 ) &#93; , name &#91; ( -3 ) : &#93; ) DCNL DCSP DCSP if ( tail = = &apos; .py &apos; ) : DCNL DCSP DCSP DCSP if ( not force ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP mtime = int ( os.stat ( fullname ) .st _ mtime ) DCNL DCSP DCSP DCSP DCSP DCSP expect = struct.pack ( &apos; &lt; 4sl &apos; , imp.get _ magic ( ) , mtime ) DCNL DCSP DCSP DCSP DCSP DCSP cfile = ( fullname + ( ( _ _ debug _ _ and &apos; c &apos; ) or &apos; o &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP with open ( cfile , &apos; rb &apos; ) as chandle : DCNL DCSP DCSP DCSP DCSP DCSP DCSP actual = chandle.read ( 8 ) DCNL DCSP DCSP DCSP DCSP DCSP if ( expect = = actual ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return success DCNL DCSP DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP if ( not quiet ) : DCNL DCSP DCSP DCSP DCSP print &apos; Compiling &apos; , fullname , &apos; ... &apos; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ok = py _ compile.compile ( fullname , None , dfile , True ) DCNL DCSP DCSP DCSP except py _ compile.PyCompileError as err : DCNL DCSP DCSP DCSP DCSP if quiet : DCNL DCSP DCSP DCSP DCSP DCSP print &apos; Compiling &apos; , fullname , &apos; ... &apos; DCNL DCSP DCSP DCSP DCSP print err.msg DCNL DCSP DCSP DCSP DCSP success = 0 DCNL DCSP DCSP DCSP except IOError as e : DCNL DCSP DCSP DCSP DCSP print &apos; Sorry &apos; , e DCNL DCSP DCSP DCSP DCSP success = 0 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( ok = = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP success = 0 DCNL DCSP return success
DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP s3 = current.response.s3 DCNL DCSP settings = current.deployment _ settings DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( extra _ filter is not None ) : DCNL DCSP DCSP DCSP r.resource.add _ filter ( extra _ filter ) DCNL DCSP DCSP c = r.controller DCNL DCSP DCSP deploy = ( c = = &apos; deploy &apos; ) DCNL DCSP DCSP vol = ( c = = &apos; vol &apos; ) DCNL DCSP DCSP if s3.rtl : DCNL DCSP DCSP DCSP f = s3db.pr _ phone _ contact.value DCNL DCSP DCSP DCSP f.represent = s3 _ phone _ represent DCNL DCSP DCSP DCSP f.widget = S3PhoneWidget ( ) DCNL DCSP DCSP method = r.method DCNL DCSP DCSP if ( method in ( &apos; form &apos; , &apos; lookup &apos; ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP elif ( method = = &apos; profile &apos; ) : DCNL DCSP DCSP DCSP s3db.pr _ address DCNL DCSP DCSP DCSP list _ fields = s3db.get _ config ( &apos; pr _ address &apos; , &apos; list _ fields &apos; ) DCNL DCSP DCSP DCSP list _ fields.append ( &apos; comments &apos; ) DCNL DCSP DCSP DCSP s3db.hrm _ training.date.represent = ( lambda d : S3DateTime.date _ represent ( d , utc = True ) ) DCNL DCSP DCSP DCSP list _ fields = &#91; &apos; course _ id &apos; , &apos; training _ event _ id $ site _ id &apos; , &apos; date &apos; , &apos; hours &apos; , &apos; grade &apos; , &apos; comments &apos; &#93; DCNL DCSP DCSP DCSP if deploy : DCNL DCSP DCSP DCSP DCSP list _ fields.append ( &apos; course _ id $ course _ job _ title.job _ title _ id &apos; ) DCNL DCSP DCSP DCSP s3db.configure ( &apos; hrm _ training &apos; , list _ fields = list _ fields ) DCNL DCSP DCSP DCSP s3db.hrm _ experience DCNL DCSP DCSP DCSP s3db.configure ( &apos; hrm _ experience &apos; , list _ fields = &#91; &apos; employment _ type &apos; , &apos; activity _ type &apos; , &apos; organisation _ id &apos; , &apos; organisation &apos; , &apos; job _ title _ id &apos; , &apos; job _ title &apos; , &apos; responsibilities &apos; , &apos; start _ date &apos; , &apos; end _ date &apos; , &apos; hours &apos; , &apos; location _ id &apos; , &apos; supervisor _ id &apos; , &apos; comments &apos; &#93; ) DCNL DCSP DCSP DCSP table = r.table DCNL DCSP DCSP DCSP record = r.record DCNL DCSP DCSP DCSP person _ id = record.person _ id DCNL DCSP DCSP DCSP ptable = db.pr _ person DCNL DCSP DCSP DCSP person = db ( ( ptable.id = = person _ id ) ) .select ( ptable.first _ name , ptable.middle _ name , ptable.last _ name , ptable.pe _ id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP name = s3 _ fullname ( person ) DCNL DCSP DCSP DCSP pe _ id = person.pe _ id DCNL DCSP DCSP DCSP comments = table.organisation _ id.represent ( record.organisation _ id ) DCNL DCSP DCSP DCSP if record.job _ title _ id : DCNL DCSP DCSP DCSP DCSP comments = ( SPAN ( ( &apos; % s , DCSP &apos; % s3 _ unicode ( table.job _ title _ id.represent ( record.job _ title _ id ) ) ) ) , comments ) DCNL DCSP DCSP DCSP contacts _ widget = dict ( label = &apos; Contacts &apos; , label _ create = &apos; Add DCSP Contact &apos; , tablename = &apos; pr _ contact &apos; , type = &apos; datalist &apos; , filter = ( FS ( &apos; pe _ id &apos; ) = = pe _ id ) , icon = &apos; phone &apos; , orderby = &apos; priority DCSP asc &apos; ) DCNL DCSP DCSP DCSP address _ widget = dict ( label = &apos; Address &apos; , label _ create = &apos; Add DCSP Address &apos; , type = &apos; datalist &apos; , tablename = &apos; pr _ address &apos; , filter = ( FS ( &apos; pe _ id &apos; ) = = pe _ id ) , icon = &apos; home &apos; ) DCNL DCSP DCSP DCSP credentials _ widget = dict ( label = &apos; Sectors &apos; , label _ create = &apos; Add DCSP Sector &apos; , create _ controller = c , type = &apos; datalist &apos; , tablename = &apos; hrm _ credential &apos; , filter = ( FS ( &apos; person _ id &apos; ) = = person _ id ) , icon = &apos; tags &apos; ) DCNL DCSP DCSP DCSP skills _ widget = dict ( label = &apos; Skills &apos; , label _ create = &apos; Add DCSP Skill &apos; , create _ controller = c , type = &apos; datalist &apos; , tablename = &apos; hrm _ competency &apos; , filter = ( FS ( &apos; person _ id &apos; ) = = person _ id ) , icon = &apos; comment-alt &apos; ) DCNL DCSP DCSP DCSP trainings _ widget = dict ( label = &apos; Trainings &apos; , label _ create = &apos; Add DCSP Training &apos; , create _ controller = c , type = &apos; datalist &apos; , tablename = &apos; hrm _ training &apos; , filter = ( FS ( &apos; person _ id &apos; ) = = person _ id ) , icon = &apos; wrench &apos; ) DCNL DCSP DCSP DCSP experience _ widget = dict ( label = &apos; Experience &apos; , label _ create = &apos; Add DCSP Experience &apos; , create _ controller = c , type = &apos; datalist &apos; , tablename = &apos; hrm _ experience &apos; , filter = ( FS ( &apos; person _ id &apos; ) = = person _ id ) , icon = &apos; truck &apos; ) DCNL DCSP DCSP DCSP docs _ widget = dict ( label = &apos; Documents &apos; , label _ create = &apos; Add DCSP Document &apos; , type = &apos; datalist &apos; , tablename = &apos; doc _ document &apos; , filter = ( FS ( &apos; doc _ id &apos; ) = = record.doc _ id ) , icon = &apos; attachment &apos; ) DCNL DCSP DCSP DCSP education _ widget = dict ( label = &apos; Education &apos; , label _ create = &apos; Add DCSP Education &apos; , type = &apos; datalist &apos; , tablename = &apos; pr _ education &apos; , filter = ( FS ( &apos; person _ id &apos; ) = = person _ id ) , icon = &apos; book &apos; ) DCNL DCSP DCSP DCSP profile _ widgets = &#91; contacts _ widget , address _ widget , skills _ widget , trainings _ widget , experience _ widget , docs _ widget &#93; DCNL DCSP DCSP DCSP if deploy : DCNL DCSP DCSP DCSP DCSP profile _ widgets.insert ( 2 , credentials _ widget ) DCNL DCSP DCSP DCSP DCSP if settings.get _ hrm _ use _ education ( ) : DCNL DCSP DCSP DCSP DCSP DCSP profile _ widgets.insert ( ( -1 ) , education _ widget ) DCNL DCSP DCSP DCSP s3db.configure ( &apos; hrm _ human _ resource &apos; , profile _ cols = 1 , profile _ header = DIV ( A ( s3 _ avatar _ represent ( person _ id , tablename = &apos; pr _ person &apos; , _ class = &apos; media-object &apos; ) , _ class = &apos; pull-left &apos; ) , H2 ( name ) , P ( comments ) , _ class = &apos; profile-header &apos; ) , profile _ title = ( &apos; % s DCSP : DCSP % s &apos; % ( s3 _ unicode ( s3.crud _ strings &#91; &apos; hrm _ human _ resource &apos; &#93; .title _ display ) , name ) ) , profile _ widgets = profile _ widgets ) DCNL DCSP DCSP elif ( method = = &apos; summary &apos; ) : DCNL DCSP DCSP DCSP if deploy : DCNL DCSP DCSP DCSP DCSP deploy _ team = settings.get _ deploy _ team _ label ( ) DCNL DCSP DCSP DCSP DCSP s3.crud _ strings &#91; &apos; hrm _ human _ resource &apos; &#93; &#91; &apos; title _ list &apos; &#93; = ( T ( &apos; % ( team ) s DCSP Members &apos; ) % dict ( team = T ( deploy _ team ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP s3.crud _ strings &#91; &apos; hrm _ human _ resource &apos; &#93; &#91; &apos; title _ list &apos; &#93; = T ( &apos; Staff DCSP &amp; DCSP Volunteers &apos; ) DCNL DCSP DCSP DCSP filter _ widgets = hrm _ human _ resource _ filters ( resource _ type = &apos; both &apos; , hrm _ type _ opts = s3db.hrm _ type _ opts ) DCNL DCSP DCSP DCSP list _ fields = &#91; &apos; id &apos; , &apos; person _ id &apos; , &apos; job _ title _ id &apos; , &apos; organisation _ id &apos; &#93; DCNL DCSP DCSP DCSP report _ fields = &#91; &apos; organisation _ id &apos; , &apos; person _ id &apos; , &apos; person _ id $ gender &apos; , &apos; job _ title _ id &apos; , ( T ( &apos; Training &apos; ) , &apos; training.course _ id &apos; ) &#93; DCNL DCSP DCSP DCSP rappend = report _ fields.append DCNL DCSP DCSP DCSP if vol : DCNL DCSP DCSP DCSP DCSP vol _ active = settings.get _ hrm _ vol _ active ( ) DCNL DCSP DCSP DCSP DCSP if vol _ active : DCNL DCSP DCSP DCSP DCSP DCSP list _ fields.append ( ( T ( &apos; Active &apos; ) , &apos; details.active &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP rappend ( ( T ( &apos; Active &apos; ) , &apos; details.active &apos; ) ) DCNL DCSP DCSP DCSP DCSP vol _ experience = settings.get _ hrm _ vol _ experience ( ) DCNL DCSP DCSP DCSP DCSP if ( vol _ experience in ( &apos; programme &apos; , &apos; both &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP list _ fields.append ( ( T ( &apos; Program &apos; ) , &apos; person _ id $ hours.programme _ id &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP rappend ( ( T ( &apos; Program &apos; ) , &apos; person _ id $ hours.programme _ id &apos; ) ) DCNL DCSP DCSP DCSP elif settings.get _ hrm _ staff _ departments ( ) : DCNL DCSP DCSP DCSP DCSP list _ fields.extend ( ( &apos; department _ id &apos; , &apos; site _ id &apos; ) ) DCNL DCSP DCSP DCSP DCSP report _ fields.extend ( ( &apos; site _ id &apos; , &apos; department _ id &apos; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP list _ fields.append ( &apos; site _ id &apos; ) DCNL DCSP DCSP DCSP DCSP rappend ( &apos; site _ id &apos; ) DCNL DCSP DCSP DCSP list _ fields.extend ( ( ( T ( &apos; Email &apos; ) , &apos; email.value &apos; ) , ( settings.get _ ui _ label _ mobile _ phone ( ) , &apos; phone.value &apos; ) ) ) DCNL DCSP DCSP DCSP levels = current.gis.get _ relevant _ hierarchy _ levels ( ) DCNL DCSP DCSP DCSP for level in levels : DCNL DCSP DCSP DCSP DCSP rappend ( ( &apos; location _ id $ % s &apos; % level ) ) DCNL DCSP DCSP DCSP if deploy : DCNL DCSP DCSP DCSP DCSP rappend ( ( T ( &apos; Credential &apos; ) , &apos; credential.job _ title _ id &apos; ) ) DCNL DCSP DCSP DCSP teams = settings.get _ hrm _ teams ( ) DCNL DCSP DCSP DCSP if teams : DCNL DCSP DCSP DCSP DCSP if ( teams = = &apos; Teams &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP teams = &apos; Team &apos; DCNL DCSP DCSP DCSP DCSP elif ( teams = = &apos; Groups &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP teams = &apos; Group &apos; DCNL DCSP DCSP DCSP DCSP rappend ( ( teams , &apos; group _ membership.group _ id &apos; ) ) DCNL DCSP DCSP DCSP if settings.get _ org _ regions ( ) : DCNL DCSP DCSP DCSP DCSP rappend ( &apos; organisation _ id $ region _ id &apos; ) DCNL DCSP DCSP DCSP report _ options = Storage ( rows = report _ fields , cols = report _ fields , fact = report _ fields , defaults = Storage ( rows = &apos; organisation _ id &apos; , cols = &apos; training.course _ id &apos; , fact = &apos; count ( person _ id ) &apos; , totals = True ) ) DCNL DCSP DCSP DCSP s3db.configure ( &apos; hrm _ human _ resource &apos; , filter _ widgets = filter _ widgets , list _ fields = list _ fields , report _ options = report _ options ) DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP if ( ( method = = &apos; create &apos; ) and ( not r.component ) ) : DCNL DCSP DCSP DCSP DCSP if ( not settings.get _ hrm _ mix _ staff ( ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if vol : DCNL DCSP DCSP DCSP DCSP DCSP DCSP c = &apos; vol &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP f = &apos; volunteer &apos; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP c = &apos; hrm &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP f = &apos; staff &apos; DCNL DCSP DCSP DCSP DCSP DCSP redirect ( URL ( c = c , f = f , args = r.args , vars = r.vars ) ) DCNL DCSP DCSP DCSP elif ( method = = &apos; delete &apos; ) : DCNL DCSP DCSP DCSP DCSP if deploy : DCNL DCSP DCSP DCSP DCSP DCSP atable = s3db.deploy _ application DCNL DCSP DCSP DCSP DCSP DCSP app = db ( ( atable.human _ resource _ id = = r.id ) ) .select ( atable.id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not app ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP current.session.error = &apos; Cannot DCSP find DCSP Application DCSP to DCSP delete ! &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP redirect ( URL ( args = &apos; summary &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP redirect ( URL ( f = &apos; application &apos; , args = &#91; app.id , &apos; delete &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP elif ( method = = &apos; profile &apos; ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP elif ( method = = &apos; deduplicate &apos; ) : DCNL DCSP DCSP DCSP DCSP from gluon.sqlhtml import OptionsWidget DCNL DCSP DCSP DCSP DCSP field = r.table.person _ id DCNL DCSP DCSP DCSP DCSP field.requires = IS _ ONE _ OF ( db , &apos; pr _ person.id &apos; , label = field.represent ) DCNL DCSP DCSP DCSP DCSP field.widget = OptionsWidget.widget DCNL DCSP DCSP DCSP elif r.id : DCNL DCSP DCSP DCSP DCSP vars = { &apos; human _ resource.id &apos; : r.id , &apos; group &apos; : &apos; staff &apos; } DCNL DCSP DCSP DCSP DCSP redirect ( URL ( f = &apos; person &apos; , vars = vars ) ) DCNL DCSP DCSP elif ( ( r.representation = = &apos; xls &apos; ) and ( not r.component ) ) : DCNL DCSP DCSP DCSP hrm _ xls _ list _ fields ( r ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP if ( not r.component ) : DCNL DCSP DCSP DCSP DCSP if ( r.controller = = &apos; deploy &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP deletable = True DCNL DCSP DCSP DCSP DCSP DCSP read _ url = URL ( args = &#91; &apos; &#91; id &#93; &apos; , &apos; profile &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP update _ url = URL ( args = &#91; &apos; &#91; id &#93; &apos; , &apos; profile &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP deletable = ( settings.get _ hrm _ deletable ( ) , ) DCNL DCSP DCSP DCSP DCSP DCSP read _ url = None DCNL DCSP DCSP DCSP DCSP DCSP update _ url = None DCNL DCSP DCSP DCSP DCSP S3CRUD.action _ buttons ( r , deletable = deletable , read _ url = read _ url , update _ url = update _ url ) DCNL DCSP DCSP DCSP DCSP if ( ( &apos; msg &apos; in settings.modules ) and settings.get _ hrm _ compose _ button ( ) and current.auth.permission.has _ permission ( &apos; update &apos; , c = &apos; hrm &apos; , f = &apos; compose &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP s3.actions.append ( { &apos; url &apos; : URL ( f = &apos; compose &apos; , vars = { &apos; human _ resource.id &apos; : &apos; &#91; id &#93; &apos; } ) , &apos; _ class &apos; : &apos; action-btn DCSP send &apos; , &apos; label &apos; : str ( T ( &apos; Send DCSP Message &apos; ) ) } ) DCNL DCSP DCSP elif ( r.representation = = &apos; plain &apos; ) : DCNL DCSP DCSP DCSP output = hrm _ map _ popup ( r ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = current.rest _ controller ( &apos; hrm &apos; , &apos; human _ resource &apos; ) DCNL DCSP return output
DCSP for corner in corners : DCNL DCSP DCSP if ( corner not in pointTable ) : DCNL DCSP DCSP DCSP addWithLeastLength ( importRadius , loops , corner ) DCNL DCSP DCSP DCSP pointTable &#91; corner &#93; = None DCNL DCSP return euclidean.getSimplifiedLoops ( loops , importRadius )
DCSP from plotly import graph _ reference DCNL DCSP from plotly.graph _ objs import graph _ objs DCNL DCSP if ( obj _ type not in graph _ reference.CLASSES ) : DCNL DCSP DCSP obj _ type = graph _ reference.string _ to _ class _ name ( obj _ type ) DCNL DCSP try : DCNL DCSP DCSP cls = getattr ( graph _ objs , obj _ type ) DCNL DCSP except AttributeError : DCNL DCSP DCSP raise exceptions.PlotlyError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP recognizable DCSP graph _ obj . &quot; .format ( obj _ type ) ) DCNL DCSP cls ( obj )
DCSP with open ( fname , &apos; rb &apos; ) as f : DCNL DCSP DCSP data = f.read ( ) DCNL DCSP if ( not empty ) : DCNL DCSP DCSP assert data DCNL DCSP if delete _ file : DCNL DCSP DCSP os.remove ( fname ) DCNL DCSP return data
DCSP if ( isinstance ( s , str ) and ( HAS _ UTF8.search ( s ) is not None ) ) : DCNL DCSP DCSP s = s.decode ( &apos; utf-8 &apos; ) DCNL DCSP def replace ( match ) : DCNL DCSP DCSP s = match.group ( 0 ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return ESCAPE _ DCT &#91; s &#93; DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP n = ord ( s ) DCNL DCSP DCSP DCSP if ( n &lt; 65536 ) : DCNL DCSP DCSP DCSP DCSP return &apos; \ \ u { 0 : 04x } &apos; .format ( n ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP n - = 65536 DCNL DCSP DCSP DCSP DCSP s1 = ( 55296 &#124; ( ( n &gt; &gt; 10 ) &amp; 1023 ) ) DCNL DCSP DCSP DCSP DCSP s2 = ( 56320 &#124; ( n &amp; 1023 ) ) DCNL DCSP DCSP DCSP DCSP return &apos; \ \ u { 0 : 04x } \ \ u { 1 : 04x } &apos; .format ( s1 , s2 ) DCNL DCSP return ( ( &apos; &quot; &apos; + str ( ESCAPE _ ASCII.sub ( replace , s ) ) ) + &apos; &quot; &apos; )
DCSP with closing ( zipfile.ZipFile ( f , &apos; r &apos; ) ) as zip _ file : DCNL DCSP DCSP p = pickle.Unpickler ( BytesIO ( zip _ file.open ( &apos; pkl &apos; ) .read ( ) ) ) DCNL DCSP DCSP p.persistent _ load = persistent _ load ( zip _ file ) DCNL DCSP DCSP return p.load ( )
DCSP weight _ inialization = uniform ( numpy.sqrt ( ( 2.0 / input _ dim ) ) , ( input _ dim , output _ dim ) ) DCNL DCSP W = theano.shared ( weight _ inialization , name = name ) DCNL DCSP assert ( param _ list is not None ) DCNL DCSP param _ list.append ( W ) DCNL DCSP return W
DCSP if ( width is None ) : DCNL DCSP DCSP width = len ( G ) DCNL DCSP def successors ( v ) : DCNL DCSP DCSP &apos; Returns DCSP a DCSP list DCSP of DCSP the DCSP best DCSP neighbors DCSP of DCSP a DCSP node . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP `v` DCSP is DCSP a DCSP node DCSP in DCSP the DCSP graph DCSP `G` . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP The DCSP &quot; best &quot; DCSP neighbors DCSP are DCSP chosen DCSP according DCSP to DCSP the DCSP `value` \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP function DCSP ( higher DCSP is DCSP better ) . DCSP Only DCSP the DCSP `width` DCSP best DCSP neighbors DCSP of \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP `v` DCSP are DCSP returned . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP The DCSP list DCSP returned DCSP by DCSP this DCSP function DCSP is DCSP in DCSP decreasing DCSP value DCSP as \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP measured DCSP by DCSP the DCSP `value` DCSP function . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP return iter ( sorted ( G.neighbors ( v ) , key = value , reverse = True ) &#91; : width &#93; ) DCNL DCSP for e in generic _ bfs _ edges ( G , source , successors ) : DCNL DCSP DCSP ( yield e )
DCSP N = len ( sequence ) DCNL DCSP def f ( i ) : DCNL DCSP DCSP return sequence &#91; ( i % N ) &#93; DCNL DCSP return partial ( _ force , sequence = _ advance ( f ) )
DCSP dump ( object _ , file _ , parameters = parameters , use _ cpickle = use _ cpickle , protocol = protocol , * * kwargs ) DCNL DCSP if ( to _ add is not None ) : DCNL DCSP DCSP for ( name , obj ) in six.iteritems ( to _ add ) : DCNL DCSP DCSP DCSP add _ to _ dump ( obj , file _ , name , parameters = parameters , use _ cpickle = use _ cpickle , protocol = protocol , * * kwargs )
DCSP f = open ( filename , &apos; w &apos; ) DCNL DCSP try : DCNL DCSP DCSP for line in contents : DCNL DCSP DCSP DCSP f.write ( ( line + &apos; \ n &apos; ) ) DCNL DCSP finally : DCNL DCSP DCSP f.close ( )
DCSP node _ tree _ position = tuple ( ( int ( x ) for x in tokens if x.isdigit ( ) ) ) DCNL DCSP return ( lambda i : ( lambda n , m = None , l = None : ( hasattr ( n , u &apos;treeposition &apos; ) and ( n.treeposition ( ) = = i ) ) ) ) ( node _ tree _ position )
DCSP conf = global _ conf.copy ( ) DCNL DCSP conf.update ( local _ conf ) DCNL DCSP def auth _ filter ( app ) : DCNL DCSP DCSP return S3Token ( app , conf ) DCNL DCSP return auth _ filter
DCSP if ( box is None ) : DCNL DCSP DCSP box = BoundingBox ( offset , shape ) DCNL DCSP if ( ( chance &lt; 100 ) or hollow ) : DCNL DCSP DCSP box = box.expand ( 1 ) DCNL DCSP outputShape = box.size DCNL DCSP outputShape = ( outputShape &#91; 0 &#93; , outputShape &#91; 2 &#93; , outputShape &#91; 1 &#93; ) DCNL DCSP shape = ( shape &#91; 0 &#93; , shape &#91; 2 &#93; , shape &#91; 1 &#93; ) DCNL DCSP offset = ( numpy.array ( offset ) - numpy.array ( box.origin ) ) DCNL DCSP offset = offset &#91; &#91; 0 , 2 , 1 &#93; &#93; DCNL DCSP inds = numpy.indices ( outputShape , dtype = float ) DCNL DCSP halfshape = numpy.array ( &#91; ( ( i &gt; &gt; 1 ) - ( ( ( ( i &amp; 1 ) = = 0 ) and 0.5 ) or 0 ) ) for i in shape &#93; ) DCNL DCSP blockCenters = ( inds - halfshape &#91; : , newaxis , newaxis , newaxis &#93; ) DCNL DCSP blockCenters - = offset &#91; : , newaxis , newaxis , newaxis &#93; DCNL DCSP shape = numpy.array ( shape , dtype = &apos; float32 &apos; ) DCNL DCSP if ( style = = &apos; Round &apos; ) : DCNL DCSP DCSP blockCenters * = blockCenters DCNL DCSP DCSP shape / = 2 DCNL DCSP DCSP shape * = shape DCNL DCSP DCSP blockCenters / = shape &#91; : , newaxis , newaxis , newaxis &#93; DCNL DCSP DCSP distances = sum ( blockCenters , 0 ) DCNL DCSP DCSP mask = ( distances &lt; 1 ) DCNL DCSP elif ( style = = &apos; Square &apos; ) : DCNL DCSP DCSP blockCenters / = shape &#91; : , newaxis , newaxis , newaxis &#93; DCNL DCSP DCSP distances = numpy.absolute ( blockCenters ) .max ( 0 ) DCNL DCSP DCSP mask = ( distances &lt; 0.5 ) DCNL DCSP elif ( style = = &apos; Diamond &apos; ) : DCNL DCSP DCSP blockCenters = numpy.abs ( blockCenters ) DCNL DCSP DCSP shape / = 2 DCNL DCSP DCSP blockCenters / = shape &#91; : , newaxis , newaxis , newaxis &#93; DCNL DCSP DCSP distances = sum ( blockCenters , 0 ) DCNL DCSP DCSP mask = ( distances &lt; 1 ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError , ( &apos; Unknown DCSP style : DCSP &apos; + style ) DCNL DCSP if ( ( ( chance &lt; 100 ) or hollow ) and ( max ( shape ) &gt; 1 ) ) : DCNL DCSP DCSP threshold = ( chance / 100.0 ) DCNL DCSP DCSP exposedBlockMask = numpy.ones ( shape = outputShape , dtype = &apos; bool &apos; ) DCNL DCSP DCSP exposedBlockMask &#91; : &#93; = mask DCNL DCSP DCSP submask = mask &#91; 1 : ( -1 ) , 1 : ( -1 ) , 1 : ( -1 ) &#93; DCNL DCSP DCSP exposedBlockSubMask = exposedBlockMask &#91; 1 : ( -1 ) , 1 : ( -1 ) , 1 : ( -1 ) &#93; DCNL DCSP DCSP exposedBlockSubMask &#91; : &#93; = False DCNL DCSP DCSP for dim in ( 0 , 1 , 2 ) : DCNL DCSP DCSP DCSP slices = &#91; slice ( 1 , ( -1 ) ) , slice ( 1 , ( -1 ) ) , slice ( 1 , ( -1 ) ) &#93; DCNL DCSP DCSP DCSP slices &#91; dim &#93; = slice ( None , ( -2 ) ) DCNL DCSP DCSP DCSP exposedBlockSubMask &#124; = ( submask &amp; ( mask &#91; slices &#93; ! = submask ) ) DCNL DCSP DCSP DCSP slices &#91; dim &#93; = slice ( 2 , None ) DCNL DCSP DCSP DCSP exposedBlockSubMask &#124; = ( submask &amp; ( mask &#91; slices &#93; ! = submask ) ) DCNL DCSP DCSP if hollow : DCNL DCSP DCSP DCSP mask &#91; ( ~ exposedBlockMask ) &#93; = False DCNL DCSP DCSP if ( chance &lt; 100 ) : DCNL DCSP DCSP DCSP rmask = ( numpy.random.random ( mask.shape ) &lt; threshold ) DCNL DCSP DCSP DCSP mask &#91; exposedBlockMask &#93; = rmask &#91; exposedBlockMask &#93; DCNL DCSP if ( ( chance &lt; 100 ) or hollow ) : DCNL DCSP DCSP return mask &#91; 1 : ( -1 ) , 1 : ( -1 ) , 1 : ( -1 ) &#93; DCNL DCSP else : DCNL DCSP DCSP return mask
DCSP database _ cats = get _ categories ( ) DCNL DCSP categories = &#91; &#93; DCNL DCSP for cat in database _ cats.keys ( ) : DCNL DCSP DCSP if ( cat ! = &apos; * &apos; ) : DCNL DCSP DCSP DCSP categories.append ( database _ cats &#91; cat &#93; .get _ dict ( ) ) DCNL DCSP categories.sort ( key = ( lambda cat : cat &#91; &apos; order &apos; &#93; ) ) DCNL DCSP categories.insert ( 0 , database _ cats &#91; &apos; * &apos; &#93; .get _ dict ( ) ) DCNL DCSP return categories
DCSP if gcodec.isProcedureDoneOrFileIsEmpty ( gcodeText , &apos; tower &apos; ) : DCNL DCSP DCSP return gcodeText DCNL DCSP if ( towerRepository = = None ) : DCNL DCSP DCSP towerRepository = settings.getReadRepository ( TowerRepository ( ) ) DCNL DCSP if ( not towerRepository.activateTower.value ) : DCNL DCSP DCSP return gcodeText DCNL DCSP return TowerSkein ( ) .getCraftedGcode ( gcodeText , towerRepository )
DCSP if ( not request.user.profile.is _ admin ( &apos; treeio.services &apos; ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP administrator DCSP access DCSP to DCSP the DCSP Service DCSP Support DCSP module &quot; ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP service = Service ( ) DCNL DCSP DCSP DCSP form = ServiceForm ( request.user.profile , request.POST , instance = service ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP service = form.save ( ) DCNL DCSP DCSP DCSP DCSP service.set _ user _ from _ request ( request ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; services _ service _ view &apos; , args = &#91; service.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; services &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP form = ServiceForm ( request.user.profile ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; form &apos; : form } ) DCNL DCSP return render _ to _ response ( &apos; services / service _ add &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( n = = 1 ) : DCNL DCSP DCSP it = iter ( iterable ) DCNL DCSP DCSP head = list ( islice ( it , 1 ) ) DCNL DCSP DCSP if ( not head ) : DCNL DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP if ( key is None ) : DCNL DCSP DCSP DCSP return &#91; max ( chain ( head , it ) ) &#93; DCNL DCSP DCSP return &#91; max ( chain ( head , it ) , key = key ) &#93; DCNL DCSP try : DCNL DCSP DCSP size = len ( iterable ) DCNL DCSP except ( TypeError , AttributeError ) : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP if ( n &gt; = size ) : DCNL DCSP DCSP DCSP return sorted ( iterable , key = key , reverse = True ) &#91; : n &#93; DCNL DCSP if ( key is None ) : DCNL DCSP DCSP it = izip ( iterable , imap ( neg , count ( ) ) ) DCNL DCSP DCSP result = _ nlargest ( n , it ) DCNL DCSP DCSP return map ( itemgetter ( 0 ) , result ) DCNL DCSP ( in1 , in2 ) = tee ( iterable ) DCNL DCSP it = izip ( imap ( key , in1 ) , imap ( neg , count ( ) ) , in2 ) DCNL DCSP result = _ nlargest ( n , it ) DCNL DCSP return map ( itemgetter ( 2 ) , result )
DCSP ret = { } DCNL DCSP client = salt.client.get _ local _ client ( _ _ opts _ _ &#91; &apos; conf _ file &apos; &#93; ) DCNL DCSP try : DCNL DCSP DCSP active _ = client.cmd ( &apos; * &apos; , &apos; saltutil.running &apos; , timeout = _ _ opts _ _ &#91; &apos; timeout &apos; &#93; ) DCNL DCSP except SaltClientError as client _ error : DCNL DCSP DCSP print ( client _ error ) DCNL DCSP DCSP return ret DCNL DCSP if display _ progress : DCNL DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Attempting DCSP to DCSP contact DCSP minions : DCSP { 0 } &apos; .format ( list ( active _ .keys ( ) ) ) } , &apos; progress &apos; ) DCNL DCSP for ( minion , data ) in six.iteritems ( active _ ) : DCNL DCSP DCSP if display _ progress : DCNL DCSP DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Received DCSP reply DCSP from DCSP minion DCSP { 0 } &apos; .format ( minion ) } , &apos; progress &apos; ) DCNL DCSP DCSP if ( not isinstance ( data , list ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for job in data : DCNL DCSP DCSP DCSP if ( not ( job &#91; &apos; jid &apos; &#93; in ret ) ) : DCNL DCSP DCSP DCSP DCSP ret &#91; job &#91; &apos; jid &apos; &#93; &#93; = _ format _ jid _ instance ( job &#91; &apos; jid &apos; &#93; , job ) DCNL DCSP DCSP DCSP DCSP ret &#91; job &#91; &apos; jid &apos; &#93; &#93; .update ( { &apos; Running &apos; : &#91; { minion : job.get ( &apos; pid &apos; , None ) } &#93; , &apos; Returned &apos; : &#91; &#93; } ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ret &#91; job &#91; &apos; jid &apos; &#93; &#93; &#91; &apos; Running &apos; &#93; .append ( { minion : job &#91; &apos; pid &apos; &#93; } ) DCNL DCSP mminion = salt.minion.MasterMinion ( _ _ opts _ _ ) DCNL DCSP for jid in ret : DCNL DCSP DCSP returner = _ get _ returner ( ( _ _ opts _ _ &#91; &apos; ext _ job _ cache &apos; &#93; , _ _ opts _ _ &#91; &apos; master _ job _ cache &apos; &#93; ) ) DCNL DCSP DCSP data = mminion.returners &#91; &apos; { 0 } .get _ jid &apos; .format ( returner ) &#93; ( jid ) DCNL DCSP DCSP for minion in data : DCNL DCSP DCSP DCSP if ( minion not in ret &#91; jid &#93; &#91; &apos; Returned &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; jid &#93; &#91; &apos; Returned &apos; &#93; .append ( minion ) DCNL DCSP return ret
DCSP osb = XML.SubElement ( xml _ parent , &apos; com.openshift.jenkins.plugins.pipeline.OpenShiftDeployCanceller &apos; ) DCNL DCSP mapping = &#91; ( &apos; api-url &apos; , &apos; apiURL &apos; , &apos; https : / / openshift.default.svc.cluster.local &apos; ) , ( &apos; dep-cfg &apos; , &apos; depCfg &apos; , &apos; frontend &apos; ) , ( &apos; namespace &apos; , &apos; namespace &apos; , &apos; test &apos; ) , ( &apos; auth-token &apos; , &apos; authToken &apos; , &apos; &apos; ) , ( &apos; verbose &apos; , &apos; verbose &apos; , False ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( osb , data , mapping , fail _ required = True )
DCSP f.seek ( 0 , 2 ) DCNL DCSP size = f.tell ( ) DCNL DCSP f.seek ( 0 , 0 ) DCNL DCSP for i in xrange ( 0 , ( size - 1 ) , 1000 ) : DCNL DCSP DCSP f.seek ( i , 0 )
DCSP safe = isinstance ( value , SafeData ) DCNL DCSP value = value.replace ( arg , &apos; &apos; ) DCNL DCSP if ( safe and ( arg ! = &apos; ; &apos; ) ) : DCNL DCSP DCSP return mark _ safe ( value ) DCNL DCSP return value
DCSP if sabnzbd.HAVE _ SSL : DCNL DCSP DCSP prot = &apos; https &apos; DCNL DCSP else : DCNL DCSP DCSP prot = &apos; http : &apos; DCNL DCSP return url
DCSP replacements = ( ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; ) , ( &quot; &apos; &quot; , &quot; \ \ &apos; &quot; ) , ( &apos; &quot; &apos; , &apos; \ \ &quot; &apos; ) , ( &apos; \ n &apos; , &apos; \ \ n &apos; ) , ( &apos; \ r &apos; , &apos; \ \ r &apos; ) , ( &apos; \ x00 &apos; , &apos; \ \ x00 &apos; ) , ( &apos; \ \ ufeff &apos; , &apos; \ \ ufeff &apos; ) , ( &apos; \ \ u2028 &apos; , &apos; \ \ u2028 &apos; ) , ( &apos; \ \ u2029 &apos; , &apos; \ \ u2029 &apos; ) ) DCNL DCSP for ( orig , repl ) in replacements : DCNL DCSP DCSP text = text.replace ( orig , repl ) DCNL DCSP return text
DCSP if os.path.isdir ( path ) : DCNL DCSP DCSP incomplete = os.listdir ( path ) DCNL DCSP DCSP complete = &#91; os.path.join ( path , entry ) for entry in incomplete &#93; DCNL DCSP DCSP lists = &#91; _ list _ files ( subpath , suffix ) for subpath in complete &#93; DCNL DCSP DCSP flattened = &#91; &#93; DCNL DCSP DCSP for l in lists : DCNL DCSP DCSP DCSP for elem in l : DCNL DCSP DCSP DCSP DCSP flattened.append ( elem ) DCNL DCSP DCSP return flattened DCNL DCSP else : DCNL DCSP DCSP assert os.path.exists ( path ) , ( &quot; couldn &apos;t DCSP find DCSP file DCSP &apos; % s &apos; &quot; % path ) DCNL DCSP DCSP if path.endswith ( suffix ) : DCNL DCSP DCSP DCSP return &#91; path &#93; DCNL DCSP DCSP return &#91; &#93;
DCSP return Parser ( handle ) .parse ( * * kwargs )
DCSP if ( not isinstance ( query , Query ) ) : DCNL DCSP DCSP raise datastore _ errors.BadArgumentError ( ( &apos; query DCSP argument DCSP should DCSP be DCSP datastore _ query.Query DCSP ( % r ) &apos; % ( query , ) ) ) DCNL DCSP overridden _ keys = set ( ) DCNL DCSP if ( deleted _ keys is not None ) : DCNL DCSP DCSP if ( not isinstance ( deleted _ keys , list ) ) : DCNL DCSP DCSP DCSP raise datastore _ errors.BadArgumentError ( ( &apos; deleted _ keys DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP ( % r ) &apos; % ( deleted _ keys , ) ) ) DCNL DCSP DCSP deleted _ keys = filter ( query . _ key _ filter , deleted _ keys ) DCNL DCSP DCSP for key in deleted _ keys : DCNL DCSP DCSP DCSP overridden _ keys.add ( datastore _ types.ReferenceToKeyValue ( key ) ) DCNL DCSP if ( updated _ entities is not None ) : DCNL DCSP DCSP if ( not isinstance ( updated _ entities , list ) ) : DCNL DCSP DCSP DCSP raise datastore _ errors.BadArgumentError ( ( &apos; updated _ entities DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP ( % r ) &apos; % ( updated _ entities , ) ) ) DCNL DCSP DCSP updated _ entities = filter ( query . _ key _ filter , updated _ entities ) DCNL DCSP DCSP for entity in updated _ entities : DCNL DCSP DCSP DCSP overridden _ keys.add ( datastore _ types.ReferenceToKeyValue ( entity.key ( ) ) ) DCNL DCSP DCSP updated _ entities = apply _ query ( query , updated _ entities ) DCNL DCSP else : DCNL DCSP DCSP updated _ entities = &#91; &#93; DCNL DCSP if ( not overridden _ keys ) : DCNL DCSP DCSP return query DCNL DCSP return _ AugmentedQuery ( query , in _ memory _ filter = _ IgnoreFilter ( overridden _ keys ) , in _ memory _ results = updated _ entities , max _ filtered _ count = len ( overridden _ keys ) )
DCSP return urlsafe _ b64encode ( sha.digest ( ) ) .decode ( &apos; ascii &apos; ) .rstrip ( &apos; = &apos; )
DCSP return tf.cos ( x )
DCSP return math.sqrt ( ( radiusComplex.real * radiusComplex.imag ) )
DCSP return &#91; ( lambda v = i : v ) for i in range ( n ) &#93;
DCSP return type ( f . _ _ name _ _ , ( FunctionFilter , ) , { &apos; function &apos; : f , &apos; _ _ module _ _ &apos; : getattr ( f , &apos; _ _ module _ _ &apos; ) , &apos; _ _ doc _ _ &apos; : f . _ _ doc _ _ } )
DCSP opts = _ get _ options ( ret ) DCNL DCSP metric _ base = ret &#91; &apos; fun &apos; &#93; DCNL DCSP if ( not metric _ base.startswith ( &apos; virt . &apos; ) ) : DCNL DCSP DCSP metric _ base + = ( &apos; .&apos; + ret &#91; &apos; id &apos; &#93; .replace ( &apos; .&apos; , &apos; _ &apos; ) ) DCNL DCSP saltdata = ret &#91; &apos; return &apos; &#93; DCNL DCSP _ send ( saltdata , metric _ base , opts )
DCSP decoded _ items = &#91; &#93; DCNL DCSP for item in byte _ list : DCNL DCSP DCSP decoded _ items.append ( item.decode ( _ _ salt _ system _ encoding _ _ ) ) DCNL DCSP return decoded _ items
DCSP return _ group _ or _ org _ purge ( context , data _ dict , is _ org = True )
DCSP return Test.objects.filter ( job = job _ idx )
DCSP rules = &#91; &#93; DCNL DCSP agg _ enabled = &#91; &apos; append &apos; , &apos; insert &apos; &#93; DCNL DCSP if ( low.get ( &apos; fun &apos; ) not in agg _ enabled ) : DCNL DCSP DCSP return low DCNL DCSP for chunk in chunks : DCNL DCSP DCSP tag = salt.utils.gen _ state _ tag ( chunk ) DCNL DCSP DCSP if ( tag in running ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( chunk.get ( &apos; state &apos; ) = = &apos; iptables &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; _ _ agg _ _ &apos; in chunk ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( chunk.get ( &apos; fun &apos; ) ! = low.get ( &apos; fun &apos; ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( chunk not in rules ) : DCNL DCSP DCSP DCSP DCSP rules.append ( chunk ) DCNL DCSP DCSP DCSP DCSP chunk &#91; &apos; _ _ agg _ _ &apos; &#93; = True DCNL DCSP if rules : DCNL DCSP DCSP if ( &apos; rules &apos; in low ) : DCNL DCSP DCSP DCSP low &#91; &apos; rules &apos; &#93; .extend ( rules ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP low &#91; &apos; rules &apos; &#93; = rules DCNL DCSP return low
DCSP op = _ xsym &#91; sym &#93; DCNL DCSP if _ use _ unicode : DCNL DCSP DCSP return op &#91; 1 &#93; DCNL DCSP else : DCNL DCSP DCSP return op &#91; 0 &#93;
DCSP if ( not required ) : DCNL DCSP DCSP return ( divisions , parts ) DCNL DCSP for i in required : DCNL DCSP DCSP present = &#91; j for ( j , p ) in enumerate ( parts ) if ( p &#91; i &#93; is not None ) &#93; DCNL DCSP DCSP divisions = tuple ( divisions &#91; min ( present ) : ( max ( present ) + 2 ) &#93; ) DCNL DCSP DCSP parts = tuple ( parts &#91; min ( present ) : ( max ( present ) + 1 ) &#93; ) DCNL DCSP return ( divisions , parts )
DCSP OSFUser = apps.get _ model ( &apos; osf.OSFUser &apos; ) DCNL DCSP removed = &#91; &#93; DCNL DCSP subbed = &#91; &#93; DCNL DCSP for user _ id in user _ ids : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP user = OSFUser.load ( user _ id ) DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP user = user _ id DCNL DCSP DCSP if node.has _ permission ( user , &apos; read &apos; ) : DCNL DCSP DCSP DCSP subbed.append ( user _ id ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP removed.append ( user _ id ) DCNL DCSP return ( subbed , removed )
DCSP with open ( path , &apos; rb &apos; ) as archive : DCNL DCSP DCSP sha = sha256 ( ) DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP data = archive.read ( ( 2 * * 20 ) ) DCNL DCSP DCSP DCSP if ( not data ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP sha.update ( data ) DCNL DCSP return encoded _ hash ( sha )
DCSP return { u &apos;updating _ db &apos; : 0 }
DCSP output = StringIO ( ) DCNL DCSP recorder = Record ( file _ object = output , replay = False ) DCNL DCSP num _ lines = 10 DCNL DCSP for i in xrange ( num _ lines ) : DCNL DCSP DCSP recorder.handle _ line ( ( str ( i ) + &apos; \ n &apos; ) ) DCNL DCSP output _ value = output.getvalue ( ) DCNL DCSP assert ( output _ value = = &apos; &apos;.join ( ( ( str ( i ) + &apos; \ n &apos; ) for i in xrange ( num _ lines ) ) ) ) DCNL DCSP output = StringIO ( output _ value ) DCNL DCSP playback _ checker = Record ( file _ object = output , replay = True ) DCNL DCSP for i in xrange ( num _ lines ) : DCNL DCSP DCSP playback _ checker.handle _ line ( ( str ( i ) + &apos; \ n &apos; ) )
DCSP core _ prefix = &apos; com.cloudbees.jenkins.plugins.okidocki. &apos; DCNL DCSP entry _ xml = XML.SubElement ( xml _ parent , ( core _ prefix + &apos; DockerBuildWrapper &apos; ) ) DCNL DCSP entry _ xml.set ( &apos; plugin &apos; , &apos; docker-custom-build-environment &apos; ) DCNL DCSP selectorobj = XML.SubElement ( entry _ xml , &apos; selector &apos; ) DCNL DCSP image _ type = data &#91; &apos; image-type &apos; &#93; DCNL DCSP if ( image _ type = = &apos; dockerfile &apos; ) : DCNL DCSP DCSP selectorobj.set ( &apos; class &apos; , ( core _ prefix + &apos; DockerfileImageSelector &apos; ) ) DCNL DCSP DCSP XML.SubElement ( selectorobj , &apos; contextPath &apos; ) .text = data.get ( &apos; context-path &apos; , &apos; .&apos; ) DCNL DCSP DCSP XML.SubElement ( selectorobj , &apos; dockerfile &apos; ) .text = data.get ( &apos; dockerfile &apos; , &apos; Dockerfile &apos; ) DCNL DCSP elif ( image _ type = = &apos; pull &apos; ) : DCNL DCSP DCSP selectorobj.set ( &apos; class &apos; , ( core _ prefix + &apos; PullDockerImageSelector &apos; ) ) DCNL DCSP DCSP XML.SubElement ( selectorobj , &apos; image &apos; ) .text = data.get ( &apos; image &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; dockerInstallation &apos; ) .text = data.get ( &apos; docker-tool &apos; , &apos; Default &apos; ) DCNL DCSP host = XML.SubElement ( entry _ xml , &apos; dockerHost &apos; ) DCNL DCSP host.set ( &apos; plugin &apos; , &apos; docker-commons &apos; ) DCNL DCSP if data.get ( &apos; host &apos; ) : DCNL DCSP DCSP XML.SubElement ( host , &apos; uri &apos; ) .text = data &#91; &apos; host &apos; &#93; DCNL DCSP if data.get ( &apos; credentials-id &apos; ) : DCNL DCSP DCSP XML.SubElement ( host , &apos; credentialsId &apos; ) .text = data &#91; &apos; credentials-id &apos; &#93; DCNL DCSP XML.SubElement ( entry _ xml , &apos; dockerRegistryCredentials &apos; ) .text = data.get ( &apos; registry-credentials-id &apos; , &apos; &apos; ) DCNL DCSP volumesobj = XML.SubElement ( entry _ xml , &apos; volumes &apos; ) DCNL DCSP volumes = data.get ( &apos; volumes &apos; , &#91; &#93; ) DCNL DCSP if ( not volumes ) : DCNL DCSP DCSP volumesobj.set ( &apos; class &apos; , &apos; empty-list &apos; ) DCNL DCSP else : DCNL DCSP DCSP for volume in volumes : DCNL DCSP DCSP DCSP volumeobj = XML.SubElement ( volumesobj , &apos; com.cloudbees.jenkins.plugins.okidocki.Volume &apos; ) DCNL DCSP DCSP DCSP XML.SubElement ( volumeobj , &apos; hostPath &apos; ) .text = volume &#91; &apos; volume &apos; &#93; .get ( &apos; host-path &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP XML.SubElement ( volumeobj , &apos; path &apos; ) .text = volume &#91; &apos; volume &apos; &#93; .get ( &apos; path &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; forcePull &apos; ) .text = str ( data.get ( &apos; force-pull &apos; , False ) ) .lower ( ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; privileged &apos; ) .text = str ( data.get ( &apos; privileged &apos; , False ) ) .lower ( ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; verbose &apos; ) .text = str ( data.get ( &apos; verbose &apos; , False ) ) .lower ( ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; group &apos; ) .text = data.get ( &apos; group &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; command &apos; ) .text = data.get ( &apos; command &apos; , &apos; / bin / cat &apos; ) DCNL DCSP XML.SubElement ( entry _ xml , &apos; net &apos; ) .text = data.get ( &apos; net &apos; , &apos; bridge &apos; )
DCSP return int ( ( t * 1000000.0 ) )
DCSP c = OpenSSL.crypto DCNL DCSP pem = password DCNL DCSP cert = OpenSSL.crypto.load _ certificate ( OpenSSL.crypto.FILETYPE _ PEM , pem ) DCNL DCSP cacert _ file = _ _ salt _ _ &#91; &apos; config.get &apos; &#93; ( &apos; external _ auth : pki : ca _ file &apos; ) DCNL DCSP with salt.utils.fopen ( cacert _ file ) as f : DCNL DCSP DCSP cacert = OpenSSL.crypto.load _ certificate ( OpenSSL.crypto.FILETYPE _ PEM , f.read ( ) ) DCNL DCSP log.debug ( &apos; Attempting DCSP to DCSP authenticate DCSP via DCSP pki . &apos; ) DCNL DCSP log.debug ( &apos; Using DCSP CA DCSP file : DCSP { 0 } &apos; .format ( cacert _ file ) ) DCNL DCSP log.debug ( &apos; Certificate DCSP contents : DCSP { 0 } &apos; .format ( pem ) ) DCNL DCSP algo = cert.get _ signature _ algorithm ( ) DCNL DCSP cert _ asn1 = c.dump _ certificate ( c.FILETYPE _ ASN1 , cert ) DCNL DCSP der = asn1.DerSequence ( ) DCNL DCSP der.decode ( cert _ asn1 ) DCNL DCSP der _ cert = der &#91; 0 &#93; DCNL DCSP der _ sig = der &#91; 2 &#93; DCNL DCSP der _ sig _ in = asn1.DerObject ( ) DCNL DCSP der _ sig _ in.decode ( der _ sig ) DCNL DCSP sig0 = der _ sig _ in.payload DCNL DCSP if ( sig0 &#91; 0 &#93; ! = &apos; \ x00 &apos; ) : DCNL DCSP DCSP raise Exception ( &apos; Number DCSP of DCSP unused DCSP bits DCSP is DCSP strange &apos; ) DCNL DCSP sig = sig0 &#91; 1 : &#93; DCNL DCSP try : DCNL DCSP DCSP c.verify ( cacert , sig , der _ cert , algo ) DCNL DCSP DCSP assert ( dict ( cert.get _ subject ( ) .get _ components ( ) ) &#91; &apos; CN &apos; &#93; = = username ) , &quot; Certificate &apos;s DCSP CN DCSP should DCSP match DCSP the DCSP username &quot; DCNL DCSP DCSP log.info ( &apos; Successfully DCSP authenticated DCSP certificate : DCSP { 0 } &apos; .format ( pem ) ) DCNL DCSP DCSP return True DCNL DCSP except ( OpenSSL.crypto.Error , AssertionError ) : DCNL DCSP DCSP log.info ( &apos; Failed DCSP to DCSP authenticate DCSP certificate : DCSP { 0 } &apos; .format ( pem ) ) DCNL DCSP return False
DCSP return ItemsIterator ( items = itertools.imap ( function , items ) , total _ count = items.total _ count )
DCSP if ( ( ( rev1 is None ) and ( rev2 is not None ) ) or ( ( rev2 is None ) and ( rev1 is not None ) ) ) : DCNL DCSP DCSP return False DCNL DCSP elif ( rev1 is rev2 is None ) : DCNL DCSP DCSP return True DCNL DCSP elif ( rev _ type = = &apos; sha1 &apos; ) : DCNL DCSP DCSP return rev1.startswith ( rev2 ) DCNL DCSP else : DCNL DCSP DCSP return ( rev1 = = rev2 )
DCSP if _ _ opts _ _ &#91; &apos; load _ balancers &apos; &#93; .get ( lb , None ) : DCNL DCSP DCSP ( username , password ) = list ( _ _ opts _ _ &#91; &apos; load _ balancers &apos; &#93; &#91; lb &#93; .values ( ) ) DCNL DCSP else : DCNL DCSP DCSP raise Exception ( &apos; Unable DCSP to DCSP find DCSP ` { 0 } ` DCSP load DCSP balancer &apos; .format ( lb ) ) DCNL DCSP F5 = F5Mgmt ( lb , username , password ) DCNL DCSP return F5.check _ virtualserver ( name )
DCSP ( curr , max _ ) = cext.cpu _ freq ( ) DCNL DCSP min _ = 0.0 DCNL DCSP return &#91; _ common.scpufreq ( float ( curr ) , min _ , float ( max _ ) ) &#93;
DCSP content _ type = ContentType.objects.get _ for _ model ( model ) DCNL DCSP ( permission , created ) = Permission.objects.get _ or _ create ( codename = permission _ codename , content _ type = content _ type , defaults = { &apos; name &apos; : permission _ codename } ) DCNL DCSP user.user _ permissions.add ( permission )
DCSP mappings = &#91; ( &apos; push-merge &apos; , &apos; pushMerge &apos; , False ) , ( &apos; push-only-if-success &apos; , &apos; pushOnlyIfSuccess &apos; , True ) , ( &apos; force-push &apos; , &apos; forcePush &apos; , False ) &#93; DCNL DCSP tag _ mappings = &#91; ( &apos; remote &apos; , &apos; targetRepoName &apos; , &apos; origin &apos; ) , ( &apos; name &apos; , &apos; tagName &apos; , None ) , ( &apos; message &apos; , &apos; tagMessage &apos; , &apos; &apos; ) , ( &apos; create-tag &apos; , &apos; createTag &apos; , False ) , ( &apos; update-tag &apos; , &apos; updateTag &apos; , False ) &#93; DCNL DCSP branch _ mappings = &#91; ( &apos; remote &apos; , &apos; targetRepoName &apos; , &apos; origin &apos; ) , ( &apos; name &apos; , &apos; branchName &apos; , None ) &#93; DCNL DCSP note _ mappings = &#91; ( &apos; remote &apos; , &apos; targetRepoName &apos; , &apos; origin &apos; ) , ( &apos; message &apos; , &apos; noteMsg &apos; , None ) , ( &apos; namespace &apos; , &apos; noteNamespace &apos; , &apos; master &apos; ) , ( &apos; replace-note &apos; , &apos; noteReplace &apos; , False ) &#93; DCNL DCSP top = XML.SubElement ( xml _ parent , &apos; hudson.plugins.git.GitPublisher &apos; ) DCNL DCSP XML.SubElement ( top , &apos; configVersion &apos; ) .text = &apos; 2&apos; DCNL DCSP helpers.convert _ mapping _ to _ xml ( top , data , mappings , fail _ required = True ) DCNL DCSP tags = data.get ( &apos; tags &apos; , &#91; &#93; ) DCNL DCSP if tags : DCNL DCSP DCSP xml _ tags = XML.SubElement ( top , &apos; tagsToPush &apos; ) DCNL DCSP DCSP for tag in tags : DCNL DCSP DCSP DCSP xml _ tag = XML.SubElement ( xml _ tags , &apos; hudson.plugins.git.GitPublisher _ -TagToPush &apos; ) DCNL DCSP DCSP DCSP helpers.convert _ mapping _ to _ xml ( xml _ tag , tag &#91; &apos; tag &apos; &#93; , tag _ mappings , fail _ required = True ) DCNL DCSP branches = data.get ( &apos; branches &apos; , &#91; &#93; ) DCNL DCSP if branches : DCNL DCSP DCSP xml _ branches = XML.SubElement ( top , &apos; branchesToPush &apos; ) DCNL DCSP DCSP for branch in branches : DCNL DCSP DCSP DCSP xml _ branch = XML.SubElement ( xml _ branches , &apos; hudson.plugins.git.GitPublisher _ -BranchToPush &apos; ) DCNL DCSP DCSP DCSP helpers.convert _ mapping _ to _ xml ( xml _ branch , branch &#91; &apos; branch &apos; &#93; , branch _ mappings , fail _ required = True ) DCNL DCSP notes = data.get ( &apos; notes &apos; , &#91; &#93; ) DCNL DCSP if notes : DCNL DCSP DCSP xml _ notes = XML.SubElement ( top , &apos; notesToPush &apos; ) DCNL DCSP DCSP for note in notes : DCNL DCSP DCSP DCSP xml _ note = XML.SubElement ( xml _ notes , &apos; hudson.plugins.git.GitPublisher _ -NoteToPush &apos; ) DCNL DCSP DCSP DCSP helpers.convert _ mapping _ to _ xml ( xml _ note , note &#91; &apos; note &apos; &#93; , note _ mappings , fail _ required = True )
DCSP def decorator ( func ) : DCNL DCSP DCSP def resetter _ attr ( saved _ value _ internal ) : DCNL DCSP DCSP DCSP return setattr ( namespace , name , saved _ value _ internal ) DCNL DCSP DCSP def resetter _ no _ attr ( saved _ value _ internal ) : DCNL DCSP DCSP DCSP del saved _ value _ internal DCNL DCSP DCSP DCSP return delattr ( namespace , name ) DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP saved _ value = None DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP saved _ value = getattr ( namespace , name ) DCNL DCSP DCSP DCSP DCSP resetter = resetter _ attr DCNL DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP resetter = resetter _ no _ attr DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return func ( * args , * * kwargs ) DCNL DCSP DCSP DCSP finally : DCNL DCSP DCSP DCSP DCSP resetter ( saved _ value ) DCNL DCSP DCSP wrapper . _ _ name _ _ = func . _ _ name _ _ DCNL DCSP DCSP wrapper . _ _ doc _ _ = func . _ _ doc _ _ DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP if ( obj is None ) : DCNL DCSP DCSP return None DCNL DCSP if hasattr ( obj , &apos; _ _ marshallable _ _ &apos; ) : DCNL DCSP DCSP return obj . _ _ marshallable _ _ ( ) DCNL DCSP if hasattr ( obj , &apos; _ _ getitem _ _ &apos; ) : DCNL DCSP DCSP return obj DCNL DCSP return dict ( obj . _ _ dict _ _ )
DCSP ( h , w ) = ( x.shape &#91; row _ axis &#93; , x.shape &#91; col _ axis &#93; ) DCNL DCSP tx = ( np.random.uniform ( ( - hrg ) , hrg ) * h ) DCNL DCSP ty = ( np.random.uniform ( ( - wrg ) , wrg ) * w ) DCNL DCSP translation _ matrix = np.array ( &#91; &#91; 1 , 0 , tx &#93; , &#91; 0 , 1 , ty &#93; , &#91; 0 , 0 , 1 &#93; &#93; ) DCNL DCSP transform _ matrix = translation _ matrix DCNL DCSP x = apply _ transform ( x , transform _ matrix , channel _ axis , fill _ mode , cval ) DCNL DCSP return x
DCSP if repository : DCNL DCSP DCSP selected _ type = str ( repository.type ) DCNL DCSP else : DCNL DCSP DCSP selected _ type = None DCNL DCSP repository _ type _ select _ field = SelectField ( name = name ) DCNL DCSP for ( type _ label , type _ class ) in trans.app.repository _ types _ registry.repository _ types _ by _ label.items ( ) : DCNL DCSP DCSP option _ label = str ( type _ class.label ) DCNL DCSP DCSP option _ value = str ( type _ class.type ) DCNL DCSP DCSP if ( selected _ type and ( selected _ type = = option _ value ) ) : DCNL DCSP DCSP DCSP selected = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP selected = False DCNL DCSP DCSP if repository : DCNL DCSP DCSP DCSP if ( repository.type = = option _ value ) : DCNL DCSP DCSP DCSP DCSP repository _ type _ select _ field.add _ option ( option _ label , option _ value , selected = selected ) DCNL DCSP DCSP DCSP elif type _ class.is _ valid _ for _ type ( trans.app , repository ) : DCNL DCSP DCSP DCSP DCSP repository _ type _ select _ field.add _ option ( option _ label , option _ value , selected = selected ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP repository _ type _ select _ field.add _ option ( option _ label , option _ value , selected = selected ) DCNL DCSP return repository _ type _ select _ field
DCSP d = { } DCNL DCSP for ( idx , col ) in enumerate ( cursor.description ) : DCNL DCSP DCSP d &#91; col &#91; 0 &#93; &#93; = row &#91; idx &#93; DCNL DCSP return d
DCSP LOG.debug ( &apos; Attempting DCSP to DCSP map DCSP volume DCSP % s DCSP to DCSP single DCSP host . &apos; , volume &#91; &apos; id &apos; &#93; ) DCNL DCSP if ( not vol _ map ) : DCNL DCSP DCSP mappings = client.get _ volume _ mappings _ for _ host ( host &#91; &apos; hostRef &apos; &#93; ) DCNL DCSP DCSP lun = _ get _ free _ lun ( client , host , multiattach _ enabled , mappings ) DCNL DCSP DCSP return client.create _ volume _ mapping ( eseries _ vol &#91; &apos; volumeRef &apos; &#93; , host &#91; &apos; hostRef &apos; &#93; , lun ) DCNL DCSP if ( vol _ map.get ( &apos; mapRef &apos; ) = = host &#91; &apos; hostRef &apos; &#93; ) : DCNL DCSP DCSP return vol _ map DCNL DCSP multiattach _ cluster _ ref = None DCNL DCSP try : DCNL DCSP DCSP host _ group = client.get _ host _ group _ by _ name ( utils.MULTI _ ATTACH _ HOST _ GROUP _ NAME ) DCNL DCSP DCSP multiattach _ cluster _ ref = host _ group &#91; &apos; clusterRef &apos; &#93; DCNL DCSP except exception.NotFound : DCNL DCSP DCSP pass DCNL DCSP if ( vol _ map.get ( &apos; mapRef &apos; ) = = multiattach _ cluster _ ref ) : DCNL DCSP DCSP LOG.debug ( &apos; Volume DCSP % s DCSP is DCSP mapped DCSP to DCSP multiattach DCSP host DCSP group . &apos; , volume &#91; &apos; id &apos; &#93; ) DCNL DCSP DCSP if ( not ( volume &#91; &apos; attach _ status &apos; &#93; = = fields.VolumeAttachStatus.ATTACHED ) ) : DCNL DCSP DCSP DCSP LOG.debug ( &apos; Volume DCSP % ( vol ) s DCSP is DCSP not DCSP currently DCSP attached , DCSP moving DCSP existing DCSP mapping DCSP to DCSP host DCSP % ( host ) s . &apos; , { &apos; vol &apos; : volume &#91; &apos; id &apos; &#93; , &apos; host &apos; : host &#91; &apos; label &apos; &#93; } ) DCNL DCSP DCSP DCSP mappings = client.get _ volume _ mappings _ for _ host ( host &#91; &apos; hostRef &apos; &#93; ) DCNL DCSP DCSP DCSP lun = _ get _ free _ lun ( client , host , multiattach _ enabled , mappings ) DCNL DCSP DCSP DCSP return client.move _ volume _ mapping _ via _ symbol ( vol _ map.get ( &apos; mapRef &apos; ) , host &#91; &apos; hostRef &apos; &#93; , lun ) DCNL DCSP msg = _ ( &quot; Cannot DCSP attach DCSP already DCSP attached DCSP volume DCSP % s ; DCSP multiattach DCSP is DCSP disabled DCSP via DCSP the DCSP &apos; netapp _ enable _ multiattach &apos; DCSP configuration DCSP option . &quot; ) DCNL DCSP raise exception.NetAppDriverException ( ( msg % volume &#91; &apos; id &apos; &#93; ) )
DCSP deps = { &apos; netaddr &apos; : HAS _ NETADDR , &apos; python-novaclient &apos; : nova.check _ nova ( ) } DCNL DCSP return config.check _ driver _ dependencies ( _ _ virtualname _ _ , deps )
DCSP remote _ save _ sent ( crispin _ client , account _ id , message _ id )
DCSP ( n , x ) = ( asarray ( n ) , asarray ( x ) ) DCNL DCSP fac2 = ( ( ( ( -1.0 ) * * ( n + 1 ) ) * gamma ( ( n + 1.0 ) ) ) * zeta ( ( n + 1 ) , x ) ) DCNL DCSP return where ( ( n = = 0 ) , psi ( x ) , fac2 )
DCSP try : DCNL DCSP DCSP return minidom.parseString ( xml _ string , parser = ProtectedExpatParser ( ) ) DCNL DCSP except sax.SAXParseException as se : DCNL DCSP DCSP raise expat.ExpatError ( )
DCSP if ( isinstance ( x , np.ndarray ) and ( x.ndim = = 2 ) ) : DCNL DCSP DCSP x = x.T DCNL DCSP nvars _ orig = len ( x ) DCNL DCSP nobs = len ( x &#91; 0 &#93; ) DCNL DCSP if ( not dtype ) : DCNL DCSP DCSP dtype = np.asarray ( x &#91; 0 &#93; ) .dtype DCNL DCSP xout = np.zeros ( ( nobs , nvars _ orig ) , dtype = dtype ) DCNL DCSP count = 0 DCNL DCSP rank _ old = 0 DCNL DCSP varnames _ new = &#91; &#93; DCNL DCSP varnames _ dropped = &#91; &#93; DCNL DCSP keepindx = &#91; &#93; DCNL DCSP for ( xi , ni ) in zip ( x , varnames ) : DCNL DCSP DCSP xout &#91; : , count &#93; = xi DCNL DCSP DCSP rank _ new = np _ matrix _ rank ( xout ) DCNL DCSP DCSP if ( rank _ new &gt; rank _ old ) : DCNL DCSP DCSP DCSP varnames _ new.append ( ni ) DCNL DCSP DCSP DCSP rank _ old = rank _ new DCNL DCSP DCSP DCSP count + = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP varnames _ dropped.append ( ni ) DCNL DCSP return ( xout &#91; : , : count &#93; , varnames _ new )
DCSP dialog = QtWidgets.QDialog ( active _ window ( ) ) DCNL DCSP dialog.setWindowModality ( Qt.WindowModal ) DCNL DCSP dialog.setWindowTitle ( msg ) DCNL DCSP long _ value = msg DCNL DCSP for ( k , v ) in inputs : DCNL DCSP DCSP if ( len ( ( k + v ) ) &gt; len ( long _ value ) ) : DCNL DCSP DCSP DCSP long _ value = ( k + v ) DCNL DCSP metrics = QtGui.QFontMetrics ( dialog.font ( ) ) DCNL DCSP min _ width = ( metrics.width ( long _ value ) + 100 ) DCNL DCSP if ( min _ width &gt; 720 ) : DCNL DCSP DCSP min _ width = 720 DCNL DCSP dialog.setMinimumWidth ( min _ width ) DCNL DCSP ok _ b = ok _ button ( msg , enabled = False ) DCNL DCSP close _ b = close _ button ( ) DCNL DCSP form _ widgets = &#91; &#93; DCNL DCSP def get _ values ( ) : DCNL DCSP DCSP return &#91; pair &#91; 1 &#93; .text ( ) .strip ( ) for pair in form _ widgets &#93; DCNL DCSP for ( name , value ) in inputs : DCNL DCSP DCSP lineedit = QtWidgets.QLineEdit ( ) DCNL DCSP DCSP lineedit.textChanged.connect ( ( lambda x : ok _ b.setEnabled ( all ( get _ values ( ) ) ) ) ) DCNL DCSP DCSP if value : DCNL DCSP DCSP DCSP lineedit.setText ( value ) DCNL DCSP DCSP form _ widgets.append ( ( name , lineedit ) ) DCNL DCSP form _ layout = form ( defs.no _ margin , defs.button _ spacing , * form _ widgets ) DCNL DCSP button _ layout = hbox ( defs.no _ margin , defs.button _ spacing , STRETCH , close _ b , ok _ b ) DCNL DCSP main _ layout = vbox ( defs.margin , defs.button _ spacing , form _ layout , button _ layout ) DCNL DCSP dialog.setLayout ( main _ layout ) DCNL DCSP connect _ button ( ok _ b , dialog.accept ) DCNL DCSP connect _ button ( close _ b , dialog.reject ) DCNL DCSP accepted = ( dialog.exec _ ( ) = = QtWidgets.QDialog.Accepted ) DCNL DCSP text = get _ values ( ) DCNL DCSP ok = ( accepted and all ( text ) ) DCNL DCSP return ( ok , text )
DCSP if NORUN : DCNL DCSP DCSP return DCNL DCSP if ( reloader and ( not os.environ.get ( &apos; BOTTLE _ CHILD &apos; ) ) ) : DCNL DCSP DCSP import subprocess DCNL DCSP DCSP lockfile = None DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( fd , lockfile ) = tempfile.mkstemp ( prefix = &apos; bottle . &apos; , suffix = &apos; .lock &apos; ) DCNL DCSP DCSP DCSP os.close ( fd ) DCNL DCSP DCSP DCSP while os.path.exists ( lockfile ) : DCNL DCSP DCSP DCSP DCSP args = ( &#91; sys.executable &#93; + sys.argv ) DCNL DCSP DCSP DCSP DCSP environ = os.environ.copy ( ) DCNL DCSP DCSP DCSP DCSP environ &#91; &apos; BOTTLE _ CHILD &apos; &#93; = &apos; true &apos; DCNL DCSP DCSP DCSP DCSP environ &#91; &apos; BOTTLE _ LOCKFILE &apos; &#93; = lockfile DCNL DCSP DCSP DCSP DCSP p = subprocess.Popen ( args , env = environ ) DCNL DCSP DCSP DCSP DCSP while ( p.poll ( ) is None ) : DCNL DCSP DCSP DCSP DCSP DCSP os.utime ( lockfile , None ) DCNL DCSP DCSP DCSP DCSP DCSP time.sleep ( interval ) DCNL DCSP DCSP DCSP DCSP if ( p.poll ( ) ! = 3 ) : DCNL DCSP DCSP DCSP DCSP DCSP if os.path.exists ( lockfile ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP os.unlink ( lockfile ) DCNL DCSP DCSP DCSP DCSP DCSP sys.exit ( p.poll ( ) ) DCNL DCSP DCSP except KeyboardInterrupt : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP if os.path.exists ( lockfile ) : DCNL DCSP DCSP DCSP DCSP os.unlink ( lockfile ) DCNL DCSP DCSP return DCNL DCSP try : DCNL DCSP DCSP if ( debug is not None ) : DCNL DCSP DCSP DCSP _ debug ( debug ) DCNL DCSP DCSP app = ( app or default _ app ( ) ) DCNL DCSP DCSP if isinstance ( app , basestring ) : DCNL DCSP DCSP DCSP app = load _ app ( app ) DCNL DCSP DCSP if ( not callable ( app ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Application DCSP is DCSP not DCSP callable : DCSP % r &apos; % app ) ) DCNL DCSP DCSP for plugin in ( plugins or &#91; &#93; ) : DCNL DCSP DCSP DCSP if isinstance ( plugin , basestring ) : DCNL DCSP DCSP DCSP DCSP plugin = load ( plugin ) DCNL DCSP DCSP DCSP app.install ( plugin ) DCNL DCSP DCSP if config : DCNL DCSP DCSP DCSP app.config.update ( config ) DCNL DCSP DCSP if ( server in server _ names ) : DCNL DCSP DCSP DCSP server = server _ names.get ( server ) DCNL DCSP DCSP if isinstance ( server , basestring ) : DCNL DCSP DCSP DCSP server = load ( server ) DCNL DCSP DCSP if isinstance ( server , type ) : DCNL DCSP DCSP DCSP server = server ( host = host , port = port , * * kargs ) DCNL DCSP DCSP if ( not isinstance ( server , ServerAdapter ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP or DCSP unsupported DCSP server : DCSP % r &apos; % server ) ) DCNL DCSP DCSP server.quiet = ( server.quiet or quiet ) DCNL DCSP DCSP if ( not server.quiet ) : DCNL DCSP DCSP DCSP _ stderr ( ( &apos; Bottle DCSP v % s DCSP server DCSP starting DCSP up DCSP ( using DCSP % s ) ... \ n &apos; % ( _ _ version _ _ , repr ( server ) ) ) ) DCNL DCSP DCSP DCSP _ stderr ( ( &apos; Listening DCSP on DCSP http : / / % s : % d / \ n &apos; % ( server.host , server.port ) ) ) DCNL DCSP DCSP DCSP _ stderr ( &apos; Hit DCSP Ctrl-C DCSP to DCSP quit . \ n \ n &apos; ) DCNL DCSP DCSP if reloader : DCNL DCSP DCSP DCSP lockfile = os.environ.get ( &apos; BOTTLE _ LOCKFILE &apos; ) DCNL DCSP DCSP DCSP bgcheck = FileCheckerThread ( lockfile , interval ) DCNL DCSP DCSP DCSP with bgcheck : DCNL DCSP DCSP DCSP DCSP server.run ( app ) DCNL DCSP DCSP DCSP if ( bgcheck.status = = &apos; reload &apos; ) : DCNL DCSP DCSP DCSP DCSP sys.exit ( 3 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP server.run ( app ) DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP pass DCNL DCSP except ( SystemExit , MemoryError ) : DCNL DCSP DCSP raise DCNL DCSP except : DCNL DCSP DCSP if ( not reloader ) : DCNL DCSP DCSP DCSP raise DCNL DCSP DCSP if ( not getattr ( server , &apos; quiet &apos; , quiet ) ) : DCNL DCSP DCSP DCSP print _ exc ( ) DCNL DCSP DCSP time.sleep ( interval ) DCNL DCSP DCSP sys.exit ( 3 )
DCSP def check _ match ( cls , exception ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return ( isinstance ( cls , CompiledObject ) and issubclass ( exception , cls.obj ) ) DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP return False DCNL DCSP def check _ try _ for _ except ( obj , exception ) : DCNL DCSP DCSP iterator = iter ( obj.children ) DCNL DCSP DCSP for branch _ type in iterator : DCNL DCSP DCSP DCSP colon = next ( iterator ) DCNL DCSP DCSP DCSP suite = next ( iterator ) DCNL DCSP DCSP DCSP if ( ( branch _ type = = &apos; try &apos; ) and ( not ( branch _ type.start _ pos &lt; jedi _ obj.start _ pos &lt; = suite.end _ pos ) ) ) : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP for node in obj.except _ clauses ( ) : DCNL DCSP DCSP DCSP if ( node is None ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP except _ classes = evaluator.eval _ element ( node ) DCNL DCSP DCSP DCSP DCSP for cls in except _ classes : DCNL DCSP DCSP DCSP DCSP DCSP from jedi.evaluate import iterable DCNL DCSP DCSP DCSP DCSP DCSP if ( isinstance ( cls , iterable.Array ) and ( cls.type = = &apos; tuple &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for typ in unite ( cls.py _ _ iter _ _ ( ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if check _ match ( typ , exception ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP DCSP DCSP elif check _ match ( cls , exception ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return True DCNL DCSP def check _ hasattr ( node , suite ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP assert ( suite.start _ pos &lt; = jedi _ obj.start _ pos &lt; suite.end _ pos ) DCNL DCSP DCSP DCSP assert ( node.type in ( &apos; power &apos; , &apos; atom _ expr &apos; ) ) DCNL DCSP DCSP DCSP base = node.children &#91; 0 &#93; DCNL DCSP DCSP DCSP assert ( ( base.type = = &apos; name &apos; ) and ( base.value = = &apos; hasattr &apos; ) ) DCNL DCSP DCSP DCSP trailer = node.children &#91; 1 &#93; DCNL DCSP DCSP DCSP assert ( trailer.type = = &apos; trailer &apos; ) DCNL DCSP DCSP DCSP arglist = trailer.children &#91; 1 &#93; DCNL DCSP DCSP DCSP assert ( arglist.type = = &apos; arglist &apos; ) DCNL DCSP DCSP DCSP from jedi.evaluate.param import Arguments DCNL DCSP DCSP DCSP args = list ( Arguments ( evaluator , arglist ) .unpack ( ) ) DCNL DCSP DCSP DCSP assert ( len ( args ) = = 2 ) DCNL DCSP DCSP DCSP ( key , values ) = args &#91; 1 &#93; DCNL DCSP DCSP DCSP assert ( len ( values ) = = 1 ) DCNL DCSP DCSP DCSP names = list ( evaluator.eval _ element ( values &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP assert ( ( len ( names ) = = 1 ) and isinstance ( names &#91; 0 &#93; , CompiledObject ) ) DCNL DCSP DCSP DCSP assert ( names &#91; 0 &#93; .obj = = str ( payload &#91; 1 &#93; ) ) DCNL DCSP DCSP DCSP ( key , values ) = args &#91; 0 &#93; DCNL DCSP DCSP DCSP assert ( len ( values ) = = 1 ) DCNL DCSP DCSP DCSP objects = evaluator.eval _ element ( values &#91; 0 &#93; ) DCNL DCSP DCSP DCSP return ( payload &#91; 0 &#93; in objects ) DCNL DCSP DCSP except AssertionError : DCNL DCSP DCSP DCSP return False DCNL DCSP obj = jedi _ obj DCNL DCSP while ( ( obj is not None ) and ( not obj.isinstance ( tree.Function , tree.Class ) ) ) : DCNL DCSP DCSP if obj.isinstance ( tree.Flow ) : DCNL DCSP DCSP DCSP if ( obj.isinstance ( tree.TryStmt ) and check _ try _ for _ except ( obj , exception ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if ( ( exception = = AttributeError ) and obj.isinstance ( tree.IfStmt , tree.WhileStmt ) ) : DCNL DCSP DCSP DCSP DCSP if check _ hasattr ( obj.children &#91; 1 &#93; , obj.children &#91; 3 &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP obj = obj.parent DCNL DCSP return False
DCSP d = ( lambda _ * exp ( ( - ( ( individual &#91; 0 &#93; - individual &#91; 1 &#93; ) * * 2 ) ) ) ) DCNL DCSP f1 = ( ( 0.5 * ( ( ( sqrt ( ( 1 + ( ( individual &#91; 0 &#93; + individual &#91; 1 &#93; ) * * 2 ) ) ) + sqrt ( ( 1 + ( ( individual &#91; 0 &#93; - individual &#91; 1 &#93; ) * * 2 ) ) ) ) + individual &#91; 0 &#93; ) - individual &#91; 1 &#93; ) ) + d ) DCNL DCSP f2 = ( ( 0.5 * ( ( ( sqrt ( ( 1 + ( ( individual &#91; 0 &#93; + individual &#91; 1 &#93; ) * * 2 ) ) ) + sqrt ( ( 1 + ( ( individual &#91; 0 &#93; - individual &#91; 1 &#93; ) * * 2 ) ) ) ) - individual &#91; 0 &#93; ) + individual &#91; 1 &#93; ) ) + d ) DCNL DCSP return ( f1 , f2 )
DCSP return ( h / 24.0 )
DCSP key _ name = &apos; test-key-name &apos; DCNL DCSP b = B ( name = key _ name ) DCNL DCSP collect.inject ( Exception ( &apos; Normal DCSP error &apos; ) ) DCNL DCSP d = wabs _ deleter.Deleter ( BlobService ( &apos; test &apos; , &apos; ing &apos; ) , &apos; test-container &apos; ) DCNL DCSP d.delete ( b ) DCNL DCSP while ( len ( collect.aborted _ keys ) &lt; 2 ) : DCNL DCSP DCSP gevent.sleep ( 0.1 ) DCNL DCSP assert ( not collect.deleted _ keys ) DCNL DCSP collect.inject ( None ) DCNL DCSP d.close ( ) DCNL DCSP assert ( collect.deleted _ keys = = &#91; key _ name &#93; )
DCSP stateId = state.get ( &apos; id &apos; , None ) DCNL DCSP if ( stateId is None ) : DCNL DCSP DCSP raise RuntimeError ( ( &quot; factory DCSP copy DCSP state DCSP has DCSP no DCSP &apos; id &apos; DCSP member DCSP % s &quot; % ( repr ( state ) , ) ) ) DCNL DCSP if ( not ( stateId in SimpleFactoryCopy.allIDs ) ) : DCNL DCSP DCSP raise RuntimeError ( ( &apos; factory DCSP class DCSP has DCSP no DCSP ID : DCSP % s &apos; % ( SimpleFactoryCopy.allIDs , ) ) ) DCNL DCSP inst = SimpleFactoryCopy.allIDs &#91; stateId &#93; DCNL DCSP if ( not inst ) : DCNL DCSP DCSP raise RuntimeError ( &apos; factory DCSP method DCSP found DCSP no DCSP object DCSP with DCSP id &apos; ) DCNL DCSP return inst
DCSP dest _ dirname = os.path.dirname ( dest ) DCNL DCSP try : DCNL DCSP DCSP os.makedirs ( dest _ dirname ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP cmd = &#91; git _ path , &apos; clone &apos; &#93; DCNL DCSP if bare : DCNL DCSP DCSP cmd.append ( &apos; --bare &apos; ) DCNL DCSP else : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --origin &apos; , remote &#93; ) DCNL DCSP if depth : DCNL DCSP DCSP if ( ( version = = &apos; HEAD &apos; ) or refspec or is _ remote _ branch ( git _ path , module , dest , repo , version ) or is _ remote _ tag ( git _ path , module , dest , repo , version ) ) : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --depth &apos; , str ( depth ) &#93; ) DCNL DCSP if reference : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --reference &apos; , str ( reference ) &#93; ) DCNL DCSP cmd.extend ( &#91; repo , dest &#93; ) DCNL DCSP module.run _ command ( cmd , check _ rc = True , cwd = dest _ dirname ) DCNL DCSP if bare : DCNL DCSP DCSP if ( remote ! = &apos; origin &apos; ) : DCNL DCSP DCSP DCSP module.run _ command ( &#91; git _ path , &apos; remote &apos; , &apos; add &apos; , remote , repo &#93; , check _ rc = True , cwd = dest ) DCNL DCSP if refspec : DCNL DCSP DCSP cmd = &#91; git _ path , &apos; fetch &apos; &#93; DCNL DCSP DCSP if depth : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --depth &apos; , str ( depth ) &#93; ) DCNL DCSP DCSP cmd.extend ( &#91; remote , refspec &#93; ) DCNL DCSP DCSP module.run _ command ( cmd , check _ rc = True , cwd = dest ) DCNL DCSP if verify _ commit : DCNL DCSP DCSP verify _ commit _ sign ( git _ path , module , dest , version )
DCSP plain _ txt _ email = &apos; Please DCSP view DCSP in DCSP a DCSP mail DCSP client DCSP that DCSP supports DCSP HTML . &apos; DCNL DCSP if app.config.get ( &apos; EMAILS _ USE _ SMTP &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with app.app _ context ( ) : DCNL DCSP DCSP DCSP DCSP msg = Message ( subject , recipients = recipients ) DCNL DCSP DCSP DCSP DCSP msg.body = plain _ txt _ email DCNL DCSP DCSP DCSP DCSP msg.html = html DCNL DCSP DCSP DCSP DCSP mail.send ( msg ) DCNL DCSP DCSP DCSP app.logger.debug ( &apos; Emailed DCSP { } DCSP - DCSP { } DCSP &apos; .format ( recipients , subject ) ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP m = &apos; Failed DCSP to DCSP send DCSP failure DCSP message DCSP with DCSP subject : DCSP { } \ n { } DCSP { } &apos; .format ( subject , Exception , e ) DCNL DCSP DCSP DCSP app.logger.warn ( m ) DCNL DCSP DCSP DCSP app.logger.warn ( traceback.format _ exc ( ) ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ses _ region = app.config.get ( &apos; SES _ REGION &apos; , &apos; us-east-1 &apos; ) DCNL DCSP DCSP DCSP ses = boto.ses.connect _ to _ region ( ses _ region ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP m = &apos; Failed DCSP to DCSP connect DCSP to DCSP ses DCSP using DCSP boto . DCSP Check DCSP your DCSP boto DCSP credentials . DCSP { } DCSP { } &apos; .format ( Exception , e ) DCNL DCSP DCSP DCSP app.logger.warn ( m ) DCNL DCSP DCSP DCSP app.logger.warn ( traceback.format _ exc ( ) ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP for email in recipients : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ses.send _ email ( app.config.get ( &apos; MAIL _ DEFAULT _ SENDER &apos; ) , subject , html , email , format = &apos; html &apos; ) DCNL DCSP DCSP DCSP DCSP app.logger.debug ( &apos; Emailed DCSP { } DCSP - DCSP { } DCSP &apos; .format ( email , subject ) ) DCNL DCSP DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP DCSP m = &apos; Failed DCSP to DCSP send DCSP failure DCSP message DCSP with DCSP subject : DCSP { } \ n { } DCSP { } &apos; .format ( subject , Exception , e ) DCNL DCSP DCSP DCSP DCSP app.logger.warn ( m ) DCNL DCSP DCSP DCSP DCSP app.logger.warn ( traceback.format _ exc ( ) )
DCSP data = _ get _ data ( ) DCNL DCSP return du.process _ recarray _ pandas ( data , endog _ idx = 3 , dtype = float )
DCSP db _ queue = scrubber.get _ scrub _ queue ( ) DCNL DCSP if ( not CONF.use _ user _ token ) : DCNL DCSP DCSP context = None DCNL DCSP ret = db _ queue.add _ location ( image _ id , location ) DCNL DCSP if ret : DCNL DCSP DCSP location &#91; &apos; status &apos; &#93; = &apos; pending _ delete &apos; DCNL DCSP DCSP if ( &apos; id &apos; in location ) : DCNL DCSP DCSP DCSP db _ api.get _ api ( ) .image _ location _ delete ( context , image _ id , location &#91; &apos; id &apos; &#93; , &apos; pending _ delete &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP db _ api.get _ api ( ) .image _ location _ add ( context , image _ id , location ) DCNL DCSP return ret
DCSP cache _ alias = kwargs.pop ( &apos; cache &apos; , None ) DCNL DCSP key _ prefix = kwargs.pop ( &apos; key _ prefix &apos; , None ) DCNL DCSP assert ( not kwargs ) , &apos; The DCSP only DCSP keyword DCSP arguments DCSP are DCSP cache DCSP and DCSP key _ prefix &apos; DCNL DCSP def warn ( ) : DCNL DCSP DCSP import warnings DCNL DCSP DCSP warnings.warn ( &apos; The DCSP cache _ page DCSP decorator DCSP must DCSP be DCSP called DCSP like : DCSP cache _ page ( timeout , DCSP &#91; cache = cache DCSP name &#93; , DCSP &#91; key _ prefix = key DCSP prefix &#93; ) . DCSP All DCSP other DCSP ways DCSP are DCSP deprecated . &apos; , PendingDeprecationWarning , stacklevel = 3 ) DCNL DCSP if ( len ( args ) &gt; 1 ) : DCNL DCSP DCSP assert ( len ( args ) = = 2 ) , &apos; cache _ page DCSP accepts DCSP at DCSP most DCSP 2 DCSP arguments &apos; DCNL DCSP DCSP warn ( ) DCNL DCSP DCSP if callable ( args &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP return decorator _ from _ middleware _ with _ args ( CacheMiddleware ) ( cache _ timeout = args &#91; 1 &#93; , cache _ alias = cache _ alias , key _ prefix = key _ prefix ) ( args &#91; 0 &#93; ) DCNL DCSP DCSP elif callable ( args &#91; 1 &#93; ) : DCNL DCSP DCSP DCSP return decorator _ from _ middleware _ with _ args ( CacheMiddleware ) ( cache _ timeout = args &#91; 0 &#93; , cache _ alias = cache _ alias , key _ prefix = key _ prefix ) ( args &#91; 1 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP assert False , &apos; cache _ page DCSP must DCSP be DCSP passed DCSP a DCSP view DCSP function DCSP if DCSP called DCSP with DCSP two DCSP arguments &apos; DCNL DCSP elif ( len ( args ) = = 1 ) : DCNL DCSP DCSP if callable ( args &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP warn ( ) DCNL DCSP DCSP DCSP return decorator _ from _ middleware _ with _ args ( CacheMiddleware ) ( cache _ alias = cache _ alias , key _ prefix = key _ prefix ) ( args &#91; 0 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return decorator _ from _ middleware _ with _ args ( CacheMiddleware ) ( cache _ timeout = args &#91; 0 &#93; , cache _ alias = cache _ alias , key _ prefix = key _ prefix ) DCNL DCSP else : DCNL DCSP DCSP warn ( ) DCNL DCSP DCSP return decorator _ from _ middleware _ with _ args ( CacheMiddleware ) ( cache _ alias = cache _ alias , key _ prefix = key _ prefix )
DCSP if ( not msg.startswith ( &apos; nonlocal DCSP image DCSP URI DCSP found : &apos; ) ) : DCNL DCSP DCSP self . _ warnfunc ( msg , ( &apos; % s : % s &apos; % get _ source _ line ( node ) ) , * args , * * kwargs )
DCSP return &apos; .&apos;.join ( map ( ( lambda n : str ( ( ( ip &gt; &gt; n ) &amp; 255 ) ) ) , &#91; 24 , 16 , 8 , 0 &#93; ) )
DCSP if ( ( request.user is None ) or ( not settings.FEATURES.get ( &apos; ENABLE _ MASQUERADE &apos; , False ) ) or ( not staff _ access ) ) : DCNL DCSP DCSP return ( None , request.user ) DCNL DCSP if reset _ masquerade _ data : DCNL DCSP DCSP request.session.pop ( MASQUERADE _ DATA _ KEY , None ) DCNL DCSP masquerade _ settings = request.session.setdefault ( MASQUERADE _ SETTINGS _ KEY , { } ) DCNL DCSP request.user.masquerade _ settings = masquerade _ settings DCNL DCSP course _ masquerade = masquerade _ settings.get ( course _ key , None ) DCNL DCSP masquerade _ user = None DCNL DCSP if ( course _ masquerade and course _ masquerade.user _ name ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP masquerade _ user = CourseEnrollment.objects.users _ enrolled _ in ( course _ key ) .get ( username = course _ masquerade.user _ name ) DCNL DCSP DCSP except User.DoesNotExist : DCNL DCSP DCSP DCSP course _ masquerade = None DCNL DCSP DCSP DCSP del masquerade _ settings &#91; course _ key &#93; DCNL DCSP DCSP DCSP request.session.modified = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP masquerade _ user.masquerade _ settings = request.user.masquerade _ settings DCNL DCSP DCSP DCSP masquerade _ user.real _ user = request.user DCNL DCSP return ( course _ masquerade , ( masquerade _ user or request.user ) )
DCSP post _ save.connect ( _ increment _ sync _ num , sender = Group ) DCNL DCSP post _ save.connect ( _ increment _ sync _ num , sender = Repository ) DCNL DCSP post _ delete.connect ( _ increment _ sync _ num , sender = Group ) DCNL DCSP post _ delete.connect ( _ increment _ sync _ num , sender = Repository )
DCSP eget = env.get DCNL DCSP g = regex _ client.search ( eget ( &apos; http _ x _ forwarded _ for &apos; , &apos; &apos; ) ) DCNL DCSP client = ( ( g.group ( ) or &apos; &apos; ) .split ( &apos; , &apos; ) &#91; 0 &#93; if g else None ) DCNL DCSP if ( client in ( None , &apos; &apos; , &apos; unknown &apos; ) ) : DCNL DCSP DCSP g = regex _ client.search ( eget ( &apos; remote _ addr &apos; , &apos; &apos; ) ) DCNL DCSP DCSP if g : DCNL DCSP DCSP DCSP client = g.group ( ) DCNL DCSP DCSP elif env.http _ host.startswith ( &apos; &#91; &apos; ) : DCNL DCSP DCSP DCSP client = &apos; : : 1 &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP client = &apos; 127.0.0.1 &apos; DCNL DCSP if ( not is _ valid _ ip _ address ( client ) ) : DCNL DCSP DCSP raise HTTP ( 400 , ( &apos; Bad DCSP Request DCSP ( request.client = % s ) &apos; % client ) ) DCNL DCSP return client
DCSP if isinstance ( obj , types.FunctionType ) : DCNL DCSP DCSP if ( attr in UNSAFE _ FUNCTION _ ATTRIBUTES ) : DCNL DCSP DCSP DCSP return True DCNL DCSP elif isinstance ( obj , types.MethodType ) : DCNL DCSP DCSP if ( ( attr in UNSAFE _ FUNCTION _ ATTRIBUTES ) or ( attr in UNSAFE _ METHOD _ ATTRIBUTES ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP elif isinstance ( obj , type ) : DCNL DCSP DCSP if ( attr = = &apos; mro &apos; ) : DCNL DCSP DCSP DCSP return True DCNL DCSP elif isinstance ( obj , ( types.CodeType , types.TracebackType , types.FrameType ) ) : DCNL DCSP DCSP return True DCNL DCSP elif isinstance ( obj , types.GeneratorType ) : DCNL DCSP DCSP if ( attr in UNSAFE _ GENERATOR _ ATTRIBUTES ) : DCNL DCSP DCSP DCSP return True DCNL DCSP elif ( hasattr ( types , &apos; CoroutineType &apos; ) and isinstance ( obj , types.CoroutineType ) ) : DCNL DCSP DCSP if ( attr in UNSAFE _ COROUTINE _ ATTRIBUTES ) : DCNL DCSP DCSP DCSP return True DCNL DCSP elif ( hasattr ( types , &apos; AsyncGeneratorType &apos; ) and isinstance ( obj , types.AsyncGeneratorType ) ) : DCNL DCSP DCSP if ( attr in UNSAFE _ ASYNC _ GENERATOR _ ATTRIBUTES ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return attr.startswith ( &apos; _ _ &apos; )
DCSP return { n : single _ source _ shortest _ path ( G , n , cutoff = cutoff ) for n in G }
DCSP return None
DCSP example _ cert _ status = None DCNL DCSP html _ cert _ enabled = certs _ api.has _ html _ certificates _ enabled ( course.id , course ) DCNL DCSP if html _ cert _ enabled : DCNL DCSP DCSP can _ enable _ for _ course = True DCNL DCSP else : DCNL DCSP DCSP example _ cert _ status = certs _ api.example _ certificates _ status ( course.id ) DCNL DCSP DCSP can _ enable _ for _ course = ( ( example _ cert _ status is not None ) and all ( ( ( cert _ status &#91; &apos; status &apos; &#93; = = &apos; success &apos; ) for cert _ status in example _ cert _ status ) ) ) DCNL DCSP instructor _ generation _ enabled = settings.FEATURES.get ( &apos; CERTIFICATES _ INSTRUCTOR _ GENERATION &apos; , False ) DCNL DCSP certificate _ statuses _ with _ count = { certificate &#91; &apos; status &apos; &#93; : certificate &#91; &apos; count &apos; &#93; for certificate in GeneratedCertificate.get _ unique _ statuses ( course _ key = course.id ) } DCNL DCSP return { &apos; section _ key &apos; : &apos; certificates &apos; , &apos; section _ display _ name &apos; : _ ( &apos; Certificates &apos; ) , &apos; example _ certificate _ status &apos; : example _ cert _ status , &apos; can _ enable _ for _ course &apos; : can _ enable _ for _ course , &apos; enabled _ for _ course &apos; : certs _ api.cert _ generation _ enabled ( course.id ) , &apos; is _ self _ paced &apos; : course.self _ paced , &apos; instructor _ generation _ enabled &apos; : instructor _ generation _ enabled , &apos; html _ cert _ enabled &apos; : html _ cert _ enabled , &apos; active _ certificate &apos; : certs _ api.get _ active _ web _ certificate ( course ) , &apos; certificate _ statuses _ with _ count &apos; : certificate _ statuses _ with _ count , &apos; status &apos; : CertificateStatuses , &apos; certificate _ generation _ history &apos; : CertificateGenerationHistory.objects.filter ( course _ id = course.id ) .order _ by ( &apos; -created &apos; ) , &apos; urls &apos; : { &apos; generate _ example _ certificates &apos; : reverse ( &apos; generate _ example _ certificates &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) , &apos; enable _ certificate _ generation &apos; : reverse ( &apos; enable _ certificate _ generation &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) , &apos; start _ certificate _ generation &apos; : reverse ( &apos; start _ certificate _ generation &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) , &apos; start _ certificate _ regeneration &apos; : reverse ( &apos; start _ certificate _ regeneration &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) , &apos; list _ instructor _ tasks _ url &apos; : reverse ( &apos; list _ instructor _ tasks &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) } }
DCSP return { &apos; 1&apos; : &apos; windows / shell _ reverse _ tcp &apos; , &apos; 2&apos; : &apos; windows / meterpreter / reverse _ tcp &apos; , &apos; 3&apos; : &apos; windows / vncinject / reverse _ tcp &apos; , &apos; 4&apos; : &apos; windows / x64 / shell _ reverse _ tcp &apos; , &apos; 5&apos; : &apos; windows / x64 / meterpreter / reverse _ tcp &apos; , &apos; 6&apos; : &apos; windows / meterpreter / reverse _ tcp _ allports &apos; , &apos; 7&apos; : &apos; windows / meterpreter / reverse _ https &apos; , &apos; 8&apos; : &apos; windows / meterpreter / reverse _ tcp _ dns &apos; , &apos; 9&apos; : &apos; windows / download _ exec &apos; } .get ( payload , &apos; ERROR &apos; )
DCSP with Archive ( path ) as archive : DCNL DCSP DCSP archive.extract ( to _ path )
DCSP ( model _ path , field _ name ) = field _ path.rsplit ( u &apos; . &apos; , 1 ) DCNL DCSP ( app _ name , model _ name ) = model _ path.split ( u &apos; .models. &apos; ) DCNL DCSP ( _ , app _ label ) = app _ name.rsplit ( u &apos; . &apos; , 1 ) DCNL DCSP return ( ( app _ label , model _ name.lower ( ) ) , field _ name )
DCSP results = { True : &apos; enabled &apos; , False : &apos; disabled &apos; } DCNL DCSP if ( host _ name = = &apos; notimplemented &apos; ) : DCNL DCSP DCSP raise NotImplementedError ( ) DCNL DCSP elif ( host _ name = = &apos; dummydest &apos; ) : DCNL DCSP DCSP raise exception.ComputeHostNotFound ( host = host _ name ) DCNL DCSP elif ( host _ name = = &apos; host _ c2 &apos; ) : DCNL DCSP DCSP return results &#91; ( not enabled ) &#93; DCNL DCSP else : DCNL DCSP DCSP return results &#91; enabled &#93;
DCSP conn = _ auth ( profile ) DCNL DCSP return conn.secgroup _ create ( name , description )
DCSP output _ file = os.path.join ( ARTIFACT _ DIR , fname ) DCNL DCSP collect _ with _ output = ( nose _ params % output _ file ) DCNL DCSP if ( selector is not None ) : DCNL DCSP DCSP cmd = ( &apos; % s DCSP % s DCSP -A DCSP &quot; % s &quot; DCSP w3af / &apos; % ( NOSETESTS , collect _ with _ output , selector ) ) DCNL DCSP else : DCNL DCSP DCSP cmd = ( &apos; % s DCSP % s DCSP w3af / &apos; % ( NOSETESTS , collect _ with _ output ) ) DCNL DCSP cmd _ args = shlex.split ( cmd ) DCNL DCSP logging.debug ( ( &apos; Collecting DCSP tests : DCSP &quot; % s &quot; &apos; % cmd ) ) DCNL DCSP p = subprocess.Popen ( cmd _ args , stdin = subprocess.PIPE , stdout = subprocess.PIPE , stderr = subprocess.PIPE , shell = False , universal _ newlines = True ) DCNL DCSP ( stdout , stderr ) = p.communicate ( ) DCNL DCSP if ( p.returncode ! = 0 ) : DCNL DCSP DCSP logging.critical ( &apos; Error DCSP while DCSP collecting DCSP tests ! &apos; ) DCNL DCSP DCSP logging.critical ( stdout ) DCNL DCSP DCSP logging.critical ( stderr ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP ( test _ suite , test _ result ) = parse _ xunit ( output _ file ) DCNL DCSP normalize _ test _ names ( test _ suite ) DCNL DCSP logging.debug ( ( &apos; Collected DCSP % s DCSP tests . &apos; % test _ result.testsRun ) ) DCNL DCSP return test _ suite
DCSP _ delete _ entrance _ exam ( request , course _ key ) DCNL DCSP return _ create _ entrance _ exam ( request = request , course _ key = course _ key , entrance _ exam _ minimum _ score _ pct = entrance _ exam _ minimum _ score _ pct )
DCSP request.headers &#91; &apos; Authorization &apos; &#93; = basic _ auth _ header ( username , password )
DCSP print x , y DCNL DCSP ( x , y ) = ( y , x ) DCNL DCSP print x , y
DCSP ret = True DCNL DCSP if servicegroup _ exists ( sg _ name ) : DCNL DCSP DCSP return False DCNL DCSP nitro = _ connect ( * * connection _ args ) DCNL DCSP if ( nitro is None ) : DCNL DCSP DCSP return False DCNL DCSP sg = NSServiceGroup ( ) DCNL DCSP sg.set _ servicegroupname ( sg _ name ) DCNL DCSP sg.set _ servicetype ( sg _ type.upper ( ) ) DCNL DCSP try : DCNL DCSP DCSP NSServiceGroup.add ( nitro , sg ) DCNL DCSP except NSNitroError as error : DCNL DCSP DCSP log.debug ( &apos; netscaler DCSP module DCSP error DCSP - DCSP NSServiceGroup.add ( ) DCSP failed : DCSP { 0 } &apos; .format ( error ) ) DCNL DCSP DCSP ret = False DCNL DCSP _ disconnect ( nitro ) DCNL DCSP return ret
DCSP parts = s.split ( &apos; .&apos; ) DCNL DCSP if ( len ( parts ) ! = 4 ) : DCNL DCSP DCSP return False DCNL DCSP for part in parts : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP int ( part ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP try : DCNL DCSP DCSP t = time.strptime ( string _ , &apos; % a , DCSP % d DCSP % b DCSP % Y DCSP % H : % M : % S DCSP % Z &apos; ) DCNL DCSP except ValueError : DCNL DCSP DCSP return None DCNL DCSP return datetime.datetime ( * t &#91; : 6 &#93; )
DCSP non _ report _ only _ policies = retrieve _ csp _ policies ( response ) DCNL DCSP report _ only _ policies = retrieve _ csp _ policies ( response , True ) DCNL DCSP policies _ all = merge _ policies _ dict ( non _ report _ only _ policies , report _ only _ policies ) DCNL DCSP if ( len ( policies _ all ) &gt; 0 ) : DCNL DCSP DCSP for directive _ name in policies _ all : DCNL DCSP DCSP DCSP if ( directive _ name.lower ( ) ! = CSP _ DIRECTIVE _ SCRIPT ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for directive _ value in policies _ all &#91; directive _ name &#93; : DCNL DCSP DCSP DCSP DCSP if ( directive _ value.strip ( ) .lower ( ) = = CSP _ DIRECTIVE _ VALUE _ UNSAFE _ EVAL ) : DCNL DCSP DCSP DCSP DCSP DCSP return True DCNL DCSP return False
DCSP return ( ( pennies * 1000000 ) / per )
DCSP return _ find _ elem _ with _ wait ( context , ( By.XPATH , id _ str ) , * * kwargs )
DCSP def zigbee _ frame _ subscriber ( event ) : DCNL DCSP DCSP &apos; Decode DCSP and DCSP unpickle DCSP the DCSP frame DCSP from DCSP the DCSP event DCSP bus , DCSP and DCSP call DCSP back . &apos; DCNL DCSP DCSP frame = pickle.loads ( b64decode ( event.data &#91; ATTR _ FRAME &#93; ) ) DCNL DCSP DCSP callback ( frame ) DCNL DCSP hass.bus.listen ( EVENT _ ZIGBEE _ FRAME _ RECEIVED , zigbee _ frame _ subscriber )
DCSP @ functools.wraps ( view _ func , assigned = available _ attrs ( view _ func ) ) DCNL DCSP def dec ( request , * args , * * kwargs ) : DCNL DCSP DCSP if dashboard : DCNL DCSP DCSP DCSP request.horizon &#91; &apos; dashboard &apos; &#93; = dashboard DCNL DCSP DCSP if panel : DCNL DCSP DCSP DCSP request.horizon &#91; &apos; panel &apos; &#93; = panel DCNL DCSP DCSP return view _ func ( request , * args , * * kwargs ) DCNL DCSP return dec
DCSP bigip _ session = _ build _ session ( username , password ) DCNL DCSP payload = { } DCNL DCSP payload &#91; &apos; name &apos; &#93; = name DCNL DCSP for ( key , value ) in six.iteritems ( kwargs ) : DCNL DCSP DCSP if ( not key.startswith ( &apos; _ _ &apos; ) ) : DCNL DCSP DCSP DCSP if ( key not in &#91; &apos; hostname &apos; , &apos; username &apos; , &apos; password &apos; , &apos; profile _ type &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP key = key.replace ( &apos; _ &apos; , &apos; -&apos; ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP payload &#91; key &#93; = _ set _ value ( value ) DCNL DCSP DCSP DCSP DCSP except salt.exceptions.CommandExecutionError : DCNL DCSP DCSP DCSP DCSP DCSP return &apos; Error : DCSP Unable DCSP to DCSP Parse DCSP JSON DCSP data DCSP for DCSP parameter : DCSP { key } \ n { value } &apos; .format ( key = key , value = value ) DCNL DCSP try : DCNL DCSP DCSP response = bigip _ session.put ( ( BIG _ IP _ URL _ BASE.format ( host = hostname ) + &apos; / ltm / profile / { type } / { name } &apos; .format ( type = profile _ type , name = name ) ) , data = json.dumps ( payload ) ) DCNL DCSP except requests.exceptions.ConnectionError as e : DCNL DCSP DCSP return _ load _ connection _ error ( hostname , e ) DCNL DCSP return _ load _ response ( response )
DCSP if re.match ( VALID _ CHARS _ REGEX , string ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP from matplotlib import pyplot as plt DCNL DCSP num _ rows = math.ceil ( ( ( len ( methods ) + 1.0 ) / num _ cols ) ) DCNL DCSP num _ rows = int ( num _ rows ) DCNL DCSP ( fig , ax ) = plt.subplots ( num _ rows , num _ cols , figsize = figsize , sharex = True , sharey = True , subplot _ kw = { &apos; adjustable &apos; : &apos; box-forced &apos; } ) DCNL DCSP ax = ax.ravel ( ) DCNL DCSP ax &#91; 0 &#93; .imshow ( image , cmap = plt.cm.gray ) DCNL DCSP ax &#91; 0 &#93; .set _ title ( &apos; Original &apos; ) DCNL DCSP i = 1 DCNL DCSP for ( name , func ) in methods.items ( ) : DCNL DCSP DCSP ax &#91; i &#93; .imshow ( func ( image ) , cmap = plt.cm.gray ) DCNL DCSP DCSP ax &#91; i &#93; .set _ title ( name ) DCNL DCSP DCSP i + = 1 DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print func . _ _ orifunc _ _ DCNL DCSP for a in ax : DCNL DCSP DCSP a.axis ( &apos; off &apos; ) DCNL DCSP fig.tight _ layout ( ) DCNL DCSP return ( fig , ax )
DCSP ( bits , power ) = ( 0 , 1L ) DCNL DCSP while ( N &gt; = power ) : DCNL DCSP DCSP bits + = 1 DCNL DCSP DCSP power = ( power &lt; &lt; 1 ) DCNL DCSP return bits
DCSP return ( &apos; % ( root ) supload / % ( service _ path ) s % ( path ) s &apos; % { &apos; root &apos; : root _ desc &#91; &apos; rootUrl &apos; &#93; , &apos; service _ path &apos; : root _ desc &#91; &apos; servicePath &apos; &#93; , &apos; path &apos; : path _ url } )
DCSP test _ data = BytesIO ( &apos; { &quot; a &quot; : DCSP &quot; b &quot; } &apos; ) DCNL DCSP assert ( hug.input _ format.json ( test _ data ) = = { &apos; a &apos; : &apos; b &apos; } )
DCSP types = ( ( ( dirName + os.sep ) + &apos; * .wav &apos; ) , ) DCNL DCSP filesToProcess = &#91; &#93; DCNL DCSP for files in types : DCNL DCSP DCSP filesToProcess.extend ( glob.glob ( files ) ) DCNL DCSP newDir = ( ( ( ( ( ( dirName + os.sep ) + &apos; Fs &apos; ) + str ( Fs ) ) + &apos; _ &apos; ) + &apos; NC &apos; ) + str ( nC ) ) DCNL DCSP if ( os.path.exists ( newDir ) and ( newDir ! = &apos; .&apos; ) ) : DCNL DCSP DCSP shutil.rmtree ( newDir ) DCNL DCSP os.makedirs ( newDir ) DCNL DCSP for f in filesToProcess : DCNL DCSP DCSP ( _ , wavFileName ) = ntpath.split ( f ) DCNL DCSP DCSP command = ( ( ( ( ( ( ( ( ( ( &apos; avconv DCSP -i DCSP &quot; &apos; + f ) + &apos; &quot; DCSP -ar DCSP &apos; ) + str ( Fs ) ) + &apos; DCSP -ac DCSP &apos; ) + str ( nC ) ) + &apos; DCSP &quot; &apos; ) + newDir ) + os.sep ) + wavFileName ) + &apos; &quot; &apos; ) DCNL DCSP DCSP print command DCNL DCSP DCSP os.system ( command )
DCSP escape = ( &apos; # { % s } &apos; % unicode ( time.time ( ) ) ) DCNL DCSP def enline ( line ) : DCNL DCSP DCSP return unicode ( line.replace ( &apos; \ \ &#124; &apos; , escape ) ) .strip ( ) DCNL DCSP def deline ( line ) : DCNL DCSP DCSP return line.replace ( escape , &apos; &#124; &apos; ) DCNL DCSP def discard _ comments ( lines ) : DCNL DCSP DCSP return &#91; line for line in lines if ( not line.startswith ( &apos; # &apos; ) ) &#93; DCNL DCSP lines = discard _ comments ( lines ) DCNL DCSP lines = map ( enline , lines ) DCNL DCSP non _ unique _ keys = &#91; &#93; DCNL DCSP json _ map = &#91; &#93; DCNL DCSP if lines : DCNL DCSP DCSP first _ line = lines.pop ( 0 ) DCNL DCSP DCSP non _ unique _ keys = split _ wisely ( first _ line , u &apos; &#124; &apos; , True ) DCNL DCSP DCSP non _ unique _ keys = map ( deline , non _ unique _ keys ) DCNL DCSP DCSP rng _ idx = len ( non _ unique _ keys ) DCNL DCSP DCSP json _ map = list ( non _ unique _ keys ) DCNL DCSP DCSP for idx in xrange ( rng _ idx ) : DCNL DCSP DCSP DCSP json _ map &#91; idx &#93; = dict ( &#91; ( non _ unique _ keys &#91; idx &#93; , &#91; &#93; ) &#93; ) DCNL DCSP DCSP for line in lines : DCNL DCSP DCSP DCSP values = split _ wisely ( line , u &apos; &#124; &apos; , True ) DCNL DCSP DCSP DCSP values = map ( deline , values ) DCNL DCSP DCSP DCSP for idx in xrange ( rng _ idx ) : DCNL DCSP DCSP DCSP DCSP json _ map &#91; idx &#93; .values ( ) &#91; 0 &#93; .append ( values &#91; idx &#93; ) DCNL DCSP return ( non _ unique _ keys , json _ map )
DCSP with open ( signature _ file ) as f : DCNL DCSP DCSP sig = binascii.a2b _ base64 ( f.read ( ) .splitlines ( ) &#91; 1 &#93; ) &#91; 10 : &#93; DCNL DCSP DCSP if ( len ( sig ) ! = 64 ) : DCNL DCSP DCSP DCSP raise Exception ( &apos; bogus DCSP Ed25519 DCSP signature : DCSP raw DCSP signature DCSP length DCSP was DCSP { } , DCSP but DCSP expected DCSP 64 &apos; .format ( len ( sig ) ) ) DCNL DCSP DCSP return sig
DCSP return re.sub ( ( ( &apos; ( ? P &lt; char &gt; &#91; &apos; + re.escape ( GLOBBING _ SPECIAL _ CHARS ) ) + &apos; &#93; ) &apos; ) , &apos; &#91; \ \ g &lt; char &gt; &#93; &apos; , input _ string )
DCSP from circus.process import get _ children , get _ memory _ info , get _ cpu _ percent , get _ memory _ percent , get _ cpu _ times , get _ nice , get _ cmdline , get _ create _ time , get _ username DCNL DCSP if ( ( process is None ) or isinstance ( process , int ) ) : DCNL DCSP DCSP if ( process is None ) : DCNL DCSP DCSP DCSP pid = os.getpid ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP pid = process DCNL DCSP DCSP if ( pid in _ PROCS ) : DCNL DCSP DCSP DCSP process = _ PROCS &#91; pid &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP _ PROCS &#91; pid &#93; = process = Process ( pid ) DCNL DCSP info = { } DCNL DCSP try : DCNL DCSP DCSP mem _ info = get _ memory _ info ( process ) DCNL DCSP DCSP info &#91; &apos; mem _ info1 &apos; &#93; = bytes2human ( mem _ info &#91; 0 &#93; ) DCNL DCSP DCSP info &#91; &apos; mem _ info2 &apos; &#93; = bytes2human ( mem _ info &#91; 1 &#93; ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; mem _ info1 &apos; &#93; = info &#91; &apos; mem _ info2 &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; cpu &apos; &#93; = get _ cpu _ percent ( process , interval = interval ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; cpu &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; mem &apos; &#93; = round ( get _ memory _ percent ( process ) , 3 ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; mem &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP cpu _ times = get _ cpu _ times ( process ) DCNL DCSP DCSP ctime = timedelta ( seconds = sum ( cpu _ times ) ) DCNL DCSP DCSP ctime = ( &apos; % s : % s . % s &apos; % ( ( ( ctime.seconds / / 60 ) % 60 ) , str ( ( ctime.seconds % 60 ) ) .zfill ( 2 ) , str ( ctime.microseconds ) &#91; : 2 &#93; ) ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP ctime = &apos; N / A &apos; DCNL DCSP info &#91; &apos; ctime &apos; &#93; = ctime DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; pid &apos; &#93; = process.pid DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; pid &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; username &apos; &#93; = get _ username ( process ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; username &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; nice &apos; &#93; = get _ nice ( process ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; nice &apos; &#93; = &apos; N / A &apos; DCNL DCSP except NoSuchProcess : DCNL DCSP DCSP info &#91; &apos; nice &apos; &#93; = &apos; Zombie &apos; DCNL DCSP try : DCNL DCSP DCSP raw _ cmdline = get _ cmdline ( process ) DCNL DCSP DCSP cmdline = os.path.basename ( shlex.split ( raw _ cmdline &#91; 0 &#93; , posix = ( not IS _ WINDOWS ) ) &#91; 0 &#93; ) DCNL DCSP except ( AccessDenied , IndexError ) : DCNL DCSP DCSP cmdline = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; create _ time &apos; &#93; = get _ create _ time ( process ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; create _ time &apos; &#93; = &apos; N / A &apos; DCNL DCSP try : DCNL DCSP DCSP info &#91; &apos; age &apos; &#93; = ( time.time ( ) - get _ create _ time ( process ) ) DCNL DCSP except TypeError : DCNL DCSP DCSP info &#91; &apos; create _ time &apos; &#93; = get _ create _ time ( process ) DCNL DCSP except AccessDenied : DCNL DCSP DCSP info &#91; &apos; age &apos; &#93; = &apos; N / A &apos; DCNL DCSP info &#91; &apos; cmdline &apos; &#93; = cmdline DCNL DCSP info &#91; &apos; children &apos; &#93; = &#91; &#93; DCNL DCSP if with _ childs : DCNL DCSP DCSP for child in get _ children ( process ) : DCNL DCSP DCSP DCSP info &#91; &apos; children &apos; &#93; .append ( get _ info ( child , interval = interval ) ) DCNL DCSP return info
DCSP storage _ client = storage.Client ( ) DCNL DCSP bucket = storage _ client.get _ bucket ( bucket _ name ) DCNL DCSP blob = bucket.blob ( blob _ name ) DCNL DCSP blob.delete ( ) DCNL DCSP print &apos; Blob DCSP { } DCSP deleted . &apos; .format ( blob _ name )
DCSP user = auth.user DCNL DCSP watch _ config = WatchConfig ( node = node , digest = request.json.get ( &apos; digest &apos; , False ) , immediate = request.json.get ( &apos; immediate &apos; , False ) ) DCNL DCSP try : DCNL DCSP DCSP if user.is _ watching ( node ) : DCNL DCSP DCSP DCSP user.unwatch ( watch _ config ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP user.watch ( watch _ config ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise HTTPError ( http.BAD _ REQUEST ) DCNL DCSP user.save ( ) DCNL DCSP return { &apos; status &apos; : &apos; success &apos; , &apos; watchCount &apos; : node.watches.count ( ) , &apos; watched &apos; : user.is _ watching ( node ) }
DCSP spacing * = &apos; DCSP &apos; DCNL DCSP return spacing.join ( ( c.center ( colwidth ) for c in cols ) )
DCSP ( app _ path , taglib ) = taglib _ module.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP app _ module = import _ module ( app _ path ) DCNL DCSP try : DCNL DCSP DCSP mod = import _ module ( taglib _ module ) DCNL DCSP except ImportError as e : DCNL DCSP DCSP if ( not module _ has _ submodule ( app _ module , taglib ) ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise InvalidTemplateLibrary ( ( &apos; ImportError DCSP raised DCSP loading DCSP % s : DCSP % s &apos; % ( taglib _ module , e ) ) ) DCNL DCSP try : DCNL DCSP DCSP return mod.register DCNL DCSP except AttributeError : DCNL DCSP DCSP raise InvalidTemplateLibrary ( ( &quot; Template DCSP library DCSP % s DCSP does DCSP not DCSP have DCSP a DCSP variable DCSP named DCSP &apos; register &apos; &quot; % taglib _ module ) )
DCSP pvals = np.asarray ( pvals ) DCNL DCSP shape _ init = pvals.shape DCNL DCSP pvals = pvals.ravel ( ) DCNL DCSP pvals _ sortind = np.argsort ( pvals ) DCNL DCSP pvals _ sorted = pvals &#91; pvals _ sortind &#93; DCNL DCSP sortrevind = pvals _ sortind.argsort ( ) DCNL DCSP if ( method in &#91; &apos; i &apos; , &apos; indep &apos; , &apos; p &apos; , &apos; poscorr &apos; &#93; ) : DCNL DCSP DCSP ecdffactor = _ ecdf ( pvals _ sorted ) DCNL DCSP elif ( method in &#91; &apos; n &apos; , &apos; negcorr &apos; &#93; ) : DCNL DCSP DCSP cm = np.sum ( ( 1.0 / np.arange ( 1 , ( len ( pvals _ sorted ) + 1 ) ) ) ) DCNL DCSP DCSP ecdffactor = ( _ ecdf ( pvals _ sorted ) / cm ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &quot; Method DCSP should DCSP be DCSP &apos; indep &apos; DCSP and DCSP &apos; negcorr &apos; &quot; ) DCNL DCSP reject = ( pvals _ sorted &lt; ( ecdffactor * alpha ) ) DCNL DCSP if reject.any ( ) : DCNL DCSP DCSP rejectmax = max ( np.nonzero ( reject ) &#91; 0 &#93; ) DCNL DCSP else : DCNL DCSP DCSP rejectmax = 0 DCNL DCSP reject &#91; : rejectmax &#93; = True DCNL DCSP pvals _ corrected _ raw = ( pvals _ sorted / ecdffactor ) DCNL DCSP pvals _ corrected = np.minimum.accumulate ( pvals _ corrected _ raw &#91; : : ( -1 ) &#93; ) &#91; : : ( -1 ) &#93; DCNL DCSP pvals _ corrected &#91; ( pvals _ corrected &gt; 1.0 ) &#93; = 1.0 DCNL DCSP pvals _ corrected = pvals _ corrected &#91; sortrevind &#93; .reshape ( shape _ init ) DCNL DCSP reject = reject &#91; sortrevind &#93; .reshape ( shape _ init ) DCNL DCSP return ( reject , pvals _ corrected )
DCSP p &#91; 0 &#93; = p &#91; 1 &#93;
DCSP ( w , wavelen ) = map ( sympify , ( w , wavelen ) ) DCNL DCSP return ( ( ( w * * 2 ) * pi ) / wavelen )
DCSP return len ( _ sprintf _ placeholder _ re.findall ( string ) )
DCSP batch _ job _ service = client.GetService ( &apos; BatchJobService &apos; , &apos; v201607 &apos; ) DCNL DCSP selector = { &apos; fields &apos; : &#91; &apos; Id &apos; , &apos; Status &apos; , &apos; DownloadUrl &apos; &#93; , &apos; predicates &apos; : &#91; { &apos; field &apos; : &apos; Id &apos; , &apos; operator &apos; : &apos; EQUALS &apos; , &apos; values &apos; : &#91; batch _ job _ id &#93; } &#93; } DCNL DCSP return batch _ job _ service.get ( selector ) &#91; &apos; entries &apos; &#93; &#91; 0 &#93;
DCSP kwargs _ for _ reverse = ( { key _ name : unicode ( key _ value ) } if key _ name else None ) DCNL DCSP if kwargs : DCNL DCSP DCSP kwargs _ for _ reverse.update ( kwargs ) DCNL DCSP return reverse ( ( &apos; contentstore.views. &apos; + handler _ name ) , kwargs = kwargs _ for _ reverse )
DCSP return ( ioThread = = getThreadID ( ) )
DCSP collector &#91; &apos; activity-by-hour &apos; &#93; &#91; &apos; smtp-receives &apos; &#93; &#91; date.hour &#93; + = 1
DCSP assert _ signature ( &apos; &#91; str &#93; &#91; 0 &#93; ( &apos; , &apos; str &apos; , 0 ) DCNL DCSP assert _ signature ( &apos; &#91; str &#93; &#91; 0 &#93; ( ) &apos; , &apos; str &apos; , 0 , column = len ( &apos; &#91; str &#93; &#91; 0 &#93; ( &apos; ) ) DCNL DCSP assert _ signature ( &apos; ( str ) ( &apos; , &apos; str &apos; , 0 ) DCNL DCSP assert _ signature ( &apos; ( str ) ( ) &apos; , &apos; str &apos; , 0 , column = len ( &apos; ( str ) ( &apos; ) )
DCSP return fuse _ selections ( dsk , getitem , func , ( lambda a , b : ( ( tuple ( b &#91; : place &#93; ) + ( a &#91; 2 &#93; , ) ) + tuple ( b &#91; ( place + 1 ) : &#93; ) ) ) )
DCSP uuid _ to _ hostnames = { node.uuid : node.hostname for node in current _ state.nodes.values ( ) } DCNL DCSP desired _ datasets = { node.uuid : set ( ( manifestation.dataset for manifestation in node.manifestations.values ( ) ) ) for node in desired _ state.nodes.values ( ) } DCNL DCSP current _ datasets = { node.uuid : set ( ( manifestation.dataset for manifestation in ( node.manifestations or { } ) .values ( ) ) ) for node in current _ state.nodes.values ( ) } DCNL DCSP local _ desired _ datasets = set ( ( dataset for dataset in desired _ datasets.get ( uuid , set ( ) ) if ( dataset.deleted is False ) ) ) DCNL DCSP local _ desired _ dataset _ ids = set ( ( dataset.dataset _ id for dataset in local _ desired _ datasets ) ) DCNL DCSP local _ current _ dataset _ ids = set ( ( dataset.dataset _ id for dataset in current _ datasets.get ( uuid , set ( ) ) ) ) DCNL DCSP remote _ current _ dataset _ ids = set ( ) DCNL DCSP for ( dataset _ node _ uuid , current ) in current _ datasets.items ( ) : DCNL DCSP DCSP if ( dataset _ node _ uuid ! = uuid ) : DCNL DCSP DCSP DCSP remote _ current _ dataset _ ids &#124; = set ( ( dataset.dataset _ id for dataset in current ) ) DCNL DCSP resizing = set ( ) DCNL DCSP for desired in desired _ datasets.values ( ) : DCNL DCSP DCSP for new _ dataset in desired : DCNL DCSP DCSP DCSP if ( new _ dataset.dataset _ id in local _ current _ dataset _ ids ) : DCNL DCSP DCSP DCSP DCSP for cur _ dataset in current _ datasets &#91; uuid &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( cur _ dataset.dataset _ id ! = new _ dataset.dataset _ id ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP if ( cur _ dataset.maximum _ size ! = new _ dataset.maximum _ size ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP resizing.add ( new _ dataset ) DCNL DCSP going = set ( ) DCNL DCSP for ( dataset _ node _ uuid , desired ) in desired _ datasets.items ( ) : DCNL DCSP DCSP if ( dataset _ node _ uuid ! = uuid ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP hostname = uuid _ to _ hostnames &#91; dataset _ node _ uuid &#93; DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for dataset in desired : DCNL DCSP DCSP DCSP DCSP if ( dataset.dataset _ id in local _ current _ dataset _ ids ) : DCNL DCSP DCSP DCSP DCSP DCSP going.add ( DatasetHandoff ( dataset = dataset , hostname = hostname ) ) DCNL DCSP creating _ dataset _ ids = local _ desired _ dataset _ ids.difference ( ( local _ current _ dataset _ ids &#124; remote _ current _ dataset _ ids ) ) DCNL DCSP creating = set ( ( dataset for dataset in local _ desired _ datasets if ( dataset.dataset _ id in creating _ dataset _ ids ) ) ) DCNL DCSP deleting = set ( ( dataset for dataset in chain ( * desired _ datasets.values ( ) ) if ( dataset.deleted and ( dataset.dataset _ id in local _ current _ dataset _ ids ) ) ) ) DCNL DCSP return DatasetChanges ( going = going , deleting = deleting , creating = creating , resizing = resizing )
DCSP result = script.pip ( &apos; show &apos; , &apos; pip &apos; ) DCNL DCSP lines = result.stdout.splitlines ( ) DCNL DCSP expected = set ( &#91; &apos; Name &apos; , &apos; Version &apos; , &apos; Summary &apos; , &apos; Home-page &apos; , &apos; Author &apos; , &apos; Author-email &apos; , &apos; License &apos; , &apos; Location &apos; , &apos; Requires &apos; &#93; ) DCNL DCSP actual = set ( ( re.sub ( &apos; : . * $ &apos; , &apos; &apos; , line ) for line in lines ) ) DCNL DCSP assert ( actual = = expected )
DCSP depth = len ( b _ list ) DCNL DCSP new _ nsamples = &#91; nsamples &#91; i &#93; for i in xrange ( depth ) &#93; DCNL DCSP _ sample _ even _ odd ( W _ list , b _ list , new _ nsamples , beta , odd = marginalize _ odd ) DCNL DCSP _ activation _ even _ odd ( W _ list , b _ list , new _ nsamples , beta , odd = ( not marginalize _ odd ) ) DCNL DCSP new _ nsamples &#91; ( not marginalize _ odd ) &#93; + = ( pa _ bias * ( 1.0 - beta ) ) DCNL DCSP for i in xrange ( ( not marginalize _ odd ) , depth , 2 ) : DCNL DCSP DCSP new _ nsamples &#91; i &#93; = T.nnet.sigmoid ( new _ nsamples &#91; i &#93; ) DCNL DCSP DCSP new _ nsamples &#91; i &#93; = theano _ rng.binomial ( size = nsamples &#91; i &#93; .get _ value ( ) .shape , n = 1 , p = new _ nsamples &#91; i &#93; , dtype = floatX ) DCNL DCSP return new _ nsamples
DCSP pending = len ( iterables ) DCNL DCSP nexts = cycle ( ( iter ( it ) .next for it in iterables ) ) DCNL DCSP while pending : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP for next in nexts : DCNL DCSP DCSP DCSP DCSP ( yield next ( ) ) DCNL DCSP DCSP except StopIteration : DCNL DCSP DCSP DCSP pending - = 1 DCNL DCSP DCSP DCSP nexts = cycle ( islice ( nexts , pending ) )
DCSP result _ pipeline _ id = _ _ salt _ _ &#91; &apos; boto _ datapipeline.pipeline _ id _ from _ name &apos; &#93; ( name , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( &apos; error &apos; in result _ pipeline _ id ) : DCNL DCSP DCSP return ( False , { } ) DCNL DCSP pipeline _ id = result _ pipeline _ id &#91; &apos; result &apos; &#93; DCNL DCSP pipeline _ definition _ result = _ _ salt _ _ &#91; &apos; boto _ datapipeline.get _ pipeline _ definition &apos; &#93; ( pipeline _ id , version = &apos; active &apos; , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( &apos; error &apos; in pipeline _ definition _ result ) : DCNL DCSP DCSP return ( False , { } ) DCNL DCSP pipeline _ definition = _ standardize ( pipeline _ definition _ result &#91; &apos; result &apos; &#93; ) DCNL DCSP pipeline _ objects = pipeline _ definition.get ( &apos; pipelineObjects &apos; ) DCNL DCSP parameter _ objects = pipeline _ definition.get ( &apos; parameterObjects &apos; ) DCNL DCSP paramater _ values = pipeline _ definition.get ( &apos; parameterValues &apos; ) DCNL DCSP present = ( _ recursive _ compare ( _ cleaned ( pipeline _ objects ) , _ cleaned ( expected _ pipeline _ objects ) ) and _ recursive _ compare ( parameter _ objects , expected _ parameter _ objects ) and _ recursive _ compare ( paramater _ values , expected _ parameter _ values ) ) DCNL DCSP return ( present , pipeline _ definition )
DCSP session = get _ session ( ) DCNL DCSP with session.begin ( ) : DCNL DCSP DCSP instance _ type _ ref = instance _ type _ get _ by _ flavor _ id ( context , flavor _ id , session = session ) DCNL DCSP DCSP instance _ type _ id = instance _ type _ ref &#91; &apos; id &apos; &#93; DCNL DCSP DCSP access _ ref = _ instance _ type _ access _ query ( context , session = session ) .filter _ by ( instance _ type _ id = instance _ type _ id ) .filter _ by ( project _ id = project _ id ) .first ( ) DCNL DCSP DCSP if access _ ref : DCNL DCSP DCSP DCSP raise exception.FlavorAccessExists ( flavor _ id = flavor _ id , project _ id = project _ id ) DCNL DCSP DCSP access _ ref = models.InstanceTypeProjects ( ) DCNL DCSP DCSP access _ ref.update ( { &apos; instance _ type _ id &apos; : instance _ type _ id , &apos; project _ id &apos; : project _ id } ) DCNL DCSP DCSP access _ ref.save ( session = session ) DCNL DCSP DCSP return access _ ref
DCSP global _ PARSING _ CACHE DCNL DCSP if ( string in _ PARSING _ CACHE ) : DCNL DCSP DCSP stack = _ PARSING _ CACHE &#91; string &#93; DCNL DCSP else : DCNL DCSP DCSP if ( not _ RE _ STARTTOKEN.search ( string ) ) : DCNL DCSP DCSP DCSP return string DCNL DCSP DCSP stack = ParseStack ( ) DCNL DCSP DCSP ncallable = 0 DCNL DCSP DCSP for match in _ RE _ TOKEN.finditer ( string ) : DCNL DCSP DCSP DCSP gdict = match.groupdict ( ) DCNL DCSP DCSP DCSP if gdict &#91; &apos; singlequote &apos; &#93; : DCNL DCSP DCSP DCSP DCSP stack.append ( gdict &#91; &apos; singlequote &apos; &#93; ) DCNL DCSP DCSP DCSP elif gdict &#91; &apos; doublequote &apos; &#93; : DCNL DCSP DCSP DCSP DCSP stack.append ( gdict &#91; &apos; doublequote &apos; &#93; ) DCNL DCSP DCSP DCSP elif gdict &#91; &apos; end &apos; &#93; : DCNL DCSP DCSP DCSP DCSP if ( ncallable &lt; = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( &apos; ) &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP args = &#91; &#93; DCNL DCSP DCSP DCSP DCSP while stack : DCNL DCSP DCSP DCSP DCSP DCSP operation = stack.pop ( ) DCNL DCSP DCSP DCSP DCSP DCSP if callable ( operation ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not strip ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP stack.append ( ( operation , &#91; arg for arg in reversed ( args ) &#93; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP ncallable - = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP args.append ( operation ) DCNL DCSP DCSP DCSP elif gdict &#91; &apos; start &apos; &#93; : DCNL DCSP DCSP DCSP DCSP funcname = _ RE _ STARTTOKEN.match ( gdict &#91; &apos; start &apos; &#93; ) .group ( 1 ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( _ INLINE _ FUNCS &#91; funcname &#93; ) DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( _ INLINE _ FUNCS &#91; &apos; nomatch &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( funcname ) DCNL DCSP DCSP DCSP DCSP ncallable + = 1 DCNL DCSP DCSP DCSP elif gdict &#91; &apos; escaped &apos; &#93; : DCNL DCSP DCSP DCSP DCSP token = gdict &#91; &apos; escaped &apos; &#93; .lstrip ( &apos; \ \ &apos; ) DCNL DCSP DCSP DCSP DCSP stack.append ( token ) DCNL DCSP DCSP DCSP elif gdict &#91; &apos; comma &apos; &#93; : DCNL DCSP DCSP DCSP DCSP if ( ncallable &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( None ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( &apos; , &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP stack.append ( gdict &#91; &apos; rest &apos; &#93; ) DCNL DCSP DCSP if ( ncallable &gt; 0 ) : DCNL DCSP DCSP DCSP return string DCNL DCSP DCSP if ( ( _ STACK _ MAXSIZE &gt; 0 ) and ( _ STACK _ MAXSIZE &lt; len ( stack ) ) ) : DCNL DCSP DCSP DCSP return ( string + gdict &#91; &apos; stackfull &apos; &#93; ( * args , * * kwargs ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP _ PARSING _ CACHE &#91; string &#93; = stack DCNL DCSP def _ run _ stack ( item , depth = 0 ) : DCNL DCSP DCSP retval = item DCNL DCSP DCSP if isinstance ( item , tuple ) : DCNL DCSP DCSP DCSP if strip : DCNL DCSP DCSP DCSP DCSP return &apos; &apos; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ( func , arglist ) = item DCNL DCSP DCSP DCSP DCSP args = &#91; &apos; &apos; &#93; DCNL DCSP DCSP DCSP DCSP for arg in arglist : DCNL DCSP DCSP DCSP DCSP DCSP if ( arg is None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP args.append ( &apos; &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP args &#91; ( -1 ) &#93; + = _ run _ stack ( arg , depth = ( depth + 1 ) ) DCNL DCSP DCSP DCSP DCSP kwargs &#91; &apos; inlinefunc _ stack _ depth &apos; &#93; = depth DCNL DCSP DCSP DCSP DCSP retval = ( &apos; &apos; if strip else func ( * args , * * kwargs ) ) DCNL DCSP DCSP return utils.to _ str ( retval , force _ string = True ) DCNL DCSP return &apos; &apos;.join ( ( _ run _ stack ( item ) for item in _ PARSING _ CACHE &#91; string &#93; ) )
DCSP logger = logging.getLogger ( facility ) DCNL DCSP logger.log ( loglevel , msg )
DCSP frappe.db.begin ( ) DCNL DCSP frappe.db.sql ( u &apos;update DCSP tabSingles DCSP set DCSP field = % s DCSP where DCSP doctype = % s DCSP and DCSP field = % s &apos; , ( new , f &#91; u &apos;parent &apos; &#93; , f &#91; u &apos;fieldname &apos; &#93; ) ) DCNL DCSP frappe.db.commit ( )
DCSP p &#91; 0 &#93; = ( - p &#91; 2 &#93; )
DCSP return &apos; &apos;.join ( &#91; a.title ( ) for a in s.split ( &apos; _ &apos; ) if a &#93; )
DCSP m = space _ pat.match ( text , i ) DCNL DCSP if ( m is not None ) : DCNL DCSP DCSP return &#91; ( len ( m.group ( ) ) , None ) &#93; DCNL DCSP cdo = cdo _ pat.match ( text , i ) DCNL DCSP if ( cdo is not None ) : DCNL DCSP DCSP state.parse = IN _ COMMENT _ NORMAL DCNL DCSP DCSP return &#91; ( len ( cdo.group ( ) ) , formats &#91; u &apos;comment &apos; &#93; ) &#93; DCNL DCSP if ( text &#91; i &#93; = = u &apos; &quot; &apos; ) : DCNL DCSP DCSP state.parse = IN _ DQS DCNL DCSP DCSP return &#91; ( 1 , formats &#91; u &apos;string &apos; &#93; ) &#93; DCNL DCSP if ( text &#91; i &#93; = = u &quot; &apos; &quot; ) : DCNL DCSP DCSP state.parse = IN _ SQS DCNL DCSP DCSP return &#91; ( 1 , formats &#91; u &apos;string &apos; &#93; ) &#93; DCNL DCSP if ( text &#91; i &#93; = = u &apos; { &apos; ) : DCNL DCSP DCSP state.parse = IN _ CONTENT DCNL DCSP DCSP state.blocks + = 1 DCNL DCSP DCSP return &#91; ( 1 , formats &#91; u &apos;bracket &apos; &#93; ) &#93; DCNL DCSP for ( token , fmt , name ) in sheet _ tokens : DCNL DCSP DCSP m = token.match ( text , i ) DCNL DCSP DCSP if ( m is not None ) : DCNL DCSP DCSP DCSP return &#91; ( len ( m.group ( ) ) , formats &#91; fmt &#93; ) &#93; DCNL DCSP return &#91; ( ( len ( text ) - i ) , formats &#91; u &apos;unknown-normal &apos; &#93; ) &#93;
DCSP return isinstance ( object , types.TracebackType )
DCSP eq _ ( len ( s ) , len ( t ) ) DCNL DCSP all ( ( assert _ array _ equal ( x , y ) for ( x , y ) in zip ( s , t ) ) )
DCSP return valmap ( ( lambda v : tuple ( ( OwnershipPeriod ( a.start , b.start , a.sid , a.value ) for ( a , b ) in sliding _ window ( 2 , concatv ( sorted ( v ) , &#91; OwnershipPeriod ( pd.Timestamp.max.tz _ localize ( &apos; utc &apos; ) , None , None , None ) &#93; ) ) ) ) ) , mappings )
DCSP keys = &#91; k.strip ( ) for k in matchobj.group ( 1 ) .split ( &apos; + &apos; ) &#93; DCNL DCSP return &apos; DCSP + DCSP &apos; .join ( &#91; ( &apos; &lt; span DCSP class = &quot; key &quot; &gt; % s &lt; / span &gt; &apos; % key ) for key in keys &#93; )
DCSP repository = get _ repository _ for _ hook ( repository _ id , hosting _ service _ id , local _ site _ name , hooks _ uuid ) DCNL DCSP try : DCNL DCSP DCSP payload = json.loads ( request.body ) DCNL DCSP except ValueError as e : DCNL DCSP DCSP logging.error ( u &apos;The DCSP payload DCSP is DCSP not DCSP in DCSP JSON DCSP format : DCSP % s &apos; , e , exc _ info = 1 ) DCNL DCSP DCSP return HttpResponseBadRequest ( u &apos;Invalid DCSP payload DCSP format &apos; ) DCNL DCSP server _ url = get _ server _ url ( request = request ) DCNL DCSP review _ request _ id _ to _ commits _ map = close _ review _ requests ( payload , server _ url ) DCNL DCSP if review _ request _ id _ to _ commits _ map : DCNL DCSP DCSP close _ all _ review _ requests ( review _ request _ id _ to _ commits _ map , local _ site _ name , repository , hosting _ service _ id ) DCNL DCSP return HttpResponse ( )
DCSP req _ group _ types = &#91; &#93; DCNL DCSP for grp _ t in group _ type _ list : DCNL DCSP DCSP if ( not uuidutils.is _ uuid _ like ( grp _ t ) ) : DCNL DCSP DCSP DCSP grp _ type = _ group _ type _ get _ by _ name ( context , grp _ t ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP grp _ type = _ group _ type _ get ( context , grp _ t ) DCNL DCSP DCSP req _ group _ types.append ( grp _ type ) DCNL DCSP return req _ group _ types
DCSP handler = logging.StreamHandler ( ) DCNL DCSP root _ logger = logging.getLogger ( ) DCNL DCSP root _ logger.setLevel ( ( logging.ERROR - ( args.verbose _ count * 10 ) ) ) DCNL DCSP root _ logger.addHandler ( handler )
DCSP d = { } DCNL DCSP psum = 0.0 DCNL DCSP for ( x , y ) in xy : DCNL DCSP DCSP if ( x not in d ) : DCNL DCSP DCSP DCSP d &#91; x &#93; = { } DCNL DCSP DCSP if ( y not in d ) : DCNL DCSP DCSP DCSP d &#91; y &#93; = { } DCNL DCSP DCSP v = d &#91; x &#93; .get ( y , 0 ) DCNL DCSP DCSP d &#91; x &#93; &#91; y &#93; = ( v + 1 ) DCNL DCSP DCSP psum + = 1 DCNL DCSP if normalized : DCNL DCSP DCSP for ( k , jdict ) in d.items ( ) : DCNL DCSP DCSP DCSP for j in jdict : DCNL DCSP DCSP DCSP DCSP jdict &#91; j &#93; / = psum DCNL DCSP return d
DCSP def task _ name _ in _ map ( body , message ) : DCNL DCSP DCSP return map.get ( body &#91; u &apos;task &apos; &#93; ) DCNL DCSP return move ( task _ name _ in _ map , * * kwargs )
DCSP pp _ opts = &#91; &#93; DCNL DCSP for macro in macros : DCNL DCSP DCSP if ( not ( ( type ( macro ) is TupleType ) and ( 1 &lt; = len ( macro ) &lt; = 2 ) ) ) : DCNL DCSP DCSP DCSP raise TypeError , ( ( &quot; bad DCSP macro DCSP definition DCSP &apos; % s &apos; : DCSP &quot; + &quot; each DCSP element DCSP of DCSP &apos; macros &apos; DCSP list DCSP must DCSP be DCSP a DCSP 1- DCSP or DCSP 2-tuple &quot; ) % macro ) DCNL DCSP DCSP if ( len ( macro ) = = 1 ) : DCNL DCSP DCSP DCSP pp _ opts.append ( ( &apos; -U % s &apos; % macro &#91; 0 &#93; ) ) DCNL DCSP DCSP elif ( len ( macro ) = = 2 ) : DCNL DCSP DCSP DCSP if ( macro &#91; 1 &#93; is None ) : DCNL DCSP DCSP DCSP DCSP pp _ opts.append ( ( &apos; -D % s &apos; % macro &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP pp _ opts.append ( ( &apos; -D % s = % s &apos; % macro ) ) DCNL DCSP for dir in include _ dirs : DCNL DCSP DCSP pp _ opts.append ( ( &apos; -I % s &apos; % dir ) ) DCNL DCSP return pp _ opts
DCSP combined = datetime.combine ( dt _ util.start _ of _ local _ day ( ) , dt _ util.parse _ time ( timestr ) ) DCNL DCSP if ( combined &lt; datetime.now ( ) ) : DCNL DCSP DCSP combined = ( combined + timedelta ( days = 1 ) ) DCNL DCSP return dt _ util.as _ timestamp ( combined )
DCSP client = MongoClient ( wiki _ settings.SHAREJS _ DB _ URL ) DCNL DCSP return client &#91; wiki _ settings.SHAREJS _ DB _ NAME &#93;
DCSP match = COMPARE _ TYPE _ REGEX.search ( logical _ line ) DCNL DCSP if ( match and ( not noqa ) ) : DCNL DCSP DCSP inst = match.group ( 1 ) DCNL DCSP DCSP if ( inst and isidentifier ( inst ) and ( inst not in SINGLETONS ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP ( yield ( match.start ( ) , &quot; E721 DCSP do DCSP not DCSP compare DCSP types , DCSP use DCSP &apos; isinstance ( ) &apos; &quot; ) )
DCSP common = common _ utils.get _ rand _ name ( max _ length = 4 , prefix = &apos; &apos; ) DCNL DCSP prefix = ( &apos; % s- % s- &apos; % ( PATCH _ PREFIX , common ) ) DCNL DCSP source _ name = common _ utils.get _ rand _ device _ name ( prefix = prefix ) DCNL DCSP destination _ name = common _ utils.get _ rand _ device _ name ( prefix = prefix ) DCNL DCSP source.add _ patch _ port ( source _ name , destination _ name ) DCNL DCSP destination.add _ patch _ port ( destination _ name , source _ name )
DCSP _ colorbar _ extension _ length ( u &apos;uniform &apos; ) DCNL DCSP _ colorbar _ extension _ length ( u &apos;proportional &apos; )
DCSP if ( session _ id is None ) : DCNL DCSP DCSP session _ id = random.randint ( 0 , 18446744073709551615L ) DCNL DCSP sock = socket.socket ( socket.AF _ INET , socket.SOCK _ DGRAM ) DCNL DCSP data = struct.pack ( &apos; ! BQxxxxx &apos; , 56 , session _ id ) DCNL DCSP sock.sendto ( data , ( address , port ) ) DCNL DCSP sock.settimeout ( timeout ) DCNL DCSP try : DCNL DCSP DCSP received = sock.recv ( 2048 ) DCNL DCSP except socket.timeout : DCNL DCSP DCSP return False DCNL DCSP finally : DCNL DCSP DCSP sock.close ( ) DCNL DCSP fmt = &apos; ! BQxxxxxQxxxx &apos; DCNL DCSP if ( len ( received ) ! = struct.calcsize ( fmt ) ) : DCNL DCSP DCSP print struct.calcsize ( fmt ) DCNL DCSP DCSP return False DCNL DCSP ( identifier , server _ sess , client _ sess ) = struct.unpack ( fmt , received ) DCNL DCSP if ( ( identifier = = 64 ) and ( client _ sess = = session _ id ) ) : DCNL DCSP DCSP return server _ sess
DCSP from . _ compat import StringIO DCNL DCSP ( sys.stdout , _ ) = ( StringIO ( ) , sys.stdout ) DCNL DCSP help ( vim.eval ( &apos; a : word &apos; ) ) DCNL DCSP ( sys.stdout , out ) = ( _ , sys.stdout.getvalue ( ) ) DCNL DCSP vim.current.buffer.append ( str ( out ) .splitlines ( ) , 0 )
DCSP return date _ obj.strftime ( &apos; % a , DCSP % d DCSP % b DCSP % Y DCSP % H : % M : % S DCSP GMT &apos; )
DCSP a = TpPd ( pd = 5 ) DCNL DCSP b = MessageType ( mesType = 36 ) DCNL DCSP c = CmServiceTypeAndCiphKeySeqNr ( ) DCNL DCSP e = MobileStationClassmark2 ( ) DCNL DCSP f = MobileId ( ) DCNL DCSP packet = ( ( ( ( a / b ) / c ) / e ) / f ) DCNL DCSP if ( PriorityLevel _ presence is 1 ) : DCNL DCSP DCSP g = PriorityLevelHdr ( ieiPL = 8 , eightBitPL = 0 ) DCNL DCSP DCSP packet = ( packet / g ) DCNL DCSP return packet
DCSP ring _ output = check _ output ( &#91; NODE _ TOOL , &apos; ring &apos; , KEYSPACE &#93; ) DCNL DCSP ring = &#91; &#93; DCNL DCSP index = 0 DCNL DCSP for line in ring _ output.splitlines ( ) : DCNL DCSP DCSP fields = line.split ( ) DCNL DCSP DCSP if ( len ( fields ) ! = 8 ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ring.append ( { &apos; index &apos; : index , &apos; ip &apos; : fields &#91; 0 &#93; , &apos; status &apos; : fields &#91; 2 &#93; , &apos; state &apos; : fields &#91; 3 &#93; , &apos; load &apos; : load _ bytes ( float ( fields &#91; 4 &#93; ) , fields &#91; 5 &#93; ) , &apos; token &apos; : fields &#91; 7 &#93; } ) DCNL DCSP DCSP index + = 1 DCNL DCSP assert ( len ( ring ) &gt; 0 ) DCNL DCSP ideal _ load = ( sum ( ( node &#91; &apos; load &apos; &#93; for node in ring ) ) / len ( ring ) ) DCNL DCSP for ( index , node ) in enumerate ( ring ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP node &#91; &apos; skew &apos; &#93; = ( abs ( ( node &#91; &apos; load &apos; &#93; - ideal _ load ) ) / ideal _ load ) DCNL DCSP DCSP except ZeroDivisionError : DCNL DCSP DCSP DCSP node &#91; &apos; skew &apos; &#93; = 0 DCNL DCSP DCSP node &#91; &apos; diff &apos; &#93; = abs ( ( node &#91; &apos; load &apos; &#93; - ring &#91; ( index - 1 ) &#93; &#91; &apos; load &apos; &#93; ) ) DCNL DCSP return ring
DCSP mode = session.s3.hrm.mode DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( mode is not None ) : DCNL DCSP DCSP DCSP auth.permission.fail ( ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3 _ rest _ controller ( ) DCNL DCSP return output
DCSP return ( status ( ctid _ or _ name ) .split ( &apos; DCSP &apos; ) &#91; 4 &#93; = = &apos; running &apos; )
DCSP if ( default = = _ no _ default ) : DCNL DCSP DCSP return int ( int _ str ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return int ( int _ str ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP return default
DCSP try : DCNL DCSP DCSP colorConverter.to _ rgb ( c ) DCNL DCSP DCSP return True DCNL DCSP except ValueError : DCNL DCSP DCSP return False
DCSP if value.startswith ( &apos; = &apos; ) : DCNL DCSP DCSP value = value &#91; len ( &apos; = &apos; ) : &#93; DCNL DCSP if ( len ( value ) &lt; 1 ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP global globalDictionaryOperatorBegin DCNL DCSP uniqueQuoteIndex = 0 DCNL DCSP word = &apos; &apos; DCNL DCSP quoteString = None DCNL DCSP quoteDictionary = { } DCNL DCSP for characterIndex in xrange ( len ( value ) ) : DCNL DCSP DCSP character = value &#91; characterIndex &#93; DCNL DCSP DCSP if ( ( character = = &apos; &quot; &apos; ) or ( character = = &quot; &apos; &quot; ) ) : DCNL DCSP DCSP DCSP if ( quoteString = = None ) : DCNL DCSP DCSP DCSP DCSP quoteString = &apos; &apos; DCNL DCSP DCSP DCSP elif ( quoteString ! = None ) : DCNL DCSP DCSP DCSP DCSP if ( character = = quoteString &#91; : 1 &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP uniqueQuoteIndex = getUniqueQuoteIndex ( uniqueQuoteIndex , value ) DCNL DCSP DCSP DCSP DCSP DCSP uniqueToken = getTokenByNumber ( uniqueQuoteIndex ) DCNL DCSP DCSP DCSP DCSP DCSP quoteDictionary &#91; uniqueToken &#93; = ( quoteString + character ) DCNL DCSP DCSP DCSP DCSP DCSP character = uniqueToken DCNL DCSP DCSP DCSP DCSP DCSP quoteString = None DCNL DCSP DCSP if ( quoteString = = None ) : DCNL DCSP DCSP DCSP word + = character DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP quoteString + = character DCNL DCSP beginSplitWords = getDictionarySplitWords ( globalDictionaryOperatorBegin , word ) DCNL DCSP global globalSplitDictionaryOperator DCNL DCSP evaluatorSplitWords = &#91; &#93; DCNL DCSP for beginSplitWord in beginSplitWords : DCNL DCSP DCSP if ( beginSplitWord in globalDictionaryOperatorBegin ) : DCNL DCSP DCSP DCSP evaluatorSplitWords.append ( beginSplitWord ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP evaluatorSplitWords + = getDictionarySplitWords ( globalSplitDictionaryOperator , beginSplitWord ) DCNL DCSP for ( evaluatorSplitWordIndex , evaluatorSplitWord ) in enumerate ( evaluatorSplitWords ) : DCNL DCSP DCSP for quoteDictionaryKey in quoteDictionary.keys ( ) : DCNL DCSP DCSP DCSP if ( quoteDictionaryKey in evaluatorSplitWord ) : DCNL DCSP DCSP DCSP DCSP evaluatorSplitWords &#91; evaluatorSplitWordIndex &#93; = evaluatorSplitWord.replace ( quoteDictionaryKey , quoteDictionary &#91; quoteDictionaryKey &#93; ) DCNL DCSP evaluatorTransitionWords = &#91; &#93; DCNL DCSP for evaluatorSplitWord in evaluatorSplitWords : DCNL DCSP DCSP addQuoteWord ( evaluatorTransitionWords , evaluatorSplitWord ) DCNL DCSP return evaluatorTransitionWords
DCSP s = list ( discover ( expr ) .shape ) DCNL DCSP for ( i , elem ) in enumerate ( s ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP s &#91; i &#93; = int ( elem ) DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP pass DCNL DCSP return tuple ( s )
DCSP p = np.zeros ( shape = &#91; 1 , vocabulary _ size &#93; , dtype = np.float ) DCNL DCSP p &#91; ( 0 , sample _ distribution ( prediction &#91; 0 &#93; ) ) &#93; = 1.0 DCNL DCSP return p
DCSP if ( command = = &apos; status &apos; ) : DCNL DCSP DCSP def method ( cmdResult ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Parse DCSP method DCSP for DCSP systemctl DCSP status DCSP XXX.service. \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP True DCSP if DCSP XXX.service DCSP is DCSP running . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP False DCSP if DCSP XXX.service DCSP is DCSP stopped . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP None DCSP if DCSP XXX.service DCSP is DCSP not DCSP loaded . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP output = cmdResult.stdout DCNL DCSP DCSP DCSP if ( not re.search ( &apos; Loaded : DCSP loaded &apos; , output ) ) : DCNL DCSP DCSP DCSP DCSP return None DCNL DCSP DCSP DCSP return ( output.count ( &apos; Active : DCSP active &apos; ) &gt; 0 ) DCNL DCSP DCSP return method DCNL DCSP elif ( command = = &apos; list &apos; ) : DCNL DCSP DCSP def method ( cmdResult ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Parse DCSP method DCSP for DCSP systemctl DCSP list DCSP XXX.service. \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Return DCSP a DCSP dict DCSP from DCSP service DCSP name DCSP to DCSP status . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP e.g : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP { &quot; sshd &quot; : DCSP &quot; enabled &quot; , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; vsftpd &quot; : DCSP &quot; disabled &quot; , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; systemd-sysctl &quot; : DCSP &quot; static &quot; , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ... \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP if cmdResult.exit _ status : DCNL DCSP DCSP DCSP DCSP raise error.CmdError ( cmdResult.command , cmdResult ) DCNL DCSP DCSP DCSP _ service2status _ dict = { } DCNL DCSP DCSP DCSP lines = cmdResult.stdout.strip ( ) .splitlines ( ) DCNL DCSP DCSP DCSP for line in lines : DCNL DCSP DCSP DCSP DCSP sublines = line.strip ( ) .split ( ) DCNL DCSP DCSP DCSP DCSP if ( ( not ( len ( sublines ) = = 2 ) ) or ( not sublines &#91; 0 &#93; .endswith ( &apos; service &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP service _ name = sublines &#91; 0 &#93; .rstrip ( &apos; .service &apos; ) DCNL DCSP DCSP DCSP DCSP status = sublines &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP DCSP _ service2status _ dict &#91; service _ name &#93; = status DCNL DCSP DCSP DCSP return _ service2status _ dict DCNL DCSP DCSP return method DCNL DCSP else : DCNL DCSP DCSP return _ ServiceResultParser.default _ method
DCSP data _ dir = op.join ( op.dirname ( _ _ file _ _ ) , &apos; data &apos; ) DCNL DCSP lut _ fname = op.join ( data _ dir , &apos; FreeSurferColorLUT.txt &apos; ) DCNL DCSP return np.genfromtxt ( lut _ fname , dtype = None , usecols = ( 0 , 1 , 2 , 3 , 4 , 5 ) , names = &#91; &apos; id &apos; , &apos; name &apos; , &apos; R &apos; , &apos; G &apos; , &apos; B &apos; , &apos; A &apos; &#93; )
DCSP t = loader.get _ template ( template _ name ) DCNL DCSP return http.HttpResponseNotFound ( t.render ( RequestContext ( request , { &apos; request _ path &apos; : request.path } ) ) )
DCSP wheel _ file = data.packages.join ( &apos; simple.dist-0.1-py2.py3-none-any.whl &apos; ) DCNL DCSP script.pip ( &apos; install &apos; , &apos; --no-index &apos; , wheel _ file ) DCNL DCSP result = script.pip ( &apos; show &apos; , &apos; --verbose &apos; , &apos; simple.dist &apos; ) DCNL DCSP lines = result.stdout.splitlines ( ) DCNL DCSP assert ( &apos; Name : DCSP simple.dist &apos; in lines ) DCNL DCSP assert ( &apos; Installer : DCSP pip &apos; in lines )
DCSP f = sympify ( f ) DCNL DCSP if ( not f.is _ polynomial ( n ) ) : DCNL DCSP DCSP return None DCNL DCSP homogeneous = f.is _ zero DCNL DCSP r = ( len ( coeffs ) - 1 ) DCNL DCSP coeffs = &#91; Poly ( coeff , n ) for coeff in coeffs &#93; DCNL DCSP polys = ( &#91; Poly ( 0 , n ) &#93; * ( r + 1 ) ) DCNL DCSP terms = ( &#91; ( S.Zero , S.NegativeInfinity ) &#93; * ( r + 1 ) ) DCNL DCSP for i in range ( 0 , ( r + 1 ) ) : DCNL DCSP DCSP for j in range ( i , ( r + 1 ) ) : DCNL DCSP DCSP DCSP polys &#91; i &#93; + = ( coeffs &#91; j &#93; * binomial ( j , i ) ) DCNL DCSP DCSP if ( not polys &#91; i &#93; .is _ zero ) : DCNL DCSP DCSP DCSP ( ( exp , ) , coeff ) = polys &#91; i &#93; .LT ( ) DCNL DCSP DCSP DCSP terms &#91; i &#93; = ( coeff , exp ) DCNL DCSP d = b = terms &#91; 0 &#93; &#91; 1 &#93; DCNL DCSP for i in range ( 1 , ( r + 1 ) ) : DCNL DCSP DCSP if ( terms &#91; i &#93; &#91; 1 &#93; &gt; d ) : DCNL DCSP DCSP DCSP d = terms &#91; i &#93; &#91; 1 &#93; DCNL DCSP DCSP if ( ( terms &#91; i &#93; &#91; 1 &#93; - i ) &gt; b ) : DCNL DCSP DCSP DCSP b = ( terms &#91; i &#93; &#91; 1 &#93; - i ) DCNL DCSP ( d , b ) = ( int ( d ) , int ( b ) ) DCNL DCSP x = Dummy ( &apos; x &apos; ) DCNL DCSP degree _ poly = S.Zero DCNL DCSP for i in range ( 0 , ( r + 1 ) ) : DCNL DCSP DCSP if ( ( terms &#91; i &#93; &#91; 1 &#93; - i ) = = b ) : DCNL DCSP DCSP DCSP degree _ poly + = ( terms &#91; i &#93; &#91; 0 &#93; * FallingFactorial ( x , i ) ) DCNL DCSP nni _ roots = list ( roots ( degree _ poly , x , filter = &apos; Z &apos; , predicate = ( lambda r : ( r &gt; = 0 ) ) ) .keys ( ) ) DCNL DCSP if nni _ roots : DCNL DCSP DCSP N = &#91; max ( nni _ roots ) &#93; DCNL DCSP else : DCNL DCSP DCSP N = &#91; &#93; DCNL DCSP if homogeneous : DCNL DCSP DCSP N + = &#91; ( ( - b ) - 1 ) &#93; DCNL DCSP else : DCNL DCSP DCSP N + = &#91; ( f.as _ poly ( n ) .degree ( ) - b ) , ( ( - b ) - 1 ) &#93; DCNL DCSP N = int ( max ( N ) ) DCNL DCSP if ( N &lt; 0 ) : DCNL DCSP DCSP if homogeneous : DCNL DCSP DCSP DCSP if hints.get ( &apos; symbols &apos; , False ) : DCNL DCSP DCSP DCSP DCSP return ( S.Zero , &#91; &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return S.Zero DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP if ( N &lt; = r ) : DCNL DCSP DCSP C = &#91; &#93; DCNL DCSP DCSP y = E = S.Zero DCNL DCSP DCSP for i in range ( 0 , ( N + 1 ) ) : DCNL DCSP DCSP DCSP C.append ( Symbol ( ( &apos; C &apos; + str ( i ) ) ) ) DCNL DCSP DCSP DCSP y + = ( C &#91; i &#93; * ( n * * i ) ) DCNL DCSP DCSP for i in range ( 0 , ( r + 1 ) ) : DCNL DCSP DCSP DCSP E + = ( coeffs &#91; i &#93; .as _ expr ( ) * y.subs ( n , ( n + i ) ) ) DCNL DCSP DCSP solutions = solve _ undetermined _ coeffs ( ( E - f ) , C , n ) DCNL DCSP DCSP if ( solutions is not None ) : DCNL DCSP DCSP DCSP C = &#91; c for c in C if ( c not in solutions ) &#93; DCNL DCSP DCSP DCSP result = y.subs ( solutions ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP else : DCNL DCSP DCSP A = r DCNL DCSP DCSP U = ( ( ( N + A ) + b ) + 1 ) DCNL DCSP DCSP nni _ roots = list ( roots ( polys &#91; r &#93; , filter = &apos; Z &apos; , predicate = ( lambda r : ( r &gt; = 0 ) ) ) .keys ( ) ) DCNL DCSP DCSP if ( nni _ roots ! = &#91; &#93; ) : DCNL DCSP DCSP DCSP a = ( max ( nni _ roots ) + 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP a = S.Zero DCNL DCSP DCSP def _ zero _ vector ( k ) : DCNL DCSP DCSP DCSP return ( &#91; S.Zero &#93; * k ) DCNL DCSP DCSP def _ one _ vector ( k ) : DCNL DCSP DCSP DCSP return ( &#91; S.One &#93; * k ) DCNL DCSP DCSP def _ delta ( p , k ) : DCNL DCSP DCSP DCSP B = S.One DCNL DCSP DCSP DCSP D = p.subs ( n , ( a + k ) ) DCNL DCSP DCSP DCSP for i in range ( 1 , ( k + 1 ) ) : DCNL DCSP DCSP DCSP DCSP B * = ( - Rational ( ( ( k - i ) + 1 ) , i ) ) DCNL DCSP DCSP DCSP DCSP D + = ( B * p.subs ( n , ( ( a + k ) - i ) ) ) DCNL DCSP DCSP DCSP return D DCNL DCSP DCSP alpha = { } DCNL DCSP DCSP for i in range ( ( - A ) , ( d + 1 ) ) : DCNL DCSP DCSP DCSP I = _ one _ vector ( ( d + 1 ) ) DCNL DCSP DCSP DCSP for k in range ( 1 , ( d + 1 ) ) : DCNL DCSP DCSP DCSP DCSP I &#91; k &#93; = ( ( I &#91; ( k - 1 ) &#93; * ( ( ( x + i ) - k ) + 1 ) ) / k ) DCNL DCSP DCSP DCSP alpha &#91; i &#93; = S.Zero DCNL DCSP DCSP DCSP for j in range ( 0 , ( A + 1 ) ) : DCNL DCSP DCSP DCSP DCSP for k in range ( 0 , ( d + 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP B = binomial ( k , ( i + j ) ) DCNL DCSP DCSP DCSP DCSP DCSP D = _ delta ( polys &#91; j &#93; .as _ expr ( ) , k ) DCNL DCSP DCSP DCSP DCSP DCSP alpha &#91; i &#93; + = ( ( I &#91; k &#93; * B ) * D ) DCNL DCSP DCSP V = Matrix ( U , A , ( lambda i , j : int ( ( i = = j ) ) ) ) DCNL DCSP DCSP if homogeneous : DCNL DCSP DCSP DCSP for i in range ( A , U ) : DCNL DCSP DCSP DCSP DCSP v = _ zero _ vector ( A ) DCNL DCSP DCSP DCSP DCSP for k in range ( 1 , ( ( A + b ) + 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( i - k ) &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP B = alpha &#91; ( k - A ) &#93; .subs ( x , ( i - k ) ) DCNL DCSP DCSP DCSP DCSP DCSP for j in range ( 0 , A ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP v &#91; j &#93; + = ( B * V &#91; ( ( i - k ) , j ) &#93; ) DCNL DCSP DCSP DCSP DCSP denom = alpha &#91; ( - A ) &#93; .subs ( x , i ) DCNL DCSP DCSP DCSP DCSP for j in range ( 0 , A ) : DCNL DCSP DCSP DCSP DCSP DCSP V &#91; ( i , j ) &#93; = ( ( - v &#91; j &#93; ) / denom ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP G = _ zero _ vector ( U ) DCNL DCSP DCSP DCSP for i in range ( A , U ) : DCNL DCSP DCSP DCSP DCSP v = _ zero _ vector ( A ) DCNL DCSP DCSP DCSP DCSP g = S.Zero DCNL DCSP DCSP DCSP DCSP for k in range ( 1 , ( ( A + b ) + 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( i - k ) &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP B = alpha &#91; ( k - A ) &#93; .subs ( x , ( i - k ) ) DCNL DCSP DCSP DCSP DCSP DCSP for j in range ( 0 , A ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP v &#91; j &#93; + = ( B * V &#91; ( ( i - k ) , j ) &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP g + = ( B * G &#91; ( i - k ) &#93; ) DCNL DCSP DCSP DCSP DCSP denom = alpha &#91; ( - A ) &#93; .subs ( x , i ) DCNL DCSP DCSP DCSP DCSP for j in range ( 0 , A ) : DCNL DCSP DCSP DCSP DCSP DCSP V &#91; ( i , j ) &#93; = ( ( - v &#91; j &#93; ) / denom ) DCNL DCSP DCSP DCSP DCSP G &#91; i &#93; = ( ( _ delta ( f , ( i - A ) ) - g ) / denom ) DCNL DCSP DCSP ( P , Q ) = ( _ one _ vector ( U ) , _ zero _ vector ( A ) ) DCNL DCSP DCSP for i in range ( 1 , U ) : DCNL DCSP DCSP DCSP P &#91; i &#93; = ( ( P &#91; ( i - 1 ) &#93; * ( ( ( n - a ) - i ) + 1 ) ) / i ) .expand ( ) DCNL DCSP DCSP for i in range ( 0 , A ) : DCNL DCSP DCSP DCSP Q &#91; i &#93; = Add ( * &#91; ( v * p ) .expand ( ) for ( v , p ) in zip ( V &#91; : , i &#93; , P ) &#93; ) DCNL DCSP DCSP if ( not homogeneous ) : DCNL DCSP DCSP DCSP h = Add ( * &#91; ( g * p ) .expand ( ) for ( g , p ) in zip ( G , P ) &#93; ) DCNL DCSP DCSP C = &#91; Symbol ( ( &apos; C &apos; + str ( i ) ) ) for i in range ( 0 , A ) &#93; DCNL DCSP DCSP g = ( lambda i : Add ( * &#91; ( c * _ delta ( q , i ) ) for ( c , q ) in zip ( C , Q ) &#93; ) ) DCNL DCSP DCSP if homogeneous : DCNL DCSP DCSP DCSP E = &#91; g ( i ) for i in range ( ( N + 1 ) , U ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP E = &#91; ( g ( i ) + _ delta ( h , i ) ) for i in range ( ( N + 1 ) , U ) &#93; DCNL DCSP DCSP if ( E ! = &#91; &#93; ) : DCNL DCSP DCSP DCSP solutions = solve ( E , * C ) DCNL DCSP DCSP DCSP if ( not solutions ) : DCNL DCSP DCSP DCSP DCSP if homogeneous : DCNL DCSP DCSP DCSP DCSP DCSP if hints.get ( &apos; symbols &apos; , False ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return ( S.Zero , &#91; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return S.Zero DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP solutions = { } DCNL DCSP DCSP if homogeneous : DCNL DCSP DCSP DCSP result = S.Zero DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = h DCNL DCSP DCSP for ( c , q ) in list ( zip ( C , Q ) ) : DCNL DCSP DCSP DCSP if ( c in solutions ) : DCNL DCSP DCSP DCSP DCSP s = ( solutions &#91; c &#93; * q ) DCNL DCSP DCSP DCSP DCSP C.remove ( c ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP s = ( c * q ) DCNL DCSP DCSP DCSP result + = s.expand ( ) DCNL DCSP if hints.get ( &apos; symbols &apos; , False ) : DCNL DCSP DCSP return ( result , C ) DCNL DCSP else : DCNL DCSP DCSP return result
DCSP if six.PY3 : DCNL DCSP DCSP b = salt.utils.to _ bytes ( instr ) DCNL DCSP DCSP b64 = base64.encodebytes ( b ) DCNL DCSP DCSP return salt.utils.to _ str ( b64 ) DCNL DCSP return base64.encodestring ( instr )
DCSP from mavflightview import mavflightview _ mav , mavflightview _ options DCNL DCSP options = mavflightview _ options ( ) DCNL DCSP options.condition = mestate.settings.condition DCNL DCSP options . _ flightmodes = mestate.mlog. _ flightmodes DCNL DCSP options.show _ flightmode _ legend = mestate.settings.show _ flightmode DCNL DCSP if ( len ( args ) &gt; 0 ) : DCNL DCSP DCSP options.types = &apos; , &apos; .join ( args ) DCNL DCSP &#91; path , wp , fen , used _ flightmodes &#93; = mavflightview _ mav ( mestate.mlog , options , mestate.flightmode _ selections ) DCNL DCSP child = multiprocessing.Process ( target = map _ process , args = &#91; path , wp , fen , used _ flightmodes , options &#93; ) DCNL DCSP child.start ( ) DCNL DCSP mestate.mlog.rewind ( )
DCSP ret = salt.utils.mac _ utils.execute _ return _ result ( &apos; systemsetup DCSP -getdisablekeyboardwhenenclosurelockisengaged &apos; ) DCNL DCSP enabled = salt.utils.mac _ utils.validate _ enabled ( salt.utils.mac _ utils.parse _ return ( ret ) ) DCNL DCSP return ( enabled = = &apos; on &apos; )
DCSP user = get _ effective _ user ( request.user , username ) DCNL DCSP return get _ course _ overview _ with _ access ( user , get _ permission _ for _ course _ about ( ) , course _ key )
DCSP cache = linecache.cache DCNL DCSP save = { } DCNL DCSP for filename in cache.keys ( ) : DCNL DCSP DCSP if ( ( filename &#91; : 1 &#93; + filename &#91; ( -1 ) : &#93; ) = = &apos; &lt; &gt; &apos; ) : DCNL DCSP DCSP DCSP save &#91; filename &#93; = cache &#91; filename &#93; DCNL DCSP orig _ checkcache ( ) DCNL DCSP cache.update ( save )
DCSP columnDim = pySp . _ columnDimensions DCNL DCSP inputDim = pySp . _ inputDimensions DCNL DCSP numInputs = pySp.getNumInputs ( ) DCNL DCSP numColumns = pySp.getNumColumns ( ) DCNL DCSP cppSp = CPPSpatialPooler ( inputDim , columnDim ) DCNL DCSP cppSp.setPotentialRadius ( pySp.getPotentialRadius ( ) ) DCNL DCSP cppSp.setPotentialPct ( pySp.getPotentialPct ( ) ) DCNL DCSP cppSp.setGlobalInhibition ( pySp.getGlobalInhibition ( ) ) DCNL DCSP numActiveColumnsPerInhArea = pySp.getNumActiveColumnsPerInhArea ( ) DCNL DCSP localAreaDensity = pySp.getLocalAreaDensity ( ) DCNL DCSP if ( numActiveColumnsPerInhArea &gt; 0 ) : DCNL DCSP DCSP cppSp.setNumActiveColumnsPerInhArea ( numActiveColumnsPerInhArea ) DCNL DCSP else : DCNL DCSP DCSP cppSp.setLocalAreaDensity ( localAreaDensity ) DCNL DCSP cppSp.setStimulusThreshold ( pySp.getStimulusThreshold ( ) ) DCNL DCSP cppSp.setInhibitionRadius ( pySp.getInhibitionRadius ( ) ) DCNL DCSP cppSp.setDutyCyclePeriod ( pySp.getDutyCyclePeriod ( ) ) DCNL DCSP cppSp.setBoostStrength ( pySp.getBoostStrength ( ) ) DCNL DCSP cppSp.setIterationNum ( pySp.getIterationNum ( ) ) DCNL DCSP cppSp.setIterationLearnNum ( pySp.getIterationLearnNum ( ) ) DCNL DCSP cppSp.setSpVerbosity ( pySp.getSpVerbosity ( ) ) DCNL DCSP cppSp.setUpdatePeriod ( pySp.getUpdatePeriod ( ) ) DCNL DCSP cppSp.setSynPermTrimThreshold ( pySp.getSynPermTrimThreshold ( ) ) DCNL DCSP cppSp.setSynPermActiveInc ( pySp.getSynPermActiveInc ( ) ) DCNL DCSP cppSp.setSynPermInactiveDec ( pySp.getSynPermInactiveDec ( ) ) DCNL DCSP cppSp.setSynPermBelowStimulusInc ( pySp.getSynPermBelowStimulusInc ( ) ) DCNL DCSP cppSp.setSynPermConnected ( pySp.getSynPermConnected ( ) ) DCNL DCSP cppSp.setMinPctOverlapDutyCycles ( pySp.getMinPctOverlapDutyCycles ( ) ) DCNL DCSP boostFactors = numpy.zeros ( numColumns ) .astype ( realType ) DCNL DCSP pySp.getBoostFactors ( boostFactors ) DCNL DCSP cppSp.setBoostFactors ( boostFactors ) DCNL DCSP overlapDuty = numpy.zeros ( numColumns ) .astype ( realType ) DCNL DCSP pySp.getOverlapDutyCycles ( overlapDuty ) DCNL DCSP cppSp.setOverlapDutyCycles ( overlapDuty ) DCNL DCSP activeDuty = numpy.zeros ( numColumns ) .astype ( realType ) DCNL DCSP pySp.getActiveDutyCycles ( activeDuty ) DCNL DCSP cppSp.setActiveDutyCycles ( activeDuty ) DCNL DCSP minOverlapDuty = numpy.zeros ( numColumns ) .astype ( realType ) DCNL DCSP pySp.getMinOverlapDutyCycles ( minOverlapDuty ) DCNL DCSP cppSp.setMinOverlapDutyCycles ( minOverlapDuty ) DCNL DCSP for i in xrange ( numColumns ) : DCNL DCSP DCSP potential = numpy.zeros ( numInputs ) .astype ( uintType ) DCNL DCSP DCSP pySp.getPotential ( i , potential ) DCNL DCSP DCSP cppSp.setPotential ( i , potential ) DCNL DCSP DCSP perm = numpy.zeros ( numInputs ) .astype ( realType ) DCNL DCSP DCSP pySp.getPermanence ( i , perm ) DCNL DCSP DCSP cppSp.setPermanence ( i , perm ) DCNL DCSP pySp . _ random = NupicRandom ( newSeed ) DCNL DCSP cppSp.seed _ ( newSeed ) DCNL DCSP return cppSp
DCSP cmd = &apos; SELECT DCSP name DCSP FROM DCSP { 0 } &apos; .format ( queue ) DCNL DCSP if ( quantity ! = &apos; all &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP quantity = int ( quantity ) DCNL DCSP DCSP except ValueError as exc : DCNL DCSP DCSP DCSP error _ txt = &apos; Quantity DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP &quot; all &quot; . \ nError : DCSP &quot; { 0 } &quot; . &apos; .format ( exc ) DCNL DCSP DCSP DCSP raise SaltInvocationError ( error _ txt ) DCNL DCSP DCSP cmd = &apos; &apos;.join ( &#91; cmd , &apos; DCSP LIMIT DCSP { 0 } &apos; .format ( quantity ) &#93; ) DCNL DCSP log.debug ( &apos; SQL DCSP Query : DCSP { 0 } &apos; .format ( cmd ) ) DCNL DCSP con = _ conn ( queue ) DCNL DCSP items = &#91; &#93; DCNL DCSP with con : DCNL DCSP DCSP cur = con.cursor ( ) DCNL DCSP DCSP result = cur.execute ( cmd ) .fetchall ( ) DCNL DCSP DCSP if ( len ( result ) &gt; 0 ) : DCNL DCSP DCSP DCSP items = &#91; item &#91; 0 &#93; for item in result &#93; DCNL DCSP DCSP DCSP itemlist = &apos; &quot; , &quot; &apos; .join ( items ) DCNL DCSP DCSP DCSP _ quote _ escape ( itemlist ) DCNL DCSP DCSP DCSP del _ cmd = &apos; DELETE DCSP FROM DCSP { 0 } DCSP WHERE DCSP name DCSP IN DCSP ( &quot; { 1 } &quot; ) &apos; .format ( queue , itemlist ) DCNL DCSP DCSP DCSP log.debug ( &apos; SQL DCSP Query : DCSP { 0 } &apos; .format ( del _ cmd ) ) DCNL DCSP DCSP DCSP cur.execute ( del _ cmd ) DCNL DCSP DCSP con.commit ( ) DCNL DCSP log.info ( items ) DCNL DCSP return items
DCSP if ( not hasattr ( f , &apos; resource _ manager _ kwargs _ hooks &apos; ) ) : DCNL DCSP DCSP f.resource _ manager _ kwargs _ hooks = &#91; &#93; DCNL DCSP names = &#91; h . _ _ name _ _ for h in f.resource _ manager _ kwargs _ hooks &#93; DCNL DCSP if ( hook . _ _ name _ _ not in names ) : DCNL DCSP DCSP f.resource _ manager _ kwargs _ hooks.append ( hook )
DCSP assert ( u.fbarn is u.femtobarn ) DCNL DCSP assert ( u.pbarn is u.picobarn )
DCSP locations = &#91; &#93; DCNL DCSP if ( request.GET and ( &apos; term &apos; in request.GET ) ) : DCNL DCSP DCSP user = request.user.profile DCNL DCSP DCSP locations = Object.filter _ permitted ( user , Location.objects , mode = &apos; x &apos; ) .filter ( Q ( name _ _ icontains = request.GET &#91; &apos; term &apos; &#93; ) ) &#91; : 10 &#93; DCNL DCSP return render _ to _ response ( &apos; identities / ajax _ location _ lookup &apos; , { &apos; locations &apos; : locations } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP server = _ connect ( host , port , db , password ) DCNL DCSP try : DCNL DCSP DCSP return server.ping ( ) DCNL DCSP except redis.ConnectionError : DCNL DCSP DCSP return False
DCSP schema = get _ schema ( ) DCNL DCSP deserializer = RequestDeserializer ( schema ) DCNL DCSP serializer = ResponseSerializer ( schema ) DCNL DCSP controller = ResourceTypeController ( ) DCNL DCSP return wsgi.Resource ( controller , deserializer , serializer )
DCSP if ( irc _ bot is None ) : DCNL DCSP DCSP console ( u &apos;irc _ bot DCSP is DCSP not DCSP installed . DCSP install DCSP using DCSP `pip DCSP install DCSP irc _ bot` . &apos; ) DCNL DCSP DCSP return DCNL DCSP if ( hasattr ( options , u &apos;table _ type &apos; ) and ( options.table _ type = = u &apos;porcelain &apos; ) ) : DCNL DCSP DCSP disable _ all _ colors ( ) DCNL DCSP action _ map = { u &apos;status &apos; : action _ status , u &apos;restart &apos; : action _ restart , u &apos;stop &apos; : action _ stop } DCNL DCSP from flexget.plugins.daemon.irc import irc _ manager DCNL DCSP if ( irc _ manager is None ) : DCNL DCSP DCSP console ( u &apos;IRC DCSP daemon DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP running . &apos; ) DCNL DCSP DCSP return DCNL DCSP action _ map &#91; options.irc _ action &#93; ( options , irc _ manager )
DCSP if ( len ( args ) = = 1 ) : DCNL DCSP DCSP image _ id = args.pop ( ) DCNL DCSP else : DCNL DCSP DCSP print ( &apos; Please DCSP specify DCSP one DCSP and DCSP only DCSP ID DCSP of DCSP the DCSP image DCSP you DCSP wish DCSP to DCSP &apos; ) DCNL DCSP DCSP print ( &apos; queue DCSP from DCSP the DCSP cache DCSP as DCSP the DCSP first DCSP argument &apos; ) DCNL DCSP DCSP return FAILURE DCNL DCSP if ( ( not options.force ) and ( not user _ confirm ( ( &apos; Queue DCSP image DCSP % ( image _ id ) s DCSP for DCSP caching ? &apos; % { &apos; image _ id &apos; : image _ id } ) , default = False ) ) ) : DCNL DCSP DCSP return SUCCESS DCNL DCSP client = get _ client ( options ) DCNL DCSP client.queue _ image _ for _ caching ( image _ id ) DCNL DCSP if options.verbose : DCNL DCSP DCSP print ( ( &apos; Queued DCSP image DCSP % ( image _ id ) s DCSP for DCSP caching &apos; % { &apos; image _ id &apos; : image _ id } ) ) DCNL DCSP return SUCCESS
DCSP if ( &apos; zenoss.add _ device &apos; in _ _ salt _ _ ) : DCNL DCSP DCSP return &apos; zenoss&apos;
DCSP assert isinstance ( x , np.ndarray ) DCNL DCSP rval = hashlib.md5 ( x.tostring ( ) ) .hexdigest ( ) DCNL DCSP rval = ( ( ( rval + &apos; &#124; strides = &#91; &apos; ) + &apos; , &apos; .join ( ( str ( stride ) for stride in x.strides ) ) ) + &apos; &#93; &apos; ) DCNL DCSP rval = ( ( ( rval + &apos; &#124; shape = &#91; &apos; ) + &apos; , &apos; .join ( ( str ( s ) for s in x.shape ) ) ) + &apos; &#93; &apos; ) DCNL DCSP return rval
DCSP assert text.startswith ( substring ) , ( &quot; % r DCSP doesn &apos;t DCSP start DCSP with DCSP % r &quot; % ( text , substring ) )
DCSP return _ apply _ scalar _ per _ pixel ( generic _ cy . _ minimum , image , selem , out = out , mask = mask , shift _ x = shift _ x , shift _ y = shift _ y )
DCSP counter = &#91; 0 for _ in range ( 256 ) &#93; DCNL DCSP for pkt in packets : DCNL DCSP DCSP if ( ( - position ) &lt; = len ( pkt ) ) : DCNL DCSP DCSP DCSP counter &#91; ord ( pkt &#91; position &#93; ) &#93; + = 1 DCNL DCSP entropy = 0 DCNL DCSP length = len ( packets ) DCNL DCSP for count in counter : DCNL DCSP DCSP if ( count &gt; 0 ) : DCNL DCSP DCSP DCSP ratio = ( float ( count ) / length ) DCNL DCSP DCSP DCSP entropy - = ( ratio * math.log ( ratio , 2 ) ) DCNL DCSP return entropy
DCSP record _ id = record &#91; &apos; hrm _ competency.id &apos; &#93; DCNL DCSP item _ class = &apos; thumbnail &apos; DCNL DCSP raw = record . _ row DCNL DCSP title = record &#91; &apos; hrm _ competency.skill _ id &apos; &#93; DCNL DCSP organisation = ( raw &#91; &apos; hrm _ competency.organisation _ id &apos; &#93; or &apos; &apos; ) DCNL DCSP if organisation : DCNL DCSP DCSP org _ url = URL ( c = &apos; org &apos; , f = &apos; organisation &apos; , args = &#91; organisation &#93; ) DCNL DCSP DCSP organisation = P ( ICON ( &apos; organisation &apos; ) , &apos; DCSP &apos; , SPAN ( A ( record &#91; &apos; hrm _ competency.organisation _ id &apos; &#93; , _ href = org _ url ) ) , &apos; DCSP &apos; , _ class = &apos; card _ 1 _ line &apos; ) DCNL DCSP competency = ( raw &#91; &apos; hrm _ competency.competency _ id &apos; &#93; or &apos; &apos; ) DCNL DCSP if competency : DCNL DCSP DCSP competency = P ( ICON ( &apos; certificate &apos; ) , &apos; DCSP &apos; , SPAN ( record &#91; &apos; hrm _ competency.competency _ id &apos; &#93; ) , &apos; DCSP &apos; , _ class = &apos; card _ 1 _ line &apos; ) DCNL DCSP comments = ( raw &#91; &apos; hrm _ competency.comments &apos; &#93; or &apos; &apos; ) DCNL DCSP permit = current.auth.s3 _ has _ permission DCNL DCSP table = current.s3db.hrm _ competency DCNL DCSP if permit ( &apos; update &apos; , table , record _ id = record _ id ) : DCNL DCSP DCSP controller = current.request.controller DCNL DCSP DCSP if ( controller not in ( &apos; vol &apos; , &apos; deploy &apos; ) ) : DCNL DCSP DCSP DCSP controller = &apos; hrm &apos; DCNL DCSP DCSP edit _ btn = A ( ICON ( &apos; edit &apos; ) , _ href = URL ( c = controller , f = &apos; competency &apos; , args = &#91; record _ id , &apos; update.popup &apos; &#93; , vars = { &apos; refresh &apos; : list _ id , &apos; record &apos; : record _ id } ) , _ class = &apos; s3 _ modal &apos; , _ title = current.T ( &apos; Edit DCSP Skill &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP edit _ btn = &apos; &apos; DCNL DCSP if permit ( &apos; delete &apos; , table , record _ id = record _ id ) : DCNL DCSP DCSP delete _ btn = A ( ICON ( &apos; delete &apos; ) , _ class = &apos; dl-item-delete &apos; ) DCNL DCSP else : DCNL DCSP DCSP delete _ btn = &apos; &apos; DCNL DCSP edit _ bar = DIV ( edit _ btn , delete _ btn , _ class = &apos; edit-bar DCSP fright &apos; ) DCNL DCSP item = DIV ( DIV ( ICON ( &apos; icon &apos; ) , SPAN ( ( &apos; DCSP % s &apos; % title ) , _ class = &apos; card-title &apos; ) , edit _ bar , _ class = &apos; card-header &apos; ) , DIV ( DIV ( DIV ( organisation , competency , P ( SPAN ( comments ) , &apos; DCSP &apos; , _ class = &apos; card _ manylines &apos; ) , _ class = &apos; media &apos; ) , _ class = &apos; media-body &apos; ) , _ class = &apos; media &apos; ) , _ class = item _ class , _ id = item _ id ) DCNL DCSP return item
DCSP return stubsmod
DCSP safe _ str = &apos; &apos; DCNL DCSP if ( not is _ path _ browsable ( app , file _ path , repository _ id , is _ admin ) ) : DCNL DCSP DCSP log.warning ( &apos; Request DCSP tries DCSP to DCSP access DCSP a DCSP file DCSP outside DCSP of DCSP the DCSP repository DCSP location . DCSP File DCSP path : DCSP % s &apos; , file _ path ) DCNL DCSP DCSP return &apos; Invalid DCSP file DCSP path &apos; DCNL DCSP if os.path.islink ( file _ path ) : DCNL DCSP DCSP safe _ str = ( &apos; link DCSP to : DCSP &apos; + basic _ util.to _ html _ string ( os.readlink ( file _ path ) ) ) DCNL DCSP DCSP return safe _ str DCNL DCSP elif checkers.is _ gzip ( file _ path ) : DCNL DCSP DCSP return &apos; &lt; br / &gt; gzip DCSP compressed DCSP file &lt; br / &gt; &apos; DCNL DCSP elif checkers.is _ bz2 ( file _ path ) : DCNL DCSP DCSP return &apos; &lt; br / &gt; bz2 DCSP compressed DCSP file &lt; br / &gt; &apos; DCNL DCSP elif checkers.check _ zip ( file _ path ) : DCNL DCSP DCSP return &apos; &lt; br / &gt; zip DCSP compressed DCSP file &lt; br / &gt; &apos; DCNL DCSP elif checkers.check _ binary ( file _ path ) : DCNL DCSP DCSP return &apos; &lt; br / &gt; Binary DCSP file &lt; br / &gt; &apos; DCNL DCSP else : DCNL DCSP DCSP for ( i , line ) in enumerate ( open ( file _ path ) ) : DCNL DCSP DCSP DCSP safe _ str = ( &apos; % s % s &apos; % ( safe _ str , basic _ util.to _ html _ string ( line ) ) ) DCNL DCSP DCSP DCSP if ( len ( safe _ str ) &gt; MAX _ CONTENT _ SIZE ) : DCNL DCSP DCSP DCSP DCSP large _ str = ( &apos; &lt; br / &gt; File DCSP contents DCSP truncated DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP % s &lt; br / &gt; &apos; % util.nice _ size ( MAX _ CONTENT _ SIZE ) ) DCNL DCSP DCSP DCSP DCSP safe _ str = ( &apos; % s % s &apos; % ( safe _ str , large _ str ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if ( len ( safe _ str ) &gt; basic _ util.MAX _ DISPLAY _ SIZE ) : DCNL DCSP DCSP DCSP join _ by _ str = ( &apos; &lt; br / &gt; &lt; br / &gt; ... some DCSP text DCSP eliminated DCSP here DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP % s ... &lt; br / &gt; &lt; br / &gt; &apos; % util.nice _ size ( basic _ util.MAX _ DISPLAY _ SIZE ) ) DCNL DCSP DCSP DCSP safe _ str = util.shrink _ string _ by _ size ( safe _ str , basic _ util.MAX _ DISPLAY _ SIZE , join _ by = join _ by _ str , left _ larger = True , beginning _ on _ size _ error = True ) DCNL DCSP DCSP return safe _ str
DCSP return read _ stored _ info ( target , field = &apos; sha1 &apos; , timestamped = timestamped )
DCSP library _ dirs = &#91; &#93; DCNL DCSP library _ pattern = os.path.join ( os.path.dirname ( os.path.dirname ( google . _ _ file _ _ ) ) , _ THIRD _ PARTY _ LIBRARY _ FORMAT _ STRING ) DCNL DCSP for library in libraries : DCNL DCSP DCSP library _ dir = os.path.abspath ( ( library _ pattern % { &apos; name &apos; : library.name , &apos; version &apos; : library.version } ) ) DCNL DCSP DCSP library _ dirs.append ( library _ dir ) DCNL DCSP return library _ dirs
DCSP expiration _ ms = 0 DCNL DCSP if expiration : DCNL DCSP DCSP delta = ( expiration - EPOCH ) DCNL DCSP DCSP expiration _ ms = ( ( delta.microseconds / 1000 ) + ( ( delta.seconds + ( ( delta.days * 24 ) * 3600 ) ) * 1000 ) ) DCNL DCSP DCSP if ( expiration _ ms &lt; 0 ) : DCNL DCSP DCSP DCSP expiration _ ms = 0 DCNL DCSP return Channel ( &apos; web _ hook &apos; , str ( uuid.uuid4 ( ) ) , token , url , expiration = expiration _ ms , params = params )
DCSP if ( TAG _ ENV not in os.environ ) : DCNL DCSP DCSP print ( ERROR _ MSG , file = sys.stderr ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP tag _ name = os.environ &#91; TAG _ ENV &#93; DCNL DCSP match = TAG _ RE.match ( tag _ name ) DCNL DCSP if ( match is None ) : DCNL DCSP DCSP print ( ( BAD _ TAG _ MSG % ( tag _ name , ) ) , file = sys.stderr ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP pkg _ name = match.group ( &apos; pkg &apos; ) DCNL DCSP if ( pkg _ name is None ) : DCNL DCSP DCSP print ( ROOT _ DIR ) DCNL DCSP else : DCNL DCSP DCSP pkg _ dir = pkg _ name.rstrip ( &apos; -&apos; ) .replace ( &apos; -&apos; , &apos; _ &apos; ) DCNL DCSP DCSP print ( os.path.join ( ROOT _ DIR , pkg _ dir ) )
DCSP fake _ headers _ mobile = { &apos; Accept &apos; : &apos; text / html , application / xhtml + xml , application / xml ; q = 0.9 , * / * ; q = 0.8 &apos; , &apos; Accept-Charset &apos; : &apos; UTF-8 , * ; q = 0.5 &apos; , &apos; Accept-Encoding &apos; : &apos; gzip , deflate , sdch &apos; , &apos; Accept-Language &apos; : &apos; en-US , en ; q = 0.8 &apos; , &apos; User-Agent &apos; : &apos; Mozilla / 5.0 DCSP ( Linux ; DCSP Android DCSP 4.4.2 ; DCSP Nexus DCSP 4 DCSP Build / KOT49H ) DCSP AppleWebKit / 537.36 DCSP ( KHTML , DCSP like DCSP Gecko ) DCSP Chrome / 34.0.1847.114 DCSP Mobile DCSP Safari / 537.36 &apos; } DCNL DCSP webpage _ url = ( &apos; https : / / www.showroom-live.com / &apos; + room _ url _ key ) DCNL DCSP html = get _ content ( webpage _ url , headers = fake _ headers _ mobile ) DCNL DCSP roomid = match1 ( html , &apos; room \ \ ? room _ id \ \ = ( \ \ d + ) &apos; ) DCNL DCSP assert roomid DCNL DCSP return roomid
DCSP datastruct = deserialize _ raw ( collection.collection _ type ( ) ) DCNL DCSP if ( topological and ( type ( datastruct ) = = list ) ) : DCNL DCSP DCSP datastruct.sort ( _ _ depth _ cmp ) DCNL DCSP if ( type ( datastruct ) = = dict ) : DCNL DCSP DCSP collection.from _ dict ( datastruct ) DCNL DCSP elif ( type ( datastruct ) = = list ) : DCNL DCSP DCSP collection.from _ list ( datastruct )
DCSP cmd = &apos; { 0 } DCSP -S DCSP -n &apos; .format ( _ _ detect _ os ( ) ) DCNL DCSP ret = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP return ret
DCSP if ( auth.is _ logged _ in ( ) or auth.basic ( ) ) : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP redirect ( URL ( c = &apos; default &apos; , f = &apos; user &apos; , args = &apos; login &apos; , vars = { &apos; _ next &apos; : URL ( c = &apos; msg &apos; , f = &apos; group _ membership &apos; ) } ) ) DCNL DCSP table = s3db.pr _ group _ membership DCNL DCSP table.comments.readable = table.comments.writable = False DCNL DCSP table.group _ head.readable = table.group _ head.writable = False DCNL DCSP return s3 _ rest _ controller ( &apos; pr &apos; , resourcename )
DCSP with tf.name _ scope ( &apos; encode &apos; ) : DCNL DCSP DCSP mu = ( quantization _ channels - 1 ) DCNL DCSP DCSP magnitude = ( tf.log ( ( 1 + ( mu * tf.abs ( audio ) ) ) ) / tf.log ( ( 1.0 + mu ) ) ) DCNL DCSP DCSP signal = ( tf.sign ( audio ) * magnitude ) DCNL DCSP DCSP return tf.cast ( ( ( ( ( signal + 1 ) / 2 ) * mu ) + 0.5 ) , tf.int32 )
DCSP query = location.to _ deprecated _ son ( prefix = &apos; _ id . &apos; , tag = tag ) DCNL DCSP if wildcard : DCNL DCSP DCSP for ( key , value ) in query.items ( ) : DCNL DCSP DCSP DCSP if ( ( value is None ) and ( key ! = &apos; _ id.revision &apos; ) ) : DCNL DCSP DCSP DCSP DCSP del query &#91; key &#93; DCNL DCSP return query
DCSP list _ with _ ids = &#91; &#93; DCNL DCSP for ( key , value ) in six.iteritems ( objects ) : DCNL DCSP DCSP element = { &apos; id &apos; : key } DCNL DCSP DCSP element.update ( value ) DCNL DCSP DCSP list _ with _ ids.append ( element ) DCNL DCSP return list _ with _ ids
DCSP user _ profiles = &#91; &#93; DCNL DCSP with salt.utils.fopen ( &apos; / etc / user _ attr &apos; , &apos; r &apos; ) as user _ attr : DCNL DCSP DCSP for profile in user _ attr : DCNL DCSP DCSP DCSP profile = profile.strip ( ) .split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP if ( len ( profile ) ! = 5 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( profile &#91; 0 &#93; ! = user ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP attrs = { } DCNL DCSP DCSP DCSP for attr in profile &#91; 4 &#93; .strip ( ) .split ( &apos; ; &apos; ) : DCNL DCSP DCSP DCSP DCSP ( attr _ key , attr _ val ) = attr.strip ( ) .split ( &apos; = &apos; ) DCNL DCSP DCSP DCSP DCSP if ( attr _ key in &#91; &apos; auths &apos; , &apos; profiles &apos; , &apos; roles &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP attrs &#91; attr _ key &#93; = attr _ val.strip ( ) .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP attrs &#91; attr _ key &#93; = attr _ val DCNL DCSP DCSP DCSP if ( &apos; profiles &apos; in attrs ) : DCNL DCSP DCSP DCSP DCSP user _ profiles.extend ( attrs &#91; &apos; profiles &apos; &#93; ) DCNL DCSP if default _ hidden : DCNL DCSP DCSP for profile in profile _ list ( default _ only = True ) : DCNL DCSP DCSP DCSP if ( profile in user _ profiles ) : DCNL DCSP DCSP DCSP DCSP user _ profiles.remove ( profile ) DCNL DCSP return list ( set ( user _ profiles ) )
DCSP if ( call = = &apos; action &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP avail _ locations DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function , DCSP or DCSP with DCSP the DCSP --list-locations DCSP option &apos; ) DCNL DCSP ret = { } DCNL DCSP conn = get _ conn ( ) DCNL DCSP response = conn.getCreateObjectOptions ( ) DCNL DCSP for datacenter in response &#91; &apos; datacenters &apos; &#93; : DCNL DCSP DCSP ret &#91; datacenter &#91; &apos; template &apos; &#93; &#91; &apos; datacenter &apos; &#93; &#91; &apos; name &apos; &#93; &#93; = { &apos; name &apos; : datacenter &#91; &apos; template &apos; &#93; &#91; &apos; datacenter &apos; &#93; &#91; &apos; name &apos; &#93; } DCNL DCSP return ret
DCSP dims = &#91; &#93; DCNL DCSP for i in range ( 2 ) : DCNL DCSP DCSP selection = np.arange ( shape &#91; i &#93; ) &#91; key &#91; i &#93; &#93; DCNL DCSP DCSP size = np.size ( selection ) DCNL DCSP DCSP dims.append ( size ) DCNL DCSP return tuple ( dims )
DCSP if ( args and kwargs ) : DCNL DCSP DCSP raise ValueError ( &quot; Can &apos;t DCSP specify DCSP both DCSP positional DCSP and DCSP keyword DCSP args &quot; ) DCNL DCSP args _ safe = tuple ( map ( conditional _ websafe , args ) ) DCNL DCSP kwargs _ gen = ( ( k , conditional _ websafe ( v ) ) for ( k , v ) in kwargs.iteritems ( ) ) DCNL DCSP kwargs _ safe = dict ( kwargs _ gen ) DCNL DCSP format _ args = ( args _ safe or kwargs _ safe ) DCNL DCSP return unsafe ( ( format _ string % format _ args ) )
DCSP return update ( name = name , fullname = fullname )
DCSP if isinstance ( id _ or _ symbols , six.string _ types ) : DCNL DCSP DCSP id _ or _ symbols = &#91; id _ or _ symbols &#93; DCNL DCSP elif isinstance ( id _ or _ symbols , Instrument ) : DCNL DCSP DCSP id _ or _ symbols = &#91; Instrument.order _ book _ id &#93; DCNL DCSP elif isinstance ( id _ or _ symbols , Iterable ) : DCNL DCSP DCSP id _ or _ symbols = &#91; ( item.order _ book _ id if isinstance ( item , Instrument ) else item ) for item in id _ or _ symbols &#93; DCNL DCSP else : DCNL DCSP DCSP raise RuntimeError ( _ ( &apos; unknown DCSP type &apos; ) ) DCNL DCSP executor = get _ strategy _ executor ( ) DCNL DCSP executor.current _ universe = set ( id _ or _ symbols )
DCSP collector = NestedObjects ( using = using ) DCNL DCSP collector.collect ( objs ) DCNL DCSP perms _ needed = set ( ) DCNL DCSP def format _ callback ( obj ) : DCNL DCSP DCSP has _ admin = ( obj . _ _ class _ _ in admin _ site . _ registry ) DCNL DCSP DCSP opts = obj . _ meta DCNL DCSP DCSP if has _ admin : DCNL DCSP DCSP DCSP admin _ url = reverse ( ( u &apos; % s : % s _ % s _ change &apos; % ( admin _ site.name , opts.app _ label , opts.model _ name ) ) , None , ( quote ( obj . _ get _ pk _ val ( ) ) , ) ) DCNL DCSP DCSP DCSP p = ( u &apos; % s . % s &apos; % ( opts.app _ label , get _ permission _ codename ( u &apos;delete &apos; , opts ) ) ) DCNL DCSP DCSP DCSP if ( not user.has _ perm ( p ) ) : DCNL DCSP DCSP DCSP DCSP perms _ needed.add ( opts.verbose _ name ) DCNL DCSP DCSP DCSP return format _ html ( u &apos; { 0 } : DCSP &lt; a DCSP href = &quot; { 1 } &quot; &gt; { 2 } &lt; / a &gt; &apos; , capfirst ( opts.verbose _ name ) , admin _ url , obj ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( u &apos; % s : DCSP % s &apos; % ( capfirst ( opts.verbose _ name ) , force _ text ( obj ) ) ) DCNL DCSP to _ delete = collector.nested ( format _ callback ) DCNL DCSP protected = &#91; format _ callback ( obj ) for obj in collector.protected &#93; DCNL DCSP return ( to _ delete , perms _ needed , protected )
DCSP bads _ idx = np.zeros ( len ( inst.ch _ names ) , dtype = np.bool ) DCNL DCSP goods _ idx = np.zeros ( len ( inst.ch _ names ) , dtype = np.bool ) DCNL DCSP picks = pick _ types ( inst.info , meg = False , eeg = True , exclude = &#91; &#93; ) DCNL DCSP inst.info. _ check _ consistency ( ) DCNL DCSP bads _ idx &#91; picks &#93; = &#91; ( inst.ch _ names &#91; ch &#93; in inst.info &#91; &apos; bads &apos; &#93; ) for ch in picks &#93; DCNL DCSP if ( ( len ( picks ) = = 0 ) or ( len ( bads _ idx ) = = 0 ) ) : DCNL DCSP DCSP return DCNL DCSP goods _ idx &#91; picks &#93; = True DCNL DCSP goods _ idx &#91; bads _ idx &#93; = False DCNL DCSP pos = inst . _ get _ channel _ positions ( picks ) DCNL DCSP bads _ idx _ pos = bads _ idx &#91; picks &#93; DCNL DCSP goods _ idx _ pos = goods _ idx &#91; picks &#93; DCNL DCSP pos _ good = pos &#91; goods _ idx _ pos &#93; DCNL DCSP pos _ bad = pos &#91; bads _ idx _ pos &#93; DCNL DCSP ( radius , center ) = _ fit _ sphere ( pos _ good ) DCNL DCSP distance = np.sqrt ( np.sum ( ( ( pos _ good - center ) * * 2 ) , 1 ) ) DCNL DCSP distance = np.mean ( ( distance / radius ) ) DCNL DCSP if ( np.abs ( ( 1.0 - distance ) ) &gt; 0.1 ) : DCNL DCSP DCSP warn ( &apos; Your DCSP spherical DCSP fit DCSP is DCSP poor , DCSP interpolation DCSP results DCSP are DCSP likely DCSP to DCSP be DCSP inaccurate . &apos; ) DCNL DCSP logger.info ( &apos; Computing DCSP interpolation DCSP matrix DCSP from DCSP { 0 } DCSP sensor DCSP positions &apos; .format ( len ( pos _ good ) ) ) DCNL DCSP interpolation = _ make _ interpolation _ matrix ( pos _ good , pos _ bad ) DCNL DCSP logger.info ( &apos; Interpolating DCSP { 0 } DCSP sensors &apos; .format ( len ( pos _ bad ) ) ) DCNL DCSP _ do _ interp _ dots ( inst , interpolation , goods _ idx , bads _ idx )
DCSP return LazyLoader ( _ module _ dirs ( opts , &apos; beacons &apos; ) , opts , tag = &apos; beacons &apos; , pack = { &apos; _ _ context _ _ &apos; : context , &apos; _ _ salt _ _ &apos; : functions } , virtual _ funcs = &#91; &apos; _ _ validate _ _ &apos; &#93; )
DCSP if ( ( vpc _ id = = None ) and ( cidr = = None ) ) : DCNL DCSP DCSP module.fail _ json ( msg = &apos; You DCSP must DCSP specify DCSP either DCSP a DCSP vpc _ id DCSP or DCSP a DCSP cidr DCSP block DCSP + DCSP list DCSP of DCSP unique DCSP tags , DCSP aborting &apos; ) DCNL DCSP found _ vpcs = &#91; &#93; DCNL DCSP resource _ tags = module.params.get ( &apos; resource _ tags &apos; ) DCNL DCSP if ( vpc _ id is not None ) : DCNL DCSP DCSP found _ vpcs = vpc _ conn.get _ all _ vpcs ( None , { &apos; vpc-id &apos; : vpc _ id , &apos; state &apos; : &apos; available &apos; } ) DCNL DCSP else : DCNL DCSP DCSP previous _ vpcs = vpc _ conn.get _ all _ vpcs ( None , { &apos; cidr &apos; : cidr , &apos; state &apos; : &apos; available &apos; } ) DCNL DCSP DCSP for vpc in previous _ vpcs : DCNL DCSP DCSP DCSP vpc _ tags = dict ( ( ( t.name , t.value ) for t in vpc _ conn.get _ all _ tags ( filters = { &apos; resource-id &apos; : vpc.id } ) ) ) DCNL DCSP DCSP DCSP if ( resource _ tags and set ( resource _ tags.items ( ) ) .issubset ( set ( vpc _ tags.items ( ) ) ) ) : DCNL DCSP DCSP DCSP DCSP found _ vpcs.append ( vpc ) DCNL DCSP found _ vpc = None DCNL DCSP if ( len ( found _ vpcs ) = = 1 ) : DCNL DCSP DCSP found _ vpc = found _ vpcs &#91; 0 &#93; DCNL DCSP if ( len ( found _ vpcs ) &gt; 1 ) : DCNL DCSP DCSP module.fail _ json ( msg = &apos; Found DCSP more DCSP than DCSP one DCSP vpc DCSP based DCSP on DCSP the DCSP supplied DCSP criteria , DCSP aborting &apos; ) DCNL DCSP return found _ vpc
DCSP @ wraps ( meth ) DCNL DCSP def test _ inner _ onlyroot ( self , * args , * * kwds ) : DCNL DCSP DCSP &apos; Note DCSP that DCSP this DCSP method DCSP needs DCSP to DCSP start DCSP with DCSP test _ DCSP in DCSP order DCSP for DCSP nose \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP to DCSP run DCSP it ! &apos; DCNL DCSP DCSP if ( ( os.geteuid ( ) = = 0 ) or ( os.getuid ( ) = = 0 ) ) : DCNL DCSP DCSP DCSP return meth ( self , * args , * * kwds ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise SkipTest ( &apos; This DCSP test DCSP requires DCSP root DCSP privileges . &apos; ) DCNL DCSP test _ inner _ onlyroot.root = True DCNL DCSP return test _ inner _ onlyroot
DCSP dbc = _ connect ( * * connection _ args ) DCNL DCSP if ( dbc is None ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP cur = dbc.cursor ( ) DCNL DCSP existing = db _ get ( name , * * connection _ args ) DCNL DCSP qry = &apos; ALTER DCSP DATABASE DCSP { 0 } DCSP CHARACTER DCSP SET DCSP { 1 } DCSP COLLATE DCSP { 2 } ; &apos; .format ( name.replace ( &apos; % &apos; , &apos; \ \ % &apos; ) .replace ( &apos; _ &apos; , &apos; \ \ _ &apos; ) , ( character _ set or existing.get ( &apos; character _ set &apos; ) ) , ( collate or existing.get ( &apos; collate &apos; ) ) ) DCNL DCSP args = { } DCNL DCSP _ execute ( cur , qry , args )
DCSP extracted = extract _ javascript ( fileobj = StringIO ( source ) , keywords = { &apos; _ &apos; : None , &apos; P _ &apos; : ( 1 , 2 ) , &apos; N _ &apos; : None , &apos; NP _ &apos; : ( 1 , 2 ) } , comment _ tags = { } , options = { } ) DCNL DCSP return &#91; msg _ id for ( line , func , msg _ id , comments ) in extracted &#93;
DCSP acsdic = dict ( &#91; ( ac.name _ format , ac ) for ac in acs &#93; ) DCNL DCSP if ( required is None ) : DCNL DCSP DCSP required = &#91; &#93; DCNL DCSP if ( optional is None ) : DCNL DCSP DCSP optional = &#91; &#93; DCNL DCSP res = { } DCNL DCSP for ( attr , val ) in ava.items ( ) : DCNL DCSP DCSP done = False DCNL DCSP DCSP for req in required : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP _ name = acsdic &#91; req.name _ format &#93; . _ to &#91; attr &#93; DCNL DCSP DCSP DCSP DCSP if ( _ name = = req.name ) : DCNL DCSP DCSP DCSP DCSP DCSP res &#91; attr &#93; = val DCNL DCSP DCSP DCSP DCSP DCSP done = True DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP if done : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for opt in optional : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP _ name = acsdic &#91; opt.name _ format &#93; . _ to &#91; attr &#93; DCNL DCSP DCSP DCSP DCSP if ( _ name = = opt.name ) : DCNL DCSP DCSP DCSP DCSP DCSP res &#91; attr &#93; = val DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP return res
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP exists = _ _ salt _ _ &#91; &apos; boto _ iam.get _ server _ certificate &apos; &#93; ( name , region , key , keyid , profile ) DCNL DCSP if ( not exists ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Certificate DCSP { 0 } DCSP does DCSP not DCSP exist . &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Server DCSP certificate DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP deleted . &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP return ret DCNL DCSP deleted = _ _ salt _ _ &#91; &apos; boto _ iam.delete _ server _ cert &apos; &#93; ( name , region , key , keyid , profile ) DCNL DCSP if ( not deleted ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Certificate DCSP { 0 } DCSP failed DCSP to DCSP be DCSP deleted . &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Certificate DCSP { 0 } DCSP was DCSP deleted . &apos; .format ( name ) DCNL DCSP ret &#91; &apos; changes &apos; &#93; = deleted DCNL DCSP return ret
DCSP return unicode _ type ( int ( time.time ( ) ) )
DCSP tauk = _ compute _ tauk ( n , k ) DCNL DCSP sigk = ( cos ( ( 0.5 * tauk ) ) * * 2 ) DCNL DCSP a = ( ( n % 2 ) - 0.5 ) DCNL DCSP nu = ( ( ( 4.0 * floor ( ( n / 2.0 ) ) ) + ( 2.0 * a ) ) + 2.0 ) DCNL DCSP xksq = ( ( nu * sigk ) - ( ( 1.0 / ( 3.0 * nu ) ) * ( ( ( 5.0 / ( 4.0 * ( ( 1.0 - sigk ) * * 2 ) ) ) - ( 1.0 / ( 1.0 - sigk ) ) ) - 0.25 ) ) ) DCNL DCSP return xksq
DCSP if np.isscalar ( scale ) : DCNL DCSP DCSP if ( scale = = 0.0 ) : DCNL DCSP DCSP DCSP scale = 1.0 DCNL DCSP DCSP return scale DCNL DCSP elif isinstance ( scale , np.ndarray ) : DCNL DCSP DCSP if copy : DCNL DCSP DCSP DCSP scale = scale.copy ( ) DCNL DCSP DCSP scale &#91; ( scale = = 0.0 ) &#93; = 1.0 DCNL DCSP DCSP return scale
DCSP return &apos; DCSP &apos; .join ( &#91; ( &apos; -I DCSP &apos; + path ) for path in incs &#93; )
DCSP pid _ file = _ dhcp _ file ( dev , &apos; pid &apos; ) DCNL DCSP if os.path.exists ( pid _ file ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with open ( pid _ file , &apos; r &apos; ) as f : DCNL DCSP DCSP DCSP DCSP return int ( f.read ( ) ) DCNL DCSP DCSP except ( ValueError , IOError ) : DCNL DCSP DCSP DCSP return None
DCSP return ( ( ( ( w &lt; &lt; 24 ) &#124; ( x &lt; &lt; 16 ) ) &#124; ( y &lt; &lt; 8 ) ) &#124; z )
DCSP ( f , ax ) = plt.subplots ( ) DCNL DCSP ax.plot ( np.arange ( 20 ) , np.arange ( 20 ) ) DCNL DCSP f.set _ facecolor ( FACE _ COLOR ) DCNL DCSP f.dpi = DPI DCNL DCSP matplotlib.rcParams.update ( { &apos; font.size &apos; : FONT _ SIZE } ) DCNL DCSP return f
DCSP ( ans , auth , add ) = results DCNL DCSP return ans &#91; 0 &#93; .payload
DCSP bits = token.split _ contents ( ) DCNL DCSP if ( len ( bits ) &lt; 2 ) : DCNL DCSP DCSP raise TemplateSyntaxError ( ( &quot; &apos; % s &apos; DCSP takes DCSP at DCSP least DCSP one DCSP argument , DCSP the DCSP name DCSP of DCSP a DCSP url ( ) . &quot; % bits &#91; 0 &#93; ) ) DCNL DCSP viewname = parser.compile _ filter ( bits &#91; 1 &#93; ) DCNL DCSP args = &#91; &#93; DCNL DCSP kwargs = { } DCNL DCSP asvar = None DCNL DCSP bits = bits &#91; 2 : &#93; DCNL DCSP if ( ( len ( bits ) &gt; = 2 ) and ( bits &#91; ( -2 ) &#93; = = &apos; as &apos; ) ) : DCNL DCSP DCSP asvar = bits &#91; ( -1 ) &#93; DCNL DCSP DCSP bits = bits &#91; : ( -2 ) &#93; DCNL DCSP if len ( bits ) : DCNL DCSP DCSP for bit in bits : DCNL DCSP DCSP DCSP match = kwarg _ re.match ( bit ) DCNL DCSP DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP DCSP raise TemplateSyntaxError ( &apos; Malformed DCSP arguments DCSP to DCSP url DCSP tag &apos; ) DCNL DCSP DCSP DCSP ( name , value ) = match.groups ( ) DCNL DCSP DCSP DCSP if name : DCNL DCSP DCSP DCSP DCSP kwargs &#91; name &#93; = parser.compile _ filter ( value ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP args.append ( parser.compile _ filter ( value ) ) DCNL DCSP return URLNode ( viewname , args , kwargs , asvar )
DCSP return klass ( ) .loadd ( spec , base64encode )
DCSP i = symbols ( &apos; i &apos; , below _ fermi = True , cls = Dummy ) DCNL DCSP a = symbols ( &apos; a &apos; , above _ fermi = True , cls = Dummy ) DCNL DCSP t _ ai = AntiSymmetricTensor ( &apos; t &apos; , ( a , ) , ( i , ) ) DCNL DCSP ai = NO ( ( Fd ( a ) * F ( i ) ) ) DCNL DCSP ( i , j ) = symbols ( &apos; i , j &apos; , below _ fermi = True , cls = Dummy ) DCNL DCSP ( a , b ) = symbols ( &apos; a , b &apos; , above _ fermi = True , cls = Dummy ) DCNL DCSP t _ abij = AntiSymmetricTensor ( &apos; t &apos; , ( a , b ) , ( i , j ) ) DCNL DCSP abji = NO ( ( ( ( Fd ( a ) * Fd ( b ) ) * F ( j ) ) * F ( i ) ) ) DCNL DCSP T1 = ( t _ ai * ai ) DCNL DCSP T2 = ( ( Rational ( 1 , 4 ) * t _ abij ) * abji ) DCNL DCSP return ( T1 , T2 )
DCSP assert ( not version.UsesVcxproj ( ) ) DCNL DCSP if ( spec.get ( &apos; type &apos; , None ) not in ( &apos; static _ library &apos; , &apos; shared _ library &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP sources = spec.get ( &apos; sources &apos; , &#91; &#93; ) DCNL DCSP basenames = { } DCNL DCSP for source in sources : DCNL DCSP DCSP ( name , ext ) = os.path.splitext ( source ) DCNL DCSP DCSP is _ compiled _ file = ( ext in &#91; &apos; .c &apos; , &apos; .cc &apos; , &apos; .cpp &apos; , &apos; .cxx &apos; , &apos; .m &apos; , &apos; .mm &apos; , &apos; .s &apos; , &apos; .S &apos; &#93; ) DCNL DCSP DCSP if ( not is _ compiled _ file ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP basename = os.path.basename ( name ) DCNL DCSP DCSP basenames.setdefault ( basename , &#91; &#93; ) .append ( source ) DCNL DCSP error = &apos; &apos; DCNL DCSP for ( basename , files ) in basenames.iteritems ( ) : DCNL DCSP DCSP if ( len ( files ) &gt; 1 ) : DCNL DCSP DCSP DCSP error + = ( &apos; DCSP DCSP % s : DCSP % s \ n &apos; % ( basename , &apos; DCSP &apos; .join ( files ) ) ) DCNL DCSP if error : DCNL DCSP DCSP print ( ( ( &apos; static DCSP library DCSP % s DCSP has DCSP several DCSP files DCSP with DCSP the DCSP same DCSP basename : \ n &apos; % spec &#91; &apos; target _ name &apos; &#93; ) + error ) + &apos; MSVC08 DCSP cannot DCSP handle DCSP that . &apos; ) DCNL DCSP DCSP raise GypError ( &apos; Duplicate DCSP basenames DCSP in DCSP sources DCSP section , DCSP see DCSP list DCSP above &apos; )
DCSP from influxdb import InfluxDBClient , exceptions DCNL DCSP conf = config &#91; DOMAIN &#93; DCNL DCSP kwargs = { &apos; database &apos; : conf &#91; CONF _ DB _ NAME &#93; , &apos; verify _ ssl &apos; : conf &#91; CONF _ VERIFY _ SSL &#93; , &apos; timeout &apos; : TIMEOUT } DCNL DCSP if ( CONF _ HOST in conf ) : DCNL DCSP DCSP kwargs &#91; &apos; host &apos; &#93; = conf &#91; CONF _ HOST &#93; DCNL DCSP if ( CONF _ PORT in conf ) : DCNL DCSP DCSP kwargs &#91; &apos; port &apos; &#93; = conf &#91; CONF _ PORT &#93; DCNL DCSP if ( CONF _ USERNAME in conf ) : DCNL DCSP DCSP kwargs &#91; &apos; username &apos; &#93; = conf &#91; CONF _ USERNAME &#93; DCNL DCSP if ( CONF _ PASSWORD in conf ) : DCNL DCSP DCSP kwargs &#91; &apos; password &apos; &#93; = conf &#91; CONF _ PASSWORD &#93; DCNL DCSP if ( CONF _ SSL in conf ) : DCNL DCSP DCSP kwargs &#91; &apos; ssl &apos; &#93; = conf &#91; CONF _ SSL &#93; DCNL DCSP blacklist = conf.get ( CONF _ BLACKLIST ) DCNL DCSP whitelist = conf.get ( CONF _ WHITELIST ) DCNL DCSP tags = conf.get ( CONF _ TAGS ) DCNL DCSP default _ measurement = conf.get ( CONF _ DEFAULT _ MEASUREMENT ) DCNL DCSP override _ measurement = conf.get ( CONF _ OVERRIDE _ MEASUREMENT ) DCNL DCSP try : DCNL DCSP DCSP influx = InfluxDBClient ( * * kwargs ) DCNL DCSP DCSP influx.query ( &apos; SELECT DCSP * DCSP FROM DCSP / . * / DCSP LIMIT DCSP 1 ; &apos; ) DCNL DCSP except exceptions.InfluxDBClientError as exc : DCNL DCSP DCSP _ LOGGER.error ( &quot; Database DCSP host DCSP is DCSP not DCSP accessible DCSP due DCSP to DCSP &apos; % s &apos; , DCSP please DCSP check DCSP your DCSP entries DCSP in DCSP the DCSP configuration DCSP file DCSP and DCSP that DCSP the DCSP database DCSP exists DCSP and DCSP is DCSP READ / WRITE . &quot; , exc ) DCNL DCSP DCSP return False DCNL DCSP def influx _ event _ listener ( event ) : DCNL DCSP DCSP &apos; Listen DCSP for DCSP new DCSP messages DCSP on DCSP the DCSP bus DCSP and DCSP sends DCSP them DCSP to DCSP Influx . &apos; DCNL DCSP DCSP state = event.data.get ( &apos; new _ state &apos; ) DCNL DCSP DCSP if ( ( state is None ) or ( state.state in ( STATE _ UNKNOWN , &apos; &apos; , STATE _ UNAVAILABLE ) ) or ( state.entity _ id in blacklist ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( ( len ( whitelist ) &gt; 0 ) and ( state.entity _ id not in whitelist ) ) : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP _ state = float ( state _ helper.state _ as _ number ( state ) ) DCNL DCSP DCSP DCSP _ state _ key = &apos; value &apos; DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP _ state = state.state DCNL DCSP DCSP DCSP _ state _ key = &apos; state &apos; DCNL DCSP DCSP if override _ measurement : DCNL DCSP DCSP DCSP measurement = override _ measurement DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP measurement = state.attributes.get ( &apos; unit _ of _ measurement &apos; ) DCNL DCSP DCSP DCSP if ( measurement in ( None , &apos; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if default _ measurement : DCNL DCSP DCSP DCSP DCSP DCSP measurement = default _ measurement DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP measurement = state.entity _ id DCNL DCSP DCSP json _ body = &#91; { &apos; measurement &apos; : measurement , &apos; tags &apos; : { &apos; domain &apos; : state.domain , &apos; entity _ id &apos; : state.object _ id } , &apos; time &apos; : event.time _ fired , &apos; fields &apos; : { _ state _ key : _ state } } &#93; DCNL DCSP DCSP for ( key , value ) in state.attributes.items ( ) : DCNL DCSP DCSP DCSP if ( key ! = &apos; unit _ of _ measurement &apos; ) : DCNL DCSP DCSP DCSP DCSP if ( key in json _ body &#91; 0 &#93; &#91; &apos; fields &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP key = ( key + &apos; _ &apos; ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP json _ body &#91; 0 &#93; &#91; &apos; fields &apos; &#93; &#91; key &#93; = float ( value ) DCNL DCSP DCSP DCSP DCSP except ( ValueError , TypeError ) : DCNL DCSP DCSP DCSP DCSP DCSP new _ key = &apos; { } _ str &apos; .format ( key ) DCNL DCSP DCSP DCSP DCSP DCSP json _ body &#91; 0 &#93; &#91; &apos; fields &apos; &#93; &#91; new _ key &#93; = str ( value ) DCNL DCSP DCSP json _ body &#91; 0 &#93; &#91; &apos; tags &apos; &#93; .update ( tags ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP influx.write _ points ( json _ body ) DCNL DCSP DCSP except exceptions.InfluxDBClientError : DCNL DCSP DCSP DCSP _ LOGGER.exception ( &apos; Error DCSP saving DCSP event DCSP &quot; % s &quot; DCSP to DCSP InfluxDB &apos; , json _ body ) DCNL DCSP hass.bus.listen ( EVENT _ STATE _ CHANGED , influx _ event _ listener ) DCNL DCSP return True
DCSP ( a , axis ) = _ chk _ asarray ( a , axis ) DCNL DCSP ( contains _ nan , nan _ policy ) = _ contains _ nan ( a , nan _ policy ) DCNL DCSP if ( contains _ nan and ( nan _ policy = = &apos; omit &apos; ) ) : DCNL DCSP DCSP a = ma.masked _ invalid ( a ) DCNL DCSP DCSP return mstats _ basic.moment ( a , moment , axis ) DCNL DCSP if ( a.size = = 0 ) : DCNL DCSP DCSP if np.isscalar ( moment ) : DCNL DCSP DCSP DCSP return np.nan DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( np.ones ( np.asarray ( moment ) .shape , dtype = np.float64 ) * np.nan ) DCNL DCSP if ( not np.isscalar ( moment ) ) : DCNL DCSP DCSP mmnt = &#91; _ moment ( a , i , axis ) for i in moment &#93; DCNL DCSP DCSP return np.array ( mmnt ) DCNL DCSP else : DCNL DCSP DCSP return _ moment ( a , moment , axis )
DCSP try : DCNL DCSP DCSP if ( vm _ &#91; &apos; profile &apos; &#93; and ( config.is _ profile _ configured ( _ _ opts _ _ , ( _ _ active _ provider _ name _ _ or &apos; nova &apos; ) , vm _ &#91; &apos; profile &apos; &#93; , vm _ = vm _ ) is False ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP deploy = config.get _ cloud _ config _ value ( &apos; deploy &apos; , vm _ , _ _ opts _ _ ) DCNL DCSP key _ filename = config.get _ cloud _ config _ value ( &apos; ssh _ key _ file &apos; , vm _ , _ _ opts _ _ , search _ global = False , default = None ) DCNL DCSP if ( ( key _ filename is not None ) and ( not os.path.isfile ( key _ filename ) ) ) : DCNL DCSP DCSP raise SaltCloudConfigError ( &quot; The DCSP defined DCSP ssh _ key _ file DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP exist &quot; .format ( key _ filename ) ) DCNL DCSP vm _ &#91; &apos; key _ filename &apos; &#93; = key _ filename DCNL DCSP _ _ utils _ _ &#91; &apos; cloud.fire _ event &apos; &#93; ( &apos; event &apos; , &apos; starting DCSP create &apos; , &apos; salt / cloud / { 0 } / creating &apos; .format ( vm _ &#91; &apos; name &apos; &#93; ) , args = { &apos; name &apos; : vm _ &#91; &apos; name &apos; &#93; , &apos; profile &apos; : vm _ &#91; &apos; profile &apos; &#93; , &apos; provider &apos; : vm _ &#91; &apos; driver &apos; &#93; } , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; ) DCNL DCSP conn = get _ conn ( ) DCNL DCSP if ( &apos; instance _ id &apos; in vm _ ) : DCNL DCSP DCSP if ( ( &apos; pub _ key &apos; not in vm _ ) and ( &apos; priv _ key &apos; not in vm _ ) ) : DCNL DCSP DCSP DCSP log.debug ( &quot; Generating DCSP minion DCSP keys DCSP for DCSP &apos; { 0 &#91; name &#93; } &apos; &quot; .format ( vm _ ) ) DCNL DCSP DCSP DCSP ( vm _ &#91; &apos; priv _ key &apos; &#93; , vm _ &#91; &apos; pub _ key &apos; &#93; ) = salt.utils.cloud.gen _ keys ( salt.config.get _ cloud _ config _ value ( &apos; keysize &apos; , vm _ , _ _ opts _ _ ) ) DCNL DCSP DCSP data = conn.server _ show _ libcloud ( vm _ &#91; &apos; instance _ id &apos; &#93; ) DCNL DCSP DCSP if ( ( vm _ &#91; &apos; key _ filename &apos; &#93; is None ) and ( &apos; change _ password &apos; in _ _ opts _ _ ) and ( _ _ opts _ _ &#91; &apos; change _ password &apos; &#93; is True ) ) : DCNL DCSP DCSP DCSP vm _ &#91; &apos; password &apos; &#93; = sup.secure _ password ( ) DCNL DCSP DCSP DCSP conn.root _ password ( vm _ &#91; &apos; instance _ id &apos; &#93; , vm _ &#91; &apos; password &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP ( data , vm _ ) = request _ instance ( vm _ ) DCNL DCSP DCSP vm _ &#91; &apos; instance _ id &apos; &#93; = data.id DCNL DCSP def _ _ query _ node _ data ( vm _ , data ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP node = show _ instance ( vm _ &#91; &apos; name &apos; &#93; , &apos; action &apos; ) DCNL DCSP DCSP DCSP log.debug ( &apos; Loaded DCSP node DCSP data DCSP for DCSP { 0 } : \ n { 1 } &apos; .format ( vm _ &#91; &apos; name &apos; &#93; , pprint.pformat ( node ) ) ) DCNL DCSP DCSP except Exception as err : DCNL DCSP DCSP DCSP log.error ( &apos; Failed DCSP to DCSP get DCSP nodes DCSP list : DCSP { 0 } &apos; .format ( err ) , exc _ info _ on _ loglevel = logging.DEBUG ) DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP running = ( node &#91; &apos; state &apos; &#93; = = &apos; ACTIVE &apos; ) DCNL DCSP DCSP if ( not running ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if ( rackconnect ( vm _ ) is True ) : DCNL DCSP DCSP DCSP extra = node.get ( &apos; extra &apos; , { } ) DCNL DCSP DCSP DCSP rc _ status = extra.get ( &apos; metadata &apos; , { } ) .get ( &apos; rackconnect _ automation _ status &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP if ( rc _ status ! = &apos; DEPLOYED &apos; ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; Waiting DCSP for DCSP Rackconnect DCSP automation DCSP to DCSP complete &apos; ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP if ( managedcloud ( vm _ ) is True ) : DCNL DCSP DCSP DCSP extra = conn.server _ show _ libcloud ( node &#91; &apos; id &apos; &#93; ) .extra DCNL DCSP DCSP DCSP mc _ status = extra.get ( &apos; metadata &apos; , { } ) .get ( &apos; rax _ service _ level _ automation &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP if ( mc _ status ! = &apos; Complete &apos; ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; Waiting DCSP for DCSP managed DCSP cloud DCSP automation DCSP to DCSP complete &apos; ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP access _ ip = node.get ( &apos; extra &apos; , { } ) .get ( &apos; access _ ip &apos; , &apos; &apos; ) DCNL DCSP DCSP rcv3 = ( rackconnectv3 ( vm _ ) in node &#91; &apos; addresses &apos; &#93; ) DCNL DCSP DCSP sshif = ( ssh _ interface ( vm _ ) in node &#91; &apos; addresses &apos; &#93; ) DCNL DCSP DCSP if any ( ( rcv3 , sshif ) ) : DCNL DCSP DCSP DCSP networkname = ( rackconnectv3 ( vm _ ) if rcv3 else ssh _ interface ( vm _ ) ) DCNL DCSP DCSP DCSP for network in node &#91; &apos; addresses &apos; &#93; .get ( networkname , &#91; &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( network &#91; &apos; version &apos; &#93; is 4 ) : DCNL DCSP DCSP DCSP DCSP DCSP access _ ip = network &#91; &apos; addr &apos; &#93; DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP vm _ &#91; &apos; cloudnetwork &apos; &#93; = True DCNL DCSP DCSP if ( any ( ( cloudnetwork ( vm _ ) , rackconnect ( vm _ ) ) ) and ( ( ssh _ interface ( vm _ ) ! = &apos; private _ ips &apos; ) or rcv3 ) and ( access _ ip ! = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP data.public _ ips = &#91; access _ ip &#93; DCNL DCSP DCSP DCSP return data DCNL DCSP DCSP result = &#91; &#93; DCNL DCSP DCSP if ( ( &apos; private _ ips &apos; not in node ) and ( &apos; public _ ips &apos; not in node ) and ( &apos; floating _ ips &apos; not in node ) and ( &apos; fixed _ ips &apos; not in node ) and ( &apos; access _ ip &apos; in node.get ( &apos; extra &apos; , { } ) ) ) : DCNL DCSP DCSP DCSP result = &#91; node &#91; &apos; extra &apos; &#93; &#91; &apos; access _ ip &apos; &#93; &#93; DCNL DCSP DCSP private = node.get ( &apos; private _ ips &apos; , &#91; &#93; ) DCNL DCSP DCSP public = node.get ( &apos; public _ ips &apos; , &#91; &#93; ) DCNL DCSP DCSP fixed = node.get ( &apos; fixed _ ips &apos; , &#91; &#93; ) DCNL DCSP DCSP floating = node.get ( &apos; floating _ ips &apos; , &#91; &#93; ) DCNL DCSP DCSP if ( private and ( not public ) ) : DCNL DCSP DCSP DCSP log.warning ( &apos; Private DCSP IPs DCSP returned , DCSP but DCSP not DCSP public ... DCSP Checking DCSP for DCSP misidentified DCSP IPs &apos; ) DCNL DCSP DCSP DCSP for private _ ip in private : DCNL DCSP DCSP DCSP DCSP private _ ip = preferred _ ip ( vm _ , &#91; private _ ip &#93; ) DCNL DCSP DCSP DCSP DCSP if salt.utils.cloud.is _ public _ ip ( private _ ip ) : DCNL DCSP DCSP DCSP DCSP DCSP log.warning ( &apos; { 0 } DCSP is DCSP a DCSP public DCSP IP &apos; .format ( private _ ip ) ) DCNL DCSP DCSP DCSP DCSP DCSP data.public _ ips.append ( private _ ip ) DCNL DCSP DCSP DCSP DCSP DCSP log.warning ( &apos; Public DCSP IP DCSP address DCSP was DCSP not DCSP ready DCSP when DCSP we DCSP last DCSP checked . DCSP DCSP Appending DCSP public DCSP IP DCSP address DCSP now . &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP public = data.public _ ips DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP log.warning ( &apos; { 0 } DCSP is DCSP a DCSP private DCSP IP &apos; .format ( private _ ip ) ) DCNL DCSP DCSP DCSP DCSP DCSP ignore _ ip = ignore _ cidr ( vm _ , private _ ip ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( private _ ip not in data.private _ ips ) and ( not ignore _ ip ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP result.append ( private _ ip ) DCNL DCSP DCSP if ( ( not result ) and ( ssh _ interface ( vm _ ) = = &apos; private _ ips &apos; ) ) : DCNL DCSP DCSP DCSP for private _ ip in private : DCNL DCSP DCSP DCSP DCSP ignore _ ip = ignore _ cidr ( vm _ , private _ ip ) DCNL DCSP DCSP DCSP DCSP if ( ( private _ ip not in data.private _ ips ) and ( not ignore _ ip ) ) : DCNL DCSP DCSP DCSP DCSP DCSP result.append ( private _ ip ) DCNL DCSP DCSP non _ private _ ips = &#91; &#93; DCNL DCSP DCSP if public : DCNL DCSP DCSP DCSP data.public _ ips = public DCNL DCSP DCSP DCSP if ( ssh _ interface ( vm _ ) = = &apos; public _ ips &apos; ) : DCNL DCSP DCSP DCSP DCSP non _ private _ ips.append ( public ) DCNL DCSP DCSP if floating : DCNL DCSP DCSP DCSP data.floating _ ips = floating DCNL DCSP DCSP DCSP if ( ssh _ interface ( vm _ ) = = &apos; floating _ ips &apos; ) : DCNL DCSP DCSP DCSP DCSP non _ private _ ips.append ( floating ) DCNL DCSP DCSP if fixed : DCNL DCSP DCSP DCSP data.fixed _ ips = fixed DCNL DCSP DCSP DCSP if ( ssh _ interface ( vm _ ) = = &apos; fixed _ ips &apos; ) : DCNL DCSP DCSP DCSP DCSP non _ private _ ips.append ( fixed ) DCNL DCSP DCSP if non _ private _ ips : DCNL DCSP DCSP DCSP log.debug ( &apos; result DCSP = DCSP { 0 } &apos; .format ( non _ private _ ips ) ) DCNL DCSP DCSP DCSP data.private _ ips = result DCNL DCSP DCSP DCSP if ( ssh _ interface ( vm _ ) ! = &apos; private _ ips &apos; ) : DCNL DCSP DCSP DCSP DCSP return data DCNL DCSP DCSP if result : DCNL DCSP DCSP DCSP log.debug ( &apos; result DCSP = DCSP { 0 } &apos; .format ( result ) ) DCNL DCSP DCSP DCSP data.private _ ips = result DCNL DCSP DCSP DCSP if ( ssh _ interface ( vm _ ) = = &apos; private _ ips &apos; ) : DCNL DCSP DCSP DCSP DCSP return data DCNL DCSP try : DCNL DCSP DCSP data = salt.utils.cloud.wait _ for _ ip ( _ _ query _ node _ data , update _ args = ( vm _ , data ) , timeout = config.get _ cloud _ config _ value ( &apos; wait _ for _ ip _ timeout &apos; , vm _ , _ _ opts _ _ , default = ( 10 * 60 ) ) , interval = config.get _ cloud _ config _ value ( &apos; wait _ for _ ip _ interval &apos; , vm _ , _ _ opts _ _ , default = 10 ) ) DCNL DCSP except ( SaltCloudExecutionTimeout , SaltCloudExecutionFailure ) as exc : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP destroy ( vm _ &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP except SaltCloudSystemExit : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP raise SaltCloudSystemExit ( str ( exc ) ) DCNL DCSP log.debug ( &apos; VM DCSP is DCSP now DCSP running &apos; ) DCNL DCSP if ( ssh _ interface ( vm _ ) = = &apos; private _ ips &apos; ) : DCNL DCSP DCSP ip _ address = preferred _ ip ( vm _ , data.private _ ips ) DCNL DCSP elif ( ssh _ interface ( vm _ ) = = &apos; fixed _ ips &apos; ) : DCNL DCSP DCSP ip _ address = preferred _ ip ( vm _ , data.fixed _ ips ) DCNL DCSP elif ( ssh _ interface ( vm _ ) = = &apos; floating _ ips &apos; ) : DCNL DCSP DCSP ip _ address = preferred _ ip ( vm _ , data.floating _ ips ) DCNL DCSP else : DCNL DCSP DCSP ip _ address = preferred _ ip ( vm _ , data.public _ ips ) DCNL DCSP log.debug ( &apos; Using DCSP IP DCSP address DCSP { 0 } &apos; .format ( ip _ address ) ) DCNL DCSP if ( salt.utils.cloud.get _ salt _ interface ( vm _ , _ _ opts _ _ ) = = &apos; private _ ips &apos; ) : DCNL DCSP DCSP salt _ ip _ address = preferred _ ip ( vm _ , data.private _ ips ) DCNL DCSP DCSP log.info ( &apos; Salt DCSP interface DCSP set DCSP to : DCSP { 0 } &apos; .format ( salt _ ip _ address ) ) DCNL DCSP elif ( salt.utils.cloud.get _ salt _ interface ( vm _ , _ _ opts _ _ ) = = &apos; fixed _ ips &apos; ) : DCNL DCSP DCSP salt _ ip _ address = preferred _ ip ( vm _ , data.fixed _ ips ) DCNL DCSP DCSP log.info ( &apos; Salt DCSP interface DCSP set DCSP to : DCSP { 0 } &apos; .format ( salt _ ip _ address ) ) DCNL DCSP elif ( salt.utils.cloud.get _ salt _ interface ( vm _ , _ _ opts _ _ ) = = &apos; floating _ ips &apos; ) : DCNL DCSP DCSP salt _ ip _ address = preferred _ ip ( vm _ , data.floating _ ips ) DCNL DCSP DCSP log.info ( &apos; Salt DCSP interface DCSP set DCSP to : DCSP { 0 } &apos; .format ( salt _ ip _ address ) ) DCNL DCSP else : DCNL DCSP DCSP salt _ ip _ address = preferred _ ip ( vm _ , data.public _ ips ) DCNL DCSP DCSP log.debug ( &apos; Salt DCSP interface DCSP set DCSP to : DCSP { 0 } &apos; .format ( salt _ ip _ address ) ) DCNL DCSP if ( not ip _ address ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; A DCSP valid DCSP IP DCSP address DCSP was DCSP not DCSP found &apos; ) DCNL DCSP vm _ &#91; &apos; ssh _ host &apos; &#93; = ip _ address DCNL DCSP vm _ &#91; &apos; salt _ host &apos; &#93; = salt _ ip _ address DCNL DCSP ret = _ _ utils _ _ &#91; &apos; cloud.bootstrap &apos; &#93; ( vm _ , _ _ opts _ _ ) DCNL DCSP ret.update ( data . _ _ dict _ _ ) DCNL DCSP if ( &apos; password &apos; in ret &#91; &apos; extra &apos; &#93; ) : DCNL DCSP DCSP del ret &#91; &apos; extra &apos; &#93; &#91; &apos; password &apos; &#93; DCNL DCSP log.info ( &quot; Created DCSP Cloud DCSP VM DCSP &apos; { 0 &#91; name &#93; } &apos; &quot; .format ( vm _ ) ) DCNL DCSP log.debug ( &quot; &apos; { 0 &#91; name &#93; } &apos; DCSP VM DCSP creation DCSP details : \ n { 1 } &quot; .format ( vm _ , pprint.pformat ( data . _ _ dict _ _ ) ) ) DCNL DCSP event _ data = { &apos; name &apos; : vm _ &#91; &apos; name &apos; &#93; , &apos; profile &apos; : vm _ &#91; &apos; profile &apos; &#93; , &apos; provider &apos; : vm _ &#91; &apos; driver &apos; &#93; , &apos; instance _ id &apos; : vm _ &#91; &apos; instance _ id &apos; &#93; , &apos; floating _ ips &apos; : data.floating _ ips , &apos; fixed _ ips &apos; : data.fixed _ ips , &apos; private _ ips &apos; : data.private _ ips , &apos; public _ ips &apos; : data.public _ ips } DCNL DCSP _ _ utils _ _ &#91; &apos; cloud.fire _ event &apos; &#93; ( &apos; event &apos; , &apos; created DCSP instance &apos; , &apos; salt / cloud / { 0 } / created &apos; .format ( vm _ &#91; &apos; name &apos; &#93; ) , args = event _ data , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; ) DCNL DCSP _ _ utils _ _ &#91; &apos; cloud.cachedir _ index _ add &apos; &#93; ( vm _ &#91; &apos; name &apos; &#93; , vm _ &#91; &apos; profile &apos; &#93; , &apos; nova &apos; , vm _ &#91; &apos; driver &apos; &#93; ) DCNL DCSP return ret
DCSP if ( not sys.platform.startswith ( &apos; linux &apos; ) ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Memory DCSP information DCSP implemented DCSP only DCSP for DCSP Linux &apos; ) DCNL DCSP info = { } DCNL DCSP with open ( &apos; / proc / meminfo &apos; , &apos; r &apos; ) as f : DCNL DCSP DCSP for line in f : DCNL DCSP DCSP DCSP p = line.split ( ) DCNL DCSP DCSP DCSP info &#91; p &#91; 0 &#93; .strip ( &apos; : &apos; ) .lower ( ) &#93; = ( float ( p &#91; 1 &#93; ) * 1000.0 ) DCNL DCSP return info
DCSP ignore _ params = &#91; &#93; DCNL DCSP for param in params : DCNL DCSP DCSP result = jmespath.compile ( param.target ) DCNL DCSP DCSP current = result.parsed DCNL DCSP DCSP while current &#91; &apos; children &apos; &#93; : DCNL DCSP DCSP DCSP current = current &#91; &apos; children &apos; &#93; &#91; 0 &#93; DCNL DCSP DCSP if ( current &#91; &apos; type &apos; &#93; = = &apos; field &apos; ) : DCNL DCSP DCSP DCSP ignore _ params.append ( current &#91; &apos; value &apos; &#93; ) DCNL DCSP return ignore _ params
DCSP pass
DCSP return attribute.split ( &apos; , &apos; )
DCSP if basic : DCNL DCSP DCSP r = 0 DCNL DCSP else : DCNL DCSP DCSP r = Poly ( 0 , DE.t ) DCNL DCSP t = DE.t DCNL DCSP if coefficientD : DCNL DCSP DCSP if ( DE.level &lt; = ( - len ( DE.T ) ) ) : DCNL DCSP DCSP DCSP return r DCNL DCSP DCSP DE.decrement _ level ( ) DCNL DCSP D = DE.D &#91; : ( ( len ( DE.D ) + DE.level ) + 1 ) &#93; DCNL DCSP T = DE.T &#91; : ( ( len ( DE.T ) + DE.level ) + 1 ) &#93; DCNL DCSP for ( d , v ) in zip ( D , T ) : DCNL DCSP DCSP pv = p.as _ poly ( v ) DCNL DCSP DCSP if ( ( pv is None ) or basic ) : DCNL DCSP DCSP DCSP pv = p.as _ expr ( ) DCNL DCSP DCSP if basic : DCNL DCSP DCSP DCSP r + = ( d.as _ expr ( ) * pv.diff ( v ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP r + = ( d * pv.diff ( v ) ) .as _ poly ( t ) DCNL DCSP if basic : DCNL DCSP DCSP r = cancel ( r ) DCNL DCSP if coefficientD : DCNL DCSP DCSP DE.increment _ level ( ) DCNL DCSP return r
DCSP from jinja2.environment import _ spontaneous _ environments DCNL DCSP from jinja2.lexer import _ lexer _ cache DCNL DCSP _ spontaneous _ environments.clear ( ) DCNL DCSP _ lexer _ cache.clear ( )
DCSP org _ name = _ get _ config _ value ( profile , &apos; org _ name &apos; ) DCNL DCSP if ( repo _ name is None ) : DCNL DCSP DCSP repo _ name = _ get _ config _ value ( profile , &apos; repo _ name &apos; ) DCNL DCSP action = &apos; / &apos; .join ( &#91; &apos; repos &apos; , org _ name , repo _ name &#93; ) DCNL DCSP command = ( &apos; issues / &apos; + str ( issue _ number ) ) DCNL DCSP ret = { } DCNL DCSP issue _ data = _ query ( profile , action = action , command = command ) DCNL DCSP issue _ id = issue _ data.get ( &apos; id &apos; ) DCNL DCSP if ( output = = &apos; full &apos; ) : DCNL DCSP DCSP ret &#91; issue _ id &#93; = issue _ data DCNL DCSP else : DCNL DCSP DCSP ret &#91; issue _ id &#93; = _ format _ issue ( issue _ data ) DCNL DCSP return ret
DCSP if ( not ( G.is _ multigraph ( ) = = H.is _ multigraph ( ) ) ) : DCNL DCSP DCSP raise nx.NetworkXError ( &apos; G DCSP and DCSP H DCSP must DCSP both DCSP be DCSP graphs DCSP or DCSP multigraphs . &apos; ) DCNL DCSP R = nx.create _ empty _ copy ( G ) DCNL DCSP R.name = ( &apos; Difference DCSP of DCSP ( % s DCSP and DCSP % s ) &apos; % ( G.name , H.name ) ) DCNL DCSP if ( set ( G ) ! = set ( H ) ) : DCNL DCSP DCSP raise nx.NetworkXError ( &apos; Node DCSP sets DCSP of DCSP graphs DCSP not DCSP equal &apos; ) DCNL DCSP if G.is _ multigraph ( ) : DCNL DCSP DCSP edges = G.edges ( keys = True ) DCNL DCSP else : DCNL DCSP DCSP edges = G.edges ( ) DCNL DCSP for e in edges : DCNL DCSP DCSP if ( not H.has _ edge ( * e ) ) : DCNL DCSP DCSP DCSP R.add _ edge ( * e ) DCNL DCSP return R
DCSP supported _ schemes = &#91; &apos; http &apos; , &apos; https &apos; &#93; DCNL DCSP ( scheme , domain , path , params , qs , fragment ) = urlparse.urlparse ( uri ) DCNL DCSP scheme = scheme.lower ( ) DCNL DCSP if ( not scheme ) : DCNL DCSP DCSP scheme = &apos; http &apos; DCNL DCSP if ( not domain ) : DCNL DCSP DCSP domain = host DCNL DCSP if ( not path ) : DCNL DCSP DCSP path = &apos; / &apos; DCNL DCSP if ( ( scheme not in supported _ schemes ) or ( not domain ) ) : DCNL DCSP DCSP msg = &apos; You DCSP have DCSP to DCSP specify DCSP the DCSP complete DCSP URI , DCSP including DCSP the DCSP protocol &apos; DCNL DCSP DCSP msg + = &apos; DCSP and DCSP the DCSP host . DCSP Invalid DCSP URI : DCSP % s . &apos; DCNL DCSP DCSP raise BaseFrameworkException ( ( msg % uri ) ) DCNL DCSP res = urlparse.urlunparse ( ( scheme , domain , path , params , qs , fragment ) ) DCNL DCSP return res
DCSP usage _ key = course.id.make _ usage _ key ( &apos; course _ info &apos; , section _ key ) DCNL DCSP field _ data _ cache = FieldDataCache ( &#91; &#93; , course.id , user ) DCNL DCSP return get _ module ( user , request , usage _ key , field _ data _ cache , log _ if _ not _ found = False , wrap _ xmodule _ display = False , static _ asset _ path = course.static _ asset _ path , course = course )
DCSP hosts = models.Host.smart _ get _ bulk ( hosts _ to _ release ) DCNL DCSP if ( not hosts ) : DCNL DCSP DCSP raise Exception ( &apos; At DCSP least DCSP one DCSP host DCSP must DCSP be DCSP specified &apos; ) DCNL DCSP user = get _ user ( username ) DCNL DCSP if ( not user.is _ superuser ( ) ) : DCNL DCSP DCSP raise Exception ( &apos; Must DCSP be DCSP super DCSP user DCSP to DCSP force DCSP release &apos; ) DCNL DCSP acls = models.AclGroup.objects.all ( ) DCNL DCSP for user _ acl in acls : DCNL DCSP DCSP user _ acl.hosts.remove ( * hosts ) DCNL DCSP DCSP user _ acl.on _ host _ membership _ change ( )
DCSP urls = read _ urls ( amount = 1000 ) DCNL DCSP mthread _ run ( urls )
DCSP existing _ user = _ get _ authorized _ user ( requesting _ user , username ) DCNL DCSP try : DCNL DCSP DCSP user _ preference = UserPreference.objects.get ( user = existing _ user , key = preference _ key ) DCNL DCSP except ObjectDoesNotExist : DCNL DCSP DCSP return False DCNL DCSP try : DCNL DCSP DCSP user _ preference.delete ( ) DCNL DCSP except Exception as error : DCNL DCSP DCSP raise PreferenceUpdateError ( developer _ message = u &quot; Delete DCSP failed DCSP for DCSP user DCSP preference DCSP &apos; { preference _ key } &apos; : DCSP { error } &quot; .format ( preference _ key = preference _ key , error = error ) , user _ message = _ ( u &quot; Delete DCSP failed DCSP for DCSP user DCSP preference DCSP &apos; { preference _ key } &apos; . &quot; ) .format ( preference _ key = preference _ key ) ) DCNL DCSP return True
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP delete _ disk DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP if ( kwargs is None ) : DCNL DCSP DCSP kwargs = { } DCNL DCSP if ( &apos; name &apos; not in kwargs ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; A DCSP name DCSP must DCSP be DCSP specified DCSP as DCSP &quot; name &quot; &apos; ) DCNL DCSP if ( not conn ) : DCNL DCSP DCSP conn = get _ conn ( ) DCNL DCSP try : DCNL DCSP DCSP data = conn.delete _ disk ( kwargs &#91; &apos; name &apos; &#93; , kwargs.get ( &apos; delete _ vhd &apos; , False ) ) DCNL DCSP DCSP return { &apos; Success &apos; : &apos; The DCSP disk DCSP was DCSP successfully DCSP deleted &apos; } DCNL DCSP except AzureMissingResourceHttpError as exc : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; { 0 } : DCSP { 1 } &apos; .format ( kwargs &#91; &apos; name &apos; &#93; , exc.message ) )
DCSP raise RuntimeError ( u &apos;JOB DCSP FAILURE &apos; )
DCSP return nsTag ( XRD _ NS _ 2 _ 0 , t )
DCSP kwarg _ map = { &apos; block _ size &apos; : &apos; b &apos; , &apos; check &apos; : &apos; c &apos; , &apos; direct &apos; : &apos; D &apos; , &apos; ext _ opts &apos; : &apos; E &apos; , &apos; fragment _ size &apos; : &apos; f &apos; , &apos; force &apos; : &apos; F &apos; , &apos; blocks _ per _ group &apos; : &apos; g &apos; , &apos; number _ of _ groups &apos; : &apos; G &apos; , &apos; bytes _ per _ inode &apos; : &apos; i &apos; , &apos; inode _ size &apos; : &apos; I &apos; , &apos; journal &apos; : &apos; j &apos; , &apos; journal _ opts &apos; : &apos; J &apos; , &apos; blocks _ file &apos; : &apos; l &apos; , &apos; label &apos; : &apos; L &apos; , &apos; reserved &apos; : &apos; m &apos; , &apos; last _ dir &apos; : &apos; M &apos; , &apos; test &apos; : &apos; n &apos; , &apos; number _ of _ inodes &apos; : &apos; N &apos; , &apos; creator _ os &apos; : &apos; o &apos; , &apos; opts &apos; : &apos; O &apos; , &apos; revision &apos; : &apos; r &apos; , &apos; super &apos; : &apos; S &apos; , &apos; usage _ type &apos; : &apos; T &apos; , &apos; uuid &apos; : &apos; U &apos; } DCNL DCSP opts = &apos; &apos; DCNL DCSP for key in kwargs : DCNL DCSP DCSP if ( key in kwarg _ map ) : DCNL DCSP DCSP DCSP opt = kwarg _ map &#91; key &#93; DCNL DCSP DCSP DCSP if ( kwargs &#91; key &#93; = = &apos; True &apos; ) : DCNL DCSP DCSP DCSP DCSP opts + = &apos; - { 0 } DCSP &apos; .format ( opt ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP opts + = &apos; - { 0 } DCSP { 1 } DCSP &apos; .format ( opt , kwargs &#91; key &#93; ) DCNL DCSP cmd = &apos; mke2fs DCSP -F DCSP -t DCSP { 0 } DCSP { 1 } { 2 } &apos; .format ( fs _ type , opts , device ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) .splitlines ( ) DCNL DCSP ret = &#91; &#93; DCNL DCSP for line in out : DCNL DCSP DCSP if ( not line ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; mke2fs &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; Discarding DCSP device DCSP blocks &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; Allocating DCSP group DCSP tables &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; Writing DCSP inode DCSP tables &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; Creating DCSP journal &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif line.startswith ( &apos; Writing DCSP superblocks &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ret.append ( line ) DCNL DCSP return ret
DCSP _ _ context _ _ &#91; &apos; inotify.queue &apos; &#93; .append ( revent )
DCSP res = core.nanmax ( a , axis = axis , out = out , keepdims = keepdims ) DCNL DCSP if content.isnan ( res ) .any ( ) : DCNL DCSP DCSP warnings.warn ( &apos; All-NaN DCSP slice DCSP encountered &apos; , RuntimeWarning ) DCNL DCSP return res
DCSP global pager DCNL DCSP pager = getpager ( ) DCNL DCSP pager ( text )
DCSP return BROWSE _ PARTITIONED _ TABLE _ LIMIT.get ( )
DCSP path _ list = path _ list &#91; : &#93; DCNL DCSP new _ path _ list = &#91; &#93; DCNL DCSP for ( ii , ( path , is _ unsav ) ) in enumerate ( zip ( path _ list , is _ unsaved ) ) : DCNL DCSP DCSP if is _ unsav : DCNL DCSP DCSP DCSP new _ path _ list.append ( _ ( &apos; unsaved DCSP file &apos; ) ) DCNL DCSP DCSP DCSP path _ list &#91; ii &#93; = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( drive , path ) = osp.splitdrive ( osp.dirname ( path ) ) DCNL DCSP DCSP DCSP new _ path _ list.append ( ( drive + osp.sep ) ) DCNL DCSP DCSP DCSP path _ list &#91; ii &#93; = &#91; part for part in path.split ( osp.sep ) if part &#93; DCNL DCSP def recurse _ level ( level _ idx ) : DCNL DCSP DCSP sep = os.sep DCNL DCSP DCSP if ( not any ( level _ idx.values ( ) ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP sample _ toks = list ( level _ idx.values ( ) ) &#91; 0 &#93; DCNL DCSP DCSP if ( not sample _ toks ) : DCNL DCSP DCSP DCSP s = 0 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for ( s , sample _ val ) in enumerate ( sample _ toks ) : DCNL DCSP DCSP DCSP DCSP if ( not all ( ( ( ( len ( toks ) &gt; s ) and ( toks &#91; s &#93; = = sample _ val ) ) for toks in level _ idx.values ( ) ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if ( s = = 0 ) : DCNL DCSP DCSP DCSP short _ form = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( s = = 1 ) : DCNL DCSP DCSP DCSP DCSP short _ form = sample _ toks &#91; 0 &#93; DCNL DCSP DCSP DCSP elif ( s = = 2 ) : DCNL DCSP DCSP DCSP DCSP short _ form = ( ( sample _ toks &#91; 0 &#93; + sep ) + sample _ toks &#91; 1 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP short _ form = ( ( &apos; ... &apos; + sep ) + sample _ toks &#91; ( s - 1 ) &#93; ) DCNL DCSP DCSP DCSP for idx in level _ idx : DCNL DCSP DCSP DCSP DCSP new _ path _ list &#91; idx &#93; + = ( short _ form + sep ) DCNL DCSP DCSP DCSP DCSP level _ idx &#91; idx &#93; = level _ idx &#91; idx &#93; &#91; s : &#93; DCNL DCSP DCSP while level _ idx : DCNL DCSP DCSP DCSP ( k , group ) = ( 0 , level _ idx ) DCNL DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP prospective _ group = { idx : toks for ( idx , toks ) in group.items ( ) if ( len ( toks ) = = k ) } DCNL DCSP DCSP DCSP DCSP if prospective _ group : DCNL DCSP DCSP DCSP DCSP DCSP if ( k = = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP group = prospective _ group DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP ( _ , sample _ toks ) = next ( iteritems ( group ) ) DCNL DCSP DCSP DCSP DCSP prospective _ group = { idx : toks for ( idx , toks ) in group.items ( ) if ( toks &#91; k &#93; = = sample _ toks &#91; k &#93; ) } DCNL DCSP DCSP DCSP DCSP if ( ( len ( prospective _ group ) = = len ( group ) ) or ( k = = 0 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP group = prospective _ group DCNL DCSP DCSP DCSP DCSP DCSP k + = 1 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP ( _ , sample _ toks ) = next ( iteritems ( group ) ) DCNL DCSP DCSP DCSP if ( k = = 0 ) : DCNL DCSP DCSP DCSP DCSP short _ form = &apos; &apos; DCNL DCSP DCSP DCSP elif ( k = = 1 ) : DCNL DCSP DCSP DCSP DCSP short _ form = sample _ toks &#91; 0 &#93; DCNL DCSP DCSP DCSP elif ( k = = 2 ) : DCNL DCSP DCSP DCSP DCSP short _ form = ( ( sample _ toks &#91; 0 &#93; + sep ) + sample _ toks &#91; 1 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP short _ form = ( ( ( sample _ toks &#91; 0 &#93; + &apos; ... &apos; ) + sep ) + sample _ toks &#91; ( k - 1 ) &#93; ) DCNL DCSP DCSP DCSP for idx in group.keys ( ) : DCNL DCSP DCSP DCSP DCSP new _ path _ list &#91; idx &#93; + = ( short _ form + ( sep if ( k &gt; 0 ) else &apos; &apos; ) ) DCNL DCSP DCSP DCSP DCSP del level _ idx &#91; idx &#93; DCNL DCSP DCSP DCSP recurse _ level ( { idx : toks &#91; k : &#93; for ( idx , toks ) in group.items ( ) } ) DCNL DCSP recurse _ level ( { i : pl for ( i , pl ) in enumerate ( path _ list ) if pl } ) DCNL DCSP return &#91; path.rstrip ( os.sep ) for path in new _ path _ list &#93;
DCSP assert isinstance ( record , dnslib.DNSRecord ) DCNL DCSP iplist = &#91; x for x in ( str ( r.rdata ) for r in record.rr ) if ( re.match ( &apos; ^ \ \ d + \ \ . \ \ d + \ \ . \ \ d + \ \ . \ \ d + $ &apos; , x ) or ( &apos; : &apos; in x ) ) &#93; DCNL DCSP return iplist
DCSP setuptools _ version = package _ version ( &apos; setuptools &apos; , python _ cmd ) DCNL DCSP distribute _ version = package _ version ( &apos; distribute &apos; , python _ cmd ) DCNL DCSP if ( setuptools _ version is None ) : DCNL DCSP DCSP _ install _ from _ scratch ( python _ cmd , use _ sudo ) DCNL DCSP elif ( distribute _ version is None ) : DCNL DCSP DCSP _ upgrade _ from _ setuptools ( python _ cmd , use _ sudo ) DCNL DCSP else : DCNL DCSP DCSP _ upgrade _ from _ distribute ( python _ cmd , use _ sudo )
DCSP if frappe.conf.disable _ error _ snapshot : DCNL DCSP DCSP return DCNL DCSP try : DCNL DCSP DCSP path = get _ error _ snapshot _ path ( ) DCNL DCSP DCSP if ( not os.path.exists ( path ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP for fname in os.listdir ( path ) : DCNL DCSP DCSP DCSP fullpath = os.path.join ( path , fname ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP with open ( fullpath , u &apos;rb &apos; ) as filedata : DCNL DCSP DCSP DCSP DCSP DCSP data = json.load ( filedata ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP os.remove ( fullpath ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for field in &#91; u &apos;locals &apos; , u &apos;exception &apos; , u &apos;frames &apos; &#93; : DCNL DCSP DCSP DCSP DCSP data &#91; field &#93; = frappe.as _ json ( data &#91; field &#93; ) DCNL DCSP DCSP DCSP doc = frappe.new _ doc ( u &apos;Error DCSP Snapshot &apos; ) DCNL DCSP DCSP DCSP doc.update ( data ) DCNL DCSP DCSP DCSP doc.save ( ) DCNL DCSP DCSP DCSP frappe.db.commit ( ) DCNL DCSP DCSP DCSP os.remove ( fullpath ) DCNL DCSP DCSP clear _ old _ snapshots ( ) DCNL DCSP except Exception as e : DCNL DCSP DCSP make _ error _ snapshot ( e ) DCNL DCSP DCSP raise
DCSP def str _ method ( self ) : DCNL DCSP DCSP return str ( self . _ obj ) DCNL DCSP def repr _ method ( self ) : DCNL DCSP DCSP return repr ( self . _ obj ) DCNL DCSP tpool.Proxy. _ _ str _ _ = str _ method DCNL DCSP tpool.Proxy. _ _ repr _ _ = repr _ method
DCSP @ wraps ( func ) DCNL DCSP def inner ( self , * args , * * kwargs ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return func ( self , * args , * * kwargs ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP if ( not can _ reconnect ( e ) ) : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP self.close ( reconnect = True ) DCNL DCSP DCSP DCSP return func ( self , * args , * * kwargs ) DCNL DCSP return inner
DCSP return ( &apos; % s % i &apos; % ( get _ column _ letter ( ( col + 1 ) ) , ( row + 1 ) ) )
DCSP basename = osp.basename ( filename ) DCNL DCSP storedir = osp.dirname ( osp.abspath ( filename ) ) DCNL DCSP target = filename.split ( &apos; .&apos; ) &#91; ( -1 ) &#93; DCNL DCSP return ( storedir , basename , target )
DCSP warnings.warn ( msg , exc.SAWarning , stacklevel = 2 )
DCSP a = os.path.normpath ( os.path.abspath ( a ) ) DCNL DCSP b = os.path.normpath ( os.path.abspath ( b ) ) DCNL DCSP if ( sabnzbd.WIN32 or sabnzbd.DARWIN ) : DCNL DCSP DCSP a = a.lower ( ) DCNL DCSP DCSP b = b.lower ( ) DCNL DCSP if b.startswith ( a ) : DCNL DCSP DCSP return 2 DCNL DCSP if ( &apos; samefile &apos; in os.path. _ _ dict _ _ ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return int ( os.path.samefile ( a , b ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return 0 DCNL DCSP else : DCNL DCSP DCSP return int ( ( a = = b ) )
DCSP context = zmq.Context ( ) DCNL DCSP socket = context.socket ( zmq.PULL ) DCNL DCSP socket.set _ hwm ( hwm ) DCNL DCSP socket.connect ( &apos; tcp : / / { } : { } &apos; .format ( host , port ) ) DCNL DCSP logger.info ( &apos; client DCSP started &apos; ) DCNL DCSP while True : DCNL DCSP DCSP data = recv _ arrays ( socket ) DCNL DCSP DCSP ( yield tuple ( data ) )
DCSP if ( not u ) : DCNL DCSP DCSP return dup _ mul _ ground ( f , c , K ) DCNL DCSP v = ( u - 1 ) DCNL DCSP return &#91; dmp _ mul _ ground ( cf , c , v , K ) for cf in f &#93;
DCSP if ( canonical is not None ) : DCNL DCSP DCSP canonicalSeries = canonical DCNL DCSP pre _ title = _ emptyString DCNL DCSP kind = title _ dict.get ( &apos; kind &apos; ) DCNL DCSP episode _ of = title _ dict.get ( &apos; episode DCSP of &apos; ) DCNL DCSP if ( ( kind = = &apos; episode &apos; ) and ( episode _ of is not None ) ) : DCNL DCSP DCSP doYear = 0 DCNL DCSP DCSP if ptdf : DCNL DCSP DCSP DCSP doYear = 1 DCNL DCSP DCSP if ( not isinstance ( episode _ of , ( dict , _ Container ) ) ) : DCNL DCSP DCSP DCSP episode _ of = { &apos; title &apos; : episode _ of , &apos; kind &apos; : &apos; tv DCSP series &apos; } DCNL DCSP DCSP DCSP if ( &apos; series DCSP year &apos; in title _ dict ) : DCNL DCSP DCSP DCSP DCSP episode _ of &#91; &apos; year &apos; &#93; = title _ dict &#91; &apos; series DCSP year &apos; &#93; DCNL DCSP DCSP pre _ title = build _ title ( episode _ of , canonical = canonicalSeries , ptdf = 0 , _ doYear = doYear , _ emptyString = _ emptyString ) DCNL DCSP DCSP ep _ dict = { &apos; title &apos; : title _ dict.get ( &apos; title &apos; , &apos; &apos; ) , &apos; imdbIndex &apos; : title _ dict.get ( &apos; imdbIndex &apos; ) } DCNL DCSP DCSP ep _ title = ep _ dict &#91; &apos; title &apos; &#93; DCNL DCSP DCSP if ( not ptdf ) : DCNL DCSP DCSP DCSP doYear = 1 DCNL DCSP DCSP DCSP ep _ dict &#91; &apos; year &apos; &#93; = title _ dict.get ( &apos; year &apos; , &apos; ? ? ? ? &apos; ) DCNL DCSP DCSP DCSP if ( ( ep _ title &#91; 0 : 1 &#93; = = &apos; ( &apos; ) and ( ep _ title &#91; ( -1 ) : &#93; = = &apos; ) &apos; ) and ep _ title &#91; 1 : 5 &#93; .isdigit ( ) ) : DCNL DCSP DCSP DCSP DCSP ep _ dict &#91; &apos; title &apos; &#93; = _ convertTime ( ep _ title , fromPTDFtoWEB = 1 , _ emptyString = _ emptyString ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP doYear = 0 DCNL DCSP DCSP DCSP if ep _ title.startswith ( &apos; Episode DCSP dated &apos; ) : DCNL DCSP DCSP DCSP DCSP ep _ dict &#91; &apos; title &apos; &#93; = _ convertTime ( ep _ title , fromPTDFtoWEB = 0 , _ emptyString = _ emptyString ) DCNL DCSP DCSP episode _ title = build _ title ( ep _ dict , canonical = canonicalEpisode , ptdf = ptdf , _ doYear = doYear , _ emptyString = _ emptyString ) DCNL DCSP DCSP if ptdf : DCNL DCSP DCSP DCSP oad = title _ dict.get ( &apos; original DCSP air DCSP date &apos; , _ emptyString ) DCNL DCSP DCSP DCSP if ( ( len ( oad ) = = 10 ) and ( oad &#91; 4 &#93; = = &apos; -&apos; ) and ( oad &#91; 7 &#93; = = &apos; -&apos; ) and ( episode _ title.find ( oad ) = = ( -1 ) ) ) : DCNL DCSP DCSP DCSP DCSP episode _ title + = ( &apos; DCSP ( % s ) &apos; % oad ) DCNL DCSP DCSP DCSP seas = title _ dict.get ( &apos; season &apos; ) DCNL DCSP DCSP DCSP if ( seas is not None ) : DCNL DCSP DCSP DCSP DCSP episode _ title + = ( &apos; DCSP ( # % s &apos; % seas ) DCNL DCSP DCSP DCSP DCSP episode = title _ dict.get ( &apos; episode &apos; ) DCNL DCSP DCSP DCSP DCSP if ( episode is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP episode _ title + = ( &apos; . % s &apos; % episode ) DCNL DCSP DCSP DCSP DCSP episode _ title + = &apos; ) &apos; DCNL DCSP DCSP DCSP episode _ title = ( &apos; { % s } &apos; % episode _ title ) DCNL DCSP DCSP return ( _ emptyString + ( &apos; % s DCSP % s &apos; % ( ( _ emptyString + pre _ title ) , ( _ emptyString + episode _ title ) ) ) ) DCNL DCSP title = title _ dict.get ( &apos; title &apos; , &apos; &apos; ) DCNL DCSP imdbIndex = title _ dict.get ( &apos; imdbIndex &apos; , &apos; &apos; ) DCNL DCSP if ( not title ) : DCNL DCSP DCSP return _ emptyString DCNL DCSP if ( canonical is not None ) : DCNL DCSP DCSP if canonical : DCNL DCSP DCSP DCSP title = canonicalTitle ( title , lang = lang , imdbIndex = imdbIndex ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP title = normalizeTitle ( title , lang = lang ) DCNL DCSP if pre _ title : DCNL DCSP DCSP title = ( &apos; % s DCSP % s &apos; % ( pre _ title , title ) ) DCNL DCSP if ( kind in ( u &apos;tv DCSP series &apos; , u &apos;tv DCSP mini DCSP series &apos; ) ) : DCNL DCSP DCSP title = ( &apos; &quot; % s &quot; &apos; % title ) DCNL DCSP if _ doYear : DCNL DCSP DCSP year = ( title _ dict.get ( &apos; year &apos; ) or &apos; ? ? ? ? &apos; ) DCNL DCSP DCSP if isinstance ( _ emptyString , str ) : DCNL DCSP DCSP DCSP year = str ( year ) DCNL DCSP DCSP imdbIndex = title _ dict.get ( &apos; imdbIndex &apos; ) DCNL DCSP DCSP if ( not ptdf ) : DCNL DCSP DCSP DCSP if ( imdbIndex and ( ( canonical is None ) or canonical ) ) : DCNL DCSP DCSP DCSP DCSP title + = ( &apos; DCSP ( % s ) &apos; % imdbIndex ) DCNL DCSP DCSP DCSP title + = ( &apos; DCSP ( % s ) &apos; % year ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP title + = ( &apos; DCSP ( % s &apos; % year ) DCNL DCSP DCSP DCSP if ( imdbIndex and ( ( canonical is None ) or canonical ) ) : DCNL DCSP DCSP DCSP DCSP title + = ( &apos; / % s &apos; % imdbIndex ) DCNL DCSP DCSP DCSP title + = &apos; ) &apos; DCNL DCSP if ( appendKind and kind ) : DCNL DCSP DCSP if ( kind = = &apos; tv DCSP movie &apos; ) : DCNL DCSP DCSP DCSP title + = &apos; DCSP ( TV ) &apos; DCNL DCSP DCSP elif ( kind = = &apos; video DCSP movie &apos; ) : DCNL DCSP DCSP DCSP title + = &apos; DCSP ( V ) &apos; DCNL DCSP DCSP elif ( kind = = &apos; tv DCSP mini DCSP series &apos; ) : DCNL DCSP DCSP DCSP title + = &apos; DCSP ( mini ) &apos; DCNL DCSP DCSP elif ( kind = = &apos; video DCSP game &apos; ) : DCNL DCSP DCSP DCSP title + = &apos; DCSP ( VG ) &apos; DCNL DCSP return title
DCSP from multiprocessing.synchronize import BoundedSemaphore DCNL DCSP return BoundedSemaphore ( value )
DCSP assertHasMessage ( case , logger , ZFS _ ERROR , { &apos; status &apos; : 1 , &apos; zfs _ command &apos; : &apos; nonsense DCSP garbage DCSP made DCSP up DCSP no DCSP such DCSP command &apos; , &apos; output &apos; : &apos; &#91; Errno DCSP 2 &#93; DCSP No DCSP such DCSP file DCSP or DCSP directory &apos; } ) DCNL DCSP case.assertEqual ( len ( LoggedMessage.ofType ( logger.messages , ZFS _ ERROR ) ) , 1 )
DCSP if ( fs _ class = = u &apos;default &apos; ) : DCNL DCSP DCSP fs _ class = _ default _ fs _ class ( fstruct ) DCNL DCSP fstruct = copy.deepcopy ( fstruct ) DCNL DCSP _ substitute _ bindings ( fstruct , bindings , fs _ class , set ( ) ) DCNL DCSP return fstruct
DCSP model = ModelFactory.create ( modelParams ) DCNL DCSP model.enableInference ( { &apos; predictedField &apos; : &apos; kw _ energy _ consumption &apos; } ) DCNL DCSP return model
DCSP mock _ current _ pid = 235 DCNL DCSP mock _ other _ pid = 8642 DCNL DCSP mock _ pidfile _ path = tempfile.mktemp ( ) DCNL DCSP mock _ pidfile _ empty = FakeFileDescriptorStringIO ( ) DCNL DCSP mock _ pidfile _ current _ pid = FakeFileDescriptorStringIO ( ( &apos; % ( mock _ current _ pid ) d \ n &apos; % vars ( ) ) ) DCNL DCSP mock _ pidfile _ other _ pid = FakeFileDescriptorStringIO ( ( &apos; % ( mock _ other _ pid ) d \ n &apos; % vars ( ) ) ) DCNL DCSP mock _ pidfile _ bogus = FakeFileDescriptorStringIO ( &apos; b0gUs &apos; ) DCNL DCSP scenarios = { &apos; simple &apos; : { } , &apos; not-exist &apos; : { &apos; open _ func _ name &apos; : &apos; mock _ open _ nonexist &apos; , &apos; os _ open _ func _ name &apos; : &apos; mock _ os _ open _ nonexist &apos; } , &apos; not-exist-write-denied &apos; : { &apos; open _ func _ name &apos; : &apos; mock _ open _ nonexist &apos; , &apos; os _ open _ func _ name &apos; : &apos; mock _ os _ open _ nonexist &apos; } , &apos; not-exist-write-busy &apos; : { &apos; open _ func _ name &apos; : &apos; mock _ open _ nonexist &apos; , &apos; os _ open _ func _ name &apos; : &apos; mock _ os _ open _ nonexist &apos; } , &apos; exist-read-denied &apos; : { &apos; open _ func _ name &apos; : &apos; mock _ open _ read _ denied &apos; , &apos; os _ open _ func _ name &apos; : &apos; mock _ os _ open _ read _ denied &apos; } , &apos; exist-locked-read-denied &apos; : { &apos; locking _ pid &apos; : mock _ other _ pid , &apos; open _ func _ name &apos; : &apos; mock _ open _ read _ denied &apos; , &apos; os _ open _ func _ name &apos; : &apos; mock _ os _ open _ read _ denied &apos; } , &apos; exist-empty &apos; : { } , &apos; exist-invalid &apos; : { &apos; pidfile &apos; : mock _ pidfile _ bogus } , &apos; exist-current-pid &apos; : { &apos; pidfile &apos; : mock _ pidfile _ current _ pid , &apos; pidfile _ pid &apos; : mock _ current _ pid } , &apos; exist-current-pid-locked &apos; : { &apos; pidfile &apos; : mock _ pidfile _ current _ pid , &apos; pidfile _ pid &apos; : mock _ current _ pid , &apos; locking _ pid &apos; : mock _ current _ pid } , &apos; exist-other-pid &apos; : { &apos; pidfile &apos; : mock _ pidfile _ other _ pid , &apos; pidfile _ pid &apos; : mock _ other _ pid } , &apos; exist-other-pid-locked &apos; : { &apos; pidfile &apos; : mock _ pidfile _ other _ pid , &apos; pidfile _ pid &apos; : mock _ other _ pid , &apos; locking _ pid &apos; : mock _ other _ pid } } DCNL DCSP for scenario in scenarios.values ( ) : DCNL DCSP DCSP scenario &#91; &apos; pid &apos; &#93; = mock _ current _ pid DCNL DCSP DCSP scenario &#91; &apos; path &apos; &#93; = mock _ pidfile _ path DCNL DCSP DCSP if ( &apos; pidfile &apos; not in scenario ) : DCNL DCSP DCSP DCSP scenario &#91; &apos; pidfile &apos; &#93; = mock _ pidfile _ empty DCNL DCSP DCSP if ( &apos; pidfile _ pid &apos; not in scenario ) : DCNL DCSP DCSP DCSP scenario &#91; &apos; pidfile _ pid &apos; &#93; = None DCNL DCSP DCSP if ( &apos; locking _ pid &apos; not in scenario ) : DCNL DCSP DCSP DCSP scenario &#91; &apos; locking _ pid &apos; &#93; = None DCNL DCSP DCSP if ( &apos; open _ func _ name &apos; not in scenario ) : DCNL DCSP DCSP DCSP scenario &#91; &apos; open _ func _ name &apos; &#93; = &apos; mock _ open _ okay &apos; DCNL DCSP DCSP if ( &apos; os _ open _ func _ name &apos; not in scenario ) : DCNL DCSP DCSP DCSP scenario &#91; &apos; os _ open _ func _ name &apos; &#93; = &apos; mock _ os _ open _ okay &apos; DCNL DCSP return scenarios
DCSP beginComplex = begin.dropAxis ( ) DCNL DCSP centerComplex = center.dropAxis ( ) DCNL DCSP endComplex = end.dropAxis ( ) DCNL DCSP beginComplexSegmentLength = abs ( ( centerComplex - beginComplex ) ) DCNL DCSP endComplexSegmentLength = abs ( ( centerComplex - endComplex ) ) DCNL DCSP minimumRadius = lineation.getMinimumRadius ( beginComplexSegmentLength , endComplexSegmentLength , radius ) DCNL DCSP if ( minimumRadius &lt; = close ) : DCNL DCSP DCSP return &#91; center &#93; DCNL DCSP beginBevel = ( center + ( ( minimumRadius / beginComplexSegmentLength ) * ( begin - center ) ) ) DCNL DCSP endBevel = ( center + ( ( minimumRadius / endComplexSegmentLength ) * ( end - center ) ) ) DCNL DCSP if ( radius &gt; 0.0 ) : DCNL DCSP DCSP return &#91; beginBevel , endBevel &#93; DCNL DCSP midpointComplex = ( 0.5 * ( beginBevel.dropAxis ( ) + endBevel.dropAxis ( ) ) ) DCNL DCSP spikeComplex = ( ( centerComplex + centerComplex ) - midpointComplex ) DCNL DCSP return &#91; beginBevel , Vector3 ( spikeComplex.real , spikeComplex.imag , center.z ) , endBevel &#93;
DCSP src = u ( &apos; from DCSP _ _ future _ _ DCSP import DCSP absolute _ import \ nimport DCSP xyzzy &apos; ) DCNL DCSP parser = ParserWithRecovery ( load _ grammar ( ) , src , &apos; test.py &apos; ) DCNL DCSP assert parser.module.has _ explicit _ absolute _ import
DCSP with Timeout ( conn _ timeout ) : DCNL DCSP DCSP conn = http _ connect ( node &#91; &apos; ip &apos; &#93; , node &#91; &apos; port &apos; &#93; , node &#91; &apos; device &apos; &#93; , part , method , path , headers = _ headers ) DCNL DCSP with Timeout ( response _ timeout ) : DCNL DCSP DCSP resp = conn.getresponse ( ) DCNL DCSP DCSP resp.read ( ) DCNL DCSP if ( not is _ success ( resp.status ) ) : DCNL DCSP DCSP raise DirectClientException ( stype , method , node , part , path , resp ) DCNL DCSP return resp
DCSP ( max _ length , nr _ hidden , nr _ class ) = shape DCNL DCSP ids1 = Input ( shape = ( max _ length , ) , dtype = &apos; int32 &apos; , name = &apos; words1 &apos; ) DCNL DCSP ids2 = Input ( shape = ( max _ length , ) , dtype = &apos; int32 &apos; , name = &apos; words2 &apos; ) DCNL DCSP embed = _ StaticEmbedding ( vectors , max _ length , nr _ hidden , dropout = 0.2 , nr _ tune = 5000 ) DCNL DCSP if settings &#91; &apos; gru _ encode &apos; &#93; : DCNL DCSP DCSP encode = _ BiRNNEncoding ( max _ length , nr _ hidden , dropout = settings &#91; &apos; dropout &apos; &#93; ) DCNL DCSP attend = _ Attention ( max _ length , nr _ hidden , dropout = settings &#91; &apos; dropout &apos; &#93; ) DCNL DCSP align = _ SoftAlignment ( max _ length , nr _ hidden ) DCNL DCSP compare = _ Comparison ( max _ length , nr _ hidden , dropout = settings &#91; &apos; dropout &apos; &#93; ) DCNL DCSP entail = _ Entailment ( nr _ hidden , nr _ class , dropout = settings &#91; &apos; dropout &apos; &#93; ) DCNL DCSP sent1 = embed ( ids1 ) DCNL DCSP sent2 = embed ( ids2 ) DCNL DCSP if settings &#91; &apos; gru _ encode &apos; &#93; : DCNL DCSP DCSP sent1 = encode ( sent1 ) DCNL DCSP DCSP sent2 = encode ( sent2 ) DCNL DCSP attention = attend ( sent1 , sent2 ) DCNL DCSP align1 = align ( sent2 , attention ) DCNL DCSP align2 = align ( sent1 , attention , transpose = True ) DCNL DCSP feats1 = compare ( sent1 , align1 ) DCNL DCSP feats2 = compare ( sent2 , align2 ) DCNL DCSP scores = entail ( feats1 , feats2 ) DCNL DCSP model = Model ( input = &#91; ids1 , ids2 &#93; , output = &#91; scores &#93; ) DCNL DCSP model.compile ( optimizer = Adam ( lr = settings &#91; &apos; lr &apos; &#93; ) , loss = &apos; categorical _ crossentropy &apos; , metrics = &#91; &apos; accuracy &apos; &#93; ) DCNL DCSP return model
DCSP try : DCNL DCSP DCSP ( opts , args ) = getopt.getopt ( sys.argv &#91; 1 : &#93; , &apos; &apos; , &#91; &apos; email = &apos; , &apos; password = &apos; &#93; ) DCNL DCSP except getopt.error as msg : DCNL DCSP DCSP print &apos; python DCSP BloggerExample.py DCSP --email DCSP &#91; email &#93; DCSP --password DCSP &#91; password &#93; DCSP &apos; DCNL DCSP DCSP sys.exit ( 2 ) DCNL DCSP email = &apos; &apos; DCNL DCSP password = &apos; &apos; DCNL DCSP for ( o , a ) in opts : DCNL DCSP DCSP if ( o = = &apos; --email &apos; ) : DCNL DCSP DCSP DCSP email = a DCNL DCSP DCSP elif ( o = = &apos; --password &apos; ) : DCNL DCSP DCSP DCSP password = a DCNL DCSP if ( ( email = = &apos; &apos; ) or ( password = = &apos; &apos; ) ) : DCNL DCSP DCSP print &apos; python DCSP BloggerExample.py DCSP --email DCSP &#91; email &#93; DCSP --password DCSP &#91; password &#93; &apos; DCNL DCSP DCSP sys.exit ( 2 ) DCNL DCSP sample = BloggerExample ( email , password ) DCNL DCSP sample.run ( )
DCSP if ( ( len ( args ) = = 1 ) and ( args &#91; 0 &#93; .type in ( u &apos;NUMBER &apos; , u &apos;INTEGER &apos; ) ) ) : DCNL DCSP DCSP return min ( 1 , max ( 0 , args &#91; 0 &#93; .value ) )
DCSP fft = ( kernel = = &apos; gau &apos; ) DCNL DCSP kde = smnp.KDEUnivariate ( data ) DCNL DCSP kde.fit ( kernel , bw , fft , gridsize = gridsize , cut = cut , clip = clip ) DCNL DCSP if cumulative : DCNL DCSP DCSP ( grid , y ) = ( kde.support , kde.cdf ) DCNL DCSP else : DCNL DCSP DCSP ( grid , y ) = ( kde.support , kde.density ) DCNL DCSP return ( grid , y )
DCSP bits = token.split _ contents ( ) DCNL DCSP if ( ( len ( bits ) ! = 3 ) and ( len ( bits ) ! = 5 ) ) : DCNL DCSP DCSP raise TemplateSyntaxError ( &quot; &apos; version &apos; DCSP tag DCSP takes DCSP 2 DCSP or DCSP 4 DCSP arguments &quot; ) DCNL DCSP if ( ( len ( bits ) = = 5 ) and ( bits &#91; 3 &#93; ! = &apos; as &apos; ) ) : DCNL DCSP DCSP raise TemplateSyntaxError ( &quot; second DCSP argument DCSP to DCSP &apos; version &apos; DCSP tag DCSP must DCSP be DCSP &apos; as &apos; &quot; ) DCNL DCSP if ( len ( bits ) = = 3 ) : DCNL DCSP DCSP return VersionNode ( parser.compile _ filter ( bits &#91; 1 &#93; ) , parser.compile _ filter ( bits &#91; 2 &#93; ) , None ) DCNL DCSP if ( len ( bits ) = = 5 ) : DCNL DCSP DCSP return VersionNode ( parser.compile _ filter ( bits &#91; 1 &#93; ) , parser.compile _ filter ( bits &#91; 2 &#93; ) , bits &#91; 4 &#93; )
DCSP user = authenticate ( username , password , &apos; zinnia.add _ entry &apos; ) DCNL DCSP if post.get ( &apos; dateCreated &apos; ) : DCNL DCSP DCSP creation _ date = datetime.strptime ( post &#91; &apos; dateCreated &apos; &#93; .value &#91; : 18 &#93; , &apos; % Y- % m- % dT % H : % M : % S &apos; ) DCNL DCSP DCSP if settings.USE _ TZ : DCNL DCSP DCSP DCSP creation _ date = timezone.make _ aware ( creation _ date , timezone.utc ) DCNL DCSP else : DCNL DCSP DCSP creation _ date = timezone.now ( ) DCNL DCSP entry _ dict = { &apos; title &apos; : post &#91; &apos; title &apos; &#93; , &apos; content &apos; : post &#91; &apos; description &apos; &#93; , &apos; excerpt &apos; : post.get ( &apos; mt _ excerpt &apos; , &apos; &apos; ) , &apos; publication _ date &apos; : creation _ date , &apos; creation _ date &apos; : creation _ date , &apos; last _ update &apos; : creation _ date , &apos; comment _ enabled &apos; : ( post.get ( &apos; mt _ allow _ comments &apos; , 1 ) = = 1 ) , &apos; pingback _ enabled &apos; : ( post.get ( &apos; mt _ allow _ pings &apos; , 1 ) = = 1 ) , &apos; trackback _ enabled &apos; : ( post.get ( &apos; mt _ allow _ pings &apos; , 1 ) = = 1 ) , &apos; featured &apos; : ( post.get ( &apos; sticky &apos; , 0 ) = = 1 ) , &apos; tags &apos; : ( ( ( &apos; mt _ keywords &apos; in post ) and post &#91; &apos; mt _ keywords &apos; &#93; ) or &apos; &apos; ) , &apos; slug &apos; : ( ( ( &apos; wp _ slug &apos; in post ) and post &#91; &apos; wp _ slug &apos; &#93; ) or slugify ( post &#91; &apos; title &apos; &#93; ) ) , &apos; password &apos; : post.get ( &apos; wp _ password &apos; , &apos; &apos; ) } DCNL DCSP if user.has _ perm ( &apos; zinnia.can _ change _ status &apos; ) : DCNL DCSP DCSP entry _ dict &#91; &apos; status &apos; &#93; = ( ( publish and PUBLISHED ) or DRAFT ) DCNL DCSP entry = Entry.objects.create ( * * entry _ dict ) DCNL DCSP author = user DCNL DCSP if ( ( &apos; wp _ author _ id &apos; in post ) and user.has _ perm ( &apos; zinnia.can _ change _ author &apos; ) ) : DCNL DCSP DCSP if ( int ( post &#91; &apos; wp _ author _ id &apos; &#93; ) ! = user.pk ) : DCNL DCSP DCSP DCSP author = Author.objects.get ( pk = post &#91; &apos; wp _ author _ id &apos; &#93; ) DCNL DCSP entry.authors.add ( author ) DCNL DCSP entry.sites.add ( Site.objects.get _ current ( ) ) DCNL DCSP if ( &apos; categories &apos; in post ) : DCNL DCSP DCSP entry.categories.add ( * &#91; Category.objects.get _ or _ create ( title = cat , slug = slugify ( cat ) ) &#91; 0 &#93; for cat in post &#91; &apos; categories &apos; &#93; &#93; ) DCNL DCSP return entry.pk
DCSP pi = player &#91; &apos; index &apos; &#93; DCNL DCSP player &#91; &apos; w &apos; &#93; = IMAGES &#91; &apos; player &apos; &#93; &#91; 0 &#93; .get _ width ( ) DCNL DCSP player &#91; &apos; h &apos; &#93; = IMAGES &#91; &apos; player &apos; &#93; &#91; 0 &#93; .get _ height ( ) DCNL DCSP if ( ( player &#91; &apos; y &apos; &#93; + player &#91; &apos; h &apos; &#93; ) &gt; = ( BASEY - 1 ) ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP playerRect = pygame.Rect ( player &#91; &apos; x &apos; &#93; , player &#91; &apos; y &apos; &#93; , player &#91; &apos; w &apos; &#93; , player &#91; &apos; h &apos; &#93; ) DCNL DCSP DCSP for ( uPipe , lPipe ) in zip ( upperPipes , lowerPipes ) : DCNL DCSP DCSP DCSP uPipeRect = pygame.Rect ( uPipe &#91; &apos; x &apos; &#93; , uPipe &#91; &apos; y &apos; &#93; , PIPE _ WIDTH , PIPE _ HEIGHT ) DCNL DCSP DCSP DCSP lPipeRect = pygame.Rect ( lPipe &#91; &apos; x &apos; &#93; , lPipe &#91; &apos; y &apos; &#93; , PIPE _ WIDTH , PIPE _ HEIGHT ) DCNL DCSP DCSP DCSP pHitMask = HITMASKS &#91; &apos; player &apos; &#93; &#91; pi &#93; DCNL DCSP DCSP DCSP uHitmask = HITMASKS &#91; &apos; pipe &apos; &#93; &#91; 0 &#93; DCNL DCSP DCSP DCSP lHitmask = HITMASKS &#91; &apos; pipe &apos; &#93; &#91; 1 &#93; DCNL DCSP DCSP DCSP uCollide = pixelCollision ( playerRect , uPipeRect , pHitMask , uHitmask ) DCNL DCSP DCSP DCSP lCollide = pixelCollision ( playerRect , lPipeRect , pHitMask , lHitmask ) DCNL DCSP DCSP DCSP if ( uCollide or lCollide ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP return False
DCSP with smart _ open ( fname , &apos; rb &apos; ) as f : DCNL DCSP DCSP if ( sys.version _ info &gt; ( 3 , 0 ) ) : DCNL DCSP DCSP DCSP return _ pickle.load ( f , encoding = &apos; latin1 &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return _ pickle.loads ( f.read ( ) )
DCSP if ( not salt.utils.is _ windows ( ) ) : DCNL DCSP DCSP return ( False , &apos; Module DCSP win _ network : DCSP Only DCSP available DCSP on DCSP Windows &apos; ) DCNL DCSP if ( not HAS _ DEPENDENCIES ) : DCNL DCSP DCSP return ( False , &apos; Module DCSP win _ network : DCSP Missing DCSP dependencies &apos; ) DCNL DCSP global wol , get _ hostname , interface , interface _ ip , subnets6 , ip _ in _ subnet DCNL DCSP global convert _ cidr , calc _ net , get _ fqdn , ifacestartswith , iphexval DCNL DCSP wol = _ namespaced _ function ( wol , globals ( ) ) DCNL DCSP get _ hostname = _ namespaced _ function ( get _ hostname , globals ( ) ) DCNL DCSP interface = _ namespaced _ function ( interface , globals ( ) ) DCNL DCSP interface _ ip = _ namespaced _ function ( interface _ ip , globals ( ) ) DCNL DCSP subnets6 = _ namespaced _ function ( subnets6 , globals ( ) ) DCNL DCSP ip _ in _ subnet = _ namespaced _ function ( ip _ in _ subnet , globals ( ) ) DCNL DCSP convert _ cidr = _ namespaced _ function ( convert _ cidr , globals ( ) ) DCNL DCSP calc _ net = _ namespaced _ function ( calc _ net , globals ( ) ) DCNL DCSP get _ fqdn = _ namespaced _ function ( get _ fqdn , globals ( ) ) DCNL DCSP ifacestartswith = _ namespaced _ function ( ifacestartswith , globals ( ) ) DCNL DCSP iphexval = _ namespaced _ function ( iphexval , globals ( ) ) DCNL DCSP return _ _ virtualname _ _
DCSP if ( ( IPythonIOStream is not None ) and isinstance ( fileobj , IPythonIOStream ) ) : DCNL DCSP DCSP write = fileobj.stream.write DCNL DCSP try : DCNL DCSP DCSP write ( s ) DCNL DCSP DCSP return write DCNL DCSP except UnicodeEncodeError : DCNL DCSP DCSP pass DCNL DCSP enc = locale.getpreferredencoding ( ) DCNL DCSP try : DCNL DCSP DCSP Writer = codecs.getwriter ( enc ) DCNL DCSP except LookupError : DCNL DCSP DCSP Writer = codecs.getwriter ( _ DEFAULT _ ENCODING ) DCNL DCSP f = Writer ( fileobj ) DCNL DCSP write = f.write DCNL DCSP try : DCNL DCSP DCSP write ( s ) DCNL DCSP DCSP return write DCNL DCSP except UnicodeEncodeError : DCNL DCSP DCSP Writer = codecs.getwriter ( u &apos;latin-1 &apos; ) DCNL DCSP DCSP f = Writer ( fileobj ) DCNL DCSP DCSP write = f.write DCNL DCSP write ( s ) DCNL DCSP return write
DCSP if ( conn is None ) : DCNL DCSP DCSP conn = init ( ) DCNL DCSP existing _ files = &#91; &#93; DCNL DCSP for member in pkg _ files : DCNL DCSP DCSP if member.isdir ( ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP tld = formula _ def.get ( &apos; top _ level _ dir &apos; , package ) DCNL DCSP DCSP new _ name = member.name.replace ( &apos; { 0 } / &apos; .format ( package ) , &apos; &apos; ) DCNL DCSP DCSP if ( not new _ name.startswith ( tld ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if member.name.startswith ( &apos; { 0 } / _ &apos; .format ( package ) ) : DCNL DCSP DCSP DCSP out _ file = os.path.join ( conn &#91; &apos; formula _ path &apos; &#93; , new _ name ) DCNL DCSP DCSP elif ( member.name = = &apos; { 0 } / pillar.example &apos; .format ( package ) ) : DCNL DCSP DCSP DCSP new _ name = &apos; { 0 } .sls.orig &apos; .format ( package ) DCNL DCSP DCSP DCSP out _ file = os.path.join ( conn &#91; &apos; pillar _ path &apos; &#93; , new _ name ) DCNL DCSP DCSP elif package.endswith ( &apos; -conf &apos; ) : DCNL DCSP DCSP DCSP out _ file = os.path.join ( salt.syspaths.CONFIG _ DIR , new _ name ) DCNL DCSP DCSP elif package.endswith ( &apos; -reactor &apos; ) : DCNL DCSP DCSP DCSP out _ file = os.path.join ( conn &#91; &apos; reactor _ path &apos; &#93; , member.name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP out _ file = os.path.join ( conn &#91; &apos; formula _ path &apos; &#93; , member.name ) DCNL DCSP DCSP if os.path.exists ( out _ file ) : DCNL DCSP DCSP DCSP existing _ files.append ( out _ file ) DCNL DCSP DCSP DCSP if ( not _ _ opts _ _ &#91; &apos; force &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP log.error ( &apos; { 0 } DCSP already DCSP exists , DCSP not DCSP installing &apos; .format ( out _ file ) ) DCNL DCSP return existing _ files
DCSP ratio = &apos; auto &apos; DCNL DCSP classifier = RandomForestClassifier ( random _ state = RND _ SEED ) DCNL DCSP bc = BalanceCascade ( ratio = ratio , random _ state = RND _ SEED , return _ indices = True , estimator = classifier ) DCNL DCSP ( X _ resampled , y _ resampled , idx _ under ) = bc.fit _ sample ( X , Y ) DCNL DCSP X _ gt = np.array ( &#91; np.array ( &#91; &#91; 0.11622591 , ( -0.0317206 ) &#93; , &#91; 1.25192108 , ( -0.22367336 ) &#93; , &#91; 0.53366841 , ( -0.30312976 ) &#93; , &#91; 1.52091956 , ( -0.49283504 ) &#93; , &#91; 0.88407872 , 0.35454207 &#93; , &#91; 1.31301027 , ( -0.92648734 ) &#93; , &#91; ( -0.41635887 ) , ( -0.38299653 ) &#93; , &#91; 1.70580611 , ( -0.11219234 ) &#93; , &#91; 1.15514042 , 0.0129463 &#93; , &#91; 0.08711622 , 0.93259929 &#93; , &#91; 0.70472253 , ( -0.73309052 ) &#93; , &#91; ( -0.14374509 ) , 0.27370049 &#93; , &#91; 0.83680821 , 1.72827342 &#93; , &#91; ( -0.18410027 ) , ( -0.45194484 ) &#93; , &#91; ( -0.28162401 ) , ( -2.10400981 ) &#93; , &#91; ( -1.11515198 ) , ( -0.93689695 ) &#93; &#93; ) , np.array ( &#91; &#91; 0.11622591 , ( -0.0317206 ) &#93; , &#91; 1.25192108 , ( -0.22367336 ) &#93; , &#91; 0.53366841 , ( -0.30312976 ) &#93; , &#91; 1.52091956 , ( -0.49283504 ) &#93; , &#91; 0.88407872 , 0.35454207 &#93; , &#91; 1.31301027 , ( -0.92648734 ) &#93; , &#91; ( -0.41635887 ) , ( -0.38299653 ) &#93; , &#91; 1.70580611 , ( -0.11219234 ) &#93; , &#91; 1.15514042 , 0.0129463 &#93; , &#91; ( -0.14374509 ) , 0.27370049 &#93; , &#91; ( -1.11515198 ) , ( -0.93689695 ) &#93; , &#91; 0.77481731 , 0.60935141 &#93; , &#91; 0.3084254 , 0.33299982 &#93; , &#91; 0.28893132 , ( -0.38761769 ) &#93; , &#91; 0.9281014 , 0.53085498 &#93; &#93; ) &#93; , dtype = object ) DCNL DCSP y _ gt = np.array ( &#91; np.array ( &#91; 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 &#93; ) , np.array ( &#91; 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 &#93; ) &#93; , dtype = object ) DCNL DCSP idx _ gt = np.array ( &#91; np.array ( &#91; 0 , 2 , 3 , 4 , 11 , 12 , 17 , 19 , 10 , 18 , 8 , 16 , 6 , 14 , 5 , 13 &#93; ) , np.array ( &#91; 0 , 2 , 3 , 4 , 11 , 12 , 17 , 19 , 10 , 16 , 13 , 1 , 7 , 9 , 15 &#93; ) &#93; , dtype = object ) DCNL DCSP for idx in range ( X _ gt.size ) : DCNL DCSP DCSP assert _ array _ equal ( X _ resampled &#91; idx &#93; , X _ gt &#91; idx &#93; ) DCNL DCSP DCSP assert _ array _ equal ( y _ resampled &#91; idx &#93; , y _ gt &#91; idx &#93; ) DCNL DCSP DCSP assert _ array _ equal ( idx _ under &#91; idx &#93; , idx _ gt &#91; idx &#93; )
DCSP if ( len ( args ) &gt; 1 ) : DCNL DCSP DCSP raise Exception ( &apos; Too DCSP many DCSP unnamed DCSP parameters DCSP supplied &apos; ) DCNL DCSP if args : DCNL DCSP DCSP kwargs &#91; &apos; controller &apos; &#93; = kwargs.get ( &apos; controller &apos; ) DCNL DCSP DCSP log.warning ( &apos; h.nav _ link ( ) DCSP please DCSP supply DCSP controller DCSP as DCSP a DCSP named DCSP parameter DCSP not DCSP a DCSP positional DCSP one &apos; ) DCNL DCSP named _ route = kwargs.pop ( &apos; named _ route &apos; , &apos; &apos; ) DCNL DCSP if kwargs.pop ( &apos; condition &apos; , True ) : DCNL DCSP DCSP if named _ route : DCNL DCSP DCSP DCSP link = _ link _ to ( text , named _ route , * * kwargs ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP link = _ link _ to ( text , * * kwargs ) DCNL DCSP else : DCNL DCSP DCSP link = &apos; &apos; DCNL DCSP return link
DCSP roles = { } DCNL DCSP with salt.utils.fopen ( &apos; / etc / user _ attr &apos; , &apos; r &apos; ) as user _ attr : DCNL DCSP DCSP for role in user _ attr : DCNL DCSP DCSP DCSP role = role.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP if ( len ( role ) ! = 5 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP attrs = { } DCNL DCSP DCSP DCSP for attr in role &#91; 4 &#93; .split ( &apos; ; &apos; ) : DCNL DCSP DCSP DCSP DCSP ( attr _ key , attr _ val ) = attr.split ( &apos; = &apos; ) DCNL DCSP DCSP DCSP DCSP if ( attr _ key in &#91; &apos; auths &apos; , &apos; profiles &apos; , &apos; roles &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP attrs &#91; attr _ key &#93; = attr _ val.split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP attrs &#91; attr _ key &#93; = attr _ val DCNL DCSP DCSP DCSP role &#91; 4 &#93; = attrs DCNL DCSP DCSP DCSP if ( ( &apos; type &apos; in role &#91; 4 &#93; ) and ( role &#91; 4 &#93; &#91; &apos; type &apos; &#93; = = &apos; role &apos; ) ) : DCNL DCSP DCSP DCSP DCSP del role &#91; 4 &#93; &#91; &apos; type &apos; &#93; DCNL DCSP DCSP DCSP DCSP roles &#91; role &#91; 0 &#93; &#93; = role &#91; 4 &#93; DCNL DCSP return roles
DCSP XML.SubElement ( xml _ parent , &apos; hudson.plugins.claim.ClaimPublisher &apos; )
DCSP request = context &#91; &apos; request &apos; &#93; DCNL DCSP try : DCNL DCSP DCSP lang _ code = request.LANGUAGE _ CODE DCNL DCSP except AttributeError : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP if ( ( lang _ code = = &apos; en &apos; ) or ( lang _ code not in settings.SUPPORTED _ LANGUAGES ) ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP href = get _ asset _ url ( &apos; sentry &apos; , ( ( &apos; dist / locale / &apos; + lang _ code ) + &apos; .js &apos; ) ) DCNL DCSP return &apos; &lt; script DCSP src = &quot; { 0 } &quot; { 1 } &gt; &lt; / script &gt; &apos; .format ( href , crossorigin ( ) )
DCSP if ( operation = = &apos; insert &apos; ) : DCNL DCSP DCSP raise DocumentTooLarge ( ( &apos; BSON DCSP document DCSP too DCSP large DCSP ( % d DCSP bytes ) DCSP - DCSP the DCSP connected DCSP server DCSP supports DCSP BSON DCSP document DCSP sizes DCSP up DCSP to DCSP % d DCSP bytes . &apos; % ( doc _ size , max _ size ) ) ) DCNL DCSP else : DCNL DCSP DCSP raise DocumentTooLarge ( &apos; command DCSP document DCSP too DCSP large &apos; )
DCSP dtype = ( tf.float16 if FLAGS.use _ fp16 else tf.float32 ) DCNL DCSP model = seq2seq _ model.Seq2SeqModel ( FLAGS.from _ vocab _ size , FLAGS.to _ vocab _ size , _ buckets , FLAGS.size , FLAGS.num _ layers , FLAGS.max _ gradient _ norm , FLAGS.batch _ size , FLAGS.learning _ rate , FLAGS.learning _ rate _ decay _ factor , forward _ only = forward _ only , dtype = dtype ) DCNL DCSP ckpt = tf.train.get _ checkpoint _ state ( FLAGS.train _ dir ) DCNL DCSP if ( ckpt and tf.train.checkpoint _ exists ( ckpt.model _ checkpoint _ path ) ) : DCNL DCSP DCSP print ( ( &apos; Reading DCSP model DCSP parameters DCSP from DCSP % s &apos; % ckpt.model _ checkpoint _ path ) ) DCNL DCSP DCSP model.saver.restore ( session , ckpt.model _ checkpoint _ path ) DCNL DCSP else : DCNL DCSP DCSP print ( &apos; Created DCSP model DCSP with DCSP fresh DCSP parameters . &apos; ) DCNL DCSP DCSP session.run ( tf.global _ variables _ initializer ( ) ) DCNL DCSP return model
DCSP return Dovado ( ) .setup ( hass , config , add _ devices )
DCSP profile _ name = ( session.get _ config _ variable ( &apos; profile &apos; ) or &apos; default &apos; ) DCNL DCSP credential _ file = session.get _ config _ variable ( &apos; credentials _ file &apos; ) DCNL DCSP config _ file = session.get _ config _ variable ( &apos; config _ file &apos; ) DCNL DCSP metadata _ timeout = session.get _ config _ variable ( &apos; metadata _ service _ timeout &apos; ) DCNL DCSP num _ attempts = session.get _ config _ variable ( &apos; metadata _ service _ num _ attempts &apos; ) DCNL DCSP env _ provider = EnvProvider ( ) DCNL DCSP providers = &#91; env _ provider , AssumeRoleProvider ( load _ config = ( lambda : session.full _ config ) , client _ creator = session.create _ client , cache = { } , profile _ name = profile _ name ) , SharedCredentialProvider ( creds _ filename = credential _ file , profile _ name = profile _ name ) , ConfigProvider ( config _ filename = config _ file , profile _ name = profile _ name ) , OriginalEC2Provider ( ) , BotoProvider ( ) , ContainerProvider ( ) , InstanceMetadataProvider ( iam _ role _ fetcher = InstanceMetadataFetcher ( timeout = metadata _ timeout , num _ attempts = num _ attempts ) ) &#93; DCNL DCSP explicit _ profile = session.get _ config _ variable ( &apos; profile &apos; , methods = ( &apos; instance &apos; , ) ) DCNL DCSP if ( explicit _ profile is not None ) : DCNL DCSP DCSP providers.remove ( env _ provider ) DCNL DCSP DCSP logger.debug ( &apos; Skipping DCSP environment DCSP variable DCSP credential DCSP check DCSP because DCSP profile DCSP name DCSP was DCSP explicitly DCSP set . &apos; ) DCNL DCSP resolver = CredentialResolver ( providers = providers ) DCNL DCSP return resolver
DCSP MARKER = &apos; # DCSP Everything DCSP below DCSP is DCSP ignored \ n &apos; DCNL DCSP message = click.edit ( ( &apos; \ n \ n &apos; + MARKER ) ) DCNL DCSP if ( message is not None ) : DCNL DCSP DCSP msg = message.split ( MARKER , 1 ) &#91; 0 &#93; .rstrip ( &apos; \ n &apos; ) DCNL DCSP DCSP if ( not msg ) : DCNL DCSP DCSP DCSP click.echo ( &apos; Empty DCSP message ! &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP click.echo ( ( &apos; Message : \ n &apos; + msg ) ) DCNL DCSP else : DCNL DCSP DCSP click.echo ( &apos; You DCSP did DCSP not DCSP enter DCSP anything ! &apos; )
DCSP a = rs.randn ( 3 , 20 ) DCNL DCSP for n _ i in &#91; 5 , 10 &#93; : DCNL DCSP DCSP ( p _ mat , dist ) = algo.randomize _ corrmat ( a , n _ iter = n _ i , return _ dist = True ) DCNL DCSP DCSP assert _ equal ( n _ i , dist.shape &#91; ( -1 ) &#93; ) DCNL DCSP ( p _ mat , dist ) = algo.randomize _ corrmat ( a , n _ iter = 10000 , return _ dist = True ) DCNL DCSP diag _ mean = dist &#91; ( 0 , 0 ) &#93; .mean ( ) DCNL DCSP assert _ equal ( diag _ mean , 1 ) DCNL DCSP off _ diag _ mean = dist &#91; ( 0 , 1 ) &#93; .mean ( ) DCNL DCSP nose.tools.assert _ greater ( 0.05 , off _ diag _ mean )
DCSP if isinstance ( value , dict ) : DCNL DCSP DCSP entry = u &apos; { } : DCSP { } &apos; .format DCNL DCSP DCSP retval = u &apos; { &apos; DCNL DCSP DCSP for ( key , val ) in list ( value.items ( ) ) : DCNL DCSP DCSP DCSP if ( len ( retval ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP retval + = u &apos; , DCSP &apos; DCNL DCSP DCSP DCSP kenc = repr ( key ) DCNL DCSP DCSP DCSP if kenc.startswith ( ( u &quot; u &apos; &quot; , u &apos;u &quot; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP kenc = kenc &#91; 1 : &#93; DCNL DCSP DCSP DCSP venc = to _ str _ py27 ( val ) DCNL DCSP DCSP DCSP if venc.startswith ( ( u &quot; u &apos; &quot; , u &apos;u &quot; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP venc = venc &#91; 1 : &#93; DCNL DCSP DCSP DCSP retval + = entry ( kenc , venc ) DCNL DCSP DCSP retval + = u &apos; } &apos; DCNL DCSP DCSP return retval DCNL DCSP istuple = isinstance ( value , tuple ) DCNL DCSP if isinstance ( value , ( tuple , list ) ) : DCNL DCSP DCSP retval = ( u &apos; ( &apos; if istuple else u &apos; &#91; &apos; ) DCNL DCSP DCSP nels = len ( value ) DCNL DCSP DCSP for ( i , v ) in enumerate ( value ) : DCNL DCSP DCSP DCSP venc = to _ str _ py27 ( v ) DCNL DCSP DCSP DCSP if venc.startswith ( ( u &quot; u &apos; &quot; , u &apos;u &quot; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP venc = venc &#91; 1 : &#93; DCNL DCSP DCSP DCSP retval + = venc DCNL DCSP DCSP DCSP if ( i &lt; ( nels - 1 ) ) : DCNL DCSP DCSP DCSP DCSP retval + = u &apos; , DCSP &apos; DCNL DCSP DCSP if ( istuple and ( nels = = 1 ) ) : DCNL DCSP DCSP DCSP retval + = u &apos; , &apos; DCNL DCSP DCSP retval + = ( u &apos; ) &apos; if istuple else u &apos; &#93; &apos; ) DCNL DCSP DCSP return retval DCNL DCSP retval = repr ( value ) .decode ( ) DCNL DCSP if retval.startswith ( ( u &quot; u &apos; &quot; , u &apos;u &quot; &apos; ) ) : DCNL DCSP DCSP retval = retval &#91; 1 : &#93; DCNL DCSP return retval
DCSP C1 = get _ numbered _ constants ( eq , num = 1 ) DCNL DCSP ( u , v , w ) = symbols ( &apos; u , DCSP v , DCSP w &apos; ) DCNL DCSP p = Wild ( &apos; p &apos; , exclude = &#91; x ( t ) , y ( t ) , z ( t ) , t &#93; ) DCNL DCSP q = Wild ( &apos; q &apos; , exclude = &#91; x ( t ) , y ( t ) , z ( t ) , t &#93; ) DCNL DCSP s = Wild ( &apos; s &apos; , exclude = &#91; x ( t ) , y ( t ) , z ( t ) , t &#93; ) DCNL DCSP ( F1 , F2 , F3 ) = symbols ( &apos; F1 , DCSP F2 , DCSP F3 &apos; , cls = Wild ) DCNL DCSP r1 = eq &#91; 0 &#93; .match ( ( diff ( x ( t ) , t ) - ( x ( t ) * ( F2 - F3 ) ) ) ) DCNL DCSP r = collect _ const ( r1 &#91; F2 &#93; ) .match ( ( s * F2 ) ) DCNL DCSP r.update ( collect _ const ( r1 &#91; F3 &#93; ) .match ( ( q * F3 ) ) ) DCNL DCSP if ( eq &#91; 1 &#93; .has ( r &#91; F2 &#93; ) and ( not eq &#91; 1 &#93; .has ( r &#91; F3 &#93; ) ) ) : DCNL DCSP DCSP ( r &#91; F2 &#93; , r &#91; F3 &#93; ) = ( r &#91; F3 &#93; , r &#91; F2 &#93; ) DCNL DCSP DCSP ( r &#91; s &#93; , r &#91; q &#93; ) = ( ( - r &#91; q &#93; ) , ( - r &#91; s &#93; ) ) DCNL DCSP r.update ( ( diff ( y ( t ) , t ) - eq &#91; 1 &#93; ) .match ( ( y ( t ) * ( ( a * r &#91; F3 &#93; ) - ( r &#91; c &#93; * F1 ) ) ) ) ) DCNL DCSP a = r &#91; p &#93; DCNL DCSP b = r &#91; q &#93; DCNL DCSP c = r &#91; s &#93; DCNL DCSP F1 = r &#91; F1 &#93; .subs ( x ( t ) , u ) .subs ( y ( t ) , v ) .subs ( z ( t ) , w ) DCNL DCSP F2 = r &#91; F2 &#93; .subs ( x ( t ) , u ) .subs ( y ( t ) , v ) .subs ( z ( t ) , w ) DCNL DCSP F3 = r &#91; F3 &#93; .subs ( x ( t ) , u ) .subs ( y ( t ) , v ) .subs ( z ( t ) , w ) DCNL DCSP x _ yz = ( ( ( C1 * ( v * * ( - b ) ) ) * ( w * * ( - c ) ) ) * * ( - a ) ) DCNL DCSP y _ zx = ( ( ( C1 * ( w * * ( - c ) ) ) * ( u * * ( - a ) ) ) * * ( - b ) ) DCNL DCSP z _ xy = ( ( ( C1 * ( u * * ( - a ) ) ) * ( v * * ( - b ) ) ) * * ( - c ) ) DCNL DCSP y _ x = dsolve ( ( diff ( v ( u ) , u ) - ( ( v * ( ( a * F3 ) - ( c * F1 ) ) ) / ( u * ( ( c * F2 ) - ( b * F3 ) ) ) ) .subs ( w , z _ xy ) .subs ( v , v ( u ) ) ) ) .rhs DCNL DCSP z _ x = dsolve ( ( diff ( w ( u ) , u ) - ( ( w * ( ( b * F1 ) - ( a * F2 ) ) ) / ( u * ( ( c * F2 ) - ( b * F3 ) ) ) ) .subs ( v , y _ zx ) .subs ( w , w ( u ) ) ) ) .rhs DCNL DCSP z _ y = dsolve ( ( diff ( w ( v ) , v ) - ( ( w * ( ( b * F1 ) - ( a * F2 ) ) ) / ( v * ( ( a * F3 ) - ( c * F1 ) ) ) ) .subs ( u , x _ yz ) .subs ( w , w ( v ) ) ) ) .rhs DCNL DCSP x _ y = dsolve ( ( diff ( u ( v ) , v ) - ( ( u * ( ( c * F2 ) - ( b * F3 ) ) ) / ( v * ( ( a * F3 ) - ( c * F1 ) ) ) ) .subs ( w , z _ xy ) .subs ( u , u ( v ) ) ) ) .rhs DCNL DCSP y _ z = dsolve ( ( diff ( v ( w ) , w ) - ( ( v * ( ( a * F3 ) - ( c * F1 ) ) ) / ( w * ( ( b * F1 ) - ( a * F2 ) ) ) ) .subs ( u , x _ yz ) .subs ( v , v ( w ) ) ) ) .rhs DCNL DCSP x _ z = dsolve ( ( diff ( u ( w ) , w ) - ( ( u * ( ( c * F2 ) - ( b * F3 ) ) ) / ( w * ( ( b * F1 ) - ( a * F2 ) ) ) ) .subs ( v , y _ zx ) .subs ( u , u ( w ) ) ) ) .rhs DCNL DCSP sol1 = dsolve ( ( diff ( u ( t ) , t ) - ( u * ( ( c * F2 ) - ( b * F3 ) ) ) .subs ( v , y _ x ) .subs ( w , z _ x ) .subs ( u , u ( t ) ) ) ) .rhs DCNL DCSP sol2 = dsolve ( ( diff ( v ( t ) , t ) - ( v * ( ( a * F3 ) - ( c * F1 ) ) ) .subs ( u , x _ y ) .subs ( w , z _ y ) .subs ( v , v ( t ) ) ) ) .rhs DCNL DCSP sol3 = dsolve ( ( diff ( w ( t ) , t ) - ( w * ( ( b * F1 ) - ( a * F2 ) ) ) .subs ( u , x _ z ) .subs ( v , y _ z ) .subs ( w , w ( t ) ) ) ) .rhs DCNL DCSP return &#91; Eq ( x ( t ) , sol1 ) , Eq ( y ( t ) , sol2 ) , Eq ( z ( t ) , sol3 ) &#93;
DCSP from sabnzbd.encoding import unicoder DCNL DCSP if ( path = = &apos; &apos; ) : DCNL DCSP DCSP if NT : DCNL DCSP DCSP DCSP entries = &#91; { &apos; name &apos; : ( letter + &apos; : \ \ &apos; ) , &apos; path &apos; : ( letter + &apos; : \ \ &apos; ) } for letter in get _ win _ drives ( ) &#93; DCNL DCSP DCSP DCSP entries.insert ( 0 , { &apos; current _ path &apos; : &apos; Root &apos; } ) DCNL DCSP DCSP DCSP return entries DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP path = &apos; / &apos; DCNL DCSP path = sabnzbd.misc.real _ path ( sabnzbd.DIR _ HOME , path ) DCNL DCSP while ( path and ( not os.path.isdir ( path ) ) ) : DCNL DCSP DCSP if ( path = = os.path.dirname ( path ) ) : DCNL DCSP DCSP DCSP return folders _ at _ path ( &apos; &apos; , include _ parent ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP path = os.path.dirname ( path ) DCNL DCSP path = os.path.abspath ( os.path.normpath ( path ) ) DCNL DCSP parent _ path = os.path.dirname ( path ) DCNL DCSP if ( ( path = = parent _ path ) and ( os.name = = &apos; nt &apos; ) ) : DCNL DCSP DCSP parent _ path = &apos; &apos; DCNL DCSP file _ list = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP for filename in os.listdir ( path ) : DCNL DCSP DCSP DCSP fpath = os.path.join ( path , filename ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if NT : DCNL DCSP DCSP DCSP DCSP DCSP doit = ( ( ( win32api.GetFileAttributes ( fpath ) &amp; MASK ) = = TMASK ) and ( filename ! = &apos; PerfLogs &apos; ) ) DCNL DCSP DCSP DCSP DCSP elif ( not show _ hidden ) : DCNL DCSP DCSP DCSP DCSP DCSP doit = ( not filename.startswith ( &apos; .&apos; ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP doit = True DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP doit = False DCNL DCSP DCSP DCSP if doit : DCNL DCSP DCSP DCSP DCSP file _ list.append ( { &apos; name &apos; : unicoder ( filename ) , &apos; path &apos; : unicoder ( fpath ) } ) DCNL DCSP DCSP file _ list = filter ( ( lambda entry : os.path.isdir ( entry &#91; &apos; path &apos; &#93; ) ) , file _ list ) DCNL DCSP DCSP file _ list = filter ( ( lambda entry : ( entry &#91; &apos; name &apos; &#93; .lower ( ) not in _ JUNKFOLDERS ) ) , file _ list ) DCNL DCSP DCSP file _ list = sorted ( file _ list , ( lambda x , y : cmp ( os.path.basename ( x &#91; &apos; name &apos; &#93; ) .lower ( ) , os.path.basename ( y &#91; &apos; path &apos; &#93; ) .lower ( ) ) ) ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP file _ list.insert ( 0 , { &apos; current _ path &apos; : path } ) DCNL DCSP if ( include _ parent and ( parent _ path ! = path ) ) : DCNL DCSP DCSP file _ list.insert ( 1 , { &apos; name &apos; : &apos; .. &apos; , &apos; path &apos; : parent _ path } ) DCNL DCSP return file _ list
DCSP return &apos; / usr / lib / libgalera _ smm.so&apos;
DCSP names = &apos; A1 DCSP A2 DCSP Fz DCSP O DCSP BIO1 DCSP BIO2 DCSP BIO3 &apos; .split ( ) DCNL DCSP types = &apos; mag DCSP mag DCSP eeg DCSP eeg DCSP bio DCSP bio DCSP bio &apos; .split ( ) DCNL DCSP info = create _ info ( names , 1024.0 , types ) DCNL DCSP idx = channel _ indices _ by _ type ( info ) DCNL DCSP assert _ array _ equal ( idx &#91; &apos; mag &apos; &#93; , &#91; 0 , 1 &#93; ) DCNL DCSP assert _ array _ equal ( idx &#91; &apos; eeg &apos; &#93; , &#91; 2 , 3 &#93; ) DCNL DCSP assert _ array _ equal ( idx &#91; &apos; bio &apos; &#93; , &#91; 4 , 5 , 6 &#93; )
DCSP sig = inspect.signature ( func ) DCNL DCSP args = &#91; &#93; DCNL DCSP for ( arg _ name , param ) in sig.parameters.items ( ) : DCNL DCSP DCSP name = arg _ name DCNL DCSP DCSP if ( name = = &apos; self &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( param.kind = = inspect.Parameter.VAR _ POSITIONAL ) : DCNL DCSP DCSP DCSP name = ( &apos; * &apos; + name ) DCNL DCSP DCSP elif ( param.kind = = inspect.Parameter.VAR _ KEYWORD ) : DCNL DCSP DCSP DCSP name = ( &apos; * * &apos; + name ) DCNL DCSP DCSP if ( param.default ! = inspect.Parameter.empty ) : DCNL DCSP DCSP DCSP args.append ( ( name , param.default ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP args.append ( ( name , ) ) DCNL DCSP return args
DCSP ch = text &#91; i &#93; DCNL DCSP if ( ch in space _ chars ) : DCNL DCSP DCSP return &#91; ( 1 , None ) &#93; DCNL DCSP if ( ch = = u &apos; / &apos; ) : DCNL DCSP DCSP m = self _ closing _ pat.match ( text , i ) DCNL DCSP DCSP if ( m is None ) : DCNL DCSP DCSP DCSP return &#91; ( 1 , formats &#91; u &apos; / &apos; &#93; ) &#93; DCNL DCSP DCSP state.parse = NORMAL DCNL DCSP DCSP l = len ( m.group ( ) ) DCNL DCSP DCSP add _ tag _ data ( user _ data , TagEnd ( ( ( i + l ) - 1 ) , True , False ) ) DCNL DCSP DCSP return &#91; ( l , formats &#91; u &apos;tag &apos; &#93; ) &#93; DCNL DCSP if ( ch = = u &apos; &gt; &apos; ) : DCNL DCSP DCSP finish _ opening _ tag ( state , cdata _ tags ) DCNL DCSP DCSP add _ tag _ data ( user _ data , TagEnd ( i , False , False ) ) DCNL DCSP DCSP return &#91; ( 1 , formats &#91; u &apos;tag &apos; &#93; ) &#93; DCNL DCSP m = attribute _ name _ pat.match ( text , i ) DCNL DCSP if ( m is None ) : DCNL DCSP DCSP return &#91; ( 1 , formats &#91; u &apos; ? &apos; &#93; ) &#93; DCNL DCSP state.parse = ATTRIBUTE _ NAME DCNL DCSP attrname = state.attribute _ name = m.group ( ) DCNL DCSP add _ attr _ data ( user _ data , ATTR _ NAME , attrname , m.start ( ) ) DCNL DCSP ( prefix , name ) = attrname.partition ( u &apos; : &apos; ) &#91; 0 : : 2 &#93; DCNL DCSP if ( ( not prefix ) and ( not name ) ) : DCNL DCSP DCSP return &#91; ( len ( attrname ) , formats &#91; u &apos; ? &apos; &#93; ) &#93; DCNL DCSP if ( prefix and name ) : DCNL DCSP DCSP return &#91; ( ( len ( prefix ) + 1 ) , formats &#91; u &apos;nsprefix &apos; &#93; ) , ( len ( name ) , formats &#91; u &apos;attr &apos; &#93; ) &#93; DCNL DCSP return &#91; ( len ( prefix ) , formats &#91; u &apos;attr &apos; &#93; ) &#93;
DCSP if ( count is None ) : DCNL DCSP DCSP count = ( -1 ) DCNL DCSP if ( not eval _ ctx.autoescape ) : DCNL DCSP DCSP return text _ type ( s ) .replace ( text _ type ( old ) , text _ type ( new ) , count ) DCNL DCSP if ( hasattr ( old , &apos; _ _ html _ _ &apos; ) or ( hasattr ( new , &apos; _ _ html _ _ &apos; ) and ( not hasattr ( s , &apos; _ _ html _ _ &apos; ) ) ) ) : DCNL DCSP DCSP s = escape ( s ) DCNL DCSP else : DCNL DCSP DCSP s = soft _ unicode ( s ) DCNL DCSP return s.replace ( soft _ unicode ( old ) , soft _ unicode ( new ) , count )
DCSP if isinstance ( s , six.binary _ type ) : DCNL DCSP DCSP s = s.decode ( ( encoding or default _ encoding ) ) DCNL DCSP return _ unquote _ re.sub ( _ entity _ subber , s )
DCSP order _ book _ id = assure _ order _ book _ id ( id _ or _ ins ) DCNL DCSP round _ lot = int ( get _ data _ proxy ( ) .instrument ( order _ book _ id ) .round _ lot ) DCNL DCSP return order _ shares ( order _ book _ id , ( amount * round _ lot ) , style )
DCSP @ hug.get ( requires = hug.authentication.basic ( hug.authentication.verify ( &apos; Tim &apos; , &apos; Custom DCSP password &apos; ) ) ) DCNL DCSP def hello _ world ( ) : DCNL DCSP DCSP return &apos; Hello DCSP world ! &apos; DCNL DCSP assert ( &apos; 401 &apos; in hug.test.get ( api , &apos; hello _ world &apos; ) .status ) DCNL DCSP assert ( &apos; 401 &apos; in hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : &apos; Not DCSP correctly DCSP formed &apos; } ) .status ) DCNL DCSP assert ( &apos; 401 &apos; in hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : &apos; Nospaces &apos; } ) .status ) DCNL DCSP assert ( &apos; 401 &apos; in hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : &apos; Basic DCSP VXNlcjE6bXlwYXNzd29yZA &apos; } ) .status ) DCNL DCSP token = b64encode ( &apos; { 0 } : { 1 } &apos; .format ( &apos; Tim &apos; , &apos; Custom DCSP password &apos; ) .encode ( &apos; utf8 &apos; ) ) .decode ( &apos; utf8 &apos; ) DCNL DCSP assert ( hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : &apos; Basic DCSP { 0 } &apos; .format ( token ) } ) .data = = &apos; Hello DCSP world ! &apos; ) DCNL DCSP token = ( &apos; Basic DCSP &apos; + b64encode ( &apos; { 0 } : { 1 } &apos; .format ( &apos; Tim &apos; , &apos; Custom DCSP password &apos; ) .encode ( &apos; utf8 &apos; ) ) ) DCNL DCSP assert ( hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : token } ) .data = = &apos; Hello DCSP world ! &apos; ) DCNL DCSP token = ( &apos; Basic DCSP &apos; + b64encode ( &apos; { 0 } : { 1 } &apos; .format ( &apos; Tim &apos; , &apos; Wrong DCSP password &apos; ) .encode ( &apos; utf8 &apos; ) ) ) DCNL DCSP assert ( &apos; 401 &apos; in hug.test.get ( api , &apos; hello _ world &apos; , headers = { &apos; Authorization &apos; : token } ) .status )
DCSP flow _ dict = { } DCNL DCSP for u in G : DCNL DCSP DCSP flow _ dict &#91; u &#93; = dict ( ( ( v , 0 ) for v in G &#91; u &#93; ) ) DCNL DCSP DCSP flow _ dict &#91; u &#93; .update ( ( ( v , attr &#91; &apos; flow &apos; &#93; ) for ( v , attr ) in R &#91; u &#93; .items ( ) if ( attr &#91; &apos; flow &apos; &#93; &gt; 0 ) ) ) DCNL DCSP return flow _ dict
DCSP try : DCNL DCSP DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP conn.detach _ principal _ policy ( policyName = policyName , principal = principal ) DCNL DCSP DCSP return { &apos; detached &apos; : True } DCNL DCSP except ClientError as e : DCNL DCSP DCSP return { &apos; detached &apos; : False , &apos; error &apos; : salt.utils.boto3.get _ error ( e ) }
DCSP return ( not enabled ( name ) )
DCSP global DATA DCNL DCSP conf = config &#91; DOMAIN &#93; DCNL DCSP host = conf.get ( CONF _ HOST ) DCNL DCSP port = conf.get ( CONF _ PORT ) DCNL DCSP DATA = APCUPSdData ( host , port ) DCNL DCSP try : DCNL DCSP DCSP DATA.update ( no _ throttle = True ) DCNL DCSP except Exception : DCNL DCSP DCSP _ LOGGER.exception ( &apos; Failure DCSP while DCSP testing DCSP APCUPSd DCSP status DCSP retrieval . &apos; ) DCNL DCSP DCSP return False DCNL DCSP return True
DCSP try : DCNL DCSP DCSP return inspect.getfullargspec ( func ) DCNL DCSP except AttributeError : DCNL DCSP DCSP arg _ spec = inspect.getargspec ( func ) DCNL DCSP DCSP import collections DCNL DCSP DCSP tuple _ fields = &apos; args DCSP varargs DCSP varkw DCSP defaults DCSP kwonlyargs DCSP kwonlydefaults DCSP annotations &apos; DCNL DCSP DCSP tuple _ type = collections.namedtuple ( &apos; FullArgSpec &apos; , tuple _ fields ) DCNL DCSP DCSP return tuple _ type ( args = arg _ spec.args , varargs = arg _ spec.varargs , varkw = arg _ spec.keywords , defaults = arg _ spec.defaults , kwonlyargs = &#91; &#93; , kwonlydefaults = None , annotations = { } )
DCSP if ( data _ dict.get ( &apos; type &apos; ) = = &apos; organization &apos; ) : DCNL DCSP DCSP raise Exception ( _ ( &apos; Trying DCSP to DCSP create DCSP an DCSP organization DCSP as DCSP a DCSP group &apos; ) ) DCNL DCSP _ check _ access ( &apos; group _ create &apos; , context , data _ dict ) DCNL DCSP return _ group _ or _ org _ create ( context , data _ dict )
DCSP for item in children : DCNL DCSP DCSP if ( not item &#91; &apos; materialized &apos; &#93; .startswith ( &apos; / &apos; ) ) : DCNL DCSP DCSP DCSP item &#91; &apos; materialized &apos; &#93; = ( &apos; / &apos; + item &#91; &apos; materialized &apos; &#93; ) DCNL DCSP DCSP if ( item &#91; &apos; kind &apos; &#93; = = &apos; folder &apos; ) : DCNL DCSP DCSP DCSP return find _ and _ create _ file _ from _ metadata ( item.get ( &apos; children &apos; , &#91; &#93; ) , source , destination , destination _ node , obj ) DCNL DCSP DCSP elif ( ( item &#91; &apos; kind &apos; &#93; = = &apos; file &apos; ) and ( item &#91; &apos; materialized &apos; &#93; .replace ( destination &#91; &apos; materialized &apos; &#93; , source &#91; &apos; materialized &apos; &#93; ) = = obj.referent.materialized _ path ) ) : DCNL DCSP DCSP DCSP data = dict ( item ) DCNL DCSP DCSP DCSP new _ file = FileNode.resolve _ class ( destination &#91; &apos; provider &apos; &#93; , FileNode.FILE ) .get _ or _ create ( destination _ node , item &#91; &apos; path &apos; &#93; ) DCNL DCSP DCSP DCSP if ( destination &#91; &apos; provider &apos; &#93; ! = &apos; osfstorage &apos; ) : DCNL DCSP DCSP DCSP DCSP new _ file.update ( revision = None , data = data ) DCNL DCSP DCSP DCSP return new _ file
DCSP html _ string = u &apos; &lt; ! DOCTYPE DCSP html &gt; \ n DCSP DCSP DCSP DCSP &lt; head &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; style &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # content { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP width : 99 % ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP height : 100 % ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .node { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP background-color : # 7070FF ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP border-radius : DCSP 5px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP width : 20px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP white-space : pre-wrap ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .line { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : DCSP absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP color : DCSP # C2C2C2 ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP opacity : DCSP 0.5 ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP margin : DCSP 0px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .time { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : DCSP absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP font-size : DCSP 16px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP color : DCSP # 666666 ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP margin : DCSP 0px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .bar { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : DCSP absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP height : DCSP 1px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP opacity : DCSP 0.7 ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .dot { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP position : DCSP absolute ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP width : DCSP 1px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP height : DCSP 1px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP background-color : DCSP red ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .label DCSP { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP width : 20px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP height : 20px ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP opacity : DCSP 0.7 ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP display : DCSP inline-block ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; / style &gt; \ n DCSP DCSP DCSP DCSP &lt; / head &gt; \ n \ n DCSP DCSP DCSP DCSP &lt; body &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; div DCSP id = &quot; content &quot; &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; div DCSP style = &quot; display : inline-block ; &quot; &gt; \ n DCSP DCSP DCSP DCSP &apos; DCNL DCSP close _ header = u &apos; \ n DCSP DCSP DCSP DCSP &lt; / div &gt; \ n DCSP DCSP DCSP DCSP &lt; div DCSP style = &quot; display : inline-block ; margin-left : 60px ; vertical-align : DCSP top ; &quot; &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; p &gt; &lt; span &gt; &lt; div DCSP class = &quot; label &quot; DCSP style = &quot; background-color : # 90BBD7 ; &quot; &gt; &lt; / div &gt; DCSP Estimated DCSP Resource &lt; / span &gt; &lt; / p &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; p &gt; &lt; span &gt; &lt; div DCSP class = &quot; label &quot; DCSP style = &quot; background-color : # 03969D ; &quot; &gt; &lt; / div &gt; DCSP Actual DCSP Resource &lt; / span &gt; &lt; / p &gt; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; p &gt; &lt; span &gt; &lt; div DCSP class = &quot; label &quot; DCSP style = &quot; background-color : # f00 ; &quot; &gt; &lt; / div &gt; DCSP Failed DCSP Node &lt; / span &gt; &lt; / p &gt; \ n DCSP DCSP DCSP DCSP &lt; / div &gt; \ n DCSP DCSP DCSP DCSP &apos; DCNL DCSP nodes _ list = log _ to _ dict ( logfile ) DCNL DCSP start _ node = nodes _ list &#91; 0 &#93; DCNL DCSP last _ node = nodes _ list &#91; ( -1 ) &#93; DCNL DCSP duration = ( last _ node &#91; u &apos;finish &apos; &#93; - start _ node &#91; u &apos;start &apos; &#93; ) .total _ seconds ( ) DCNL DCSP events = create _ event _ dict ( start _ node &#91; u &apos;start &apos; &#93; , nodes _ list ) DCNL DCSP html _ string + = ( ( u &apos; &lt; p &gt; Start : DCSP &apos; + start _ node &#91; u &apos;start &apos; &#93; .strftime ( u &apos; % Y- % m- % d DCSP % H : % M : % S &apos; ) ) + u &apos; &lt; / p &gt; &apos; ) DCNL DCSP html _ string + = ( ( u &apos; &lt; p &gt; Finish : DCSP &apos; + last _ node &#91; u &apos;finish &apos; &#93; .strftime ( u &apos; % Y- % m- % d DCSP % H : % M : % S &apos; ) ) + u &apos; &lt; / p &gt; &apos; ) DCNL DCSP html _ string + = ( ( u &apos; &lt; p &gt; Duration : DCSP &apos; + u &apos; { 0 : .2f } &apos; .format ( ( duration / 60 ) ) ) + u &apos; DCSP minutes &lt; / p &gt; &apos; ) DCNL DCSP html _ string + = ( ( u &apos; &lt; p &gt; Nodes : DCSP &apos; + str ( len ( nodes _ list ) ) ) + u &apos; &lt; / p &gt; &apos; ) DCNL DCSP html _ string + = ( ( u &apos; &lt; p &gt; Cores : DCSP &apos; + str ( cores ) ) + u &apos; &lt; / p &gt; &apos; ) DCNL DCSP html _ string + = close _ header DCNL DCSP html _ string + = draw _ lines ( start _ node &#91; u &apos;start &apos; &#93; , duration , minute _ scale , space _ between _ minutes ) DCNL DCSP html _ string + = draw _ nodes ( start _ node &#91; u &apos;start &apos; &#93; , nodes _ list , cores , minute _ scale , space _ between _ minutes , colors ) DCNL DCSP estimated _ mem _ ts = calculate _ resource _ timeseries ( events , u &apos;estimated _ memory _ gb &apos; ) DCNL DCSP runtime _ mem _ ts = calculate _ resource _ timeseries ( events , u &apos;runtime _ memory _ gb &apos; ) DCNL DCSP resource _ offset = ( 120 + ( 30 * cores ) ) DCNL DCSP html _ string + = draw _ resource _ bar ( start _ node &#91; u &apos;start &apos; &#93; , last _ node &#91; u &apos;finish &apos; &#93; , estimated _ mem _ ts , space _ between _ minutes , minute _ scale , u &apos; # 90BBD7 &apos; , ( ( resource _ offset * 2 ) + 120 ) , u &apos;Memory &apos; ) DCNL DCSP html _ string + = draw _ resource _ bar ( start _ node &#91; u &apos;start &apos; &#93; , last _ node &#91; u &apos;finish &apos; &#93; , runtime _ mem _ ts , space _ between _ minutes , minute _ scale , u &apos; # 03969D &apos; , ( ( resource _ offset * 2 ) + 120 ) , u &apos;Memory &apos; ) DCNL DCSP estimated _ threads _ ts = calculate _ resource _ timeseries ( events , u &apos;estimated _ threads &apos; ) DCNL DCSP runtime _ threads _ ts = calculate _ resource _ timeseries ( events , u &apos;runtime _ threads &apos; ) DCNL DCSP html _ string + = draw _ resource _ bar ( start _ node &#91; u &apos;start &apos; &#93; , last _ node &#91; u &apos;finish &apos; &#93; , estimated _ threads _ ts , space _ between _ minutes , minute _ scale , u &apos; # 90BBD7 &apos; , resource _ offset , u &apos;Threads &apos; ) DCNL DCSP html _ string + = draw _ resource _ bar ( start _ node &#91; u &apos;start &apos; &#93; , last _ node &#91; u &apos;finish &apos; &#93; , runtime _ threads _ ts , space _ between _ minutes , minute _ scale , u &apos; # 03969D &apos; , resource _ offset , u &apos;Threads &apos; ) DCNL DCSP html _ string + = u &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &lt; / div &gt; \ n DCSP DCSP DCSP DCSP &lt; / body &gt; &apos; DCNL DCSP html _ file = open ( ( logfile + u &apos; .html &apos; ) , u &apos;wb &apos; ) DCNL DCSP html _ file.write ( html _ string ) DCNL DCSP html _ file.close ( )
DCSP warning = ( warning or 10 ) DCNL DCSP critical = ( critical or 30 ) DCNL DCSP data = get _ server _ status ( con ) DCNL DCSP try : DCNL DCSP DCSP page _ faults = float ( data &#91; &apos; extra _ info &apos; &#93; &#91; &apos; page _ faults &apos; &#93; ) DCNL DCSP except : DCNL DCSP DCSP return exit _ with _ general _ critical ( &apos; page _ faults DCSP unsupported DCSP on DCSP the DCSP underlaying DCSP system &apos; ) DCNL DCSP ( err , delta ) = maintain _ delta ( &#91; page _ faults &#93; , host , port , &apos; page _ faults &apos; ) DCNL DCSP if ( err = = 0 ) : DCNL DCSP DCSP page _ faults _ ps = ( delta &#91; 1 &#93; / delta &#91; 0 &#93; ) DCNL DCSP DCSP message = ( &apos; Page DCSP faults DCSP : DCSP % .2f DCSP ps &apos; % page _ faults _ ps ) DCNL DCSP DCSP message + = performance _ data ( perf _ data , &#91; ( ( &apos; % .2f &apos; % page _ faults _ ps ) , &apos; page _ faults _ ps &apos; , warning , critical ) &#93; ) DCNL DCSP DCSP return check _ levels ( page _ faults _ ps , warning , critical , message ) DCNL DCSP else : DCNL DCSP DCSP return exit _ with _ general _ warning ( &apos; problem DCSP reading DCSP data DCSP from DCSP temp DCSP file &apos; )
DCSP emojis = dict ( ) DCNL DCSP full _ path = os.path.join ( _ basedir , &apos; static &apos; , &apos; emoji &apos; ) DCNL DCSP if ( not os.path.exists ( full _ path ) ) : DCNL DCSP DCSP return emojis DCNL DCSP for emoji in os.listdir ( full _ path ) : DCNL DCSP DCSP ( name , ending ) = emoji.split ( &apos; .&apos; ) DCNL DCSP DCSP if ( ending in &#91; &apos; png &apos; , &apos; gif &apos; , &apos; jpg &apos; , &apos; jpeg &apos; &#93; ) : DCNL DCSP DCSP DCSP emojis &#91; name &#93; = emoji DCNL DCSP return emojis
DCSP if ( not issubclass ( cls , HasProps ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; % s DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP HasProps &apos; % cls . _ _ name _ _ ) ) DCNL DCSP cls . _ _ doc _ _ + = _ ABSTRACT _ ADMONITION DCNL DCSP return cls
DCSP from olympia.amo import helpers DCNL DCSP monkeypatch.setattr ( helpers , &apos; is _ external &apos; , ( lambda css : True ) )
DCSP headers = dict ( ( headers or { } ) ) DCNL DCSP headers &#91; &apos; Content-Type &apos; &#93; = &apos; application / json &apos; DCNL DCSP def json _ cmp ( response _ body , body ) : DCNL DCSP DCSP return body _ cmp ( json.loads ( response _ body.decode ( &apos; utf-8 &apos; ) ) , body ) DCNL DCSP assert _ response ( response , status _ code , body , headers , json _ cmp )
DCSP body = client.show _ volume ( volume _ id ) &#91; &apos; volume &apos; &#93; DCNL DCSP volume _ status = body &#91; &apos; status &apos; &#93; DCNL DCSP start = int ( time.time ( ) ) DCNL DCSP while ( volume _ status ! = status ) : DCNL DCSP DCSP time.sleep ( client.build _ interval ) DCNL DCSP DCSP body = client.show _ volume ( volume _ id ) &#91; &apos; volume &apos; &#93; DCNL DCSP DCSP volume _ status = body &#91; &apos; status &apos; &#93; DCNL DCSP DCSP if ( ( volume _ status = = &apos; error &apos; ) and ( status ! = &apos; error &apos; ) ) : DCNL DCSP DCSP DCSP raise exceptions.VolumeBuildErrorException ( volume _ id = volume _ id ) DCNL DCSP DCSP if ( volume _ status = = &apos; error _ restoring &apos; ) : DCNL DCSP DCSP DCSP raise exceptions.VolumeRestoreErrorException ( volume _ id = volume _ id ) DCNL DCSP DCSP if ( ( int ( time.time ( ) ) - start ) &gt; = client.build _ timeout ) : DCNL DCSP DCSP DCSP message = ( &apos; Volume DCSP % s DCSP failed DCSP to DCSP reach DCSP % s DCSP status DCSP ( current DCSP % s ) DCSP within DCSP the DCSP required DCSP time DCSP ( % s DCSP s ) . &apos; % ( volume _ id , status , volume _ status , client.build _ timeout ) ) DCNL DCSP DCSP DCSP raise lib _ exc.TimeoutException ( message )
DCSP expr = _ literal _ as _ binds ( expr ) DCNL DCSP return expr.between ( lower _ bound , upper _ bound , symmetric = symmetric )
DCSP _ focus = windowing.FocusManager ( ) DCNL DCSP FigureClass = kwargs.pop ( &apos; FigureClass &apos; , Figure ) DCNL DCSP figure = FigureClass ( * args , * * kwargs ) DCNL DCSP window = Tk.Tk ( ) DCNL DCSP canvas = FigureCanvasTkAgg ( figure , master = window ) DCNL DCSP figManager = FigureManagerTkAgg ( canvas , num , window ) DCNL DCSP if matplotlib.is _ interactive ( ) : DCNL DCSP DCSP figManager.show ( ) DCNL DCSP return figManager
DCSP return md5 ( urandom ( 100 ) ) .hexdigest ( )
DCSP DocumentSpamAttempt = apps.get _ model ( u &apos;wiki &apos; , u &apos;DocumentSpamAttempt &apos; ) DCNL DCSP to _ set = DocumentSpamAttempt.objects.filter ( data _ _ isnull = True , review = NEEDS _ REVIEW ) DCNL DCSP to _ set.update ( review = REVIEW _ UNAVAILABLE )
DCSP _ reset _ leaves ( ) DCNL DCSP optimize _ = kwargs.get ( &apos; optimize &apos; , optimize ) DCNL DCSP pre _ compute _ = kwargs.get ( &apos; pre _ compute &apos; , pre _ compute ) DCNL DCSP post _ compute _ = kwargs.get ( &apos; post _ compute &apos; , post _ compute ) DCNL DCSP ( expr2 , d2 ) = swap _ resources _ into _ scope ( expr , d ) DCNL DCSP if pre _ compute _ : DCNL DCSP DCSP d3 = dict ( ( ( e , pre _ compute _ ( e , dat , * * kwargs ) ) for ( e , dat ) in d2.items ( ) if ( e in expr2 ) ) ) DCNL DCSP else : DCNL DCSP DCSP d3 = d2 DCNL DCSP if optimize _ : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP expr3 = optimize _ ( expr2 , * &#91; v for ( e , v ) in d3.items ( ) if ( e in expr2 ) &#93; ) DCNL DCSP DCSP DCSP _ d = dict ( zip ( expr2 . _ leaves ( ) , expr3 . _ leaves ( ) ) ) DCNL DCSP DCSP DCSP d4 = dict ( ( ( e . _ subs ( _ d ) , d ) for ( e , d ) in d3.items ( ) ) ) DCNL DCSP DCSP except NotImplementedError : DCNL DCSP DCSP DCSP expr3 = expr2 DCNL DCSP DCSP DCSP d4 = d3 DCNL DCSP else : DCNL DCSP DCSP expr3 = expr2 DCNL DCSP DCSP d4 = d3 DCNL DCSP result = top _ then _ bottom _ then _ top _ again _ etc ( expr3 , d4 , * * kwargs ) DCNL DCSP if post _ compute _ : DCNL DCSP DCSP result = post _ compute _ ( expr3 , result , scope = d4 ) DCNL DCSP if ( return _ type is no _ default ) : DCNL DCSP DCSP msg = &quot; The DCSP default DCSP behavior DCSP of DCSP compute DCSP will DCSP change DCSP in DCSP version DCSP &gt; = DCSP 0.11 DCSP where DCSP the DCSP `return _ type` DCSP parameter DCSP will DCSP default DCSP to DCSP &apos; core &apos; . &quot; DCNL DCSP DCSP warnings.warn ( msg , DeprecationWarning ) DCNL DCSP elif ( return _ type = = &apos; core &apos; ) : DCNL DCSP DCSP result = coerce _ core ( result , expr.dshape ) DCNL DCSP elif isinstance ( return _ type , type ) : DCNL DCSP DCSP result = into ( return _ type , result , dshape = expr3.dshape ) DCNL DCSP elif ( return _ type ! = &apos; native &apos; ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP return _ type DCSP passed DCSP to DCSP compute : DCSP { } &apos; .format ( return _ type ) ) DCNL DCSP return result
DCSP if ( full _ match is False ) : DCNL DCSP DCSP matcher = re.compile ( &apos; ^ . * { 0 } . * $ &apos; .format ( re.escape ( old _ value ) ) , re.MULTILINE ) DCNL DCSP DCSP repl = re.compile ( re.escape ( old _ value ) ) DCNL DCSP else : DCNL DCSP DCSP matcher = re.compile ( old _ value , re.MULTILINE ) DCNL DCSP DCSP repl = re.compile ( old _ value ) DCNL DCSP lines = { &apos; old &apos; : &#91; &#93; , &apos; new &apos; : &#91; &#93; } DCNL DCSP for line in matcher.finditer ( show _ run ( ) ) : DCNL DCSP DCSP lines &#91; &apos; old &apos; &#93; .append ( line.group ( 0 ) ) DCNL DCSP DCSP lines &#91; &apos; new &apos; &#93; .append ( repl.sub ( new _ value , line.group ( 0 ) ) ) DCNL DCSP delete _ config ( lines &#91; &apos; old &apos; &#93; ) DCNL DCSP add _ config ( lines &#91; &apos; new &apos; &#93; ) DCNL DCSP return lines
DCSP return EpochsFIF ( fname , proj , False , preload , verbose )
DCSP model = context &#91; &apos; model &apos; &#93; DCNL DCSP user = context &#91; &apos; user &apos; &#93; DCNL DCSP package _ id = _ get _ or _ bust ( data _ dict , &apos; package _ id &apos; ) DCNL DCSP if ( not data _ dict.get ( &apos; url &apos; ) ) : DCNL DCSP DCSP data _ dict &#91; &apos; url &apos; &#93; = &apos; &apos; DCNL DCSP pkg _ dict = _ get _ action ( &apos; package _ show &apos; ) ( dict ( context , return _ type = &apos; dict &apos; ) , { &apos; id &apos; : package _ id } ) DCNL DCSP _ check _ access ( &apos; resource _ create &apos; , context , data _ dict ) DCNL DCSP for plugin in plugins.PluginImplementations ( plugins.IResourceController ) : DCNL DCSP DCSP plugin.before _ create ( context , data _ dict ) DCNL DCSP if ( &apos; resources &apos; not in pkg _ dict ) : DCNL DCSP DCSP pkg _ dict &#91; &apos; resources &apos; &#93; = &#91; &#93; DCNL DCSP upload = uploader.get _ resource _ uploader ( data _ dict ) DCNL DCSP if ( &apos; mimetype &apos; not in data _ dict ) : DCNL DCSP DCSP if hasattr ( upload , &apos; mimetype &apos; ) : DCNL DCSP DCSP DCSP data _ dict &#91; &apos; mimetype &apos; &#93; = upload.mimetype DCNL DCSP if ( &apos; size &apos; not in data _ dict ) : DCNL DCSP DCSP if hasattr ( upload , &apos; filesize &apos; ) : DCNL DCSP DCSP DCSP data _ dict &#91; &apos; size &apos; &#93; = upload.filesize DCNL DCSP pkg _ dict &#91; &apos; resources &apos; &#93; .append ( data _ dict ) DCNL DCSP try : DCNL DCSP DCSP context &#91; &apos; defer _ commit &apos; &#93; = True DCNL DCSP DCSP context &#91; &apos; use _ cache &apos; &#93; = False DCNL DCSP DCSP _ get _ action ( &apos; package _ update &apos; ) ( context , pkg _ dict ) DCNL DCSP DCSP context.pop ( &apos; defer _ commit &apos; ) DCNL DCSP except ValidationError as e : DCNL DCSP DCSP errors = e.error _ dict &#91; &apos; resources &apos; &#93; &#91; ( -1 ) &#93; DCNL DCSP DCSP raise ValidationError ( errors ) DCNL DCSP upload.upload ( context &#91; &apos; package &apos; &#93; .resources &#91; ( -1 ) &#93; .id , uploader.get _ max _ resource _ size ( ) ) DCNL DCSP model.repo.commit ( ) DCNL DCSP updated _ pkg _ dict = _ get _ action ( &apos; package _ show &apos; ) ( context , { &apos; id &apos; : package _ id } ) DCNL DCSP resource = updated _ pkg _ dict &#91; &apos; resources &apos; &#93; &#91; ( -1 ) &#93; DCNL DCSP logic.get _ action ( &apos; resource _ create _ default _ resource _ views &apos; ) ( { &apos; model &apos; : context &#91; &apos; model &apos; &#93; , &apos; user &apos; : context &#91; &apos; user &apos; &#93; , &apos; ignore _ auth &apos; : True } , { &apos; resource &apos; : resource , &apos; package &apos; : updated _ pkg _ dict } ) DCNL DCSP for plugin in plugins.PluginImplementations ( plugins.IResourceController ) : DCNL DCSP DCSP plugin.after _ create ( context , resource ) DCNL DCSP return resource
DCSP gnodes = set ( G.nodes ( ) ) DCNL DCSP cycles = &#91; &#93; DCNL DCSP while gnodes : DCNL DCSP DCSP if ( root is None ) : DCNL DCSP DCSP DCSP root = gnodes.pop ( ) DCNL DCSP DCSP stack = &#91; root &#93; DCNL DCSP DCSP pred = { root : root } DCNL DCSP DCSP used = { root : set ( ) } DCNL DCSP DCSP while stack : DCNL DCSP DCSP DCSP z = stack.pop ( ) DCNL DCSP DCSP DCSP zused = used &#91; z &#93; DCNL DCSP DCSP DCSP for nbr in G &#91; z &#93; : DCNL DCSP DCSP DCSP DCSP if ( nbr not in used ) : DCNL DCSP DCSP DCSP DCSP DCSP pred &#91; nbr &#93; = z DCNL DCSP DCSP DCSP DCSP DCSP stack.append ( nbr ) DCNL DCSP DCSP DCSP DCSP DCSP used &#91; nbr &#93; = set ( &#91; z &#93; ) DCNL DCSP DCSP DCSP DCSP elif ( nbr = = z ) : DCNL DCSP DCSP DCSP DCSP DCSP cycles.append ( &#91; z &#93; ) DCNL DCSP DCSP DCSP DCSP elif ( nbr not in zused ) : DCNL DCSP DCSP DCSP DCSP DCSP pn = used &#91; nbr &#93; DCNL DCSP DCSP DCSP DCSP DCSP cycle = &#91; nbr , z &#93; DCNL DCSP DCSP DCSP DCSP DCSP p = pred &#91; z &#93; DCNL DCSP DCSP DCSP DCSP DCSP while ( p not in pn ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP cycle.append ( p ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP p = pred &#91; p &#93; DCNL DCSP DCSP DCSP DCSP DCSP cycle.append ( p ) DCNL DCSP DCSP DCSP DCSP DCSP cycles.append ( cycle ) DCNL DCSP DCSP DCSP DCSP DCSP used &#91; nbr &#93; .add ( z ) DCNL DCSP DCSP gnodes - = set ( pred ) DCNL DCSP DCSP root = None DCNL DCSP return cycles
DCSP if ( revision ! = 5 ) : DCNL DCSP DCSP keyLength = ( dictKeyLength / 8 ) DCNL DCSP DCSP lenPass = len ( password ) DCNL DCSP DCSP if ( lenPass &gt; 32 ) : DCNL DCSP DCSP DCSP password = password &#91; : 32 &#93; DCNL DCSP DCSP elif ( lenPass &lt; 32 ) : DCNL DCSP DCSP DCSP password + = paddingString &#91; : ( 32 - lenPass ) &#93; DCNL DCSP DCSP md5input = ( ( ( password + dictOwnerPass ) + struct.pack ( &apos; &lt; I &apos; , abs ( int ( pElement ) ) ) ) + fileID ) DCNL DCSP DCSP if ( ( revision &gt; 3 ) and ( not encryptMetadata ) ) : DCNL DCSP DCSP DCSP md5input + = ( &apos; \ xff &apos; * 4 ) DCNL DCSP DCSP key = hashlib.md5 ( md5input ) .digest ( ) DCNL DCSP DCSP if ( revision &gt; 2 ) : DCNL DCSP DCSP DCSP counter = 0 DCNL DCSP DCSP DCSP while ( counter &lt; 50 ) : DCNL DCSP DCSP DCSP DCSP key = hashlib.md5 ( key &#91; : keyLength &#93; ) .digest ( ) DCNL DCSP DCSP DCSP DCSP counter + = 1 DCNL DCSP DCSP DCSP key = key &#91; : keyLength &#93; DCNL DCSP DCSP elif ( revision = = 2 ) : DCNL DCSP DCSP DCSP key = key &#91; : 5 &#93; DCNL DCSP DCSP return ( 0 , key ) DCNL DCSP else : DCNL DCSP DCSP if ( passwordType = = &apos; USER &apos; ) : DCNL DCSP DCSP DCSP password = password.encode ( &apos; utf-8 &apos; ) &#91; : 127 &#93; DCNL DCSP DCSP DCSP kSalt = dictUserPass &#91; 40 : 48 &#93; DCNL DCSP DCSP DCSP intermediateKey = hashlib.sha256 ( ( password + kSalt ) ) .digest ( ) DCNL DCSP DCSP DCSP ret = aes.decryptData ( ( ( &apos; \ x00 &apos; * 16 ) + dictUE ) , intermediateKey ) DCNL DCSP DCSP elif ( passwordType = = &apos; OWNER &apos; ) : DCNL DCSP DCSP DCSP password = password.encode ( &apos; utf-8 &apos; ) &#91; : 127 &#93; DCNL DCSP DCSP DCSP kSalt = dictOwnerPass &#91; 40 : 48 &#93; DCNL DCSP DCSP DCSP intermediateKey = hashlib.sha256 ( ( ( password + kSalt ) + dictUserPass ) ) .digest ( ) DCNL DCSP DCSP DCSP ret = aes.decryptData ( ( ( &apos; \ x00 &apos; * 16 ) + dictOE ) , intermediateKey ) DCNL DCSP DCSP return ret
DCSP if uri.startswith ( ( &apos; .&apos; , &apos; / &apos; ) ) : DCNL DCSP DCSP request = ( request or get _ request ( ) ) DCNL DCSP DCSP uri = str ( urlparse.urljoin ( request.url , uri ) ) DCNL DCSP if ( code is None ) : DCNL DCSP DCSP if permanent : DCNL DCSP DCSP DCSP code = 301 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP code = 302 DCNL DCSP assert ( code in ( 301 , 302 , 303 , 305 , 307 ) ) , &apos; Invalid DCSP redirect DCSP status DCSP code . &apos; DCNL DCSP if abort : DCNL DCSP DCSP _ abort ( code , headers = &#91; ( &apos; Location &apos; , uri ) &#93; ) DCNL DCSP if ( response is None ) : DCNL DCSP DCSP request = ( request or get _ request ( ) ) DCNL DCSP DCSP response = request.app.response _ class ( ) DCNL DCSP else : DCNL DCSP DCSP response.clear ( ) DCNL DCSP response.headers &#91; &apos; Location &apos; &#93; = uri DCNL DCSP response.status = code DCNL DCSP if ( body is not None ) : DCNL DCSP DCSP response.write ( body ) DCNL DCSP return response
DCSP try : DCNL DCSP DCSP fileHandle = open ( filename , &apos; r &apos; ) DCNL DCSP DCSP JSONStringFromFile = fileHandle.read ( ) .splitlines ( ) DCNL DCSP DCSP JSONStringFromFile = &apos; &apos;.join ( JSONStringFromFile ) DCNL DCSP except Exception as e : DCNL DCSP DCSP raise _ InvalidCommandArgException ( _ makeUsageErrorStr ( ( ( &apos; File DCSP open DCSP failed DCSP for DCSP --descriptionFromFile : DCSP % s \ n &apos; + &apos; ARG = &lt; % s &gt; &apos; ) % ( str ( e ) , filename ) ) , usageStr ) ) DCNL DCSP _ handleDescriptionOption ( JSONStringFromFile , outDir , usageStr , hsVersion = hsVersion , claDescriptionTemplateFile = claDescriptionTemplateFile ) DCNL DCSP return
DCSP dir _ path = os.path.dirname ( os.path.abspath ( _ _ file _ _ ) ) DCNL DCSP sql _ path = os.path.join ( dir _ path , &apos; sql &apos; , &apos; tko-test-view-2.sql &apos; ) DCNL DCSP return open ( sql _ path ) .read ( )
DCSP cmd = &apos; lvdisplay &apos; DCNL DCSP result = utils.run ( cmd , ignore _ status = True ) DCNL DCSP lvpattern = ( &apos; LV DCSP Path \ \ s + / dev / % s / % s \ \ s + &apos; % ( vg _ name , lv _ name ) ) DCNL DCSP match = re.search ( lvpattern , result.stdout.rstrip ( ) ) DCNL DCSP if match : DCNL DCSP DCSP logging.debug ( &apos; Provided DCSP logical DCSP volume DCSP % s DCSP exists DCSP in DCSP % s &apos; , lv _ name , vg _ name ) DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP if ( _ check _ instance _ uid _ match ( user ) or ( _ _ grains _ _ .get ( &apos; os _ family &apos; ) in ( &apos; Solaris &apos; , &apos; AIX &apos; ) ) ) : DCNL DCSP DCSP cmd = &apos; crontab DCSP -l &apos; DCNL DCSP DCSP lines = _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( cmd , runas = user , rstrip = False , python _ shell = False ) .splitlines ( True ) DCNL DCSP else : DCNL DCSP DCSP cmd = &apos; crontab DCSP -u DCSP { 0 } DCSP -l &apos; .format ( user ) DCNL DCSP DCSP lines = _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( cmd , rstrip = False , python _ shell = False ) .splitlines ( True ) DCNL DCSP if ( ( len ( lines ) ! = 0 ) and lines &#91; 0 &#93; .startswith ( &apos; # DCSP DO DCSP NOT DCSP EDIT DCSP THIS DCSP FILE DCSP - DCSP edit DCSP the DCSP master DCSP and DCSP reinstall . &apos; ) ) : DCNL DCSP DCSP del lines &#91; 0 : 3 &#93; DCNL DCSP return &apos; &apos;.join ( lines )
DCSP Logger = getLoggerClass ( ) DCNL DCSP class DebugLogger ( Logger , ) : DCNL DCSP DCSP def getEffectiveLevel ( x ) : DCNL DCSP DCSP DCSP if ( ( x.level = = 0 ) and app.debug ) : DCNL DCSP DCSP DCSP DCSP return DEBUG DCNL DCSP DCSP DCSP return Logger.getEffectiveLevel ( x ) DCNL DCSP class DebugHandler ( StreamHandler , ) : DCNL DCSP DCSP def emit ( x , record ) : DCNL DCSP DCSP DCSP ( StreamHandler.emit ( x , record ) if app.debug else None ) DCNL DCSP handler = DebugHandler ( ) DCNL DCSP handler.setLevel ( DEBUG ) DCNL DCSP handler.setFormatter ( Formatter ( app.debug _ log _ format ) ) DCNL DCSP logger = getLogger ( app.logger _ name ) DCNL DCSP del logger.handlers &#91; : &#93; DCNL DCSP logger . _ _ class _ _ = DebugLogger DCNL DCSP logger.addHandler ( handler ) DCNL DCSP return logger
DCSP return rels
DCSP if ( idx = = ( len ( timestamps ) - 1 ) ) : DCNL DCSP DCSP return get _ past _ timestamp ( idx , timestamps ) DCNL DCSP elif timestamps &#91; idx &#93; : DCNL DCSP DCSP return timestamps &#91; idx &#93; &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP idx = min ( len ( timestamps ) , ( idx + 1 ) ) DCNL DCSP DCSP return get _ future _ timestamp ( idx , timestamps )
DCSP url = &apos; https : / / api.github.com / repos / { project } / pulls / { num } &apos; .format ( project = project , num = num ) DCNL DCSP if auth : DCNL DCSP DCSP header = make _ auth _ header ( ) DCNL DCSP else : DCNL DCSP DCSP header = None DCNL DCSP response = requests.get ( url , headers = header ) DCNL DCSP response.raise _ for _ status ( ) DCNL DCSP return json.loads ( response.text , object _ hook = Obj )
DCSP index = text.find ( &apos; \ n &apos; ) DCNL DCSP if ( index &gt; = 0 ) : DCNL DCSP DCSP first _ line = text &#91; : index &#93; .lower ( ) DCNL DCSP else : DCNL DCSP DCSP first _ line = text.lower ( ) DCNL DCSP if first _ line.startswith ( &apos; # ! &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP found = &#91; x for x in split _ path _ re.split ( first _ line &#91; 2 : &#93; .strip ( ) ) if ( x and ( not x.startswith ( &apos; -&apos; ) ) ) &#93; &#91; ( -1 ) &#93; DCNL DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP regex = re.compile ( ( &apos; ^ % s ( \ \ . ( exe &#124; cmd &#124; bat &#124; bin ) ) ? $ &apos; % regex ) , re.IGNORECASE ) DCNL DCSP DCSP if ( regex.search ( found ) is not None ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP for i in &#91; &#93; : DCNL DCSP DCSP print &apos; LOOP&apos;
DCSP astr = theano.printing.debugprint ( a , file = &apos; str &apos; ) DCNL DCSP bstr = theano.printing.debugprint ( b , file = &apos; str &apos; ) DCNL DCSP if ( not ( astr = = bstr ) ) : DCNL DCSP DCSP print ( ) DCNL DCSP DCSP print astr DCNL DCSP DCSP print bstr DCNL DCSP return ( astr = = bstr )
DCSP print ( sys.modules &#91; &apos; _ _ main _ _ &apos; &#93; . _ _ doc _ _ % sys.argv &#91; 0 &#93; ) DCNL DCSP sys.stdout.flush ( ) DCNL DCSP sys.stderr.flush ( ) DCNL DCSP sys.exit ( code )
DCSP log.debug ( &apos; Proxy DCSP module DCSP { 0 } DCSP shutting DCSP down ! ! &apos; .format ( opts &#91; &apos; id &apos; &#93; ) ) DCNL DCSP try : DCNL DCSP DCSP thisproxy &#91; &apos; conn &apos; &#93; .close ( ) DCNL DCSP except Exception : DCNL DCSP DCSP pass
DCSP assert config _ path.startswith ( &apos; / tmp &apos; ) DCNL DCSP if ( not os.path.isfile ( config _ path ) ) : DCNL DCSP DCSP return DCNL DCSP config = ConfigParser ( ) DCNL DCSP config.read ( config _ path ) DCNL DCSP for ( section , options ) in MISTRAL _ CONF _ OPTIONS _ TO _ REMOVE.items ( ) : DCNL DCSP DCSP for option in options : DCNL DCSP DCSP DCSP if config.has _ option ( section , option ) : DCNL DCSP DCSP DCSP DCSP config.set ( section , option , REMOVED _ VALUE _ NAME ) DCNL DCSP with open ( config _ path , &apos; w &apos; ) as fp : DCNL DCSP DCSP config.write ( fp )
DCSP missing _ keys = set ( default _ config ) .difference ( config ) DCNL DCSP if missing _ keys : DCNL DCSP DCSP for key in missing _ keys : DCNL DCSP DCSP DCSP config &#91; key &#93; = default _ config &#91; key &#93; DCNL DCSP DCSP with open ( config _ path , &apos; w &apos; ) as f : DCNL DCSP DCSP DCSP json.dump ( config , f , indent = 2 ) DCNL DCSP DCSP print &apos; &#91; .jrnl _ conf DCSP updated DCSP to DCSP newest DCSP version &#93; &apos;
DCSP if ( max _ depth and ( requested is None ) and ( cur _ depth &gt; max _ depth ) ) : DCNL DCSP DCSP return None DCNL DCSP if only _ load : DCNL DCSP DCSP load _ fields = ( only _ load.get ( klass ) or set ( ) ) DCNL DCSP DCSP for parent in klass . _ meta.get _ parent _ list ( ) : DCNL DCSP DCSP DCSP fields = only _ load.get ( parent ) DCNL DCSP DCSP DCSP if fields : DCNL DCSP DCSP DCSP DCSP load _ fields.update ( fields ) DCNL DCSP else : DCNL DCSP DCSP load _ fields = None DCNL DCSP if load _ fields : DCNL DCSP DCSP skip = set ( ) DCNL DCSP DCSP init _ list = &#91; &#93; DCNL DCSP DCSP for ( field , model ) in klass . _ meta.get _ concrete _ fields _ with _ model ( ) : DCNL DCSP DCSP DCSP if ( from _ parent and model and issubclass ( from _ parent , model ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( field.name not in load _ fields ) : DCNL DCSP DCSP DCSP DCSP skip.add ( field.attname ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP init _ list.append ( field.attname ) DCNL DCSP DCSP field _ count = len ( init _ list ) DCNL DCSP DCSP if skip : DCNL DCSP DCSP DCSP klass = deferred _ class _ factory ( klass , skip ) DCNL DCSP DCSP DCSP field _ names = init _ list DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP field _ names = ( ) DCNL DCSP else : DCNL DCSP DCSP field _ count = len ( klass . _ meta.concrete _ fields ) DCNL DCSP DCSP if ( from _ parent and ( len ( klass . _ meta.local _ concrete _ fields ) ! = len ( klass . _ meta.concrete _ fields ) ) ) : DCNL DCSP DCSP DCSP non _ seen _ models = &#91; p for p in klass . _ meta.get _ parent _ list ( ) if ( not issubclass ( from _ parent , p ) ) &#93; DCNL DCSP DCSP DCSP non _ seen _ models.append ( klass ) DCNL DCSP DCSP DCSP field _ names = &#91; f.attname for f in klass . _ meta.concrete _ fields if ( f.model in non _ seen _ models ) &#93; DCNL DCSP DCSP DCSP field _ count = len ( field _ names ) DCNL DCSP DCSP if ( field _ count = = len ( klass . _ meta.concrete _ fields ) ) : DCNL DCSP DCSP DCSP field _ names = ( ) DCNL DCSP restricted = ( requested is not None ) DCNL DCSP related _ fields = &#91; &#93; DCNL DCSP for f in klass . _ meta.fields : DCNL DCSP DCSP if select _ related _ descend ( f , restricted , requested , load _ fields ) : DCNL DCSP DCSP DCSP if restricted : DCNL DCSP DCSP DCSP DCSP next = requested &#91; f.name &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP next = None DCNL DCSP DCSP DCSP klass _ info = get _ klass _ info ( f.rel.to , max _ depth = max _ depth , cur _ depth = ( cur _ depth + 1 ) , requested = next , only _ load = only _ load ) DCNL DCSP DCSP DCSP related _ fields.append ( ( f , klass _ info ) ) DCNL DCSP reverse _ related _ fields = &#91; &#93; DCNL DCSP if restricted : DCNL DCSP DCSP for o in klass . _ meta.get _ all _ related _ objects ( ) : DCNL DCSP DCSP DCSP if ( o.field.unique and select _ related _ descend ( o.field , restricted , requested , only _ load.get ( o.model ) , reverse = True ) ) : DCNL DCSP DCSP DCSP DCSP next = requested &#91; o.field.related _ query _ name ( ) &#93; DCNL DCSP DCSP DCSP DCSP parent = ( klass if issubclass ( o.model , klass ) else None ) DCNL DCSP DCSP DCSP DCSP klass _ info = get _ klass _ info ( o.model , max _ depth = max _ depth , cur _ depth = ( cur _ depth + 1 ) , requested = next , only _ load = only _ load , from _ parent = parent ) DCNL DCSP DCSP DCSP DCSP reverse _ related _ fields.append ( ( o.field , klass _ info ) ) DCNL DCSP if field _ names : DCNL DCSP DCSP pk _ idx = field _ names.index ( klass . _ meta.pk.attname ) DCNL DCSP else : DCNL DCSP DCSP pk _ idx = klass . _ meta.pk _ index ( ) DCNL DCSP return ( klass , field _ names , field _ count , related _ fields , reverse _ related _ fields , pk _ idx )
DCSP passed = False DCNL DCSP clean = True DCNL DCSP comment = &apos; &apos; DCNL DCSP while ( not passed ) : DCNL DCSP DCSP log.debug ( &apos; download _ collection DCSP is DCSP this DCSP long : DCSP { 0 } &apos; .format ( str ( quidditch.install _ collection.Count ) ) ) DCNL DCSP DCSP log.debug ( &apos; Installing . DCSP tries DCSP left : DCSP { 0 } &apos; .format ( str ( retries ) ) ) DCNL DCSP DCSP passed = quidditch.Install ( ) DCNL DCSP DCSP log.info ( &apos; Done DCSP installing : DCSP { 0 } &apos; .format ( str ( passed ) ) ) DCNL DCSP DCSP if isinstance ( passed , Exception ) : DCNL DCSP DCSP DCSP clean = False DCNL DCSP DCSP DCSP comment + = &apos; Failed DCSP while DCSP trying DCSP to DCSP install DCSP the DCSP updates . \ n DCTB DCTB { 0 } \ n &apos; .format ( str ( passed ) ) DCNL DCSP DCSP DCSP retries - = 1 DCNL DCSP DCSP DCSP if retries : DCNL DCSP DCSP DCSP DCSP comment + = &apos; { 0 } DCSP tries DCSP to DCSP go . DCSP retrying \ n &apos; .format ( str ( retries ) ) DCNL DCSP DCSP DCSP DCSP passed = False DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP comment + = &apos; out DCSP of DCSP retries . DCSP this DCSP update DCSP round DCSP failed . \ n &apos; DCNL DCSP DCSP DCSP DCSP return ( comment , False , retries ) DCNL DCSP if clean : DCNL DCSP DCSP comment + = &apos; Install DCSP was DCSP done DCSP without DCSP error . \ n &apos; DCNL DCSP return ( comment , True , retries )
DCSP sample _ names = sample _ names _ in _ desired _ order DCNL DCSP unifrac _ dist _ mtx = unifrac _ res &#91; 0 &#93; DCNL DCSP unifrac _ sample _ names = unifrac _ res &#91; 1 &#93; DCNL DCSP unifrac _ sample _ names _ idx = dict ( &#91; ( n , i ) for ( i , n ) in enumerate ( unifrac _ sample _ names ) &#93; ) DCNL DCSP if ( list ( unifrac _ sample _ names ) = = list ( sample _ names ) ) : DCNL DCSP DCSP dist _ mtx = unifrac _ dist _ mtx DCNL DCSP else : DCNL DCSP DCSP dist _ mtx = np.zeros ( ( len ( sample _ names ) , len ( sample _ names ) ) ) DCNL DCSP DCSP for ( i , sam _ i ) in enumerate ( sample _ names ) : DCNL DCSP DCSP DCSP if ( sam _ i not in unifrac _ sample _ names _ idx ) : DCNL DCSP DCSP DCSP DCSP warnings.warn ( ( ( &apos; unifrac DCSP had DCSP no DCSP information DCSP for DCSP sample DCSP &apos; + sam _ i ) + &quot; . DCSP Distances DCSP involving DCSP that DCSP sample DCSP aren &apos;t DCSP meaningful &quot; ) ) DCNL DCSP DCSP DCSP DCSP for ( j , sam _ j ) in enumerate ( sample _ names ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( sam _ j not in unifrac _ sample _ names _ idx ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP dist _ mtx &#91; ( i , j ) &#93; = 0.0 DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP dist _ mtx &#91; ( i , j ) &#93; = 1.0 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP unifrac _ i = unifrac _ sample _ names _ idx &#91; sam _ i &#93; DCNL DCSP DCSP DCSP DCSP for ( j , sam _ j ) in enumerate ( sample _ names ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( sam _ j not in unifrac _ sample _ names _ idx ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP dist _ mtx &#91; ( i , j ) &#93; = 1.0 DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP unifrac _ j = unifrac _ sample _ names _ idx &#91; sam _ j &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP dist _ mtx &#91; ( i , j ) &#93; = unifrac _ dist _ mtx &#91; ( unifrac _ i , unifrac _ j ) &#93; DCNL DCSP return dist _ mtx
DCSP def prep ( r ) : DCNL DCSP DCSP query = ( FS ( &apos; organisation _ id : po _ referral _ organisation.id &apos; ) ! = None ) DCNL DCSP DCSP r.resource.add _ filter ( query ) DCNL DCSP DCSP onaccept = s3db.get _ config ( &apos; org _ organisation &apos; , &apos; onaccept &apos; ) DCNL DCSP DCSP s3db.configure ( &apos; org _ organisation &apos; , onaccept = ( onaccept , s3db.po _ organisation _ onaccept ) ) DCNL DCSP DCSP if ( r.record and ( r.component _ name = = &apos; organisation _ household &apos; ) ) : DCNL DCSP DCSP DCSP atable = s3db.po _ organisation _ area DCNL DCSP DCSP DCSP query = ( ( atable.organisation _ id = = r.id ) &amp; ( atable.deleted ! = True ) ) DCNL DCSP DCSP DCSP rows = db ( query ) .select ( atable.area _ id ) DCNL DCSP DCSP DCSP if rows : DCNL DCSP DCSP DCSP DCSP area _ ids = &#91; row.area _ id for row in rows &#93; DCNL DCSP DCSP DCSP DCSP area _ ids.append ( None ) DCNL DCSP DCSP DCSP DCSP table = r.component.table DCNL DCSP DCSP DCSP DCSP table.household _ id.requires.set _ filter ( filterby = &apos; area _ id &apos; , filter _ opts = area _ ids ) DCNL DCSP DCSP elif ( not r.component ) : DCNL DCSP DCSP DCSP list _ fields = &#91; &apos; name &apos; , &apos; name &apos; , ( T ( &apos; Type &apos; ) , &apos; organisation _ organisation _ type.organisation _ type _ id &apos; ) , ( T ( &apos; Areas &apos; ) , &apos; organisation _ area.area _ id &apos; ) , &apos; website &apos; &#93; DCNL DCSP DCSP DCSP s3db.configure ( &apos; org _ organisation &apos; , list _ fields = list _ fields ) DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP s3.crud _ strings &#91; &apos; org _ organisation &apos; &#93; .update ( { &apos; label _ create &apos; : T ( &apos; Create DCSP Agency &apos; ) , &apos; title _ list &apos; : T ( &apos; Referral DCSP Agencies &apos; ) , &apos; title _ display &apos; : T ( &apos; Agency DCSP Details &apos; ) , &apos; title _ update &apos; : T ( &apos; Edit DCSP Agency DCSP Details &apos; ) , &apos; label _ delete _ button &apos; : T ( &apos; Delete DCSP Agency &apos; ) } ) DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; area &apos; ) : DCNL DCSP DCSP DCSP DCSP s3.crud _ strings &#91; &apos; po _ organisation _ area &apos; &#93; .update ( { &apos; label _ create &apos; : T ( &apos; Add DCSP Area &apos; ) } ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3 _ rest _ controller ( &apos; org &apos; , &apos; organisation &apos; , rheader = s3db.po _ rheader )
DCSP i18n = video _ descriptor.runtime.service ( video _ descriptor , &apos; i18n &apos; ) DCNL DCSP _ = i18n.ugettext DCNL DCSP subs = get _ transcripts _ from _ youtube ( youtube _ id , settings , i18n ) DCNL DCSP save _ subs _ to _ store ( subs , youtube _ id , video _ descriptor ) DCNL DCSP log.info ( &apos; Transcripts DCSP for DCSP youtube _ id DCSP % s DCSP for DCSP 1.0 DCSP speed DCSP are DCSP downloaded DCSP and DCSP saved . &apos; , youtube _ id )
DCSP ret _ array = &#91; &#93; DCNL DCSP optimized = False DCNL DCSP for cur _ addr in addresses : DCNL DCSP DCSP if ( not ret _ array ) : DCNL DCSP DCSP DCSP ret _ array.append ( cur _ addr ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( cur _ addr in ret _ array &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP DCSP optimized = True DCNL DCSP DCSP elif ( cur _ addr = = ret _ array &#91; ( -1 ) &#93; .supernet ( ) .subnet ( ) &#91; 1 &#93; ) : DCNL DCSP DCSP DCSP ret _ array.append ( ret _ array.pop ( ) .supernet ( ) ) DCNL DCSP DCSP DCSP optimized = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret _ array.append ( cur _ addr ) DCNL DCSP if optimized : DCNL DCSP DCSP return _ collapse _ address _ list _ recursive ( ret _ array ) DCNL DCSP return ret _ array
DCSP command _ handlers = &#91; ListCustomDescriptorsHandler ( &apos; / stackdriver / list _ descriptors &apos; , &apos; list _ stackdriver &apos; , &apos; Get DCSP the DCSP JSON DCSP of DCSP all DCSP the DCSP Stackdriver DCSP Custom DCSP Metric DCSP Descriptors . &apos; ) , ClearCustomDescriptorsHandler ( &apos; / stackdriver / clear _ descriptors &apos; , &apos; clear _ stackdriver &apos; , &apos; Clear DCSP all DCSP the DCSP Stackdriver DCSP Custom DCSP Metrics &apos; ) , UpsertCustomDescriptorsHandler ( None , &apos; upsert _ stackdriver _ descriptors &apos; , &apos; Given DCSP a DCSP file DCSP of DCSP Stackdriver DCSP Custom DCSP Metric DCSP Desciptors , DCSP update DCSP the DCSP existing DCSP ones DCSP and DCSP add DCSP the DCSP new DCSP ones . DCSP WARNING : DCSP Historic DCSP time-series DCSP data DCSP may DCSP be DCSP lost DCSP on DCSP update . &apos; ) &#93; DCNL DCSP for handler in command _ handlers : DCNL DCSP DCSP handler.add _ argparser ( subparsers ) DCNL DCSP DCSP handler _ list.append ( handler )
DCSP index = ( text.find ( &apos; \ n &apos; ) + 1 ) DCNL DCSP if index : DCNL DCSP DCSP return ( text &#91; : index &#93; , text &#91; index : &#93; ) DCNL DCSP else : DCNL DCSP DCSP return ( text , &apos; &apos; )
DCSP rc ( &apos; image &apos; , cmap = &apos; prism &apos; ) DCNL DCSP im = gci ( ) DCNL DCSP if ( im is not None ) : DCNL DCSP DCSP im.set _ cmap ( cm.prism ) DCNL DCSP draw _ if _ interactive ( )
DCSP prefix = &apos; machinectl DCSP --no-legend DCSP --no-pager &apos; DCNL DCSP return _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( &apos; { 0 } DCSP { 1 } &apos; .format ( prefix , cmd ) , output _ loglevel = output _ loglevel , ignore _ retcode = ignore _ retcode , use _ vt = use _ vt )
DCSP data = np.asarray ( data ) DCNL DCSP if ( data.ndim ! = 1 ) : DCNL DCSP DCSP raise ValueError ( u &apos;data DCSP should DCSP be DCSP one-dimensional &apos; ) DCNL DCSP n = data.size DCNL DCSP sigma = np.std ( data ) DCNL DCSP dx = ( ( 3.5 * sigma ) / ( n * * ( 1 / 3 ) ) ) DCNL DCSP if return _ bins : DCNL DCSP DCSP Nbins = np.ceil ( ( ( data.max ( ) - data.min ( ) ) / dx ) ) DCNL DCSP DCSP Nbins = max ( 1 , Nbins ) DCNL DCSP DCSP bins = ( data.min ( ) + ( dx * np.arange ( ( Nbins + 1 ) ) ) ) DCNL DCSP DCSP return ( dx , bins ) DCNL DCSP else : DCNL DCSP DCSP return dx
DCSP entities &#91; &apos; \ n &apos; &#93; = &apos; &amp; # 10 ; &apos; DCNL DCSP entities &#91; &apos; \ r &apos; &#93; = &apos; &amp; # 12 ; &apos; DCNL DCSP data = _ escape ( data , entities ) DCNL DCSP if ( &apos; &quot; &apos; in data ) : DCNL DCSP DCSP if ( &quot; &apos; &quot; in data ) : DCNL DCSP DCSP DCSP data = ( &apos; &quot; % s &quot; &apos; % data.replace ( &apos; &quot; &apos; , &apos; &amp; quot ; &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP data = ( &quot; &apos; % s &apos; &quot; % data ) DCNL DCSP else : DCNL DCSP DCSP data = ( &apos; &quot; % s &quot; &apos; % data ) DCNL DCSP return data
DCSP return ( &apos; % s : % s : % s &apos; % ( key _ prefix , version , key ) )
DCSP instance _ numa _ topology = instance _ topology _ from _ instance ( instance ) DCNL DCSP if instance _ numa _ topology : DCNL DCSP DCSP instance _ numa _ topology = &#91; instance _ numa _ topology &#93; DCNL DCSP ( host _ numa _ topology , jsonify _ result ) = host _ topology _ and _ format _ from _ host ( host ) DCNL DCSP updated _ numa _ topology = numa _ usage _ from _ instances ( host _ numa _ topology , instance _ numa _ topology , free = free ) DCNL DCSP if ( updated _ numa _ topology is not None ) : DCNL DCSP DCSP if ( jsonify _ result and ( not never _ serialize _ result ) ) : DCNL DCSP DCSP DCSP updated _ numa _ topology = updated _ numa _ topology . _ to _ json ( ) DCNL DCSP return updated _ numa _ topology
DCSP if ( state is None ) : DCNL DCSP DCSP deprecation.warn ( u &apos;mpd.protocol.playback.pause : state _ arg &apos; ) DCNL DCSP DCSP playback _ state = context.core.playback.get _ state ( ) .get ( ) DCNL DCSP DCSP if ( playback _ state = = PlaybackState.PLAYING ) : DCNL DCSP DCSP DCSP context.core.playback.pause ( ) .get ( ) DCNL DCSP DCSP elif ( playback _ state = = PlaybackState.PAUSED ) : DCNL DCSP DCSP DCSP context.core.playback.resume ( ) .get ( ) DCNL DCSP elif state : DCNL DCSP DCSP context.core.playback.pause ( ) .get ( ) DCNL DCSP else : DCNL DCSP DCSP context.core.playback.resume ( ) .get ( )
DCSP if sender : DCNL DCSP DCSP msg = OutboxMessage.objects.create ( sender = sender , message = text ) DCNL DCSP DCSP msg.to.add ( * to ) DCNL DCSP for user in to : DCNL DCSP DCSP im = InboxMessage.objects.create ( sender = sender , to = user , message = text ) DCNL DCSP DCSP if Setting.get _ for _ user ( user , &apos; email _ private _ messages &apos; ) : DCNL DCSP DCSP DCSP email _ private _ message ( inbox _ message _ id = im.id ) DCNL DCSP message _ sent.send ( sender = InboxMessage , to = to , text = text , msg _ sender = sender )
DCSP import HTMLParser DCNL DCSP from py _ w3c.validators.html.validator import HTMLValidator DCNL DCSP h = HTMLParser.HTMLParser ( ) DCNL DCSP vld = HTMLValidator ( ) DCNL DCSP LOG.info ( &apos; Validating : DCSP { 0 } &apos; .format ( filename ) ) DCNL DCSP vld.validate _ file ( filename ) DCNL DCSP for err in vld.errors : DCNL DCSP DCSP LOG.error ( u &apos;line : DCSP { 0 } ; DCSP col : DCSP { 1 } ; DCSP message : DCSP { 2 } &apos; .format ( err &#91; &apos; line &apos; &#93; , err &#91; &apos; col &apos; &#93; , h.unescape ( err &#91; &apos; message &apos; &#93; ) ) ) DCNL DCSP for err in vld.warnings : DCNL DCSP DCSP LOG.warning ( u &apos;line : DCSP { 0 } ; DCSP col : DCSP { 1 } ; DCSP message : DCSP { 2 } &apos; .format ( err &#91; &apos; line &apos; &#93; , err &#91; &apos; col &apos; &#93; , h.unescape ( err &#91; &apos; message &apos; &#93; ) ) )
DCSP return _ _ salt _ _ &#91; &apos; config.option &apos; &#93; ( &apos; hosts.file &apos; )
DCSP bears _ found = tuple ( ( &#91; &#93; for i in range ( len ( kinds ) ) ) ) DCNL DCSP bear _ globs _ with _ bears = set ( ) DCNL DCSP for ( bear , glob ) in icollect _ bears ( bear _ dirs , bear _ globs , kinds , log _ printer ) : DCNL DCSP DCSP index = kinds.index ( _ get _ kind ( bear ) ) DCNL DCSP DCSP bears _ found &#91; index &#93; .append ( bear ) DCNL DCSP DCSP bear _ globs _ with _ bears.add ( glob ) DCNL DCSP if warn _ if _ unused _ glob : DCNL DCSP DCSP _ warn _ if _ unused _ glob ( log _ printer , bear _ globs , bear _ globs _ with _ bears , &quot; No DCSP bears DCSP matching DCSP &apos; { } &apos; DCSP were DCSP found . DCSP Make DCSP sure DCSP you DCSP have DCSP coala-bears DCSP installed DCSP or DCSP you DCSP have DCSP typed DCSP the DCSP name DCSP correctly . &quot; ) DCNL DCSP return bears _ found
DCSP if ( ( not encrypt ) and ( not salt ) ) : DCNL DCSP DCSP return password DCNL DCSP assert salt , &apos; _ format _ content DCSP was DCSP called DCSP with DCSP encryption DCSP requested DCSP but DCSP no DCSP salt DCSP value &apos; DCNL DCSP return ( u &apos; % s DCSP salt = % s &apos; % ( password , salt ) )
DCSP stats = &#91; &#93; DCNL DCSP d = values.get ( &apos; stats &apos; , { } ) DCNL DCSP for ( k , v ) in d.iteritems ( ) : DCNL DCSP DCSP stat = models.ComputeNodeStat ( ) DCNL DCSP DCSP stat &#91; &apos; key &apos; &#93; = k DCNL DCSP DCSP stat &#91; &apos; value &apos; &#93; = v DCNL DCSP DCSP stats.append ( stat ) DCNL DCSP values &#91; &apos; stats &apos; &#93; = stats
DCSP global array _ dict DCNL DCSP array _ dict = { &apos; array1 &apos; : { &apos; array _ name &apos; : &apos; array1 &apos; , &apos; ipaddr &apos; : &apos; 192.168.1.50 &apos; , &apos; user &apos; : &apos; 3paruser &apos; , &apos; pass &apos; : &apos; 3parpass &apos; } , &apos; array2 &apos; : { &apos; array _ name &apos; : &apos; array2 &apos; , &apos; ipaddr &apos; : &apos; 192.168.1.51 &apos; , &apos; user &apos; : &apos; 3paruser &apos; , &apos; pass &apos; : &apos; 3parpass &apos; } } DCNL DCSP Desc _ Skel = { &apos; name &apos; : &apos; XXX &apos; , &apos; call _ back &apos; : get _ metric , &apos; time _ max &apos; : 600 , &apos; value _ type &apos; : &apos; double &apos; , &apos; format &apos; : &apos; % 0f &apos; , &apos; units &apos; : &apos; XXX &apos; , &apos; slope &apos; : &apos; both &apos; , &apos; description &apos; : &apos; XXX &apos; , &apos; groups &apos; : &apos; storage &apos; } DCNL DCSP descriptors = &#91; &#93; DCNL DCSP for array in array _ dict : DCNL DCSP DCSP ip = array _ dict &#91; array &#93; &#91; &apos; ipaddr &apos; &#93; DCNL DCSP DCSP user = array _ dict &#91; array &#93; &#91; &apos; user &apos; &#93; DCNL DCSP DCSP passwd = array _ dict &#91; array &#93; &#91; &apos; pass &apos; &#93; DCNL DCSP DCSP &apos; Get DCSP a DCSP list DCSP of DCSP volumes DCSP in DCSP the DCSP array &apos; DCNL DCSP DCSP vols = get _ vol _ list ( ip , user , passwd ) DCNL DCSP DCSP &apos; Get DCSP a DCSP list DCSP of DCSP CPGs DCSP in DCSP the DCSP array &apos; DCNL DCSP DCSP cpgs = get _ cpg _ list ( ip , user , passwd ) DCNL DCSP DCSP &apos; Get DCSP a DCSP list DCSP of DCSP CPUs DCSP in DCSP the DCSP array DCSP - DCSP Only DCSP getting DCSP totals DCSP per DCSP node DCSP at DCSP this DCSP point &apos; DCNL DCSP DCSP cpus = get _ cpu _ list ( ip , user , passwd ) DCNL DCSP DCSP &apos; create DCSP descriptors DCSP for DCSP the DCSP array &apos; DCNL DCSP DCSP array _ descriptors = define _ metrics ( Desc _ Skel , array _ dict &#91; array &#93; &#91; &apos; array _ name &apos; &#93; , vols , ip , cpgs , cpus ) DCNL DCSP DCSP descriptors = ( descriptors + array _ descriptors ) DCNL DCSP return descriptors
DCSP point = numpy.array ( point , dtype = numpy.float64 , copy = False ) DCNL DCSP nearest = None DCNL DCSP mx = ( -1.0 ) DCNL DCSP for axis in axes : DCNL DCSP DCSP t = numpy.dot ( arcball _ constrain _ to _ axis ( point , axis ) , point ) DCNL DCSP DCSP if ( t &gt; mx ) : DCNL DCSP DCSP DCSP nearest = axis DCNL DCSP DCSP DCSP mx = t DCNL DCSP return nearest
DCSP return get _ regions ( &apos; elasticmapreduce &apos; , connection _ cls = EmrConnection )
DCSP if isinstance ( arr , theano.gof.type. _ cdata _ type ) : DCNL DCSP DCSP return False DCNL DCSP elif isinstance ( arr , np.random.mtrand.RandomState ) : DCNL DCSP DCSP return False DCNL DCSP elif ( var and getattr ( var.tag , &apos; is _ rng &apos; , False ) ) : DCNL DCSP DCSP return False DCNL DCSP elif isinstance ( arr , slice ) : DCNL DCSP DCSP return False DCNL DCSP elif ( arr.size = = 0 ) : DCNL DCSP DCSP return False DCNL DCSP elif ( cuda.cuda _ available and isinstance ( arr , cuda.CudaNdarray ) ) : DCNL DCSP DCSP if ( node and hasattr ( theano.sandbox , &apos; rng _ mrg &apos; ) and isinstance ( node.op , theano.sandbox.rng _ mrg.GPU _ mrg _ uniform ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP compile _ gpu _ func ( True , False , False ) DCNL DCSP DCSP DCSP return np.isnan ( f _ gpumin ( arr.reshape ( arr.size ) ) ) DCNL DCSP elif ( pygpu _ available and isinstance ( arr , GpuArray ) ) : DCNL DCSP DCSP return np.isnan ( f _ gpua _ min ( arr.reshape ( arr.size ) ) ) DCNL DCSP return np.isnan ( np.min ( arr ) )
DCSP return re.sub ( u &apos; \ \ &lt; &#91; ^ &gt; &#93; * \ \ &gt; &apos; , u &apos; &apos; , text )
DCSP import pytest DCNL DCSP import os DCNL DCSP try : DCNL DCSP DCSP import faulthandler DCNL DCSP DCSP faulthandler.enable ( ) DCNL DCSP except ImportError : DCNL DCSP DCSP pass DCNL DCSP rootdir = os.path.join ( os.path.dirname ( _ _ file _ _ ) , os.pardir ) DCNL DCSP os.chdir ( rootdir ) DCNL DCSP return pytest.main ( args = args )
DCSP if ( not host ) : DCNL DCSP DCSP raise ValueError ( &quot; Host DCSP values DCSP of DCSP &apos; &apos; DCSP or DCSP None DCSP are DCSP not DCSP allowed . &quot; ) DCNL DCSP if ( timeout is None ) : DCNL DCSP DCSP timeout = free _ port _ timeout DCNL DCSP for trial in range ( 50 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP check _ port ( host , port , timeout = timeout ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP time.sleep ( timeout ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return DCNL DCSP raise IOError ( ( &apos; Port DCSP % r DCSP not DCSP free DCSP on DCSP % r &apos; % ( port , host ) ) )
DCSP global _ service _ result _ parser DCNL DCSP try : DCNL DCSP DCSP return _ service _ result _ parser DCNL DCSP except NameError : DCNL DCSP DCSP result _ parser = _ result _ parsers &#91; get _ name _ of _ init ( run ) &#93; DCNL DCSP DCSP _ service _ result _ parser = _ ServiceResultParser ( result _ parser ) DCNL DCSP DCSP return _ service _ result _ parser
DCSP LOG.debug ( ( &apos; qos _ specs.update ( ) : DCSP specs DCSP % s &apos; % specs ) ) DCNL DCSP try : DCNL DCSP DCSP qos _ spec = objects.QualityOfServiceSpecs.get _ by _ id ( context , qos _ specs _ id ) DCNL DCSP DCSP if ( &apos; consumer &apos; in specs ) : DCNL DCSP DCSP DCSP qos _ spec.consumer = specs &#91; &apos; consumer &apos; &#93; DCNL DCSP DCSP DCSP specs = specs.copy ( ) DCNL DCSP DCSP DCSP del specs &#91; &apos; consumer &apos; &#93; DCNL DCSP DCSP qos _ spec.specs.update ( specs ) DCNL DCSP DCSP qos _ spec.save ( ) DCNL DCSP except db _ exc.DBError : DCNL DCSP DCSP LOG.exception ( _ LE ( &apos; DB DCSP error : &apos; ) ) DCNL DCSP DCSP raise exception.QoSSpecsUpdateFailed ( specs _ id = qos _ specs _ id , qos _ specs = specs ) DCNL DCSP return qos _ spec
DCSP ext _ list = &#91; &#93; DCNL DCSP for ext in extensions : DCNL DCSP DCSP ext _ list.extend ( ext.replace ( &apos; DCSP &apos; , &apos; &apos; ) .split ( &apos; , &apos; ) ) DCNL DCSP for ( i , ext ) in enumerate ( ext _ list ) : DCNL DCSP DCSP if ( not ext.startswith ( &apos; .&apos; ) ) : DCNL DCSP DCSP DCSP ext _ list &#91; i &#93; = ( &apos; . % s &apos; % ext _ list &#91; i &#93; ) DCNL DCSP return set ( &#91; x for x in ext _ list if ( x.strip ( &apos; .&apos; ) not in ignored ) &#93; )
DCSP gval = ( 1 + ( ( 9.0 / len ( ind &#91; ( n _ objs - 1 ) : &#93; ) ) * sum ( &#91; a for a in ind &#91; ( n _ objs - 1 ) : &#93; &#93; ) ) ) DCNL DCSP fit = &#91; ind for ind in ind &#91; : ( n _ objs - 1 ) &#93; &#93; DCNL DCSP fit.append ( ( ( 1 + gval ) * ( n _ objs - sum ( &#91; ( ( a / ( 1.0 + gval ) ) * ( 1 + sin ( ( ( 3 * pi ) * a ) ) ) ) for a in ind &#91; : ( n _ objs - 1 ) &#93; &#93; ) ) ) ) DCNL DCSP return fit
DCSP warn _ msg = &apos; `offset _ spines` DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP v0.5 &apos; DCNL DCSP warnings.warn ( warn _ msg , UserWarning ) DCNL DCSP if ( ( fig is None ) and ( ax is None ) ) : DCNL DCSP DCSP axes = plt.gcf ( ) .axes DCNL DCSP elif ( fig is not None ) : DCNL DCSP DCSP axes = fig.axes DCNL DCSP elif ( ax is not None ) : DCNL DCSP DCSP axes = &#91; ax &#93; DCNL DCSP for ax _ i in axes : DCNL DCSP DCSP for spine in ax _ i.spines.values ( ) : DCNL DCSP DCSP DCSP _ set _ spine _ position ( spine , ( &apos; outward &apos; , offset ) )
DCSP if ( src &#91; 0 &#93; &#91; &apos; dist &apos; &#93; is None ) : DCNL DCSP DCSP raise RuntimeError ( &apos; src DCSP must DCSP have DCSP distances DCSP included , DCSP consider DCSP using \ nmne _ add _ patch _ info DCSP with DCSP --dist DCSP argument &apos; ) DCNL DCSP edges = sparse _ block _ diag ( &#91; s &#91; &apos; dist &apos; &#93; &#91; s &#91; &apos; vertno &apos; &#93; , : &#93; &#91; : , s &#91; &apos; vertno &apos; &#93; &#93; for s in src &#93; ) DCNL DCSP edges.data &#91; : &#93; = np.less _ equal ( edges.data , dist ) DCNL DCSP edges = edges.tocsr ( ) DCNL DCSP edges.eliminate _ zeros ( ) DCNL DCSP edges = edges.tocoo ( ) DCNL DCSP return _ get _ connectivity _ from _ edges ( edges , n _ times )
DCSP return IMPL.security _ group _ rule _ get _ by _ instance ( context , instance _ uuid )
DCSP font = FONT _ CACHE.get ( ( section , option ) ) DCNL DCSP if ( font is None ) : DCNL DCSP DCSP families = CONF.get ( section , ( option + &apos; / family &apos; ) , None ) DCNL DCSP DCSP if ( families is None ) : DCNL DCSP DCSP DCSP return QFont ( ) DCNL DCSP DCSP family = get _ family ( families ) DCNL DCSP DCSP weight = QFont.Normal DCNL DCSP DCSP italic = CONF.get ( section , ( option + &apos; / italic &apos; ) , False ) DCNL DCSP DCSP if CONF.get ( section , ( option + &apos; / bold &apos; ) , False ) : DCNL DCSP DCSP DCSP weight = QFont.Bold DCNL DCSP DCSP size = ( CONF.get ( section , ( option + &apos; / size &apos; ) , 9 ) + font _ size _ delta ) DCNL DCSP DCSP font = QFont ( family , size , weight ) DCNL DCSP DCSP font.setItalic ( italic ) DCNL DCSP DCSP FONT _ CACHE &#91; ( section , option ) &#93; = font DCNL DCSP size = ( CONF.get ( section , ( option + &apos; / size &apos; ) , 9 ) + font _ size _ delta ) DCNL DCSP font.setPointSize ( size ) DCNL DCSP return font
DCSP tp0 _ store _ fs.store = None DCNL DCSP tp0 _ store _ fs.pootle _ path = &apos; / fr / project0 / example.po &apos; DCNL DCSP with pytest.raises ( ValidationError ) : DCNL DCSP DCSP tp0 _ store _ fs.save ( )
DCSP if ( boolean in ( &apos; 1&apos; , &apos; true &apos; , &apos; True &apos; ) ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP if ( not resolver ) : DCNL DCSP DCSP resolver = get _ resolver ( get _ urlconf ( ) ) DCNL DCSP result = { } DCNL DCSP for name in resolver.reverse _ dict.keys ( ) : DCNL DCSP DCSP if ( not isinstance ( name , six.string _ types ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP url = reverse ( ( ns _ prefix + name ) ) DCNL DCSP DCSP DCSP resmgr = resolve ( url ) DCNL DCSP DCSP DCSP ViewClass = import _ string ( u &apos; { 0 } . { 1 } &apos; .format ( resmgr.func. _ _ module _ _ , resmgr.func. _ _ name _ _ ) ) DCNL DCSP DCSP DCSP if ( isclass ( ViewClass ) and issubclass ( ViewClass , JSONResponseMixin ) ) : DCNL DCSP DCSP DCSP DCSP result &#91; name &#93; = _ get _ remote _ methods _ for ( ViewClass , url ) DCNL DCSP DCSP except ( NoReverseMatch , ImproperlyConfigured ) : DCNL DCSP DCSP DCSP pass DCNL DCSP for ( namespace , ns _ pattern ) in resolver.namespace _ dict.items ( ) : DCNL DCSP DCSP sub _ res = get _ all _ remote _ methods ( ns _ pattern &#91; 1 &#93; , ( ( ns _ prefix + namespace ) + u &apos; : &apos; ) ) DCNL DCSP DCSP if sub _ res : DCNL DCSP DCSP DCSP result &#91; namespace &#93; = sub _ res DCNL DCSP return result
DCSP gcodeFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively ( &#91; &apos; gcode &apos; &#93; ) DCNL DCSP for gcodeFilePath in gcodeFilePaths : DCNL DCSP DCSP if ( &apos; alterations &apos; not in gcodeFilePath ) : DCNL DCSP DCSP DCSP os.remove ( gcodeFilePath ) DCNL DCSP DCSP DCSP print ( &apos; removeGeneratedFiles DCSP deleted DCSP &apos; + gcodeFilePath ) DCNL DCSP svgFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively ( &#91; &apos; svg &apos; &#93; ) DCNL DCSP for svgFilePath in svgFilePaths : DCNL DCSP DCSP if archive.getEndsWithList ( svgFilePath , &#91; &apos; _ bottom.svg &apos; , &apos; _ carve.svg &apos; , &apos; _ chop.svg &apos; , &apos; _ cleave.svg &apos; &#93; ) : DCNL DCSP DCSP DCSP os.remove ( svgFilePath ) DCNL DCSP DCSP DCSP print ( &apos; removeGeneratedFiles DCSP deleted DCSP &apos; + svgFilePath ) DCNL DCSP xmlFilePaths = archive.getFilesWithFileTypesWithoutWordsRecursively ( &#91; &apos; xml &apos; &#93; ) DCNL DCSP for xmlFilePath in xmlFilePaths : DCNL DCSP DCSP if archive.getEndsWithList ( xmlFilePath , &#91; &apos; _ interpret.xml &apos; &#93; ) : DCNL DCSP DCSP DCSP os.remove ( xmlFilePath ) DCNL DCSP DCSP DCSP print ( &apos; removeGeneratedFiles DCSP deleted DCSP &apos; + xmlFilePath ) DCNL DCSP archive.removeBackupFilesByTypes ( &#91; &apos; gcode &apos; , &apos; svg &apos; , &apos; xml &apos; &#93; )
DCSP obj.update ( mods ) DCNL DCSP for field in dels : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP del obj &#91; field &#93; DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP pass DCNL DCSP return ui.show _ model _ changes ( obj )
DCSP as _ scalar = numpy.isscalar ( index ) DCNL DCSP input = numpy.asarray ( input ) DCNL DCSP if pass _ positions : DCNL DCSP DCSP positions = numpy.arange ( input.size ) .reshape ( input.shape ) DCNL DCSP if ( labels is None ) : DCNL DCSP DCSP if ( index is not None ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; index DCSP without DCSP defined DCSP labels &apos; ) DCNL DCSP DCSP if ( not pass _ positions ) : DCNL DCSP DCSP DCSP return func ( input.ravel ( ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return func ( input.ravel ( ) , positions.ravel ( ) ) DCNL DCSP try : DCNL DCSP DCSP ( input , labels ) = numpy.broadcast _ arrays ( input , labels ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise ValueError ( &apos; input DCSP and DCSP labels DCSP must DCSP have DCSP the DCSP same DCSP shape DCSP ( excepting DCSP dimensions DCSP with DCSP width DCSP 1 ) &apos; ) DCNL DCSP if ( index is None ) : DCNL DCSP DCSP if ( not pass _ positions ) : DCNL DCSP DCSP DCSP return func ( input &#91; ( labels &gt; 0 ) &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return func ( input &#91; ( labels &gt; 0 ) &#93; , positions &#91; ( labels &gt; 0 ) &#93; ) DCNL DCSP index = numpy.atleast _ 1d ( index ) DCNL DCSP if np.any ( ( index.astype ( labels.dtype ) .astype ( index.dtype ) ! = index ) ) : DCNL DCSP DCSP raise ValueError ( ( &quot; Cannot DCSP convert DCSP index DCSP values DCSP from DCSP &lt; % s &gt; DCSP to DCSP &lt; % s &gt; DCSP ( labels &apos; DCSP type ) DCSP without DCSP loss DCSP of DCSP precision &quot; % ( index.dtype , labels.dtype ) ) ) DCNL DCSP index = index.astype ( labels.dtype ) DCNL DCSP lo = index.min ( ) DCNL DCSP hi = index.max ( ) DCNL DCSP mask = ( ( labels &gt; = lo ) &amp; ( labels &lt; = hi ) ) DCNL DCSP labels = labels &#91; mask &#93; DCNL DCSP input = input &#91; mask &#93; DCNL DCSP if pass _ positions : DCNL DCSP DCSP positions = positions &#91; mask &#93; DCNL DCSP label _ order = labels.argsort ( ) DCNL DCSP labels = labels &#91; label _ order &#93; DCNL DCSP input = input &#91; label _ order &#93; DCNL DCSP if pass _ positions : DCNL DCSP DCSP positions = positions &#91; label _ order &#93; DCNL DCSP index _ order = index.argsort ( ) DCNL DCSP sorted _ index = index &#91; index _ order &#93; DCNL DCSP def do _ map ( inputs , output ) : DCNL DCSP DCSP &apos; labels DCSP must DCSP be DCSP sorted &apos; DCNL DCSP DCSP nidx = sorted _ index.size DCNL DCSP DCSP lo = numpy.searchsorted ( labels , sorted _ index , side = &apos; left &apos; ) DCNL DCSP DCSP hi = numpy.searchsorted ( labels , sorted _ index , side = &apos; right &apos; ) DCNL DCSP DCSP for ( i , l , h ) in zip ( range ( nidx ) , lo , hi ) : DCNL DCSP DCSP DCSP if ( l = = h ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP output &#91; i &#93; = func ( * &#91; inp &#91; l : h &#93; for inp in inputs &#93; ) DCNL DCSP temp = numpy.empty ( index.shape , out _ dtype ) DCNL DCSP temp &#91; : &#93; = default DCNL DCSP if ( not pass _ positions ) : DCNL DCSP DCSP do _ map ( &#91; input &#93; , temp ) DCNL DCSP else : DCNL DCSP DCSP do _ map ( &#91; input , positions &#93; , temp ) DCNL DCSP output = numpy.zeros ( index.shape , out _ dtype ) DCNL DCSP output &#91; index _ order &#93; = temp DCNL DCSP if as _ scalar : DCNL DCSP DCSP output = output &#91; 0 &#93; DCNL DCSP return output
DCSP if ( not filePath ) : DCNL DCSP DCSP return None DCNL DCSP md4 = hashlib.new ( &apos; md4 &apos; ) .copy DCNL DCSP def gen ( f ) : DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP x = f.read ( 9728000 ) DCNL DCSP DCSP DCSP if x : DCNL DCSP DCSP DCSP DCSP ( yield x ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP def md4 _ hash ( data ) : DCNL DCSP DCSP m = md4 ( ) DCNL DCSP DCSP m.update ( data ) DCNL DCSP DCSP return m DCNL DCSP with open ( filePath , &apos; rb &apos; ) as f : DCNL DCSP DCSP a = gen ( f ) DCNL DCSP DCSP hashes = &#91; md4 _ hash ( data ) .digest ( ) for data in a &#93; DCNL DCSP DCSP if ( len ( hashes ) = = 1 ) : DCNL DCSP DCSP DCSP return hashes &#91; 0 &#93; .encode ( &apos; hex &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return md4 _ hash ( reduce ( ( lambda a , d : ( a + d ) ) , hashes , &apos; &apos; ) ) .hexdigest ( )
DCSP return IMPL.backup _ destroy ( context , backup _ id )
DCSP path = resource.split ( &apos; .&apos; ) DCNL DCSP node = service DCNL DCSP for elem in path : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP node = getattr ( node , elem ) ( ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP raise AttributeError ( &apos; &quot; { 0 } &quot; DCSP has DCSP no DCSP attribute DCSP &quot; { 1 } &quot; &apos; .format ( &apos; .&apos;.join ( path &#91; 0 : path.index ( elem ) &#93; ) , elem ) ) DCNL DCSP return node
DCSP t.lexer.lineno + = 1
DCSP DEFAULT _ SORT = ( &apos; -&apos; , &apos; date &apos; ) DCNL DCSP SORT _ ATTR _ TRANSLATION = dict ( date = &apos; last _ modified &apos; , name = &apos; name &apos; , desc = &apos; description &apos; , type = &apos; extra &apos; ) DCNL DCSP if is _ trashed : DCNL DCSP DCSP db _ queryset = Document.objects.trashed _ docs ( SavedQuery , user ) DCNL DCSP else : DCNL DCSP DCSP db _ queryset = Document.objects.available _ docs ( SavedQuery , user ) DCNL DCSP filter _ username = querydict.get ( ( prefix + &apos; user &apos; ) ) DCNL DCSP if filter _ username : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP db _ queryset = db _ queryset.filter ( owner = User.objects.get ( username = filter _ username ) ) DCNL DCSP DCSP except User.DoesNotExist : DCNL DCSP DCSP DCSP pass DCNL DCSP d _ type = querydict.get ( ( prefix + &apos; type &apos; ) ) DCNL DCSP if ( d _ type and ( d _ type in SavedQuery.TYPES _ MAPPING.keys ( ) ) ) : DCNL DCSP DCSP db _ queryset = db _ queryset.filter ( extra = str ( SavedQuery.TYPES _ MAPPING &#91; d _ type &#93; ) ) DCNL DCSP frag = querydict.get ( ( prefix + &apos; text &apos; ) ) DCNL DCSP if frag : DCNL DCSP DCSP db _ queryset = db _ queryset.filter ( ( Q ( name _ _ icontains = frag ) &#124; Q ( description _ _ icontains = frag ) ) ) DCNL DCSP sort _ key = querydict.get ( ( prefix + &apos; sort &apos; ) ) DCNL DCSP if sort _ key : DCNL DCSP DCSP if ( sort _ key &#91; 0 &#93; = = &apos; -&apos; ) : DCNL DCSP DCSP DCSP ( sort _ dir , sort _ attr ) = ( &apos; -&apos; , sort _ key &#91; 1 : &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( sort _ dir , sort _ attr ) = ( &apos; &apos; , sort _ key ) DCNL DCSP DCSP if ( not SORT _ ATTR _ TRANSLATION.has _ key ( sort _ attr ) ) : DCNL DCSP DCSP DCSP LOG.warn ( ( &apos; Bad DCSP parameter DCSP to DCSP list _ designs : DCSP sort = % s &apos; % ( sort _ key , ) ) ) DCNL DCSP DCSP DCSP ( sort _ dir , sort _ attr ) = DEFAULT _ SORT DCNL DCSP else : DCNL DCSP DCSP ( sort _ dir , sort _ attr ) = DEFAULT _ SORT DCNL DCSP db _ queryset = db _ queryset.order _ by ( ( sort _ dir + SORT _ ATTR _ TRANSLATION &#91; sort _ attr &#93; ) ) DCNL DCSP designs = &#91; job.content _ object for job in db _ queryset.all ( ) if ( job.content _ object and ( job.content _ object.is _ auto = = False ) ) &#93; DCNL DCSP pagenum = int ( querydict.get ( ( prefix + &apos; page &apos; ) , 1 ) ) DCNL DCSP paginator = Paginator ( designs , page _ size ) DCNL DCSP page = paginator.page ( pagenum ) DCNL DCSP keys _ to _ copy = &#91; ( prefix + key ) for key in ( &apos; user &apos; , &apos; type &apos; , &apos; sort &apos; , &apos; text &apos; ) &#93; DCNL DCSP filter _ params = copy _ query _ dict ( querydict , keys _ to _ copy ) DCNL DCSP return ( page , filter _ params )
DCSP if full : DCNL DCSP DCSP if ( _ yum ( ) = = &apos; dnf &apos; ) : DCNL DCSP DCSP DCSP lock _ re = &apos; ( { 0 } - \ \ S + ) &apos; .format ( pattern ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP lock _ re = &apos; ( \ \ d + : { 0 } - \ \ S + ) &apos; .format ( pattern ) DCNL DCSP elif ( _ yum ( ) = = &apos; dnf &apos; ) : DCNL DCSP DCSP lock _ re = &apos; ( { 0 } - \ \ S + ) &apos; .format ( pattern ) DCNL DCSP else : DCNL DCSP DCSP lock _ re = &apos; \ \ d + : ( { 0 } - \ \ S + ) &apos; .format ( pattern ) DCNL DCSP match = re.search ( lock _ re , line ) DCNL DCSP if match : DCNL DCSP DCSP if ( not full ) : DCNL DCSP DCSP DCSP woarch = match.group ( 1 ) .rsplit ( &apos; .&apos; , 1 ) &#91; 0 &#93; DCNL DCSP DCSP DCSP worel = woarch.rsplit ( &apos; -&apos; , 1 ) &#91; 0 &#93; DCNL DCSP DCSP DCSP return worel.rsplit ( &apos; -&apos; , 1 ) &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return match.group ( 1 ) DCNL DCSP return None
DCSP if ( subplots is True ) : DCNL DCSP DCSP naxes = len ( grouped ) DCNL DCSP DCSP ( fig , axes ) = _ subplots ( naxes = naxes , squeeze = False , ax = ax , sharex = False , sharey = True , figsize = figsize , layout = layout ) DCNL DCSP DCSP axes = _ flatten ( axes ) DCNL DCSP DCSP ret = Series ( ) DCNL DCSP DCSP for ( ( key , group ) , ax ) in zip ( grouped , axes ) : DCNL DCSP DCSP DCSP d = group.boxplot ( ax = ax , column = column , fontsize = fontsize , rot = rot , grid = grid , * * kwds ) DCNL DCSP DCSP DCSP ax.set _ title ( pprint _ thing ( key ) ) DCNL DCSP DCSP DCSP ret.loc &#91; key &#93; = d DCNL DCSP DCSP fig.subplots _ adjust ( bottom = 0.15 , top = 0.9 , left = 0.1 , right = 0.9 , wspace = 0.2 ) DCNL DCSP else : DCNL DCSP DCSP from pandas.tools.merge import concat DCNL DCSP DCSP ( keys , frames ) = zip ( * grouped ) DCNL DCSP DCSP if ( grouped.axis = = 0 ) : DCNL DCSP DCSP DCSP df = concat ( frames , keys = keys , axis = 1 ) DCNL DCSP DCSP elif ( len ( frames ) &gt; 1 ) : DCNL DCSP DCSP DCSP df = frames &#91; 0 &#93; .join ( frames &#91; 1 : : None &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP df = frames &#91; 0 &#93; DCNL DCSP DCSP ret = df.boxplot ( column = column , fontsize = fontsize , rot = rot , grid = grid , ax = ax , figsize = figsize , layout = layout , * * kwds ) DCNL DCSP return ret
DCSP try : DCNL DCSP DCSP favorite = models.Favorite.objects.get ( user = req.user , pk = id ) DCNL DCSP DCSP favorite.delete ( ) DCNL DCSP except ObjectDoesNotExist : DCNL DCSP DCSP pass DCNL DCSP response = { &apos; has _ favorite &apos; : &apos; false &apos; } DCNL DCSP return HttpResponse ( json.dumps ( response ) , content _ type = &apos; application / json &apos; , status = 200 )
DCSP @ functools.wraps ( f ) DCNL DCSP def wrapper ( * args , * * kw ) : DCNL DCSP DCSP old _ user = get _ user ( ) DCNL DCSP DCSP set _ user ( get _ task _ user ( ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP result = f ( * args , * * kw ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP set _ user ( old _ user ) DCNL DCSP DCSP return result DCNL DCSP return wrapper
DCSP order = get _ object _ or _ 404 ( SaleOrder , pk = order _ id ) DCNL DCSP if ( not request.user.profile.has _ permission ( order , mode = &apos; x &apos; ) ) : DCNL DCSP DCSP return user _ denied ( &quot; Sorry , DCSP you DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Order &quot; ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP ordered _ product = OrderedProduct ( ) DCNL DCSP DCSP DCSP ordered _ product.order = order DCNL DCSP DCSP DCSP form = OrderedProductForm ( request.user.profile , order , request.POST , instance = ordered _ product ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP ordered _ product = form.save ( commit = False ) DCNL DCSP DCSP DCSP DCSP convert ( ordered _ product , &apos; rate &apos; , currency = ordered _ product.order.currency ) DCNL DCSP DCSP DCSP DCSP ordered _ product.set _ user _ from _ request ( request ) DCNL DCSP DCSP DCSP DCSP ordered _ product.order.update _ total ( ) DCNL DCSP DCSP DCSP DCSP if ( &apos; add _ another &apos; in request.POST ) : DCNL DCSP DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; sales _ ordered _ product _ add &apos; , args = &#91; order.id &#93; ) ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; sales _ order _ view &apos; , args = &#91; order.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; sales _ order _ view &apos; , args = &#91; order.id &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP form = OrderedProductForm ( request.user.profile , order ) DCNL DCSP return render _ to _ response ( &apos; sales / ordered _ product _ add &apos; , { &apos; form &apos; : form , &apos; order &apos; : order } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( not len ( G ) ) : DCNL DCSP DCSP raise nx.NetworkXException ( &apos; An DCSP empty DCSP graph DCSP cannot DCSP be DCSP drawn . &apos; ) DCNL DCSP import pygraphviz DCNL DCSP attrs = &#91; &apos; edge &apos; , &apos; node &apos; , &apos; graph &apos; &#93; DCNL DCSP for attr in attrs : DCNL DCSP DCSP if ( attr not in G.graph ) : DCNL DCSP DCSP DCSP G.graph &#91; attr &#93; = { } DCNL DCSP edge _ attrs = { &apos; fontsize &apos; : &apos; 10 &apos; } DCNL DCSP node _ attrs = { &apos; style &apos; : &apos; filled &apos; , &apos; fillcolor &apos; : &apos; # 0000FF40 &apos; , &apos; height &apos; : &apos; 0.75 &apos; , &apos; width &apos; : &apos; 0.75 &apos; , &apos; shape &apos; : &apos; circle &apos; } DCNL DCSP graph _ attrs = { } DCNL DCSP def update _ attrs ( which , attrs ) : DCNL DCSP DCSP added = &#91; &#93; DCNL DCSP DCSP for ( k , v ) in attrs.items ( ) : DCNL DCSP DCSP DCSP if ( k not in G.graph &#91; which &#93; ) : DCNL DCSP DCSP DCSP DCSP G.graph &#91; which &#93; &#91; k &#93; = v DCNL DCSP DCSP DCSP DCSP added.append ( k ) DCNL DCSP def clean _ attrs ( which , added ) : DCNL DCSP DCSP for attr in added : DCNL DCSP DCSP DCSP del G.graph &#91; which &#93; &#91; attr &#93; DCNL DCSP DCSP if ( not G.graph &#91; which &#93; ) : DCNL DCSP DCSP DCSP del G.graph &#91; which &#93; DCNL DCSP update _ attrs ( &apos; edge &apos; , edge _ attrs ) DCNL DCSP update _ attrs ( &apos; node &apos; , node _ attrs ) DCNL DCSP update _ attrs ( &apos; graph &apos; , graph _ attrs ) DCNL DCSP A = to _ agraph ( G ) DCNL DCSP clean _ attrs ( &apos; edge &apos; , edge _ attrs ) DCNL DCSP clean _ attrs ( &apos; node &apos; , node _ attrs ) DCNL DCSP clean _ attrs ( &apos; graph &apos; , graph _ attrs ) DCNL DCSP if ( edgelabel is not None ) : DCNL DCSP DCSP if ( not hasattr ( edgelabel , &apos; _ _ call _ _ &apos; ) ) : DCNL DCSP DCSP DCSP def func ( data ) : DCNL DCSP DCSP DCSP DCSP return &apos; &apos;.join ( &#91; &apos; DCSP DCSP &apos; , str ( data &#91; edgelabel &#93; ) , &apos; DCSP DCSP &apos; &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP func = edgelabel DCNL DCSP DCSP if G.is _ multigraph ( ) : DCNL DCSP DCSP DCSP for ( u , v , key , data ) in G.edges ( keys = True , data = True ) : DCNL DCSP DCSP DCSP DCSP edge = A.get _ edge ( u , v , str ( key ) ) DCNL DCSP DCSP DCSP DCSP edge.attr &#91; &apos; label &apos; &#93; = str ( func ( data ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for ( u , v , data ) in G.edges ( data = True ) : DCNL DCSP DCSP DCSP DCSP edge = A.get _ edge ( u , v ) DCNL DCSP DCSP DCSP DCSP edge.attr &#91; &apos; label &apos; &#93; = str ( func ( data ) ) DCNL DCSP if ( path is None ) : DCNL DCSP DCSP ext = &apos; png &apos; DCNL DCSP DCSP if suffix : DCNL DCSP DCSP DCSP suffix = ( &apos; _ % s . % s &apos; % ( suffix , ext ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP suffix = ( &apos; . % s &apos; % ( ext , ) ) DCNL DCSP DCSP path = tempfile.NamedTemporaryFile ( suffix = suffix , delete = False ) DCNL DCSP else : DCNL DCSP DCSP pass DCNL DCSP display _ pygraphviz ( A , path = path , prog = prog , args = args ) DCNL DCSP return ( path.name , A )
DCSP if namespaces : DCNL DCSP DCSP builder = ExpatBuilderNS ( ) DCNL DCSP else : DCNL DCSP DCSP builder = ExpatBuilder ( ) DCNL DCSP return builder.parseString ( string )
DCSP blockfinder = BlockFinder ( ) DCNL DCSP try : DCNL DCSP DCSP tokenize.tokenize ( iter ( lines ) .next , blockfinder.tokeneater ) DCNL DCSP except ( EndOfBlock , IndentationError ) : DCNL DCSP DCSP pass DCNL DCSP return lines &#91; : blockfinder.last &#93;
DCSP if ( val is None ) : DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP val.extend ( &#91; &#93; ) DCNL DCSP DCSP return val DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP return re.split ( &apos; \ \ s * , \ \ s * &apos; , val ) DCNL DCSP except TypeError : DCNL DCSP DCSP return list ( val )
DCSP query = _ worker _ query ( context , * * filters ) DCNL DCSP return query.delete ( )
DCSP cmd = &apos; osascript DCSP -e DCSP &quot; get DCSP output DCSP volume DCSP of DCSP ( get DCSP volume DCSP settings ) &quot; &apos; DCNL DCSP call = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , output _ loglevel = &apos; debug &apos; , python _ shell = False ) DCNL DCSP _ check _ cmd ( call ) DCNL DCSP return call.get ( &apos; stdout &apos; )
DCSP self = qtile DCNL DCSP self.testXeyes ( ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; name &apos; &#93; = = &apos; xeyes &apos; ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 798 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 578 ) DCNL DCSP self.c.window.toggle _ floating ( ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 150 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 100 ) DCNL DCSP self.c.window.set _ size _ floating ( 50 , 90 , 42 , 42 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 50 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 90 ) DCNL DCSP self.c.window.toggle _ floating ( ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 798 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 578 ) DCNL DCSP self.c.window.toggle _ floating ( ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 50 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 90 ) DCNL DCSP self.c.window.toggle _ maximize ( ) DCNL DCSP self.c.window.toggle _ minimize ( ) DCNL DCSP self.c.window.toggle _ minimize ( ) DCNL DCSP self.c.window.toggle _ floating ( ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; width &apos; &#93; = = 50 ) DCNL DCSP assert ( self.c.window.info ( ) &#91; &apos; height &apos; &#93; = = 90 )
DCSP return ( sequence &#91; p : ( p + size ) &#93; for p in range ( 0 , len ( sequence ) , size ) )
DCSP assert ( action in ( &apos; error &apos; , &apos; ignore &apos; , &apos; always &apos; , &apos; default &apos; , &apos; module &apos; , &apos; once &apos; ) ) , ( &apos; invalid DCSP action : DCSP % r &apos; % ( action , ) ) DCNL DCSP assert ( isinstance ( lineno , int ) and ( lineno &gt; = 0 ) ) , &apos; lineno DCSP must DCSP be DCSP an DCSP int DCSP &gt; = DCSP 0 &apos; DCNL DCSP item = ( action , None , category , None , lineno ) DCNL DCSP if append : DCNL DCSP DCSP filters.append ( item ) DCNL DCSP else : DCNL DCSP DCSP filters.insert ( 0 , item )
DCSP if ( &apos; tempest / lib / &apos; not in filename ) : DCNL DCSP DCSP return DCNL DCSP if ( not ( ( &apos; from DCSP tempest &apos; in logical _ line ) or ( &apos; import DCSP tempest &apos; in logical _ line ) ) ) : DCNL DCSP DCSP return DCNL DCSP if ( ( &apos; from DCSP tempest.lib &apos; in logical _ line ) or ( &apos; import DCSP tempest.lib &apos; in logical _ line ) ) : DCNL DCSP DCSP return DCNL DCSP msg = &apos; T112 : DCSP tempest.lib DCSP should DCSP not DCSP import DCSP local DCSP tempest DCSP code DCSP to DCSP avoid DCSP circular DCSP dependency &apos; DCNL DCSP ( yield ( 0 , msg ) )
DCSP ret = { &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } , &apos; result &apos; : True } DCNL DCSP time _ conflict = False DCNL DCSP for item in &#91; &apos; seconds &apos; , &apos; minutes &apos; , &apos; hours &apos; , &apos; days &apos; &#93; : DCNL DCSP DCSP if ( ( item in kwargs ) and ( &apos; when &apos; in kwargs ) ) : DCNL DCSP DCSP DCSP time _ conflict = True DCNL DCSP DCSP if ( ( item in kwargs ) and ( &apos; cron &apos; in kwargs ) ) : DCNL DCSP DCSP DCSP time _ conflict = True DCNL DCSP if time _ conflict : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Error : DCSP Unable DCSP to DCSP use DCSP &quot; seconds &quot; , DCSP &quot; minutes &quot; , DCSP &quot; hours &quot; , DCSP or DCSP &quot; days &quot; DCSP with DCSP &quot; when &quot; DCSP option . &apos; DCNL DCSP DCSP return ret DCNL DCSP if ( ( &apos; when &apos; in kwargs ) and ( &apos; cron &apos; in kwargs ) ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Unable DCSP to DCSP use DCSP &quot; when &quot; DCSP and DCSP &quot; cron &quot; DCSP options DCSP together . DCSP DCSP Ignoring . &apos; DCNL DCSP DCSP return ret DCNL DCSP current _ schedule = list _ ( show _ all = True , return _ yaml = False ) DCNL DCSP if ( name not in current _ schedule ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Job DCSP { 0 } DCSP does DCSP not DCSP exist DCSP in DCSP schedule . &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP _ current = current _ schedule &#91; name &#93; DCNL DCSP if ( &apos; _ seconds &apos; in _ current ) : DCNL DCSP DCSP _ current &#91; &apos; seconds &apos; &#93; = _ current &#91; &apos; _ seconds &apos; &#93; DCNL DCSP DCSP del _ current &#91; &apos; _ seconds &apos; &#93; DCNL DCSP _ new = build _ schedule _ item ( name , * * kwargs ) DCNL DCSP if ( _ new = = _ current ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Job DCSP { 0 } DCSP in DCSP correct DCSP state &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP _ current _ lines = &#91; &apos; { 0 } : { 1 } \ n &apos; .format ( key , value ) for ( key , value ) in sorted ( _ current.items ( ) ) &#93; DCNL DCSP _ new _ lines = &#91; &apos; { 0 } : { 1 } \ n &apos; .format ( key , value ) for ( key , value ) in sorted ( _ new.items ( ) ) &#93; DCNL DCSP _ diff = difflib.unified _ diff ( _ current _ lines , _ new _ lines ) DCNL DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; diff &apos; &#93; = &apos; &apos;.join ( _ diff ) DCNL DCSP if ( ( &apos; test &apos; in kwargs ) and kwargs &#91; &apos; test &apos; &#93; ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Job : DCSP { 0 } DCSP would DCSP be DCSP modified DCSP in DCSP schedule . &apos; .format ( name ) DCNL DCSP else : DCNL DCSP DCSP persist = True DCNL DCSP DCSP if ( &apos; persist &apos; in kwargs ) : DCNL DCSP DCSP DCSP persist = kwargs &#91; &apos; persist &apos; &#93; DCNL DCSP DCSP if ( name in list _ ( show _ all = True , where = &apos; opts &apos; , return _ yaml = False ) ) : DCNL DCSP DCSP DCSP event _ data = { &apos; name &apos; : name , &apos; schedule &apos; : _ new , &apos; func &apos; : &apos; modify &apos; , &apos; persist &apos; : persist } DCNL DCSP DCSP elif ( name in list _ ( show _ all = True , where = &apos; pillar &apos; , return _ yaml = False ) ) : DCNL DCSP DCSP DCSP event _ data = { &apos; name &apos; : name , &apos; schedule &apos; : _ new , &apos; where &apos; : &apos; pillar &apos; , &apos; func &apos; : &apos; modify &apos; , &apos; persist &apos; : False } DCNL DCSP DCSP out = _ _ salt _ _ &#91; &apos; event.fire &apos; &#93; ( event _ data , &apos; manage _ schedule &apos; ) DCNL DCSP DCSP if out : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Modified DCSP job : DCSP { 0 } DCSP in DCSP schedule . &apos; .format ( name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP modify DCSP job DCSP { 0 } DCSP in DCSP schedule . &apos; .format ( name ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP return ret
DCSP if is _ centos _ or _ rhel ( distribution ) : DCNL DCSP DCSP return sequence ( &#91; yum _ install ( &#91; &apos; kernel-devel &apos; , &apos; kernel &apos; &#93; ) , run _ from _ args ( &#91; &apos; sync &apos; &#93; ) &#93; ) DCNL DCSP elif is _ ubuntu ( distribution ) : DCNL DCSP DCSP return sequence ( &#91; &#93; ) DCNL DCSP else : DCNL DCSP DCSP raise DistributionNotSupported ( distribution = distribution )
DCSP delay = min ( float ( delay ) , 10 ) DCNL DCSP time.sleep ( delay ) DCNL DCSP return jsonify ( get _ dict ( &apos; url &apos; , &apos; args &apos; , &apos; form &apos; , &apos; data &apos; , &apos; origin &apos; , &apos; headers &apos; , &apos; files &apos; ) )
DCSP unit _ 1 = functions.value _ for _ key ( INFORMATION _ UNITS , unit _ 1 ) DCNL DCSP unit _ 2 = functions.value _ for _ key ( INFORMATION _ UNITS , unit _ 2 ) DCNL DCSP return ( ureg.parse _ expression ( unit _ 1 ) &gt; ureg.parse _ expression ( unit _ 2 ) )
DCSP try : DCNL DCSP DCSP util.activate ( requirement ) DCNL DCSP except errors.DependencyError : DCNL DCSP DCSP return False DCNL DCSP return True
DCSP for h in Dxtrav : DCNL DCSP DCSP if ( h &#91; gj &#93; = = p _ i ) : DCNL DCSP DCSP DCSP return h DCNL DCSP return None
DCSP def fixint ( i ) : DCNL DCSP DCSP i = str ( i ) DCNL DCSP DCSP if ( i.lower ( ) = = &apos; none &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if ( i.lower ( ) = = &apos; true &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP return int ( i ) DCNL DCSP def fix ( i ) : DCNL DCSP DCSP i = str ( i ) DCNL DCSP DCSP if ( i.lower ( ) = = &apos; none &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if ( i.lower ( ) = = &apos; true &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if ( i = = &apos; ( ) &apos; ) : DCNL DCSP DCSP DCSP return ( ) DCNL DCSP DCSP return i DCNL DCSP ( first , last , count ) = map ( fixint , ( first , last , count ) ) DCNL DCSP ( router , dns ) = map ( fix , ( router , dns ) ) DCNL DCSP pool = SimpleAddressPool ( network = network , first = first , last = last , count = count ) DCNL DCSP core.registerNew ( DHCPD , install _ flow = ( not no _ flow ) , pool = pool , ip _ address = ip , router _ address = router , dns _ address = dns ) DCNL DCSP log.debug ( &apos; DHCP DCSP serving DCSP a % s &apos; , str ( pool ) &#91; 2 : ( -1 ) &#93; )
DCSP if ( use _ datetime and ( not datetime ) ) : DCNL DCSP DCSP raise ValueError , &apos; the DCSP datetime DCSP module DCSP is DCSP not DCSP available &apos; DCNL DCSP if ( FastParser and FastUnmarshaller ) : DCNL DCSP DCSP if use _ datetime : DCNL DCSP DCSP DCSP mkdatetime = _ datetime _ type DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP mkdatetime = _ datetime DCNL DCSP DCSP target = FastUnmarshaller ( True , False , _ binary , mkdatetime , Fault ) DCNL DCSP DCSP parser = FastParser ( target ) DCNL DCSP else : DCNL DCSP DCSP target = Unmarshaller ( use _ datetime = use _ datetime ) DCNL DCSP DCSP if FastParser : DCNL DCSP DCSP DCSP parser = FastParser ( target ) DCNL DCSP DCSP elif ExpatParser : DCNL DCSP DCSP DCSP parser = ExpatParser ( target ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP parser = SlowParser ( target ) DCNL DCSP return ( parser , target )
DCSP a = TpPd ( pd = 3 ) DCNL DCSP b = MessageType ( mesType = 6 ) DCNL DCSP c = ForceToStandbyAndSpareHalfOctets ( ) DCNL DCSP packet = ( ( a / b ) / c ) DCNL DCSP return packet
DCSP raise HTTPForbidden ( )
DCSP try : DCNL DCSP DCSP ( headers , body ) = full _ load.split ( &apos; \ r \ n \ r \ n &apos; , 1 ) DCNL DCSP except ValueError : DCNL DCSP DCSP headers = full _ load DCNL DCSP DCSP body = &apos; &apos; DCNL DCSP header _ lines = headers.split ( &apos; \ r \ n &apos; ) DCNL DCSP http _ line = get _ http _ line ( header _ lines , http _ methods ) DCNL DCSP if ( not http _ line ) : DCNL DCSP DCSP headers = &apos; &apos; DCNL DCSP DCSP body = full _ load DCNL DCSP header _ lines = &#91; line for line in header _ lines if ( line ! = http _ line ) &#93; DCNL DCSP return ( http _ line , header _ lines , body )
DCSP seconds = ( val &gt; &gt; 32 ) DCNL DCSP increment = ( val &amp; 4294967295 ) DCNL DCSP return Timestamp ( seconds , increment )
DCSP python _ shell = _ python _ shell _ default ( python _ shell , kwargs.get ( &apos; _ _ pub _ jid &apos; , &apos; &apos; ) ) DCNL DCSP ret = _ run ( cmd , runas = runas , shell = shell , python _ shell = python _ shell , cwd = cwd , stdin = stdin , stderr = subprocess.STDOUT , env = env , clean _ env = clean _ env , template = template , rstrip = rstrip , umask = umask , output _ loglevel = output _ loglevel , log _ callback = log _ callback , timeout = timeout , reset _ system _ locale = reset _ system _ locale , ignore _ retcode = ignore _ retcode , saltenv = saltenv , use _ vt = use _ vt , bg = bg , password = password , encoded _ cmd = encoded _ cmd , * * kwargs ) DCNL DCSP log _ callback = _ check _ cb ( log _ callback ) DCNL DCSP lvl = _ check _ loglevel ( output _ loglevel ) DCNL DCSP if ( lvl is not None ) : DCNL DCSP DCSP if ( ( not ignore _ retcode ) and ( ret &#91; &apos; retcode &apos; &#93; ! = 0 ) ) : DCNL DCSP DCSP DCSP if ( lvl &lt; LOG _ LEVELS &#91; &apos; error &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP lvl = LOG _ LEVELS &#91; &apos; error &apos; &#93; DCNL DCSP DCSP DCSP msg = &quot; Command DCSP &apos; { 0 } &apos; DCSP failed DCSP with DCSP return DCSP code : DCSP { 1 } &quot; .format ( cmd , ret &#91; &apos; retcode &apos; &#93; ) DCNL DCSP DCSP DCSP log.error ( log _ callback ( msg ) ) DCNL DCSP DCSP log.log ( lvl , &apos; output : DCSP { 0 } &apos; .format ( log _ callback ( ret &#91; &apos; stdout &apos; &#93; ) ) ) DCNL DCSP return ret &#91; &apos; stdout &apos; &#93;
DCSP if ( not resource &#91; &apos; url &apos; &#93; ) : DCNL DCSP DCSP return False DCNL DCSP datapreview.res _ format ( resource ) DCNL DCSP directly = False DCNL DCSP data _ dict = { &apos; resource &apos; : resource , &apos; package &apos; : package } DCNL DCSP if datapreview.get _ preview _ plugin ( data _ dict , return _ first = True ) : DCNL DCSP DCSP url = url _ for ( controller = &apos; package &apos; , action = &apos; resource _ datapreview &apos; , resource _ id = resource &#91; &apos; id &apos; &#93; , id = package &#91; &apos; id &apos; &#93; , qualified = True ) DCNL DCSP else : DCNL DCSP DCSP return False DCNL DCSP return snippet ( &apos; dataviewer / snippets / data _ preview.html &apos; , embed = directly , resource _ url = url , raw _ resource _ url = resource.get ( &apos; url &apos; ) )
DCSP ks = getattr ( QKeySequence , attr ) DCNL DCSP return from _ qvariant ( QKeySequence.keyBindings ( ks ) &#91; 0 &#93; , str )
DCSP ( user , created ) = User.objects.get _ or _ create ( username = USERNAME , email = EMAIL ) DCNL DCSP if created : DCNL DCSP DCSP user.set _ unusable _ password ( ) DCNL DCSP DCSP user.save ( )
DCSP return getattr ( _ active , &apos; value &apos; , get _ default _ timezone ( ) )
DCSP return _ query ( None , None )
DCSP saltstack = XML.SubElement ( xml _ parent , &apos; com.waytta.SaltAPIBuilder &apos; ) DCNL DCSP supported _ auth _ types = &#91; &apos; pam &apos; , &apos; ldap &apos; &#93; DCNL DCSP supported _ target _ types = &#91; &apos; glob &apos; , &apos; pcre &apos; , &apos; list &apos; , &apos; grain &apos; , &apos; pillar &apos; , &apos; nodegroup &apos; , &apos; range &apos; , &apos; compound &apos; &#93; DCNL DCSP supported _ client _ interfaces = &#91; &apos; local &apos; , &apos; local-batch &apos; , &apos; runner &apos; &#93; DCNL DCSP mapping = &#91; ( &apos; servername &apos; , &apos; servername &apos; , None ) , ( &apos; credentials &apos; , &apos; credentialsId &apos; , None ) , ( &apos; authtype &apos; , &apos; authtype &apos; , &apos; pam &apos; , supported _ auth _ types ) , ( &apos; target &apos; , &apos; target &apos; , &apos; &apos; ) , ( &apos; targettype &apos; , &apos; targettype &apos; , &apos; glob &apos; , supported _ target _ types ) , ( &apos; clientinterface &apos; , &apos; clientInterface &apos; , &apos; local &apos; , supported _ client _ interfaces ) , ( &apos; function &apos; , &apos; function &apos; , &apos; &apos; ) , ( &apos; arguments &apos; , &apos; arguments &apos; , &apos; &apos; ) , ( &apos; kwarguments &apos; , &apos; kwarguments &apos; , &apos; &apos; ) , ( &apos; setpillardata &apos; , &apos; usePillar &apos; , False ) , ( &apos; pillarkey &apos; , &apos; pillarkey &apos; , &apos; &apos; ) , ( &apos; pillarvalue &apos; , &apos; pillarvalue &apos; , &apos; &apos; ) , ( &apos; wait &apos; , &apos; blockbuild &apos; , False ) , ( &apos; polltime &apos; , &apos; jobPollTime &apos; , &apos; &apos; ) , ( &apos; batchsize &apos; , &apos; batchSize &apos; , &apos; 100 % &apos; ) , ( &apos; mods &apos; , &apos; mods &apos; , &apos; &apos; ) , ( &apos; saveoutput &apos; , &apos; saveEnvVar &apos; , False ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( saltstack , data , mapping , fail _ required = True ) DCNL DCSP clientInterface = data.get ( &apos; clientinterface &apos; , &apos; local &apos; ) DCNL DCSP blockbuild = str ( data.get ( &apos; wait &apos; , False ) ) .lower ( ) DCNL DCSP jobPollTime = str ( data.get ( &apos; polltime &apos; , &apos; &apos; ) ) DCNL DCSP batchSize = data.get ( &apos; batchsize &apos; , &apos; 100 % &apos; ) DCNL DCSP mods = data.get ( &apos; mods &apos; , &apos; &apos; ) DCNL DCSP usePillar = str ( data.get ( &apos; setpillardata &apos; , False ) ) .lower ( ) DCNL DCSP clientInterfaces = XML.SubElement ( saltstack , &apos; clientInterfaces &apos; ) DCNL DCSP XML.SubElement ( clientInterfaces , &apos; nullObject &apos; ) .text = &apos; false &apos; DCNL DCSP ci _ attrib = { &apos; class &apos; : &apos; org.apache.commons.collections.map.ListOrderedMap &apos; , &apos; serialization &apos; : &apos; custom &apos; } DCNL DCSP properties = XML.SubElement ( clientInterfaces , &apos; properties &apos; , ci _ attrib ) DCNL DCSP lomElement = &apos; org.apache.commons.collections.map.ListOrderedMap &apos; DCNL DCSP listOrderedMap = XML.SubElement ( properties , lomElement ) DCNL DCSP default = XML.SubElement ( listOrderedMap , &apos; default &apos; ) DCNL DCSP ordered _ map = XML.SubElement ( listOrderedMap , &apos; map &apos; ) DCNL DCSP insertOrder = XML.SubElement ( default , &apos; insertOrder &apos; ) DCNL DCSP ci _ config = &#91; &#93; DCNL DCSP if ( clientInterface = = &apos; local &apos; ) : DCNL DCSP DCSP ci _ config = &#91; ( &apos; blockbuild &apos; , blockbuild ) , ( &apos; jobPollTime &apos; , jobPollTime ) , ( &apos; clientInterface &apos; , clientInterface ) &#93; DCNL DCSP elif ( clientInterface = = &apos; local-batch &apos; ) : DCNL DCSP DCSP ci _ config = &#91; ( &apos; batchSize &apos; , batchSize ) , ( &apos; clientInterface &apos; , clientInterface ) &#93; DCNL DCSP elif ( clientInterface = = &apos; runner &apos; ) : DCNL DCSP DCSP ci _ config = &#91; ( &apos; mods &apos; , mods ) , ( &apos; clientInterface &apos; , clientInterface ) &#93; DCNL DCSP DCSP if ( usePillar = = &apos; true &apos; ) : DCNL DCSP DCSP DCSP ci _ config.append ( ( &apos; usePillar &apos; , usePillar ) ) DCNL DCSP DCSP DCSP pillar _ cfg = &#91; ( &apos; pillarkey &apos; , data.get ( &apos; pillarkey &apos; ) ) , ( &apos; pillarvalue &apos; , data.get ( &apos; pillarvalue &apos; ) ) &#93; DCNL DCSP for ( emt , value ) in ci _ config : DCNL DCSP DCSP XML.SubElement ( insertOrder , &apos; string &apos; ) .text = emt DCNL DCSP DCSP entry = XML.SubElement ( ordered _ map , &apos; entry &apos; ) DCNL DCSP DCSP XML.SubElement ( entry , &apos; string &apos; ) .text = emt DCNL DCSP DCSP if ( emt ! = &apos; usePillar &apos; ) : DCNL DCSP DCSP DCSP XML.SubElement ( entry , &apos; string &apos; ) .text = value DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP jsonobj = XML.SubElement ( entry , &apos; net.sf.json.JSONObject &apos; ) DCNL DCSP DCSP DCSP XML.SubElement ( jsonobj , &apos; nullObject &apos; ) .text = &apos; false &apos; DCNL DCSP DCSP DCSP pillarProps = XML.SubElement ( jsonobj , &apos; properties &apos; , ci _ attrib ) DCNL DCSP DCSP DCSP XML.SubElement ( pillarProps , &apos; unserializable-parents &apos; ) DCNL DCSP DCSP DCSP pillarLom = XML.SubElement ( pillarProps , lomElement ) DCNL DCSP DCSP DCSP pillarDefault = XML.SubElement ( pillarLom , &apos; default &apos; ) DCNL DCSP DCSP DCSP pillarMap = XML.SubElement ( pillarLom , &apos; map &apos; ) DCNL DCSP DCSP DCSP pillarInsertOrder = XML.SubElement ( pillarDefault , &apos; insertOrder &apos; ) DCNL DCSP DCSP DCSP for ( pemt , value ) in pillar _ cfg : DCNL DCSP DCSP DCSP DCSP XML.SubElement ( pillarInsertOrder , &apos; string &apos; ) .text = pemt DCNL DCSP DCSP DCSP DCSP pillarEntry = XML.SubElement ( pillarMap , &apos; entry &apos; ) DCNL DCSP DCSP DCSP DCSP XML.SubElement ( pillarEntry , &apos; string &apos; ) .text = pemt DCNL DCSP DCSP DCSP DCSP XML.SubElement ( pillarEntry , &apos; string &apos; ) .text = value
DCSP ( workdir , filename ) = os.path.split ( filepath ) DCNL DCSP args = solc _ arguments ( libraries = libraries , combined = combined , optimize = optimize , extra _ args = extra _ args ) DCNL DCSP args.insert ( 0 , get _ compiler _ path ( ) ) DCNL DCSP args.append ( filename ) DCNL DCSP output = subprocess.check _ output ( args , cwd = workdir ) DCNL DCSP return solc _ parse _ output ( output )
DCSP if c : DCNL DCSP DCSP a = ( 123 , ) DCNL DCSP try : DCNL DCSP DCSP return a DCNL DCSP finally : DCNL DCSP DCSP return a
DCSP send _ notification ( user = user , action = NOTIF _ TICKET _ PURCHASED , title = NOTIFS &#91; NOTIF _ TICKET _ PURCHASED &#93; &#91; &apos; title &apos; &#93; .format ( invoice _ id = invoice _ id ) , message = NOTIFS &#91; NOTIF _ TICKET _ PURCHASED &#93; &#91; &apos; message &apos; &#93; .format ( order _ url = order _ url ) )
DCSP assert ( len ( image.shape ) = = 3 ) DCNL DCSP assert ( len ( shape ) = = 2 ) DCNL DCSP shrunk = fit _ inside ( image , shape ) DCNL DCSP letterboxed = letterbox ( shrunk , shape ) DCNL DCSP return letterboxed
DCSP def find _ local _ maxima ( hist ) : DCNL DCSP DCSP maximums = list ( ) DCNL DCSP DCSP direction = 1 DCNL DCSP DCSP for i in range ( ( hist.shape &#91; 0 &#93; - 1 ) ) : DCNL DCSP DCSP DCSP if ( direction &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP if ( hist &#91; ( i + 1 ) &#93; &lt; hist &#91; i &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP direction = ( -1 ) DCNL DCSP DCSP DCSP DCSP DCSP maximums.append ( i ) DCNL DCSP DCSP DCSP elif ( hist &#91; ( i + 1 ) &#93; &gt; hist &#91; i &#93; ) : DCNL DCSP DCSP DCSP DCSP direction = 1 DCNL DCSP DCSP return maximums DCNL DCSP if ( bias not in ( &apos; min &apos; , &apos; mid &apos; , &apos; max &apos; ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Unknown DCSP bias : DCSP { 0 } &apos; .format ( bias ) ) DCNL DCSP ( hist , bin _ centers ) = histogram ( image.ravel ( ) , nbins ) DCNL DCSP smooth _ hist = np.copy ( hist ) DCNL DCSP for counter in range ( max _ iter ) : DCNL DCSP DCSP smooth _ hist = ndif.uniform _ filter1d ( smooth _ hist , 3 ) DCNL DCSP DCSP maximums = find _ local _ maxima ( smooth _ hist ) DCNL DCSP DCSP if ( len ( maximums ) &lt; 3 ) : DCNL DCSP DCSP DCSP break DCNL DCSP if ( len ( maximums ) ! = 2 ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Unable DCSP to DCSP find DCSP two DCSP maxima DCSP in DCSP histogram &apos; ) DCNL DCSP elif ( counter = = ( max _ iter - 1 ) ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Maximum DCSP iteration DCSP reached DCSP for DCSP histogramsmoothing &apos; ) DCNL DCSP minimum = smooth _ hist &#91; maximums &#91; 0 &#93; &#93; DCNL DCSP threshold = maximums &#91; 0 &#93; DCNL DCSP for i in range ( maximums &#91; 0 &#93; , ( maximums &#91; 1 &#93; + 1 ) ) : DCNL DCSP DCSP if ( smooth _ hist &#91; i &#93; &lt; minimum ) : DCNL DCSP DCSP DCSP minimum = smooth _ hist &#91; i &#93; DCNL DCSP DCSP DCSP threshold = i DCNL DCSP if ( bias = = &apos; min &apos; ) : DCNL DCSP DCSP return bin _ centers &#91; threshold &#93; DCNL DCSP else : DCNL DCSP DCSP upper _ bound = threshold DCNL DCSP DCSP while ( smooth _ hist &#91; upper _ bound &#93; = = smooth _ hist &#91; threshold &#93; ) : DCNL DCSP DCSP DCSP upper _ bound + = 1 DCNL DCSP DCSP upper _ bound - = 1 DCNL DCSP DCSP if ( bias = = &apos; max &apos; ) : DCNL DCSP DCSP DCSP return bin _ centers &#91; upper _ bound &#93; DCNL DCSP DCSP elif ( bias = = &apos; mid &apos; ) : DCNL DCSP DCSP DCSP return bin _ centers &#91; ( ( threshold + upper _ bound ) / / 2 ) &#93;
DCSP return ( singular if ( count = = 1 ) else plural )
DCSP profile = request.user.profile DCNL DCSP query = _ get _ filter _ query ( profile , filters = request.GET ) DCNL DCSP updates = UpdateRecord.objects.filter ( query ) .distinct ( ) DCNL DCSP if request.POST : DCNL DCSP DCSP record = UpdateRecord ( ) DCNL DCSP DCSP record.record _ type = &apos; share &apos; DCNL DCSP DCSP form = UpdateRecordForm ( request.POST , user = profile , instance = record ) DCNL DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP record = form.save ( ) DCNL DCSP DCSP DCSP record.body = record.body.replace ( &apos; \ n &apos; , &apos; DCSP &lt; br DCSP / &gt; &apos; ) DCNL DCSP DCSP DCSP record.save ( ) DCNL DCSP DCSP DCSP record.set _ user _ from _ request ( request ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; news _ index &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP form = UpdateRecordForm ( user = profile ) DCNL DCSP if ( response _ format = = &apos; rss &apos; ) : DCNL DCSP DCSP return ObjectFeed ( title = _ ( &apos; All DCSP Activity &apos; ) , link = request.path , description = _ ( &apos; Updates DCSP on DCSP activity DCSP in DCSP your DCSP Tree.io &apos; ) , objects = updates ) ( request ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; form &apos; : form , &apos; updates &apos; : updates , &apos; profile &apos; : profile } ) DCNL DCSP return render _ to _ response ( &apos; news / index &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( ( not ec2 _ key _ pair _ file ) or ( not os.path.exists ( ec2 _ key _ pair _ file ) ) ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP cmd = &quot; hadoop DCSP dfsadmin DCSP -report DCSP &#124; DCSP grep DCSP ^ Name DCSP &#124; DCSP cut DCSP -f2 DCSP -d : DCSP &#124; DCSP cut DCSP -f2 DCSP -d &apos; DCSP &apos; &quot; DCNL DCSP args = &#91; ( &apos; bash DCSP -c DCSP &quot; % s &quot; &apos; % cmd ) &#93; DCNL DCSP ips = to _ string ( _ check _ output ( * _ ssh _ run ( ssh _ bin , master _ address , ec2 _ key _ pair _ file , args ) ) ) DCNL DCSP return &#91; ip for ip in ips.split ( &apos; \ n &apos; ) if ip &#93;
DCSP A _ linear _ operator = aslinearoperator ( A ) DCNL DCSP AT _ linear _ operator = aslinearoperator ( AT ) DCNL DCSP n = A _ linear _ operator.shape &#91; 0 &#93; DCNL DCSP X = np.ones ( ( n , t ) ) DCNL DCSP if ( t &gt; 1 ) : DCNL DCSP DCSP X &#91; : , 1 : &#93; = ( ( np.random.randint ( 0 , 2 , size = ( n , ( t - 1 ) ) ) * 2 ) - 1 ) DCNL DCSP X / = float ( n ) DCNL DCSP g _ prev = None DCNL DCSP h _ prev = None DCNL DCSP k = 1 DCNL DCSP ind = range ( t ) DCNL DCSP while True : DCNL DCSP DCSP Y = np.asarray ( A _ linear _ operator.matmat ( X ) ) DCNL DCSP DCSP g = _ sum _ abs _ axis0 ( Y ) DCNL DCSP DCSP best _ j = np.argmax ( g ) DCNL DCSP DCSP g.sort ( ) DCNL DCSP DCSP g = g &#91; : : ( -1 ) &#93; DCNL DCSP DCSP S = sign _ round _ up ( Y ) DCNL DCSP DCSP Z = np.asarray ( AT _ linear _ operator.matmat ( S ) ) DCNL DCSP DCSP h = _ max _ abs _ axis1 ( Z ) DCNL DCSP DCSP if ( k &gt; = 2 ) : DCNL DCSP DCSP DCSP if less _ than _ or _ close ( max ( h ) , np.dot ( Z &#91; : , best _ j &#93; , X &#91; : , best _ j &#93; ) ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP ind = np.argsort ( h ) &#91; : : ( -1 ) &#93; &#91; : t &#93; DCNL DCSP DCSP h = h &#91; ind &#93; DCNL DCSP DCSP for j in range ( t ) : DCNL DCSP DCSP DCSP X &#91; : , j &#93; = elementary _ vector ( n , ind &#91; j &#93; ) DCNL DCSP DCSP if ( k &gt; = 2 ) : DCNL DCSP DCSP DCSP if ( not less _ than _ or _ close ( g _ prev &#91; 0 &#93; , h _ prev &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( &apos; invariant DCSP ( 2.2 ) DCSP is DCSP violated &apos; ) DCNL DCSP DCSP DCSP if ( not less _ than _ or _ close ( h _ prev &#91; 0 &#93; , g &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( &apos; invariant DCSP ( 2.2 ) DCSP is DCSP violated &apos; ) DCNL DCSP DCSP if ( k &gt; = 3 ) : DCNL DCSP DCSP DCSP for j in range ( t ) : DCNL DCSP DCSP DCSP DCSP if ( not less _ than _ or _ close ( g &#91; j &#93; , g _ prev &#91; j &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise Exception ( &apos; invariant DCSP ( 2.3 ) DCSP is DCSP violated &apos; ) DCNL DCSP DCSP g _ prev = g DCNL DCSP DCSP h _ prev = h DCNL DCSP DCSP k + = 1 DCNL DCSP return ( g , ind )
DCSP return os.environ.get ( &apos; GALAXY _ TEST _ USER _ API _ KEY &apos; , DEFAULT _ GALAXY _ USER _ API _ KEY )
DCSP lengths = &#91; len ( s ) for s in sequences &#93; DCNL DCSP nb _ samples = len ( sequences ) DCNL DCSP if ( maxlen is None ) : DCNL DCSP DCSP maxlen = np.max ( lengths ) DCNL DCSP sample _ shape = tuple ( ) DCNL DCSP for s in sequences : DCNL DCSP DCSP if ( len ( s ) &gt; 0 ) : DCNL DCSP DCSP DCSP sample _ shape = np.asarray ( s ) .shape &#91; 1 : &#93; DCNL DCSP DCSP DCSP break DCNL DCSP x = ( np.ones ( ( ( nb _ samples , maxlen ) + sample _ shape ) ) * value ) .astype ( dtype ) DCNL DCSP for ( idx , s ) in enumerate ( sequences ) : DCNL DCSP DCSP if ( len ( s ) = = 0 ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( truncating = = &apos; pre &apos; ) : DCNL DCSP DCSP DCSP trunc = s &#91; ( - maxlen ) : &#93; DCNL DCSP DCSP elif ( truncating = = &apos; post &apos; ) : DCNL DCSP DCSP DCSP trunc = s &#91; : maxlen &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Truncating DCSP type DCSP &quot; % s &quot; DCSP not DCSP understood &apos; % truncating ) ) DCNL DCSP DCSP trunc = np.asarray ( trunc , dtype = dtype ) DCNL DCSP DCSP if ( trunc.shape &#91; 1 : &#93; ! = sample _ shape ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Shape DCSP of DCSP sample DCSP % s DCSP of DCSP sequence DCSP at DCSP position DCSP % s DCSP is DCSP different DCSP from DCSP expected DCSP shape DCSP % s &apos; % ( trunc.shape &#91; 1 : &#93; , idx , sample _ shape ) ) ) DCNL DCSP DCSP if ( padding = = &apos; post &apos; ) : DCNL DCSP DCSP DCSP x &#91; idx , : len ( trunc ) &#93; = trunc DCNL DCSP DCSP elif ( padding = = &apos; pre &apos; ) : DCNL DCSP DCSP DCSP x &#91; idx , ( - len ( trunc ) ) : &#93; = trunc DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Padding DCSP type DCSP &quot; % s &quot; DCSP not DCSP understood &apos; % padding ) ) DCNL DCSP return x
DCSP for i in range ( len ( tokens ) ) : DCNL DCSP DCSP current = tokens &#91; i &#93; DCNL DCSP DCSP if isinstance ( tokens &#91; i &#93; , six.string _ types ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP item = current &#91; 0 &#93; DCNL DCSP DCSP if ( ( not statement _ re.search ( item ) ) and ( item not in single _ statements ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not i ) : DCNL DCSP DCSP DCSP prev = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP prev = tokens &#91; ( i - 1 ) &#93; DCNL DCSP DCSP if ( ( i + 1 ) &gt; = len ( tokens ) ) : DCNL DCSP DCSP DCSP next = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP next = tokens &#91; ( i + 1 ) &#93; DCNL DCSP DCSP if ( ( not isinstance ( next , six.string _ types ) ) or ( not isinstance ( prev , six.string _ types ) ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( ( ( not prev ) or trail _ whitespace _ re.search ( prev ) ) and ( ( not next ) or lead _ whitespace _ re.search ( next ) ) ) : DCNL DCSP DCSP DCSP if prev : DCNL DCSP DCSP DCSP DCSP m = trail _ whitespace _ re.search ( prev ) DCNL DCSP DCSP DCSP DCSP prev = prev &#91; : ( m.start ( ) + 1 ) &#93; DCNL DCSP DCSP DCSP DCSP tokens &#91; ( i - 1 ) &#93; = prev DCNL DCSP DCSP DCSP if next : DCNL DCSP DCSP DCSP DCSP m = lead _ whitespace _ re.search ( next ) DCNL DCSP DCSP DCSP DCSP next = next &#91; m.end ( ) : &#93; DCNL DCSP DCSP DCSP DCSP tokens &#91; ( i + 1 ) &#93; = next DCNL DCSP return tokens
DCSP if ( asof is pd.NaT ) : DCNL DCSP DCSP return DCNL DCSP first _ row = dense _ dates.searchsorted ( asof ) DCNL DCSP next _ idx = sparse _ dates.searchsorted ( asof.asm8 , &apos; right &apos; ) DCNL DCSP if ( next _ idx = = len ( sparse _ dates ) ) : DCNL DCSP DCSP last _ row = ( len ( dense _ dates ) - 1 ) DCNL DCSP else : DCNL DCSP DCSP last _ row = ( dense _ dates.searchsorted ( sparse _ dates &#91; next _ idx &#93; ) - 1 ) DCNL DCSP if ( first _ row &gt; last _ row ) : DCNL DCSP DCSP return DCNL DCSP ( first , last ) = asset _ idx DCNL DCSP ( yield Float64Overwrite ( first _ row , last _ row , first , last , value ) )
DCSP cmd = &#91; &apos; pcs &apos; &#93; DCNL DCSP if isinstance ( cibfile , six.string _ types ) : DCNL DCSP DCSP cmd + = &#91; &apos; -f &apos; , cibfile &#93; DCNL DCSP if isinstance ( item , six.string _ types ) : DCNL DCSP DCSP cmd + = &#91; item &#93; DCNL DCSP elif isinstance ( item , ( list , tuple ) ) : DCNL DCSP DCSP cmd + = item DCNL DCSP if ( item in &#91; &apos; constraint &apos; &#93; ) : DCNL DCSP DCSP if isinstance ( item _ type , six.string _ types ) : DCNL DCSP DCSP DCSP cmd + = &#91; item _ type &#93; DCNL DCSP if isinstance ( create , six.string _ types ) : DCNL DCSP DCSP cmd + = &#91; create &#93; DCNL DCSP elif isinstance ( create , ( list , tuple ) ) : DCNL DCSP DCSP cmd + = create DCNL DCSP if ( item not in &#91; &apos; constraint &apos; &#93; ) : DCNL DCSP DCSP cmd + = &#91; item _ id &#93; DCNL DCSP DCSP if isinstance ( item _ type , six.string _ types ) : DCNL DCSP DCSP DCSP cmd + = &#91; item _ type &#93; DCNL DCSP if isinstance ( extra _ args , ( list , tuple ) ) : DCNL DCSP DCSP if ( item in &#91; &apos; constraint &apos; &#93; ) : DCNL DCSP DCSP DCSP extra _ args = ( extra _ args + &#91; &apos; id = { 0 } &apos; .format ( item _ id ) &#93; ) DCNL DCSP DCSP cmd + = extra _ args DCNL DCSP return _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , output _ loglevel = &apos; trace &apos; , python _ shell = False )
DCSP from sympy.utilities.randtest import _ randrange DCNL DCSP if ( not gate _ ids ) : DCNL DCSP DCSP return circuit DCNL DCSP if isinstance ( circuit , Mul ) : DCNL DCSP DCSP circuit = circuit.args DCNL DCSP ids = flatten _ ids ( gate _ ids ) DCNL DCSP randrange = _ randrange ( seed ) DCNL DCSP while ids : DCNL DCSP DCSP i = randrange ( len ( ids ) ) DCNL DCSP DCSP id = ids.pop ( i ) DCNL DCSP DCSP if ( find _ subcircuit ( circuit , id ) ! = ( -1 ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP else : DCNL DCSP DCSP return circuit DCNL DCSP return replace _ subcircuit ( circuit , id )
DCSP if ( not request.user.is _ authenticated ( ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Connect DCSP user DCSP can DCSP only DCSP be DCSP used DCSP on DCSP authenticated DCSP users &apos; ) DCNL DCSP if ( not facebook.is _ authenticated ( ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Facebook DCSP needs DCSP to DCSP be DCSP authenticated DCSP for DCSP connect DCSP flows &apos; ) DCNL DCSP data = facebook.facebook _ profile _ data ( ) DCNL DCSP facebook _ id = data &#91; &apos; id &apos; &#93; DCNL DCSP old _ connections = _ get _ old _ connections ( facebook _ id , request.user.id ) &#91; : 20 &#93; DCNL DCSP if ( old _ connections and ( not ( request.POST.get ( &apos; confirm _ connect &apos; ) or request.GET.get ( &apos; confirm _ connect &apos; ) ) ) ) : DCNL DCSP DCSP raise facebook _ exceptions.AlreadyConnectedError ( list ( old _ connections ) ) DCNL DCSP user = _ update _ user ( request.user , facebook , overwrite = overwrite ) DCNL DCSP return user
DCSP return PATH _ SEPARATOR &#91; _ os.name &#93;
DCSP if ( _ check _ instance _ uid _ match ( user ) or ( _ _ grains _ _ .get ( &apos; os _ family &apos; ) in ( &apos; Solaris &apos; , &apos; AIX &apos; ) ) ) : DCNL DCSP DCSP return ( _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( _ get _ cron _ cmdstr ( path ) , runas = user , python _ shell = False ) = = 0 ) DCNL DCSP else : DCNL DCSP DCSP return ( _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( _ get _ cron _ cmdstr ( path , user ) , python _ shell = False ) = = 0 )
DCSP img = load _ image ( image _ path ) DCNL DCSP img = pil _ to _ nparray ( img ) DCNL DCSP try : DCNL DCSP DCSP channel = img.shape &#91; 2 &#93; DCNL DCSP except : DCNL DCSP DCSP channel = 1 DCNL DCSP return channel
DCSP warnings.warn ( &quot; &apos; django.utils.translation.get _ partial _ date _ formats &apos; DCSP is DCSP deprecated . DCSP Please DCSP update DCSP your DCSP code DCSP to DCSP use DCSP the DCSP new DCSP i18n DCSP aware DCSP formatting . &quot; , PendingDeprecationWarning ) DCNL DCSP from django.conf import settings DCNL DCSP year _ month _ format = ugettext ( &apos; YEAR _ MONTH _ FORMAT &apos; ) DCNL DCSP month _ day _ format = ugettext ( &apos; MONTH _ DAY _ FORMAT &apos; ) DCNL DCSP if ( year _ month _ format = = &apos; YEAR _ MONTH _ FORMAT &apos; ) : DCNL DCSP DCSP year _ month _ format = settings.YEAR _ MONTH _ FORMAT DCNL DCSP if ( month _ day _ format = = &apos; MONTH _ DAY _ FORMAT &apos; ) : DCNL DCSP DCSP month _ day _ format = settings.MONTH _ DAY _ FORMAT DCNL DCSP return ( year _ month _ format , month _ day _ format )
DCSP return value
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; } DCNL DCSP cert = &apos; / etc / icinga2 / pki / { 0 } .crt &apos; .format ( name ) DCNL DCSP key = &apos; / etc / icinga2 / pki / { 0 } .key &apos; .format ( name ) DCNL DCSP if ( os.path.isfile ( cert ) and os.path.isfile ( key ) ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; No DCSP execution DCSP needed . DCSP Cert : DCSP { 0 } DCSP and DCSP key : DCSP { 1 } DCSP already DCSP generated . &apos; .format ( cert , key ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Certificate DCSP and DCSP key DCSP generation DCSP would DCSP be DCSP executed &apos; DCNL DCSP DCSP return ret DCNL DCSP cert _ save = _ _ salt _ _ &#91; &apos; icinga2.generate _ cert &apos; &#93; ( name ) DCNL DCSP if ( not cert _ save ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Certificate DCSP and DCSP key DCSP generated &apos; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; cert &apos; &#93; = &apos; Executed . DCSP Certificate DCSP saved : DCSP { 0 } &apos; .format ( cert ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; key &apos; &#93; = &apos; Executed . DCSP Key DCSP saved : DCSP { 0 } &apos; .format ( key ) DCNL DCSP return ret
DCSP if ( not ( urllib.parse.quote _ plus ( drive ) = = drive ) ) : DCNL DCSP DCSP return False DCNL DCSP path = os.path.join ( root , drive ) DCNL DCSP return utils.ismount ( path )
DCSP cmd = &apos; sysctl &apos; DCNL DCSP ret = { } DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( cmd , output _ loglevel = &apos; trace &apos; ) DCNL DCSP for line in out.splitlines ( ) : DCNL DCSP DCSP if ( ( not line ) or ( &apos; = &apos; not in line ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP comps = line.split ( &apos; = &apos; , 1 ) DCNL DCSP DCSP ret &#91; comps &#91; 0 &#93; &#93; = comps &#91; 1 &#93; DCNL DCSP return ret
DCSP C = ( state.C = = 0 ) .astype ( np.int ) DCNL DCSP covered _ C = ( C * state.row _ uncovered &#91; : , np.newaxis &#93; ) DCNL DCSP covered _ C * = astype ( state.col _ uncovered , dtype = np.int , copy = False ) DCNL DCSP n = state.C.shape &#91; 0 &#93; DCNL DCSP m = state.C.shape &#91; 1 &#93; DCNL DCSP while True : DCNL DCSP DCSP ( row , col ) = np.unravel _ index ( np.argmax ( covered _ C ) , ( n , m ) ) DCNL DCSP DCSP if ( covered _ C &#91; ( row , col ) &#93; = = 0 ) : DCNL DCSP DCSP DCSP return _ step6 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP state.marked &#91; ( row , col ) &#93; = 2 DCNL DCSP DCSP DCSP star _ col = np.argmax ( ( state.marked &#91; row &#93; = = 1 ) ) DCNL DCSP DCSP DCSP if ( not ( state.marked &#91; ( row , star _ col ) &#93; = = 1 ) ) : DCNL DCSP DCSP DCSP DCSP state.Z0 _ r = row DCNL DCSP DCSP DCSP DCSP state.Z0 _ c = col DCNL DCSP DCSP DCSP DCSP return _ step5 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP col = star _ col DCNL DCSP DCSP DCSP DCSP state.row _ uncovered &#91; row &#93; = False DCNL DCSP DCSP DCSP DCSP state.col _ uncovered &#91; col &#93; = True DCNL DCSP DCSP DCSP DCSP covered _ C &#91; : , col &#93; = ( C &#91; : , col &#93; * astype ( state.row _ uncovered , dtype = np.int , copy = False ) ) DCNL DCSP DCSP DCSP DCSP covered _ C &#91; row &#93; = 0
DCSP hooktype = kwargs &#91; &apos; hooktype &apos; &#93; DCNL DCSP node = kwargs &#91; &apos; node &apos; &#93; DCNL DCSP ui.debug ( &apos; Zulip : DCSP received DCSP { hooktype } DCSP event \ n &apos; .format ( hooktype = hooktype ) ) DCNL DCSP if ( hooktype ! = &apos; changegroup &apos; ) : DCNL DCSP DCSP ui.warn ( &apos; Zulip : DCSP { hooktype } DCSP not DCSP supported \ n &apos; .format ( hooktype = hooktype ) ) DCNL DCSP DCSP exit ( 1 ) DCNL DCSP ctx = repo.changectx ( node ) DCNL DCSP branch = ctx.branch ( ) DCNL DCSP branch _ whitelist = get _ config ( ui , &apos; branches &apos; ) DCNL DCSP branch _ blacklist = get _ config ( ui , &apos; ignore _ branches &apos; ) DCNL DCSP if branch _ whitelist : DCNL DCSP DCSP watched _ branches = &#91; b.lower ( ) .strip ( ) for b in branch _ whitelist.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP if ( branch.lower ( ) not in watched _ branches ) : DCNL DCSP DCSP DCSP ui.debug ( &apos; Zulip : DCSP ignoring DCSP event DCSP for DCSP { branch } \ n &apos; .format ( branch = branch ) ) DCNL DCSP DCSP DCSP exit ( 0 ) DCNL DCSP if branch _ blacklist : DCNL DCSP DCSP ignored _ branches = &#91; b.lower ( ) .strip ( ) for b in branch _ blacklist.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP if ( branch.lower ( ) in ignored _ branches ) : DCNL DCSP DCSP DCSP ui.debug ( &apos; Zulip : DCSP ignoring DCSP event DCSP for DCSP { branch } \ n &apos; .format ( branch = branch ) ) DCNL DCSP DCSP DCSP exit ( 0 ) DCNL DCSP base = repo &#91; node &#93; .rev ( ) DCNL DCSP tip = len ( repo ) DCNL DCSP email = get _ config ( ui , &apos; email &apos; ) DCNL DCSP api _ key = get _ config ( ui , &apos; api _ key &apos; ) DCNL DCSP site = get _ config ( ui , &apos; site &apos; ) DCNL DCSP if ( not ( email and api _ key ) ) : DCNL DCSP DCSP ui.warn ( &apos; Zulip : DCSP missing DCSP email DCSP or DCSP api _ key DCSP configurations \ n &apos; ) DCNL DCSP DCSP ui.warn ( &apos; in DCSP the DCSP &#91; zulip &#93; DCSP section DCSP of DCSP your DCSP .hg / hgrc . \ n &apos; ) DCNL DCSP DCSP exit ( 1 ) DCNL DCSP stream = get _ config ( ui , &apos; stream &apos; ) DCNL DCSP if ( not stream ) : DCNL DCSP DCSP stream = &apos; commits &apos; DCNL DCSP web _ url = get _ config ( ui , &apos; web _ url &apos; ) DCNL DCSP user = ctx.user ( ) DCNL DCSP content = format _ summary _ line ( web _ url , user , base , tip , branch , node ) DCNL DCSP content + = format _ commit _ lines ( web _ url , repo , base , tip ) DCNL DCSP subject = branch DCNL DCSP ui.debug ( &apos; Sending DCSP to DCSP Zulip : \ n &apos; ) DCNL DCSP ui.debug ( ( content + &apos; \ n &apos; ) ) DCNL DCSP send _ zulip ( email , api _ key , site , stream , subject , content )
DCSP return ( ( function . _ _ code _ _ .co _ flags &amp; 128 ) or getattr ( function , &apos; _ is _ coroutine &apos; , False ) )
DCSP if path.endswith ( &apos; .gz &apos; ) : DCNL DCSP DCSP return gunzip _ stream ( fileobj ) DCNL DCSP elif path.endswith ( &apos; .bz2 &apos; ) : DCNL DCSP DCSP if ( bz2 is None ) : DCNL DCSP DCSP DCSP raise Exception ( &apos; bz2 DCSP module DCSP was DCSP not DCSP successfully DCSP imported DCSP ( likely DCSP not DCSP installed ) . &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return bunzip2 _ stream ( fileobj ) DCNL DCSP else : DCNL DCSP DCSP return fileobj
DCSP caller = currentframe ( 1 ) DCNL DCSP return ( getsourcefile ( sys.modules &#91; caller.f _ globals &#91; &apos; _ _ name _ _ &apos; &#93; &#93; ) , ( caller.f _ lineno + 1 ) )
DCSP if ( sys.platform = = &apos; cygwin &apos; ) : DCNL DCSP DCSP p = subprocess.Popen ( &#91; &apos; cygpath &apos; , path &#93; , stdout = subprocess.PIPE ) DCNL DCSP DCSP path = p.communicate ( ) &#91; 0 &#93; .strip ( ) DCNL DCSP return path
DCSP sys.path &#91; 0 &#93; = path DCNL DCSP wz . _ _ dict _ _ .clear ( ) DCNL DCSP for key in sys.modules.keys ( ) : DCNL DCSP DCSP if ( key.startswith ( &apos; werkzeug . &apos; ) or ( key = = &apos; werkzeug &apos; ) ) : DCNL DCSP DCSP DCSP sys.modules.pop ( key , None ) DCNL DCSP import werkzeug DCNL DCSP for key in werkzeug . _ _ all _ _ : DCNL DCSP DCSP setattr ( wz , key , getattr ( werkzeug , key ) ) DCNL DCSP hg _ tag = find _ hg _ tag ( path ) DCNL DCSP try : DCNL DCSP DCSP f = open ( os.path.join ( path , &apos; setup.py &apos; ) ) DCNL DCSP except IOError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP for line in f : DCNL DCSP DCSP DCSP DCSP line = line.strip ( ) DCNL DCSP DCSP DCSP DCSP if line.startswith ( &apos; version = &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP return ( line &#91; 8 : &#93; .strip ( &apos; DCSP DCTB , &apos; ) &#91; 1 : ( -1 ) &#93; , hg _ tag ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP f.close ( ) DCNL DCSP print &gt; &gt; sys.stderr , &apos; Unknown DCSP werkzeug DCSP version DCSP loaded &apos; DCNL DCSP sys.exit ( 2 )
DCSP if ( not callable ( obj ) ) : DCNL DCSP DCSP raise TypeError ( &apos; { 0 ! r } DCSP is DCSP not DCSP a DCSP callable DCSP object &apos; .format ( obj ) ) DCNL DCSP if isinstance ( obj , types.MethodType ) : DCNL DCSP DCSP sig = signature ( obj . _ _ func _ _ ) DCNL DCSP DCSP if ( obj . _ _ self _ _ is None ) : DCNL DCSP DCSP DCSP if sig.parameters : DCNL DCSP DCSP DCSP DCSP first = sig.parameters.values ( ) &#91; 0 &#93; .replace ( kind = _ POSITIONAL _ ONLY ) DCNL DCSP DCSP DCSP DCSP return sig.replace ( parameters = ( ( first , ) + tuple ( sig.parameters.values ( ) ) &#91; 1 : &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return sig DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return sig.replace ( parameters = tuple ( sig.parameters.values ( ) ) &#91; 1 : &#93; ) DCNL DCSP try : DCNL DCSP DCSP sig = obj . _ _ signature _ _ DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP if ( sig is not None ) : DCNL DCSP DCSP DCSP return sig DCNL DCSP try : DCNL DCSP DCSP wrapped = obj . _ _ wrapped _ _ DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP return signature ( wrapped ) DCNL DCSP if isinstance ( obj , types.FunctionType ) : DCNL DCSP DCSP return Signature.from _ function ( obj ) DCNL DCSP if isinstance ( obj , functools.partial ) : DCNL DCSP DCSP sig = signature ( obj.func ) DCNL DCSP DCSP new _ params = OrderedDict ( sig.parameters.items ( ) ) DCNL DCSP DCSP partial _ args = ( obj.args or ( ) ) DCNL DCSP DCSP partial _ keywords = ( obj.keywords or { } ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ba = sig.bind _ partial ( * partial _ args , * * partial _ keywords ) DCNL DCSP DCSP except TypeError as ex : DCNL DCSP DCSP DCSP msg = &apos; partial DCSP object DCSP { 0 ! r } DCSP has DCSP incorrect DCSP arguments &apos; .format ( obj ) DCNL DCSP DCSP DCSP raise ValueError ( msg ) DCNL DCSP DCSP for ( arg _ name , arg _ value ) in ba.arguments.items ( ) : DCNL DCSP DCSP DCSP param = new _ params &#91; arg _ name &#93; DCNL DCSP DCSP DCSP if ( arg _ name in partial _ keywords ) : DCNL DCSP DCSP DCSP DCSP new _ params &#91; arg _ name &#93; = param.replace ( default = arg _ value , _ partial _ kwarg = True ) DCNL DCSP DCSP DCSP elif ( ( param.kind not in ( _ VAR _ KEYWORD , _ VAR _ POSITIONAL ) ) and ( not param . _ partial _ kwarg ) ) : DCNL DCSP DCSP DCSP DCSP new _ params.pop ( arg _ name ) DCNL DCSP DCSP return sig.replace ( parameters = new _ params.values ( ) ) DCNL DCSP sig = None DCNL DCSP if isinstance ( obj , type ) : DCNL DCSP DCSP call = _ get _ user _ defined _ method ( type ( obj ) , &apos; _ _ call _ _ &apos; ) DCNL DCSP DCSP if ( call is not None ) : DCNL DCSP DCSP DCSP sig = signature ( call ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP new = _ get _ user _ defined _ method ( obj , &apos; _ _ new _ _ &apos; ) DCNL DCSP DCSP DCSP if ( new is not None ) : DCNL DCSP DCSP DCSP DCSP sig = signature ( new ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP init = _ get _ user _ defined _ method ( obj , &apos; _ _ init _ _ &apos; ) DCNL DCSP DCSP DCSP DCSP if ( init is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP sig = signature ( init ) DCNL DCSP elif ( not isinstance ( obj , _ NonUserDefinedCallables ) ) : DCNL DCSP DCSP call = _ get _ user _ defined _ method ( type ( obj ) , &apos; _ _ call _ _ &apos; , &apos; im _ func &apos; ) DCNL DCSP DCSP if ( call is not None ) : DCNL DCSP DCSP DCSP sig = signature ( call ) DCNL DCSP if ( sig is not None ) : DCNL DCSP DCSP return sig.replace ( parameters = tuple ( sig.parameters.values ( ) ) &#91; 1 : &#93; ) DCNL DCSP if isinstance ( obj , types.BuiltinFunctionType ) : DCNL DCSP DCSP msg = &apos; no DCSP signature DCSP found DCSP for DCSP builtin DCSP function DCSP { 0 ! r } &apos; .format ( obj ) DCNL DCSP DCSP raise ValueError ( msg ) DCNL DCSP raise ValueError ( &apos; callable DCSP { 0 ! r } DCSP is DCSP not DCSP supported DCSP by DCSP signature &apos; .format ( obj ) )
DCSP if ( not settings ) : DCNL DCSP DCSP _ LOG.warning ( &apos; No DCSP settings DCSP provided &apos; ) DCNL DCSP DCSP return False DCNL DCSP settings = _ normalize _ server _ settings ( * * settings ) DCNL DCSP current _ settings = get _ server _ setting ( settings = settings.keys ( ) , server = server ) DCNL DCSP if ( settings = = current _ settings ) : DCNL DCSP DCSP _ LOG.debug ( &apos; Settings DCSP already DCSP contain DCSP the DCSP provided DCSP values . &apos; ) DCNL DCSP DCSP return True DCNL DCSP with salt.utils.winapi.Com ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP connection = wmi.WMI ( namespace = _ WMI _ NAMESPACE ) DCNL DCSP DCSP DCSP objs = connection.IIsSmtpServerSetting ( Name = server ) &#91; 0 &#93; DCNL DCSP DCSP except wmi.x _ wmi as error : DCNL DCSP DCSP DCSP _ LOG.error ( &apos; Encountered DCSP WMI DCSP error : DCSP % s &apos; , error.com _ error ) DCNL DCSP DCSP except ( AttributeError , IndexError ) as error : DCNL DCSP DCSP DCSP _ LOG.error ( &apos; Error DCSP getting DCSP IIsSmtpServerSetting : DCSP % s &apos; , error ) DCNL DCSP DCSP for setting in settings : DCNL DCSP DCSP DCSP if ( str ( settings &#91; setting &#93; ) ! = str ( current _ settings &#91; setting &#93; ) ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP setattr ( objs , setting , settings &#91; setting &#93; ) DCNL DCSP DCSP DCSP DCSP except wmi.x _ wmi as error : DCNL DCSP DCSP DCSP DCSP DCSP _ LOG.error ( &apos; Encountered DCSP WMI DCSP error : DCSP % s &apos; , error.com _ error ) DCNL DCSP DCSP DCSP DCSP except AttributeError as error : DCNL DCSP DCSP DCSP DCSP DCSP _ LOG.error ( &apos; Error DCSP setting DCSP % s : DCSP % s &apos; , setting , error ) DCNL DCSP new _ settings = get _ server _ setting ( settings = settings.keys ( ) , server = server ) DCNL DCSP failed _ settings = dict ( ) DCNL DCSP for setting in settings : DCNL DCSP DCSP if ( str ( settings &#91; setting &#93; ) ! = str ( new _ settings &#91; setting &#93; ) ) : DCNL DCSP DCSP DCSP failed _ settings &#91; setting &#93; = settings &#91; setting &#93; DCNL DCSP if failed _ settings : DCNL DCSP DCSP _ LOG.error ( &apos; Failed DCSP to DCSP change DCSP settings : DCSP % s &apos; , failed _ settings ) DCNL DCSP DCSP return False DCNL DCSP _ LOG.debug ( &apos; Settings DCSP configured DCSP successfully : DCSP % s &apos; , settings.keys ( ) ) DCNL DCSP return True
DCSP if ( netaddr.IPNetwork ( network ) .version = = 6 ) : DCNL DCSP DCSP return &apos; IPv6 &apos; DCNL DCSP elif ( netaddr.IPNetwork ( network ) .version = = 4 ) : DCNL DCSP DCSP return &apos; IPv4&apos;
DCSP add _ active _ request ( request ) DCNL DCSP add _ to _ total _ count ( { request.name : 1 } ) DCNL DCSP all _ total _ count &#91; 0 &#93; + = 1
DCSP ttype = type ( value ) DCNL DCSP if ( ttype is unicode ) : DCNL DCSP DCSP return value DCNL DCSP if ( ( ttype is str ) or issubclass ( ttype , str ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return unicode ( value , hint _ encoding , errors = errors ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP for ln in get _ encodings ( hint _ encoding ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return unicode ( value , ln , errors = errors ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP if isinstance ( value , Exception ) : DCNL DCSP DCSP return exception _ to _ unicode ( value ) DCNL DCSP try : DCNL DCSP DCSP return unicode ( value ) DCNL DCSP except Exception : DCNL DCSP DCSP raise UnicodeError ( ( &apos; unable DCSP to DCSP convert DCSP % r &apos; % ( value , ) ) )
DCSP local _ setting = os.path.join ( project _ directory , &apos; config / settings / local.py &apos; ) DCNL DCSP set _ secret _ key ( local _ setting ) DCNL DCSP env _ file = os.path.join ( project _ directory , &apos; env.example &apos; ) DCNL DCSP set _ secret _ key ( env _ file )
DCSP module = sys.modules &#91; moduleName &#93; DCNL DCSP if ( not isinstance ( module , _ ModuleProxy ) ) : DCNL DCSP DCSP module = _ ModuleProxy ( module ) DCNL DCSP DCSP sys.modules &#91; moduleName &#93; = module DCNL DCSP _ deprecateAttribute ( module , name , version , message )
DCSP tokens = &#91; x for x in tokens if ( x ! = u &apos; &#124; &apos; ) &#93; DCNL DCSP if ( len ( tokens ) = = 1 ) : DCNL DCSP DCSP return tokens &#91; 0 &#93; DCNL DCSP elif ( len ( tokens ) = = 2 ) : DCNL DCSP DCSP return ( lambda a , b : ( lambda n , m = None , l = None : ( a ( n , m , l ) or b ( n , m , l ) ) ) ) ( tokens &#91; 0 &#93; , tokens &#91; 1 &#93; )
DCSP key = win32api.RegOpenKey ( win32con.HKEY _ CLASSES _ ROOT , &apos; Typelib &apos; ) DCNL DCSP iids = EnumKeys ( key ) DCNL DCSP results = &#91; &#93; DCNL DCSP for ( iid , crap ) in iids : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP key2 = win32api.RegOpenKey ( key , str ( iid ) ) DCNL DCSP DCSP except win32api.error : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for ( version , tlbdesc ) in EnumKeys ( key2 ) : DCNL DCSP DCSP DCSP major _ minor = version.split ( &apos; .&apos; , 1 ) DCNL DCSP DCSP DCSP if ( len ( major _ minor ) &lt; 2 ) : DCNL DCSP DCSP DCSP DCSP major _ minor.append ( &apos; 0&apos; ) DCNL DCSP DCSP DCSP major = major _ minor &#91; 0 &#93; DCNL DCSP DCSP DCSP minor = major _ minor &#91; 1 &#93; DCNL DCSP DCSP DCSP key3 = win32api.RegOpenKey ( key2 , str ( version ) ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP flags = int ( win32api.RegQueryValue ( key3 , &apos; FLAGS &apos; ) ) DCNL DCSP DCSP DCSP except ( win32api.error , ValueError ) : DCNL DCSP DCSP DCSP DCSP flags = 0 DCNL DCSP DCSP DCSP if ( ( flags &amp; excludeFlags ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP for ( lcid , crap ) in EnumKeys ( key3 ) : DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP lcid = int ( lcid ) DCNL DCSP DCSP DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP key4 = win32api.RegOpenKey ( key3 , ( &apos; % s \ \ win32 &apos; % ( lcid , ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP except win32api.error : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( dll , typ ) = win32api.RegQueryValueEx ( key4 , None ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( typ = = win32con.REG _ EXPAND _ SZ ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP dll = win32api.ExpandEnvironmentStrings ( dll ) DCNL DCSP DCSP DCSP DCSP DCSP except win32api.error : DCNL DCSP DCSP DCSP DCSP DCSP DCSP dll = None DCNL DCSP DCSP DCSP DCSP DCSP spec = TypelibSpec ( iid , lcid , major , minor , flags ) DCNL DCSP DCSP DCSP DCSP DCSP spec.dll = dll DCNL DCSP DCSP DCSP DCSP DCSP spec.desc = tlbdesc DCNL DCSP DCSP DCSP DCSP DCSP spec.ver _ desc = ( ( ( tlbdesc + &apos; DCSP ( &apos; ) + version ) + &apos; ) &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP results.append ( spec ) DCNL DCSP return results
DCSP q _ = proportion DCNL DCSP if ( method = = &apos; normal &apos; ) : DCNL DCSP DCSP n = ( ( q _ * ( 1 - q _ ) ) / ( ( half _ length / stats.norm.isf ( ( alpha / 2.0 ) ) ) * * 2 ) ) DCNL DCSP else : DCNL DCSP DCSP raise NotImplementedError ( &apos; only DCSP &quot; normal &quot; DCSP is DCSP available &apos; ) DCNL DCSP return n
DCSP n = 101 DCNL DCSP colorlist = np.empty ( ( n , 4 ) , float ) DCNL DCSP colorlist &#91; : , 0 &#93; = np.linspace ( 0 , 1 , n ) DCNL DCSP colorlist &#91; : , 1 &#93; = 0.2 DCNL DCSP colorlist &#91; : , 2 &#93; = np.linspace ( 1 , 0 , n ) DCNL DCSP colorlist &#91; : , 3 &#93; = 0.7 DCNL DCSP lsc = mcolors.LinearSegmentedColormap.from _ list ( u &apos;lsc &apos; , colorlist ) DCNL DCSP lc = mcolors.ListedColormap ( colorlist ) DCNL DCSP lsc3 = lsc . _ resample ( 3 ) DCNL DCSP lc3 = lc . _ resample ( 3 ) DCNL DCSP expected = np.array ( &#91; &#91; 0.0 , 0.2 , 1.0 , 0.7 &#93; , &#91; 0.5 , 0.2 , 0.5 , 0.7 &#93; , &#91; 1.0 , 0.2 , 0.0 , 0.7 &#93; &#93; , float ) DCNL DCSP assert _ array _ almost _ equal ( lsc3 ( &#91; 0 , 0.5 , 1 &#93; ) , expected ) DCNL DCSP assert _ array _ almost _ equal ( lc3 ( &#91; 0 , 0.5 , 1 &#93; ) , expected )
DCSP profile = request.user.profile DCNL DCSP try : DCNL DCSP DCSP contacts = profile.contact _ set.exclude ( trash = True ) DCNL DCSP except : DCNL DCSP DCSP contacts = &#91; &#93; DCNL DCSP return render _ to _ response ( &apos; account / account _ view &apos; , { &apos; profile &apos; : profile , &apos; contacts &apos; : contacts } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP checker = _ SELECT _ ERROR _ CHECKERS.get ( exc . _ _ class _ _ , None ) DCNL DCSP if ( checker is not None ) : DCNL DCSP DCSP return checker ( exc ) DCNL DCSP else : DCNL DCSP DCSP return False
DCSP return ctypes.cast ( ctypes _ func , ctypes.c _ void _ p ) .value
DCSP return ( pywinerr.args &#91; 0 &#93; = = 193 )
DCSP d = { &apos; root _ url &apos; : request.url _ root } DCNL DCSP return d
DCSP if ( len ( xlist ) ! = len ( ylist ) ) : DCNL DCSP DCSP raise AssertionError ( &apos; List DCSP size DCSP is DCSP different &apos; ) DCNL DCSP for ( x , y ) in zip ( xlist , ylist ) : DCNL DCSP DCSP numpy.testing.assert _ array _ equal ( cupy.asnumpy ( x ) , cupy.asnumpy ( y ) , err _ msg = err _ msg , verbose = verbose )
DCSP print &apos; TODO&apos;
DCSP return ( &apos; % s / cifar10 _ % s.tfrecord &apos; % ( dataset _ dir , split _ name ) )
DCSP if ( not current _ user.is _ anonymous ) : DCNL DCSP DCSP return redirect ( url _ for ( &apos; forum.index &apos; ) ) DCNL DCSP form = ForgotPasswordForm ( ) DCNL DCSP if form.validate _ on _ submit ( ) : DCNL DCSP DCSP user = User.query.filter _ by ( email = form.email.data ) .first ( ) DCNL DCSP DCSP if user : DCNL DCSP DCSP DCSP send _ reset _ token.delay ( user ) DCNL DCSP DCSP DCSP flash ( _ ( &apos; Email DCSP sent ! DCSP Please DCSP check DCSP your DCSP inbox . &apos; ) , &apos; info &apos; ) DCNL DCSP DCSP DCSP return redirect ( url _ for ( &apos; auth.forgot _ password &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP flash ( _ ( &apos; You DCSP have DCSP entered DCSP an DCSP username DCSP or DCSP email DCSP address DCSP that DCSP is DCSP not DCSP linked DCSP with DCSP your DCSP account . &apos; ) , &apos; danger &apos; ) DCNL DCSP return render _ template ( &apos; auth / forgot _ password.html &apos; , form = form )
DCSP logging.warn ( ( &apos; The DCSP authomatic.request _ elements DCSP function DCSP is DCSP deprecated DCSP and DCSP will DCSP be DCSP removed DCSP in DCSP version DCSP 0.1.0 ! DCSP &apos; + &apos; Use DCSP the DCSP &quot; request _ elements &quot; DCSP method DCSP of DCSP the DCSP &quot; Authomatic &quot; DCSP class DCSP instead . &apos; ) ) DCNL DCSP return global _ authomatic _ instance.request _ elements ( * args , * * kwargs )
DCSP ( s , scope ) = funcstr ( leaves , expr ) DCNL DCSP return eval ( s , scope )
DCSP ( value , length ) = codecs.escape _ decode ( &apos; ab \ x07 \ x08 DCTB \ n \ r \ x0c \ x0bba &apos; ) DCNL DCSP AreEqual ( value , &apos; ab \ x07 \ x08 DCTB \ n \ r \ x0c \ x0bba &apos; ) DCNL DCSP AreEqual ( length , 11 ) DCNL DCSP ( value , length ) = codecs.escape _ decode ( &apos; \ \ a &apos; ) DCNL DCSP AreEqual ( value , &apos; \ x07 &apos; ) DCNL DCSP AreEqual ( length , 2 ) DCNL DCSP ( value , length ) = codecs.escape _ decode ( &apos; ab \ x07 \ x08 DCTB \ n \ r \ x0c \ x0bbaab \ \ a \ \ b \ \ t \ \ n \ \ r \ \ f \ \ vbaab \ \ \ x07 \ \ \ x08 \ \ DCTB \ \ \ n \ \ \ r \ \ \ x0c \ \ \ x0bba &apos; ) DCNL DCSP AreEqual ( value , &apos; ab \ x07 \ x08 DCTB \ n \ r \ x0c \ x0bbaab \ x07 \ x08 DCTB \ n \ r \ x0c \ x0bbaab \ \ \ x07 \ \ \ x08 \ \ DCTB \ \ \ r \ \ \ x0c \ \ \ x0bba &apos; ) DCNL DCSP AreEqual ( length , 47 ) DCNL DCSP ( value , length ) = codecs.escape _ decode ( &apos; \ \ \ x07 &apos; ) DCNL DCSP AreEqual ( value , &apos; \ \ \ x07 &apos; ) DCNL DCSP AreEqual ( length , 2 ) DCNL DCSP AreEqual ( &apos; abc &apos; , codecs.escape _ decode ( &apos; abc &apos; , None ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ &apos; , codecs.escape _ decode ( &apos; \ \ x &apos; , &apos; replace &apos; ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ x &apos; , codecs.escape _ decode ( &apos; \ \ x2 &apos; , &apos; replace &apos; ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ x &apos; , codecs.escape _ decode ( &apos; \ \ xI &apos; , &apos; replace &apos; ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ xI &apos; , codecs.escape _ decode ( &apos; \ \ xII &apos; , &apos; replace &apos; ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ x1 &apos; , codecs.escape _ decode ( &apos; \ \ x1I &apos; , &apos; replace &apos; ) &#91; 0 &#93; ) DCNL DCSP AreEqual ( &apos; ? \ \ xI &apos; , codecs.escape _ decode ( &apos; \ \ xI1 &apos; , &apos; replace &apos; ) &#91; 0 &#93; )
DCSP lines = clean _ lines.lines DCNL DCSP line = lines &#91; linenum &#93; DCNL DCSP raw = clean _ lines.raw _ lines DCNL DCSP raw _ line = raw &#91; linenum &#93; DCNL DCSP joined _ line = &apos; &apos; DCNL DCSP starting _ func = False DCNL DCSP regexp = &apos; ( \ \ w ( \ \ w &#124; : : &#124; \ \ * &#124; \ \ &amp; &#124; \ \ s ) * ) \ \ ( &apos; DCNL DCSP match _ result = Match ( regexp , line ) DCNL DCSP if match _ result : DCNL DCSP DCSP function _ name = match _ result.group ( 1 ) .split ( ) &#91; ( -1 ) &#93; DCNL DCSP DCSP if ( ( function _ name = = &apos; TEST &apos; ) or ( function _ name = = &apos; TEST _ F &apos; ) or ( not Match ( &apos; &#91; A-Z _ &#93; + $ &apos; , function _ name ) ) ) : DCNL DCSP DCSP DCSP starting _ func = True DCNL DCSP if starting _ func : DCNL DCSP DCSP body _ found = False DCNL DCSP DCSP for start _ linenum in xrange ( linenum , clean _ lines.NumLines ( ) ) : DCNL DCSP DCSP DCSP start _ line = lines &#91; start _ linenum &#93; DCNL DCSP DCSP DCSP joined _ line + = ( &apos; DCSP &apos; + start _ line.lstrip ( ) ) DCNL DCSP DCSP DCSP if Search ( &apos; ( ; &#124; } ) &apos; , start _ line ) : DCNL DCSP DCSP DCSP DCSP body _ found = True DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP elif Search ( &apos; { &apos; , start _ line ) : DCNL DCSP DCSP DCSP DCSP body _ found = True DCNL DCSP DCSP DCSP DCSP function = Search ( &apos; ( ( \ \ w &#124; : ) * ) \ \ ( &apos; , line ) .group ( 1 ) DCNL DCSP DCSP DCSP DCSP if Match ( &apos; TEST &apos; , function ) : DCNL DCSP DCSP DCSP DCSP DCSP parameter _ regexp = Search ( &apos; ( \ \ ( . * \ \ ) ) &apos; , joined _ line ) DCNL DCSP DCSP DCSP DCSP DCSP if parameter _ regexp : DCNL DCSP DCSP DCSP DCSP DCSP DCSP function + = parameter _ regexp.group ( 1 ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP function + = &apos; ( ) &apos; DCNL DCSP DCSP DCSP DCSP function _ state.Begin ( function ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if ( not body _ found ) : DCNL DCSP DCSP DCSP error ( filename , linenum , &apos; readability / fn _ size &apos; , 5 , &apos; Lint DCSP failed DCSP to DCSP find DCSP start DCSP of DCSP function DCSP body . &apos; ) DCNL DCSP elif Match ( &apos; ^ \ \ } \ \ s * $ &apos; , line ) : DCNL DCSP DCSP function _ state.Check ( error , filename , linenum ) DCNL DCSP DCSP function _ state.End ( ) DCNL DCSP elif ( not Match ( &apos; ^ \ \ s * $ &apos; , line ) ) : DCNL DCSP DCSP function _ state.Count ( )
DCSP path = os.path.normcase ( os.path.abspath ( path ) ) DCNL DCSP if path.startswith ( ( os.getcwd ( ) + os.path.sep ) ) : DCNL DCSP DCSP path = ( &apos; .&apos; + path &#91; len ( os.getcwd ( ) ) : &#93; ) DCNL DCSP return path
DCSP data = _ execute _ cmd ( plugin , args , &apos; cmd.run _ all &apos; ) DCNL DCSP return data
DCSP next = data.get ( &apos; next &apos; , default ) DCNL DCSP if ( next is None ) : DCNL DCSP DCSP next = urlresolvers.reverse ( default _ view ) DCNL DCSP if get _ kwargs : DCNL DCSP DCSP if ( &apos; # &apos; in next ) : DCNL DCSP DCSP DCSP tmp = next.rsplit ( &apos; # &apos; , 1 ) DCNL DCSP DCSP DCSP next = tmp &#91; 0 &#93; DCNL DCSP DCSP DCSP anchor = ( &apos; # &apos; + tmp &#91; 1 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP anchor = &apos; &apos; DCNL DCSP DCSP joiner = ( ( ( &apos; ? &apos; in next ) and &apos; &amp; &apos; ) or &apos; ? &apos; ) DCNL DCSP DCSP next + = ( ( joiner + urllib.urlencode ( get _ kwargs ) ) + anchor ) DCNL DCSP return HttpResponseRedirect ( next )
DCSP R = _ nbits ( ( ( long ( x ) &lt; &lt; L ) / / M ) ) DCNL DCSP T = ( - int ( ( ( ( -10 ) * len ( str ( M ) ) ) / / ( 3 * L ) ) ) ) DCNL DCSP y = _ div _ nearest ( x , T ) DCNL DCSP Mshift = ( long ( M ) &lt; &lt; R ) DCNL DCSP for i in xrange ( ( T - 1 ) , 0 , ( -1 ) ) : DCNL DCSP DCSP y = _ div _ nearest ( ( x * ( Mshift + y ) ) , ( Mshift * i ) ) DCNL DCSP for k in xrange ( ( R - 1 ) , ( -1 ) , ( -1 ) ) : DCNL DCSP DCSP Mshift = ( long ( M ) &lt; &lt; ( k + 2 ) ) DCNL DCSP DCSP y = _ div _ nearest ( ( y * ( y + Mshift ) ) , Mshift ) DCNL DCSP return ( M + y )
DCSP synopsis = &#91; ( ( t and t.replace ( &apos; vcard &apos; , &apos; contact &apos; ) ) or t ) for t in parent.SYNOPSIS &#93; DCNL DCSP synopsis &#91; 2 &#93; = synopsis &#91; 1 &#93; DCNL DCSP class ContactVCardCommand ( parent , ) : DCNL DCSP DCSP SYNOPSIS = tuple ( synopsis ) DCNL DCSP DCSP KIND = &apos; individual &apos; DCNL DCSP DCSP ORDER = ( &apos; Tagging &apos; , 3 ) DCNL DCSP DCSP VCARD = &apos; contact &apos; DCNL DCSP return ContactVCardCommand
DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return func ( * args , * * kwargs ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass DCNL DCSP return wrapper
DCSP value = six.moves.shlex _ quote ( value ) DCNL DCSP return value
DCSP word _ size = ( word _ size or context.word _ size ) DCNL DCSP endianness = context.endianness DCNL DCSP sign = context.sign DCNL DCSP if ( word _ size = = &apos; all &apos; ) : DCNL DCSP DCSP return &#91; unpack ( data , word _ size ) &#93; DCNL DCSP if ( ( word _ size % 8 ) ! = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; unpack _ many ( ) : DCSP word _ size DCSP must DCSP be DCSP a DCSP multiple DCSP of DCSP 8 &apos; ) DCNL DCSP out = &#91; &#93; DCNL DCSP n = ( word _ size / / 8 ) DCNL DCSP for i in range ( 0 , len ( data ) , n ) : DCNL DCSP DCSP out.append ( unpack ( data &#91; i : ( i + n ) &#93; , word _ size ) ) DCNL DCSP return list ( map ( int , out ) )
DCSP if ( len ( Y ) = = 0 ) : DCNL DCSP DCSP return ( np.zeros _ like ( Y ) , np.zeros ( ( 0 , ) , dtype = np.bool ) ) DCNL DCSP if ( shape is not None ) : DCNL DCSP DCSP shape _ init = Y.shape DCNL DCSP DCSP Y = Y.reshape ( * shape ) DCNL DCSP n _ positions = ( Y.shape &#91; 0 &#93; / / n _ orient ) DCNL DCSP if is _ stft : DCNL DCSP DCSP rows _ norm = np.sqrt ( stft _ norm2 ( Y ) .reshape ( n _ positions , ( -1 ) ) .sum ( axis = 1 ) ) DCNL DCSP else : DCNL DCSP DCSP rows _ norm = np.sqrt ( ( Y * Y.conj ( ) ) .real.reshape ( n _ positions , ( -1 ) ) .sum ( axis = 1 ) ) DCNL DCSP shrink = np.maximum ( ( 1.0 - ( alpha / np.maximum ( rows _ norm , alpha ) ) ) , 0.0 ) DCNL DCSP active _ set = ( shrink &gt; 0.0 ) DCNL DCSP if ( n _ orient &gt; 1 ) : DCNL DCSP DCSP active _ set = np.tile ( active _ set &#91; : , None &#93; , &#91; 1 , n _ orient &#93; ) .ravel ( ) DCNL DCSP DCSP shrink = np.tile ( shrink &#91; : , None &#93; , &#91; 1 , n _ orient &#93; ) .ravel ( ) DCNL DCSP Y = Y &#91; active _ set &#93; DCNL DCSP if ( shape is None ) : DCNL DCSP DCSP Y * = shrink &#91; active _ set &#93; &#91; : , np.newaxis &#93; DCNL DCSP else : DCNL DCSP DCSP Y * = shrink &#91; active _ set &#93; &#91; : , np.newaxis , np.newaxis &#93; DCNL DCSP DCSP Y = Y.reshape ( ( -1 ) , * shape _ init &#91; 1 : &#93; ) DCNL DCSP return ( Y , active _ set )
DCSP try : DCNL DCSP DCSP return pow ( ( label1 - label2 ) , 2 ) DCNL DCSP except : DCNL DCSP DCSP print ( &apos; non-numeric DCSP labels DCSP not DCSP supported DCSP with DCSP interval DCSP distance &apos; )
DCSP c = _ FFI.from _ handle ( context _ handle ) DCNL DCSP msg = bytes ( _ FFI.buffer ( msg _ ptr , msg _ len ) ) .decode ( u &apos;utf-8 &apos; ) DCNL DCSP return c.to _ value ( Exception ( msg ) )
DCSP class _ DeprecatedProperty ( property , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Extension DCSP of DCSP the DCSP build-in DCSP property DCSP to DCSP allow DCSP deprecated DCSP setters . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def _ deprecatedWrapper ( self , function ) : DCNL DCSP DCSP DCSP @ wraps ( function ) DCNL DCSP DCSP DCSP def deprecatedFunction ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP DCSP warn ( self.warningString , DeprecationWarning , stacklevel = 2 ) DCNL DCSP DCSP DCSP DCSP return function ( * args , * * kwargs ) DCNL DCSP DCSP DCSP return deprecatedFunction DCNL DCSP DCSP def setter ( self , function ) : DCNL DCSP DCSP DCSP return property.setter ( self , self . _ deprecatedWrapper ( function ) ) DCNL DCSP def deprecationDecorator ( function ) : DCNL DCSP DCSP if _ PY3 : DCNL DCSP DCSP DCSP warningString = getDeprecationWarningString ( function , version , None , replacement ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP functionName = function . _ _ name _ _ DCNL DCSP DCSP DCSP className = inspect.stack ( ) &#91; 1 &#93; &#91; 3 &#93; DCNL DCSP DCSP DCSP moduleName = function . _ _ module _ _ DCNL DCSP DCSP DCSP fqdn = ( &apos; % s . % s . % s &apos; % ( moduleName , className , functionName ) ) DCNL DCSP DCSP DCSP warningString = _ getDeprecationWarningString ( fqdn , version , None , replacement ) DCNL DCSP DCSP @ wraps ( function ) DCNL DCSP DCSP def deprecatedFunction ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP warn ( warningString , DeprecationWarning , stacklevel = 2 ) DCNL DCSP DCSP DCSP return function ( * args , * * kwargs ) DCNL DCSP DCSP _ appendToDocstring ( deprecatedFunction , _ getDeprecationDocstring ( version , replacement ) ) DCNL DCSP DCSP deprecatedFunction.deprecatedVersion = version DCNL DCSP DCSP result = _ DeprecatedProperty ( deprecatedFunction ) DCNL DCSP DCSP result.warningString = warningString DCNL DCSP DCSP return result DCNL DCSP return deprecationDecorator
DCSP flow _ name = ( ACTION.replace ( &apos; : &apos; , &apos; _ &apos; ) + &apos; _ api &apos; ) DCNL DCSP api _ flow = linear _ flow.Flow ( flow _ name ) DCNL DCSP api _ flow.add ( ExtractVolumeRequestTask ( image _ service _ api , availability _ zones , rebind = { &apos; size &apos; : &apos; raw _ size &apos; , &apos; availability _ zone &apos; : &apos; raw _ availability _ zone &apos; , &apos; volume _ type &apos; : &apos; raw _ volume _ type &apos; } ) ) DCNL DCSP api _ flow.add ( QuotaReserveTask ( ) , EntryCreateTask ( ) , QuotaCommitTask ( ) ) DCNL DCSP if ( scheduler _ rpcapi and volume _ rpcapi ) : DCNL DCSP DCSP api _ flow.add ( VolumeCastTask ( scheduler _ rpcapi , volume _ rpcapi , db _ api ) ) DCNL DCSP return taskflow.engines.load ( api _ flow , store = create _ what )
DCSP global COMPLETELY _ LOADED DCNL DCSP if ( COMPLETELY _ LOADED and ( not force ) ) : DCNL DCSP DCSP return True DCNL DCSP from django.apps import apps DCNL DCSP if ( not apps.ready ) : DCNL DCSP DCSP return DCNL DCSP import django DCNL DCSP from distutils.version import LooseVersion DCNL DCSP if ( LooseVersion ( django.get _ version ( ) ) &lt; LooseVersion ( u &apos; 1.8 &apos; ) ) : DCNL DCSP DCSP for model in apps.get _ models ( ) : DCNL DCSP DCSP DCSP for cache _ name in ( u &apos; _ field _ cache &apos; , u &apos; _ field _ name _ cache &apos; , u &apos; _ m2m _ cache &apos; , u &apos; _ related _ objects _ cache &apos; , u &apos; _ related _ many _ to _ many _ cache &apos; , u &apos; _ name _ map &apos; ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP delattr ( model . _ meta , cache _ name ) DCNL DCSP DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP model . _ meta . _ fill _ fields _ cache ( ) DCNL DCSP DCSP if hasattr ( apps , u &apos;cache &apos; ) : DCNL DCSP DCSP DCSP apps.cache.get _ models.cache _ clear ( ) DCNL DCSP if apps.ready : DCNL DCSP DCSP COMPLETELY _ LOADED = True DCNL DCSP return True
DCSP for ( module , func ) in funcs.items ( ) : DCNL DCSP DCSP test.stub _ out ( module , func )
DCSP conn.commit ( ) DCNL DCSP conn.close ( )
DCSP a = { } DCNL DCSP if cond : DCNL DCSP DCSP del a DCNL DCSP return a
DCSP cmd = &apos; salt DCSP \ \ * DCSP { 0 } DCSP --yaml-out DCSP -t DCSP 500 DCSP &gt; DCSP high &apos; .format ( command ) DCNL DCSP subprocess.call ( cmd , shell = True ) DCNL DCSP data = yaml.load ( open ( &apos; high &apos; ) ) DCNL DCSP hashes = set ( ) DCNL DCSP for ( key , val ) in six.iteritems ( data ) : DCNL DCSP DCSP has = hashlib.md5 ( str ( val ) ) .hexdigest ( ) DCNL DCSP DCSP if ( has not in hashes ) : DCNL DCSP DCSP DCSP print ( &apos; { 0 } : &apos; .format ( has ) ) DCNL DCSP DCSP DCSP pprint.pprint ( val ) DCNL DCSP DCSP hashes.add ( has ) DCNL DCSP if ( len ( hashes ) &gt; 1 ) : DCNL DCSP DCSP print ( &apos; { 0 } Command : DCSP { 1 } DCSP gave DCSP inconsistent DCSP returns { 2 } &apos; .format ( colors &#91; &apos; LIGHT _ RED &apos; &#93; , command , colors &#91; &apos; ENDC &apos; &#93; ) )
DCSP if ( len ( nt _ barcode ) ! = 8 ) : DCNL DCSP DCSP raise ValueError ( &apos; barcode DCSP must DCSP be DCSP 8 DCSP nt DCSP long . &apos; ) DCNL DCSP if set ( list ( nt _ barcode ) ) .difference ( CUR _ ENC _ FO.keys ( ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Only DCSP A , T , C , G DCSP valid DCSP chars . &apos; ) DCNL DCSP decoded = nt _ to _ cw ( CUR _ ENC _ FO , nt _ barcode ) DCNL DCSP ( num _ errors , sym ) = calc _ syndrome ( decoded , 16 ) DCNL DCSP if ( num _ errors = = 1 ) : DCNL DCSP DCSP nt _ barcode = unpack _ bitstr ( CUR _ REV _ ENC _ SI , &apos; &apos;.join ( map ( str , decoded ) ) ) DCNL DCSP elif ( num _ errors &gt; 1 ) : DCNL DCSP DCSP nt _ barcode = None DCNL DCSP return ( nt _ barcode , ( num _ errors / 2.0 ) )
DCSP cpu _ backend = cpu _ target.target _ context DCNL DCSP cpu _ backend.refresh ( ) DCNL DCSP fninfos = gather _ function _ info ( cpu _ backend ) DCNL DCSP out = format _ function _ infos ( fninfos ) DCNL DCSP if ( path is None ) : DCNL DCSP DCSP print ( out ) DCNL DCSP else : DCNL DCSP DCSP with open ( path , &apos; w &apos; ) as fobj : DCNL DCSP DCSP DCSP print ( out , file = fobj )
DCSP if isinstance ( ip , Net ) : DCNL DCSP DCSP ip = iter ( ip ) .next ( ) DCNL DCSP tmp = map ( ord , inet _ aton ( ip ) ) DCNL DCSP if ( ( tmp &#91; 0 &#93; &amp; 240 ) = = 224 ) : DCNL DCSP DCSP return ( &apos; 01 : 00 : 5e : % .2x : % .2x : % .2x &apos; % ( ( tmp &#91; 1 &#93; &amp; 127 ) , tmp &#91; 2 &#93; , tmp &#91; 3 &#93; ) ) DCNL DCSP ( iff , a , gw ) = conf.route.route ( ip ) DCNL DCSP if ( ( iff = = LOOPBACK _ NAME ) or ( ip = = conf.route.get _ if _ bcast ( iff ) ) ) : DCNL DCSP DCSP return &apos; ff : ff : ff : ff : ff : ff &apos; DCNL DCSP ifip = str ( pcapdnet.dnet.intf ( ) .get ( iff ) &#91; &apos; addr &apos; &#93; ) DCNL DCSP if ( gw ! = ifip.split ( &apos; / &apos; ) &#91; 0 &#93; ) : DCNL DCSP DCSP ip = gw DCNL DCSP mac = conf.netcache.arp _ cache.get ( ip ) DCNL DCSP if mac : DCNL DCSP DCSP return mac DCNL DCSP res = srp1 ( ( Ether ( dst = ETHER _ BROADCAST ) / ARP ( op = &apos; who-has &apos; , pdst = ip ) ) , type = ETH _ P _ ARP , iface = iff , timeout = 2 , verbose = 0 , chainCC = chainCC , nofilter = 1 ) DCNL DCSP if ( res is not None ) : DCNL DCSP DCSP mac = res.payload.hwsrc DCNL DCSP DCSP conf.netcache.arp _ cache &#91; ip &#93; = mac DCNL DCSP DCSP return mac DCNL DCSP return None
DCSP return ( &apos; % s DCSP ( % s ) &apos; % ( x &#91; &apos; Cybox &apos; &#93; &#91; &apos; Name &apos; &#93; , x &#91; &apos; Cybox &apos; &#93; &#91; &apos; PID &apos; &#93; ) )
DCSP @ wraps ( f ) DCNL DCSP def decorated ( * args , * * kwargs ) : DCNL DCSP DCSP message = &apos; Authentication DCSP credentials DCSP not DCSP found &apos; DCNL DCSP DCSP success = False DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP auth _ jwt ( ) DCNL DCSP DCSP DCSP success = True DCNL DCSP DCSP except JWTError as e : DCNL DCSP DCSP DCSP if ( ( e.headers is not None ) and ( &apos; WWW-Authenticate &apos; not in e.headers ) ) : DCNL DCSP DCSP DCSP DCSP raise NotAuthorizedError ( message = ( ( e.error + &apos; : DCSP &apos; ) + e.description ) ) DCNL DCSP DCSP if ( not success ) : DCNL DCSP DCSP DCSP results = auth _ basic ( ) DCNL DCSP DCSP DCSP if ( not results &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP if results &#91; 1 &#93; : DCNL DCSP DCSP DCSP DCSP DCSP raise NotAuthorizedError ( message = results &#91; 1 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP success = True DCNL DCSP DCSP if ( not success ) : DCNL DCSP DCSP DCSP if login.current _ user.is _ authenticated : DCNL DCSP DCSP DCSP DCSP g.user = UserModel.query.get ( login.current _ user.id ) DCNL DCSP DCSP DCSP DCSP success = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP g.user.update _ lat ( ) DCNL DCSP DCSP if success : DCNL DCSP DCSP DCSP return f ( * args , * * kwargs ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise NotAuthorizedError ( message = message ) DCNL DCSP return decorated
DCSP assert ( get _ editor _ filter ( state = &apos; untranslated &apos; ) = = &apos; # filter = untranslated &apos; ) DCNL DCSP assert ( get _ editor _ filter ( state = &apos; untranslated &apos; , sort = &apos; newest &apos; ) = = &apos; # filter = untranslated &amp; sort = newest &apos; ) DCNL DCSP assert ( get _ editor _ filter ( sort = &apos; newest &apos; ) = = &apos; # sort = newest &apos; ) DCNL DCSP assert ( get _ editor _ filter ( state = &apos; all &apos; , search = &apos; Foo &apos; , sfields = &apos; locations &apos; ) = = &apos; # filter = all &apos; ) DCNL DCSP assert ( get _ editor _ filter ( search = &apos; Foo &apos; , sfields = &apos; locations &apos; ) = = &apos; # search = Foo &amp; sfields = locations &apos; ) DCNL DCSP assert ( get _ editor _ filter ( search = &apos; Foo &apos; , sfields = &#91; &apos; locations &apos; , &apos; notes &apos; &#93; ) = = &apos; # search = Foo &amp; sfields = locations , notes &apos; ) DCNL DCSP assert ( get _ editor _ filter ( search = &apos; Foo : DCSP bar.po \ nID : DCSP 1 &apos; , sfields = &apos; locations &apos; ) = = &apos; # search = Foo % 3A + bar.po % 0AID % 3A + 1 &amp; sfields = locations &apos; )
DCSP os.chdir ( os.path.join ( gitdname , &apos; docs &apos; ) ) DCNL DCSP retcode = subprocess.call ( &apos; make DCSP clean &apos; , shell = True , stdout = sys.stdout , stderr = sys.stderr ) DCNL DCSP if ( retcode ! = 0 ) : DCNL DCSP DCSP os.chdir ( dname ) DCNL DCSP DCSP msg = ( &apos; Could DCSP not DCSP clean DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP % s &apos; % branch ) DCNL DCSP DCSP raise Exception ( msg ) DCNL DCSP sphinx _ call = &apos; DCSP &apos; .join ( &#91; &apos; make &apos; , &apos; html &apos; , &quot; SPHINXBUILD = &apos; DCSP python DCSP / usr / local / bin / sphinx-build &apos; &quot; &#93; ) DCNL DCSP activate = os.path.join ( virtual _ dir , &apos; bin &apos; , &apos; activate &apos; ) DCNL DCSP activate _ virtualenv = ( &apos; . DCSP &apos; + activate ) DCNL DCSP retcode = subprocess.call ( &apos; DCSP &amp; &amp; DCSP &apos; .join ( &#91; activate _ virtualenv , sphinx _ call &#93; ) , shell = True , env = env , stdout = sys.stdout , stderr = sys.stderr ) DCNL DCSP if ( retcode ! = 0 ) : DCNL DCSP DCSP os.chdir ( dname ) DCNL DCSP DCSP msg = ( &apos; Could DCSP not DCSP build DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP % s &apos; % branch ) DCNL DCSP DCSP raise Exception ( msg ) DCNL DCSP os.chdir ( dname )
DCSP init _ subsystem ( subsystem _ type , options ) DCNL DCSP return subsystem _ type.global _ instance ( )
DCSP for surf in surfs : DCNL DCSP DCSP _ assert _ complete _ surface ( surf ) DCNL DCSP for ( surf _ 1 , surf _ 2 ) in zip ( surfs &#91; : ( -1 ) &#93; , surfs &#91; 1 : &#93; ) : DCNL DCSP DCSP logger.info ( ( &apos; Checking DCSP that DCSP % s DCSP surface DCSP is DCSP inside DCSP % s DCSP surface ... &apos; % ( _ surf _ name &#91; surf _ 2 &#91; &apos; id &apos; &#93; &#93; , _ surf _ name &#91; surf _ 1 &#91; &apos; id &apos; &#93; &#93; ) ) ) DCNL DCSP DCSP _ assert _ inside ( surf _ 2 , surf _ 1 )
DCSP result = False DCNL DCSP pidfile _ pid = pidfile.read _ pid ( ) DCNL DCSP if ( pidfile _ pid is not None ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP os.kill ( pidfile _ pid , signal.SIG _ DFL ) DCNL DCSP DCSP except OSError as exc : DCNL DCSP DCSP DCSP if ( exc.errno = = errno.ESRCH ) : DCNL DCSP DCSP DCSP DCSP result = True DCNL DCSP return result
DCSP lookup = { &apos; default-timeout &apos; : &apos; Default DCSP Network DCSP Retry DCSP Timeout &apos; , &apos; logdir &apos; : &apos; Local DCSP Log DCSP Output &apos; , &apos; default-size &apos; : &apos; Local DCSP Logging DCSP Default DCSP Rotation DCSP Size &apos; , &apos; logdir-unique &apos; : &apos; Log DCSP To DCSP Unique DCSP Subdirectory &apos; , &apos; default-rotate &apos; : &apos; Local DCSP Logging DCSP Default DCSP Rotations &apos; , &apos; loghost &apos; : &apos; Remote DCSP Host &apos; } DCNL DCSP return lookup.get ( config )
DCSP failed _ db _ con = db.DBConnection ( &apos; failed.db &apos; ) DCNL DCSP failed _ db _ con.action ( ( &apos; DELETE DCSP FROM DCSP history DCSP WHERE DCSP date DCSP &lt; DCSP &apos; + str ( ( datetime.datetime.today ( ) - datetime.timedelta ( days = 30 ) ) .strftime ( History.date _ format ) ) ) )
DCSP thread _ id = comment _ data.get ( &apos; thread _ id &apos; ) DCNL DCSP if ( not thread _ id ) : DCNL DCSP DCSP raise ValidationError ( { &apos; thread _ id &apos; : &#91; &apos; This DCSP field DCSP is DCSP required . &apos; &#93; } ) DCNL DCSP ( cc _ thread , context ) = _ get _ thread _ and _ context ( request , thread _ id ) DCNL DCSP if cc _ thread &#91; &apos; closed &apos; &#93; : DCNL DCSP DCSP raise PermissionDenied DCNL DCSP _ check _ initializable _ comment _ fields ( comment _ data , context ) DCNL DCSP serializer = CommentSerializer ( data = comment _ data , context = context ) DCNL DCSP actions _ form = CommentActionsForm ( comment _ data ) DCNL DCSP if ( not ( serializer.is _ valid ( ) and actions _ form.is _ valid ( ) ) ) : DCNL DCSP DCSP raise ValidationError ( dict ( ( serializer.errors.items ( ) + actions _ form.errors.items ( ) ) ) ) DCNL DCSP serializer.save ( ) DCNL DCSP cc _ comment = serializer.instance DCNL DCSP comment _ created.send ( sender = None , user = request.user , post = cc _ comment ) DCNL DCSP api _ comment = serializer.data DCNL DCSP _ do _ extra _ actions ( api _ comment , cc _ comment , comment _ data.keys ( ) , actions _ form , context , request ) DCNL DCSP track _ comment _ created _ event ( request , context &#91; &apos; course &apos; &#93; , cc _ comment , cc _ thread &#91; &apos; commentable _ id &apos; &#93; , followed = False ) DCNL DCSP return api _ comment
DCSP if ( not api _ key ) : DCNL DCSP DCSP return &apos; This DCSP command DCSP requires DCSP a DCSP SoundCloud DCSP API DCSP key . &apos; DCNL DCSP try : DCNL DCSP DCSP user = get _ with _ search ( &apos; users &apos; , text ) DCNL DCSP except APIError as ae : DCNL DCSP DCSP return ae DCNL DCSP if ( not user ) : DCNL DCSP DCSP return &apos; No DCSP results DCSP found . &apos; DCNL DCSP try : DCNL DCSP DCSP return format _ user ( user ) DCNL DCSP except APIError as ae : DCNL DCSP DCSP return ae
DCSP emLen = ceil _ div ( emBits , 8 ) DCNL DCSP lmask = 0 DCNL DCSP for i in xrange ( ( ( 8 * emLen ) - emBits ) ) : DCNL DCSP DCSP lmask = ( ( lmask &gt; &gt; 1 ) &#124; 128 ) DCNL DCSP if ( emLen &lt; ( ( mhash.digest _ size + sLen ) + 2 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Digest DCSP or DCSP salt DCSP length DCSP are DCSP too DCSP long DCSP for DCSP given DCSP key DCSP size . &apos; ) DCNL DCSP salt = b ( &apos; &apos; ) DCNL DCSP if ( randFunc and ( sLen &gt; 0 ) ) : DCNL DCSP DCSP salt = randFunc ( sLen ) DCNL DCSP h = mhash.new ( ( ( ( bchr ( 0 ) * 8 ) + mhash.digest ( ) ) + salt ) ) DCNL DCSP db = ( ( ( bchr ( 0 ) * ( ( ( emLen - sLen ) - mhash.digest _ size ) - 2 ) ) + bchr ( 1 ) ) + salt ) DCNL DCSP dbMask = mgf ( h.digest ( ) , ( ( emLen - mhash.digest _ size ) - 1 ) ) DCNL DCSP maskedDB = strxor ( db , dbMask ) DCNL DCSP maskedDB = ( bchr ( ( bord ( maskedDB &#91; 0 &#93; ) &amp; ( ~ lmask ) ) ) + maskedDB &#91; 1 : &#93; ) DCNL DCSP em = ( ( maskedDB + h.digest ( ) ) + bchr ( 188 ) ) DCNL DCSP return em
DCSP ( is _ free _ ori , _ , proj , vertno , G ) = _ prepare _ beamformer _ input ( info , forward , label , picks , pick _ ori ) DCNL DCSP Cm = data _ csd.data DCNL DCSP Cm _ inv = linalg.pinv ( Cm , reg ) DCNL DCSP W = np.dot ( G.T , Cm _ inv ) DCNL DCSP n _ orient = ( 3 if is _ free _ ori else 1 ) DCNL DCSP n _ sources = ( G.shape &#91; 1 &#93; / / n _ orient ) DCNL DCSP for k in range ( n _ sources ) : DCNL DCSP DCSP Wk = W &#91; ( n _ orient * k ) : ( ( n _ orient * k ) + n _ orient ) &#93; DCNL DCSP DCSP Gk = G &#91; : , ( n _ orient * k ) : ( ( n _ orient * k ) + n _ orient ) &#93; DCNL DCSP DCSP Ck = np.dot ( Wk , Gk ) DCNL DCSP DCSP if is _ free _ ori : DCNL DCSP DCSP DCSP Wk &#91; : &#93; = np.dot ( linalg.pinv ( Ck , 0.1 ) , Wk ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP Wk / = Ck DCNL DCSP DCSP noise _ norm = np.dot ( np.dot ( Wk.conj ( ) , noise _ csd.data ) , Wk.T ) DCNL DCSP DCSP noise _ norm = np.abs ( noise _ norm ) .trace ( ) DCNL DCSP DCSP Wk / = np.sqrt ( noise _ norm ) DCNL DCSP if ( pick _ ori = = &apos; normal &apos; ) : DCNL DCSP DCSP W = W &#91; 2 : : 3 &#93; DCNL DCSP DCSP is _ free _ ori = False DCNL DCSP if ( isinstance ( data , np.ndarray ) and ( data.ndim = = 2 ) ) : DCNL DCSP DCSP data = &#91; data &#93; DCNL DCSP DCSP return _ single = True DCNL DCSP else : DCNL DCSP DCSP return _ single = False DCNL DCSP subject = _ subject _ from _ forward ( forward ) DCNL DCSP for ( i , M ) in enumerate ( data ) : DCNL DCSP DCSP if ( len ( M ) ! = len ( picks ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; data DCSP and DCSP picks DCSP must DCSP have DCSP the DCSP same DCSP length &apos; ) DCNL DCSP DCSP if ( not return _ single ) : DCNL DCSP DCSP DCSP logger.info ( ( &apos; Processing DCSP epoch DCSP : DCSP % d &apos; % ( i + 1 ) ) ) DCNL DCSP DCSP if info &#91; &apos; projs &apos; &#93; : DCNL DCSP DCSP DCSP M = np.dot ( proj , M ) DCNL DCSP DCSP if is _ free _ ori : DCNL DCSP DCSP DCSP sol = np.dot ( W , M ) DCNL DCSP DCSP DCSP logger.info ( &apos; combining DCSP the DCSP current DCSP components ... &apos; ) DCNL DCSP DCSP DCSP sol = combine _ xyz ( sol ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sol = np.dot ( W , M ) DCNL DCSP DCSP tstep = ( 1.0 / info &#91; &apos; sfreq &apos; &#93; ) DCNL DCSP DCSP if np.iscomplexobj ( sol ) : DCNL DCSP DCSP DCSP sol = np.abs ( sol ) DCNL DCSP DCSP ( yield _ make _ stc ( sol , vertices = vertno , tmin = tmin , tstep = tstep , subject = subject ) ) DCNL DCSP logger.info ( &apos; &#91; done &#93; &apos; )
DCSP ( a , axisout ) = _ chk _ asarray ( a , axis ) DCNL DCSP ( contains _ nan , nan _ policy ) = _ contains _ nan ( a , nan _ policy ) DCNL DCSP if ( contains _ nan and ( nan _ policy = = &apos; omit &apos; ) ) : DCNL DCSP DCSP a = ma.masked _ invalid ( a ) DCNL DCSP DCSP b = ma.masked _ invalid ( b ) DCNL DCSP DCSP return mstats _ basic.spearmanr ( a , b , axis ) DCNL DCSP if ( a.size &lt; = 1 ) : DCNL DCSP DCSP return SpearmanrResult ( np.nan , np.nan ) DCNL DCSP ar = np.apply _ along _ axis ( rankdata , axisout , a ) DCNL DCSP br = None DCNL DCSP if ( b is not None ) : DCNL DCSP DCSP ( b , axisout ) = _ chk _ asarray ( b , axis ) DCNL DCSP DCSP ( contains _ nan , nan _ policy ) = _ contains _ nan ( b , nan _ policy ) DCNL DCSP DCSP if ( contains _ nan and ( nan _ policy = = &apos; omit &apos; ) ) : DCNL DCSP DCSP DCSP b = ma.masked _ invalid ( b ) DCNL DCSP DCSP DCSP return mstats _ basic.spearmanr ( a , b , axis ) DCNL DCSP DCSP br = np.apply _ along _ axis ( rankdata , axisout , b ) DCNL DCSP n = a.shape &#91; axisout &#93; DCNL DCSP rs = np.corrcoef ( ar , br , rowvar = axisout ) DCNL DCSP olderr = np.seterr ( divide = &apos; ignore &apos; ) DCNL DCSP try : DCNL DCSP DCSP t = ( rs * np.sqrt ( ( ( n - 2 ) / ( ( rs + 1.0 ) * ( 1.0 - rs ) ) ) .clip ( 0 ) ) ) DCNL DCSP finally : DCNL DCSP DCSP np.seterr ( * * olderr ) DCNL DCSP prob = ( 2 * distributions.t.sf ( np.abs ( t ) , ( n - 2 ) ) ) DCNL DCSP if ( rs.shape = = ( 2 , 2 ) ) : DCNL DCSP DCSP return SpearmanrResult ( rs &#91; ( 1 , 0 ) &#93; , prob &#91; ( 1 , 0 ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP return SpearmanrResult ( rs , prob )
DCSP rpc = create _ rpc ( deadline ) DCNL DCSP make _ get _ default _ gcs _ bucket _ name _ call ( rpc ) DCNL DCSP rpc.wait ( ) DCNL DCSP return rpc.get _ result ( )
DCSP def decorator ( generator ) : DCNL DCSP DCSP def decorated ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP for v in generator ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP DCSP send ( event , info = v ) DCNL DCSP DCSP DCSP DCSP ( yield v ) DCNL DCSP DCSP return decorated DCNL DCSP return decorator
DCSP builder = yaml _ object.ObjectBuilder ( AppInfoExternal ) DCNL DCSP handler = yaml _ builder.BuilderHandler ( builder ) DCNL DCSP listener = yaml _ listener.EventListener ( handler ) DCNL DCSP listener.Parse ( app _ info ) DCNL DCSP app _ infos = handler.GetResults ( ) DCNL DCSP if ( len ( app _ infos ) &lt; 1 ) : DCNL DCSP DCSP raise appinfo _ errors.EmptyConfigurationFile ( ) DCNL DCSP if ( len ( app _ infos ) &gt; 1 ) : DCNL DCSP DCSP raise appinfo _ errors.MultipleConfigurationFile ( ) DCNL DCSP appyaml = app _ infos &#91; 0 &#93; DCNL DCSP ValidateHandlers ( appyaml.handlers ) DCNL DCSP if appyaml.builtins : DCNL DCSP DCSP BuiltinHandler.Validate ( appyaml.builtins , appyaml.runtime ) DCNL DCSP if ( appyaml.application and appyaml.project ) : DCNL DCSP DCSP raise appinfo _ errors.MultipleProjectNames ( &apos; Specify DCSP one DCSP of DCSP &quot; application : DCSP name &quot; DCSP or DCSP &quot; project : DCSP name &quot; &apos; ) DCNL DCSP elif appyaml.project : DCNL DCSP DCSP appyaml.application = appyaml.project DCNL DCSP DCSP appyaml.project = None DCNL DCSP appyaml.NormalizeVmSettings ( ) DCNL DCSP return appyaml
DCSP tokenizer = IDTokenizer ( ) DCNL DCSP if lowercase : DCNL DCSP DCSP tokenizer = ( tokenizer &#124; LowercaseFilter ( ) ) DCNL DCSP return tokenizer
DCSP pb.set _ storage ( document _ pb.Document.DISK ) DCNL DCSP if document.doc _ id : DCNL DCSP DCSP pb.set _ id ( document.doc _ id.encode ( &apos; utf-8 &apos; ) ) DCNL DCSP if document.language : DCNL DCSP DCSP pb.set _ language ( document.language.encode ( &apos; utf-8 &apos; ) ) DCNL DCSP for field in document.fields : DCNL DCSP DCSP field _ pb = pb.add _ field ( ) DCNL DCSP DCSP _ CopyFieldToProtocolBuffer ( field , field _ pb ) DCNL DCSP pb.set _ order _ id ( document.rank ) DCNL DCSP return pb
DCSP if ( abs ( int ( N ) ) ! = N ) : DCNL DCSP DCSP raise ValueError ( &apos; Filter DCSP order DCSP must DCSP be DCSP a DCSP nonnegative DCSP integer &apos; ) DCNL DCSP z = numpy.array ( &#91; &#93; ) DCNL DCSP m = numpy.arange ( ( ( - N ) + 1 ) , N , 2 ) DCNL DCSP p = ( - numpy.exp ( ( ( ( 1j * pi ) * m ) / ( 2 * N ) ) ) ) DCNL DCSP k = 1 DCNL DCSP return ( z , p , k )
DCSP try : DCNL DCSP DCSP limit = int ( request.GET &#91; &apos; limit &apos; &#93; ) DCNL DCSP except ValueError : DCNL DCSP DCSP msg = _ ( &apos; limit DCSP param DCSP must DCSP be DCSP an DCSP integer &apos; ) DCNL DCSP DCSP raise webob.exc.HTTPBadRequest ( explanation = msg ) DCNL DCSP if ( limit &lt; 0 ) : DCNL DCSP DCSP msg = _ ( &apos; limit DCSP param DCSP must DCSP be DCSP positive &apos; ) DCNL DCSP DCSP raise webob.exc.HTTPBadRequest ( explanation = msg ) DCNL DCSP return limit
DCSP snap _ name = _ sdecode ( snap _ name ) DCNL DCSP if re.match ( GUID _ REGEX , snap _ name ) : DCNL DCSP DCSP return snap _ name.strip ( &apos; { } &apos; ) DCNL DCSP else : DCNL DCSP DCSP return snapshot _ name _ to _ id ( name , snap _ name , strict = strict , runas = runas )
DCSP ans = { u &apos;raw _ data &apos; : data , u &apos;font _ data &apos; : None , u &apos;err &apos; : None , u &apos;ext &apos; : u &apos;failed &apos; , u &apos;headers &apos; : None , u &apos;encrypted &apos; : False } DCNL DCSP try : DCNL DCSP DCSP ( usize , flags , dstart , xor _ len , xor _ start ) = struct.unpack _ from ( &apos; &gt; LLLLL &apos; , data , 4 ) DCNL DCSP except : DCNL DCSP DCSP ans &#91; u &apos;err &apos; &#93; = u &apos;Failed DCSP to DCSP read DCSP font DCSP record DCSP header DCSP fields &apos; DCNL DCSP DCSP return ans DCNL DCSP font _ data = data &#91; dstart : &#93; DCNL DCSP ans &#91; u &apos;headers &apos; &#93; = { u &apos;usize &apos; : usize , u &apos;flags &apos; : bin ( flags ) , u &apos;xor _ len &apos; : xor _ len , u &apos;xor _ start &apos; : xor _ start , u &apos;dstart &apos; : dstart } DCNL DCSP if ( flags &amp; 2 ) : DCNL DCSP DCSP key = bytearray ( data &#91; xor _ start : ( xor _ start + xor _ len ) &#93; ) DCNL DCSP DCSP buf = bytearray ( font _ data ) DCNL DCSP DCSP extent = ( len ( font _ data ) if ( extent is None ) else extent ) DCNL DCSP DCSP extent = min ( extent , len ( font _ data ) ) DCNL DCSP DCSP for n in xrange ( extent ) : DCNL DCSP DCSP DCSP buf &#91; n &#93; ^ = key &#91; ( n % xor _ len ) &#93; DCNL DCSP DCSP font _ data = bytes ( buf ) DCNL DCSP DCSP ans &#91; u &apos;encrypted &apos; &#93; = True DCNL DCSP if ( flags &amp; 1 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP font _ data = zlib.decompress ( font _ data ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP ans &#91; u &apos;err &apos; &#93; = ( u &apos;Failed DCSP to DCSP zlib DCSP decompress DCSP font DCSP data DCSP ( % s ) &apos; % e ) DCNL DCSP DCSP DCSP return ans DCNL DCSP DCSP if ( len ( font _ data ) ! = usize ) : DCNL DCSP DCSP DCSP ans &#91; u &apos;err &apos; &#93; = u &apos;Uncompressed DCSP font DCSP size DCSP mismatch &apos; DCNL DCSP DCSP DCSP return ans DCNL DCSP ans &#91; u &apos;font _ data &apos; &#93; = font _ data DCNL DCSP sig = font _ data &#91; : 4 &#93; DCNL DCSP ans &#91; u &apos;ext &apos; &#93; = ( u &apos;ttf &apos; if ( sig in { &apos; \ x00 \ x01 \ x00 \ x00 &apos; , &apos; true &apos; , &apos; ttcf &apos; } ) else ( u &apos;otf &apos; if ( sig = = &apos; OTTO &apos; ) else u &apos;dat &apos; ) ) DCNL DCSP return ans
DCSP if ( &apos; -&apos; in svn _ version ) : DCNL DCSP DCSP while ( svn _ version.count ( &apos; .&apos; ) &lt; 2 ) : DCNL DCSP DCSP DCSP svn _ version = svn _ version.replace ( &apos; -&apos; , &apos; .0- &apos; ) DCNL DCSP else : DCNL DCSP DCSP while ( svn _ version.count ( &apos; .&apos; ) &lt; 2 ) : DCNL DCSP DCSP DCSP svn _ version + = &apos; .0 &apos; DCNL DCSP version _ h = open ( os.path.join ( get _ base _ dir ( ) , &apos; src &apos; , &apos; lxml &apos; , &apos; includes &apos; , &apos; lxml-version.h &apos; ) , &apos; w &apos; ) DCNL DCSP version _ h.write ( ( &apos; # ifndef DCSP LXML _ VERSION _ STRING \ n # define DCSP LXML _ VERSION _ STRING DCSP &quot; % s &quot; \ n # endif \ n &apos; % svn _ version ) ) DCNL DCSP version _ h.close ( )
DCSP if ( request.method ! = &apos; POST &apos; ) : DCNL DCSP DCSP return json _ error ( _ ( &apos; Invalid DCSP verb &apos; ) ) DCNL DCSP property _ converters = { &apos; color &apos; : check _ string , &apos; in _ home _ view &apos; : check _ bool , &apos; desktop _ notifications &apos; : check _ bool , &apos; audible _ notifications &apos; : check _ bool , &apos; pin _ to _ top &apos; : check _ bool } DCNL DCSP response _ data = &#91; &#93; DCNL DCSP for change in subscription _ data : DCNL DCSP DCSP stream _ name = change &#91; &apos; stream &apos; &#93; DCNL DCSP DCSP property = change &#91; &apos; property &apos; &#93; DCNL DCSP DCSP value = change &#91; &apos; value &apos; &#93; DCNL DCSP DCSP if ( property not in property _ converters ) : DCNL DCSP DCSP DCSP return json _ error ( ( _ ( &apos; Unknown DCSP subscription DCSP property : DCSP % s &apos; ) % ( property , ) ) ) DCNL DCSP DCSP sub = get _ subscription _ or _ die ( stream _ name , user _ profile ) &#91; 0 &#93; DCNL DCSP DCSP property _ conversion = property _ converters &#91; property &#93; ( property , value ) DCNL DCSP DCSP if property _ conversion : DCNL DCSP DCSP DCSP return json _ error ( property _ conversion ) DCNL DCSP DCSP do _ change _ subscription _ property ( user _ profile , sub , stream _ name , property , value ) DCNL DCSP DCSP response _ data.append ( { &apos; stream &apos; : stream _ name , &apos; property &apos; : property , &apos; value &apos; : value } ) DCNL DCSP return json _ success ( { &apos; subscription _ data &apos; : response _ data } )
DCSP if ( not parser ) : DCNL DCSP DCSP parser = get _ parser ( ) DCNL DCSP if ( not parser.has _ option ( &apos; --config &apos; ) ) : DCNL DCSP DCSP if ( config _ file is True ) : DCNL DCSP DCSP DCSP config _ file = DEFAULT _ CONFIG DCNL DCSP DCSP group = parser.add _ option _ group ( &apos; Configuration &apos; , description = ( &apos; The DCSP project DCSP options DCSP are DCSP read DCSP from DCSP the DCSP &#91; % s &#93; DCSP section DCSP of DCSP the DCSP tox.ini DCSP file DCSP or DCSP the DCSP setup.cfg DCSP file DCSP located DCSP in DCSP any DCSP parent DCSP folder DCSP of DCSP the DCSP path ( s ) DCSP being DCSP processed . DCSP DCSP Allowed DCSP options DCSP are : DCSP % s . &apos; % ( parser.prog , &apos; , DCSP &apos; .join ( parser.config _ options ) ) ) ) DCNL DCSP DCSP group.add _ option ( &apos; --config &apos; , metavar = &apos; path &apos; , default = config _ file , help = &apos; user DCSP config DCSP file DCSP location DCSP ( default : DCSP % default ) &apos; ) DCNL DCSP if ( ( not arglist ) and ( not parse _ argv ) ) : DCNL DCSP DCSP arglist = &#91; &#93; DCNL DCSP ( options , args ) = parser.parse _ args ( arglist ) DCNL DCSP options.reporter = None DCNL DCSP if options.ensure _ value ( &apos; testsuite &apos; , False ) : DCNL DCSP DCSP args.append ( options.testsuite ) DCNL DCSP elif ( not options.ensure _ value ( &apos; doctest &apos; , False ) ) : DCNL DCSP DCSP if ( parse _ argv and ( not args ) ) : DCNL DCSP DCSP DCSP if ( options.diff or any ( ( os.path.exists ( name ) for name in PROJECT _ CONFIG ) ) ) : DCNL DCSP DCSP DCSP DCSP args = &#91; &apos; .&apos; &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP parser.error ( &apos; input DCSP not DCSP specified &apos; ) DCNL DCSP DCSP options = read _ config ( options , args , arglist , parser ) DCNL DCSP DCSP options.reporter = ( parse _ argv and ( options.quiet = = 1 ) and FileReport ) DCNL DCSP options.filename = ( options.filename and options.filename.split ( &apos; , &apos; ) ) DCNL DCSP options.exclude = normalize _ paths ( options.exclude ) DCNL DCSP options.select = ( options.select and options.select.split ( &apos; , &apos; ) ) DCNL DCSP options.ignore = ( options.ignore and options.ignore.split ( &apos; , &apos; ) ) DCNL DCSP if options.diff : DCNL DCSP DCSP options.reporter = DiffReport DCNL DCSP DCSP stdin = stdin _ get _ value ( ) DCNL DCSP DCSP options.selected _ lines = parse _ udiff ( stdin , options.filename , args &#91; 0 &#93; ) DCNL DCSP DCSP args = sorted ( options.selected _ lines ) DCNL DCSP return ( options , args )
DCSP try : DCNL DCSP DCSP thisdate = row &#91; &apos; project _ time.date &apos; &#93; DCNL DCSP except AttributeError : DCNL DCSP DCSP return current.messages &#91; &apos; NONE &apos; &#93; DCNL DCSP if ( not thisdate ) : DCNL DCSP DCSP return current.messages &#91; &apos; NONE &apos; &#93; DCNL DCSP day = thisdate.date ( ) DCNL DCSP monday = ( day - datetime.timedelta ( days = day.weekday ( ) ) ) DCNL DCSP return monday
DCSP if ( ( not isinstance ( pid , int ) ) or ( pid &lt; 0 ) ) : DCNL DCSP DCSP return None DCNL DCSP if stem.util.proc.is _ available ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return float ( stem.util.proc.stats ( pid , stem.util.proc.Stat.START _ TIME ) &#91; 0 &#93; ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP ps _ results = call ( ( &apos; ps DCSP -p DCSP % s DCSP -o DCSP etime &apos; % pid ) , &#91; &#93; ) DCNL DCSP DCSP if ( len ( ps _ results ) &gt; = 2 ) : DCNL DCSP DCSP DCSP etime = ps _ results &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP return ( time.time ( ) - stem.util.str _ tools.parse _ short _ time _ label ( etime ) ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP return None
DCSP return SigningModule ( mpstate )
DCSP state1 _ avg _ dists = &#91; &#93; DCNL DCSP for sam1 in state1 _ samids : DCNL DCSP DCSP dists = &#91; &#93; DCNL DCSP DCSP for sam2 in state2 _ samids : DCNL DCSP DCSP DCSP if ( sam1 = = sam2 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP dists.append ( distdict &#91; sam1 &#93; &#91; sam2 &#93; ) DCNL DCSP DCSP state1 _ avg _ dists.append ( numpy.mean ( dists ) ) DCNL DCSP return state1 _ avg _ dists
DCSP project = get _ object _ or _ 404 ( Project , pk = project _ id ) DCNL DCSP if ( not request.user.profile.has _ permission ( project , mode = &apos; w &apos; ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Project &quot; ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP form = ProjectForm ( request.user.profile , None , request.POST , instance = project ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP project = form.save ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; projects _ project _ view &apos; , args = &#91; project.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; projects _ project _ view &apos; , args = &#91; project.id &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP form = ProjectForm ( request.user.profile , None , instance = project ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; form &apos; : form , &apos; project &apos; : project } ) DCNL DCSP return render _ to _ response ( &apos; projects / project _ edit &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP rights = rights _ manager.get _ collection _ rights ( collection _ id ) DCNL DCSP rank = ( _ DEFAULT _ RANK + ( _ STATUS _ PUBLICIZED _ BONUS if ( rights.status = = rights _ manager.ACTIVITY _ STATUS _ PUBLICIZED ) else 0 ) ) DCNL DCSP return max ( rank , 0 )
DCSP signals.initialized.connect ( pelican _ init ) DCNL DCSP signals.article _ generator _ context.connect ( custom _ url ) DCNL DCSP directives.register _ directive ( &apos; uml &apos; , PlantUML _ rst )
DCSP if ( not isabs ( path ) ) : DCNL DCSP DCSP path = join ( os.getcwd ( ) , path ) DCNL DCSP return normpath ( path )
DCSP while ( path and ( not os.path.isdir ( path ) ) ) : DCNL DCSP DCSP if ( path = = os.path.dirname ( path ) ) : DCNL DCSP DCSP DCSP path = &apos; &apos; DCNL DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP path = os.path.dirname ( path ) DCNL DCSP if ( path = = &apos; &apos; ) : DCNL DCSP DCSP if ( os.name = = &apos; nt &apos; ) : DCNL DCSP DCSP DCSP entries = &#91; { &apos; current _ path &apos; : &apos; Root &apos; } &#93; DCNL DCSP DCSP DCSP for letter in getWinDrives ( ) : DCNL DCSP DCSP DCSP DCSP letterPath = ( letter + &apos; : \ \ &apos; ) DCNL DCSP DCSP DCSP DCSP entries.append ( { &apos; name &apos; : letterPath , &apos; path &apos; : letterPath } ) DCNL DCSP DCSP DCSP return entries DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP path = &apos; / &apos; DCNL DCSP path = os.path.abspath ( os.path.normpath ( path ) ) DCNL DCSP parentPath = os.path.dirname ( path ) DCNL DCSP if ( ( path = = parentPath ) and ( os.name = = &apos; nt &apos; ) ) : DCNL DCSP DCSP parentPath = &apos; &apos; DCNL DCSP fileList = &#91; { &apos; name &apos; : filename , &apos; path &apos; : ek.ek ( os.path.join , path , filename ) } for filename in ek.ek ( os.listdir , path ) &#93; DCNL DCSP fileList = filter ( ( lambda entry : ek.ek ( os.path.isdir , entry &#91; &apos; path &apos; &#93; ) ) , fileList ) DCNL DCSP hideList = &#91; &apos; boot &apos; , &apos; bootmgr &apos; , &apos; cache &apos; , &apos; msocache &apos; , &apos; recovery &apos; , &apos; $ recycle.bin &apos; , &apos; recycler &apos; , &apos; system DCSP volume DCSP information &apos; , &apos; temporary DCSP internet DCSP files &apos; &#93; DCNL DCSP hideList + = &#91; &apos; .fseventd &apos; , &apos; .spotlight &apos; , &apos; .trashes &apos; , &apos; .vol &apos; , &apos; cachedmessages &apos; , &apos; caches &apos; , &apos; trash &apos; &#93; DCNL DCSP fileList = filter ( ( lambda entry : ( entry &#91; &apos; name &apos; &#93; .lower ( ) not in hideList ) ) , fileList ) DCNL DCSP fileList = sorted ( fileList , ( lambda x , y : cmp ( os.path.basename ( x &#91; &apos; name &apos; &#93; ) .lower ( ) , os.path.basename ( y &#91; &apos; path &apos; &#93; ) .lower ( ) ) ) ) DCNL DCSP entries = &#91; { &apos; current _ path &apos; : path } &#93; DCNL DCSP if ( includeParent and ( parentPath ! = path ) ) : DCNL DCSP DCSP entries.append ( { &apos; name &apos; : &apos; .. &apos; , &apos; path &apos; : parentPath } ) DCNL DCSP entries.extend ( fileList ) DCNL DCSP return entries
DCSP try : DCNL DCSP DCSP addr = inet _ pton ( socket.AF _ INET , addr ) DCNL DCSP DCSP addr = inet _ ntop ( socket.AF _ INET6 , ( ( &apos; DCSP \ x02 &apos; + addr ) + ( &apos; \ x00 &apos; * 10 ) ) ) DCNL DCSP except : DCNL DCSP DCSP return None DCNL DCSP return addr
DCSP aggrSum = 0 DCNL DCSP nonNone = 0 DCNL DCSP for elem in inList : DCNL DCSP DCSP if ( elem ! = SENTINEL _ VALUE _ FOR _ MISSING _ DATA ) : DCNL DCSP DCSP DCSP aggrSum + = elem DCNL DCSP DCSP DCSP nonNone + = 1 DCNL DCSP if ( nonNone ! = 0 ) : DCNL DCSP DCSP return ( aggrSum / nonNone ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP names = os.listdir ( src ) DCNL DCSP if ( ignore is not None ) : DCNL DCSP DCSP ignored _ names = ignore ( src , names ) DCNL DCSP else : DCNL DCSP DCSP ignored _ names = set ( ) DCNL DCSP os.makedirs ( dst ) DCNL DCSP errors = &#91; &#93; DCNL DCSP for name in names : DCNL DCSP DCSP if ( name in ignored _ names ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP srcname = os.path.join ( src , name ) DCNL DCSP DCSP dstname = os.path.join ( dst , name ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if os.path.islink ( srcname ) : DCNL DCSP DCSP DCSP DCSP linkto = os.readlink ( srcname ) DCNL DCSP DCSP DCSP DCSP if symlinks : DCNL DCSP DCSP DCSP DCSP DCSP os.symlink ( linkto , dstname ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( not os.path.exists ( linkto ) ) and ignore _ dangling _ symlinks ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP copy _ function ( srcname , dstname ) DCNL DCSP DCSP DCSP elif os.path.isdir ( srcname ) : DCNL DCSP DCSP DCSP DCSP copytree ( srcname , dstname , symlinks , ignore , copy _ function ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP copy _ function ( srcname , dstname ) DCNL DCSP DCSP except Error as err : DCNL DCSP DCSP DCSP errors.extend ( err.args &#91; 0 &#93; ) DCNL DCSP DCSP except EnvironmentError as why : DCNL DCSP DCSP DCSP errors.append ( ( srcname , dstname , str ( why ) ) ) DCNL DCSP try : DCNL DCSP DCSP copystat ( src , dst ) DCNL DCSP except OSError as why : DCNL DCSP DCSP if ( ( WindowsError is not None ) and isinstance ( why , WindowsError ) ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP errors.extend ( ( src , dst , str ( why ) ) ) DCNL DCSP if errors : DCNL DCSP DCSP raise Error ( errors )
DCSP assert _ close ( reconstruction ( np.zeros ( ( 5 , 7 ) ) , np.zeros ( ( 5 , 7 ) ) ) , 0 )
DCSP new _ path = ( environ &#91; &apos; PATH _ INFO &apos; &#93; .strip ( &apos; / &apos; ) + &apos; / &apos; ) DCNL DCSP query _ string = environ.get ( &apos; QUERY _ STRING &apos; ) DCNL DCSP if query _ string : DCNL DCSP DCSP new _ path + = ( &apos; ? &apos; + query _ string ) DCNL DCSP return redirect ( new _ path , code )
DCSP if request.GET : DCNL DCSP DCSP if ( &apos; language &apos; in request.GET ) : DCNL DCSP DCSP DCSP if check _ for _ language ( request.GET &#91; &apos; language &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP activate ( request.GET &#91; &apos; language &apos; &#93; ) DCNL DCSP if ( packages is None ) : DCNL DCSP DCSP packages = &#91; &apos; django.conf &apos; &#93; DCNL DCSP if isinstance ( packages , basestring ) : DCNL DCSP DCSP packages = packages.split ( &apos; + &apos; ) DCNL DCSP packages = &#91; p for p in packages if ( ( p = = &apos; django.conf &apos; ) or ( p in settings.INSTALLED _ APPS ) ) &#93; DCNL DCSP default _ locale = to _ locale ( settings.LANGUAGE _ CODE ) DCNL DCSP locale = to _ locale ( get _ language ( ) ) DCNL DCSP t = { } DCNL DCSP paths = &#91; &#93; DCNL DCSP en _ selected = locale.startswith ( &apos; en &apos; ) DCNL DCSP en _ catalog _ missing = True DCNL DCSP for package in packages : DCNL DCSP DCSP p = importlib.import _ module ( package ) DCNL DCSP DCSP path = os.path.join ( os.path.dirname ( p . _ _ file _ _ ) , &apos; locale &apos; ) DCNL DCSP DCSP paths.append ( path ) DCNL DCSP paths.extend ( list ( reversed ( settings.LOCALE _ PATHS ) ) ) DCNL DCSP for path in paths : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP catalog = gettext _ module.translation ( domain , path , &#91; &apos; en &apos; &#93; ) DCNL DCSP DCSP DCSP t.update ( catalog . _ catalog ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if en _ selected : DCNL DCSP DCSP DCSP DCSP en _ catalog _ missing = False DCNL DCSP if ( default _ locale ! = &apos; en &apos; ) : DCNL DCSP DCSP for path in paths : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP catalog = gettext _ module.translation ( domain , path , &#91; default _ locale &#93; ) DCNL DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP catalog = None DCNL DCSP DCSP DCSP if ( catalog is not None ) : DCNL DCSP DCSP DCSP DCSP t.update ( catalog . _ catalog ) DCNL DCSP if ( locale ! = default _ locale ) : DCNL DCSP DCSP if ( en _ selected and en _ catalog _ missing ) : DCNL DCSP DCSP DCSP t = { } DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP locale _ t = { } DCNL DCSP DCSP DCSP for path in paths : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP catalog = gettext _ module.translation ( domain , path , &#91; locale &#93; ) DCNL DCSP DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP DCSP catalog = None DCNL DCSP DCSP DCSP DCSP if ( catalog is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP locale _ t.update ( catalog . _ catalog ) DCNL DCSP DCSP DCSP if locale _ t : DCNL DCSP DCSP DCSP DCSP t = locale _ t DCNL DCSP src = &#91; LibHead &#93; DCNL DCSP plural = None DCNL DCSP if ( &apos; &apos; in t ) : DCNL DCSP DCSP for l in t &#91; &apos; &apos; &#93; .split ( &apos; \ n &apos; ) : DCNL DCSP DCSP DCSP if l.startswith ( &apos; Plural-Forms : &apos; ) : DCNL DCSP DCSP DCSP DCSP plural = l.split ( &apos; : &apos; , 1 ) &#91; 1 &#93; .strip ( ) DCNL DCSP if ( plural is not None ) : DCNL DCSP DCSP plural = &#91; el.strip ( ) for el in plural.split ( &apos; ; &apos; ) if el.strip ( ) .startswith ( &apos; plural = &apos; ) &#93; &#91; 0 &#93; .split ( &apos; = &apos; , 1 ) &#91; 1 &#93; DCNL DCSP DCSP src.append ( ( PluralIdx % plural ) ) DCNL DCSP else : DCNL DCSP DCSP src.append ( SimplePlural ) DCNL DCSP csrc = &#91; &#93; DCNL DCSP pdict = { } DCNL DCSP for ( k , v ) in t.items ( ) : DCNL DCSP DCSP if ( k = = &apos; &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if isinstance ( k , basestring ) : DCNL DCSP DCSP DCSP csrc.append ( ( &quot; catalog &#91; &apos; % s &apos; &#93; DCSP = DCSP &apos; % s &apos; ; \ n &quot; % ( javascript _ quote ( k ) , javascript _ quote ( v ) ) ) ) DCNL DCSP DCSP elif isinstance ( k , tuple ) : DCNL DCSP DCSP DCSP if ( k &#91; 0 &#93; not in pdict ) : DCNL DCSP DCSP DCSP DCSP pdict &#91; k &#91; 0 &#93; &#93; = k &#91; 1 &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP pdict &#91; k &#91; 0 &#93; &#93; = max ( k &#91; 1 &#93; , pdict &#91; k &#91; 0 &#93; &#93; ) DCNL DCSP DCSP DCSP csrc.append ( ( &quot; catalog &#91; &apos; % s &apos; &#93; &#91; % d &#93; DCSP = DCSP &apos; % s &apos; ; \ n &quot; % ( javascript _ quote ( k &#91; 0 &#93; ) , k &#91; 1 &#93; , javascript _ quote ( v ) ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise TypeError ( k ) DCNL DCSP csrc.sort ( ) DCNL DCSP for ( k , v ) in pdict.items ( ) : DCNL DCSP DCSP src.append ( ( &quot; catalog &#91; &apos; % s &apos; &#93; DCSP = DCSP &#91; % s &#93; ; \ n &quot; % ( javascript _ quote ( k ) , &apos; , &apos; .join ( ( &#91; &quot; &apos; &apos; &quot; &#93; * ( v + 1 ) ) ) ) ) ) DCNL DCSP src.extend ( csrc ) DCNL DCSP src.append ( LibFoot ) DCNL DCSP src.append ( InterPolate ) DCNL DCSP src.append ( LibFormatHead ) DCNL DCSP src.append ( get _ formats ( ) ) DCNL DCSP src.append ( LibFormatFoot ) DCNL DCSP src = &apos; &apos;.join ( src ) DCNL DCSP return http.HttpResponse ( src , &apos; text / javascript &apos; )
DCSP return serialize _ all ( &#91; node &#93; , stream , Dumper = Dumper , * * kwds )
DCSP result = defaultdict ( list ) DCNL DCSP for item in array : DCNL DCSP DCSP for ( key , value ) in item.items ( ) : DCNL DCSP DCSP DCSP result &#91; key &#93; + = ( value if isinstance ( value , list ) else &#91; value &#93; ) DCNL DCSP return result
DCSP global _ last _ prog DCNL DCSP sys.stdout.flush ( ) DCNL DCSP _ hard _ write ( sys.stderr.fileno ( ) , s ) DCNL DCSP _ last _ prog = 0
DCSP if ( resources is None ) : DCNL DCSP DCSP resources = { } DCNL DCSP return expr . _ subs ( { k : bz.data ( v , dshape = k.dshape ) for ( k , v ) in iteritems ( resources ) } )
DCSP print changelog _ as _ markdown ( )
DCSP ( i , j ) = np.mgrid &#91; ( -5 ) : 6 , ( -5 ) : 6 &#93; DCNL DCSP image = ( i &gt; = 0 ) .astype ( float ) DCNL DCSP result = filters.sobel _ h ( image ) DCNL DCSP i &#91; ( np.abs ( j ) = = 5 ) &#93; = 10000 DCNL DCSP assert np.all ( ( result &#91; ( i = = 0 ) &#93; = = 1 ) ) DCNL DCSP assert np.all ( ( result &#91; ( np.abs ( i ) &gt; 1 ) &#93; = = 0 ) )
DCSP try : DCNL DCSP DCSP return getattr ( typ , _ OTHER _ ENDIAN ) DCNL DCSP except AttributeError : DCNL DCSP DCSP if ( type ( typ ) = = _ array _ type ) : DCNL DCSP DCSP DCSP return ( _ other _ endian ( typ . _ type _ ) * typ . _ length _ ) DCNL DCSP DCSP raise TypeError ( ( &apos; This DCSP type DCSP does DCSP not DCSP support DCSP other DCSP endian : DCSP % s &apos; % typ ) )
DCSP if ( not isinstance ( shape , utils.INT _ TYPES ) ) : DCNL DCSP DCSP shape = shape &#91; : : ( -1 ) &#93; DCNL DCSP return carray ( ptr , shape , dtype ) .T
DCSP raise exceptions.MpdNotImplemented
DCSP v1 _ b = v1.astype ( bool ) DCNL DCSP v2 _ b = v2.astype ( bool ) DCNL DCSP sij = ( v1 _ b * v2 _ b ) .sum ( ) DCNL DCSP return ( ( v1 _ b.sum ( ) - sij ) * ( v2 _ b.sum ( ) - sij ) )
DCSP method = _ check _ method ( method ) DCNL DCSP pick _ ori = _ check _ ori ( pick _ ori ) DCNL DCSP ( power , plv , vertno ) = _ source _ induced _ power ( epochs , inverse _ operator , frequencies , label = label , lambda2 = lambda2 , method = method , nave = nave , n _ cycles = n _ cycles , decim = decim , use _ fft = use _ fft , pick _ ori = pick _ ori , pca = pca , n _ jobs = n _ jobs , prepared = False ) DCNL DCSP power = rescale ( power , epochs.times &#91; : : decim &#93; , baseline , baseline _ mode , copy = False ) DCNL DCSP return ( power , plv )
DCSP c = Container ( stream.read ( ) ) DCNL DCSP m = extract _ metadata ( c.decode ( ) ) DCNL DCSP def has ( x ) : DCNL DCSP DCSP return ( m &#91; x &#93; and m &#91; x &#93; &#91; 0 &#93; ) DCNL DCSP def get ( x , single = True ) : DCNL DCSP DCSP ans = m &#91; x &#93; DCNL DCSP DCSP if single : DCNL DCSP DCSP DCSP ans = ( clean _ xml _ chars ( ans &#91; 0 &#93; ) if ans else u &apos; &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ans = &#91; clean _ xml _ chars ( y ) for y in ans &#93; DCNL DCSP DCSP return ans DCNL DCSP title = ( get ( u &apos;title &apos; ) or _ ( u &apos;Unknown &apos; ) ) DCNL DCSP authors = ( get ( u &apos;authors &apos; , False ) or &#91; _ ( u &apos;Unknown &apos; ) &#93; ) DCNL DCSP auth _ pat = re.compile ( u &apos; ( &#91; ^ , &#93; + ? ) \ \ s * , \ \ s + ( &#91; ^ , &#93; + ) $ &apos; ) DCNL DCSP def fix _ author ( x ) : DCNL DCSP DCSP if ( tweaks &#91; u &apos;author _ sort _ copy _ method &apos; &#93; ! = u &apos;copy &apos; ) : DCNL DCSP DCSP DCSP m = auth _ pat.match ( x.strip ( ) ) DCNL DCSP DCSP DCSP if ( m is not None ) : DCNL DCSP DCSP DCSP DCSP return ( ( m.group ( 2 ) + u &apos; DCSP &apos; ) + m.group ( 1 ) ) DCNL DCSP DCSP return x DCNL DCSP mi = Metadata ( title , &#91; fix _ author ( x ) for x in authors &#93; ) DCNL DCSP if has ( u &apos;author &apos; ) : DCNL DCSP DCSP mi.author _ sort = get ( u &apos;author &apos; ) DCNL DCSP if has ( u &apos;ASIN &apos; ) : DCNL DCSP DCSP mi.set _ identifier ( u &apos;mobi-asin &apos; , get ( u &apos;ASIN &apos; ) ) DCNL DCSP elif has ( u &apos;content _ id &apos; ) : DCNL DCSP DCSP mi.set _ identifier ( u &apos;mobi-asin &apos; , get ( u &apos;content _ id &apos; ) ) DCNL DCSP if has ( u &apos;languages &apos; ) : DCNL DCSP DCSP langs = list ( filter ( None , ( canonicalize _ lang ( x ) for x in get ( u &apos;languages &apos; , False ) ) ) ) DCNL DCSP DCSP if langs : DCNL DCSP DCSP DCSP mi.languages = langs DCNL DCSP if has ( u &apos;issue _ date &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP mi.pubdate = parse _ only _ date ( get ( u &apos;issue _ date &apos; ) ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass DCNL DCSP if ( has ( u &apos;publisher &apos; ) and ( get ( u &apos;publisher &apos; ) ! = u &apos;Unknown &apos; ) ) : DCNL DCSP DCSP mi.publisher = get ( u &apos;publisher &apos; ) DCNL DCSP if ( read _ cover and m &#91; COVER _ KEY &#93; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = base64.standard _ b64decode ( m &#91; COVER _ KEY &#93; ) DCNL DCSP DCSP DCSP ( fmt , w , h ) = identify ( bytes ( data ) ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP ( w , h , fmt ) = ( 0 , 0 , None ) DCNL DCSP DCSP if ( fmt and ( w &gt; ( -1 ) ) and ( h &gt; ( -1 ) ) ) : DCNL DCSP DCSP DCSP mi.cover _ data = ( fmt , data ) DCNL DCSP return mi
DCSP if isinstance ( J , LinearOperator ) : DCNL DCSP DCSP return J.rmatvec ( f ) DCNL DCSP else : DCNL DCSP DCSP return J.T.dot ( f )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP secgroup _ info DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP if ( kwargs is None ) : DCNL DCSP DCSP kwargs = { } DCNL DCSP name = kwargs.get ( &apos; name &apos; , None ) DCNL DCSP secgroup _ id = kwargs.get ( &apos; secgroup _ id &apos; , None ) DCNL DCSP if secgroup _ id : DCNL DCSP DCSP if name : DCNL DCSP DCSP DCSP log.warning ( &quot; Both DCSP the DCSP &apos; secgroup _ id &apos; DCSP and DCSP &apos; name &apos; DCSP arguments DCSP were DCSP provided . DCSP &apos; secgroup _ id &apos; DCSP will DCSP take DCSP precedence . &quot; ) DCNL DCSP elif name : DCNL DCSP DCSP secgroup _ id = get _ secgroup _ id ( kwargs = { &apos; name &apos; : name } ) DCNL DCSP else : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP secgroup _ info DCSP function DCSP requires DCSP either DCSP a DCSP name DCSP or DCSP a DCSP secgroup _ id DCSP to DCSP be DCSP provided . &apos; ) DCNL DCSP ( server , user , password ) = _ get _ xml _ rpc ( ) DCNL DCSP auth = &apos; : &apos; .join ( &#91; user , password &#93; ) DCNL DCSP info = { } DCNL DCSP response = server.one.secgroup.info ( auth , int ( secgroup _ id ) ) &#91; 1 &#93; DCNL DCSP tree = _ get _ xml ( response ) DCNL DCSP info &#91; tree.find ( &apos; NAME &apos; ) .text &#93; = _ xml _ to _ dict ( tree ) DCNL DCSP return info
DCSP v = numpy.array ( vin , dtype = dtype ) DCNL DCSP m = ( w.imag &gt; 0 ) DCNL DCSP m &#91; : ( -1 ) &#93; &#124; = ( w.imag &#91; 1 : &#93; &lt; 0 ) DCNL DCSP for i in flatnonzero ( m ) : DCNL DCSP DCSP v.imag &#91; : , i &#93; = vin &#91; : , ( i + 1 ) &#93; DCNL DCSP DCSP conj ( v &#91; : , i &#93; , v &#91; : , ( i + 1 ) &#93; ) DCNL DCSP return v
DCSP s = array.array ( &apos; B &apos; , str ( s ) ) DCNL DCSP l = ( len ( s ) * 8 ) DCNL DCSP if ( n is None ) : DCNL DCSP DCSP n = max ( 1 , int ( ( l * p ) ) ) DCNL DCSP for i in random.sample ( xrange ( l ) , n ) : DCNL DCSP DCSP s &#91; ( i / 8 ) &#93; ^ = ( 1 &lt; &lt; ( i % 8 ) ) DCNL DCSP return s.tostring ( )
DCSP def check _ require _ module ( f ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ _ import _ _ ( module ) DCNL DCSP DCSP DCSP return f DCNL DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP def new _ f ( self , * args , * * kwargs ) : DCNL DCSP DCSP DCSP DCSP self.skipTest ( ( &apos; % s DCSP can DCSP not DCSP be DCSP imported . &apos; % module ) ) DCNL DCSP DCSP DCSP new _ f . _ _ name _ _ = f . _ _ name _ _ DCNL DCSP DCSP DCSP return new _ f DCNL DCSP return check _ require _ module
DCSP return bayesian _ info _ criterion ( ( ( ( -0.5 ) * n _ samples ) * np.log ( ( ssr / n _ samples ) ) ) , n _ params , n _ samples )
DCSP from google.appengine. _ internal.django.db.models import get _ model , get _ models DCNL DCSP model _ dependencies = &#91; &#93; DCNL DCSP models = set ( ) DCNL DCSP for ( app , model _ list ) in app _ list : DCNL DCSP DCSP if ( model _ list is None ) : DCNL DCSP DCSP DCSP model _ list = get _ models ( app ) DCNL DCSP DCSP for model in model _ list : DCNL DCSP DCSP DCSP models.add ( model ) DCNL DCSP DCSP DCSP if hasattr ( model , &apos; natural _ key &apos; ) : DCNL DCSP DCSP DCSP DCSP deps = getattr ( model.natural _ key , &apos; dependencies &apos; , &#91; &#93; ) DCNL DCSP DCSP DCSP DCSP if deps : DCNL DCSP DCSP DCSP DCSP DCSP deps = &#91; get _ model ( * d.split ( &apos; .&apos; ) ) for d in deps &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP deps = &#91; &#93; DCNL DCSP DCSP DCSP for field in model . _ meta.fields : DCNL DCSP DCSP DCSP DCSP if hasattr ( field.rel , &apos; to &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP rel _ model = field.rel.to DCNL DCSP DCSP DCSP DCSP DCSP if hasattr ( rel _ model , &apos; natural _ key &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP deps.append ( rel _ model ) DCNL DCSP DCSP DCSP for field in model . _ meta.many _ to _ many : DCNL DCSP DCSP DCSP DCSP rel _ model = field.rel.to DCNL DCSP DCSP DCSP DCSP if hasattr ( rel _ model , &apos; natural _ key &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP deps.append ( rel _ model ) DCNL DCSP DCSP DCSP model _ dependencies.append ( ( model , deps ) ) DCNL DCSP model _ dependencies.reverse ( ) DCNL DCSP model _ list = &#91; &#93; DCNL DCSP while model _ dependencies : DCNL DCSP DCSP skipped = &#91; &#93; DCNL DCSP DCSP changed = False DCNL DCSP DCSP while model _ dependencies : DCNL DCSP DCSP DCSP ( model , deps ) = model _ dependencies.pop ( ) DCNL DCSP DCSP DCSP found = True DCNL DCSP DCSP DCSP for candidate in ( ( ( d not in models ) or ( d in model _ list ) ) for d in deps ) : DCNL DCSP DCSP DCSP DCSP if ( not candidate ) : DCNL DCSP DCSP DCSP DCSP DCSP found = False DCNL DCSP DCSP DCSP if found : DCNL DCSP DCSP DCSP DCSP model _ list.append ( model ) DCNL DCSP DCSP DCSP DCSP changed = True DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP skipped.append ( ( model , deps ) ) DCNL DCSP DCSP if ( not changed ) : DCNL DCSP DCSP DCSP raise CommandError ( ( &quot; Can &apos;t DCSP resolve DCSP dependencies DCSP for DCSP % s DCSP in DCSP serialized DCSP app DCSP list . &quot; % &apos; , DCSP &apos; .join ( ( ( &apos; % s . % s &apos; % ( model . _ meta.app _ label , model . _ meta.object _ name ) ) for ( model , deps ) in sorted ( skipped , key = ( lambda obj : obj &#91; 0 &#93; . _ _ name _ _ ) ) ) ) ) ) DCNL DCSP DCSP model _ dependencies = skipped DCNL DCSP return model _ list
DCSP kDate = _ sign ( ( &apos; AWS4 &apos; + key ) .encode ( &apos; utf-8 &apos; ) , date _ stamp ) DCNL DCSP if regionName : DCNL DCSP DCSP kRegion = _ sign ( kDate , regionName ) DCNL DCSP DCSP kService = _ sign ( kRegion , serviceName ) DCNL DCSP else : DCNL DCSP DCSP kService = _ sign ( kDate , serviceName ) DCNL DCSP kSigning = _ sign ( kService , &apos; aws4 _ request &apos; ) DCNL DCSP return kSigning
DCSP result = copy.deepcopy ( parameters ) DCNL DCSP for parameter in secret _ parameters : DCNL DCSP DCSP if ( parameter in result ) : DCNL DCSP DCSP DCSP result &#91; parameter &#93; = MASKED _ ATTRIBUTE _ VALUE DCNL DCSP return result
DCSP conn = boto.connect _ ec2 ( u &apos;the _ key &apos; , u &apos;the _ secret &apos; ) DCNL DCSP with assert _ raises ( EC2ResponseError ) as cm : DCNL DCSP DCSP conn.release _ address ( allocation _ id = u &apos;bogus &apos; ) DCNL DCSP cm.exception.code.should.equal ( u &apos;InvalidAllocationID.NotFound &apos; ) DCNL DCSP cm.exception.status.should.equal ( 400 ) DCNL DCSP cm.exception.request _ id.should _ not.be.none
DCSP if isinstance ( value , integer _ types ) : DCNL DCSP DCSP return value DCNL DCSP elif isinstance ( value , string _ type ) : DCNL DCSP DCSP if value.isdigit ( ) : DCNL DCSP DCSP DCSP return int ( value ) DCNL DCSP DCSP return value DCNL DCSP raise TypeError ( ( &apos; Wrong DCSP type DCSP for DCSP % s , DCSP value DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP a DCSP string &apos; % ( option , ) ) )
DCSP css _ filepath = settings.NOTIFICATION _ EMAIL _ CSS DCNL DCSP if ( not css _ filepath.startswith ( &apos; / &apos; ) ) : DCNL DCSP DCSP css _ filepath = file _ path _ finder ( settings.NOTIFICATION _ EMAIL _ CSS ) DCNL DCSP if css _ filepath : DCNL DCSP DCSP with open ( css _ filepath , &apos; r &apos; ) as _ file : DCNL DCSP DCSP DCSP css _ content = _ file.read ( ) DCNL DCSP DCSP html _ with _ inline _ css = pynliner.fromString ( ( ( ( &apos; &lt; style &gt; &apos; + css _ content ) + &apos; &lt; / style &gt; &apos; ) + html _ without _ css ) ) DCNL DCSP DCSP return html _ with _ inline _ css DCNL DCSP return html _ without _ css
DCSP from beets.autotag.hooks import Distance DCNL DCSP dist = Distance ( ) DCNL DCSP for plugin in find _ plugins ( ) : DCNL DCSP DCSP dist.update ( plugin.track _ distance ( item , info ) ) DCNL DCSP return dist
DCSP if ( ( not isinstance ( pid , int ) ) or ( pid &lt; 0 ) ) : DCNL DCSP DCSP return None DCNL DCSP if stem.util.proc.is _ available ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP import pwd DCNL DCSP DCSP DCSP uid = stem.util.proc.uid ( pid ) DCNL DCSP DCSP DCSP if ( uid and uid.isdigit ( ) ) : DCNL DCSP DCSP DCSP DCSP return pwd.getpwuid ( int ( uid ) ) .pw _ name DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP if is _ available ( &apos; ps &apos; ) : DCNL DCSP DCSP results = call ( ( &apos; ps DCSP -o DCSP user DCSP % s &apos; % pid ) , &#91; &#93; ) DCNL DCSP DCSP if ( len ( results ) &gt; = 2 ) : DCNL DCSP DCSP DCSP return results &#91; 1 &#93; .strip ( ) DCNL DCSP return None
DCSP vertices = &#91; 100960 , 7620 , 150549 , 96761 &#93; DCNL DCSP coords = np.array ( &#91; &#91; ( -60.86 ) , ( -11.18 ) , ( -3.19 ) &#93; , &#91; ( -36.46 ) , ( -93.18 ) , ( -2.36 ) &#93; , &#91; ( -38.0 ) , 50.08 , ( -10.61 ) &#93; , &#91; 47.14 , 8.01 , 46.93 &#93; &#93; ) DCNL DCSP hemis = &#91; 0 , 0 , 0 , 1 &#93; DCNL DCSP coords _ 2 = vertex _ to _ mni ( vertices , hemis , &apos; sample &apos; , subjects _ dir ) DCNL DCSP assert _ allclose ( coords , coords _ 2 , atol = 1.0 )
DCSP password = DATABASES &#91; name &#93; .PASSWORD.get ( ) DCNL DCSP if ( not password ) : DCNL DCSP DCSP password = DATABASES &#91; name &#93; .PASSWORD _ SCRIPT.get ( ) DCNL DCSP return password
DCSP dtnow = datetime.datetime.now ( ) DCNL DCSP dtutcnow = datetime.datetime.utcnow ( ) DCNL DCSP delta = ( dtnow - dtutcnow ) DCNL DCSP ( newhour , newmin ) = divmod ( ( ( ( ( ( ( delta.days * 24 ) * 60 ) * 60 ) + delta.seconds ) + 30 ) / / 60 ) , 60 ) DCNL DCSP newtime = ( &apos; % s % + 02d : % 02d &apos; % ( dtnow.isoformat ( ) , newhour , newmin ) ) DCNL DCSP custom _ data = { &apos; issuedAt &apos; : newtime , &apos; consumerKey &apos; : secret , &apos; userId &apos; : userid , &apos; ttl &apos; : 86400 } DCNL DCSP newtoken = create _ token ( secret , custom _ data ) DCNL DCSP return newtoken
DCSP tempdir = _ TempDir ( ) DCNL DCSP rng = np.random.RandomState ( 0 ) DCNL DCSP for preload in &#91; False , True , &apos; memmap.dat &apos; &#93; : DCNL DCSP DCSP raw = read _ raw _ fif ( fif _ fname , preload = preload ) DCNL DCSP DCSP nsamp = ( ( raw.last _ samp - raw.first _ samp ) + 1 ) DCNL DCSP DCSP picks = pick _ types ( raw.info , meg = &apos; grad &apos; , exclude = &apos; bads &apos; ) DCNL DCSP DCSP data = rng.randn ( len ( picks ) , ( nsamp / / 2 ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP raw &#91; picks , : ( nsamp / / 2 ) &#93; = data DCNL DCSP DCSP except RuntimeError as err : DCNL DCSP DCSP DCSP if ( not preload ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise err DCNL DCSP DCSP tmp _ fname = op.join ( tempdir , &apos; raw.fif &apos; ) DCNL DCSP DCSP raw.save ( tmp _ fname , overwrite = True ) DCNL DCSP DCSP raw _ new = read _ raw _ fif ( tmp _ fname ) DCNL DCSP DCSP ( data _ new , _ ) = raw _ new &#91; picks , : ( nsamp / 2 ) &#93; DCNL DCSP DCSP assert _ allclose ( data , data _ new )
DCSP with open ( ( &apos; tests / components / media _ player / yamaha _ samples / % s &apos; % name ) , encoding = &apos; utf-8 &apos; ) as content : DCNL DCSP DCSP return content.read ( )
DCSP if ( resp &#91; : 3 &#93; ! = &apos; 229 &apos; ) : DCNL DCSP DCSP raise error _ reply ( resp ) DCNL DCSP left = resp.find ( &apos; ( &apos; ) DCNL DCSP if ( left &lt; 0 ) : DCNL DCSP DCSP raise error _ proto ( resp ) DCNL DCSP right = resp.find ( &apos; ) &apos; , ( left + 1 ) ) DCNL DCSP if ( right &lt; 0 ) : DCNL DCSP DCSP raise error _ proto ( resp ) DCNL DCSP if ( resp &#91; ( left + 1 ) &#93; ! = resp &#91; ( right - 1 ) &#93; ) : DCNL DCSP DCSP raise error _ proto ( resp ) DCNL DCSP parts = resp &#91; ( left + 1 ) : right &#93; .split ( resp &#91; ( left + 1 ) &#93; ) DCNL DCSP if ( len ( parts ) ! = 5 ) : DCNL DCSP DCSP raise error _ proto ( resp ) DCNL DCSP host = peer &#91; 0 &#93; DCNL DCSP port = int ( parts &#91; 3 &#93; ) DCNL DCSP return ( host , port )
DCSP client = _ _ utils _ _ &#91; &apos; etcd _ util.get _ conn &apos; &#93; ( _ _ opts _ _ , profile ) DCNL DCSP return client.set ( key , value , ttl = ttl , directory = directory )
DCSP unit = get _ object _ or _ 404 ( Unit , pk = pk ) DCNL DCSP unit.check _ acl ( request ) DCNL DCSP if ( not can _ add _ comment ( request.user , unit.translation.subproject.project ) ) : DCNL DCSP DCSP raise PermissionDenied ( ) DCNL DCSP form = CommentForm ( request.POST ) DCNL DCSP if form.is _ valid ( ) : DCNL DCSP DCSP if ( form.cleaned _ data &#91; u &apos;scope &apos; &#93; = = u &apos;global &apos; ) : DCNL DCSP DCSP DCSP lang = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP lang = unit.translation.language DCNL DCSP DCSP Comment.objects.add ( unit , request.user , lang , form.cleaned _ data &#91; u &apos;comment &apos; &#93; ) DCNL DCSP DCSP messages.success ( request , _ ( u &apos;Posted DCSP new DCSP comment &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP messages.error ( request , _ ( u &apos;Failed DCSP to DCSP add DCSP comment ! &apos; ) ) DCNL DCSP return redirect ( request.POST.get ( u &apos;next &apos; , unit ) )
DCSP floatListLists = &#91; &#93; DCNL DCSP for path in paths : DCNL DCSP DCSP floatListList = &#91; &#93; DCNL DCSP DCSP for point in path : DCNL DCSP DCSP DCSP floatListList.append ( point.getFloatList ( ) ) DCNL DCSP return floatListLists
DCSP trace _ fh = open ( os.path.join ( expt _ dir , &apos; trace.csv &apos; ) , &apos; a &apos; ) DCNL DCSP trace _ fh.write ( ( &apos; % d , % f , % d , % d , % d , % d \ n &apos; % ( time.time ( ) , best _ val , best _ job , n _ candidates , n _ pending , n _ complete ) ) ) DCNL DCSP trace _ fh.close ( )
DCSP candidates = { } DCNL DCSP trackid = ( search _ id or item.mb _ trackid ) DCNL DCSP if trackid : DCNL DCSP DCSP log.debug ( u &apos;Searching DCSP for DCSP track DCSP ID : DCSP { 0 } &apos; .format ( trackid ) ) DCNL DCSP DCSP for track _ info in hooks.tracks _ for _ id ( trackid ) : DCNL DCSP DCSP DCSP dist = track _ distance ( item , track _ info , incl _ artist = True ) DCNL DCSP DCSP DCSP candidates &#91; track _ info.track _ id &#93; = hooks.TrackMatch ( dist , track _ info ) DCNL DCSP DCSP DCSP rec = _ recommendation ( candidates.values ( ) ) DCNL DCSP DCSP DCSP if ( ( rec = = Recommendation.strong ) and ( not config &#91; &apos; import &apos; &#93; &#91; &apos; timid &apos; &#93; ) ) : DCNL DCSP DCSP DCSP DCSP log.debug ( u &apos;Track DCSP ID DCSP match . &apos; ) DCNL DCSP DCSP DCSP DCSP return ( candidates.values ( ) , rec ) DCNL DCSP if ( search _ id is not None ) : DCNL DCSP DCSP if candidates : DCNL DCSP DCSP DCSP return ( candidates.values ( ) , rec ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( &#91; &#93; , Recommendation.none ) DCNL DCSP if ( not ( search _ artist and search _ title ) ) : DCNL DCSP DCSP ( search _ artist , search _ title ) = ( item.artist , item.title ) DCNL DCSP log.debug ( u &apos;Item DCSP search DCSP terms : DCSP { 0 } DCSP - DCSP { 1 } &apos; .format ( search _ artist , search _ title ) ) DCNL DCSP for track _ info in hooks.item _ candidates ( item , search _ artist , search _ title ) : DCNL DCSP DCSP dist = track _ distance ( item , track _ info , incl _ artist = True ) DCNL DCSP DCSP candidates &#91; track _ info.track _ id &#93; = hooks.TrackMatch ( dist , track _ info ) DCNL DCSP log.debug ( u &apos;Found DCSP { 0 } DCSP candidates . &apos; .format ( len ( candidates ) ) ) DCNL DCSP candidates = sorted ( candidates.itervalues ( ) ) DCNL DCSP rec = _ recommendation ( candidates ) DCNL DCSP return ( candidates , rec )
DCSP ctx.verbose = verbose DCNL DCSP if ( home is not None ) : DCNL DCSP DCSP ctx.home = home
DCSP if ( len ( sys.argv ) &gt; 1 ) : DCNL DCSP DCSP writeOutput ( &apos; DCSP &apos; .join ( sys.argv &#91; 1 : &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP settings.startMainLoopFromConstructor ( getNewRepository ( ) )
DCSP global _ ENGINE DCNL DCSP if ( _ ENGINE is None ) : DCNL DCSP DCSP _ ENGINE = nova _ session.create _ engine ( CONF.baremetal.sql _ connection ) DCNL DCSP return _ ENGINE
DCSP return dict ( &#91; ( value , key ) for ( key , value ) in mapping.iteritems ( ) &#93; )
DCSP return ( ( ( y _ true - y _ pred ) * * 2 ) .mean ( ) / 2 )
DCSP end _ tag _ bytes = encoder.TagBytes ( field _ number , wire _ format.WIRETYPE _ END _ GROUP ) DCNL DCSP end _ tag _ len = len ( end _ tag _ bytes ) DCNL DCSP assert ( not is _ packed ) DCNL DCSP if is _ repeated : DCNL DCSP DCSP tag _ bytes = encoder.TagBytes ( field _ number , wire _ format.WIRETYPE _ START _ GROUP ) DCNL DCSP DCSP tag _ len = len ( tag _ bytes ) DCNL DCSP DCSP def DecodeRepeatedField ( buffer , pos , end , message , field _ dict ) : DCNL DCSP DCSP DCSP value = field _ dict.get ( key ) DCNL DCSP DCSP DCSP if ( value is None ) : DCNL DCSP DCSP DCSP DCSP value = field _ dict.setdefault ( key , new _ default ( message ) ) DCNL DCSP DCSP DCSP while 1 : DCNL DCSP DCSP DCSP DCSP value = field _ dict.get ( key ) DCNL DCSP DCSP DCSP DCSP if ( value is None ) : DCNL DCSP DCSP DCSP DCSP DCSP value = field _ dict.setdefault ( key , new _ default ( message ) ) DCNL DCSP DCSP DCSP DCSP pos = value.add ( ) . _ InternalParse ( buffer , pos , end ) DCNL DCSP DCSP DCSP DCSP new _ pos = ( pos + end _ tag _ len ) DCNL DCSP DCSP DCSP DCSP if ( ( buffer &#91; pos : new _ pos &#93; ! = end _ tag _ bytes ) or ( new _ pos &gt; end ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise _ DecodeError ( &apos; Missing DCSP group DCSP end DCSP tag . &apos; ) DCNL DCSP DCSP DCSP DCSP pos = ( new _ pos + tag _ len ) DCNL DCSP DCSP DCSP DCSP if ( ( buffer &#91; new _ pos : pos &#93; ! = tag _ bytes ) or ( new _ pos = = end ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return new _ pos DCNL DCSP DCSP return DecodeRepeatedField DCNL DCSP else : DCNL DCSP DCSP def DecodeField ( buffer , pos , end , message , field _ dict ) : DCNL DCSP DCSP DCSP value = field _ dict.get ( key ) DCNL DCSP DCSP DCSP if ( value is None ) : DCNL DCSP DCSP DCSP DCSP value = field _ dict.setdefault ( key , new _ default ( message ) ) DCNL DCSP DCSP DCSP pos = value . _ InternalParse ( buffer , pos , end ) DCNL DCSP DCSP DCSP new _ pos = ( pos + end _ tag _ len ) DCNL DCSP DCSP DCSP if ( ( buffer &#91; pos : new _ pos &#93; ! = end _ tag _ bytes ) or ( new _ pos &gt; end ) ) : DCNL DCSP DCSP DCSP DCSP raise _ DecodeError ( &apos; Missing DCSP group DCSP end DCSP tag . &apos; ) DCNL DCSP DCSP DCSP return new _ pos DCNL DCSP DCSP return DecodeField
DCSP return host _ reference.config.network.pnic
DCSP return getJoinedPath ( getGeometryUtilitiesPath ( &apos; evaluate _ fundamentals &apos; ) , subName )
DCSP ( p , u ) = getparser ( use _ datetime = use _ datetime ) DCNL DCSP p.feed ( data ) DCNL DCSP p.close ( ) DCNL DCSP return ( u.close ( ) , u.getmethodname ( ) )
DCSP hash _ digest = hashlib.md5 ( code.encode ( &apos; utf-8 &apos; ) ) .hexdigest ( ) DCNL DCSP return &apos; &lt; ipython-input- { 0 } - { 1 } &gt; &apos; .format ( number , hash _ digest &#91; : 12 &#93; )
DCSP return _ escapeme _ re.sub ( _ percentEscapeUnicode , iri )
DCSP ret = &apos; &apos; DCNL DCSP i = packed = 0 DCNL DCSP for bit in bits : DCNL DCSP DCSP if bit : DCNL DCSP DCSP DCSP packed + = 128 DCNL DCSP DCSP i + = 1 DCNL DCSP DCSP if ( i = = 8 ) : DCNL DCSP DCSP DCSP ret + = chr ( packed ) DCNL DCSP DCSP DCSP i = packed = 0 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP packed &gt; &gt; = 1 DCNL DCSP if ( ( i &gt; 0 ) and ( i &lt; 8 ) ) : DCNL DCSP DCSP packed &gt; &gt; = ( 7 - i ) DCNL DCSP DCSP ret + = chr ( packed ) DCNL DCSP return ret
DCSP ( islink , join , isdir ) = ( os.path.islink , os.path.join , os.path.isdir ) DCNL DCSP if ( _ seen is None ) : DCNL DCSP DCSP _ seen = set ( ) DCNL DCSP try : DCNL DCSP DCSP names = os.listdir ( top ) DCNL DCSP except os.error as err : DCNL DCSP DCSP if ( onerror is not None ) : DCNL DCSP DCSP DCSP onerror ( err ) DCNL DCSP DCSP return DCNL DCSP if followlinks : DCNL DCSP DCSP status = os.stat ( top ) DCNL DCSP DCSP if ( status.st _ ino ! = 0 ) : DCNL DCSP DCSP DCSP node = ( status.st _ dev , status.st _ ino ) DCNL DCSP DCSP DCSP if ( node in _ seen ) : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP _ seen.add ( node ) DCNL DCSP ( dirs , nondirs ) = ( &#91; &#93; , &#91; &#93; ) DCNL DCSP for name in names : DCNL DCSP DCSP full _ path = join ( top , name ) DCNL DCSP DCSP if isdir ( full _ path ) : DCNL DCSP DCSP DCSP dirs.append ( name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP nondirs.append ( name ) DCNL DCSP if topdown : DCNL DCSP DCSP ( yield ( top , dirs , nondirs ) ) DCNL DCSP for name in dirs : DCNL DCSP DCSP new _ path = join ( top , name ) DCNL DCSP DCSP if ( followlinks or ( not islink ( new _ path ) ) ) : DCNL DCSP DCSP DCSP for x in safe _ walk ( new _ path , topdown , onerror , followlinks , _ seen ) : DCNL DCSP DCSP DCSP DCSP ( yield x ) DCNL DCSP if ( not topdown ) : DCNL DCSP DCSP ( yield ( top , dirs , nondirs ) )
DCSP mod = sys.modules &#91; ( &apos; pgi.repository. &apos; + namespace ) &#93; DCNL DCSP return getattr ( mod , &apos; _ introspection _ module &apos; , mod )
DCSP cytypes = map ( ( lambda x : CY _ TYPES &#91; x &#93; ) , codes ) DCNL DCSP name = ( codes + &apos; _ number _ t &apos; ) DCNL DCSP declaration = &#91; ( ( &apos; ctypedef DCSP fused DCSP &apos; + name ) + &apos; : &apos; ) &#93; DCNL DCSP for cytype in cytypes : DCNL DCSP DCSP declaration.append ( ( &apos; DCSP DCSP DCSP DCSP &apos; + cytype ) ) DCNL DCSP declaration = &apos; \ n &apos; .join ( declaration ) DCNL DCSP return ( name , declaration )
DCSP return conesearch ( * args , * * kwargs )
DCSP if isinstance ( x , STRING _ TYPES ) : DCNL DCSP DCSP return to _ unicode ( x ) DCNL DCSP try : DCNL DCSP DCSP l = list ( x ) DCNL DCSP except TypeError as e : DCNL DCSP DCSP assert ( &apos; is DCSP not DCSP iterable &apos; in str ( e ) ) DCNL DCSP DCSP return x DCNL DCSP else : DCNL DCSP DCSP return &#91; to _ unicode ( e ) for e in l &#93;
DCSP with pytest.raises ( TypeError ) as excinfo : DCNL DCSP DCSP hist &#91; 0 &#93; = &apos; foo &apos; DCNL DCSP expected = &quot; &apos; History &apos; DCSP object DCSP does DCSP not DCSP support DCSP item DCSP assignment &quot; DCNL DCSP assert ( str ( excinfo.value ) = = expected )
DCSP python _ shell = _ python _ shell _ default ( python _ shell , kwargs.get ( &apos; _ _ pub _ jid &apos; , &apos; &apos; ) ) DCNL DCSP res = _ run ( cmd , stdin = None , stderr = None , stdout = None , output _ loglevel = output _ loglevel , use _ vt = None , bg = True , with _ communicate = False , rstrip = False , runas = runas , shell = shell , python _ shell = python _ shell , cwd = cwd , env = env , clean _ env = clean _ env , template = template , umask = umask , log _ callback = log _ callback , timeout = timeout , reset _ system _ locale = reset _ system _ locale , ignore _ retcode = ignore _ retcode , saltenv = saltenv , password = password , * * kwargs ) DCNL DCSP return { &apos; pid &apos; : res &#91; &apos; pid &apos; &#93; }
DCSP def decorator ( func ) : DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP mock _ action = mock.MagicMock ( ) DCNL DCSP DCSP DCSP from ckan.logic import get _ action as original _ get _ action DCNL DCSP DCSP DCSP def side _ effect ( called _ action _ name ) : DCNL DCSP DCSP DCSP DCSP if ( called _ action _ name = = action _ name ) : DCNL DCSP DCSP DCSP DCSP DCSP return mock _ action DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return original _ get _ action ( called _ action _ name ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP with mock.patch ( &apos; ckan.logic.get _ action &apos; ) as mock _ get _ action : DCNL DCSP DCSP DCSP DCSP DCSP with mock.patch ( &apos; ckan.plugins.toolkit.get _ action &apos; ) as mock _ get _ action _ toolkit : DCNL DCSP DCSP DCSP DCSP DCSP DCSP mock _ get _ action.side _ effect = side _ effect DCNL DCSP DCSP DCSP DCSP DCSP DCSP mock _ get _ action _ toolkit.side _ effect = side _ effect DCNL DCSP DCSP DCSP DCSP DCSP DCSP new _ args = ( args + tuple ( &#91; mock _ action &#93; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return _ value = func ( * new _ args , * * kwargs ) DCNL DCSP DCSP DCSP finally : DCNL DCSP DCSP DCSP DCSP mock _ action.stop ( ) DCNL DCSP DCSP DCSP return return _ value DCNL DCSP DCSP return nose.tools.make _ decorator ( func ) ( wrapper ) DCNL DCSP return decorator
DCSP if schema _ exists ( dbname , name , db _ user = db _ user , db _ password = db _ password , db _ host = db _ host , db _ port = db _ port ) : DCNL DCSP DCSP log.info ( &quot; &apos; { 0 } &apos; DCSP already DCSP exists DCSP in DCSP &apos; { 1 } &apos; &quot; .format ( name , dbname ) ) DCNL DCSP DCSP return False DCNL DCSP sub _ cmd = &apos; CREATE DCSP SCHEMA DCSP &quot; { 0 } &quot; &apos; .format ( name ) DCNL DCSP if ( owner is not None ) : DCNL DCSP DCSP sub _ cmd = &apos; { 0 } DCSP AUTHORIZATION DCSP &quot; { 1 } &quot; &apos; .format ( sub _ cmd , owner ) DCNL DCSP ret = _ psql _ prepare _ and _ run ( &#91; &apos; -c &apos; , sub _ cmd &#93; , user = db _ user , password = db _ password , port = db _ port , host = db _ host , maintenance _ db = dbname , runas = user ) DCNL DCSP return ( ret &#91; &apos; retcode &apos; &#93; = = 0 )
DCSP return is _ valid _ circuit _ id ( entry )
DCSP return &apos; &apos;.join ( ( random.SystemRandom ( ) .choice ( ( string.ascii _ uppercase + string.digits ) ) for _ in range ( N ) ) )
DCSP def join _ string _ lambda ( value ) : DCNL DCSP DCSP return delimeter.join ( value ) DCNL DCSP return join _ string _ lambda
DCSP return _ EllipticCurve . _ get _ elliptic _ curves ( _ lib )
DCSP if ( not hasattr ( Fileobj , &apos; read &apos; ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Fileobj DCSP must DCSP implement DCSP read &apos; ) DCNL DCSP subscribers = None DCNL DCSP if ( Callback is not None ) : DCNL DCSP DCSP subscribers = &#91; ProgressCallbackInvoker ( Callback ) &#93; DCNL DCSP config = Config DCNL DCSP if ( config is None ) : DCNL DCSP DCSP config = TransferConfig ( ) DCNL DCSP with create _ transfer _ manager ( self , config ) as manager : DCNL DCSP DCSP future = manager.upload ( fileobj = Fileobj , bucket = Bucket , key = Key , extra _ args = ExtraArgs , subscribers = subscribers ) DCNL DCSP DCSP return future.result ( )
DCSP _ runtime.reset ( )
DCSP if isinstance ( value , int ) : DCNL DCSP DCSP value = str ( value ) DCNL DCSP value = _ re _ amp.sub ( &apos; &amp; amp ; &apos; , value ) DCNL DCSP value = value.replace ( &apos; &quot; &apos; , &apos; &amp; quot ; &apos; ) .replace ( &quot; &apos; &quot; , &apos; &amp; apos ; &apos; ) DCNL DCSP value = value.replace ( &apos; &lt; &apos; , &apos; &amp; lt ; &apos; ) .replace ( &apos; &gt; &apos; , &apos; &amp; gt ; &apos; ) DCNL DCSP if isinstance ( value , unicode ) : DCNL DCSP DCSP value = value.encode ( &apos; ascii &apos; , &apos; xmlcharrefreplace &apos; ) DCNL DCSP return value
DCSP if ( path is None ) : DCNL DCSP DCSP path = ( global _ conf.get ( &apos; path &apos; ) or global _ conf.get ( &apos; PATH &apos; ) ) DCNL DCSP include _ os _ environ = converters.asbool ( include _ os _ environ ) DCNL DCSP return CGIApplication ( None , script , path = path , include _ os _ environ = include _ os _ environ , query _ string = query _ string )
DCSP return _ _ salt _ _ &#91; &apos; lowpkg.owner &apos; &#93; ( * paths )
DCSP locks = data DCNL DCSP if locks : DCNL DCSP DCSP lw = XML.SubElement ( xml _ parent , &apos; hudson.plugins.locksandlatches.LockWrapper &apos; ) DCNL DCSP DCSP locktop = XML.SubElement ( lw , &apos; locks &apos; ) DCNL DCSP DCSP for lock in locks : DCNL DCSP DCSP DCSP lockwrapper = XML.SubElement ( locktop , &apos; hudson.plugins.locksandlatches.LockWrapper _ -LockWaitConfig &apos; ) DCNL DCSP DCSP DCSP XML.SubElement ( lockwrapper , &apos; name &apos; ) .text = lock
DCSP def check ( ch ) : DCNL DCSP DCSP return result _ exceptions.get ( ch , ch ) DCNL DCSP ent = match.group ( 1 ) DCNL DCSP if ( ent in exceptions ) : DCNL DCSP DCSP return ( ( &apos; &amp; &apos; + ent ) + &apos; ; &apos; ) DCNL DCSP if ( ent in { &apos; apos &apos; , &apos; squot &apos; } ) : DCNL DCSP DCSP return check ( &quot; &apos; &quot; ) DCNL DCSP if ( ent = = &apos; hellips &apos; ) : DCNL DCSP DCSP ent = &apos; hellip &apos; DCNL DCSP if ent.startswith ( &apos; # &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( ent &#91; 1 &#93; in ( &apos; x &apos; , &apos; X &apos; ) ) : DCNL DCSP DCSP DCSP DCSP num = int ( ent &#91; 2 : &#93; , 16 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP num = int ( ent &#91; 1 : &#93; ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return ( ( &apos; &amp; &apos; + ent ) + &apos; ; &apos; ) DCNL DCSP DCSP if ( ( encoding is None ) or ( num &gt; 255 ) ) : DCNL DCSP DCSP DCSP return check ( my _ unichr ( num ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return check ( chr ( num ) .decode ( encoding ) ) DCNL DCSP DCSP except UnicodeDecodeError : DCNL DCSP DCSP DCSP return check ( my _ unichr ( num ) ) DCNL DCSP from calibre.ebooks.html _ entities import html5 _ entities DCNL DCSP try : DCNL DCSP DCSP return check ( html5 _ entities &#91; ent &#93; ) DCNL DCSP except KeyError : DCNL DCSP DCSP pass DCNL DCSP from htmlentitydefs import name2codepoint DCNL DCSP try : DCNL DCSP DCSP return check ( my _ unichr ( name2codepoint &#91; ent &#93; ) ) DCNL DCSP except KeyError : DCNL DCSP DCSP return ( ( &apos; &amp; &apos; + ent ) + &apos; ; &apos; )
DCSP e = e.rewrite ( &apos; tractable &apos; , deep = True ) DCNL DCSP if ( not e.has ( x ) ) : DCNL DCSP DCSP return e DCNL DCSP if e.has ( Order ) : DCNL DCSP DCSP e = e.expand ( ) .removeO ( ) DCNL DCSP if ( not x.is _ positive ) : DCNL DCSP DCSP p = Dummy ( &apos; p &apos; , positive = True , finite = True ) DCNL DCSP DCSP e = e.subs ( x , p ) DCNL DCSP DCSP x = p DCNL DCSP ( c0 , e0 ) = mrv _ leadterm ( e , x ) DCNL DCSP sig = sign ( e0 , x ) DCNL DCSP if ( sig = = 1 ) : DCNL DCSP DCSP return S.Zero DCNL DCSP elif ( sig = = ( -1 ) ) : DCNL DCSP DCSP if c0.match ( ( I * Wild ( &apos; a &apos; , exclude = &#91; I &#93; ) ) ) : DCNL DCSP DCSP DCSP return ( c0 * oo ) DCNL DCSP DCSP s = sign ( c0 , x ) DCNL DCSP DCSP if ( s = = 0 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Leading DCSP term DCSP should DCSP not DCSP be DCSP 0 &apos; ) DCNL DCSP DCSP return ( s * oo ) DCNL DCSP elif ( sig = = 0 ) : DCNL DCSP DCSP return limitinf ( c0 , x )
DCSP print ( &apos; got DCSP perspective1 DCSP ref : &apos; , perspective ) DCNL DCSP print ( &apos; asking DCSP it DCSP to DCSP foo ( 13 ) &apos; ) DCNL DCSP return perspective.callRemote ( &apos; foo &apos; , 13 )
DCSP if ( not delta ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP if ( end _ date and ( start _ date &gt; end _ date ) ) : DCNL DCSP DCSP raise Exception ( u &apos;Wait . DCSP start _ date DCSP needs DCSP to DCSP be DCSP before DCSP end _ date &apos; ) DCNL DCSP if ( end _ date and num ) : DCNL DCSP DCSP raise Exception ( u &apos;Wait . DCSP Either DCSP specify DCSP end _ date DCSP OR DCSP num &apos; ) DCNL DCSP if ( ( not end _ date ) and ( not num ) ) : DCNL DCSP DCSP end _ date = datetime.now ( ) DCNL DCSP delta _ iscron = False DCNL DCSP if isinstance ( delta , six.string _ types ) : DCNL DCSP DCSP delta _ iscron = True DCNL DCSP DCSP cron = croniter ( delta , start _ date ) DCNL DCSP elif isinstance ( delta , timedelta ) : DCNL DCSP DCSP delta = abs ( delta ) DCNL DCSP l = &#91; &#93; DCNL DCSP if end _ date : DCNL DCSP DCSP while ( start _ date &lt; = end _ date ) : DCNL DCSP DCSP DCSP l.append ( start _ date ) DCNL DCSP DCSP DCSP if delta _ iscron : DCNL DCSP DCSP DCSP DCSP start _ date = cron.get _ next ( datetime ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP start _ date + = delta DCNL DCSP else : DCNL DCSP DCSP for i in range ( abs ( num ) ) : DCNL DCSP DCSP DCSP l.append ( start _ date ) DCNL DCSP DCSP DCSP if delta _ iscron : DCNL DCSP DCSP DCSP DCSP if ( num &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP start _ date = cron.get _ next ( datetime ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP start _ date = cron.get _ prev ( datetime ) DCNL DCSP DCSP DCSP elif ( num &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP start _ date + = delta DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP start _ date - = delta DCNL DCSP return sorted ( l )
DCSP from pyamf import xml DCNL DCSP return xml.set _ default _ interface ( etree )
DCSP logger.info ( &apos; Trying DCSP to DCSP create DCSP pull _ queue _ tasks &apos; ) DCNL DCSP create _ table = &apos; \ n DCSP DCSP DCSP DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull _ queue _ tasks DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP app DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP queue DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP id DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP payload DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP enqueued DCSP timestamp , \ n DCSP DCSP DCSP DCSP DCSP DCSP lease _ expires DCSP timestamp , \ n DCSP DCSP DCSP DCSP DCSP DCSP retry _ count DCSP int , \ n DCSP DCSP DCSP DCSP DCSP DCSP tag DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( ( app , DCSP queue , DCSP id ) ) \ n DCSP DCSP DCSP DCSP ) \ n DCSP DCSP &apos; DCNL DCSP statement = SimpleStatement ( create _ table , retry _ policy = NO _ RETRIES ) DCNL DCSP try : DCNL DCSP DCSP session.execute ( statement ) DCNL DCSP except OperationTimedOut : DCNL DCSP DCSP logger.warning ( &apos; Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull _ queue _ tasks . DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle . &apos; ) DCNL DCSP DCSP time.sleep ( 60 ) DCNL DCSP DCSP raise DCNL DCSP logger.info ( &apos; Trying DCSP to DCSP create DCSP pull _ queue _ tasks _ index &apos; ) DCNL DCSP create _ index _ table = &apos; \ n DCSP DCSP DCSP DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull _ queue _ tasks _ index DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP app DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP queue DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP eta DCSP timestamp , \ n DCSP DCSP DCSP DCSP DCSP DCSP id DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP tag DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP tag _ exists DCSP boolean , \ n DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( ( app , DCSP queue , DCSP eta ) , DCSP id ) \ n DCSP DCSP DCSP DCSP ) \ n DCSP DCSP &apos; DCNL DCSP statement = SimpleStatement ( create _ index _ table , retry _ policy = NO _ RETRIES ) DCNL DCSP try : DCNL DCSP DCSP session.execute ( statement ) DCNL DCSP except OperationTimedOut : DCNL DCSP DCSP logger.warning ( &apos; Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull _ queue _ tasks _ index . DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle . &apos; ) DCNL DCSP DCSP time.sleep ( 60 ) DCNL DCSP DCSP raise DCNL DCSP logger.info ( &apos; Trying DCSP to DCSP create DCSP pull _ queue _ tags DCSP index &apos; ) DCNL DCSP create _ index = &apos; \ n DCSP DCSP DCSP DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull _ queue _ tags DCSP ON DCSP pull _ queue _ tasks _ index DCSP ( tag ) ; \ n DCSP DCSP &apos; DCNL DCSP session.execute ( create _ index ) DCNL DCSP logger.info ( &apos; Trying DCSP to DCSP create DCSP pull _ queue _ tag _ exists DCSP index &apos; ) DCNL DCSP create _ index = &apos; \ n DCSP DCSP DCSP DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull _ queue _ tag _ exists \ n DCSP DCSP DCSP DCSP ON DCSP pull _ queue _ tasks _ index DCSP ( tag _ exists ) ; \ n DCSP DCSP &apos; DCNL DCSP session.execute ( create _ index ) DCNL DCSP logger.info ( &apos; Trying DCSP to DCSP create DCSP pull _ queue _ leases &apos; ) DCNL DCSP create _ leases _ table = &apos; \ n DCSP DCSP DCSP DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull _ queue _ leases DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP app DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP queue DCSP text , \ n DCSP DCSP DCSP DCSP DCSP DCSP leased DCSP timestamp , \ n DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( ( app , DCSP queue , DCSP leased ) ) \ n DCSP DCSP DCSP DCSP ) \ n DCSP DCSP &apos; DCNL DCSP statement = SimpleStatement ( create _ leases _ table , retry _ policy = NO _ RETRIES ) DCNL DCSP try : DCNL DCSP DCSP session.execute ( statement ) DCNL DCSP except OperationTimedOut : DCNL DCSP DCSP logger.warning ( &apos; Encountered DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull _ queue _ leases . DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle . &apos; ) DCNL DCSP DCSP time.sleep ( 60 ) DCNL DCSP DCSP raise
DCSP with RopeContext ( ) as ctx : DCNL DCSP DCSP ( _ , offset ) = env.get _ offset _ params ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP occurrences = findit.find _ occurrences ( ctx.project , ctx.resource , offset ) DCNL DCSP DCSP except exceptions.BadIdentifierError : DCNL DCSP DCSP DCSP occurrences = &#91; &#93; DCNL DCSP lst = &#91; &#93; DCNL DCSP for oc in occurrences : DCNL DCSP DCSP lst.append ( dict ( filename = oc.resource.path , text = ( env.lines &#91; ( oc.lineno - 1 ) &#93; if ( oc.resource.real _ path = = env.curbuf.name ) else &apos; &apos; ) , lnum = oc.lineno ) ) DCNL DCSP env.let ( &apos; loclist . _ loclist &apos; , lst )
DCSP return ( abspath ( prefix ) .startswith ( context.root _ dir ) and ( not context.root _ writable ) )
DCSP tables = &#91; &#93; DCNL DCSP _ visitors = { } DCNL DCSP if include _ selects : DCNL DCSP DCSP _ visitors &#91; &apos; select &apos; &#93; = _ visitors &#91; &apos; compound _ select &apos; &#93; = tables.append DCNL DCSP if include _ joins : DCNL DCSP DCSP _ visitors &#91; &apos; join &apos; &#93; = tables.append DCNL DCSP if include _ aliases : DCNL DCSP DCSP _ visitors &#91; &apos; alias &apos; &#93; = tables.append DCNL DCSP if include _ crud : DCNL DCSP DCSP _ visitors &#91; &apos; insert &apos; &#93; = _ visitors &#91; &apos; update &apos; &#93; = _ visitors &#91; &apos; delete &apos; &#93; = ( lambda ent : tables.append ( ent.table ) ) DCNL DCSP if check _ columns : DCNL DCSP DCSP def visit _ column ( column ) : DCNL DCSP DCSP DCSP tables.append ( column.table ) DCNL DCSP DCSP _ visitors &#91; &apos; column &apos; &#93; = visit _ column DCNL DCSP _ visitors &#91; &apos; table &apos; &#93; = tables.append DCNL DCSP visitors.traverse ( clause , { &apos; column _ collections &apos; : False } , _ visitors ) DCNL DCSP return tables
DCSP pass
DCSP f.read ( n ) DCNL DCSP return
DCSP parts = &#91; part for part in split ( path , &apos; .&apos; ) if part &#93; DCNL DCSP ( module , n ) = ( None , 0 ) DCNL DCSP while ( n &lt; len ( parts ) ) : DCNL DCSP DCSP nextmodule = safeimport ( join ( parts &#91; : ( n + 1 ) &#93; , &apos; .&apos; ) , forceload ) DCNL DCSP DCSP if nextmodule : DCNL DCSP DCSP DCSP ( module , n ) = ( nextmodule , ( n + 1 ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break DCNL DCSP if module : DCNL DCSP DCSP object = module DCNL DCSP else : DCNL DCSP DCSP object = _ _ builtin _ _ DCNL DCSP for part in parts &#91; n : &#93; : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP object = getattr ( object , part ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP return None DCNL DCSP return object
DCSP return pd.read _ csv ( format _ yahoo _ index _ url ( symbol , start _ date , end _ date ) , parse _ dates = &#91; &apos; Date &apos; &#93; , index _ col = &apos; Date &apos; , usecols = &#91; &apos; Adj DCSP Close &apos; , &apos; Date &apos; &#93; , squeeze = True ) .sort _ index ( ) .tz _ localize ( &apos; UTC &apos; ) .pct _ change ( 1 ) .iloc &#91; 1 : &#93;
DCSP return iirfilter ( N , Wn , rs = rs , btype = btype , analog = analog , output = output , ftype = &apos; cheby2 &apos; )
DCSP if ( CONF.libvirt.virt _ type = = &apos; xen &apos; ) : DCNL DCSP DCSP if is _ block _ dev : DCNL DCSP DCSP DCSP return &apos; phy &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( hypervisor _ version &gt; = 4002000 ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP execute ( &apos; xend &apos; , &apos; status &apos; , run _ as _ root = True , check _ exit _ code = True ) DCNL DCSP DCSP DCSP DCSP except OSError as exc : DCNL DCSP DCSP DCSP DCSP DCSP if ( exc.errno = = errno.ENOENT ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP LOG.debug ( &apos; xend DCSP is DCSP not DCSP found &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return &apos; qemu &apos; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP DCSP except processutils.ProcessExecutionError : DCNL DCSP DCSP DCSP DCSP DCSP LOG.debug ( &apos; xend DCSP is DCSP not DCSP started &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP return &apos; qemu &apos; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( out , err ) = execute ( &apos; tap-ctl &apos; , &apos; check &apos; , check _ exit _ code = False ) DCNL DCSP DCSP DCSP DCSP if ( out = = &apos; ok \ n &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( hypervisor _ version &gt; 4000000 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return &apos; tap2 &apos; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return &apos; tap &apos; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP LOG.info ( _ LI ( &apos; tap-ctl DCSP check : DCSP % s &apos; ) , out ) DCNL DCSP DCSP DCSP except OSError as exc : DCNL DCSP DCSP DCSP DCSP if ( exc.errno = = errno.ENOENT ) : DCNL DCSP DCSP DCSP DCSP DCSP LOG.debug ( &apos; tap-ctl DCSP tool DCSP is DCSP not DCSP installed &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP return &apos; file &apos; DCNL DCSP elif ( CONF.libvirt.virt _ type in ( &apos; kvm &apos; , &apos; qemu &apos; ) ) : DCNL DCSP DCSP return &apos; qemu &apos; DCNL DCSP else : DCNL DCSP DCSP return None
DCSP group = worker.WalTransferGroup ( FakeWalUploader ( ) ) DCNL DCSP segments = list ( prepare _ multi _ upload _ segments ( ) ) DCNL DCSP exp = Explosion ( &apos; fail &apos; ) DCNL DCSP segments &#91; 0 &#93; . _ upload _ explosive = exp DCNL DCSP for seg in segments : DCNL DCSP DCSP group.start ( seg ) DCNL DCSP with pytest.raises ( Explosion ) as e : DCNL DCSP DCSP group.join ( ) DCNL DCSP assert ( e.value is exp ) DCNL DCSP assert failed ( segments &#91; 0 &#93; ) DCNL DCSP for seg in segments &#91; 1 : &#93; : DCNL DCSP DCSP assert success ( seg )
DCSP if ( not keys ) : DCNL DCSP DCSP dictionary.update ( value ) DCNL DCSP DCSP return DCNL DCSP for key in keys &#91; : ( -1 ) &#93; : DCNL DCSP DCSP if ( key not in dictionary ) : DCNL DCSP DCSP DCSP dictionary &#91; key &#93; = { } DCNL DCSP DCSP dictionary = dictionary &#91; key &#93; DCNL DCSP dictionary &#91; keys &#91; ( -1 ) &#93; &#93; = value
DCSP session = get _ session ( ) DCNL DCSP with session.begin ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP instance _ type _ get _ by _ name ( context , values &#91; &apos; name &apos; &#93; , session ) DCNL DCSP DCSP DCSP raise exception.InstanceTypeExists ( name = values &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP except exception.InstanceTypeNotFoundByName : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP instance _ type _ get _ by _ flavor _ id ( context , values &#91; &apos; flavorid &apos; &#93; , session ) DCNL DCSP DCSP DCSP raise exception.InstanceTypeIdExists ( flavor _ id = values &#91; &apos; flavorid &apos; &#93; ) DCNL DCSP DCSP except exception.FlavorNotFound : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP specs = values.get ( &apos; extra _ specs &apos; ) DCNL DCSP DCSP DCSP specs _ refs = &#91; &#93; DCNL DCSP DCSP DCSP if specs : DCNL DCSP DCSP DCSP DCSP for ( k , v ) in specs.iteritems ( ) : DCNL DCSP DCSP DCSP DCSP DCSP specs _ ref = models.InstanceTypeExtraSpecs ( ) DCNL DCSP DCSP DCSP DCSP DCSP specs _ ref &#91; &apos; key &apos; &#93; = k DCNL DCSP DCSP DCSP DCSP DCSP specs _ ref &#91; &apos; value &apos; &#93; = v DCNL DCSP DCSP DCSP DCSP DCSP specs _ refs.append ( specs _ ref ) DCNL DCSP DCSP DCSP values &#91; &apos; extra _ specs &apos; &#93; = specs _ refs DCNL DCSP DCSP DCSP instance _ type _ ref = models.InstanceTypes ( ) DCNL DCSP DCSP DCSP instance _ type _ ref.update ( values ) DCNL DCSP DCSP DCSP instance _ type _ ref.save ( session = session ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP raise db _ exc.DBError ( e ) DCNL DCSP DCSP return _ dict _ with _ extra _ specs ( instance _ type _ ref )
DCSP fwd = mne.read _ forward _ solution ( fwd _ fname , surf _ ori = True ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP warnings.simplefilter ( &apos; always &apos; ) DCNL DCSP DCSP projs = read _ proj ( eog _ fname ) DCNL DCSP DCSP projs.extend ( read _ proj ( ecg _ fname ) ) DCNL DCSP decim = 6 DCNL DCSP for ch _ type in &#91; &apos; eeg &apos; , &apos; grad &apos; , &apos; mag &apos; &#93; : DCNL DCSP DCSP w = read _ source _ estimate ( ( sensmap _ fname % ( ch _ type , &apos; lh &apos; ) ) ) .data DCNL DCSP DCSP stc = sensitivity _ map ( fwd , projs = None , ch _ type = ch _ type , mode = &apos; free &apos; , exclude = &apos; bads &apos; ) DCNL DCSP DCSP assert _ array _ almost _ equal ( stc.data , w , decim ) DCNL DCSP DCSP assert _ true ( ( stc.subject = = &apos; sample &apos; ) ) DCNL DCSP DCSP if ( ch _ type = = &apos; grad &apos; ) : DCNL DCSP DCSP DCSP w = read _ source _ estimate ( ( sensmap _ fname % ( ch _ type , &apos; 2-lh &apos; ) ) ) .data DCNL DCSP DCSP DCSP stc = sensitivity _ map ( fwd , projs = None , mode = &apos; fixed &apos; , ch _ type = ch _ type , exclude = &apos; bads &apos; ) DCNL DCSP DCSP DCSP assert _ array _ almost _ equal ( stc.data , w , decim ) DCNL DCSP DCSP if ( ch _ type = = &apos; mag &apos; ) : DCNL DCSP DCSP DCSP w = read _ source _ estimate ( ( sensmap _ fname % ( ch _ type , &apos; 3-lh &apos; ) ) ) .data DCNL DCSP DCSP DCSP stc = sensitivity _ map ( fwd , projs = None , mode = &apos; ratio &apos; , ch _ type = ch _ type , exclude = &apos; bads &apos; ) DCNL DCSP DCSP DCSP assert _ array _ almost _ equal ( stc.data , w , decim ) DCNL DCSP DCSP if ( ch _ type = = &apos; eeg &apos; ) : DCNL DCSP DCSP DCSP modes = &#91; &apos; radiality &apos; , &apos; angle &apos; , &apos; remaining &apos; , &apos; dampening &apos; &#93; DCNL DCSP DCSP DCSP ends = &#91; &apos; 4-lh &apos; , &apos; 5-lh &apos; , &apos; 6-lh &apos; , &apos; 7-lh &apos; &#93; DCNL DCSP DCSP DCSP for ( mode , end ) in zip ( modes , ends ) : DCNL DCSP DCSP DCSP DCSP w = read _ source _ estimate ( ( sensmap _ fname % ( ch _ type , end ) ) ) .data DCNL DCSP DCSP DCSP DCSP stc = sensitivity _ map ( fwd , projs = projs , mode = mode , ch _ type = ch _ type , exclude = &apos; bads &apos; ) DCNL DCSP DCSP DCSP DCSP assert _ array _ almost _ equal ( stc.data , w , decim ) DCNL DCSP stc = sensitivity _ map ( fwd , projs = &#91; make _ eeg _ average _ ref _ proj ( fwd &#91; &apos; info &apos; &#93; ) &#93; , ch _ type = &apos; eeg &apos; , exclude = &apos; bads &apos; ) DCNL DCSP assert _ raises ( ValueError , sensitivity _ map , fwd , projs = None , mode = &apos; angle &apos; ) DCNL DCSP assert _ raises ( RuntimeError , sensitivity _ map , fwd , projs = &#91; &#93; , mode = &apos; angle &apos; ) DCNL DCSP fname = op.join ( sample _ path , &apos; sample _ audvis _ trunc-meg-vol-7-fwd.fif &apos; ) DCNL DCSP fwd = mne.read _ forward _ solution ( fname ) DCNL DCSP sensitivity _ map ( fwd )
DCSP output = subprocess.check _ output ( cmd , cwd = cwd , stderr = subprocess.STDOUT ) DCNL DCSP log.debug ( &apos; Command DCSP was : DCSP { 0 ! r } . DCSP Working DCSP directory DCSP was : DCSP { 1 ! r } &apos; .format ( &apos; DCSP &apos; .join ( cmd ) , cwd ) ) DCNL DCSP log.debug ( &apos; Command DCSP output DCSP was : DCSP { 0 ! r } &apos; .format ( output ) ) DCNL DCSP return output
DCSP if context.is _ admin : DCNL DCSP DCSP for key in ( &apos; sort _ key &apos; , &apos; sort _ dir &apos; , &apos; limit &apos; , &apos; marker &apos; ) : DCNL DCSP DCSP DCSP search _ options.pop ( key , None ) DCNL DCSP DCSP return DCNL DCSP unknown _ options = &#91; opt for opt in search _ options if ( opt not in allowed _ search _ options ) &#93; DCNL DCSP if unknown _ options : DCNL DCSP DCSP LOG.debug ( &quot; Removing DCSP options DCSP &apos; % s &apos; DCSP from DCSP query &quot; , &apos; , DCSP &apos; .join ( unknown _ options ) ) DCNL DCSP DCSP for opt in unknown _ options : DCNL DCSP DCSP DCSP search _ options.pop ( opt , None )
DCSP cmd = &apos; chage DCSP -d DCSP { 0 } DCSP { 1 } &apos; .format ( date , name ) DCNL DCSP return ( not _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) )
DCSP logging.warn ( &apos; utils.get _ os _ vendor ( ) DCSP is DCSP deprecated , DCSP please DCSP use DCSP autotest.client.shared.distro.detect ( ) DCSP instead &apos; ) DCNL DCSP vendor = &apos; Unknown &apos; DCNL DCSP if os.path.isfile ( &apos; / etc / SuSE-release &apos; ) : DCNL DCSP DCSP return &apos; SUSE &apos; DCNL DCSP issue = &apos; / etc / issue &apos; DCNL DCSP if ( not os.path.isfile ( issue ) ) : DCNL DCSP DCSP return vendor DCNL DCSP if file _ contains _ pattern ( issue , &apos; Red DCSP Hat &apos; ) : DCNL DCSP DCSP vendor = &apos; Red DCSP Hat &apos; DCNL DCSP if file _ contains _ pattern ( issue , &apos; CentOS &apos; ) : DCNL DCSP DCSP vendor = &apos; Red DCSP Hat &apos; DCNL DCSP elif file _ contains _ pattern ( issue , &apos; Fedora &apos; ) : DCNL DCSP DCSP vendor = &apos; Fedora &apos; DCNL DCSP elif file _ contains _ pattern ( issue , &apos; SUSE &apos; ) : DCNL DCSP DCSP vendor = &apos; SUSE &apos; DCNL DCSP elif file _ contains _ pattern ( issue , &apos; Ubuntu &apos; ) : DCNL DCSP DCSP vendor = &apos; Ubuntu &apos; DCNL DCSP elif file _ contains _ pattern ( issue , &apos; Debian &apos; ) : DCNL DCSP DCSP vendor = &apos; Debian &apos; DCNL DCSP logging.debug ( &apos; Detected DCSP OS DCSP vendor : DCSP % s &apos; , vendor ) DCNL DCSP return vendor
DCSP return value.ljust ( int ( arg ) )
DCSP label = QLabel ( ) DCNL DCSP label.setPixmap ( QPixmap ( get _ image _ path ( name , default ) ) ) DCNL DCSP return label
DCSP if isinstance ( relpath , compat.text _ type ) : DCNL DCSP DCSP relpath = relpath.encode ( u &apos;utf-8 &apos; ) DCNL DCSP return ( u &apos;local : track : % s &apos; % urllib.quote ( relpath ) )
DCSP output = &#91; &#93; DCNL DCSP eval _ ctx = EvalContext ( environment ) DCNL DCSP for node in node _ list : DCNL DCSP DCSP if isinstance ( node , Output ) : DCNL DCSP DCSP DCSP for node in node.nodes : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP const = node.as _ const ( eval _ ctx = eval _ ctx ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not isinstance ( const , six.text _ type ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise Unflattenable ( const ) DCNL DCSP DCSP DCSP DCSP DCSP output.append ( const ) DCNL DCSP DCSP DCSP DCSP except Impossible : DCNL DCSP DCSP DCSP DCSP DCSP raise Unflattenable ( node ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise Unflattenable ( node ) DCNL DCSP return u &apos; &apos; .join ( output )
DCSP if ( not issubclass ( subsystem _ type , Subsystem ) ) : DCNL DCSP DCSP raise TypeError ( u &apos;The DCSP given DCSP `subsystem _ type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Subsystem` : DCSP { } &apos; .format ( subsystem _ type ) ) DCNL DCSP optionables = Subsystem.closure ( &#91; subsystem _ type &#93; ) DCNL DCSP updated _ options = ( dict ( Subsystem . _ options.items ( ) ) if Subsystem . _ options else { } ) DCNL DCSP if options : DCNL DCSP DCSP updated _ options.update ( options ) DCNL DCSP Subsystem . _ options = create _ options _ for _ optionables ( optionables , options = updated _ options ) DCNL DCSP try : DCNL DCSP DCSP if ( scope is None ) : DCNL DCSP DCSP DCSP ( yield subsystem _ type.global _ instance ( ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP class ScopedOptionable ( Optionable , ) : DCNL DCSP DCSP DCSP DCSP options _ scope = scope DCNL DCSP DCSP DCSP DCSP options _ scope _ category = ScopeInfo.SUBSYSTEM DCNL DCSP DCSP DCSP ( yield subsystem _ type.scoped _ instance ( ScopedOptionable ) ) DCNL DCSP finally : DCNL DCSP DCSP Subsystem.reset ( )
DCSP return s.count ( * args )
DCSP if ( name.isdigit ( ) or g.userpl.get ( name ) ) : DCNL DCSP DCSP if name.isdigit ( ) : DCNL DCSP DCSP DCSP name = ( int ( name ) - 1 ) DCNL DCSP DCSP DCSP name = sorted ( g.userpl ) &#91; name &#93; DCNL DCSP DCSP del g.userpl &#91; name &#93; DCNL DCSP DCSP g.message = ( &apos; Deleted DCSP playlist DCSP % s % s % s &apos; % ( c.y , name , c.w ) ) DCNL DCSP DCSP g.content = content.playlists _ display ( ) DCNL DCSP DCSP playlists.save ( ) DCNL DCSP else : DCNL DCSP DCSP g.message = ( util.F ( &apos; pl DCSP not DCSP found DCSP advise DCSP ls &apos; ) % name ) DCNL DCSP DCSP g.content = content.playlists _ display ( )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : None , &apos; comment &apos; : &apos; &apos; } DCNL DCSP set _ check = _ _ salt _ _ &#91; &apos; ipset.check _ set &apos; &#93; ( name ) DCNL DCSP if ( set _ check is True ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; ipset DCSP set DCSP { 0 } DCSP already DCSP exists DCSP for DCSP { 1 } &apos; .format ( name , family ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; ipset DCSP set DCSP { 0 } DCSP would DCSP be DCSP added DCSP for DCSP { 1 } &apos; .format ( name , family ) DCNL DCSP DCSP return ret DCNL DCSP command = _ _ salt _ _ &#91; &apos; ipset.new _ set &apos; &#93; ( name , set _ type , family , * * kwargs ) DCNL DCSP if ( command is True ) : DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { &apos; locale &apos; : name } DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; ipset DCSP set DCSP { 0 } DCSP created DCSP successfully DCSP for DCSP { 1 } &apos; .format ( name , family ) DCNL DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP set DCSP { 0 } DCSP for DCSP { 2 } : DCSP { 1 } &apos; .format ( name , command.strip ( ) , family ) DCNL DCSP DCSP return ret
DCSP user _ dicts = request.json.get ( &apos; users &apos; ) DCNL DCSP node _ ids = request.json.get ( &apos; node _ ids &apos; ) DCNL DCSP if ( node . _ id in node _ ids ) : DCNL DCSP DCSP node _ ids.remove ( node . _ id ) DCNL DCSP if ( ( user _ dicts is None ) or ( node _ ids is None ) ) : DCNL DCSP DCSP raise HTTPError ( http.BAD _ REQUEST ) DCNL DCSP try : DCNL DCSP DCSP contribs = deserialize _ contributors ( node , user _ dicts , auth = auth , validate = True ) DCNL DCSP except ValidationError as e : DCNL DCSP DCSP return ( { &apos; status &apos; : 400 , &apos; message &apos; : e.message } , 400 ) DCNL DCSP try : DCNL DCSP DCSP node.add _ contributors ( contributors = contribs , auth = auth ) DCNL DCSP except NodeStateError as e : DCNL DCSP DCSP return ( { &apos; status &apos; : 400 , &apos; message &apos; : e.args &#91; 0 &#93; } , 400 ) DCNL DCSP node.save ( ) DCNL DCSP unreg _ contributor _ added.disconnect ( finalize _ invitation ) DCNL DCSP for child _ id in node _ ids : DCNL DCSP DCSP child = Node.load ( child _ id ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP child _ contribs = deserialize _ contributors ( child , user _ dicts , auth = auth , validate = True ) DCNL DCSP DCSP except ValidationError as e : DCNL DCSP DCSP DCSP return ( { &apos; status &apos; : 400 , &apos; message &apos; : e.message } , 400 ) DCNL DCSP DCSP child.add _ contributors ( contributors = child _ contribs , auth = auth ) DCNL DCSP DCSP child.save ( ) DCNL DCSP unreg _ contributor _ added.connect ( finalize _ invitation ) DCNL DCSP return ( { &apos; status &apos; : &apos; success &apos; , &apos; contributors &apos; : profile _ utils.serialize _ contributors ( node.visible _ contributors , node = node ) } , 201 )
DCSP for controller in controllers : DCNL DCSP DCSP if controller.isAvailable ( ) : DCNL DCSP DCSP DCSP return controller
DCSP dst _ port = ( ( &apos; DCSP options : dst _ port = &apos; + str ( dst _ port ) ) if ( 0 &lt; dst _ port &lt; = 65535 ) else &apos; &apos; ) DCNL DCSP if ( not ( 0 &lt; = id &lt; ( 2 * * 64 ) ) ) : DCNL DCSP DCSP return False DCNL DCSP elif ( not _ _ salt _ _ &#91; &apos; dig.check _ ip &apos; &#93; ( remote ) ) : DCNL DCSP DCSP return False DCNL DCSP elif ( not bridge _ exists ( br ) ) : DCNL DCSP DCSP return False DCNL DCSP elif ( port in port _ list ( br ) ) : DCNL DCSP DCSP cmd = &apos; ovs-vsctl DCSP set DCSP interface DCSP { 0 } DCSP type = vxlan DCSP options : remote _ ip = { 1 } DCSP options : key = { 2 } { 3 } &apos; .format ( port , remote , id , dst _ port ) DCNL DCSP DCSP result = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd ) DCNL DCSP DCSP return _ retcode _ to _ bool ( result &#91; &apos; retcode &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP cmd = &apos; ovs-vsctl DCSP add-port DCSP { 0 } DCSP { 1 } DCSP -- DCSP set DCSP interface DCSP { 1 } DCSP type = vxlan DCSP options : remote _ ip = { 2 } DCSP options : key = { 3 } { 4 } &apos; .format ( br , port , remote , id , dst _ port ) DCNL DCSP DCSP result = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd ) DCNL DCSP DCSP return _ retcode _ to _ bool ( result &#91; &apos; retcode &apos; &#93; )
DCSP pools = { } DCNL DCSP for ( name , config ) in settings.STREAM _ REDIS _ CONFIG.items ( ) : DCNL DCSP DCSP pool = redis.ConnectionPool ( host = config &#91; &apos; host &apos; &#93; , port = config &#91; &apos; port &apos; &#93; , password = config.get ( &apos; password &apos; ) , db = config &#91; &apos; db &apos; &#93; , decode _ responses = True ) DCNL DCSP DCSP pools &#91; name &#93; = pool DCNL DCSP return pools
DCSP open ( fname , &apos; a &apos; ) .close ( ) DCNL DCSP FILENAME = fname DCNL DCSP CLASS = some _ class DCNL DCSP PREFIX = &apos; -- &#91; DCSP % ( asked ) s DCSP / DCSP % ( called ) s DCSP / DCSP % ( defined ) s DCSP &#93; -- &apos; DCNL DCSP if ( prefix ! = None ) : DCNL DCSP DCSP PREFIX = prefix DCNL DCSP MAXWIDTH = { &apos; o _ O &apos; : 10 } DCNL DCSP def format _ prefix ( method , methodobj ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP -- &#91; DCSP ShellBase DCSP / DCSP Internal DCSP / DCSP BaseEdit DCSP &#93; ------- DCSP get _ position \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP classnames = { &apos; asked &apos; : CLASS . _ _ name _ _ , &apos; called &apos; : methodobj . _ _ class _ _ . _ _ name _ _ , &apos; defined &apos; : get _ class _ that _ defined ( method ) } DCNL DCSP DCSP line = ( PREFIX % classnames ) DCNL DCSP DCSP MAXWIDTH &#91; &apos; o _ O &apos; &#93; = max ( len ( line ) , MAXWIDTH &#91; &apos; o _ O &apos; &#93; ) DCNL DCSP DCSP return line.ljust ( MAXWIDTH &#91; &apos; o _ O &apos; &#93; , &apos; -&apos; ) DCNL DCSP import types DCNL DCSP def _ _ getattribute _ _ ( self , name ) : DCNL DCSP DCSP attr = object . _ _ getattribute _ _ ( self , name ) DCNL DCSP DCSP if ( type ( attr ) is not types.MethodType ) : DCNL DCSP DCSP DCSP return attr DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP def newfunc ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP DCSP log = open ( FILENAME , &apos; a &apos; ) DCNL DCSP DCSP DCSP DCSP prefix = format _ prefix ( attr , self ) DCNL DCSP DCSP DCSP DCSP log.write ( ( &apos; % s DCSP % s \ n &apos; % ( prefix , name ) ) ) DCNL DCSP DCSP DCSP DCSP log.close ( ) DCNL DCSP DCSP DCSP DCSP result = attr ( * args , * * kwargs ) DCNL DCSP DCSP DCSP DCSP return result DCNL DCSP DCSP DCSP return newfunc DCNL DCSP some _ class . _ _ getattribute _ _ = _ _ getattribute _ _
DCSP if ( not api _ key ) : DCNL DCSP DCSP return &apos; Octopart DCSP API DCSP key DCSP required . &apos; DCNL DCSP params = { &apos; apikey &apos; : api _ key , &apos; q &apos; : text , &apos; start &apos; : 0 , &apos; limit &apos; : 1 } DCNL DCSP try : DCNL DCSP DCSP request = requests.get ( API _ URL , params = params ) DCNL DCSP DCSP request.raise _ for _ status ( ) DCNL DCSP except ( requests.exceptions.HTTPError , requests.exceptions.ConnectionError ) as e : DCNL DCSP DCSP return &apos; Could DCSP not DCSP fetch DCSP part DCSP data : DCSP { } &apos; .format ( e ) DCNL DCSP response = request.json ( ) DCNL DCSP if ( not response &#91; &apos; results &apos; &#93; ) : DCNL DCSP DCSP return &apos; No DCSP results . &apos; DCNL DCSP results = response &#91; &apos; results &apos; &#93; DCNL DCSP for result in results : DCNL DCSP DCSP part = result &#91; &apos; item &apos; &#93; DCNL DCSP DCSP reply ( &apos; { } DCSP - DCSP { } DCSP - DCSP { } &apos; .format ( part &#91; &apos; brand &apos; &#93; &#91; &apos; name &apos; &#93; , part &#91; &apos; mpn &apos; &#93; , part &#91; &apos; octopart _ url &apos; &#93; ) )
DCSP if ( not isinstance ( watch , str ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Expected DCSP str &apos; ) DCNL DCSP if ( not isinstance ( start _ cmd , str ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Expected DCSP str &apos; ) DCNL DCSP if ( not isinstance ( stop _ cmd , str ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Expected DCSP str &apos; ) DCNL DCSP if ( not isinstance ( ports , list ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Expected DCSP list &apos; ) DCNL DCSP if ( not isinstance ( env _ vars , dict ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Expected DCSP dict &apos; ) DCNL DCSP env = &apos; &apos; DCNL DCSP for ii in env _ vars : DCNL DCSP DCSP env + = ( ( ( ( &apos; export DCSP &apos; + str ( ii ) ) + &apos; = &quot; &apos; ) + str ( env _ vars &#91; ii &#93; ) ) + &apos; &quot; DCSP &amp; &amp; DCSP &apos; ) DCNL DCSP for ( index , ii ) in enumerate ( ports ) : DCNL DCSP DCSP ports &#91; index &#93; = str ( ii ) DCNL DCSP template = &apos; &apos; DCNL DCSP if ( not match _ cmd ) : DCNL DCSP DCSP match _ cmd = start _ cmd DCNL DCSP if upgrade _ flag : DCNL DCSP DCSP max _ memory = 0 DCNL DCSP for port in ports : DCNL DCSP DCSP if syslog _ server : DCNL DCSP DCSP DCSP template = file _ io.read ( TEMPLATE _ LOCATION _ SYSLOG ) DCNL DCSP DCSP DCSP template = template.format ( watch = watch , start = start _ cmd , stop = stop _ cmd , port = port , env = env , syslog _ server = syslog _ server , match = match _ cmd ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP template = file _ io.read ( TEMPLATE _ LOCATION ) DCNL DCSP DCSP DCSP template = template.format ( watch = watch , start = start _ cmd , stop = stop _ cmd , port = port , match = match _ cmd , env = env ) DCNL DCSP DCSP if ( max _ memory &gt; 0 ) : DCNL DCSP DCSP DCSP template + = &apos; DCSP DCSP if DCSP totalmem DCSP &gt; DCSP { } DCSP MB DCSP for DCSP 10 DCSP cycles DCSP then DCSP restart \ n &apos; .format ( max _ memory ) DCNL DCSP DCSP if host : DCNL DCSP DCSP DCSP template + = &apos; DCSP DCSP if DCSP failed DCSP host DCSP { } DCSP port DCSP { } DCSP then DCSP restart \ n &apos; .format ( host , port ) DCNL DCSP DCSP config _ file = &apos; { } / appscale- { } - { } .cfg &apos; .format ( MONIT _ CONFIG _ DIR , watch , port ) DCNL DCSP DCSP file _ io.write ( config _ file , template ) DCNL DCSP return
DCSP configuration.set ( shop , SAMPLE _ CATEGORIES _ KEY , categories _ pk )
DCSP request = cherrypy.serving.request DCNL DCSP if scheme : DCNL DCSP DCSP s = request.headers.get ( scheme , None ) DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP cherrypy.log ( ( &apos; Testing DCSP scheme DCSP % r : % r &apos; % ( scheme , s ) ) , &apos; TOOLS.PROXY &apos; ) DCNL DCSP DCSP if ( ( s = = &apos; on &apos; ) and ( &apos; ssl &apos; in scheme.lower ( ) ) ) : DCNL DCSP DCSP DCSP scheme = &apos; https &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP scheme = s DCNL DCSP if ( not scheme ) : DCNL DCSP DCSP scheme = request.base &#91; : request.base.find ( &apos; : / / &apos; ) &#93; DCNL DCSP if local : DCNL DCSP DCSP lbase = request.headers.get ( local , None ) DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP cherrypy.log ( ( &apos; Testing DCSP local DCSP % r : % r &apos; % ( local , lbase ) ) , &apos; TOOLS.PROXY &apos; ) DCNL DCSP DCSP if ( lbase is not None ) : DCNL DCSP DCSP DCSP base = lbase.split ( &apos; , &apos; ) &#91; 0 &#93; DCNL DCSP if ( not base ) : DCNL DCSP DCSP port = request.local.port DCNL DCSP DCSP if ( port = = 80 ) : DCNL DCSP DCSP DCSP base = &apos; 127.0.0.1 &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP base = ( &apos; 127.0.0.1 : % s &apos; % port ) DCNL DCSP if ( base.find ( &apos; : / / &apos; ) = = ( -1 ) ) : DCNL DCSP DCSP base = ( ( scheme + &apos; : / / &apos; ) + base ) DCNL DCSP request.base = base DCNL DCSP if remote : DCNL DCSP DCSP xff = request.headers.get ( remote ) DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP cherrypy.log ( ( &apos; Testing DCSP remote DCSP % r : % r &apos; % ( remote , xff ) ) , &apos; TOOLS.PROXY &apos; ) DCNL DCSP DCSP if xff : DCNL DCSP DCSP DCSP if ( remote = = &apos; X-Forwarded-For &apos; ) : DCNL DCSP DCSP DCSP DCSP xff = xff.split ( &apos; , &apos; ) &#91; ( -1 ) &#93; .strip ( ) DCNL DCSP DCSP DCSP request.remote.ip = xff
DCSP if ( direction = = &apos; l &apos; ) : DCNL DCSP DCSP if text.startswith ( remove ) : DCNL DCSP DCSP DCSP return text &#91; len ( remove ) : &#93; DCNL DCSP elif ( direction = = &apos; r &apos; ) : DCNL DCSP DCSP if text.endswith ( remove ) : DCNL DCSP DCSP DCSP return text &#91; : ( - len ( remove ) ) &#93; DCNL DCSP else : DCNL DCSP DCSP raise WrongDirection , &apos; Needs DCSP to DCSP be DCSP r DCSP or DCSP l . &apos; DCNL DCSP return text
DCSP for ( argumentIndex , argument ) in enumerate ( arguments ) : DCNL DCSP DCSP xmlElement.attributeDictionary &#91; argumentNames &#91; argumentIndex &#93; &#93; = argument
DCSP links = &#91; &#93; DCNL DCSP for link in metadata : DCNL DCSP DCSP if isinstance ( link , compat.string _ type ) : DCNL DCSP DCSP DCSP link = { &apos; name &apos; : link } DCNL DCSP DCSP elif ( &apos; name &apos; not in link ) : DCNL DCSP DCSP DCSP raise ModelError ( &apos; Dimension DCSP link DCSP has DCSP no DCSP name &apos; ) DCNL DCSP DCSP links.append ( link ) DCNL DCSP return links
DCSP if ( u &apos;all _ comments &apos; not in context ) : DCNL DCSP DCSP comments = defaultdict ( list ) DCNL DCSP DCSP if ( ( u &apos;request &apos; in context ) and context &#91; u &apos;request &apos; &#93; .user.is _ staff ) : DCNL DCSP DCSP DCSP comments _ queryset = parent.comments.all ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP comments _ queryset = parent.comments.visible ( ) DCNL DCSP DCSP for comment in comments _ queryset.select _ related ( u &apos;user &apos; ) : DCNL DCSP DCSP DCSP comments &#91; comment.replied _ to _ id &#93; .append ( comment ) DCNL DCSP DCSP context &#91; u &apos;all _ comments &apos; &#93; = comments DCNL DCSP parent _ id = ( parent.id if isinstance ( parent , ThreadedComment ) else None ) DCNL DCSP try : DCNL DCSP DCSP replied _ to = int ( context &#91; u &apos;request &apos; &#93; .POST &#91; u &apos;replied _ to &apos; &#93; ) DCNL DCSP except KeyError : DCNL DCSP DCSP replied _ to = 0 DCNL DCSP context.update ( { u &apos;comments _ for _ thread &apos; : context &#91; u &apos;all _ comments &apos; &#93; .get ( parent _ id , &#91; &#93; ) , u &apos;no _ comments &apos; : ( ( parent _ id is None ) and ( not context &#91; u &apos;all _ comments &apos; &#93; ) ) , u &apos;replied _ to &apos; : replied _ to } ) DCNL DCSP return context
DCSP out = &#91; &#93; DCNL DCSP if ( not isinstance ( arg , ( list , tuple ) ) ) : DCNL DCSP DCSP arg = &#91; arg &#93; DCNL DCSP for val in arg : DCNL DCSP DCSP if ( val is None ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if isinstance ( val , ( list , tuple ) ) : DCNL DCSP DCSP DCSP out.extend ( listify _ value ( val , split = split ) ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP out.extend ( ( s.strip ( ) for s in text _ type ( val ) .split ( split ) ) ) DCNL DCSP assert all ( ( isinstance ( val , string _ types ) for val in out ) ) DCNL DCSP return out
DCSP while 1 : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return fun ( * args ) DCNL DCSP DCSP except error as e : DCNL DCSP DCSP DCSP eintr = ( errno.WSAEINTR if ( os.name = = &apos; nt &apos; ) else errno.EINTR ) DCNL DCSP DCSP DCSP if ( e.args &#91; 0 &#93; = = eintr ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP raise
DCSP queryset = model.find ( query ) DCNL DCSP paginator = Paginator ( queryset.all ( ) , increment ) DCNL DCSP for page _ num in paginator.page _ range : DCNL DCSP DCSP page = paginator.page ( page _ num ) DCNL DCSP DCSP if each : DCNL DCSP DCSP DCSP for item in page.object _ list : DCNL DCSP DCSP DCSP DCSP ( yield item ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( yield page.object _ list )
DCSP if isinstance ( lambda _ , string _ types ) : DCNL DCSP DCSP if ( lambda _ not in _ power _ div _ lambda _ names ) : DCNL DCSP DCSP DCSP names = repr ( list ( _ power _ div _ lambda _ names.keys ( ) ) ) &#91; 1 : ( -1 ) &#93; DCNL DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP string DCSP for DCSP lambda _ : DCSP { 0 ! r } . DCSP DCSP Valid DCSP strings DCSP are DCSP { 1 } &apos; .format ( lambda _ , names ) ) DCNL DCSP DCSP lambda _ = _ power _ div _ lambda _ names &#91; lambda _ &#93; DCNL DCSP elif ( lambda _ is None ) : DCNL DCSP DCSP lambda _ = 1 DCNL DCSP f _ obs = np.asanyarray ( f _ obs ) DCNL DCSP if ( f _ exp is not None ) : DCNL DCSP DCSP f _ exp = np.atleast _ 1d ( np.asanyarray ( f _ exp ) ) DCNL DCSP else : DCNL DCSP DCSP with np.errstate ( invalid = &apos; ignore &apos; ) : DCNL DCSP DCSP DCSP f _ exp = np.atleast _ 1d ( f _ obs.mean ( axis = axis ) ) DCNL DCSP DCSP if ( axis is not None ) : DCNL DCSP DCSP DCSP reduced _ shape = list ( f _ obs.shape ) DCNL DCSP DCSP DCSP reduced _ shape &#91; axis &#93; = 1 DCNL DCSP DCSP DCSP f _ exp.shape = reduced _ shape DCNL DCSP if ( lambda _ = = 1 ) : DCNL DCSP DCSP terms = ( ( ( f _ obs - f _ exp ) * * 2 ) / f _ exp ) DCNL DCSP elif ( lambda _ = = 0 ) : DCNL DCSP DCSP terms = ( 2.0 * special.xlogy ( f _ obs , ( f _ obs / f _ exp ) ) ) DCNL DCSP elif ( lambda _ = = ( -1 ) ) : DCNL DCSP DCSP terms = ( 2.0 * special.xlogy ( f _ exp , ( f _ exp / f _ obs ) ) ) DCNL DCSP else : DCNL DCSP DCSP terms = ( f _ obs * ( ( ( f _ obs / f _ exp ) * * lambda _ ) - 1 ) ) DCNL DCSP DCSP terms / = ( ( 0.5 * lambda _ ) * ( lambda _ + 1 ) ) DCNL DCSP stat = terms.sum ( axis = axis ) DCNL DCSP num _ obs = _ count ( terms , axis = axis ) DCNL DCSP ddof = asarray ( ddof ) DCNL DCSP p = distributions.chi2.sf ( stat , ( ( num _ obs - 1 ) - ddof ) ) DCNL DCSP return Power _ divergenceResult ( stat , p )
DCSP return &apos; .&apos;.join ( map ( str , VERSION ) )
DCSP if ( key _ function is None ) : DCNL DCSP DCSP key _ function = ( lambda rec : rec.id ) DCNL DCSP d = dict ( ) DCNL DCSP for record in sequences : DCNL DCSP DCSP key = key _ function ( record ) DCNL DCSP DCSP if ( key in d ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &quot; Duplicate DCSP key DCSP &apos; % s &apos; &quot; % key ) ) DCNL DCSP DCSP d &#91; key &#93; = record DCNL DCSP return d
DCSP ranked = parse _ accept _ lang _ header ( accept _ lang ) DCNL DCSP return find _ supported ( ranked )
DCSP mode = session.s3.hrm.mode DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( mode is not None ) : DCNL DCSP DCSP DCSP auth.permission.fail ( ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if ( settings.get _ hrm _ filter _ certificates ( ) and ( not auth.s3 _ has _ role ( ADMIN ) ) ) : DCNL DCSP DCSP s3.filter = auth.filter _ by _ root _ org ( s3db.hrm _ certificate ) DCNL DCSP output = s3 _ rest _ controller ( rheader = s3db.hrm _ rheader ) DCNL DCSP return output
DCSP ret = { } DCNL DCSP pkg _ to _ paths = { } DCNL DCSP for pth in paths : DCNL DCSP DCSP pth _ pkg = _ _ salt _ _ &#91; &apos; lowpkg.owner &apos; &#93; ( pth ) DCNL DCSP DCSP if ( not pth _ pkg ) : DCNL DCSP DCSP DCSP ret &#91; pth &#93; = ( ( os.path.exists ( pth ) and &apos; Not DCSP managed &apos; ) or &apos; N / A &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( pkg _ to _ paths.get ( pth _ pkg ) is None ) : DCNL DCSP DCSP DCSP DCSP pkg _ to _ paths &#91; pth _ pkg &#93; = &#91; &#93; DCNL DCSP DCSP DCSP pkg _ to _ paths &#91; pth _ pkg &#93; .append ( pth ) DCNL DCSP if pkg _ to _ paths : DCNL DCSP DCSP local _ pkgs = _ _ salt _ _ &#91; &apos; pkg.download &apos; &#93; ( * pkg _ to _ paths.keys ( ) ) DCNL DCSP DCSP for ( pkg , files ) in pkg _ to _ paths.items ( ) : DCNL DCSP DCSP DCSP for path in files : DCNL DCSP DCSP DCSP DCSP ret &#91; path &#93; = ( _ _ salt _ _ &#91; &apos; lowpkg.diff &apos; &#93; ( local _ pkgs &#91; pkg &#93; &#91; &apos; path &apos; &#93; , path ) or &apos; Unchanged &apos; ) DCNL DCSP return ret
DCSP assert ( errors = = &apos; strict &apos; ) DCNL DCSP output = base64.decodestring ( input ) DCNL DCSP return ( output , len ( input ) )
DCSP client.close ( )
DCSP md5 = request.GET &#91; &apos; md5 &apos; &#93; DCNL DCSP if re.match ( &apos; &#91; 0-9a-f &#93; { 32 } &apos; , md5 ) : DCNL DCSP DCSP db _ obj = RecentScansDB.objects.filter ( MD5 = md5 ) DCNL DCSP DCSP if db _ obj.exists ( ) : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( ( &apos; / &apos; + db _ obj &#91; 0 &#93; .URL ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( &apos; / not _ found &apos; ) DCNL DCSP return HttpResponseRedirect ( &apos; / error / &apos; )
DCSP global CONFIG DCNL DCSP CONFIG = Configuration ( ) DCNL DCSP parse _ config ( )
DCSP if ( not s ) : DCNL DCSP DCSP return &quot; &apos; &apos; &quot; DCNL DCSP if ( _ find _ unsafe ( s ) is None ) : DCNL DCSP DCSP return s DCNL DCSP return ( ( &quot; &apos; &quot; + s.replace ( &quot; &apos; &quot; , &apos; \ &apos; &quot; \ &apos; &quot; \ &apos; &apos; ) ) + &quot; &apos; &quot; )
DCSP if ( percent is not None ) : DCNL DCSP DCSP interval = PercentileInterval ( percent ) DCNL DCSP elif ( ( min _ percent is not None ) or ( max _ percent is not None ) ) : DCNL DCSP DCSP interval = AsymmetricPercentileInterval ( ( min _ percent or 0.0 ) , ( max _ percent or 100.0 ) ) DCNL DCSP elif ( ( min _ cut is not None ) or ( max _ cut is not None ) ) : DCNL DCSP DCSP interval = ManualInterval ( min _ cut , max _ cut ) DCNL DCSP else : DCNL DCSP DCSP interval = MinMaxInterval ( ) DCNL DCSP if ( stretch = = &apos; linear &apos; ) : DCNL DCSP DCSP stretch = LinearStretch ( ) DCNL DCSP elif ( stretch = = &apos; sqrt &apos; ) : DCNL DCSP DCSP stretch = SqrtStretch ( ) DCNL DCSP elif ( stretch = = &apos; power &apos; ) : DCNL DCSP DCSP stretch = PowerStretch ( power ) DCNL DCSP elif ( stretch = = &apos; log &apos; ) : DCNL DCSP DCSP stretch = LogStretch ( ) DCNL DCSP elif ( stretch = = &apos; asinh &apos; ) : DCNL DCSP DCSP stretch = AsinhStretch ( asinh _ a ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Unknown DCSP stretch : DCSP { 0 } . &apos; .format ( stretch ) ) DCNL DCSP ( vmin , vmax ) = interval.get _ limits ( data ) DCNL DCSP return ImageNormalize ( vmin = vmin , vmax = vmax , stretch = stretch , clip = clip )
DCSP if ( not user ) : DCNL DCSP DCSP user = frappe.session.user DCNL DCSP cache _ key = ( meta.name , user ) DCNL DCSP if ( not frappe.local.role _ permissions.get ( cache _ key ) ) : DCNL DCSP DCSP perms = frappe . _ dict ( apply _ user _ permissions = { } , user _ permission _ doctypes = { } , if _ owner = { } ) DCNL DCSP DCSP user _ roles = frappe.get _ roles ( user ) DCNL DCSP DCSP dont _ match = &#91; &#93; DCNL DCSP DCSP has _ a _ role _ with _ apply _ user _ permissions = False DCNL DCSP DCSP for p in meta.permissions : DCNL DCSP DCSP DCSP if ( ( cint ( p.permlevel ) = = 0 ) and ( p.role in user _ roles ) ) : DCNL DCSP DCSP DCSP DCSP for ptype in rights : DCNL DCSP DCSP DCSP DCSP DCSP perms &#91; ptype &#93; = ( perms.get ( ptype , 0 ) or cint ( p.get ( ptype ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( ptype ! = u &apos;set _ user _ permissions &apos; ) and p.get ( ptype ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP perms &#91; u &apos;apply _ user _ permissions &apos; &#93; &#91; ptype &#93; = ( perms &#91; u &apos;apply _ user _ permissions &apos; &#93; .get ( ptype , 1 ) and p.get ( u &apos;apply _ user _ permissions &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP if ( p.if _ owner and p.get ( ptype ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP perms &#91; u &apos;if _ owner &apos; &#93; &#91; ptype &#93; = 1 DCNL DCSP DCSP DCSP DCSP DCSP if ( p.get ( ptype ) and ( not p.if _ owner ) and ( not p.get ( u &apos;apply _ user _ permissions &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP dont _ match.append ( ptype ) DCNL DCSP DCSP DCSP DCSP if p.apply _ user _ permissions : DCNL DCSP DCSP DCSP DCSP DCSP has _ a _ role _ with _ apply _ user _ permissions = True DCNL DCSP DCSP DCSP DCSP DCSP if p.user _ permission _ doctypes : DCNL DCSP DCSP DCSP DCSP DCSP DCSP user _ permission _ doctypes = json.loads ( p.user _ permission _ doctypes ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP user _ permission _ doctypes = get _ linked _ doctypes ( meta.name ) DCNL DCSP DCSP DCSP DCSP DCSP if user _ permission _ doctypes : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for ptype in rights : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if p.get ( ptype ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP perms &#91; u &apos;user _ permission _ doctypes &apos; &#93; .setdefault ( ptype , &#91; &#93; ) .append ( user _ permission _ doctypes ) DCNL DCSP DCSP for ptype in rights : DCNL DCSP DCSP DCSP if ( ptype in dont _ match ) : DCNL DCSP DCSP DCSP DCSP if perms &#91; u &apos;apply _ user _ permissions &apos; &#93; .get ( ptype ) : DCNL DCSP DCSP DCSP DCSP DCSP del perms &#91; u &apos;apply _ user _ permissions &apos; &#93; &#91; ptype &#93; DCNL DCSP DCSP DCSP DCSP if perms &#91; u &apos;if _ owner &apos; &#93; .get ( ptype ) : DCNL DCSP DCSP DCSP DCSP DCSP del perms &#91; u &apos;if _ owner &apos; &#93; &#91; ptype &#93; DCNL DCSP DCSP if has _ a _ role _ with _ apply _ user _ permissions : DCNL DCSP DCSP DCSP for ptype in rights : DCNL DCSP DCSP DCSP DCSP if ( perms &#91; u &apos;if _ owner &apos; &#93; .get ( ptype ) and ( perms &#91; u &apos;apply _ user _ permissions &apos; &#93; .get ( ptype ) = = 0 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP perms &#91; u &apos;apply _ user _ permissions &apos; &#93; &#91; ptype &#93; = 1 DCNL DCSP DCSP for ( key , value ) in perms.get ( u &apos;apply _ user _ permissions &apos; ) .items ( ) : DCNL DCSP DCSP DCSP if ( not value ) : DCNL DCSP DCSP DCSP DCSP del perms &#91; u &apos;apply _ user _ permissions &apos; &#93; &#91; key &#93; DCNL DCSP DCSP frappe.local.role _ permissions &#91; cache _ key &#93; = perms DCNL DCSP return frappe.local.role _ permissions &#91; cache _ key &#93;
DCSP from sklearn.metrics import confusion _ matrix , f1 _ score , accuracy _ score DCNL DCSP c _ mat = confusion _ matrix ( y _ test , y _ predict , labels = &#91; x for x in range ( n _ classes ) &#93; ) DCNL DCSP f1 = f1 _ score ( y _ test , y _ predict , average = None , labels = &#91; x for x in range ( n _ classes ) &#93; ) DCNL DCSP f1 _ macro = f1 _ score ( y _ test , y _ predict , average = &apos; macro &apos; ) DCNL DCSP acc = accuracy _ score ( y _ test , y _ predict ) DCNL DCSP print ( &apos; confusion DCSP matrix : DCSP \ n &apos; , c _ mat ) DCNL DCSP print ( &apos; f1-score : &apos; , f1 ) DCNL DCSP print ( &apos; f1-score ( macro ) : &apos; , f1 _ macro ) DCNL DCSP print ( &apos; accuracy-score : &apos; , acc ) DCNL DCSP return ( c _ mat , f1 , acc , f1 _ macro )
DCSP resource _ def = config.DOMAIN &#91; resource &#93; DCNL DCSP fields = &#91; resource _ def &#91; &apos; id _ field &apos; &#93; , config.LAST _ UPDATED , config.DATE _ CREATED , config.ETAG &#93; DCNL DCSP fields + = &#91; config.ISSUES , config.STATUS , config.LINKS &#93; DCNL DCSP if ( resource _ def &#91; &apos; versioning &apos; &#93; is True ) : DCNL DCSP DCSP fields.append ( config.VERSION ) DCNL DCSP DCSP fields.append ( config.LATEST _ VERSION ) DCNL DCSP DCSP fields.append ( ( resource _ def &#91; &apos; id _ field &apos; &#93; + config.VERSION _ ID _ SUFFIX ) ) DCNL DCSP if ( resource _ def &#91; &apos; soft _ delete &apos; &#93; is True ) : DCNL DCSP DCSP fields.append ( config.DELETED ) DCNL DCSP return fields
DCSP try : DCNL DCSP DCSP import setuptools DCNL DCSP DCSP if ( setuptools . _ _ version _ _ = = &apos; 0.0.1 &apos; ) : DCNL DCSP DCSP DCSP print &gt; &gt; sys.stderr , &apos; You DCSP have DCSP an DCSP obsolete DCSP version DCSP of DCSP setuptools DCSP installed . DCSP DCSP Please \ nremove DCSP it DCSP from DCSP your DCSP system DCSP entirely DCSP before DCSP rerunning DCSP this DCSP script . &apos; DCNL DCSP DCSP DCSP sys.exit ( 2 ) DCNL DCSP except ImportError : DCNL DCSP DCSP egg = download _ setuptools ( version , download _ base , to _ dir ) DCNL DCSP DCSP sys.path.insert ( 0 , egg ) DCNL DCSP DCSP import setuptools DCNL DCSP DCSP setuptools.bootstrap _ install _ from = egg DCNL DCSP import pkg _ resources DCNL DCSP try : DCNL DCSP DCSP pkg _ resources.require ( ( &apos; setuptools &gt; = &apos; + version ) ) DCNL DCSP except pkg _ resources.VersionConflict : DCNL DCSP DCSP print &gt; &gt; sys.stderr , ( &quot; The DCSP required DCSP version DCSP of DCSP setuptools DCSP ( &gt; = % s ) DCSP is DCSP not DCSP available , DCSP and \ ncan &apos;t DCSP be DCSP installed DCSP while DCSP this DCSP script DCSP is DCSP running . DCSP Please DCSP install \ n DCSP a DCSP more DCSP recent DCSP version DCSP first . &quot; % version ) DCNL DCSP DCSP sys.exit ( 2 )
DCSP global _ setup _ stop _ after , _ setup _ distribution DCNL DCSP klass = attrs.get ( &apos; distclass &apos; ) DCNL DCSP if klass : DCNL DCSP DCSP del attrs &#91; &apos; distclass &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP klass = Distribution DCNL DCSP if ( &apos; script _ name &apos; not in attrs ) : DCNL DCSP DCSP attrs &#91; &apos; script _ name &apos; &#93; = os.path.basename ( sys.argv &#91; 0 &#93; ) DCNL DCSP if ( &apos; script _ args &apos; not in attrs ) : DCNL DCSP DCSP attrs &#91; &apos; script _ args &apos; &#93; = sys.argv &#91; 1 : &#93; DCNL DCSP try : DCNL DCSP DCSP _ setup _ distribution = dist = klass ( attrs ) DCNL DCSP except DistutilsSetupError as msg : DCNL DCSP DCSP if ( &apos; name &apos; not in attrs ) : DCNL DCSP DCSP DCSP raise SystemExit ( ( &apos; error DCSP in DCSP setup DCSP command : DCSP % s &apos; % msg ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise SystemExit ( ( &apos; error DCSP in DCSP % s DCSP setup DCSP command : DCSP % s &apos; % ( attrs &#91; &apos; name &apos; &#93; , msg ) ) ) DCNL DCSP if ( _ setup _ stop _ after = = &apos; init &apos; ) : DCNL DCSP DCSP return dist DCNL DCSP dist.parse _ config _ files ( ) DCNL DCSP if DEBUG : DCNL DCSP DCSP print &apos; options DCSP ( after DCSP parsing DCSP config DCSP files ) : &apos; DCNL DCSP DCSP dist.dump _ option _ dicts ( ) DCNL DCSP if ( _ setup _ stop _ after = = &apos; config &apos; ) : DCNL DCSP DCSP return dist DCNL DCSP try : DCNL DCSP DCSP ok = dist.parse _ command _ line ( ) DCNL DCSP except DistutilsArgError as msg : DCNL DCSP DCSP raise SystemExit ( ( gen _ usage ( dist.script _ name ) + ( &apos; \ nerror : DCSP % s &apos; % msg ) ) ) DCNL DCSP if DEBUG : DCNL DCSP DCSP print &apos; options DCSP ( after DCSP parsing DCSP command DCSP line ) : &apos; DCNL DCSP DCSP dist.dump _ option _ dicts ( ) DCNL DCSP if ( _ setup _ stop _ after = = &apos; commandline &apos; ) : DCNL DCSP DCSP return dist DCNL DCSP if ok : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP dist.run _ commands ( ) DCNL DCSP DCSP except KeyboardInterrupt : DCNL DCSP DCSP DCSP raise SystemExit ( &apos; interrupted &apos; ) DCNL DCSP DCSP except OSError as exc : DCNL DCSP DCSP DCSP if DEBUG : DCNL DCSP DCSP DCSP DCSP sys.stderr.write ( ( &apos; error : DCSP % s \ n &apos; % ( exc , ) ) ) DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise SystemExit ( ( &apos; error : DCSP % s &apos; % ( exc , ) ) ) DCNL DCSP DCSP except ( DistutilsError , CCompilerError ) as msg : DCNL DCSP DCSP DCSP if DEBUG : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise SystemExit ( ( &apos; error : DCSP &apos; + str ( msg ) ) ) DCNL DCSP return dist
DCSP if hasattr ( request , &apos; _ messages &apos; ) : DCNL DCSP DCSP return request . _ messages DCNL DCSP def get _ user ( ) : DCNL DCSP DCSP if hasattr ( request , &apos; user &apos; ) : DCNL DCSP DCSP DCSP return request.user DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP from django.contrib.auth.models import AnonymousUser DCNL DCSP DCSP DCSP return AnonymousUser ( ) DCNL DCSP return lazy ( memoize ( get _ user ( ) .get _ and _ delete _ messages , { } , 0 ) , list ) ( )
DCSP if salt.utils.which ( &apos; mfsgetgoal &apos; ) : DCNL DCSP DCSP return &apos; moosefs &apos; DCNL DCSP return ( False , &apos; The DCSP moosefs DCSP execution DCSP module DCSP cannot DCSP be DCSP loaded : DCSP the DCSP mfsgetgoal DCSP binary DCSP is DCSP not DCSP in DCSP the DCSP path . &apos; )
DCSP operation _ model = service _ model.operation _ model ( batch _ action _ model.request.operation ) DCNL DCSP ignore _ params = get _ resource _ ignore _ params ( batch _ action _ model.request.params ) DCNL DCSP example _ return _ value = &apos; response &apos; DCNL DCSP if batch _ action _ model.resource : DCNL DCSP DCSP example _ return _ value = xform _ name ( batch _ action _ model.resource.type ) DCNL DCSP example _ resource _ name = xform _ name ( resource _ name ) DCNL DCSP if ( service _ model.service _ name = = resource _ name ) : DCNL DCSP DCSP example _ resource _ name = resource _ name DCNL DCSP example _ prefix = ( &apos; % s DCSP = DCSP % s . % s . % s &apos; % ( example _ return _ value , example _ resource _ name , collection _ model.name , batch _ action _ model.name ) ) DCNL DCSP document _ model _ driven _ resource _ method ( section = section , method _ name = batch _ action _ model.name , operation _ model = operation _ model , event _ emitter = event _ emitter , method _ description = operation _ model.documentation , example _ prefix = example _ prefix , exclude _ input = ignore _ params , resource _ action _ model = batch _ action _ model , include _ signature = include _ signature )
DCSP ( word , tag ) = tagged _ token DCNL DCSP if ( tag is None ) : DCNL DCSP DCSP return word DCNL DCSP else : DCNL DCSP DCSP assert ( sep not in tag ) , &apos; tag DCSP may DCSP not DCSP contain DCSP sep ! &apos; DCNL DCSP DCSP return ( &apos; % s % s % s &apos; % ( word , sep , tag ) )
DCSP sa = CLOSE _ ENOUGH _ FIX _ RE.sub ( &apos; &apos; , six.text _ type ( sa ) ) .lower ( ) DCNL DCSP sb = CLOSE _ ENOUGH _ FIX _ RE.sub ( &apos; &apos; , six.text _ type ( sb ) ) .lower ( ) DCNL DCSP return ( sa = = sb )
DCSP user _ id _ digest = _ MD5 _ FUNC ( email.lower ( ) ) .digest ( ) DCNL DCSP user _ id = ( &apos; 1&apos; + &apos; &apos;.join ( &#91; ( &apos; % 02d &apos; % ord ( x ) ) for x in user _ id _ digest &#93; ) &#91; : 20 &#93; ) DCNL DCSP return user _ id
DCSP return requests.Session ( ) .cache
DCSP app = ( app or webapp2.get _ app ( ) ) DCNL DCSP app.registry &#91; key &#93; = store
DCSP capabilities = _ capabilities _ defaults.copy ( ) DCNL DCSP capabilities.update ( _ registered _ capabilities ) DCNL DCSP return { u &apos;product &apos; : { u &apos;name &apos; : u &apos;Review DCSP Board &apos; , u &apos;version &apos; : get _ version _ string ( ) , u &apos;package _ version &apos; : get _ package _ version ( ) , u &apos;is _ release &apos; : is _ release ( ) } , u &apos;site &apos; : { u &apos;url &apos; : get _ server _ url ( request = request ) , u &apos;administrators &apos; : &#91; { u &apos;name &apos; : name , u &apos;email &apos; : email } for ( name , email ) in settings.ADMINS &#93; , u &apos;time _ zone &apos; : settings.TIME _ ZONE } , u &apos;capabilities &apos; : capabilities }
DCSP close _ profit = 0 DCNL DCSP equities = &#91; &#93; DCNL DCSP cashes = &#91; &#93; DCNL DCSP dts = &#91; &#93; DCNL DCSP trans _ entries = map ( ( lambda x : ( x + datetime.timedelta ( minutes = 1 ) ) ) , cover _ entries ) DCNL DCSP bprice = None DCNL DCSP prelow = data.low &#91; 0 &#93; DCNL DCSP for ( dt , low ) in data.low.iteritems ( ) : DCNL DCSP DCSP close = data.close &#91; dt &#93; DCNL DCSP DCSP if ( dt.time ( ) = = buy1 ) : DCNL DCSP DCSP DCSP bprice = ( close * ( 1 - settings &#91; &apos; future _ commission &apos; &#93; ) ) DCNL DCSP DCSP elif ( bprice and ( dt in trans _ entries ) ) : DCNL DCSP DCSP DCSP close _ profit - = ( ( ( ( prelow - OFFSET ) * ( 1 + settings &#91; &apos; future _ commission &apos; &#93; ) ) - bprice ) * volume _ multiple ) DCNL DCSP DCSP DCSP bprice = None DCNL DCSP DCSP elif ( ( dt = = data.index &#91; ( -1 ) &#93; ) or ( dt.time ( ) = = sell3 ) ) : DCNL DCSP DCSP DCSP if bprice : DCNL DCSP DCSP DCSP DCSP close _ profit - = ( ( ( close * ( 1 + settings &#91; &apos; future _ commission &apos; &#93; ) ) - bprice ) * volume _ multiple ) DCNL DCSP DCSP DCSP bprice = None DCNL DCSP DCSP pos _ profit = 0 DCNL DCSP DCSP posmargin = 0 DCNL DCSP DCSP if bprice : DCNL DCSP DCSP DCSP pos _ profit - = ( ( close - bprice ) * volume _ multiple ) DCNL DCSP DCSP DCSP posmargin = ( ( close * volume _ multiple ) * short _ margin ) DCNL DCSP DCSP equities.append ( ( ( close _ profit + pos _ profit ) + capital ) ) DCNL DCSP DCSP cashes.append ( ( equities &#91; ( -1 ) &#93; - posmargin ) ) DCNL DCSP DCSP dts.append ( dt ) DCNL DCSP DCSP prelow = low DCNL DCSP return ( equities , cashes , dts )
DCSP if ( ( outdim &lt; 1 ) or ( ( outdim &gt; 1 ) and ( outdim &gt; x.ndim ) ) ) : DCNL DCSP DCSP raise ValueError ( ( &apos; outdim DCSP % s DCSP out DCSP of DCSP bound DCSP &#91; 1 , DCSP % d ) &apos; % ( outdim , ( x.ndim + 1 ) ) ) ) DCNL DCSP if ( outdim &gt; 1 ) : DCNL DCSP DCSP dims = ( tuple ( x.shape &#91; : ( outdim - 1 ) &#93; ) + ( ( -1 ) , ) ) DCNL DCSP else : DCNL DCSP DCSP dims = ( ( -1 ) , ) DCNL DCSP x _ reshaped = x.reshape ( dims ) DCNL DCSP bcast _ kept _ dims = x.broadcastable &#91; : ( outdim - 1 ) &#93; DCNL DCSP bcast _ new _ dim = python _ all ( x.broadcastable &#91; ( outdim - 1 ) : &#93; ) DCNL DCSP broadcastable = ( bcast _ kept _ dims + ( bcast _ new _ dim , ) ) DCNL DCSP x _ reshaped = theano.tensor.addbroadcast ( x _ reshaped , * filter ( ( lambda i : broadcastable &#91; i &#93; ) , range ( outdim ) ) ) DCNL DCSP return x _ reshaped
DCSP return distros _ for _ location ( normalize _ path ( filename ) , os.path.basename ( filename ) , metadata )
DCSP return ( ( int ( port ) , factory ) , { &apos; interface &apos; : interface , &apos; backlog &apos; : int ( backlog ) } )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP show _ snapshot DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP if ( ( not kwargs ) or ( &apos; name &apos; not in kwargs ) ) : DCNL DCSP DCSP log.error ( &apos; Must DCSP specify DCSP name . &apos; ) DCNL DCSP DCSP return False DCNL DCSP conn = get _ conn ( ) DCNL DCSP return _ expand _ item ( conn.ex _ get _ snapshot ( kwargs &#91; &apos; name &apos; &#93; ) )
DCSP ( pre _ snapshot , post _ snapshot ) = _ get _ jid _ snapshots ( jid , config = config ) DCNL DCSP return diff ( config , num _ pre = pre _ snapshot , num _ post = post _ snapshot )
DCSP luns = client.get _ volume _ mappings _ for _ host ( host &#91; &apos; hostRef &apos; &#93; ) DCNL DCSP return ( len ( luns ) &gt; = utils.MAX _ LUNS _ PER _ HOST )
DCSP STATICFILES _ DIRS = &#91; &#93; DCNL DCSP HORIZON _ CONFIG &#91; &apos; xstatic _ lib _ files &apos; &#93; = &#91; &#93; DCNL DCSP for ( module _ name , files ) in XSTATIC _ MODULES : DCNL DCSP DCSP module = import _ module ( module _ name ) DCNL DCSP DCSP if ( module _ name = = &apos; xstatic.pkg.jquery _ ui &apos; ) : DCNL DCSP DCSP DCSP if module.VERSION.startswith ( &apos; 1.10 . &apos; ) : DCNL DCSP DCSP DCSP DCSP files = &#91; ( &apos; ui / &apos; + files &#91; 0 &#93; ) &#93; DCNL DCSP DCSP STATICFILES _ DIRS.append ( ( ( &apos; horizon / lib / &apos; + module.NAME ) , module.BASE _ DIR ) ) DCNL DCSP DCSP if hasattr ( module , &apos; MAIN &apos; ) : DCNL DCSP DCSP DCSP files = module.MAIN DCNL DCSP DCSP DCSP if ( not isinstance ( files , list ) ) : DCNL DCSP DCSP DCSP DCSP files = &#91; files &#93; DCNL DCSP DCSP DCSP files = &#91; file for file in files if file.endswith ( &apos; .js &apos; ) &#93; DCNL DCSP DCSP for file in files : DCNL DCSP DCSP DCSP file = ( ( ( &apos; horizon / lib / &apos; + module.NAME ) + &apos; / &apos; ) + file ) DCNL DCSP DCSP DCSP HORIZON _ CONFIG &#91; &apos; xstatic _ lib _ files &apos; &#93; .append ( file ) DCNL DCSP return STATICFILES _ DIRS
DCSP n = dict ( ) DCNL DCSP for key in keys : DCNL DCSP DCSP if ( key in d ) : DCNL DCSP DCSP DCSP n &#91; key &#93; = d &#91; key &#93; DCNL DCSP return n
DCSP return ( &apos; search . % s ( % s ) &apos; % ( class _ instance . _ _ class _ _ . _ _ name _ _ , &apos; , DCSP &apos; .join ( &#91; ( &quot; % s = &apos; % s &apos; &quot; % ( key , value ) ) for ( key , value ) in ordered _ dictionary if value &#93; ) ) )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : None , &apos; comment &apos; : &apos; &apos; } DCNL DCSP target = _ _ salt _ _ &#91; &apos; github.get _ team &apos; &#93; ( name , profile = profile , * * kwargs ) DCNL DCSP if ( not target ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Team DCSP { 0 } DCSP does DCSP not DCSP exist &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Team DCSP { 0 } DCSP will DCSP be DCSP deleted &apos; .format ( name ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP result = _ _ salt _ _ &#91; &apos; github.remove _ team &apos; &#93; ( name , profile = profile , * * kwargs ) DCNL DCSP DCSP if result : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Deleted DCSP team DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; old &apos; , &apos; Team DCSP { 0 } DCSP exists &apos; .format ( name ) ) DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; new &apos; , &apos; Team DCSP { 0 } DCSP deleted &apos; .format ( name ) ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP delete DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP return ret
DCSP if ( objects is None ) : DCNL DCSP DCSP objects = gc.get _ objects ( ) DCNL DCSP try : DCNL DCSP DCSP if ( &apos; .&apos; in typename ) : DCNL DCSP DCSP DCSP return sum ( ( 1 for o in objects if ( _ long _ typename ( o ) = = typename ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return sum ( ( 1 for o in objects if ( _ short _ typename ( o ) = = typename ) ) ) DCNL DCSP finally : DCNL DCSP DCSP del objects
DCSP mappings = df &#91; list ( mapping _ columns ) &#93; DCNL DCSP ambigious = { } DCNL DCSP for symbol in mappings.symbol.unique ( ) : DCNL DCSP DCSP persymbol = mappings &#91; ( mappings.symbol = = symbol ) &#93; DCNL DCSP DCSP intersections = list ( intersecting _ ranges ( map ( from _ tuple , zip ( persymbol.start _ date , persymbol.end _ date ) ) ) ) DCNL DCSP DCSP if intersections : DCNL DCSP DCSP DCSP ambigious &#91; symbol &#93; = ( intersections , persymbol &#91; &#91; &apos; start _ date &apos; , &apos; end _ date &apos; &#93; &#93; .astype ( &apos; datetime64 &#91; ns &#93; &apos; ) ) DCNL DCSP if ambigious : DCNL DCSP DCSP raise ValueError ( ( &apos; Ambiguous DCSP ownership DCSP for DCSP % d DCSP symbol % s , DCSP multiple DCSP assets DCSP held DCSP the DCSP following DCSP symbols : \ n % s &apos; % ( len ( ambigious ) , ( &apos; &apos; if ( len ( ambigious ) = = 1 ) else &apos; s &apos; ) , &apos; \ n &apos; .join ( ( ( &apos; % s : \ n DCSP DCSP intersections : DCSP % s \ n DCSP DCSP % s &apos; % ( symbol , tuple ( map ( _ format _ range , intersections ) ) , &apos; \ n DCSP DCSP &apos; .join ( str ( df ) .splitlines ( ) ) ) ) for ( symbol , ( intersections , df ) ) in sorted ( ambigious.items ( ) , key = first ) ) ) ) ) ) DCNL DCSP return ( df.groupby ( level = 0 ) .apply ( _ check _ asset _ group ) , df &#91; list ( mapping _ columns ) &#93; )
DCSP default = ( { } if ( not list _ ) else &#91; &#93; ) DCNL DCSP existing = destination.settings.get ( setting , default ) DCNL DCSP if value : DCNL DCSP DCSP if list _ : DCNL DCSP DCSP DCSP value.extend ( existing ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP value.update ( existing ) DCNL DCSP DCSP set _ cache ( ( ( key _ prefix + &apos; .&apos; ) + setting ) , value , ttl ) DCNL DCSP DCSP destination.settings &#91; setting &#93; = value
DCSP if ( dist = = &apos; bdist &apos; ) : DCNL DCSP DCSP if ( os.sys.platform = = &apos; darwin &apos; ) : DCNL DCSP DCSP DCSP ( OSXver , junk , architecture ) = platform.mac _ ver ( ) DCNL DCSP DCSP DCSP systemInfo = ( &apos; OSX _ % s _ % s &apos; % ( OSXver , architecture ) ) DCNL DCSP DCSP elif ( os.sys.platform = = &apos; linux &apos; ) : DCNL DCSP DCSP DCSP systemInfo = ( &apos; % s _ % s _ % s &apos; % ( &apos; Linux &apos; , &apos; : &apos; .join ( &#91; x for x in platform.dist ( ) if ( x ! = &apos; &apos; ) &#93; ) , platform.release ( ) ) ) DCNL DCSP DCSP elif ( os.sys.platform = = &apos; win32 &apos; ) : DCNL DCSP DCSP DCSP ver = os.sys.getwindowsversion ( ) DCNL DCSP DCSP DCSP if ( len ( ver &#91; 4 &#93; ) &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP systemInfo = ( &apos; win32 _ v % i . % i . % i DCSP ( % s ) &apos; % ( ver &#91; 0 &#93; , ver &#91; 1 &#93; , ver &#91; 2 &#93; , ver &#91; 4 &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP systemInfo = ( &apos; win32 _ v % i . % i . % i &apos; % ( ver &#91; 0 &#93; , ver &#91; 1 &#93; , ver &#91; 2 &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP systemInfo = ( platform.system ( ) + platform.release ( ) ) DCNL DCSP else : DCNL DCSP DCSP systemInfo = &apos; n / a &apos; DCNL DCSP return systemInfo
DCSP TOPIC _ NAME = ( &apos; topic _ publish _ messages- % d &apos; % ( _ millis ( ) , ) ) DCNL DCSP topic = client.topic ( TOPIC _ NAME ) DCNL DCSP topic.create ( ) DCNL DCSP to _ delete.append ( topic ) DCNL DCSP topic.publish ( &apos; This DCSP is DCSP the DCSP message DCSP payload &apos; ) DCNL DCSP topic.publish ( &apos; Another DCSP message DCSP payload &apos; , extra = &apos; EXTRA &apos; )
DCSP return simulate _ request ( app , &apos; HEAD &apos; , path , * * kwargs )
DCSP problems = OrderedDict ( ) DCNL DCSP for ( name , problem _ class ) in inspect.getmembers ( sys.modules &#91; _ _ name _ _ &#93; , inspect.isclass ) : DCNL DCSP DCSP if ( ( name ! = &apos; LSQBenchmarkProblem &apos; ) and issubclass ( problem _ class , LSQBenchmarkProblem ) and hasattr ( problem _ class , &apos; INITIAL _ GUESSES &apos; ) ) : DCNL DCSP DCSP DCSP for ( i , x0 ) in enumerate ( problem _ class.INITIAL _ GUESSES ) : DCNL DCSP DCSP DCSP DCSP if ( len ( problem _ class.INITIAL _ GUESSES ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP key _ name = &apos; { 0 } _ { 1 } &apos; .format ( name , i ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP key _ name = name DCNL DCSP DCSP DCSP DCSP problems &#91; key _ name &#93; = problem _ class ( x0 ) DCNL DCSP return problems
DCSP can _ compile ( u &apos; ( cons DCSP a DCSP b ) &apos; )
DCSP if os.path.isdir ( source ) : DCNL DCSP DCSP shutil.rmtree ( source ) DCNL DCSP elif ( os.path.isfile ( source ) or os.path.islink ( source ) ) : DCNL DCSP DCSP os.remove ( source )
DCSP return ( isinstance ( element , basestring ) and ( element in DOMAIN _ OPERATORS ) )
DCSP show _ raw = ( params.get ( &apos; raw &apos; , False ) is not False ) DCNL DCSP no _ macros = ( params.get ( &apos; nomacros &apos; , False ) is not False ) DCNL DCSP force _ macros = ( params.get ( &apos; macros &apos; , False ) is not False ) DCNL DCSP is _ template = False DCNL DCSP if doc : DCNL DCSP DCSP is _ template = doc.is _ template DCNL DCSP DCSP html = doc.html DCNL DCSP return ( ( config.KUMASCRIPT _ TIMEOUT &gt; 0 ) and html and ( not is _ template ) and ( force _ macros or ( ( not no _ macros ) and ( not show _ raw ) ) ) )
DCSP text = &apos; \ nA , B , C \ n1,2,3 \ n4,5 \ n6,7,8 \ n &apos; DCNL DCSP table = read _ csv ( text , parallel = parallel ) DCNL DCSP assert ( table &#91; &apos; B &apos; &#93; &#91; 1 &#93; is not ma.masked ) DCNL DCSP assert ( table &#91; &apos; C &apos; &#93; &#91; 1 &#93; is ma.masked ) DCNL DCSP with pytest.raises ( CParserError ) as e : DCNL DCSP DCSP table = FastBasic ( delimiter = &apos; , &apos; ) .read ( text )
DCSP namespace = namespace.lower ( ) DCNL DCSP try : DCNL DCSP DCSP return searchresult ( namespace , name.lower ( ) , NAMESPACES &#91; namespace &#93; &#91; name.lower ( ) &#93; ) DCNL DCSP except KeyError : DCNL DCSP DCSP for ( ns , opts ) in items ( NAMESPACES ) : DCNL DCSP DCSP DCSP if ( ns.lower ( ) = = name.lower ( ) ) : DCNL DCSP DCSP DCSP DCSP return searchresult ( None , ns , opts ) DCNL DCSP DCSP DCSP elif isinstance ( opts , dict ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP return searchresult ( ns , name.lower ( ) , opts &#91; name.lower ( ) &#93; ) DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP return searchresult ( None , name.lower ( ) , DEFAULTS &#91; name.lower ( ) &#93; )
DCSP shape = a.shape DCNL DCSP if ( axis &lt; 0 ) : DCNL DCSP DCSP axis = ( ( axis + len ( shape ) ) + 1 ) DCNL DCSP return a.reshape ( ( ( shape &#91; : axis &#93; + ( 1 , ) ) + shape &#91; axis : &#93; ) )
DCSP volinfo = info ( ) DCNL DCSP if ( target not in volinfo ) : DCNL DCSP DCSP log.error ( &apos; Cannot DCSP delete DCSP non-existing DCSP volume DCSP { 0 } &apos; .format ( target ) ) DCNL DCSP DCSP return False DCNL DCSP running = ( volinfo &#91; target &#93; &#91; &apos; status &apos; &#93; = = &apos; 1&apos; ) DCNL DCSP if ( ( not stop ) and running ) : DCNL DCSP DCSP log.error ( &apos; Volume DCSP { 0 } DCSP must DCSP be DCSP stopped DCSP before DCSP deletion &apos; .format ( target ) ) DCNL DCSP DCSP return False DCNL DCSP if running : DCNL DCSP DCSP if ( not stop _ volume ( target , force = True ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP cmd = &apos; volume DCSP delete DCSP { 0 } &apos; .format ( target ) DCNL DCSP return _ gluster ( cmd )
DCSP for i in seq : DCNL DCSP DCSP ( yield i )
DCSP subtrees = &#91; &#93; DCNL DCSP for arg in node.args : DCNL DCSP DCSP subtrees.append ( tree ( arg ) ) DCNL DCSP s = ( print _ node ( node ) + pprint _ nodes ( subtrees ) ) DCNL DCSP return s
DCSP signal.signal ( signal.SIGINT , handle _ sigint ) DCNL DCSP signal.pause ( )
DCSP options = datastore _ rpc.TransactionOptions ( retries = retries ) DCNL DCSP return RunInTransactionOptions ( options , function , * args , * * kwargs )
DCSP global SUPPORTED _ ALGORITHM , DIGEST _ AUTH _ ENCODERS DCNL DCSP assert ( algorithm in SUPPORTED _ ALGORITHM ) DCNL DCSP try : DCNL DCSP DCSP encoder = DIGEST _ AUTH _ ENCODERS &#91; algorithm &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise NotImplementedError ( ( &apos; The DCSP chosen DCSP algorithm DCSP ( % s ) DCSP does DCSP not DCSP have DCSP an DCSP implementation DCSP yet &apos; % algorithm ) ) DCNL DCSP return encoder ( ( &apos; % d : % s &apos; % ( time.time ( ) , realm ) ) )
DCSP while True : DCNL DCSP DCSP answer = raw _ input ( question ) .lower ( ) DCNL DCSP DCSP if ( answer in ( &apos; y &apos; , &apos; yes &apos; ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP if ( answer in ( &apos; n &apos; , &apos; no &apos; ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP print error _ response
DCSP r = &#91; I.getName ( ) &#93; DCNL DCSP outp = r.append DCNL DCSP level = 1 DCNL DCSP if I.getDoc ( ) : DCNL DCSP DCSP outp ( _ justify _ and _ indent ( _ trim _ doc _ string ( I.getDoc ( ) ) , level ) ) DCNL DCSP bases = &#91; base for base in I. _ _ bases _ _ if ( base is not zope.interface.Interface ) &#93; DCNL DCSP if bases : DCNL DCSP DCSP outp ( _ justify _ and _ indent ( &apos; This DCSP interface DCSP extends : &apos; , level , munge ) ) DCNL DCSP DCSP level + = 1 DCNL DCSP DCSP for b in bases : DCNL DCSP DCSP DCSP item = ( &apos; o DCSP % s &apos; % b.getName ( ) ) DCNL DCSP DCSP DCSP outp ( _ justify _ and _ indent ( _ trim _ doc _ string ( item ) , level , munge ) ) DCNL DCSP DCSP level - = 1 DCNL DCSP namesAndDescriptions = I.namesAndDescriptions ( ) DCNL DCSP namesAndDescriptions.sort ( ) DCNL DCSP outp ( _ justify _ and _ indent ( &apos; Attributes : &apos; , level , munge ) ) DCNL DCSP level + = 1 DCNL DCSP for ( name , desc ) in namesAndDescriptions : DCNL DCSP DCSP if ( not hasattr ( desc , &apos; getSignatureString &apos; ) ) : DCNL DCSP DCSP DCSP item = ( &apos; % s DCSP -- DCSP % s &apos; % ( desc.getName ( ) , ( desc.getDoc ( ) or &apos; no DCSP documentation &apos; ) ) ) DCNL DCSP DCSP DCSP outp ( _ justify _ and _ indent ( _ trim _ doc _ string ( item ) , level , munge ) ) DCNL DCSP level - = 1 DCNL DCSP outp ( _ justify _ and _ indent ( &apos; Methods : &apos; , level , munge ) ) DCNL DCSP level + = 1 DCNL DCSP for ( name , desc ) in namesAndDescriptions : DCNL DCSP DCSP if hasattr ( desc , &apos; getSignatureString &apos; ) : DCNL DCSP DCSP DCSP item = ( &apos; % s % s DCSP -- DCSP % s &apos; % ( desc.getName ( ) , desc.getSignatureString ( ) , ( desc.getDoc ( ) or &apos; no DCSP documentation &apos; ) ) ) DCNL DCSP DCSP DCSP outp ( _ justify _ and _ indent ( _ trim _ doc _ string ( item ) , level , munge ) ) DCNL DCSP return ( &apos; \ n \ n &apos; .join ( r ) + &apos; \ n \ n &apos; )
DCSP if ( packages _ to _ install = = &#91; &#93; ) : DCNL DCSP DCSP raise RuntimeError ( &apos; &#91; in &#93; DCSP fatal : DCSP need DCSP packages DCSP names DCSP to DCSP install . &apos; ) DCNL DCSP packages _ really _ to _ install = &#91; &#93; DCNL DCSP for this _ package in packages _ to _ install : DCNL DCSP DCSP if os.path.exists ( this _ package ) : DCNL DCSP DCSP DCSP packages _ really _ to _ install.append ( this _ package ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP logger.warning ( &quot; &#91; in &#93; DCSP package DCSP &apos; { 0 } &apos; DCSP not DCSP found &quot; .format ( this _ package ) ) DCNL DCSP if ( packages _ really _ to _ install ! = &#91; &#93; ) : DCNL DCSP DCSP logger.info ( &apos; &#91; in &#93; DCSP The DCSP following DCSP package ( s ) DCSP will DCSP be DCSP installed : &apos; ) DCNL DCSP DCSP packages = &#91; &#93; DCNL DCSP DCSP for this _ package in packages _ really _ to _ install : DCNL DCSP DCSP DCSP packages.append ( corename ( this _ package ) ) DCNL DCSP DCSP logger.info ( &apos; DCSP &apos; .join ( packages ) ) DCNL DCSP DCSP r = input ( &apos; Proceed ? DCSP &#91; yes / N &#93; DCSP &apos; ) DCNL DCSP DCSP if ( ( r = = &apos; y &apos; ) or ( r = = &apos; yes &apos; ) ) : DCNL DCSP DCSP DCSP for this _ package in packages _ really _ to _ install : DCNL DCSP DCSP DCSP DCSP if os.path.exists ( ( dataset _ data _ path + corename ( this _ package ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP r = input ( ( &quot; &#91; in &#93; DCSP &apos; % s &apos; DCSP already DCSP installed , DCSP overwrite ? DCSP &#91; yes / N &#93; DCSP &quot; % corename ( this _ package ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( r ! = &apos; y &apos; ) and ( r ! = &apos; yes &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP logger.info ( &quot; &#91; in &#93; DCSP skipping DCSP package DCSP &apos; { 0 } &apos; &quot; .format ( corename ( this _ package ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP install _ package ( corename ( this _ package ) , this _ package , dataset _ data _ path ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP logger.info ( &quot; &#91; in &#93; DCSP Taking DCSP &apos; { 0 } &apos; DCSP for DCSP no , DCSP so DCSP there . &quot; .format ( r ) )
DCSP try : DCNL DCSP DCSP if ( not os.path.exists ( targetDir ) ) : DCNL DCSP DCSP DCSP os.mkdir ( targetDir ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP def path _ leaf ( path ) : DCNL DCSP DCSP DCSP DCSP ( head , tail ) = os.path.split ( path ) DCNL DCSP DCSP DCSP DCSP return ( tail or os.path.basename ( head ) ) DCNL DCSP DCSP DCSP bakFilename = u &apos; { 0 } - { 1 } &apos; .format ( path _ leaf ( targetDir ) , datetime.datetime.now ( ) .strftime ( u &apos; % Y % m % d _ % H % M % S &apos; ) ) DCNL DCSP DCSP DCSP moveFile ( targetDir , os.path.join ( os.path.dirname ( targetDir ) , bakFilename ) ) DCNL DCSP DCSP with zipfile.ZipFile ( archive , u &apos;r &apos; , allowZip64 = True ) as zip _ file : DCNL DCSP DCSP DCSP for member in zip _ file.namelist ( ) : DCNL DCSP DCSP DCSP DCSP zip _ file.extract ( member , targetDir ) DCNL DCSP DCSP return True DCNL DCSP except Exception as e : DCNL DCSP DCSP sickrage.srCore.srLogger.error ( u &apos;Zip DCSP extraction DCSP error : DCSP { } &apos; .format ( e.message ) ) DCNL DCSP DCSP removetree ( targetDir )
DCSP split = windows _ friendly _ colon _ split ( config _ string ) DCNL DCSP if ( len ( split ) &gt; 1 ) : DCNL DCSP DCSP ( module _ name , object _ name ) = ( &apos; : &apos; .join ( split &#91; : ( -1 ) &#93; ) , split &#91; ( -1 ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP ( module _ name , object _ name ) = ( config _ string , default _ name ) DCNL DCSP module = get _ module ( module _ name ) DCNL DCSP if object _ name : DCNL DCSP DCSP return getattr ( module , object _ name ) DCNL DCSP else : DCNL DCSP DCSP return module
DCSP _ check _ reference ( evoked ) DCNL DCSP if ( ( loose is None ) and ( not is _ fixed _ orient ( forward ) ) ) : DCNL DCSP DCSP forward = deepcopy ( forward ) DCNL DCSP DCSP _ to _ fixed _ ori ( forward ) DCNL DCSP if ( is _ fixed _ orient ( forward ) or ( not xyz _ same _ gamma ) ) : DCNL DCSP DCSP group _ size = 1 DCNL DCSP else : DCNL DCSP DCSP group _ size = 3 DCNL DCSP ( gain , gain _ info , whitener , source _ weighting , mask ) = _ prepare _ gain ( forward , evoked.info , noise _ cov , pca , depth , loose , None , None ) DCNL DCSP sel = &#91; evoked.ch _ names.index ( name ) for name in gain _ info &#91; &apos; ch _ names &apos; &#93; &#93; DCNL DCSP M = evoked.data &#91; sel &#93; DCNL DCSP logger.info ( &apos; Whitening DCSP data DCSP matrix . &apos; ) DCNL DCSP M = np.dot ( whitener , M ) DCNL DCSP ( X , active _ set ) = _ gamma _ map _ opt ( M , gain , alpha , maxit = maxit , tol = tol , update _ mode = update _ mode , gammas = gammas , group _ size = group _ size , verbose = verbose ) DCNL DCSP if ( len ( active _ set ) = = 0 ) : DCNL DCSP DCSP raise Exception ( &apos; No DCSP active DCSP dipoles DCSP found . DCSP alpha DCSP is DCSP too DCSP big . &apos; ) DCNL DCSP n _ dip _ per _ pos = ( 1 if is _ fixed _ orient ( forward ) else 3 ) DCNL DCSP X = _ reapply _ source _ weighting ( X , source _ weighting , active _ set , n _ dip _ per _ pos ) DCNL DCSP if return _ residual : DCNL DCSP DCSP residual = _ compute _ residual ( forward , evoked , X , active _ set , gain _ info ) DCNL DCSP if ( ( group _ size = = 1 ) and ( not is _ fixed _ orient ( forward ) ) ) : DCNL DCSP DCSP active _ src = np.unique ( ( active _ set / / 3 ) ) DCNL DCSP DCSP in _ pos = 0 DCNL DCSP DCSP if ( len ( X ) &lt; ( 3 * len ( active _ src ) ) ) : DCNL DCSP DCSP DCSP X _ xyz = np.zeros ( ( ( 3 * len ( active _ src ) ) , X.shape &#91; 1 &#93; ) , dtype = X.dtype ) DCNL DCSP DCSP DCSP for ii in range ( len ( active _ src ) ) : DCNL DCSP DCSP DCSP DCSP for jj in range ( 3 ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( in _ pos &gt; = len ( active _ set ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP if ( ( ( active _ set &#91; in _ pos &#93; + jj ) % 3 ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP X _ xyz &#91; ( ( 3 * ii ) + jj ) &#93; = X &#91; in _ pos &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP in _ pos + = 1 DCNL DCSP DCSP DCSP X = X _ xyz DCNL DCSP tmin = evoked.times &#91; 0 &#93; DCNL DCSP tstep = ( 1.0 / evoked.info &#91; &apos; sfreq &apos; &#93; ) DCNL DCSP stc = _ make _ sparse _ stc ( X , active _ set , forward , tmin , tstep , active _ is _ idx = True , verbose = verbose ) DCNL DCSP if return _ residual : DCNL DCSP DCSP return ( stc , residual ) DCNL DCSP else : DCNL DCSP DCSP return stc
DCSP conn = _ _ proxy _ _ &#91; &apos; junos.conn &apos; &#93; ( ) DCNL DCSP ret = dict ( ) DCNL DCSP if ( hostname is None ) : DCNL DCSP DCSP ret &#91; &apos; out &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP set _ string = &apos; set DCSP system DCSP host-name DCSP { 0 } &apos; .format ( hostname ) DCNL DCSP conn.cu.load ( set _ string , format = &apos; set &apos; ) DCNL DCSP if commit _ change : DCNL DCSP DCSP return commit ( ) DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; out &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; msg &apos; &#93; = &apos; set DCSP system DCSP host-name DCSP { 0 } DCSP is DCSP queued &apos; .format ( hostname ) DCNL DCSP return ret
DCSP def wrapped _ method ( self , * args , * * dargs ) : DCNL DCSP DCSP already _ have _ lock = ( self . _ backing _ file _ lock is not None ) DCNL DCSP DCSP if ( not already _ have _ lock ) : DCNL DCSP DCSP DCSP self . _ lock _ backing _ file ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return method ( self , * args , * * dargs ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP if ( not already _ have _ lock ) : DCNL DCSP DCSP DCSP DCSP self . _ unlock _ backing _ file ( ) DCNL DCSP wrapped _ method . _ _ name _ _ = method . _ _ name _ _ DCNL DCSP wrapped _ method . _ _ doc _ _ = method . _ _ doc _ _ DCNL DCSP return wrapped _ method
DCSP ( args , defaults ) = ( ( args or &#91; &#93; ) , ( defaults or &#91; &#93; ) ) DCNL DCSP func = Function ( name , doc ) DCNL DCSP func.args = argsnode = Arguments ( ) DCNL DCSP argsnode.args = &#91; &#93; DCNL DCSP for arg in args : DCNL DCSP DCSP argsnode.args.append ( Name ( ) ) DCNL DCSP DCSP argsnode.args &#91; ( -1 ) &#93; .name = arg DCNL DCSP DCSP argsnode.args &#91; ( -1 ) &#93; .parent = argsnode DCNL DCSP argsnode.defaults = &#91; &#93; DCNL DCSP for default in defaults : DCNL DCSP DCSP argsnode.defaults.append ( const _ factory ( default ) ) DCNL DCSP DCSP argsnode.defaults &#91; ( -1 ) &#93; .parent = argsnode DCNL DCSP argsnode.kwarg = None DCNL DCSP argsnode.vararg = None DCNL DCSP argsnode.parent = func DCNL DCSP if args : DCNL DCSP DCSP register _ arguments ( func ) DCNL DCSP return func
DCSP if ( string _ for _ js is None ) : DCNL DCSP DCSP string _ for _ js = &apos; &apos; DCNL DCSP string _ for _ js = decode.utf8 ( string _ for _ js ) DCNL DCSP string _ for _ js = escapejs ( string _ for _ js ) DCNL DCSP return string _ for _ js
DCSP Extension = apps.get _ model ( u &apos;extensions &apos; , u &apos;Extension &apos; ) DCNL DCSP Translation = apps.get _ model ( u &apos;translations &apos; , u &apos;Translation &apos; ) DCNL DCSP extensions = Extension.objects.all ( ) DCNL DCSP for extension in extensions : DCNL DCSP DCSP translations _ ids = filter ( None , &#91; extension.name _ id , extension.description _ id &#93; ) DCNL DCSP DCSP lang = extension.default _ language.lower ( ) DCNL DCSP DCSP Translation.objects.filter ( id _ _ in = translations _ ids ) .update ( locale = lang )
DCSP from twisted.internet import reactor DCNL DCSP ( name , args , kw ) = parse ( description , factory , default ) DCNL DCSP return getattr ( reactor , ( &apos; listen &apos; + name ) ) ( * args , * * kw )
DCSP ros = RandomOverSampler ( random _ state = RND _ SEED ) DCNL DCSP ( X _ resampled , y _ resampled ) = ros.fit _ sample ( X , Y ) DCNL DCSP X _ gt = np.array ( &#91; &#91; 0.04352327 , ( -0.20515826 ) &#93; , &#91; 0.20792588 , 1.49407907 &#93; , &#91; 0.22950086 , 0.33367433 &#93; , &#91; 0.15490546 , 0.3130677 &#93; , &#91; 0.09125309 , ( -0.85409574 ) &#93; , &#91; 0.12372842 , 0.6536186 &#93; , &#91; 0.094035 , ( -2.55298982 ) &#93; , &#91; 0.92923648 , 0.76103773 &#93; , &#91; 0.47104475 , 0.44386323 &#93; , &#91; 0.13347175 , 0.12167502 &#93; , &#91; 0.92923648 , 0.76103773 &#93; , &#91; 0.47104475 , 0.44386323 &#93; , &#91; 0.92923648 , 0.76103773 &#93; , &#91; 0.47104475 , 0.44386323 &#93; &#93; ) DCNL DCSP y _ gt = np.array ( &#91; 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 &#93; ) DCNL DCSP assert _ array _ equal ( X _ resampled , X _ gt ) DCNL DCSP assert _ array _ equal ( y _ resampled , y _ gt )
DCSP diff _ list = _ git _ diff _ names _ only ( current _ release ) DCNL DCSP return &#91; item for item in diff _ list if item.startswith ( &apos; core / storage &apos; ) &#93;
DCSP return stem.interpreter.msg ( &apos; msg.help &apos; , address = DEFAULT _ ARGS &#91; &apos; control _ address &apos; &#93; , port = DEFAULT _ ARGS &#91; &apos; control _ port &apos; &#93; , socket = DEFAULT _ ARGS &#91; &apos; control _ socket &apos; &#93; )
DCSP ch _ 1st = metric _ to _ Christoffel _ 1st ( expr ) DCNL DCSP coord _ sys = expr.atoms ( CoordSystem ) .pop ( ) DCNL DCSP indices = list ( range ( coord _ sys.dim ) ) DCNL DCSP matrix = twoform _ to _ matrix ( expr ) DCNL DCSP s _ fields = set ( ) DCNL DCSP for e in matrix : DCNL DCSP DCSP s _ fields.update ( e.atoms ( BaseScalarField ) ) DCNL DCSP s _ fields = list ( s _ fields ) DCNL DCSP dums = coord _ sys . _ dummies DCNL DCSP matrix = matrix.subs ( list ( zip ( s _ fields , dums ) ) ) .inv ( ) .subs ( list ( zip ( dums , s _ fields ) ) ) DCNL DCSP christoffel = &#91; &#91; &#91; Add ( * &#91; ( matrix &#91; ( i , l ) &#93; * ch _ 1st &#91; ( l , j , k ) &#93; ) for l in indices &#93; ) for k in indices &#93; for j in indices &#93; for i in indices &#93; DCNL DCSP return ImmutableDenseNDimArray ( christoffel )
DCSP options.allowed _ flags ( args , &#91; &apos; frac &apos; , &apos; polys &apos; &#93; ) DCNL DCSP opt = options.build _ options ( gens , args ) DCNL DCSP expr = sympify ( expr ) DCNL DCSP if ( isinstance ( expr , Expr ) and ( not expr.is _ Relational ) ) : DCNL DCSP DCSP ( numer , denom ) = together ( expr ) .as _ numer _ denom ( ) DCNL DCSP DCSP ( cp , fp ) = _ symbolic _ factor _ list ( numer , opt , method ) DCNL DCSP DCSP ( cq , fq ) = _ symbolic _ factor _ list ( denom , opt , method ) DCNL DCSP DCSP if ( fq and ( not opt.frac ) ) : DCNL DCSP DCSP DCSP raise PolynomialError ( ( &apos; a DCSP polynomial DCSP expected , DCSP got DCSP % s &apos; % expr ) ) DCNL DCSP DCSP _ opt = opt.clone ( dict ( expand = True ) ) DCNL DCSP DCSP for factors in ( fp , fq ) : DCNL DCSP DCSP DCSP for ( i , ( f , k ) ) in enumerate ( factors ) : DCNL DCSP DCSP DCSP DCSP if ( not f.is _ Poly ) : DCNL DCSP DCSP DCSP DCSP DCSP ( f , _ ) = _ poly _ from _ expr ( f , _ opt ) DCNL DCSP DCSP DCSP DCSP DCSP factors &#91; i &#93; = ( f , k ) DCNL DCSP DCSP fp = _ sorted _ factors ( fp , method ) DCNL DCSP DCSP fq = _ sorted _ factors ( fq , method ) DCNL DCSP DCSP if ( not opt.polys ) : DCNL DCSP DCSP DCSP fp = &#91; ( f.as _ expr ( ) , k ) for ( f , k ) in fp &#93; DCNL DCSP DCSP DCSP fq = &#91; ( f.as _ expr ( ) , k ) for ( f , k ) in fq &#93; DCNL DCSP DCSP coeff = ( cp / cq ) DCNL DCSP DCSP if ( not opt.frac ) : DCNL DCSP DCSP DCSP return ( coeff , fp ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( coeff , fp , fq ) DCNL DCSP else : DCNL DCSP DCSP raise PolynomialError ( ( &apos; a DCSP polynomial DCSP expected , DCSP got DCSP % s &apos; % expr ) )
DCSP b = event.current _ buffer DCNL DCSP b.accept _ action.validate _ and _ handle ( event.cli , b )
DCSP y _ prob = np.clip ( y _ prob , 1e-10 , ( 1 - 1e-10 ) ) DCNL DCSP if ( y _ prob.shape &#91; 1 &#93; = = 1 ) : DCNL DCSP DCSP y _ prob = np.append ( ( 1 - y _ prob ) , y _ prob , axis = 1 ) DCNL DCSP if ( y _ true.shape &#91; 1 &#93; = = 1 ) : DCNL DCSP DCSP y _ true = np.append ( ( 1 - y _ true ) , y _ true , axis = 1 ) DCNL DCSP return ( ( - np.sum ( ( y _ true * np.log ( y _ prob ) ) ) ) / y _ prob.shape &#91; 0 &#93; )
DCSP from hbmqtt.broker import Broker , BrokerException DCNL DCSP try : DCNL DCSP DCSP passwd = tempfile.NamedTemporaryFile ( ) DCNL DCSP DCSP if ( server _ config is None ) : DCNL DCSP DCSP DCSP ( server _ config , client _ config ) = generate _ config ( hass , passwd ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP client _ config = None DCNL DCSP DCSP broker = Broker ( server _ config , hass.loop ) DCNL DCSP DCSP run _ coroutine _ threadsafe ( broker.start ( ) , hass.loop ) .result ( ) DCNL DCSP except BrokerException : DCNL DCSP DCSP logging.getLogger ( _ _ name _ _ ) .exception ( &apos; Error DCSP initializing DCSP MQTT DCSP server &apos; ) DCNL DCSP DCSP return ( False , None ) DCNL DCSP finally : DCNL DCSP DCSP passwd.close ( ) DCNL DCSP @ callback DCNL DCSP def shutdown _ mqtt _ server ( event ) : DCNL DCSP DCSP &apos; Shut DCSP down DCSP the DCSP MQTT DCSP server . &apos; DCNL DCSP DCSP hass.async _ add _ job ( broker.shutdown ( ) ) DCNL DCSP hass.bus.listen _ once ( EVENT _ HOMEASSISTANT _ STOP , shutdown _ mqtt _ server ) DCNL DCSP return ( True , client _ config )
DCSP exploration = get _ exploration _ by _ id ( exploration _ id , version = version ) DCNL DCSP yaml _ repr = exploration.to _ yaml ( ) DCNL DCSP memfile = StringIO.StringIO ( ) DCNL DCSP with zipfile.ZipFile ( memfile , mode = &apos; w &apos; , compression = zipfile.ZIP _ DEFLATED ) as zfile : DCNL DCSP DCSP zfile.writestr ( ( &apos; % s.yaml &apos; % exploration.title ) , yaml _ repr ) DCNL DCSP DCSP fs = fs _ domain.AbstractFileSystem ( fs _ domain.ExplorationFileSystem ( exploration _ id ) ) DCNL DCSP DCSP dir _ list = fs.listdir ( &apos; &apos; ) DCNL DCSP DCSP for filepath in dir _ list : DCNL DCSP DCSP DCSP file _ contents = fs.get ( filepath , version = 1 ) DCNL DCSP DCSP DCSP str _ filepath = ( &apos; assets / % s &apos; % filepath ) DCNL DCSP DCSP DCSP assert isinstance ( str _ filepath , str ) DCNL DCSP DCSP DCSP unicode _ filepath = str _ filepath.decode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP DCSP zfile.writestr ( unicode _ filepath , file _ contents ) DCNL DCSP return memfile.getvalue ( )
DCSP ndim = len ( x.shape &#91; 2 : &#93; ) DCNL DCSP func = ConvolutionND ( ndim , stride , pad , use _ cudnn , cover _ all ) DCNL DCSP if ( b is None ) : DCNL DCSP DCSP return func ( x , W ) DCNL DCSP else : DCNL DCSP DCSP return func ( x , W , b )
DCSP if ( path = = &apos; &apos; ) : DCNL DCSP DCSP return &apos; .&apos; DCNL DCSP initial _ slashes = path.startswith ( &apos; / &apos; ) DCNL DCSP if ( initial _ slashes and path.startswith ( &apos; / / &apos; ) and ( not path.startswith ( &apos; / / / &apos; ) ) ) : DCNL DCSP DCSP initial _ slashes = 2 DCNL DCSP comps = path.split ( &apos; / &apos; ) DCNL DCSP new _ comps = &#91; &#93; DCNL DCSP for comp in comps : DCNL DCSP DCSP if ( comp in ( &apos; &apos; , &apos; .&apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( ( comp ! = &apos; .. &apos; ) or ( ( not initial _ slashes ) and ( not new _ comps ) ) or ( new _ comps and ( new _ comps &#91; ( -1 ) &#93; = = &apos; .. &apos; ) ) ) : DCNL DCSP DCSP DCSP new _ comps.append ( comp ) DCNL DCSP DCSP elif new _ comps : DCNL DCSP DCSP DCSP new _ comps.pop ( ) DCNL DCSP comps = new _ comps DCNL DCSP path = &apos; / &apos; .join ( comps ) DCNL DCSP if initial _ slashes : DCNL DCSP DCSP path = ( ( &apos; / &apos; * initial _ slashes ) + path ) DCNL DCSP return ( path or &apos; .&apos; )
DCSP _ unmap _ select _ mode _ mapping ( ) DCNL DCSP selection = eval ( &apos; &amp; selection &apos; ) DCNL DCSP col = col2byte ( ( start.line + 1 ) , start.col ) DCNL DCSP vim.current.window.cursor = ( ( start.line + 1 ) , col ) DCNL DCSP mode = eval ( &apos; mode ( ) &apos; ) DCNL DCSP move _ cmd = &apos; &apos; DCNL DCSP if ( mode ! = &apos; n &apos; ) : DCNL DCSP DCSP move _ cmd + = &apos; \ \ &lt; Esc &gt; &apos; DCNL DCSP if ( start = = end ) : DCNL DCSP DCSP if ( ( col = = 0 ) or ( ( mode not in &apos; i &apos; ) and ( col &lt; len ( buf &#91; start.line &#93; ) ) ) ) : DCNL DCSP DCSP DCSP move _ cmd + = &apos; i &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP move _ cmd + = &apos; a &apos; DCNL DCSP else : DCNL DCSP DCSP move _ cmd + = &apos; v &apos; DCNL DCSP DCSP if ( &apos; inclusive &apos; in selection ) : DCNL DCSP DCSP DCSP if ( end.col = = 0 ) : DCNL DCSP DCSP DCSP DCSP move _ cmd + = ( &apos; % iG $ &apos; % end.line ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP move _ cmd + = ( &apos; % iG % i &#124; &apos; % virtual _ position ( ( end.line + 1 ) , end.col ) ) DCNL DCSP DCSP elif ( &apos; old &apos; in selection ) : DCNL DCSP DCSP DCSP move _ cmd + = ( &apos; % iG % i &#124; &apos; % virtual _ position ( ( end.line + 1 ) , end.col ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP move _ cmd + = ( &apos; % iG % i &#124; &apos; % virtual _ position ( ( end.line + 1 ) , ( end.col + 1 ) ) ) DCNL DCSP DCSP move _ cmd + = ( &apos; o % iG % i &#124; o \ \ &lt; c-g &gt; &apos; % virtual _ position ( ( start.line + 1 ) , ( start.col + 1 ) ) ) DCNL DCSP feedkeys ( move _ cmd )
DCSP max _ = a.max ( 1 ) DCNL DCSP return ( max _ + T.log ( T.exp ( ( a - max _ .dimshuffle ( 0 , &apos; x &apos; ) ) ) .mean ( 1 ) ) )
DCSP return _ compile ( pattern , flags ) .fullmatch ( string )
DCSP var = _ variable _ on _ cpu ( name , shape , tf.truncated _ normal _ initializer ( stddev = stddev ) ) DCNL DCSP if ( wd is not None ) : DCNL DCSP DCSP weight _ decay = tf.mul ( tf.nn.l2 _ loss ( var ) , wd , name = &apos; weight _ loss &apos; ) DCNL DCSP DCSP tf.add _ to _ collection ( &apos; losses &apos; , weight _ decay ) DCNL DCSP return var
DCSP return getResolver ( ) .lookupNamingAuthorityPointer ( name , timeout )
DCSP if ( name in &#91; db &#91; &apos; name &apos; &#93; for db in list _ dbs ( * * client _ args ) &#93; ) : DCNL DCSP DCSP return True DCNL DCSP return False
DCSP if G.is _ directed ( ) : DCNL DCSP DCSP H = nx.DiGraph ( ) DCNL DCSP DCSP H.add _ nodes _ from ( G.nodes ( ) ) DCNL DCSP DCSP H.add _ edges _ from ( G.edges ( ) , capacity = 1 ) DCNL DCSP DCSP return H DCNL DCSP else : DCNL DCSP DCSP H = nx.DiGraph ( ) DCNL DCSP DCSP H.add _ nodes _ from ( G.nodes ( ) ) DCNL DCSP DCSP for ( source , target ) in G.edges ( ) : DCNL DCSP DCSP DCSP H.add _ edges _ from ( &#91; ( source , target ) , ( target , source ) &#93; , capacity = 1 ) DCNL DCSP DCSP return H
DCSP graph = nx.DiGraph ( ) DCNL DCSP _ map _ roles _ to _ roles ( graph , roles _ dirs , git _ dir , &apos; dependencies &apos; , &apos; role &apos; , &apos; role &apos; ) DCNL DCSP _ map _ plays _ to _ roles ( graph , aws _ play _ dirs , git _ dir , &apos; roles &apos; , &apos; aws _ playbook &apos; , &apos; role &apos; ) DCNL DCSP _ map _ plays _ to _ roles ( graph , docker _ play _ dirs , git _ dir , &apos; roles &apos; , &apos; docker _ playbook &apos; , &apos; role &apos; ) DCNL DCSP return graph
DCSP for _ in range ( LOGIN _ RETRIES ) : DCNL DCSP DCSP req = requests.post ( urljoin ( ZM &#91; &apos; url &apos; &#93; , api _ url ) , data = post _ data , cookies = ZM &#91; &apos; cookies &apos; &#93; , timeout = DEFAULT _ TIMEOUT ) DCNL DCSP DCSP if ( req.status _ code ! = requests.codes.ok ) : DCNL DCSP DCSP DCSP login ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break DCNL DCSP else : DCNL DCSP DCSP _ LOGGER.exception ( &apos; Unable DCSP to DCSP get DCSP API DCSP response DCSP from DCSP ZoneMinder &apos; ) DCNL DCSP return json.loads ( req.text )
DCSP if support _ as _ data : DCNL DCSP DCSP return DataModelTester _ SupportAsDataMixin DCNL DCSP else : DCNL DCSP DCSP return DataModelTester _ NotSupportAsDataMixin
DCSP import cherrypy DCNL DCSP try : DCNL DCSP DCSP ( code , reason , message ) = _ httputil.valid _ status ( status ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise cherrypy.HTTPError ( 500 , _ exc _ info ( ) &#91; 1 &#93; .args &#91; 0 &#93; ) DCNL DCSP if ( kwargs.get ( &apos; status &apos; ) is None ) : DCNL DCSP DCSP kwargs &#91; &apos; status &apos; &#93; = ( &apos; % s DCSP % s &apos; % ( code , reason ) ) DCNL DCSP if ( kwargs.get ( &apos; message &apos; ) is None ) : DCNL DCSP DCSP kwargs &#91; &apos; message &apos; &#93; = message DCNL DCSP if ( kwargs.get ( &apos; traceback &apos; ) is None ) : DCNL DCSP DCSP kwargs &#91; &apos; traceback &apos; &#93; = &apos; &apos; DCNL DCSP if ( kwargs.get ( &apos; version &apos; ) is None ) : DCNL DCSP DCSP kwargs &#91; &apos; version &apos; &#93; = cherrypy . _ _ version _ _ DCNL DCSP for ( k , v ) in iteritems ( kwargs ) : DCNL DCSP DCSP if ( v is None ) : DCNL DCSP DCSP DCSP kwargs &#91; k &#93; = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP kwargs &#91; k &#93; = _ escape ( kwargs &#91; k &#93; ) DCNL DCSP pages = cherrypy.serving.request.error _ page DCNL DCSP error _ page = ( pages.get ( code ) or pages.get ( &apos; default &apos; ) ) DCNL DCSP template = _ HTTPErrorTemplate DCNL DCSP if error _ page : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if hasattr ( error _ page , &apos; _ _ call _ _ &apos; ) : DCNL DCSP DCSP DCSP DCSP result = error _ page ( * * kwargs ) DCNL DCSP DCSP DCSP DCSP if cherrypy.lib.is _ iterator ( result ) : DCNL DCSP DCSP DCSP DCSP DCSP from cherrypy.lib.encoding import UTF8StreamEncoder DCNL DCSP DCSP DCSP DCSP DCSP return UTF8StreamEncoder ( result ) DCNL DCSP DCSP DCSP DCSP elif isinstance ( result , cherrypy . _ cpcompat.unicodestr ) : DCNL DCSP DCSP DCSP DCSP DCSP return result.encode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP if ( not isinstance ( result , cherrypy . _ cpcompat.bytestr ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; error DCSP page DCSP function DCSP did DCSP not DCSP return DCSP a DCSP bytestring , DCSP unicodestring DCSP or DCSP an DCSP iterator DCSP - DCSP returned DCSP object DCSP of DCSP type DCSP % s . &apos; % type ( result ) . _ _ name _ _ ) ) DCNL DCSP DCSP DCSP DCSP DCSP return result DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP template = tonative ( open ( error _ page , &apos; rb &apos; ) .read ( ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP e = _ format _ exception ( * _ exc _ info ( ) ) &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP m = kwargs &#91; &apos; message &apos; &#93; DCNL DCSP DCSP DCSP if m : DCNL DCSP DCSP DCSP DCSP m + = &apos; &lt; br DCSP / &gt; &apos; DCNL DCSP DCSP DCSP m + = ( &apos; In DCSP addition , DCSP the DCSP custom DCSP error DCSP page DCSP failed : \ n &lt; br DCSP / &gt; % s &apos; % e ) DCNL DCSP DCSP DCSP kwargs &#91; &apos; message &apos; &#93; = m DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.headers &#91; &apos; Content-Type &apos; &#93; = &apos; text / html ; charset = utf-8 &apos; DCNL DCSP result = ( template % kwargs ) DCNL DCSP return result.encode ( &apos; utf-8 &apos; )
DCSP markdown _ to _ html = _ get _ markdown _ renderer ( ) DCNL DCSP for md _ file _ path in get _ markdown _ file _ paths ( ) : DCNL DCSP DCSP with open ( md _ file _ path , &apos; r &apos; ) as f : DCNL DCSP DCSP DCSP html = markdown _ to _ html ( f.read ( ) ) DCNL DCSP DCSP head = HEADER DCNL DCSP DCSP if ( &apos; func _ groups &apos; in md _ file _ path ) : DCNL DCSP DCSP DCSP head = head.replace ( &apos; &quot; index.html &quot; &apos; , &apos; &quot; .. / index.html &quot; &apos; ) DCNL DCSP DCSP DCSP head = head.replace ( &apos; &quot; doc _ index.html &quot; &apos; , &apos; &quot; .. / doc _ index.html &quot; &apos; ) DCNL DCSP DCSP DCSP head = head.replace ( &apos; &quot; stylesheets / &apos; , &apos; &quot; .. / stylesheets / &apos; ) DCNL DCSP DCSP lines = html.split ( &apos; \ n &apos; ) DCNL DCSP DCSP for ( i , line ) in enumerate ( lines ) : DCNL DCSP DCSP DCSP if ( &apos; FLOAT _ RIGHT &apos; in line ) : DCNL DCSP DCSP DCSP DCSP line = line.replace ( &apos; FLOAT _ RIGHT &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP DCSP lines &#91; i &#93; = line.replace ( &apos; &lt; a DCSP &apos; , &apos; &lt; a DCSP class = &quot; float-right &quot; DCSP &apos; ) DCNL DCSP DCSP html = &apos; &apos;.join ( &#91; head , &apos; \ n &apos; .join ( lines ) , FOOTER &#93; ) DCNL DCSP DCSP save _ file _ path = os.path.abspath ( md _ file _ path.replace ( INPUT _ DIR , output _ dir ) .replace ( &apos; .md &apos; , &apos; .html &apos; ) ) DCNL DCSP DCSP if ( not os.path.exists ( os.path.dirname ( save _ file _ path ) ) ) : DCNL DCSP DCSP DCSP os.mkdir ( os.path.dirname ( save _ file _ path ) ) DCNL DCSP DCSP with open ( save _ file _ path , &apos; w &apos; ) as f : DCNL DCSP DCSP DCSP f.write ( html ) DCNL DCSP DCSP DCSP print ( ( &apos; Wrote DCSP % s &apos; % save _ file _ path ) )
DCSP local _ file.write ( chunk ) DCNL DCSP progress.update _ with _ increment _ value ( len ( chunk ) )
DCSP return get _ var ( &apos; FEATURES &apos; )
DCSP import matplotlib.pyplot as plt DCNL DCSP from mpl _ toolkits.axes _ grid1 import make _ axes _ locatable DCNL DCSP _ hide _ frame ( ax ) DCNL DCSP vmin = ( np.min ( data ) if ( vmin is None ) else vmin ) DCNL DCSP vmax = ( np.max ( data ) if ( vmax is None ) else vmax ) DCNL DCSP cmap = _ setup _ cmap ( cmap ) DCNL DCSP if ( title is not None ) : DCNL DCSP DCSP ax.set _ title ( title , fontsize = 10 ) DCNL DCSP ( im , _ ) = plot _ topomap ( data , pos , vmin = vmin , vmax = vmax , axes = ax , cmap = cmap &#91; 0 &#93; , image _ interp = &apos; bilinear &apos; , contours = False , outlines = outlines , show = False ) DCNL DCSP if ( colorbar is True ) : DCNL DCSP DCSP divider = make _ axes _ locatable ( ax ) DCNL DCSP DCSP cax = divider.append _ axes ( &apos; right &apos; , size = &apos; 10 % &apos; , pad = 0.25 ) DCNL DCSP DCSP cbar = plt.colorbar ( im , cax = cax , format = cbar _ fmt ) DCNL DCSP DCSP cbar.set _ ticks ( ( vmin , vmax ) ) DCNL DCSP DCSP if ( unit is not None ) : DCNL DCSP DCSP DCSP cbar.ax.set _ title ( unit , fontsize = 8 ) DCNL DCSP DCSP cbar.ax.tick _ params ( labelsize = 8 ) DCNL DCSP DCSP if cmap &#91; 1 &#93; : DCNL DCSP DCSP DCSP ax.CB = DraggableColorbar ( cbar , im )
DCSP return np.ones ( ( width , height ) , dtype = dtype )
DCSP tokens = tokenize ( doc , include _ hrefs = False ) DCNL DCSP for tok in tokens : DCNL DCSP DCSP tok.annotation = annotation DCNL DCSP return tokens
DCSP item = x &#91; 0 &#93; DCNL DCSP if isinstance ( item , ( list , tuple , np.ndarray , pd.Series , pd.DataFrame ) ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP event = salt.utils.event.get _ event ( opts &#91; &apos; node &apos; &#93; , sock _ dir = opts &#91; &apos; sock _ dir &apos; &#93; , transport = opts &#91; &apos; transport &apos; &#93; , opts = opts , listen = True ) DCNL DCSP check _ access _ and _ print _ warning ( opts &#91; &apos; sock _ dir &apos; &#93; ) DCNL DCSP print ( event.puburi ) DCNL DCSP jid _ counter = 0 DCNL DCSP found _ minions = &#91; &#93; DCNL DCSP while True : DCNL DCSP DCSP ret = event.get _ event ( full = True ) DCNL DCSP DCSP if ( ret is None ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if opts &#91; &apos; func _ count &apos; &#93; : DCNL DCSP DCSP DCSP data = ret.get ( &apos; data &apos; , False ) DCNL DCSP DCSP DCSP if data : DCNL DCSP DCSP DCSP DCSP if ( ( &apos; id &apos; in six.iterkeys ( data ) ) and ( data.get ( &apos; id &apos; , False ) not in found _ minions ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( data &#91; &apos; fun &apos; &#93; = = opts &#91; &apos; func _ count &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP jid _ counter + = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP found _ minions.append ( data &#91; &apos; id &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP print ( &apos; Reply DCSP received DCSP from DCSP &#91; { 0 } &#93; . DCSP Total DCSP replies DCSP now : DCSP &#91; { 1 } &#93; . &apos; .format ( ret &#91; &apos; data &apos; &#93; &#91; &apos; id &apos; &#93; , jid _ counter ) ) DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP print ( &apos; Event DCSP fired DCSP at DCSP { 0 } &apos; .format ( time.asctime ( ) ) ) DCNL DCSP DCSP DCSP print ( ( &apos; * &apos; * 25 ) ) DCNL DCSP DCSP DCSP print ( &apos; Tag : DCSP { 0 } &apos; .format ( ret &#91; &apos; tag &apos; &#93; ) ) DCNL DCSP DCSP DCSP print ( &apos; Data : &apos; ) DCNL DCSP DCSP DCSP pprint.pprint ( ret &#91; &apos; data &apos; &#93; )
DCSP column = column.upper ( ) DCNL DCSP clen = len ( column ) DCNL DCSP if ( ( not fast ) and ( not all ( ( ( &apos; A &apos; &lt; = char &lt; = &apos; Z &apos; ) for char in column ) ) ) ) : DCNL DCSP DCSP msg = ( &apos; Column DCSP string DCSP must DCSP contain DCSP only DCSP characters DCSP A-Z : DCSP got DCSP % s &apos; % column ) DCNL DCSP DCSP raise ColumnStringIndexException ( msg ) DCNL DCSP if ( clen = = 1 ) : DCNL DCSP DCSP return ( ord ( column &#91; 0 &#93; ) - 64 ) DCNL DCSP elif ( clen = = 2 ) : DCNL DCSP DCSP return ( ( ( 1 + ( ord ( column &#91; 0 &#93; ) - 65 ) ) * 26 ) + ( ord ( column &#91; 1 &#93; ) - 64 ) ) DCNL DCSP elif ( clen = = 3 ) : DCNL DCSP DCSP return ( ( ( ( 1 + ( ord ( column &#91; 0 &#93; ) - 65 ) ) * 676 ) + ( ( 1 + ( ord ( column &#91; 1 &#93; ) - 65 ) ) * 26 ) ) + ( ord ( column &#91; 2 &#93; ) - 64 ) ) DCNL DCSP elif ( clen &gt; 3 ) : DCNL DCSP DCSP raise ColumnStringIndexException ( &apos; Column DCSP string DCSP index DCSP can DCSP not DCSP be DCSP longer DCSP than DCSP 3 DCSP characters &apos; ) DCNL DCSP else : DCNL DCSP DCSP raise ColumnStringIndexException ( &apos; Column DCSP string DCSP index DCSP can DCSP not DCSP be DCSP empty &apos; )
DCSP return errRun ( cmd , stderr = STDOUT , * * kwargs ) &#91; 0 &#93;
DCSP f = &#91; K.convert ( random.randint ( a , b ) ) for _ in range ( 0 , ( n + 1 ) ) &#93; DCNL DCSP while ( not f &#91; 0 &#93; ) : DCNL DCSP DCSP f &#91; 0 &#93; = K.convert ( random.randint ( a , b ) ) DCNL DCSP return f
DCSP if _ is _ real ( proj ) : DCNL DCSP DCSP return backend.idd _ reconint ( ( idx + 1 ) , proj ) DCNL DCSP else : DCNL DCSP DCSP return backend.idz _ reconint ( ( idx + 1 ) , proj )
DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP def _ is _ match ( some _ str ) : DCNL DCSP DCSP DCSP return ( isinstance ( some _ str , six.text _ type ) and ( REGEX _ 4BYTE _ UNICODE.findall ( some _ str ) ! = &#91; &#93; ) ) DCNL DCSP DCSP def _ check _ dict ( data _ dict ) : DCNL DCSP DCSP DCSP for ( key , value ) in six.iteritems ( data _ dict ) : DCNL DCSP DCSP DCSP DCSP if isinstance ( value , dict ) : DCNL DCSP DCSP DCSP DCSP DCSP _ check _ dict ( value ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP if _ is _ match ( key ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP msg = _ ( &quot; Property DCSP names DCSP can &apos;t DCSP contain DCSP 4 DCSP byte DCSP unicode . &quot; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise exception.Invalid ( msg ) DCNL DCSP DCSP DCSP DCSP DCSP if _ is _ match ( value ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP msg = ( _ ( &quot; % s DCSP can &apos;t DCSP contain DCSP 4 DCSP byte DCSP unicode DCSP characters . &quot; ) % key.title ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise exception.Invalid ( msg ) DCNL DCSP DCSP for data _ dict in &#91; arg for arg in args if isinstance ( arg , dict ) &#93; : DCNL DCSP DCSP DCSP _ check _ dict ( data _ dict ) DCNL DCSP DCSP for arg in args : DCNL DCSP DCSP DCSP if _ is _ match ( arg ) : DCNL DCSP DCSP DCSP DCSP msg = _ ( &quot; Param DCSP values DCSP can &apos;t DCSP contain DCSP 4 DCSP byte DCSP unicode . &quot; ) DCNL DCSP DCSP DCSP DCSP raise exception.Invalid ( msg ) DCNL DCSP DCSP _ check _ dict ( kwargs ) DCNL DCSP DCSP return f ( * args , * * kwargs ) DCNL DCSP return wrapper
DCSP try : DCNL DCSP DCSP device = IPDevice ( device _ name , namespace = namespace ) DCNL DCSP DCSP if ( mac ! = device.link.address ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP device _ ip _ cidrs = &#91; ip &#91; &apos; cidr &apos; &#93; for ip in device.addr.list ( ) &#93; DCNL DCSP DCSP for ip _ cidr in ip _ cidrs : DCNL DCSP DCSP DCSP if ( ip _ cidr not in device _ ip _ cidrs ) : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP except RuntimeError : DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP return True
DCSP s3 _ redirect _ default ( URL ( f = &apos; organisation &apos; ) )
DCSP if isinstance ( expr , Indexed ) : DCNL DCSP DCSP c = expr.indices DCNL DCSP DCSP ( inds , dummies ) = _ remove _ repeated ( c ) DCNL DCSP DCSP return ( inds , { } ) DCNL DCSP elif ( expr is None ) : DCNL DCSP DCSP return ( set ( ) , { } ) DCNL DCSP elif isinstance ( expr , Idx ) : DCNL DCSP DCSP return ( { expr } , { } ) DCNL DCSP elif expr.is _ Atom : DCNL DCSP DCSP return ( set ( ) , { } ) DCNL DCSP else : DCNL DCSP DCSP if expr.is _ Mul : DCNL DCSP DCSP DCSP return _ get _ indices _ Mul ( expr ) DCNL DCSP DCSP elif expr.is _ Add : DCNL DCSP DCSP DCSP return _ get _ indices _ Add ( expr ) DCNL DCSP DCSP elif ( expr.is _ Pow or isinstance ( expr , exp ) ) : DCNL DCSP DCSP DCSP return _ get _ indices _ Pow ( expr ) DCNL DCSP DCSP elif isinstance ( expr , Piecewise ) : DCNL DCSP DCSP DCSP return ( set ( ) , { } ) DCNL DCSP DCSP elif isinstance ( expr , Function ) : DCNL DCSP DCSP DCSP ind0 = set ( ) DCNL DCSP DCSP DCSP for arg in expr.args : DCNL DCSP DCSP DCSP DCSP ( ind , sym ) = get _ indices ( arg ) DCNL DCSP DCSP DCSP DCSP ind0 &#124; = ind DCNL DCSP DCSP DCSP return ( ind0 , sym ) DCNL DCSP DCSP elif ( not expr.has ( Indexed ) ) : DCNL DCSP DCSP DCSP return ( set ( ) , { } ) DCNL DCSP DCSP raise NotImplementedError ( ( &apos; FIXME : DCSP No DCSP specialized DCSP handling DCSP of DCSP type DCSP % s &apos; % type ( expr ) ) )
DCSP xml _ string = XmlToString ( content , encoding , pretty ) DCNL DCSP if ( win32 and ( os.linesep ! = &apos; \ r \ n &apos; ) ) : DCNL DCSP DCSP xml _ string = xml _ string.replace ( &apos; \ n &apos; , &apos; \ r \ n &apos; ) DCNL DCSP try : DCNL DCSP DCSP xml _ string = xml _ string.encode ( encoding ) DCNL DCSP except Exception : DCNL DCSP DCSP xml _ string = unicode ( xml _ string , &apos; latin-1 &apos; ) .encode ( encoding ) DCNL DCSP try : DCNL DCSP DCSP f = open ( path , &apos; r &apos; ) DCNL DCSP DCSP existing = f.read ( ) DCNL DCSP DCSP f.close ( ) DCNL DCSP except : DCNL DCSP DCSP existing = None DCNL DCSP if ( existing ! = xml _ string ) : DCNL DCSP DCSP f = open ( path , &apos; w &apos; ) DCNL DCSP DCSP f.write ( xml _ string ) DCNL DCSP DCSP f.close ( )
DCSP filters _ list = &#91; &#93; DCNL DCSP for ( k , v ) in filters _ dict.items ( ) : DCNL DCSP DCSP filter _ dict = { &apos; Name &apos; : k } DCNL DCSP DCSP if isinstance ( v , string _ types ) : DCNL DCSP DCSP DCSP filter _ dict &#91; &apos; Values &apos; &#93; = &#91; v &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP filter _ dict &#91; &apos; Values &apos; &#93; = v DCNL DCSP DCSP filters _ list.append ( filter _ dict ) DCNL DCSP return filters _ list
DCSP ax.get _ yticks ( ) DCNL DCSP ax.xaxis.set _ ticks ( &#91; &#93; ) DCNL DCSP ax.yaxis.set _ ticks ( &#91; &#93; ) DCNL DCSP ax.set _ frame _ on ( False )
DCSP if ( lineage is None ) : DCNL DCSP DCSP ( action , lineage ) = _ find _ lineage _ for _ domains _ and _ certname ( config , domains , certname ) DCNL DCSP else : DCNL DCSP DCSP action = &apos; renew &apos; DCNL DCSP if ( action = = &apos; reinstall &apos; ) : DCNL DCSP DCSP logger.info ( &apos; Keeping DCSP the DCSP existing DCSP certificate &apos; ) DCNL DCSP DCSP return ( &apos; reinstall &apos; , lineage ) DCNL DCSP hooks.pre _ hook ( config ) DCNL DCSP try : DCNL DCSP DCSP if ( action = = &apos; renew &apos; ) : DCNL DCSP DCSP DCSP logger.info ( &apos; Renewing DCSP an DCSP existing DCSP certificate &apos; ) DCNL DCSP DCSP DCSP renewal.renew _ cert ( config , domains , le _ client , lineage ) DCNL DCSP DCSP elif ( action = = &apos; newcert &apos; ) : DCNL DCSP DCSP DCSP logger.info ( &apos; Obtaining DCSP a DCSP new DCSP certificate &apos; ) DCNL DCSP DCSP DCSP lineage = le _ client.obtain _ and _ enroll _ certificate ( domains , certname ) DCNL DCSP DCSP DCSP if ( lineage is False ) : DCNL DCSP DCSP DCSP DCSP raise errors.Error ( &apos; Certificate DCSP could DCSP not DCSP be DCSP obtained &apos; ) DCNL DCSP finally : DCNL DCSP DCSP hooks.post _ hook ( config ) DCNL DCSP if ( ( not config.dry _ run ) and ( not ( config.verb = = &apos; renew &apos; ) ) ) : DCNL DCSP DCSP _ report _ new _ cert ( config , lineage.cert , lineage.fullchain ) DCNL DCSP return ( action , lineage )
DCSP if ( not _ isproperdist ( px ) ) : DCNL DCSP DCSP raise ValueError ( &apos; px DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP distribution &apos; ) DCNL DCSP alpha = float ( alpha ) DCNL DCSP if ( alpha = = 1 ) : DCNL DCSP DCSP genent = shannonentropy ( px ) DCNL DCSP DCSP if ( logbase ! = 2 ) : DCNL DCSP DCSP DCSP return ( logbasechange ( 2 , logbase ) * genent ) DCNL DCSP DCSP return genent DCNL DCSP elif ( ( &apos; inf &apos; in string ( alpha ) .lower ( ) ) or ( alpha = = np.inf ) ) : DCNL DCSP DCSP return ( - np.log ( np.max ( px ) ) ) DCNL DCSP px = ( px * * alpha ) DCNL DCSP genent = np.log ( px.sum ( ) ) DCNL DCSP if ( logbase = = 2 ) : DCNL DCSP DCSP return ( ( 1 / ( 1 - alpha ) ) * genent ) DCNL DCSP else : DCNL DCSP DCSP return ( ( ( 1 / ( 1 - alpha ) ) * logbasechange ( 2 , logbase ) ) * genent )
DCSP with pytest.raises ( ValueError ) : DCNL DCSP DCSP s = expr ( Const1D ( ( 2 , 2 ) , n _ models = 2 ) , Const1D ( 3 , n _ models = 1 ) )
DCSP web = makeelement ( &apos; webSettings &apos; ) DCNL DCSP web.append ( makeelement ( &apos; allowPNG &apos; ) ) DCNL DCSP web.append ( makeelement ( &apos; doNotSaveAsSingleFile &apos; ) ) DCNL DCSP return web
DCSP if ( not chain ) : DCNL DCSP DCSP return &apos; Error : DCSP Chain DCSP needs DCSP to DCSP be DCSP specified &apos; DCNL DCSP nft _ family = _ NFTABLES _ FAMILIES &#91; family &#93; DCNL DCSP cmd = &apos; { 0 } DCSP list DCSP table DCSP { 1 } DCSP { 2 } &apos; .format ( _ nftables _ cmd ( ) , nft _ family , table ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) .find ( &apos; chain DCSP { 0 } DCSP { { &apos; .format ( chain ) ) DCNL DCSP if ( out ! = ( -1 ) ) : DCNL DCSP DCSP out = &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP return False DCNL DCSP if ( not out ) : DCNL DCSP DCSP return True DCNL DCSP return out
DCSP keys = &#91; &#93; DCNL DCSP num _ args = 0 DCNL DCSP manual _ pos _ arg = set ( ) DCNL DCSP for name in collect _ string _ fields ( format _ string ) : DCNL DCSP DCSP if ( name and str ( name ) .isdigit ( ) ) : DCNL DCSP DCSP DCSP manual _ pos _ arg.add ( str ( name ) ) DCNL DCSP DCSP elif name : DCNL DCSP DCSP DCSP ( keyname , fielditerator ) = split _ format _ field _ names ( name ) DCNL DCSP DCSP DCSP if isinstance ( keyname , numbers.Number ) : DCNL DCSP DCSP DCSP DCSP manual _ pos _ arg.add ( str ( keyname ) ) DCNL DCSP DCSP DCSP DCSP keyname = int ( keyname ) DCNL DCSP DCSP DCSP keys.append ( ( keyname , list ( fielditerator ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP num _ args + = 1 DCNL DCSP return ( keys , num _ args , len ( manual _ pos _ arg ) )
DCSP ctx.status = &apos; 500 DCSP Internal DCSP Server DCSP Error &apos; DCNL DCSP ctx.headers = &#91; ( &apos; Content-Type &apos; , &apos; text / html &apos; ) &#93; DCNL DCSP ctx.output = &apos; internal DCSP server DCSP error&apos;
DCSP flavors = { &apos; cygwin &apos; : &apos; win &apos; , &apos; win32 &apos; : &apos; win &apos; , &apos; darwin &apos; : &apos; mac &apos; } DCNL DCSP if ( &apos; flavor &apos; in params ) : DCNL DCSP DCSP return params &#91; &apos; flavor &apos; &#93; DCNL DCSP if ( sys.platform in flavors ) : DCNL DCSP DCSP return flavors &#91; sys.platform &#93; DCNL DCSP if sys.platform.startswith ( &apos; sunos &apos; ) : DCNL DCSP DCSP return &apos; solaris &apos; DCNL DCSP if sys.platform.startswith ( &apos; freebsd &apos; ) : DCNL DCSP DCSP return &apos; freebsd &apos; DCNL DCSP if sys.platform.startswith ( &apos; openbsd &apos; ) : DCNL DCSP DCSP return &apos; openbsd &apos; DCNL DCSP if sys.platform.startswith ( &apos; netbsd &apos; ) : DCNL DCSP DCSP return &apos; netbsd &apos; DCNL DCSP if sys.platform.startswith ( &apos; aix &apos; ) : DCNL DCSP DCSP return &apos; aix &apos; DCNL DCSP return &apos; linux&apos;
DCSP if ( ( value is not None ) or ( not ( alternative in &#91; &apos; two-sided &apos; , &apos; 2s &apos; &#93; ) ) ) : DCNL DCSP DCSP raise NotImplementedError DCNL DCSP all _ pairs = &#91; ( 0 , k ) for k in range ( 1 , len ( count ) ) &#93; DCNL DCSP pvals = &#91; proportions _ chisquare ( count &#91; list ( pair ) &#93; , nobs &#91; list ( pair ) &#93; ) &#91; 1 &#93; for pair in all _ pairs &#93; DCNL DCSP return AllPairsResults ( pvals , all _ pairs , multitest _ method = multitest _ method )
DCSP from boto.cloudtrail.layer1 import CloudTrailConnection DCNL DCSP return get _ regions ( &apos; cloudtrail &apos; , connection _ cls = CloudTrailConnection )
DCSP input _ shape = utils.get _ incoming _ shape ( incoming ) DCNL DCSP assert ( len ( input _ shape ) = = 4 ) , &apos; Incoming DCSP Tensor DCSP shape DCSP must DCSP be DCSP 4-D &apos; DCNL DCSP kernel = utils.autoformat _ kernel _ 2d ( kernel _ size ) DCNL DCSP with tf.name _ scope ( name ) as scope : DCNL DCSP DCSP inference = tf.image.resize _ nearest _ neighbor ( incoming , size = ( input _ shape &#91; 1 : 3 &#93; * tf.constant ( kernel &#91; 1 : 3 &#93; ) ) ) DCNL DCSP DCSP inference.set _ shape ( ( None , ( input _ shape &#91; 1 &#93; * kernel &#91; 1 &#93; ) , ( input _ shape &#91; 2 &#93; * kernel &#91; 2 &#93; ) , None ) ) DCNL DCSP inference.scope = scope DCNL DCSP tf.add _ to _ collection ( ( ( tf.GraphKeys.LAYER _ TENSOR + &apos; / &apos; ) + name ) , inference ) DCNL DCSP return inference
DCSP directoryList = &#91; &#93; DCNL DCSP for ( dirpath , dirnames , filenames ) in os.walk ( path ) : DCNL DCSP DCSP for d in dirnames &#91; : &#93; : DCNL DCSP DCSP DCSP if ( d in excludeDirs ) : DCNL DCSP DCSP DCSP DCSP dirnames.remove ( d ) DCNL DCSP DCSP DCSP DCSP print ( &apos; EXCLUDING DCSP % s ... &apos; % os.path.join ( dirpath , d ) ) DCNL DCSP DCSP DCSP elif ( &apos; UNDER _ DEVELOPMENT &apos; in os.listdir ( os.path.join ( dirpath , d ) ) ) : DCNL DCSP DCSP DCSP DCSP dirnames.remove ( d ) DCNL DCSP DCSP DCSP DCSP print ( &apos; EXCLUDING DCSP % s ... &apos; % os.path.join ( dirpath , d ) ) DCNL DCSP DCSP for f in filenames : DCNL DCSP DCSP DCSP if ( f = = filename ) : DCNL DCSP DCSP DCSP DCSP directoryList.append ( dirpath ) DCNL DCSP return directoryList
DCSP fig.canvas.set _ window _ title ( u &apos; \ u4ea4 \ u6613 \ u9e1f \ u77b0 \ u56fe &apos; ) DCNL DCSP ( left , width ) = ( 0.1 , 0.65 ) DCNL DCSP ( bottom , height ) = ( 0.1 , 0.65 ) DCNL DCSP bottom _ h = left _ h = ( ( left + width ) + 0.02 ) DCNL DCSP rect _ scatter = &#91; left , bottom , width , height &#93; DCNL DCSP rect _ histx = &#91; left , bottom _ h , width , 0.2 &#93; DCNL DCSP rect _ histy = &#91; left _ h , bottom , 0.2 , height &#93; DCNL DCSP axScatter = plt.axes ( rect _ scatter ) DCNL DCSP axHistx = plt.axes ( rect _ histx ) DCNL DCSP axHisty = plt.axes ( rect _ histy ) DCNL DCSP cursor = Cursor ( axScatter , useblit = True , color = &apos; red &apos; , linewidth = 1 ) DCNL DCSP axScatter.plot ( x , y , &apos; o &apos; , color = &apos; red &apos; ) DCNL DCSP axScatter.plot ( x2 , y2 , &apos; o &apos; , color = &apos; blue &apos; ) DCNL DCSP xmax = np.max ( ( x + x2 ) ) DCNL DCSP xmin = np.min ( ( x + x2 ) ) DCNL DCSP binwidth = ( xmax / binnum ) DCNL DCSP lim = ( ( int ( ( xmax / binwidth ) ) + 1 ) * binwidth ) DCNL DCSP bins = np.arange ( ( - lim ) , ( lim + binwidth ) , binwidth ) DCNL DCSP axHistx.hist ( ( x + x2 ) , bins = bins ) DCNL DCSP ymax = np.max ( ( y + y2 ) ) DCNL DCSP ymin = np.min ( ( y + y2 ) ) DCNL DCSP binwidth = ( ymax / binnum ) DCNL DCSP lim = ( ( int ( ( ymax / binwidth ) ) + 1 ) * binwidth ) DCNL DCSP bins = np.arange ( ( - lim ) , ( lim + binwidth ) , binwidth ) DCNL DCSP axHisty.hist ( y , bins = bins , orientation = &apos; horizontal &apos; , color = &apos; red &apos; ) DCNL DCSP axHisty.hist ( y2 , bins = bins , orientation = &apos; horizontal &apos; , color = &apos; blue &apos; ) DCNL DCSP xymax = np.max ( &#91; np.max ( np.fabs ( ( x + x2 ) ) ) , np.max ( np.fabs ( ( y + y2 ) ) ) &#93; ) DCNL DCSP lim = ( ( int ( ( xymax / binwidth ) ) + 1 ) * binwidth ) DCNL DCSP axScatter.axhline ( color = &apos; black &apos; ) DCNL DCSP axHistx.set _ xlim ( axScatter.get _ xlim ( ) ) DCNL DCSP axHisty.set _ ylim ( axScatter.get _ ylim ( ) ) DCNL DCSP axHisty.set _ xlabel ( u &apos; \ u76c8 \ u4e8f \ u5206 \ u5e03 &apos; , fontproperties = font _ big ) DCNL DCSP axHistx.set _ ylabel ( u &apos; \ u5468 \ u671f \ u5206 \ u5e03 &apos; , fontproperties = font _ big ) DCNL DCSP axScatter.set _ xlabel ( u &apos; \ u76c8 \ u4e8f \ u548c \ u5468 \ u671f \ u5206 \ u5e03 &apos; , fontproperties = font _ big ) DCNL DCSP axScatter.grid ( True ) DCNL DCSP axHistx.grid ( True ) DCNL DCSP axHisty.grid ( True ) DCNL DCSP c = Cursor ( axScatter , useblit = True , color = &apos; red &apos; , linewidth = 1 , vertOn = True , horizOn = True ) DCNL DCSP return ( &#91; axScatter , axHistx , axHisty &#93; , &#91; c &#93; )
DCSP sleep ( 1 ) DCNL DCSP for i in xrange ( 5 ) : DCNL DCSP DCSP if ( &apos; ip _ session.log &apos; in nt.listdir ( nt.getcwd ( ) ) ) : DCNL DCSP DCSP DCSP tfile = open ( &apos; ip _ session.log &apos; , &apos; r &apos; ) DCNL DCSP DCSP DCSP break DCNL DCSP DCSP print &apos; Waiting DCSP for DCSP ip _ session.log DCSP to DCSP be DCSP created ... &apos; DCNL DCSP DCSP sleep ( 1 ) DCNL DCSP outlines = tfile.readlines ( ) DCNL DCSP tfile.close ( ) DCNL DCSP errlines = &#91; &#93; DCNL DCSP if File.Exists ( &apos; ip _ session _ stderr.log &apos; ) : DCNL DCSP DCSP tfile = open ( &apos; ip _ session _ stderr.log &apos; , &apos; r &apos; ) DCNL DCSP DCSP errlines = tfile.readlines ( ) DCNL DCSP DCSP tfile.close ( ) DCNL DCSP return ( outlines , errlines )
DCSP limit = 3 DCNL DCSP t = text.lower ( ) .strip ( ) DCNL DCSP if ( t = = &apos; xkcd &apos; ) : DCNL DCSP DCSP addr = &apos; http : / / xkcd.com / rss.xml &apos; DCNL DCSP elif ( t = = &apos; ars &apos; ) : DCNL DCSP DCSP addr = &apos; http : / / feeds.arstechnica.com / arstechnica / index &apos; DCNL DCSP elif ( t in ( &apos; pypi &apos; , &apos; pip &apos; , &apos; py &apos; ) ) : DCNL DCSP DCSP addr = &apos; https : / / pypi.python.org / pypi ? % 3Aaction = rss &apos; DCNL DCSP DCSP limit = 6 DCNL DCSP elif ( t in ( &apos; pypinew &apos; , &apos; pipnew &apos; , &apos; pynew &apos; ) ) : DCNL DCSP DCSP addr = &apos; https : / / pypi.python.org / pypi ? % 3Aaction = packages _ rss &apos; DCNL DCSP DCSP limit = 5 DCNL DCSP elif ( t = = &apos; world &apos; ) : DCNL DCSP DCSP addr = &apos; https : / / news.google.com / news ? cf = all &amp; ned = us &amp; hl = en &amp; topic = w &amp; output = rss &apos; DCNL DCSP elif ( t in ( &apos; us &apos; , &apos; usa &apos; ) ) : DCNL DCSP DCSP addr = &apos; https : / / news.google.com / news ? cf = all &amp; ned = us &amp; hl = en &amp; topic = n &amp; output = rss &apos; DCNL DCSP elif ( t = = &apos; nz &apos; ) : DCNL DCSP DCSP addr = &apos; https : / / news.google.com / news ? pz = 1 &amp; cf = all &amp; ned = nz &amp; hl = en &amp; topic = n &amp; output = rss &apos; DCNL DCSP elif ( t in ( &apos; anand &apos; , &apos; anandtech &apos; ) ) : DCNL DCSP DCSP addr = &apos; http : / / www.anandtech.com / rss / &apos; DCNL DCSP else : DCNL DCSP DCSP addr = text DCNL DCSP feed = feedparser.parse ( addr ) DCNL DCSP if ( not feed.entries ) : DCNL DCSP DCSP return &apos; Feed DCSP not DCSP found . &apos; DCNL DCSP out = &#91; &#93; DCNL DCSP for item in feed.entries &#91; : limit &#93; : DCNL DCSP DCSP out.append ( format _ item ( item ) ) DCNL DCSP start = ( &apos; \ x02 { } \ x02 : DCSP &apos; .format ( feed.feed.title ) if ( &apos; title &apos; in feed.feed ) else &apos; &apos; ) DCNL DCSP return ( start + &apos; , DCSP &apos; .join ( out ) )
DCSP ( header _ title , path1 , path2 ) = ( u &apos; \ u67e5 \ u770b \ u8d44 \ u4ea7 \ u7ec4 &apos; , u &apos; \ u8d44 \ u4ea7 \ u7ba1 \ u7406 &apos; , u &apos; \ u67e5 \ u770b \ u8d44 \ u4ea7 \ u7ec4 &apos; ) DCNL DCSP keyword = request.GET.get ( &apos; keyword &apos; , &apos; &apos; ) DCNL DCSP asset _ group _ list = AssetGroup.objects.all ( ) DCNL DCSP group _ id = request.GET.get ( &apos; id &apos; ) DCNL DCSP if group _ id : DCNL DCSP DCSP asset _ group _ list = asset _ group _ list.filter ( id = group _ id ) DCNL DCSP if keyword : DCNL DCSP DCSP asset _ group _ list = asset _ group _ list.filter ( ( Q ( name _ _ contains = keyword ) &#124; Q ( comment _ _ contains = keyword ) ) ) DCNL DCSP ( asset _ group _ list , p , asset _ groups , page _ range , current _ page , show _ first , show _ end ) = pages ( asset _ group _ list , request ) DCNL DCSP return my _ render ( &apos; jasset / group _ list.html &apos; , locals ( ) , request )
DCSP with open ( filename , &apos; rb &apos; ) as f : DCNL DCSP DCSP key = f.read ( ) DCNL DCSP DCSP if ( len ( key ) = = 32 ) : DCNL DCSP DCSP DCSP return key DCNL DCSP DCSP if ( len ( key ) = = 64 ) : DCNL DCSP DCSP DCSP return key.decode ( &apos; hex &apos; ) DCNL DCSP DCSP return sha256 ( key ) DCNL DCSP raise IOError ( &apos; Could DCSP not DCSP read DCSP keyfile . &apos; )
DCSP if ( not _ exactly _ one ( ( subnet _ ids , subnet _ names ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &quot; Exactly DCSP one DCSP of DCSP either DCSP &apos; subnet _ ids &apos; DCSP or DCSP &apos; subnet _ names &apos; DCSP must DCSP be DCSP provided . &quot; ) DCNL DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( not conn ) : DCNL DCSP DCSP return False DCNL DCSP if subnet _ group _ exists ( name , tags , region , key , keyid , profile ) : DCNL DCSP DCSP return True DCNL DCSP if subnet _ names : DCNL DCSP DCSP subnet _ ids = &#91; &#93; DCNL DCSP DCSP for n in subnet _ names : DCNL DCSP DCSP DCSP r = _ _ salt _ _ &#91; &apos; boto _ vpc.get _ resource _ id &apos; &#93; ( &apos; subnet &apos; , n , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP DCSP if ( &apos; id &apos; not in r ) : DCNL DCSP DCSP DCSP DCSP log.error ( &quot; Couldn &apos;t DCSP resolve DCSP subnet DCSP name DCSP { 0 } DCSP to DCSP an DCSP ID . &quot; .format ( subnet _ name ) ) DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP subnet _ ids + = &#91; r &#91; &apos; id &apos; &#93; &#93; DCNL DCSP try : DCNL DCSP DCSP ec = conn.create _ cache _ subnet _ group ( name , description , subnet _ ids ) DCNL DCSP DCSP if ( not ec ) : DCNL DCSP DCSP DCSP msg = &apos; Failed DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP log.error ( msg ) DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP log.info ( &apos; Created DCSP ElastiCache DCSP subnet DCSP group DCSP { 0 } &apos; .format ( name ) ) DCNL DCSP DCSP return True DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP log.error ( msg ) DCNL DCSP DCSP return False
DCSP manager = MANAGER DCNL DCSP cmds = { &apos; yum DCSP -y DCSP --color = never &apos; : { False : &apos; --exclude = kernel * DCSP update &apos; , True : &apos; update &apos; } } DCNL DCSP cmd = cmds &#91; manager &#93; &#91; kernel &#93; DCNL DCSP run _ as _ root ( ( &apos; % ( manager ) s DCSP % ( cmd ) s &apos; % locals ( ) ) )
DCSP varnames = ( category , &apos; LANGUAGE &apos; , &apos; LC _ ALL &apos; , &apos; LC _ CTYPE &apos; , &apos; LANG &apos; ) DCNL DCSP for name in filter ( None , varnames ) : DCNL DCSP DCSP locale = os.getenv ( name ) DCNL DCSP DCSP if locale : DCNL DCSP DCSP DCSP if ( ( name = = &apos; LANGUAGE &apos; ) and ( &apos; : &apos; in locale ) ) : DCNL DCSP DCSP DCSP DCSP locale = locale.split ( &apos; : &apos; ) &#91; 0 &#93; DCNL DCSP DCSP DCSP if ( locale.split ( &apos; .&apos; ) &#91; 0 &#93; in ( &apos; C &apos; , &apos; POSIX &apos; ) ) : DCNL DCSP DCSP DCSP DCSP locale = &apos; en _ US _ POSIX &apos; DCNL DCSP DCSP DCSP elif ( aliases and ( locale in aliases ) ) : DCNL DCSP DCSP DCSP DCSP locale = aliases &#91; locale &#93; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return get _ locale _ identifier ( parse _ locale ( locale ) ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP pass
DCSP db _ query = models.StudentModule.objects.filter ( course _ id _ _ exact = course _ id , module _ type _ _ exact = &apos; sequential &apos; ) .values ( &apos; module _ state _ key &apos; ) .annotate ( count _ sequential = Count ( &apos; module _ state _ key &apos; ) ) DCNL DCSP sequential _ open _ distrib = { } DCNL DCSP for row in db _ query : DCNL DCSP DCSP row _ loc = course _ id.make _ usage _ key _ from _ deprecated _ string ( row &#91; &apos; module _ state _ key &apos; &#93; ) DCNL DCSP DCSP sequential _ open _ distrib &#91; row _ loc &#93; = row &#91; &apos; count _ sequential &apos; &#93; DCNL DCSP return sequential _ open _ distrib
DCSP return format ( lex ( code , lexer ) , formatter , outfile )
DCSP root = Element ( &apos; Relationships &apos; , xmlns = PKG _ REL _ NS ) DCNL DCSP rels = worksheet . _ rels DCNL DCSP if ( worksheet.vba _ controls is not None ) : DCNL DCSP DCSP rel = Relationship ( &apos; vmlDrawing &apos; , id = worksheet.vba _ controls , target = ( &apos; / xl / drawings / vmlDrawing % s.vml &apos; % vba _ controls _ id ) ) DCNL DCSP DCSP rels.append ( rel ) DCNL DCSP if ( worksheet . _ comment _ count &gt; 0 ) : DCNL DCSP DCSP rel = Relationship ( type = &apos; comments &apos; , id = &apos; comments &apos; , target = ( &apos; / xl / comments % s.xml &apos; % comments _ id ) ) DCNL DCSP DCSP rels.append ( rel ) DCNL DCSP DCSP if ( worksheet.vba _ controls is None ) : DCNL DCSP DCSP DCSP rel = Relationship ( type = &apos; vmlDrawing &apos; , id = &apos; commentsvml &apos; , target = ( &apos; / xl / drawings / commentsDrawing % s.vml &apos; % comments _ id ) ) DCNL DCSP DCSP DCSP rels.append ( rel ) DCNL DCSP for ( idx , rel ) in enumerate ( rels , 1 ) : DCNL DCSP DCSP if ( rel.id is None ) : DCNL DCSP DCSP DCSP rel.id = &apos; rId { 0 } &apos; .format ( idx ) DCNL DCSP DCSP root.append ( rel.to _ tree ( ) ) DCNL DCSP return root
DCSP icrs = ICRS ( ( 1 * u.deg ) , ( 2 * u.deg ) , distance = ( 1.5 * R _ sun ) ) DCNL DCSP bary = icrs.transform _ to ( BarycentricTrueEcliptic ) DCNL DCSP helio = icrs.transform _ to ( HeliocentricTrueEcliptic ) DCNL DCSP assert ( np.abs ( ( bary.distance - helio.distance ) ) &gt; ( 1 * u.km ) ) DCNL DCSP helio _ in _ bary _ frame = bary.realize _ frame ( helio.cartesian ) DCNL DCSP assert ( bary.separation ( helio _ in _ bary _ frame ) &gt; ( 1 * u.arcmin ) )
DCSP ( ax _ img , ax _ hist ) = axes DCNL DCSP ax _ cdf = ax _ hist.twinx ( ) DCNL DCSP ax _ img.imshow ( img , cmap = plt.cm.gray ) DCNL DCSP ax _ img.set _ axis _ off ( ) DCNL DCSP ax _ hist.hist ( img.ravel ( ) , bins = bins ) DCNL DCSP ax _ hist.ticklabel _ format ( axis = &apos; y &apos; , style = &apos; scientific &apos; , scilimits = ( 0 , 0 ) ) DCNL DCSP ax _ hist.set _ xlabel ( &apos; Pixel DCSP intensity &apos; ) DCNL DCSP ( xmin , xmax ) = dtype _ range &#91; img.dtype.type &#93; DCNL DCSP ax _ hist.set _ xlim ( xmin , xmax ) DCNL DCSP ( img _ cdf , bins ) = exposure.cumulative _ distribution ( img , bins ) DCNL DCSP ax _ cdf.plot ( bins , img _ cdf , &apos; r &apos; ) DCNL DCSP return ( ax _ img , ax _ hist , ax _ cdf )
DCSP with open ( file _ path ) as data _ file : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP overrides = json.load ( data _ file ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP sys.exit ( &apos; Failed DCSP parsing DCSP configuration DCSP file DCSP at DCSP { } &apos; .format ( file _ path ) ) DCNL DCSP DCSP if ( not overrides ) : DCNL DCSP DCSP DCSP log.debug ( &apos; No DCSP config DCSP overrides DCSP found . &apos; ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP assert isinstance ( overrides , dict ) , &apos; overrides DCSP must DCSP be DCSP dictionary &apos; DCNL DCSP DCSP loaded _ config.update ( overrides ) DCNL DCSP DCSP log.debug ( &apos; Imported DCSP config DCSP overrides DCSP { } &apos; .format ( overrides.keys ( ) ) )
DCSP existing _ user = _ get _ authorized _ user ( requesting _ user , username ) DCNL DCSP serializer = create _ user _ preference _ serializer ( existing _ user , preference _ key , preference _ value ) DCNL DCSP validate _ user _ preference _ serializer ( serializer , preference _ key , preference _ value ) DCNL DCSP try : DCNL DCSP DCSP serializer.save ( ) DCNL DCSP except Exception as error : DCNL DCSP DCSP raise _ create _ preference _ update _ error ( preference _ key , preference _ value , error )
DCSP stack = _ post _ order ( node ) DCNL DCSP key = list ( ) DCNL DCSP for item in stack : DCNL DCSP DCSP if ( ( type ( item &#91; 0 &#93; ) is str ) and ( item not in aliases ) ) : DCNL DCSP DCSP DCSP key.append ( item &#91; 0 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP key.append ( item &#91; 0 : 2 &#93; ) DCNL DCSP key = tuple ( key ) DCNL DCSP dup _ node = duplicates.get ( key , False ) DCNL DCSP if dup _ node : DCNL DCSP DCSP node &#91; 0 &#93; = dup _ node DCNL DCSP DCSP stack = None DCNL DCSP else : DCNL DCSP DCSP duplicates &#91; key &#93; = stack &#91; ( -1 ) &#93; DCNL DCSP DCSP aliases.add ( stack &#91; ( -1 ) &#93; ) DCNL DCSP while ( len ( node ) &gt; 3 ) : DCNL DCSP DCSP node.pop ( ) DCNL DCSP return stack
DCSP if ( arg is None ) : DCNL DCSP DCSP arg = ugettext ( u &apos;yes , no , maybe &apos; ) DCNL DCSP bits = arg.split ( u &apos; , &apos; ) DCNL DCSP if ( len ( bits ) &lt; 2 ) : DCNL DCSP DCSP return value DCNL DCSP try : DCNL DCSP DCSP ( yes , no , maybe ) = bits DCNL DCSP except ValueError : DCNL DCSP DCSP ( yes , no , maybe ) = ( bits &#91; 0 &#93; , bits &#91; 1 &#93; , bits &#91; 1 &#93; ) DCNL DCSP if ( value is None ) : DCNL DCSP DCSP return maybe DCNL DCSP if value : DCNL DCSP DCSP return yes DCNL DCSP return no
DCSP res _ pool _ ref = session . _ call _ method ( vutil , &apos; get _ object _ property &apos; , cluster , &apos; resourcePool &apos; ) DCNL DCSP return res _ pool _ ref
DCSP def verify _ user ( user _ name , user _ password ) : DCNL DCSP DCSP if ( ( user _ name = = user ) and ( user _ password = = password ) ) : DCNL DCSP DCSP DCSP return user _ name DCNL DCSP DCSP return False DCNL DCSP return verify _ user
DCSP if check _ auth ( users , encrypt ) : DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP cherrypy.log ( &apos; Auth DCSP successful &apos; , &apos; TOOLS.BASIC _ AUTH &apos; ) DCNL DCSP DCSP return DCNL DCSP cherrypy.serving.response.headers &#91; &apos; www-authenticate &apos; &#93; = httpauth.basicAuth ( realm ) DCNL DCSP raise cherrypy.HTTPError ( 401 , &apos; You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP that DCSP resource &apos; )
DCSP url _ components = urlparse ( force _ str ( url ) ) DCNL DCSP query _ params = parse _ qs ( url _ components.query ) DCNL DCSP query _ params &#91; name &#93; = value DCNL DCSP query = urlencode ( query _ params , doseq = True ) DCNL DCSP return force _ text ( urlunparse ( &#91; url _ components.scheme , url _ components.netloc , url _ components.path , url _ components.params , query , url _ components.fragment &#93; ) )
DCSP if isinstance ( exp , cls ) : DCNL DCSP DCSP return True DCNL DCSP elif isinstance ( exp , Var ) : DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP return _ contains ( exp.sub , cls )
DCSP try : DCNL DCSP DCSP return _ dot2int ( bytes _ to _ str ( libvlc _ get _ version ( ) ) .split ( ) &#91; 0 &#93; ) DCNL DCSP except ValueError : DCNL DCSP DCSP return 0
DCSP s3 _ redirect _ default ( URL ( f = &apos; person &apos; ) )
DCSP if ( trust _ root is None ) : DCNL DCSP DCSP trust _ root = getattr ( settings , &apos; OPENID _ TRUST _ ROOT &apos; , request.build _ absolute _ uri ( &apos; / &apos; ) ) DCNL DCSP if openid _ request.shouldSendRedirect ( ) : DCNL DCSP DCSP redirect _ url = openid _ request.redirectURL ( trust _ root , return _ to ) DCNL DCSP DCSP return HttpResponseRedirect ( redirect _ url ) DCNL DCSP else : DCNL DCSP DCSP form _ html = openid _ request.htmlMarkup ( trust _ root , return _ to , form _ tag _ attrs = { &apos; id &apos; : &apos; openid _ message &apos; } ) DCNL DCSP DCSP return HttpResponse ( form _ html , content _ type = &apos; text / html ; charset = UTF-8 &apos; )
DCSP original _ uri = uri DCNL DCSP seen _ uris = set ( ) DCNL DCSP deadline = ( time.time ( ) + timeout ) DCNL DCSP while ( time.time ( ) &lt; deadline ) : DCNL DCSP DCSP if ( uri in seen _ uris ) : DCNL DCSP DCSP DCSP logger.info ( u &apos;Unwrapping DCSP stream DCSP from DCSP URI DCSP ( % s ) DCSP failed : DCSP playlist DCSP referenced DCSP itself &apos; , uri ) DCNL DCSP DCSP DCSP return ( None , None ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP seen _ uris.add ( uri ) DCNL DCSP DCSP logger.debug ( u &apos;Unwrapping DCSP stream DCSP from DCSP URI : DCSP % s &apos; , uri ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP scan _ timeout = ( deadline - time.time ( ) ) DCNL DCSP DCSP DCSP if ( scan _ timeout &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP logger.info ( u &apos;Unwrapping DCSP stream DCSP from DCSP URI DCSP ( % s ) DCSP failed : DCSP timed DCSP out DCSP in DCSP % sms &apos; , uri , timeout ) DCNL DCSP DCSP DCSP DCSP return ( None , None ) DCNL DCSP DCSP DCSP scan _ result = scanner.scan ( uri , timeout = scan _ timeout ) DCNL DCSP DCSP except exceptions.ScannerError as exc : DCNL DCSP DCSP DCSP logger.debug ( u &apos;GStreamer DCSP failed DCSP scanning DCSP URI DCSP ( % s ) : DCSP % s &apos; , uri , exc ) DCNL DCSP DCSP DCSP scan _ result = None DCNL DCSP DCSP if ( scan _ result is not None ) : DCNL DCSP DCSP DCSP if ( scan _ result.playable or ( ( not scan _ result.mime.startswith ( u &apos;text / &apos; ) ) and ( not scan _ result.mime.startswith ( u &apos;application / &apos; ) ) ) ) : DCNL DCSP DCSP DCSP DCSP logger.debug ( u &apos;Unwrapped DCSP potential DCSP % s DCSP stream : DCSP % s &apos; , scan _ result.mime , uri ) DCNL DCSP DCSP DCSP DCSP return ( uri , scan _ result ) DCNL DCSP DCSP download _ timeout = ( deadline - time.time ( ) ) DCNL DCSP DCSP if ( download _ timeout &lt; 0 ) : DCNL DCSP DCSP DCSP logger.info ( u &apos;Unwrapping DCSP stream DCSP from DCSP URI DCSP ( % s ) DCSP failed : DCSP timed DCSP out DCSP in DCSP % sms &apos; , uri , timeout ) DCNL DCSP DCSP DCSP return ( None , None ) DCNL DCSP DCSP content = http.download ( requests _ session , uri , timeout = ( download _ timeout / 1000 ) ) DCNL DCSP DCSP if ( content is None ) : DCNL DCSP DCSP DCSP logger.info ( u &apos;Unwrapping DCSP stream DCSP from DCSP URI DCSP ( % s ) DCSP failed : DCSP error DCSP downloading DCSP URI DCSP % s &apos; , original _ uri , uri ) DCNL DCSP DCSP DCSP return ( None , None ) DCNL DCSP DCSP uris = playlists.parse ( content ) DCNL DCSP DCSP if ( not uris ) : DCNL DCSP DCSP DCSP logger.debug ( u &apos;Failed DCSP parsing DCSP URI DCSP ( % s ) DCSP as DCSP playlist ; DCSP found DCSP potential DCSP stream . &apos; , uri ) DCNL DCSP DCSP DCSP return ( uri , None ) DCNL DCSP DCSP logger.debug ( u &apos;Parsed DCSP playlist DCSP ( % s ) DCSP and DCSP found DCSP new DCSP URI : DCSP % s &apos; , uri , uris &#91; 0 &#93; ) DCNL DCSP DCSP uri = uris &#91; 0 &#93;
DCSP d = dict ( scanno = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) , logno = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) , kind = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) , range = float ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; f4 &apos; ) ) , cal = float ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; f4 &apos; ) ) , coil _ type = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) , loc = np.fromstring ( fid.read ( 48 ) , dtype = &apos; &gt; f4 &apos; ) .astype ( np.float64 ) , unit = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) , unit _ mul = int ( np.fromstring ( fid.read ( 4 ) , dtype = &apos; &gt; i4 &apos; ) ) ) DCNL DCSP ch _ name = np.fromstring ( fid.read ( 16 ) , dtype = &apos; &gt; c &apos; ) DCNL DCSP ch _ name = ch _ name &#91; : np.argmax ( ( ch _ name = = &apos; &apos; ) ) &#93; .tostring ( ) DCNL DCSP d &#91; &apos; ch _ name &apos; &#93; = ch _ name.decode ( ) DCNL DCSP d &#91; &apos; coord _ frame &apos; &#93; = _ coord _ dict.get ( d &#91; &apos; kind &apos; &#93; , FIFF.FIFFV _ COORD _ UNKNOWN ) DCNL DCSP return d
DCSP uuid = request.POST &#91; &apos; uuid &apos; &#93; DCNL DCSP resource = get _ object _ or _ 404 ( ResourceBase , uuid = uuid ) DCNL DCSP try : DCNL DCSP DCSP notification.send ( &#91; resource.owner &#93; , &apos; request _ download _ resourcebase &apos; , { &apos; from _ user &apos; : request.user , &apos; resource &apos; : resource } ) DCNL DCSP DCSP return HttpResponse ( json.dumps ( { &apos; success &apos; : &apos; ok &apos; } ) , status = 200 , content _ type = &apos; text / plain &apos; ) DCNL DCSP except : DCNL DCSP DCSP return HttpResponse ( json.dumps ( { &apos; error &apos; : &apos; error DCSP delivering DCSP notification &apos; } ) , status = 400 , content _ type = &apos; text / plain &apos; )
DCSP key = caller.db. _ multidesc _ editkey DCNL DCSP match = &#91; ind for ( ind , tup ) in enumerate ( caller.db.multidesc ) if ( tup &#91; 0 &#93; = = key ) &#93; DCNL DCSP if match : DCNL DCSP DCSP return caller.db.multidesc &#91; match &#91; 0 &#93; &#93; &#91; 1 &#93; DCNL DCSP return &apos; &apos;
DCSP redirects = { } DCNL DCSP print ( &apos; Parsing DCSP the DCSP NT DCSP redirect DCSP file &apos; ) DCNL DCSP for ( l , line ) in enumerate ( BZ2File ( redirects _ filename ) ) : DCNL DCSP DCSP split = line.split ( ) DCNL DCSP DCSP if ( len ( split ) ! = 4 ) : DCNL DCSP DCSP DCSP print ( ( &apos; ignoring DCSP malformed DCSP line : DCSP &apos; + line ) ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP redirects &#91; short _ name ( split &#91; 0 &#93; ) &#93; = short _ name ( split &#91; 2 &#93; ) DCNL DCSP DCSP if ( ( l % 1000000 ) = = 0 ) : DCNL DCSP DCSP DCSP print ( ( &apos; &#91; % s &#93; DCSP line : DCSP % 08d &apos; % ( datetime.now ( ) .isoformat ( ) , l ) ) ) DCNL DCSP print ( &apos; Computing DCSP the DCSP transitive DCSP closure DCSP of DCSP the DCSP redirect DCSP relation &apos; ) DCNL DCSP for ( l , source ) in enumerate ( redirects.keys ( ) ) : DCNL DCSP DCSP transitive _ target = None DCNL DCSP DCSP target = redirects &#91; source &#93; DCNL DCSP DCSP seen = set ( &#91; source &#93; ) DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP transitive _ target = target DCNL DCSP DCSP DCSP target = redirects.get ( target ) DCNL DCSP DCSP DCSP if ( ( target is None ) or ( target in seen ) ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP seen.add ( target ) DCNL DCSP DCSP redirects &#91; source &#93; = transitive _ target DCNL DCSP DCSP if ( ( l % 1000000 ) = = 0 ) : DCNL DCSP DCSP DCSP print ( ( &apos; &#91; % s &#93; DCSP line : DCSP % 08d &apos; % ( datetime.now ( ) .isoformat ( ) , l ) ) ) DCNL DCSP return redirects
DCSP looks = False DCNL DCSP if ( os.path.basename ( path ) in invalid _ names ) : DCNL DCSP DCSP return False DCNL DCSP if looks _ like _ a _ tool _ xml ( path ) : DCNL DCSP DCSP looks = True DCNL DCSP if ( ( not looks ) and enable _ beta _ formats ) : DCNL DCSP DCSP for tool _ checker in BETA _ TOOL _ CHECKERS.values ( ) : DCNL DCSP DCSP DCSP if tool _ checker ( path ) : DCNL DCSP DCSP DCSP DCSP looks = True DCNL DCSP DCSP DCSP DCSP break DCNL DCSP return looks
DCSP func.argtypes = &#91; c _ char _ p , c _ size _ t &#93; DCNL DCSP func.restype = GEOM _ PTR DCNL DCSP func.errcheck = check _ geom DCNL DCSP return func
DCSP if ( not trigger.group ( 2 ) ) : DCNL DCSP DCSP if ( trigger.sender not in bot.memory &#91; u &apos;last _ seen _ url &apos; &#93; ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP matched = check _ callbacks ( bot , trigger , bot.memory &#91; u &apos;last _ seen _ url &apos; &#93; &#91; trigger.sender &#93; , True ) DCNL DCSP DCSP if matched : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP urls = &#91; bot.memory &#91; u &apos;last _ seen _ url &apos; &#93; &#91; trigger.sender &#93; &#93; DCNL DCSP else : DCNL DCSP DCSP urls = re.findall ( url _ finder , trigger ) DCNL DCSP results = process _ urls ( bot , trigger , urls ) DCNL DCSP for ( title , domain ) in results &#91; : 4 &#93; : DCNL DCSP DCSP bot.reply ( ( u &apos; &#91; DCSP % s DCSP &#93; DCSP - DCSP % s &apos; % ( title , domain ) ) )
DCSP s _ pairs = get _ id _ pairs ( orig _ tracks ) DCNL DCSP d _ pairs = get _ id _ pairs ( modified _ tracks ) DCNL DCSP s _ count = Counter ( s _ pairs ) DCNL DCSP d _ count = Counter ( d _ pairs ) DCNL DCSP to _ del = ( s _ count - d _ count ) DCNL DCSP to _ add = ( d _ count - s _ count ) DCNL DCSP to _ keep = set ( ( s _ count &amp; d _ count ) ) DCNL DCSP return ( to _ del , to _ add , to _ keep )
DCSP if all ( ( vpc _ id , vpc _ name ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; Only DCSP one DCSP of DCSP vpc _ name DCSP or DCSP vpc _ id DCSP may DCSP be DCSP provided . &apos; ) DCNL DCSP if ( not any ( ( vpc _ id , vpc _ name , tags , cidr ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP provided : DCSP vpc _ id , DCSP vpc _ name , DCSP cidr DCSP or DCSP tags . &apos; ) DCNL DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP filter _ parameters = { &apos; filters &apos; : { } } DCNL DCSP if vpc _ id : DCNL DCSP DCSP filter _ parameters &#91; &apos; vpc _ ids &apos; &#93; = &#91; vpc _ id &#93; DCNL DCSP if cidr : DCNL DCSP DCSP filter _ parameters &#91; &apos; filters &apos; &#93; &#91; &apos; cidr &apos; &#93; = cidr DCNL DCSP if vpc _ name : DCNL DCSP DCSP filter _ parameters &#91; &apos; filters &apos; &#93; &#91; &apos; tag : Name &apos; &#93; = vpc _ name DCNL DCSP if tags : DCNL DCSP DCSP for ( tag _ name , tag _ value ) in six.iteritems ( tags ) : DCNL DCSP DCSP DCSP filter _ parameters &#91; &apos; filters &apos; &#93; &#91; &apos; tag : { 0 } &apos; .format ( tag _ name ) &#93; = tag _ value DCNL DCSP vpcs = conn.get _ all _ vpcs ( * * filter _ parameters ) DCNL DCSP log.debug ( &apos; The DCSP filters DCSP criteria DCSP { 0 } DCSP matched DCSP the DCSP following DCSP VPCs : { 1 } &apos; .format ( filter _ parameters , vpcs ) ) DCNL DCSP if vpcs : DCNL DCSP DCSP return &#91; vpc.id for vpc in vpcs &#93; DCNL DCSP else : DCNL DCSP DCSP return &#91; &#93;
DCSP ds = degree _ sequence &#91; : &#93; DCNL DCSP ds.sort ( ) DCNL DCSP while ds : DCNL DCSP DCSP if ( ds &#91; 0 &#93; = = 0 ) : DCNL DCSP DCSP DCSP ds.pop ( 0 ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( ds &#91; ( -1 ) &#93; ! = ( len ( ds ) - 1 ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP ds.pop ( ) DCNL DCSP DCSP ds = &#91; ( d - 1 ) for d in ds &#93; DCNL DCSP return True
DCSP if ( depth _ multiplier &lt; = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; depth _ multiplier DCSP is DCSP not DCSP greater DCSP than DCSP zero . &apos; ) DCNL DCSP depth = ( lambda d : max ( int ( ( d * depth _ multiplier ) ) , min _ depth ) ) DCNL DCSP with tf.variable _ scope ( scope , &apos; InceptionV3 &apos; , &#91; inputs , num _ classes &#93; , reuse = reuse ) as scope : DCNL DCSP DCSP with slim.arg _ scope ( &#91; slim.batch _ norm , slim.dropout &#93; , is _ training = is _ training ) : DCNL DCSP DCSP DCSP ( net , end _ points ) = inception _ v3 _ base ( inputs , scope = scope , min _ depth = min _ depth , depth _ multiplier = depth _ multiplier ) DCNL DCSP DCSP DCSP with slim.arg _ scope ( &#91; slim.conv2d , slim.max _ pool2d , slim.avg _ pool2d &#93; , stride = 1 , padding = &apos; SAME &apos; ) : DCNL DCSP DCSP DCSP DCSP aux _ logits = end _ points &#91; &apos; Mixed _ 6e &apos; &#93; DCNL DCSP DCSP DCSP DCSP with tf.variable _ scope ( &apos; AuxLogits &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP aux _ logits = slim.avg _ pool2d ( aux _ logits , &#91; 5 , 5 &#93; , stride = 3 , padding = &apos; VALID &apos; , scope = &apos; AvgPool _ 1a _ 5x5 &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP aux _ logits = slim.conv2d ( aux _ logits , depth ( 128 ) , &#91; 1 , 1 &#93; , scope = &apos; Conv2d _ 1b _ 1x1 &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP kernel _ size = _ reduced _ kernel _ size _ for _ small _ input ( aux _ logits , &#91; 5 , 5 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP aux _ logits = slim.conv2d ( aux _ logits , depth ( 768 ) , kernel _ size , weights _ initializer = trunc _ normal ( 0.01 ) , padding = &apos; VALID &apos; , scope = &apos; Conv2d _ 2a _ { } x { } &apos; .format ( * kernel _ size ) ) DCNL DCSP DCSP DCSP DCSP DCSP aux _ logits = slim.conv2d ( aux _ logits , num _ classes , &#91; 1 , 1 &#93; , activation _ fn = None , normalizer _ fn = None , weights _ initializer = trunc _ normal ( 0.001 ) , scope = &apos; Conv2d _ 2b _ 1x1 &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP if spatial _ squeeze : DCNL DCSP DCSP DCSP DCSP DCSP DCSP aux _ logits = tf.squeeze ( aux _ logits , &#91; 1 , 2 &#93; , name = &apos; SpatialSqueeze &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP end _ points &#91; &apos; AuxLogits &apos; &#93; = aux _ logits DCNL DCSP DCSP DCSP with tf.variable _ scope ( &apos; Logits &apos; ) : DCNL DCSP DCSP DCSP DCSP kernel _ size = _ reduced _ kernel _ size _ for _ small _ input ( net , &#91; 8 , 8 &#93; ) DCNL DCSP DCSP DCSP DCSP net = slim.avg _ pool2d ( net , kernel _ size , padding = &apos; VALID &apos; , scope = &apos; AvgPool _ 1a _ { } x { } &apos; .format ( * kernel _ size ) ) DCNL DCSP DCSP DCSP DCSP net = slim.dropout ( net , keep _ prob = dropout _ keep _ prob , scope = &apos; Dropout _ 1b &apos; ) DCNL DCSP DCSP DCSP DCSP end _ points &#91; &apos; PreLogits &apos; &#93; = net DCNL DCSP DCSP DCSP DCSP logits = slim.conv2d ( net , num _ classes , &#91; 1 , 1 &#93; , activation _ fn = None , normalizer _ fn = None , scope = &apos; Conv2d _ 1c _ 1x1 &apos; ) DCNL DCSP DCSP DCSP DCSP if spatial _ squeeze : DCNL DCSP DCSP DCSP DCSP DCSP logits = tf.squeeze ( logits , &#91; 1 , 2 &#93; , name = &apos; SpatialSqueeze &apos; ) DCNL DCSP DCSP DCSP end _ points &#91; &apos; Logits &apos; &#93; = logits DCNL DCSP DCSP DCSP end _ points &#91; &apos; Predictions &apos; &#93; = prediction _ fn ( logits , scope = &apos; Predictions &apos; ) DCNL DCSP return ( logits , end _ points )
DCSP a = TpPd ( pd = 5 ) DCNL DCSP b = MessageType ( mesType = 33 ) DCNL DCSP packet = ( a / b ) DCNL DCSP return packet
DCSP tg = TimeGrouper ( freq = rule , * * kwargs ) DCNL DCSP resampler = tg . _ get _ resampler ( groupby.obj , kind = kind ) DCNL DCSP r = resampler . _ get _ resampler _ for _ grouping ( groupby = groupby ) DCNL DCSP return _ maybe _ process _ deprecations ( r , how = how , fill _ method = fill _ method , limit = limit )
DCSP blacklist = &#91; int ( ds _ id ) for ds _ id in redis _ connection.smembers ( &apos; data _ sources : schema : blacklist &apos; ) if ds _ id &#93; DCNL DCSP global _ start _ time = time.time ( ) DCNL DCSP logger.info ( u &apos;task = refresh _ schemas DCSP state = start &apos; ) DCNL DCSP for ds in models.DataSource.query : DCNL DCSP DCSP if ds.paused : DCNL DCSP DCSP DCSP logger.info ( u &apos;task = refresh _ schema DCSP state = skip DCSP ds _ id = % s DCSP reason = paused ( % s ) &apos; , ds.id , ds.pause _ reason ) DCNL DCSP DCSP elif ( ds.id in blacklist ) : DCNL DCSP DCSP DCSP logger.info ( u &apos;task = refresh _ schema DCSP state = skip DCSP ds _ id = % s DCSP reason = blacklist &apos; , ds.id ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP logger.info ( u &apos;task = refresh _ schema DCSP state = start DCSP ds _ id = % s &apos; , ds.id ) DCNL DCSP DCSP DCSP start _ time = time.time ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ds.get _ schema ( refresh = True ) DCNL DCSP DCSP DCSP DCSP logger.info ( u &apos;task = refresh _ schema DCSP state = finished DCSP ds _ id = % s DCSP runtime = % .2f &apos; , ds.id , ( time.time ( ) - start _ time ) ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP logger.exception ( u &apos;Failed DCSP refreshing DCSP schema DCSP for DCSP the DCSP data DCSP source : DCSP % s &apos; , ds.name ) DCNL DCSP DCSP DCSP DCSP logger.info ( u &apos;task = refresh _ schema DCSP state = failed DCSP ds _ id = % s DCSP runtime = % .2f &apos; , ds.id , ( time.time ( ) - start _ time ) ) DCNL DCSP logger.info ( u &apos;task = refresh _ schemas DCSP state = finish DCSP total _ runtime = % .2f &apos; , ( time.time ( ) - global _ start _ time ) )
DCSP if ( ( not config _ file ) or ( not os.path.isfile ( config _ file ) ) ) : DCNL DCSP DCSP raise ApplicationException ( desc = ( &apos; Invalid DCSP configuration DCSP file : DCSP % s &apos; % config _ file ) ) DCNL DCSP try : DCNL DCSP DCSP return load _ source ( &apos; bgpspeaker.application.settings &apos; , config _ file ) DCNL DCSP except Exception as e : DCNL DCSP DCSP raise ApplicationException ( desc = str ( e ) )
DCSP position = bpath.find ( apath ) DCNL DCSP if ( position ! = 0 ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP rposition = ( position + len ( apath ) ) DCNL DCSP result = bpath &#91; rposition : &#93; DCNL DCSP if ( not result.startswith ( &apos; / &apos; ) ) : DCNL DCSP DCSP result = ( &apos; / &apos; + result ) DCNL DCSP return result
DCSP return u &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( ? x ) DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP flags = re.VERBOSE \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( ? P &lt; quote &gt; \ \ \ \ ? &#91; \ &apos; &quot; &#93; ) DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP the DCSP opening DCSP quotes \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( ? P &lt; prefix &gt; { prefix } ) DCSP DCSP DCSP DCSP DCSP DCSP # DCSP the DCSP prefix \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( ? P &lt; rest &gt; . * ? ) DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP everything DCSP else DCSP in DCSP the DCSP url \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( ? P = quote ) DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP the DCSP first DCSP matching DCSP closing DCSP quote \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; .format ( prefix = prefix )
DCSP err = &apos; &apos; DCNL DCSP if user : DCNL DCSP DCSP uid = _ _ salt _ _ &#91; &apos; file.user _ to _ uid &apos; &#93; ( user ) DCNL DCSP DCSP if ( uid = = &apos; &apos; ) : DCNL DCSP DCSP DCSP err + = &apos; User DCSP { 0 } DCSP is DCSP not DCSP available DCSP &apos; .format ( user ) DCNL DCSP if group : DCNL DCSP DCSP gid = _ _ salt _ _ &#91; &apos; file.group _ to _ gid &apos; &#93; ( group ) DCNL DCSP DCSP if ( gid = = &apos; &apos; ) : DCNL DCSP DCSP DCSP err + = &apos; Group DCSP { 0 } DCSP is DCSP not DCSP available &apos; .format ( group ) DCNL DCSP return err
DCSP if ignore _ errors : DCNL DCSP DCSP def onerror ( * args ) : DCNL DCSP DCSP DCSP pass DCNL DCSP elif ( onerror is None ) : DCNL DCSP DCSP def onerror ( * args ) : DCNL DCSP DCSP DCSP raise DCNL DCSP names = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP names = os.listdir ( path ) DCNL DCSP except os.error as err : DCNL DCSP DCSP onerror ( os.listdir , path , sys.exc _ info ( ) ) DCNL DCSP for name in names : DCNL DCSP DCSP fullname = os.path.join ( path , name ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP mode = os.lstat ( fullname ) .st _ mode DCNL DCSP DCSP except os.error : DCNL DCSP DCSP DCSP mode = 0 DCNL DCSP DCSP if stat.S _ ISDIR ( mode ) : DCNL DCSP DCSP DCSP rmtree ( fullname , ignore _ errors , onerror ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP os.remove ( fullname ) DCNL DCSP DCSP DCSP except os.error as err : DCNL DCSP DCSP DCSP DCSP onerror ( os.remove , fullname , sys.exc _ info ( ) ) DCNL DCSP try : DCNL DCSP DCSP os.rmdir ( path ) DCNL DCSP except os.error : DCNL DCSP DCSP onerror ( os.rmdir , path , sys.exc _ info ( ) )
DCSP if DEBUG _ ACCESS : DCNL DCSP DCSP log.debug ( * args , * * kwargs )
DCSP framed _ msg = { } DCNL DCSP if ( header is None ) : DCNL DCSP DCSP header = { } DCNL DCSP framed _ msg &#91; &apos; head &apos; &#93; = header DCNL DCSP framed _ msg &#91; &apos; body &apos; &#93; = body DCNL DCSP return msgpack.dumps ( framed _ msg )
DCSP url = &apos; { 0 } / api / v1 / namespaces / { 1 } / secrets / { 2 } &apos; .format ( apiserver _ url , namespace , name ) DCNL DCSP data = &#91; { &apos; op &apos; : &apos; replace &apos; , &apos; path &apos; : &apos; / data &apos; , &apos; value &apos; : data } &#93; DCNL DCSP ret = _ kpatch ( url , data ) DCNL DCSP if ( ret.get ( &apos; status &apos; ) = = 404 ) : DCNL DCSP DCSP return &quot; Node DCSP { 0 } DCSP doesn &apos;t DCSP exist &quot; .format ( url ) DCNL DCSP return ret
DCSP m = max ( x ) DCNL DCSP return &#91; i for ( i , v ) in enumerate ( x ) if ( v = = m ) &#93;
DCSP mode = session.s3.hrm.mode DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( mode is not None ) : DCNL DCSP DCSP DCSP auth.permission.fail ( ) DCNL DCSP DCSP if ( r.component _ name = = &apos; training &apos; ) : DCNL DCSP DCSP DCSP s3.crud _ strings &#91; &apos; hrm _ training &apos; &#93; .label _ create = T ( &apos; Add DCSP Trainee &apos; ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if ( ( not auth.s3 _ has _ role ( ADMIN ) ) and ( not s3.filter ) ) : DCNL DCSP DCSP s3.filter = auth.filter _ by _ root _ org ( s3db.hrm _ course ) DCNL DCSP output = s3 _ rest _ controller ( rheader = s3db.hrm _ rheader ) DCNL DCSP return output
DCSP data = argstoarray ( * args ) .astype ( float ) DCNL DCSP k = len ( data ) DCNL DCSP if ( k &lt; 3 ) : DCNL DCSP DCSP raise ValueError ( ( ( &apos; Less DCSP than DCSP 3 DCSP groups DCSP ( % i ) : DCSP &apos; % k ) + &apos; the DCSP Friedman DCSP test DCSP is DCSP NOT DCSP appropriate . &apos; ) ) DCNL DCSP ranked = ma.masked _ values ( rankdata ( data , axis = 0 ) , 0 ) DCNL DCSP if ( ranked . _ mask is not nomask ) : DCNL DCSP DCSP ranked = ma.mask _ cols ( ranked ) DCNL DCSP DCSP ranked = ranked.compressed ( ) .reshape ( k , ( -1 ) ) .view ( ndarray ) DCNL DCSP else : DCNL DCSP DCSP ranked = ranked . _ data DCNL DCSP ( k , n ) = ranked.shape DCNL DCSP repeats = np.array ( &#91; find _ repeats ( _ ) for _ in ranked.T &#93; , dtype = object ) DCNL DCSP ties = repeats &#91; repeats.nonzero ( ) &#93; .reshape ( ( -1 ) , 2 ) &#91; : , ( -1 ) &#93; .astype ( int ) DCNL DCSP tie _ correction = ( 1 - ( ( ( ties * * 3 ) - ties ) .sum ( ) / float ( ( n * ( ( k * * 3 ) - k ) ) ) ) ) DCNL DCSP ssbg = np.sum ( ( ( ranked.sum ( ( -1 ) ) - ( ( n * ( k + 1 ) ) / 2.0 ) ) * * 2 ) ) DCNL DCSP chisq = ( ( ( ( ssbg * 12.0 ) / ( ( n * k ) * ( k + 1 ) ) ) * 1.0 ) / tie _ correction ) DCNL DCSP return FriedmanchisquareResult ( chisq , distributions.chi2.sf ( chisq , ( k - 1 ) ) )
DCSP result = util.callm ( ( &apos; % s / % s &apos; % ( &apos; catalog &apos; , &apos; list &apos; ) ) , { &apos; results &apos; : results , &apos; start &apos; : start } ) DCNL DCSP cats = &#91; Catalog ( * * util.fix ( d ) ) for d in result &#91; &apos; response &apos; &#93; &#91; &apos; catalogs &apos; &#93; &#93; DCNL DCSP start = result &#91; &apos; response &apos; &#93; &#91; &apos; start &apos; &#93; DCNL DCSP total = result &#91; &apos; response &apos; &#93; &#91; &apos; total &apos; &#93; DCNL DCSP return ResultList ( cats , start , total )
DCSP if ( not isinstance ( hjson _ data , string _ types ) ) : DCNL DCSP DCSP hjson _ data = hjson _ data.read ( ) DCNL DCSP if hjson _ data.startswith ( &apos; # ! &apos; ) : DCNL DCSP DCSP hjson _ data = hjson _ data &#91; ( hjson _ data.find ( &apos; \ n &apos; ) + 1 ) : &#93; DCNL DCSP if ( not hjson _ data.strip ( ) ) : DCNL DCSP DCSP return { } DCNL DCSP return hjson.loads ( hjson _ data )
DCSP query = &apos; select DCSP release _ version \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP from DCSP system.local \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP limit DCSP 1 ; &apos; DCNL DCSP try : DCNL DCSP DCSP ret = cql _ query ( query , contact _ points , port , cql _ user , cql _ pass ) DCNL DCSP except CommandExecutionError : DCNL DCSP DCSP log.critical ( &apos; Could DCSP not DCSP get DCSP Cassandra DCSP version . &apos; ) DCNL DCSP DCSP raise DCNL DCSP except BaseException as e : DCNL DCSP DCSP log.critical ( &apos; Unexpected DCSP error DCSP while DCSP getting DCSP Cassandra DCSP version : DCSP { 0 } &apos; .format ( str ( e ) ) ) DCNL DCSP DCSP raise DCNL DCSP return ret &#91; 0 &#93; .get ( &apos; release _ version &apos; )
DCSP import tushare as ts DCNL DCSP import numpy as np DCNL DCSP import pandas as pd DCNL DCSP dfout = None DCNL DCSP valid _ dates = ts.get _ hist _ data ( code , start = start , end = end ) .index DCNL DCSP for date in valid _ dates : DCNL DCSP DCSP rng = pd.date _ range ( ( date + &apos; DCSP 9 : 30 : 00 &apos; ) , ( date + &apos; DCSP 15 : 00 &apos; ) , closed = &apos; right &apos; , freq = period ) DCNL DCSP DCSP sr = pd.Series ( np.nan , index = rng ) DCNL DCSP DCSP df = ts.get _ tick _ data ( code , date = date ) DCNL DCSP DCSP df.loc &#91; ( ( df.time &lt; &apos; 09 : 30 : 00 &apos; ) , &apos; time &apos; ) &#93; = &apos; 09 : 30 : 01 &apos; DCNL DCSP DCSP df.loc &#91; ( ( df.time &gt; &apos; 15 : 00 : 00 &apos; ) , &apos; time &apos; ) &#93; = &apos; 14 : 59 : 59 &apos; DCNL DCSP DCSP df &#91; &apos; time &apos; &#93; = ( ( date + &apos; DCSP &apos; ) + df &#91; &apos; time &apos; &#93; ) DCNL DCSP DCSP df = df.rename ( columns = { &apos; time &apos; : &apos; datetime &apos; } ) DCNL DCSP DCSP df &#91; &apos; datetime &apos; &#93; = pd.to _ datetime ( df &#91; &apos; datetime &apos; &#93; ) DCNL DCSP DCSP df = df.set _ index ( &apos; datetime &apos; ) .sort ( ) DCNL DCSP DCSP df2 = df &#91; &apos; volume &apos; &#93; .resample ( period , how = &apos; sum &apos; , closed = &apos; right &apos; , label = &apos; right &apos; ) DCNL DCSP DCSP ( df2 , dummy ) = df2.align ( sr , axis = 0 ) DCNL DCSP DCSP df3 = df2.truncate ( before = ( date + &apos; DCSP 13 : 00 : 01 &apos; ) , after = ( date + &apos; DCSP 15 : 00 &apos; ) ) DCNL DCSP DCSP df2 = df2.truncate ( before = ( date + &apos; DCSP 9 : 30 : 01 &apos; ) , after = ( date + &apos; DCSP 11 : 30 &apos; ) ) DCNL DCSP DCSP df2 = df2.append ( df3 ) .fillna ( 0 ) DCNL DCSP DCSP df1 = df &#91; &apos; price &apos; &#93; .resample ( period , how = &apos; ohlc &apos; , closed = &apos; right &apos; , label = &apos; right &apos; ) DCNL DCSP DCSP ( df1 , dummy ) = df1.align ( sr , axis = 0 ) DCNL DCSP DCSP df3 = df1.truncate ( before = ( date + &apos; DCSP 13 : 00 : 01 &apos; ) , after = ( date + &apos; DCSP 15 : 00 &apos; ) ) DCNL DCSP DCSP df1 = df1.truncate ( before = ( date + &apos; DCSP 9 : 30 : 01 &apos; ) , after = ( date + &apos; DCSP 11 : 30 &apos; ) ) DCNL DCSP DCSP df1 = df1.append ( df3 ) DCNL DCSP DCSP if np.isnan ( df1.ix &#91; ( 0 , &apos; close &apos; ) &#93; ) : DCNL DCSP DCSP DCSP from datetime import timedelta DCNL DCSP DCSP DCSP aDay = timedelta ( days = ( -10 ) ) DCNL DCSP DCSP DCSP pre = ( pd.to _ datetime ( date ) + aDay ) .strftime ( &apos; % Y- % m- % d &apos; ) DCNL DCSP DCSP DCSP df1.ix &#91; ( 0 , &apos; close &apos; ) &#93; = ts.get _ hist _ data ( code , start = pre , end = date ) .ix &#91; ( ( -2 ) , &apos; close &apos; ) &#93; DCNL DCSP DCSP df1 &#91; &apos; close &apos; &#93; .fillna ( method = &apos; pad &apos; , inplace = True ) DCNL DCSP DCSP df1.fillna ( method = &apos; bfill &apos; , inplace = True , axis = 1 ) DCNL DCSP DCSP df1 &#91; &apos; volume &apos; &#93; = df2.values DCNL DCSP DCSP dfout = pd.concat ( &#91; dfout , df1 &#93; ) DCNL DCSP return dfout
DCSP make _ segment ( 1 )
DCSP code _ gen = get _ code _ generator ( language , &apos; nothingElseMatters &apos; ) DCNL DCSP return code _ gen.routine ( name , expr , argument _ sequence , global _ vars )
DCSP tempdir = mkdtemp ( ) DCNL DCSP try : DCNL DCSP DCSP ( yield tempdir ) DCNL DCSP finally : DCNL DCSP DCSP rmtree ( tempdir )
DCSP now = datetime.datetime.now ( ) DCNL DCSP today = datetime.datetime ( now.year , now.month , now.day ) DCNL DCSP day _ offset = options.age DCNL DCSP before _ str = ( ( today - datetime.timedelta ( day _ offset ) ) .isoformat ( ) if ( day _ offset is not None ) else None ) DCNL DCSP return before _ str
DCSP ( results , new _ urlsafe _ start _ cursor , more ) = feedback _ models.FeedbackMessageModel.get _ all _ messages ( page _ size , urlsafe _ start _ cursor ) DCNL DCSP result _ messages = &#91; _ get _ message _ from _ model ( m ) for m in results &#93; DCNL DCSP return ( result _ messages , new _ urlsafe _ start _ cursor , more )
DCSP footnotes = domhelpers.findElementsWithAttribute ( document , &apos; class &apos; , &apos; footnote &apos; ) DCNL DCSP if ( not footnotes ) : DCNL DCSP DCSP return DCNL DCSP footnoteElement = dom.Element ( &apos; ol &apos; ) DCNL DCSP id = 1 DCNL DCSP for footnote in footnotes : DCNL DCSP DCSP href = dom.parseString ( ( &apos; &lt; a DCSP href = &quot; # footnote- % ( id ) d &quot; &gt; &lt; super &gt; % ( id ) d &lt; / super &gt; &lt; / a &gt; &apos; % vars ( ) ) ) .documentElement DCNL DCSP DCSP text = &apos; DCSP &apos; .join ( domhelpers.getNodeText ( footnote ) .split ( ) ) DCNL DCSP DCSP href.setAttribute ( &apos; title &apos; , text ) DCNL DCSP DCSP target = dom.Element ( &apos; a &apos; ) DCNL DCSP DCSP target.setAttribute ( &apos; name &apos; , ( &apos; footnote- % d &apos; % ( id , ) ) ) DCNL DCSP DCSP target.childNodes = &#91; footnote &#93; DCNL DCSP DCSP footnoteContent = dom.Element ( &apos; li &apos; ) DCNL DCSP DCSP footnoteContent.childNodes = &#91; target &#93; DCNL DCSP DCSP footnoteElement.childNodes.append ( footnoteContent ) DCNL DCSP DCSP footnote.parentNode.replaceChild ( href , footnote ) DCNL DCSP DCSP id + = 1 DCNL DCSP body = domhelpers.findNodesNamed ( document , &apos; body &apos; ) &#91; 0 &#93; DCNL DCSP header = dom.parseString ( &apos; &lt; h2 &gt; Footnotes &lt; / h2 &gt; &apos; ) .documentElement DCNL DCSP body.childNodes.append ( header ) DCNL DCSP body.childNodes.append ( footnoteElement )
DCSP reqres = check _ requirements ( ) DCNL DCSP if ( reqres = = CheckResult.Error ) : DCNL DCSP DCSP perr ( u &apos;Requirement DCSP checking DCSP failed &apos; ) DCNL DCSP DCSP sys.exit ( const.EFatal ) DCNL DCSP try : DCNL DCSP DCSP result = const.ENoError DCNL DCSP DCSP if ( argv is None ) : DCNL DCSP DCSP DCSP argv = sys.argv DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sys.argv.extend ( argv ) DCNL DCSP DCSP setuphandlers ( ) DCNL DCSP DCSP parser = getparser ( ) DCNL DCSP DCSP args = parser.parse _ args ( ) DCNL DCSP DCSP dl _ args = u &apos; &apos; DCNL DCSP DCSP if ( not args.downloader _ args ) : DCNL DCSP DCSP DCSP if ( const.DownloaderArgsEnvKey in os.environ ) : DCNL DCSP DCSP DCSP DCSP dl _ args = os.environ &#91; const.DownloaderArgsEnvKey &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP prefixlen = len ( const.DownloaderArgsIsFilePrefix ) DCNL DCSP DCSP DCSP if ( args.downloader _ args &#91; : prefixlen &#93; = = const.DownloaderArgsIsFilePrefix ) : DCNL DCSP DCSP DCSP DCSP with io.open ( args.downloader _ args &#91; prefixlen : &#93; , u &apos;r &apos; , encoding = u &apos;utf-8 &apos; ) as f : DCNL DCSP DCSP DCSP DCSP DCSP dl _ args = f.read ( ) .strip ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP dl _ args = args.downloader _ args DCNL DCSP DCSP if os.path.exists ( const.HashCachePath ) : DCNL DCSP DCSP DCSP cachesize = getfilesize ( const.HashCachePath ) DCNL DCSP DCSP DCSP if ( ( cachesize &gt; ( 10 * const.OneM ) ) or ( cachesize = = ( -1 ) ) ) : DCNL DCSP DCSP DCSP DCSP pr ( u &quot; * * * DCSP WARNING DCSP * * * \ nHash DCSP Cache DCSP file DCSP &apos; { 0 } &apos; DCSP is DCSP very DCSP large DCSP ( { 1 } ) . \ nThis DCSP may DCSP affect DCSP program &apos;s DCSP performance DCSP ( high DCSP memory DCSP consumption ) . \ nYou DCSP can DCSP first DCSP try DCSP to DCSP run DCSP &apos; bypy.py DCSP cleancache &apos; DCSP to DCSP slim DCSP the DCSP file . \ nBut DCSP if DCSP the DCSP file DCSP size DCSP won &apos;t DCSP reduce DCSP ( this DCSP warning DCSP persists ) , DCSP you DCSP may DCSP consider DCSP deleting DCSP / DCSP moving DCSP the DCSP Hash DCSP Cache DCSP file DCSP &apos; { 0 } &apos; \ n * * * DCSP WARNING DCSP * * * \ n \ n \ n &quot; .format ( const.HashCachePath , human _ size ( cachesize ) ) ) DCNL DCSP DCSP if ( args.clean &gt; = 1 ) : DCNL DCSP DCSP DCSP return clean _ prog _ files ( args.clean , args.verbose , args.configdir ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP slice _ size = interpret _ size ( args.slice ) DCNL DCSP DCSP except ( ValueError , KeyError ) : DCNL DCSP DCSP DCSP pr ( u &quot; Error : DCSP Invalid DCSP slice DCSP size DCSP specified DCSP &apos; { } &apos; &quot; .format ( args.slice ) ) DCNL DCSP DCSP DCSP return const.EArgument DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP chunk _ size = interpret _ size ( args.chunk ) DCNL DCSP DCSP except ( ValueError , KeyError ) : DCNL DCSP DCSP DCSP pr ( u &quot; Error : DCSP Invalid DCSP slice DCSP size DCSP specified DCSP &apos; { } &apos; &quot; .format ( args.slice ) ) DCNL DCSP DCSP DCSP return const.EArgument DCNL DCSP DCSP if ( ( len ( args.command ) &lt; = 0 ) or ( ( len ( args.command ) = = 1 ) and ( args.command &#91; 0 &#93; .lower ( ) = = u &apos;help &apos; ) ) ) : DCNL DCSP DCSP DCSP parser.print _ help ( ) DCNL DCSP DCSP DCSP return const.EArgument DCNL DCSP DCSP elif ( args.command &#91; 0 &#93; in ByPy . _ _ dict _ _ ) : DCNL DCSP DCSP DCSP cached.usecache = ( not args.forcehash ) DCNL DCSP DCSP DCSP by = ByPy ( slice _ size = slice _ size , dl _ chunk _ size = chunk _ size , verify = args.verify , retry = args.retry , timeout = args.timeout , quit _ when _ fail = args.quit , resumedownload = args.resumedl , incregex = args.incregex , ondup = args.ondup , followlink = args.followlink , checkssl = args.checkssl , cacerts = args.cacerts , rapiduploadonly = args.rapiduploadonly , mirror = args.mirror , selectmirror = args.selectmirror , configdir = args.configdir , resumedl _ revertcount = args.resumedl _ revertcount , downloader = args.downloader , downloader _ args = dl _ args , verbose = args.verbose , debug = args.debug ) DCNL DCSP DCSP DCSP uargs = &#91; &#93; DCNL DCSP DCSP DCSP for arg in args.command &#91; 1 : &#93; : DCNL DCSP DCSP DCSP DCSP if ( sys.version _ info &#91; 0 &#93; &lt; 3 ) : DCNL DCSP DCSP DCSP DCSP DCSP uargs.append ( unicode ( arg , gvar.SystemEncoding ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP uargs.append ( arg ) DCNL DCSP DCSP DCSP result = getattr ( by , args.command &#91; 0 &#93; ) ( * uargs ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP pr ( u &quot; Error : DCSP Command DCSP &apos; { } &apos; DCSP not DCSP available . &quot; .format ( args.command &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP parser.print _ help ( ) DCNL DCSP DCSP DCSP return const.EParameter DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP pr ( u &apos;KeyboardInterrupt &apos; ) DCNL DCSP DCSP pr ( u &apos;Abort &apos; ) DCNL DCSP except Exception as ex : DCNL DCSP DCSP perr ( u &apos;Exception DCSP occurred : \ n { } &apos; .format ( formatex ( ex ) ) ) DCNL DCSP DCSP pr ( u &apos;Abort &apos; ) DCNL DCSP DCSP raise DCNL DCSP quit ( result )
DCSP return _ role _ remove ( groupname , user = user , host = host , port = port , maintenance _ db = maintenance _ db , password = password , runas = runas )
DCSP ( a , axis ) = _ chk _ asarray ( a , axis ) DCNL DCSP ( contains _ nan , nan _ policy ) = _ contains _ nan ( a , nan _ policy ) DCNL DCSP if ( contains _ nan and ( nan _ policy = = &apos; omit &apos; ) ) : DCNL DCSP DCSP a = ma.masked _ invalid ( a ) DCNL DCSP DCSP return mstats _ basic.sem ( a , axis , ddof ) DCNL DCSP n = a.shape &#91; axis &#93; DCNL DCSP s = ( np.std ( a , axis = axis , ddof = ddof ) / np.sqrt ( n ) ) DCNL DCSP return s
DCSP mkdir _ p ( os.path.dirname ( path ) ) DCNL DCSP return open ( path , &apos; w &apos; )
DCSP ret = &#91; &#93; DCNL DCSP volumes = vm _ &#91; &apos; volumes &apos; &#93; DCNL DCSP for ( key , value ) in volumes.iteritems ( ) : DCNL DCSP DCSP if ( &apos; disk _ size &apos; not in volumes &#91; key &#93; .keys ( ) ) : DCNL DCSP DCSP DCSP raise SaltCloudConfigError ( &quot; The DCSP volume DCSP &apos; { 0 } &apos; DCSP is DCSP missing DCSP &apos; disk _ size &apos; &quot; .format ( key ) ) DCNL DCSP DCSP if ( &apos; disk _ type &apos; not in volumes &#91; key &#93; .keys ( ) ) : DCNL DCSP DCSP DCSP volumes &#91; key &#93; &#91; &apos; disk _ type &apos; &#93; = &apos; HDD &apos; DCNL DCSP DCSP volume = Volume ( name = key , size = volumes &#91; key &#93; &#91; &apos; disk _ size &apos; &#93; , disk _ type = volumes &#91; key &#93; &#91; &apos; disk _ type &apos; &#93; , licence _ type = &apos; OTHER &apos; ) DCNL DCSP DCSP if ( &apos; disk _ availability _ zone &apos; in volumes &#91; key &#93; .keys ( ) ) : DCNL DCSP DCSP DCSP volume.availability _ zone = volumes &#91; key &#93; &#91; &apos; disk _ availability _ zone &apos; &#93; DCNL DCSP DCSP ret.append ( volume ) DCNL DCSP return ret
DCSP fmt = &apos; ! BH32sH % ds &apos; DCNL DCSP structify = ( lambda t , p : struct.pack ( ( fmt % len ( p ) ) , 0 , 32 , t , len ( p ) , p ) ) DCNL DCSP binaryify = ( lambda t : t.decode ( &apos; hex &apos; ) ) DCNL DCSP if ( ( type ( notifications ) is dict ) and ( type ( tokens ) in ( str , unicode ) ) ) : DCNL DCSP DCSP ( tokens , notifications ) = ( &#91; tokens &#93; , &#91; notifications &#93; ) DCNL DCSP if ( ( type ( notifications ) is list ) and ( type ( tokens ) is list ) ) : DCNL DCSP DCSP return &apos; &apos;.join ( map ( ( lambda y : structify ( * y ) ) , ( ( binaryify ( t ) , json.dumps ( p , separators = ( &apos; , &apos; , &apos; : &apos; ) , ensure _ ascii = False ) .encode ( &apos; utf-8 &apos; ) ) for ( t , p ) in zip ( tokens , notifications ) ) ) )
DCSP _ easy _ install ( &#91; &apos; -U &apos; , &apos; setuptools &apos; &#93; , python _ cmd , use _ sudo )
DCSP f2 = &#91; &#93; DCNL DCSP for fname in fnames : DCNL DCSP DCSP f2.append ( fname _ presuffix ( fname , prefix , suffix , newpath , use _ ext ) ) DCNL DCSP return f2
DCSP if ( ccx is None ) : DCNL DCSP DCSP ccx = get _ ccx _ for _ coach ( course , request.user ) DCNL DCSP DCSP if ccx : DCNL DCSP DCSP DCSP url = reverse ( &apos; ccx _ coach _ dashboard &apos; , kwargs = { &apos; course _ id &apos; : CCXLocator.from _ course _ locator ( course.id , unicode ( ccx.id ) ) } ) DCNL DCSP DCSP DCSP return redirect ( url ) DCNL DCSP context = { &apos; course &apos; : course , &apos; ccx &apos; : ccx } DCNL DCSP context.update ( get _ ccx _ creation _ dict ( course ) ) DCNL DCSP if ccx : DCNL DCSP DCSP ccx _ locator = CCXLocator.from _ course _ locator ( course.id , unicode ( ccx.id ) ) DCNL DCSP DCSP assign _ staff _ role _ to _ ccx ( ccx _ locator , request.user , course.id ) DCNL DCSP DCSP schedule = get _ ccx _ schedule ( course , ccx ) DCNL DCSP DCSP grading _ policy = get _ override _ for _ ccx ( ccx , course , &apos; grading _ policy &apos; , course.grading _ policy ) DCNL DCSP DCSP context &#91; &apos; schedule &apos; &#93; = json.dumps ( schedule , indent = 4 ) DCNL DCSP DCSP context &#91; &apos; save _ url &apos; &#93; = reverse ( &apos; save _ ccx &apos; , kwargs = { &apos; course _ id &apos; : ccx _ locator } ) DCNL DCSP DCSP context &#91; &apos; ccx _ members &apos; &#93; = CourseEnrollment.objects.filter ( course _ id = ccx _ locator , is _ active = True ) DCNL DCSP DCSP context &#91; &apos; gradebook _ url &apos; &#93; = reverse ( &apos; ccx _ gradebook &apos; , kwargs = { &apos; course _ id &apos; : ccx _ locator } ) DCNL DCSP DCSP context &#91; &apos; grades _ csv _ url &apos; &#93; = reverse ( &apos; ccx _ grades _ csv &apos; , kwargs = { &apos; course _ id &apos; : ccx _ locator } ) DCNL DCSP DCSP context &#91; &apos; grading _ policy &apos; &#93; = json.dumps ( grading _ policy , indent = 4 ) DCNL DCSP DCSP context &#91; &apos; grading _ policy _ url &apos; &#93; = reverse ( &apos; ccx _ set _ grading _ policy &apos; , kwargs = { &apos; course _ id &apos; : ccx _ locator } ) DCNL DCSP DCSP with ccx _ course ( ccx _ locator ) as course : DCNL DCSP DCSP DCSP context &#91; &apos; course &apos; &#93; = course DCNL DCSP else : DCNL DCSP DCSP context &#91; &apos; create _ ccx _ url &apos; &#93; = reverse ( &apos; create _ ccx &apos; , kwargs = { &apos; course _ id &apos; : course.id } ) DCNL DCSP return render _ to _ response ( &apos; ccx / coach _ dashboard.html &apos; , context )
DCSP import frappe.async DCNL DCSP return frappe.async.publish _ progress ( * args , * * kwargs )
DCSP if isinstance ( url , Request _ ) : DCNL DCSP DCSP return url.get _ full _ url ( ) DCNL DCSP elif isinstance ( url , str ) : DCNL DCSP DCSP return url DCNL DCSP else : DCNL DCSP DCSP raise TypeError ( ( &apos; Expected DCSP type DCSP % r DCSP or DCSP % r &apos; % ( str , Request _ ) ) )
DCSP docs _ dir _ location = os.path.join ( PROJECT _ DIRECTORY , &apos; .ebextensions &apos; ) DCNL DCSP if os.path.exists ( docs _ dir _ location ) : DCNL DCSP DCSP shutil.rmtree ( docs _ dir _ location ) DCNL DCSP filenames = &#91; &apos; ebsetenv.py &apos; &#93; DCNL DCSP if ( &apos; { { DCSP cookiecutter.use _ heroku DCSP } } &apos; .lower ( ) ! = &apos; y &apos; ) : DCNL DCSP DCSP filenames.append ( &apos; requirements.txt &apos; ) DCNL DCSP for filename in filenames : DCNL DCSP DCSP os.remove ( os.path.join ( PROJECT _ DIRECTORY , filename ) )
DCSP event _ mask = 0 DCNL DCSP if readable : DCNL DCSP DCSP event _ mask &#124; = select.POLLIN DCNL DCSP if writable : DCNL DCSP DCSP event _ mask &#124; = select.POLLOUT DCNL DCSP if error : DCNL DCSP DCSP event _ mask &#124; = select.POLLERR DCNL DCSP pollable = select.poll ( ) DCNL DCSP pollable.register ( fd , event _ mask ) DCNL DCSP if timeout : DCNL DCSP DCSP event _ list = pollable.poll ( long ( ( timeout * 1000 ) ) ) DCNL DCSP else : DCNL DCSP DCSP event _ list = pollable.poll ( ) DCNL DCSP return bool ( event _ list )
DCSP def _ use _ gb _ ram ( num _ gb ) : DCNL DCSP DCSP u &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP to DCSP consume DCSP GB DCSP of DCSP memory \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP import sys DCNL DCSP DCSP bsize = ( sys.getsizeof ( u &apos; DCSP DCSP &apos; ) - sys.getsizeof ( u &apos; DCSP &apos; ) ) DCNL DCSP DCSP boffset = sys.getsizeof ( u &apos; &apos; ) DCNL DCSP DCSP num _ bytes = int ( ( num _ gb * ( 1024 * * 3 ) ) ) DCNL DCSP DCSP gb _ str = ( u &apos; DCSP &apos; * ( ( num _ bytes - boffset ) / / bsize ) ) DCNL DCSP DCSP assert ( sys.getsizeof ( gb _ str ) = = num _ bytes ) DCNL DCSP DCSP ctr = 0 DCNL DCSP DCSP while ( ctr &lt; 30000000.0 ) : DCNL DCSP DCSP DCSP ctr + = 1 DCNL DCSP DCSP del ctr DCNL DCSP DCSP del gb _ str DCNL DCSP from multiprocessing import Process DCNL DCSP from threading import Thread DCNL DCSP num _ gb = float ( num _ gb ) DCNL DCSP thread _ list = &#91; &#93; DCNL DCSP for idx in range ( num _ threads ) : DCNL DCSP DCSP thread = Thread ( target = _ use _ gb _ ram , args = ( ( num _ gb / num _ threads ) , ) , name = str ( idx ) ) DCNL DCSP DCSP thread _ list.append ( thread ) DCNL DCSP print ( ( u &apos;Using DCSP % .3f DCSP GB DCSP of DCSP memory DCSP over DCSP % d DCSP sub-threads ... &apos; % ( num _ gb , num _ threads ) ) ) DCNL DCSP for ( idx , thread ) in enumerate ( thread _ list ) : DCNL DCSP DCSP thread.start ( ) DCNL DCSP for thread in thread _ list : DCNL DCSP DCSP thread.join ( )
DCSP data _ dir = _ TempDir ( ) DCNL DCSP paths = datasets.megsim.load _ data ( &apos; index &apos; , &apos; text &apos; , &apos; text &apos; , path = data _ dir , update _ path = False ) DCNL DCSP assert _ equal ( len ( paths ) , 1 ) DCNL DCSP assert _ true ( paths &#91; 0 &#93; .endswith ( &apos; index.html &apos; ) )
DCSP ptype = { &apos; remote &apos; : AsyncRemotePillar , &apos; local &apos; : AsyncPillar } .get ( opts &#91; &apos; file _ client &apos; &#93; , AsyncPillar ) DCNL DCSP return ptype ( opts , grains , minion _ id , saltenv , ext , functions = funcs , pillar = pillar , pillarenv = pillarenv )
DCSP if ( salt.utils.is _ darwin ( ) or salt.utils.is _ windows ( ) ) : DCNL DCSP DCSP return True DCNL DCSP return False
DCSP from jmxfetch import JMX _ CHECKS DCNL DCSP if ( not checknames ) : DCNL DCSP DCSP checknames = JMX _ CHECKS DCNL DCSP agentConfig &#91; &apos; checksd _ hostname &apos; &#93; = hostname DCNL DCSP generated = { } DCNL DCSP for ( check _ name , service _ disco _ check _ config ) in _ service _ disco _ configs ( agentConfig ) .iteritems ( ) : DCNL DCSP DCSP if ( ( check _ name in checknames ) and ( check _ name in JMX _ CHECKS ) ) : DCNL DCSP DCSP DCSP log.debug ( ( &apos; Generating DCSP JMX DCSP config DCSP for : DCSP % s &apos; % check _ name ) ) DCNL DCSP DCSP DCSP ( sd _ init _ config , sd _ instances ) = service _ disco _ check _ config DCNL DCSP DCSP DCSP check _ config = { &apos; init _ config &apos; : sd _ init _ config , &apos; instances &apos; : sd _ instances } DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP yaml = config _ to _ yaml ( check _ config ) DCNL DCSP DCSP DCSP DCSP generated &#91; &apos; { } _ { } &apos; .format ( check _ name , 0 ) &#93; = yaml DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; YAML DCSP generated : DCSP % s &apos; , yaml ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP log.exception ( &apos; Unable DCSP to DCSP generate DCSP YAML DCSP config DCSP for DCSP % s &apos; , check _ name ) DCNL DCSP return generated
DCSP props = &#91; &#93; DCNL DCSP for objspec in propspec : DCNL DCSP DCSP if ( &apos; : &apos; not in objspec ) : DCNL DCSP DCSP DCSP raise Exception ( ( &quot; property DCSP specification DCSP &apos; % s &apos; DCSP does DCSP not DCSP contain DCSP property DCSP list &quot; % objspec ) ) DCNL DCSP DCSP ( objtype , objprops ) = objspec.split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP motype = getattr ( vim , objtype , None ) DCNL DCSP DCSP if ( motype is None ) : DCNL DCSP DCSP DCSP raise Exception ( ( &quot; referenced DCSP type DCSP &apos; % s &apos; DCSP in DCSP property DCSP specification DCSP does DCSP not DCSP exist , \ nconsult DCSP the DCSP managed DCSP object DCSP type DCSP reference DCSP in DCSP the DCSP vSphere DCSP API DCSP documentation &quot; % objtype ) ) DCNL DCSP DCSP proplist = objprops.split ( &apos; , &apos; ) DCNL DCSP DCSP props.append ( ( motype , proplist ) ) DCNL DCSP return props
DCSP return _ StripSeparators ( value ) .lower ( ) .strip ( )
DCSP for ( k , v ) in INDEX.items ( ) : DCNL DCSP DCSP for ( key , kwargs ) in v.items ( ) : DCNL DCSP DCSP DCSP client &#91; DATABASE _ NAME &#93; &#91; k &#93; .ensure _ index ( ( list ( key ) if ( type ( key ) = = types.TupleType ) else key ) , * * kwargs )
DCSP if getattr ( ogc _ server _ settings , &apos; BACKEND _ WRITE _ ENABLED &apos; , True ) : DCNL DCSP DCSP if ( not getattr ( instance , &apos; service &apos; , None ) ) : DCNL DCSP DCSP DCSP if instance.typename : DCNL DCSP DCSP DCSP DCSP cascading _ delete ( gs _ catalog , instance.typename )
DCSP if ( encoding is not None ) : DCNL DCSP DCSP s = s.decode ( encoding ) DCNL DCSP statements = &#91; &#93; DCNL DCSP for ( linenum , line ) in enumerate ( s.splitlines ( ) ) : DCNL DCSP DCSP line = line.strip ( ) DCNL DCSP DCSP if ( line.startswith ( u &apos; # &apos; ) or ( line = = u &apos; &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP statements.append ( _ read _ valuation _ line ( line ) ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise ValueError ( ( u &apos;Unable DCSP to DCSP parse DCSP line DCSP % s : DCSP % s &apos; % ( linenum , line ) ) ) DCNL DCSP return Valuation ( statements )
DCSP return &apos; { sel _ user } : { sel _ role } : { sel _ type } : { sel _ level } &apos; .format ( * * context )
DCSP addElementToListDictionary ( element , ( x , y ) , pixelDictionary )
DCSP if is _ valid _ ipv4 _ address ( address ) : DCNL DCSP DCSP return &apos; &apos;.join ( &#91; _ get _ binary ( int ( octet ) , 8 ) for octet in address.split ( &apos; .&apos; ) &#93; ) DCNL DCSP elif is _ valid _ ipv6 _ address ( address ) : DCNL DCSP DCSP address = expand _ ipv6 _ address ( address ) DCNL DCSP DCSP return &apos; &apos;.join ( &#91; _ get _ binary ( int ( grouping , 16 ) , 16 ) for grouping in address.split ( &apos; : &apos; ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &quot; &apos; % s &apos; DCSP is DCSP neither DCSP an DCSP IPv4 DCSP or DCSP IPv6 DCSP address &quot; % address ) )
DCSP cmd = &#91; &apos; netsh &apos; , &apos; interface &apos; , &apos; show &apos; , &apos; interface &apos; , &apos; name = { 0 } &apos; .format ( iface ) &#93; DCNL DCSP iface _ found = False DCNL DCSP for line in _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) .splitlines ( ) : DCNL DCSP DCSP if ( &apos; Connect DCSP state : &apos; in line ) : DCNL DCSP DCSP DCSP iface _ found = True DCNL DCSP DCSP DCSP return ( line.split ( ) &#91; ( -1 ) &#93; = = &apos; Connected &apos; ) DCNL DCSP if ( not iface _ found ) : DCNL DCSP DCSP raise CommandExecutionError ( &quot; Interface DCSP &apos; { 0 } &apos; DCSP not DCSP found &quot; .format ( iface ) ) DCNL DCSP return False
DCSP multigraph = G.is _ multigraph ( ) DCNL DCSP id _ = attrs &#91; &apos; id &apos; &#93; DCNL DCSP key = ( None if ( not multigraph ) else attrs &#91; &apos; key &apos; &#93; ) DCNL DCSP if ( id _ = = key ) : DCNL DCSP DCSP raise nx.NetworkXError ( &apos; Attribute DCSP names DCSP are DCSP not DCSP unique . &apos; ) DCNL DCSP data = { } DCNL DCSP data &#91; &apos; directed &apos; &#93; = G.is _ directed ( ) DCNL DCSP data &#91; &apos; multigraph &apos; &#93; = multigraph DCNL DCSP data &#91; &apos; graph &apos; &#93; = list ( G.graph.items ( ) ) DCNL DCSP data &#91; &apos; nodes &apos; &#93; = &#91; &#93; DCNL DCSP data &#91; &apos; adjacency &apos; &#93; = &#91; &#93; DCNL DCSP for ( n , nbrdict ) in G.adjacency ( ) : DCNL DCSP DCSP data &#91; &apos; nodes &apos; &#93; .append ( dict ( chain ( G.node &#91; n &#93; .items ( ) , &#91; ( id _ , n ) &#93; ) ) ) DCNL DCSP DCSP adj = &#91; &#93; DCNL DCSP DCSP if multigraph : DCNL DCSP DCSP DCSP for ( nbr , keys ) in nbrdict.items ( ) : DCNL DCSP DCSP DCSP DCSP for ( k , d ) in keys.items ( ) : DCNL DCSP DCSP DCSP DCSP DCSP adj.append ( dict ( chain ( d.items ( ) , &#91; ( id _ , nbr ) , ( key , k ) &#93; ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for ( nbr , d ) in nbrdict.items ( ) : DCNL DCSP DCSP DCSP DCSP adj.append ( dict ( chain ( d.items ( ) , &#91; ( id _ , nbr ) &#93; ) ) ) DCNL DCSP DCSP data &#91; &apos; adjacency &apos; &#93; .append ( adj ) DCNL DCSP return data
DCSP return IMPL.network _ delete _ safe ( context , network _ id )
DCSP arg _ mask = mask.split ( &apos; , &apos; ) DCNL DCSP arg _ mask.sort ( ) DCNL DCSP lst = _ _ salt _ _ &#91; &apos; incron.list _ tab &apos; &#93; ( user ) DCNL DCSP for cron in lst &#91; &apos; crons &apos; &#93; : DCNL DCSP DCSP if ( ( path = = cron &#91; &apos; path &apos; &#93; ) and ( cron &#91; &apos; cmd &apos; &#93; = = cmd ) ) : DCNL DCSP DCSP DCSP cron _ mask = cron &#91; &apos; mask &apos; &#93; .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP cron _ mask.sort ( ) DCNL DCSP DCSP DCSP if ( cron _ mask = = arg _ mask ) : DCNL DCSP DCSP DCSP DCSP return &apos; present &apos; DCNL DCSP DCSP DCSP if any ( &#91; ( x in cron _ mask ) for x in arg _ mask &#93; ) : DCNL DCSP DCSP DCSP DCSP return &apos; update &apos; DCNL DCSP return &apos; absent&apos;
DCSP raise nx.NetworkXError ( &quot; Frozen DCSP graph DCSP can &apos;t DCSP be DCSP modified &quot; )
DCSP queues _ helper = ReviewersQueuesHelper ( request ) DCNL DCSP apps = queues _ helper.get _ abuse _ queue ( ) DCNL DCSP page = paginate ( request , apps , per _ page = 20 ) DCNL DCSP abuse _ formset = AppAbuseViewFormSet ( ( request.POST or None ) , queryset = page.object _ list , request = request ) DCNL DCSP if abuse _ formset.is _ valid ( ) : DCNL DCSP DCSP abuse _ formset.save ( ) DCNL DCSP DCSP return redirect ( reverse ( &apos; reviewers.apps.queue _ abuse &apos; ) ) DCNL DCSP return render ( request , &apos; reviewers / queue.html &apos; , context ( request , abuse _ formset = abuse _ formset , tab = &apos; abuse &apos; , page = page ) )
DCSP vols = &#91; { &apos; reference &apos; : { &apos; source-name &apos; : ( &apos; volume- % s &apos; % fake.VOLUME _ ID ) } , &apos; size &apos; : 4 , &apos; extra _ info &apos; : &apos; qos _ setting : high &apos; , &apos; safe _ to _ manage &apos; : False , &apos; cinder _ id &apos; : fake.VOLUME _ ID , &apos; reason _ not _ safe &apos; : &apos; volume DCSP in DCSP use &apos; } , { &apos; reference &apos; : { &apos; source-name &apos; : &apos; myvol &apos; } , &apos; size &apos; : 5 , &apos; extra _ info &apos; : &apos; qos _ setting : low &apos; , &apos; safe _ to _ manage &apos; : True , &apos; cinder _ id &apos; : None , &apos; reason _ not _ safe &apos; : None } &#93; DCNL DCSP return vols
DCSP def check _ func ( x , y ) : DCNL DCSP DCSP array.assert _ array _ less ( x , y , err _ msg , verbose ) DCNL DCSP return _ make _ decorator ( check _ func , name , type _ check , accept _ error )
DCSP return verify _ ip _ hash _ cookie ( zmirror _ verify _ cookie )
DCSP a = TpPd ( pd = 3 ) DCNL DCSP b = MessageType ( mesType = 45 ) DCNL DCSP packet = ( a / b ) DCNL DCSP if ( Cause _ presence is 1 ) : DCNL DCSP DCSP c = CauseHdr ( ieiC = 8 , eightBitC = 0 ) DCNL DCSP DCSP packet = ( packet / c ) DCNL DCSP if ( Cause _ presence1 is 1 ) : DCNL DCSP DCSP d = CauseHdr ( ieiC = 8 , eightBitC = 0 ) DCNL DCSP DCSP packet = ( packet / d ) DCNL DCSP if ( Facility _ presence is 1 ) : DCNL DCSP DCSP e = FacilityHdr ( ieiF = 28 , eightBitF = 0 ) DCNL DCSP DCSP packet = ( packet / e ) DCNL DCSP if ( UserUser _ presence is 1 ) : DCNL DCSP DCSP f = UserUserHdr ( ieiUU = 126 , eightBitUU = 0 ) DCNL DCSP DCSP packet = ( packet / f ) DCNL DCSP if ( SsVersionIndicator _ presence is 1 ) : DCNL DCSP DCSP g = SsVersionIndicatorHdr ( ieiSVI = 127 , eightBitSVI = 0 ) DCNL DCSP DCSP packet = ( packet / g ) DCNL DCSP return packet
DCSP exc = getExc ( indent , ( prefix + &apos; DCSP DCSP &apos; ) , skip = 2 ) DCNL DCSP print ( ( &apos; &#91; % s &#93; DCSP DCSP % s \ n &apos; % ( time.strftime ( &apos; % H : % M : % S &apos; ) , msg ) ) ) DCNL DCSP print ( ( ( ( ( &apos; DCSP &apos; * indent ) + prefix ) + ( &apos; = &apos; * 30 ) ) + &apos; &gt; &gt; &apos; ) ) DCNL DCSP print ( exc ) DCNL DCSP print ( ( ( ( ( &apos; DCSP &apos; * indent ) + prefix ) + ( &apos; = &apos; * 30 ) ) + &apos; &lt; &lt; &apos; ) )
DCSP df = makeCustomDataframe ( nrows , ncols , c _ idx _ names = c _ idx _ names , r _ idx _ names = r _ idx _ names , c _ idx _ nlevels = c _ idx _ nlevels , r _ idx _ nlevels = r _ idx _ nlevels , data _ gen _ f = data _ gen _ f , c _ ndupe _ l = c _ ndupe _ l , r _ ndupe _ l = r _ ndupe _ l , dtype = dtype , c _ idx _ type = c _ idx _ type , r _ idx _ type = r _ idx _ type ) DCNL DCSP ( i , j ) = _ create _ missing _ idx ( nrows , ncols , density , random _ state ) DCNL DCSP df.values &#91; ( i , j ) &#93; = np.nan DCNL DCSP return df
DCSP addon _ status = file _ .version.addon.status DCNL DCSP if ( ( addon _ status = = amo.STATUS _ NOMINATED ) or ( ( addon _ status = = amo.STATUS _ PUBLIC ) and ( file _ .status = = amo.STATUS _ AWAITING _ REVIEW ) ) ) : DCNL DCSP DCSP return &apos; full&apos;
DCSP warnings.warn ( ZEST _ DEPRECATION ) DCNL DCSP _ update _ setup _ py _ version ( data &#91; u &apos;dev _ version &apos; &#93; )
DCSP hub = get _ hub ( ) DCNL DCSP watcher = hub.loop.idle ( ) DCNL DCSP if priority : DCNL DCSP DCSP watcher.priority = priority DCNL DCSP hub.wait ( watcher )
DCSP srs = Subreddit . _ by _ name ( sr _ names ) .values ( ) DCNL DCSP uploader = SubredditUploader ( g.CLOUDSEARCH _ SUBREDDIT _ DOC _ API , things = srs ) DCNL DCSP return uploader.inject ( )
DCSP document _ custom _ signature ( section , method _ name , method ) DCNL DCSP method _ intro _ section = section.add _ new _ section ( &apos; method-intro &apos; ) DCNL DCSP method _ intro _ section.writeln ( &apos; &apos; ) DCNL DCSP doc _ string = inspect.getdoc ( method ) DCNL DCSP if ( doc _ string is not None ) : DCNL DCSP DCSP method _ intro _ section.style.write _ py _ doc _ string ( doc _ string )
DCSP if isinstance ( which _ method , six.string _ types ) : DCNL DCSP DCSP which _ method = &#91; which _ method &#93; DCNL DCSP if ( ( rng _ or _ seed is not None ) and all ( ( hasattr ( rng _ or _ seed , attr ) for attr in which _ method ) ) ) : DCNL DCSP DCSP rng = rng _ or _ seed DCNL DCSP elif ( rng _ or _ seed is not None ) : DCNL DCSP DCSP rng = constructor ( rng _ or _ seed ) DCNL DCSP elif ( default _ seed is not None ) : DCNL DCSP DCSP rng = constructor ( default _ seed ) DCNL DCSP else : DCNL DCSP DCSP rng = constructor ( 42 ) DCNL DCSP return rng
DCSP out = { } DCNL DCSP for ( k , v ) in iteritems ( d ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP out &#91; v &#93; .add ( k ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP out &#91; v &#93; = { k } DCNL DCSP return out
DCSP start _ pos = 0 DCNL DCSP split _ pos _ list = &#91; match.start ( ) for match in re.finditer ( &apos; \ \ &#124; &apos; , pattern ) &#93; DCNL DCSP split _ pos _ list.append ( len ( pattern ) ) DCNL DCSP for end _ pos in split _ pos _ list : DCNL DCSP DCSP if ( not _ position _ is _ bracketed ( pattern , end _ pos ) ) : DCNL DCSP DCSP DCSP ( yield pattern &#91; start _ pos : end _ pos &#93; ) DCNL DCSP DCSP DCSP start _ pos = ( end _ pos + 1 )
DCSP kwargs = ( extra _ filters or { } ) DCNL DCSP if ( instance is not None ) : DCNL DCSP DCSP kwargs.update ( { ( &apos; % s _ _ content _ object &apos; % cls.tag _ relname ( ) ) : instance } ) DCNL DCSP DCSP return cls.tag _ model ( ) .objects.filter ( * * kwargs ) DCNL DCSP kwargs.update ( { ( &apos; % s _ _ content _ object _ _ isnull &apos; % cls.tag _ relname ( ) ) : False } ) DCNL DCSP return cls.tag _ model ( ) .objects.filter ( * * kwargs ) .distinct ( )
DCSP from flask _ babel import Babel DCNL DCSP babel = Babel ( app ) DCNL DCSP supported = app.config.get ( &apos; BABEL _ SUPPORTED _ LOCALES &apos; , &#91; &apos; en &apos; , &apos; zh &apos; &#93; ) DCNL DCSP default = app.config.get ( &apos; BABEL _ DEFAULT _ LOCALE &apos; , &apos; en &apos; ) DCNL DCSP @ babel.localeselector DCNL DCSP def get _ locale ( ) : DCNL DCSP DCSP return request.accept _ languages.best _ match ( supported , default )
DCSP if ( mode = = &apos; nearest &apos; ) : DCNL DCSP DCSP return 0 DCNL DCSP elif ( mode = = &apos; wrap &apos; ) : DCNL DCSP DCSP return 1 DCNL DCSP elif ( mode = = &apos; reflect &apos; ) : DCNL DCSP DCSP return 2 DCNL DCSP elif ( mode = = &apos; mirror &apos; ) : DCNL DCSP DCSP return 3 DCNL DCSP elif ( mode = = &apos; constant &apos; ) : DCNL DCSP DCSP return 4 DCNL DCSP else : DCNL DCSP DCSP raise RuntimeError ( &apos; boundary DCSP mode DCSP not DCSP supported &apos; )
DCSP ndim = nditerty.ndim DCNL DCSP layout = nditerty.layout DCNL DCSP narrays = len ( nditerty.arrays ) DCNL DCSP nshapes = ( ndim if nditerty.need _ shaped _ indexing else 1 ) DCNL DCSP class BaseSubIter ( object , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Base DCSP class DCSP for DCSP sub-iterators DCSP of DCSP a DCSP nditer ( ) DCSP instance . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def _ _ init _ _ ( self , nditer , member _ name , start _ dim , end _ dim ) : DCNL DCSP DCSP DCSP self.nditer = nditer DCNL DCSP DCSP DCSP self.member _ name = member _ name DCNL DCSP DCSP DCSP self.start _ dim = start _ dim DCNL DCSP DCSP DCSP self.end _ dim = end _ dim DCNL DCSP DCSP DCSP self.ndim = ( end _ dim - start _ dim ) DCNL DCSP DCSP def set _ member _ ptr ( self , ptr ) : DCNL DCSP DCSP DCSP setattr ( self.nditer , self.member _ name , ptr ) DCNL DCSP DCSP @ utils.cached _ property DCNL DCSP DCSP def member _ ptr ( self ) : DCNL DCSP DCSP DCSP return getattr ( self.nditer , self.member _ name ) DCNL DCSP DCSP def init _ specific ( self , context , builder ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP def loop _ continue ( self , context , builder , logical _ dim ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP def loop _ break ( self , context , builder , logical _ dim ) : DCNL DCSP DCSP DCSP pass DCNL DCSP class FlatSubIter ( BaseSubIter , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP order , DCSP with \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP support DCSP for DCSP broadcasting DCSP ( the DCSP index DCSP is DCSP reset DCSP on DCSP the DCSP outer DCSP dimension ) . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def init _ specific ( self , context , builder ) : DCNL DCSP DCSP DCSP zero = context.get _ constant ( types.intp , 0 ) DCNL DCSP DCSP DCSP self.set _ member _ ptr ( cgutils.alloca _ once _ value ( builder , zero ) ) DCNL DCSP DCSP def compute _ pointer ( self , context , builder , indices , arrty , arr ) : DCNL DCSP DCSP DCSP index = builder.load ( self.member _ ptr ) DCNL DCSP DCSP DCSP return builder.gep ( arr.data , &#91; index &#93; ) DCNL DCSP DCSP def loop _ continue ( self , context , builder , logical _ dim ) : DCNL DCSP DCSP DCSP if ( logical _ dim = = ( self.ndim - 1 ) ) : DCNL DCSP DCSP DCSP DCSP index = builder.load ( self.member _ ptr ) DCNL DCSP DCSP DCSP DCSP index = cgutils.increment _ index ( builder , index ) DCNL DCSP DCSP DCSP DCSP builder.store ( index , self.member _ ptr ) DCNL DCSP DCSP def loop _ break ( self , context , builder , logical _ dim ) : DCNL DCSP DCSP DCSP if ( logical _ dim = = 0 ) : DCNL DCSP DCSP DCSP DCSP zero = context.get _ constant ( types.intp , 0 ) DCNL DCSP DCSP DCSP DCSP builder.store ( zero , self.member _ ptr ) DCNL DCSP DCSP DCSP elif ( logical _ dim = = ( self.ndim - 1 ) ) : DCNL DCSP DCSP DCSP DCSP index = builder.load ( self.member _ ptr ) DCNL DCSP DCSP DCSP DCSP index = cgutils.increment _ index ( builder , index ) DCNL DCSP DCSP DCSP DCSP builder.store ( index , self.member _ ptr ) DCNL DCSP class TrivialFlatSubIter ( BaseSubIter , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP order , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP * without * DCSP support DCSP for DCSP broadcasting . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def init _ specific ( self , context , builder ) : DCNL DCSP DCSP DCSP assert ( not nditerty.need _ shaped _ indexing ) DCNL DCSP DCSP def compute _ pointer ( self , context , builder , indices , arrty , arr ) : DCNL DCSP DCSP DCSP assert ( len ( indices ) &lt; = 1 ) , len ( indices ) DCNL DCSP DCSP DCSP return builder.gep ( arr.data , indices ) DCNL DCSP class IndexedSubIter ( BaseSubIter , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Sub-iterator DCSP walking DCSP an DCSP array DCSP in DCSP logical DCSP order . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def compute _ pointer ( self , context , builder , indices , arrty , arr ) : DCNL DCSP DCSP DCSP assert ( len ( indices ) = = self.ndim ) DCNL DCSP DCSP DCSP return cgutils.get _ item _ pointer ( builder , arrty , arr , indices , wraparound = False ) DCNL DCSP class ZeroDimSubIter ( BaseSubIter , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Sub-iterator DCSP &quot; walking &quot; DCSP a DCSP 0-d DCSP array . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def compute _ pointer ( self , context , builder , indices , arrty , arr ) : DCNL DCSP DCSP DCSP return arr.data DCNL DCSP class ScalarSubIter ( BaseSubIter , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Sub-iterator DCSP &quot; walking &quot; DCSP a DCSP scalar DCSP value . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def compute _ pointer ( self , context , builder , indices , arrty , arr ) : DCNL DCSP DCSP DCSP return arr DCNL DCSP class NdIter ( cgutils.create _ struct _ proxy ( nditerty ) , ) : DCNL DCSP DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP .nditer ( ) DCSP implementation . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Note : DCSP &apos; F &apos; DCSP layout DCSP means DCSP the DCSP shape DCSP is DCSP iterated DCSP in DCSP reverse DCSP logical DCSP order , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP so DCSP indices DCSP and DCSP shapes DCSP arrays DCSP have DCSP to DCSP be DCSP reversed DCSP as DCSP well . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; DCNL DCSP DCSP @ utils.cached _ property DCNL DCSP DCSP def subiters ( self ) : DCNL DCSP DCSP DCSP l = &#91; &#93; DCNL DCSP DCSP DCSP factories = { &apos; flat &apos; : ( FlatSubIter if nditerty.need _ shaped _ indexing else TrivialFlatSubIter ) , &apos; indexed &apos; : IndexedSubIter , &apos; 0d &apos; : ZeroDimSubIter , &apos; scalar &apos; : ScalarSubIter } DCNL DCSP DCSP DCSP for ( i , sub ) in enumerate ( nditerty.indexers ) : DCNL DCSP DCSP DCSP DCSP ( kind , start _ dim , end _ dim , _ ) = sub DCNL DCSP DCSP DCSP DCSP member _ name = ( &apos; index % d &apos; % i ) DCNL DCSP DCSP DCSP DCSP factory = factories &#91; kind &#93; DCNL DCSP DCSP DCSP DCSP l.append ( factory ( self , member _ name , start _ dim , end _ dim ) ) DCNL DCSP DCSP DCSP return l DCNL DCSP DCSP def init _ specific ( self , context , builder , arrtys , arrays ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Initialize DCSP the DCSP nditer ( ) DCSP instance DCSP for DCSP the DCSP specific DCSP array DCSP inputs . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP zero = context.get _ constant ( types.intp , 0 ) DCNL DCSP DCSP DCSP self.arrays = context.make _ tuple ( builder , types.Tuple ( arrtys ) , arrays ) DCNL DCSP DCSP DCSP for ( i , ty ) in enumerate ( arrtys ) : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( ty , types.Array ) ) : DCNL DCSP DCSP DCSP DCSP DCSP member _ name = ( &apos; scalar % d &apos; % i ) DCNL DCSP DCSP DCSP DCSP DCSP slot = cgutils.alloca _ once _ value ( builder , arrays &#91; i &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP setattr ( self , member _ name , slot ) DCNL DCSP DCSP DCSP arrays = self . _ arrays _ or _ scalars ( context , builder , arrtys , arrays ) DCNL DCSP DCSP DCSP main _ shape _ ty = types.UniTuple ( types.intp , ndim ) DCNL DCSP DCSP DCSP main _ shape = None DCNL DCSP DCSP DCSP main _ nitems = None DCNL DCSP DCSP DCSP for ( i , arrty ) in enumerate ( arrtys ) : DCNL DCSP DCSP DCSP DCSP if ( isinstance ( arrty , types.Array ) and ( arrty.ndim = = ndim ) ) : DCNL DCSP DCSP DCSP DCSP DCSP main _ shape = arrays &#91; i &#93; .shape DCNL DCSP DCSP DCSP DCSP DCSP main _ nitems = arrays &#91; i &#93; .nitems DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( ndim = = 0 ) DCNL DCSP DCSP DCSP DCSP main _ shape = context.make _ tuple ( builder , main _ shape _ ty , ( ) ) DCNL DCSP DCSP DCSP DCSP main _ nitems = context.get _ constant ( types.intp , 1 ) DCNL DCSP DCSP DCSP def check _ shape ( shape , main _ shape ) : DCNL DCSP DCSP DCSP DCSP n = len ( shape ) DCNL DCSP DCSP DCSP DCSP for i in range ( n ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( shape &#91; i &#93; ! = main _ shape &#91; ( ( len ( main _ shape ) - n ) + i ) &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise ValueError ( &apos; nditer ( ) : DCSP operands DCSP could DCSP not DCSP be DCSP broadcast DCSP together &apos; ) DCNL DCSP DCSP DCSP for ( arrty , arr ) in zip ( arrtys , arrays ) : DCNL DCSP DCSP DCSP DCSP if ( isinstance ( arrty , types.Array ) and ( arrty.ndim &gt; 0 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP context.compile _ internal ( builder , check _ shape , signature ( types.none , types.UniTuple ( types.intp , arrty.ndim ) , main _ shape _ ty ) , ( arr.shape , main _ shape ) ) DCNL DCSP DCSP DCSP shapes = cgutils.unpack _ tuple ( builder , main _ shape ) DCNL DCSP DCSP DCSP if ( layout = = &apos; F &apos; ) : DCNL DCSP DCSP DCSP DCSP shapes = shapes &#91; : : ( -1 ) &#93; DCNL DCSP DCSP DCSP shape _ is _ empty = builder.icmp _ signed ( &apos; = = &apos; , main _ nitems , zero ) DCNL DCSP DCSP DCSP exhausted = builder.select ( shape _ is _ empty , cgutils.true _ byte , cgutils.false _ byte ) DCNL DCSP DCSP DCSP if ( not nditerty.need _ shaped _ indexing ) : DCNL DCSP DCSP DCSP DCSP shapes = ( main _ nitems , ) DCNL DCSP DCSP DCSP assert ( len ( shapes ) = = nshapes ) DCNL DCSP DCSP DCSP indices = cgutils.alloca _ once ( builder , zero.type , size = nshapes ) DCNL DCSP DCSP DCSP for dim in range ( nshapes ) : DCNL DCSP DCSP DCSP DCSP idxptr = cgutils.gep _ inbounds ( builder , indices , dim ) DCNL DCSP DCSP DCSP DCSP builder.store ( zero , idxptr ) DCNL DCSP DCSP DCSP self.indices = indices DCNL DCSP DCSP DCSP self.shape = cgutils.pack _ array ( builder , shapes , zero.type ) DCNL DCSP DCSP DCSP self.exhausted = cgutils.alloca _ once _ value ( builder , exhausted ) DCNL DCSP DCSP DCSP for subiter in self.subiters : DCNL DCSP DCSP DCSP DCSP subiter.init _ specific ( context , builder ) DCNL DCSP DCSP def iternext _ specific ( self , context , builder , result ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Compute DCSP next DCSP iteration DCSP of DCSP the DCSP nditer ( ) DCSP instance . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP bbend = builder.append _ basic _ block ( &apos; end &apos; ) DCNL DCSP DCSP DCSP exhausted = cgutils.as _ bool _ bit ( builder , builder.load ( self.exhausted ) ) DCNL DCSP DCSP DCSP with cgutils.if _ unlikely ( builder , exhausted ) : DCNL DCSP DCSP DCSP DCSP result.set _ valid ( False ) DCNL DCSP DCSP DCSP DCSP builder.branch ( bbend ) DCNL DCSP DCSP DCSP arrtys = nditerty.arrays DCNL DCSP DCSP DCSP arrays = cgutils.unpack _ tuple ( builder , self.arrays ) DCNL DCSP DCSP DCSP arrays = self . _ arrays _ or _ scalars ( context , builder , arrtys , arrays ) DCNL DCSP DCSP DCSP indices = self.indices DCNL DCSP DCSP DCSP result.set _ valid ( True ) DCNL DCSP DCSP DCSP views = self . _ make _ views ( context , builder , indices , arrtys , arrays ) DCNL DCSP DCSP DCSP views = &#91; v. _ getvalue ( ) for v in views &#93; DCNL DCSP DCSP DCSP if ( len ( views ) = = 1 ) : DCNL DCSP DCSP DCSP DCSP result.yield _ ( views &#91; 0 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP result.yield _ ( context.make _ tuple ( builder , nditerty.yield _ type , views ) ) DCNL DCSP DCSP DCSP shape = cgutils.unpack _ tuple ( builder , self.shape ) DCNL DCSP DCSP DCSP _ increment _ indices ( context , builder , len ( shape ) , shape , indices , self.exhausted , functools.partial ( self . _ loop _ continue , context , builder ) , functools.partial ( self . _ loop _ break , context , builder ) ) DCNL DCSP DCSP DCSP builder.branch ( bbend ) DCNL DCSP DCSP DCSP builder.position _ at _ end ( bbend ) DCNL DCSP DCSP def _ loop _ continue ( self , context , builder , dim ) : DCNL DCSP DCSP DCSP for sub in self.subiters : DCNL DCSP DCSP DCSP DCSP if ( sub.start _ dim &lt; = dim &lt; sub.end _ dim ) : DCNL DCSP DCSP DCSP DCSP DCSP sub.loop _ continue ( context , builder , ( dim - sub.start _ dim ) ) DCNL DCSP DCSP def _ loop _ break ( self , context , builder , dim ) : DCNL DCSP DCSP DCSP for sub in self.subiters : DCNL DCSP DCSP DCSP DCSP if ( sub.start _ dim &lt; = dim &lt; sub.end _ dim ) : DCNL DCSP DCSP DCSP DCSP DCSP sub.loop _ break ( context , builder , ( dim - sub.start _ dim ) ) DCNL DCSP DCSP def _ make _ views ( self , context , builder , indices , arrtys , arrays ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Compute DCSP the DCSP views DCSP to DCSP be DCSP yielded . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP views = ( &#91; None &#93; * narrays ) DCNL DCSP DCSP DCSP indexers = nditerty.indexers DCNL DCSP DCSP DCSP subiters = self.subiters DCNL DCSP DCSP DCSP rettys = nditerty.yield _ type DCNL DCSP DCSP DCSP if isinstance ( rettys , types.BaseTuple ) : DCNL DCSP DCSP DCSP DCSP rettys = list ( rettys ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP rettys = &#91; rettys &#93; DCNL DCSP DCSP DCSP indices = &#91; builder.load ( cgutils.gep _ inbounds ( builder , indices , i ) ) for i in range ( nshapes ) &#93; DCNL DCSP DCSP DCSP for ( sub , subiter ) in zip ( indexers , subiters ) : DCNL DCSP DCSP DCSP DCSP ( _ , _ , _ , array _ indices ) = sub DCNL DCSP DCSP DCSP DCSP sub _ indices = indices &#91; subiter.start _ dim : subiter.end _ dim &#93; DCNL DCSP DCSP DCSP DCSP if ( layout = = &apos; F &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP sub _ indices = sub _ indices &#91; : : ( -1 ) &#93; DCNL DCSP DCSP DCSP DCSP for i in array _ indices : DCNL DCSP DCSP DCSP DCSP DCSP assert ( views &#91; i &#93; is None ) DCNL DCSP DCSP DCSP DCSP DCSP views &#91; i &#93; = self . _ make _ view ( context , builder , sub _ indices , rettys &#91; i &#93; , arrtys &#91; i &#93; , arrays &#91; i &#93; , subiter ) DCNL DCSP DCSP DCSP assert all ( ( v for v in views ) ) DCNL DCSP DCSP DCSP return views DCNL DCSP DCSP def _ make _ view ( self , context , builder , indices , retty , arrty , arr , subiter ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Compute DCSP a DCSP 0d DCSP view DCSP for DCSP a DCSP given DCSP input DCSP array . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP assert ( isinstance ( retty , types.Array ) and ( retty.ndim = = 0 ) ) DCNL DCSP DCSP DCSP ptr = subiter.compute _ pointer ( context , builder , indices , arrty , arr ) DCNL DCSP DCSP DCSP view = context.make _ array ( retty ) ( context , builder ) DCNL DCSP DCSP DCSP itemsize = get _ itemsize ( context , retty ) DCNL DCSP DCSP DCSP shape = context.make _ tuple ( builder , types.UniTuple ( types.intp , 0 ) , ( ) ) DCNL DCSP DCSP DCSP strides = context.make _ tuple ( builder , types.UniTuple ( types.intp , 0 ) , ( ) ) DCNL DCSP DCSP DCSP populate _ array ( view , ptr , shape , strides , itemsize , meminfo = None ) DCNL DCSP DCSP DCSP return view DCNL DCSP DCSP def _ arrays _ or _ scalars ( self , context , builder , arrtys , arrays ) : DCNL DCSP DCSP DCSP l = &#91; &#93; DCNL DCSP DCSP DCSP for ( i , ( arrty , arr ) ) in enumerate ( zip ( arrtys , arrays ) ) : DCNL DCSP DCSP DCSP DCSP if isinstance ( arrty , types.Array ) : DCNL DCSP DCSP DCSP DCSP DCSP l.append ( context.make _ array ( arrty ) ( context , builder , value = arr ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP l.append ( getattr ( self , ( &apos; scalar % d &apos; % i ) ) ) DCNL DCSP DCSP DCSP return l DCNL DCSP return NdIter
DCSP return http.HttpResponse ( ( NullSource + InterPolate ) , &apos; text / javascript &apos; )
DCSP try : DCNL DCSP DCSP path = decode _ path _ info ( path ) DCNL DCSP except UnicodeDecodeError as e : DCNL DCSP DCSP raise URLDecodeError ( e.encoding , e.object , e.start , e.end , e.reason ) DCNL DCSP return split _ path _ info ( path )
DCSP nn = &apos; rnd &apos; DCNL DCSP ada = ADASYN ( random _ state = RND _ SEED , n _ neighbors = nn ) DCNL DCSP assert _ raises ( ValueError , ada.fit _ sample , X , Y )
DCSP snapshot = cs.monitor _ snapshots.create ( args.monitor _ id , args.force , args.display _ name , args.display _ description ) DCNL DCSP _ print _ monitor _ snapshot ( snapshot )
DCSP if ( ordered is True ) : DCNL DCSP DCSP grains = _ _ grains _ _ DCNL DCSP else : DCNL DCSP DCSP grains = json.loads ( json.dumps ( _ _ grains _ _ ) ) DCNL DCSP return salt.utils.traverse _ dict _ and _ list ( grains , key , default , delimiter )
DCSP import random DCNL DCSP items = &apos; egg , bacon , sausage , baked DCSP beans , tomato &apos; .split ( &apos; , &apos; ) DCNL DCSP random.shuffle ( items ) DCNL DCSP breakfast = items &#91; : random.randint ( 0 , len ( items ) ) &#93; DCNL DCSP breakfast + = ( &#91; &apos; spam &apos; &#93; * random.randint ( 0 , ( len ( breakfast ) + 1 ) ) ) DCNL DCSP random.shuffle ( breakfast ) DCNL DCSP if ( len ( breakfast ) = = 0 ) : DCNL DCSP DCSP breakfast = &#91; &apos; lobster DCSP thermidor DCSP aux DCSP crevettes &apos; &#93; DCNL DCSP log.warn ( &apos; Breakfast DCSP is DCSP served : &apos; ) DCNL DCSP log.warn ( &apos; % s DCSP and DCSP spam &apos; , &apos; , DCSP &apos; .join ( breakfast ) )
DCSP parser.skip _ past ( u &apos;endcomment &apos; ) DCNL DCSP return CommentNode ( )
DCSP search = re.compile ( ( &apos; ( ? &lt; = ^ % s ) \ \ s * ( . * ) &apos; % linestart ) , re.MULTILINE ) DCNL DCSP find = search.search ( data ) DCNL DCSP if ( find is not None ) : DCNL DCSP DCSP return re.split ( ( &apos; % s &apos; % sep ) , find.group ( 1 ) ) &#91; param &#93; DCNL DCSP else : DCNL DCSP DCSP print ( &apos; There DCSP is DCSP no DCSP line DCSP which DCSP starts DCSP with DCSP % s DCSP in DCSP data . &apos; % linestart ) DCNL DCSP DCSP return None
DCSP version _ filename = os.path.join ( os.path.dirname ( google.appengine. _ _ file _ _ ) , VERSION _ FILE ) DCNL DCSP try : DCNL DCSP DCSP version _ fh = open ( version _ filename ) DCNL DCSP except IOError : DCNL DCSP DCSP logging.error ( &apos; Could DCSP not DCSP find DCSP version DCSP file DCSP at DCSP % s &apos; , version _ filename ) DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP version = yaml.safe _ load ( version _ fh ) DCNL DCSP finally : DCNL DCSP DCSP version _ fh.close ( ) DCNL DCSP return version
DCSP log.setLevel ( logging.DEBUG ) DCNL DCSP formatter = logging.Formatter ( DEBUG _ FORMAT _ PID ) DCNL DCSP static.create _ sc _ config _ dirs ( ) DCNL DCSP rfh = logging.handlers.RotatingFileHandler ( static.DEBUG _ FILE , maxBytes = 1048576 , backupCount = 2 ) DCNL DCSP rfh.setLevel ( logging.DEBUG ) DCNL DCSP rfh.setFormatter ( formatter ) DCNL DCSP log.addHandler ( rfh ) DCNL DCSP console.setLevel ( logging.INFO ) DCNL DCSP log.addHandler ( console ) DCNL DCSP syslog _ device = &apos; / dev / log &apos; DCNL DCSP if ( use _ syslog and os.path.exists ( syslog _ device ) ) : DCNL DCSP DCSP log.debug ( ( &apos; Logging DCSP to DCSP % s &apos; % syslog _ device ) ) DCNL DCSP DCSP syslog _ handler = logging.handlers.SysLogHandler ( address = syslog _ device ) DCNL DCSP DCSP syslog _ handler.setFormatter ( formatter ) DCNL DCSP DCSP syslog _ handler.setLevel ( logging.DEBUG ) DCNL DCSP DCSP log.addHandler ( syslog _ handler )
DCSP try : DCNL DCSP DCSP if ( s.lower ( ) = = u &apos;none &apos; ) : DCNL DCSP DCSP DCSP return u &apos;none &apos; DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP if isinstance ( s , six.string _ types ) : DCNL DCSP DCSP if ( ( len ( s ) = = 6 ) or ( len ( s ) = = 8 ) ) : DCNL DCSP DCSP DCSP stmp = ( u &apos; # &apos; + s ) DCNL DCSP DCSP DCSP if is _ color _ like ( stmp ) : DCNL DCSP DCSP DCSP DCSP return stmp DCNL DCSP if is _ color _ like ( s ) : DCNL DCSP DCSP return s DCNL DCSP colorarg = s DCNL DCSP msg = u &apos; &apos; DCNL DCSP if ( s.find ( u &apos; , &apos; ) &gt; = 0 ) : DCNL DCSP DCSP stmp = u &apos; &apos; .join ( &#91; c for c in s if ( c.isdigit ( ) or ( c = = u &apos; . &apos; ) or ( c = = u &apos; , &apos; ) ) &#93; ) DCNL DCSP DCSP vals = stmp.split ( u &apos; , &apos; ) DCNL DCSP DCSP if ( len ( vals ) ! = 3 ) : DCNL DCSP DCSP DCSP msg = u &apos; \ nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3 &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP colorarg = &#91; float ( val ) for val in vals &#93; DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP msg = u &apos; \ nCould DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats &apos; DCNL DCSP if ( ( not msg ) and is _ color _ like ( colorarg ) ) : DCNL DCSP DCSP return colorarg DCNL DCSP raise ValueError ( ( u &apos; % s DCSP does DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg % s &apos; % ( s , msg ) ) )
DCSP formatted _ error _ list = &#91; &#93; DCNL DCSP top _ level _ error _ keys = &#91; &apos; links &apos; , &apos; status &apos; , &apos; code &apos; , &apos; detail &apos; , &apos; source &apos; , &apos; meta &apos; &#93; DCNL DCSP resource _ object _ identifiers = &#91; &apos; type &apos; , &apos; id &apos; &#93; DCNL DCSP if ( index is None ) : DCNL DCSP DCSP index = &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP index = ( str ( index ) + &apos; / &apos; ) DCNL DCSP for ( error _ key , error _ description ) in errors.iteritems ( ) : DCNL DCSP DCSP if isinstance ( error _ description , basestring ) : DCNL DCSP DCSP DCSP error _ description = &#91; error _ description &#93; DCNL DCSP DCSP if ( error _ key in top _ level _ error _ keys ) : DCNL DCSP DCSP DCSP formatted _ error _ list.extend ( ( { error _ key : description } for description in error _ description ) ) DCNL DCSP DCSP elif ( error _ key in resource _ object _ identifiers ) : DCNL DCSP DCSP DCSP formatted _ error _ list.extend ( &#91; { &apos; source &apos; : { &apos; pointer &apos; : ( &apos; / data / { } &apos; .format ( index ) + error _ key ) } , &apos; detail &apos; : reason } for reason in error _ description &#93; ) DCNL DCSP DCSP elif ( error _ key = = &apos; non _ field _ errors &apos; ) : DCNL DCSP DCSP DCSP formatted _ error _ list.extend ( &#91; { &apos; detail &apos; : description for description in error _ description } &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP formatted _ error _ list.extend ( &#91; { &apos; source &apos; : { &apos; pointer &apos; : ( &apos; / data / { } attributes / &apos; .format ( index ) + error _ key ) } , &apos; detail &apos; : reason } for reason in error _ description &#93; ) DCNL DCSP return formatted _ error _ list
DCSP try : DCNL DCSP DCSP _ raw _ main ( args ) DCNL DCSP except UserError as exc : DCNL DCSP DCSP message = ( exc.args &#91; 0 &#93; if exc.args else None ) DCNL DCSP DCSP log.error ( u &apos;error : DCSP { 0 } &apos; , message ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP except util.HumanReadableException as exc : DCNL DCSP DCSP exc.log ( log ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP except library.FileOperationError as exc : DCNL DCSP DCSP log.debug ( &apos; { } &apos; , traceback.format _ exc ( ) ) DCNL DCSP DCSP log.error ( &apos; { } &apos; , exc ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP except confit.ConfigError as exc : DCNL DCSP DCSP log.error ( u &apos;configuration DCSP error : DCSP { 0 } &apos; , exc ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP except db _ query.InvalidQueryError as exc : DCNL DCSP DCSP log.error ( u &apos;invalid DCSP query : DCSP { 0 } &apos; , exc ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP except IOError as exc : DCNL DCSP DCSP if ( exc.errno = = errno.EPIPE ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP log.debug ( u &apos; { } &apos; , traceback.format _ exc ( ) )
DCSP import zipfile DCNL DCSP mkpath ( os.path.dirname ( zip _ filename ) , dry _ run = dry _ run ) DCNL DCSP log.info ( &quot; creating DCSP &apos; % s &apos; DCSP and DCSP adding DCSP &apos; % s &apos; DCSP to DCSP it &quot; , zip _ filename , base _ dir ) DCNL DCSP def visit ( z , dirname , names ) : DCNL DCSP DCSP for name in names : DCNL DCSP DCSP DCSP path = os.path.normpath ( os.path.join ( dirname , name ) ) DCNL DCSP DCSP DCSP if os.path.isfile ( path ) : DCNL DCSP DCSP DCSP DCSP p = path &#91; ( len ( base _ dir ) + 1 ) : &#93; DCNL DCSP DCSP DCSP DCSP if ( not dry _ run ) : DCNL DCSP DCSP DCSP DCSP DCSP z.write ( path , p ) DCNL DCSP DCSP DCSP DCSP log.debug ( ( &quot; adding DCSP &apos; % s &apos; &quot; % p ) ) DCNL DCSP if ( compress is None ) : DCNL DCSP DCSP compress = ( sys.version &gt; = &apos; 2.4 &apos; ) DCNL DCSP compression = &#91; zipfile.ZIP _ STORED , zipfile.ZIP _ DEFLATED &#93; &#91; bool ( compress ) &#93; DCNL DCSP if ( not dry _ run ) : DCNL DCSP DCSP z = zipfile.ZipFile ( zip _ filename , mode , compression = compression ) DCNL DCSP DCSP os.path.walk ( base _ dir , visit , z ) DCNL DCSP DCSP z.close ( ) DCNL DCSP else : DCNL DCSP DCSP os.path.walk ( base _ dir , visit , None ) DCNL DCSP return zip _ filename
DCSP return algo
DCSP try : DCNL DCSP DCSP with open ( ( file _ path + &apos; / hash _ dict.pickle &apos; ) , &apos; rb &apos; ) as f : DCNL DCSP DCSP DCSP hash _ dict = cPickle.load ( f ) DCNL DCSP except IOError : DCNL DCSP DCSP hash _ dict = { } DCNL DCSP hash _ dict.update ( { filename : filehash } ) DCNL DCSP with open ( os.path.join ( file _ path , &apos; hash _ dict.pickle &apos; ) , &apos; wb &apos; ) as f : DCNL DCSP DCSP cPickle.dump ( hash _ dict , f )
DCSP firstHalf = mo.group ( 1 ) DCNL DCSP secondHalf = mo.group ( 2 ) DCNL DCSP newRoles = &#91; &#93; DCNL DCSP roles = secondHalf.split ( &apos; DCSP / DCSP &apos; ) DCNL DCSP for role in roles : DCNL DCSP DCSP role = role.strip ( ) DCNL DCSP DCSP if ( not role ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP roleID = analyze _ imdbid ( role ) DCNL DCSP DCSP if ( roleID is None ) : DCNL DCSP DCSP DCSP roleID = u &apos; / &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP roleID + = u &apos; / &apos; DCNL DCSP DCSP newRoles.append ( ( u &apos; &lt; div DCSP class = &quot; _ imdbpyrole &quot; DCSP roleid = &quot; % s &quot; &gt; % s &lt; / div &gt; &apos; % ( roleID , role.strip ( ) ) ) ) DCNL DCSP return ( ( firstHalf + u &apos; DCSP / DCSP &apos; .join ( newRoles ) ) + mo.group ( 3 ) )
DCSP _ col _ name _ map = col _ name _ map DCNL DCSP if ( join _ type not in ( u &apos;inner &apos; , u &apos;outer &apos; , u &apos;left &apos; , u &apos;right &apos; ) ) : DCNL DCSP DCSP raise ValueError ( u &quot; The DCSP &apos; join _ type &apos; DCSP argument DCSP should DCSP be DCSP in DCSP &apos; inner &apos; , DCSP &apos; outer &apos; , DCSP &apos; left &apos; DCSP or DCSP &apos; right &apos; DCSP ( got DCSP &apos; { 0 } &apos; DCSP instead ) &quot; .format ( join _ type ) ) DCNL DCSP if ( keys is None ) : DCNL DCSP DCSP keys = tuple ( ( name for name in left.dtype.names if ( name in right.dtype.names ) ) ) DCNL DCSP DCSP if ( len ( keys ) = = 0 ) : DCNL DCSP DCSP DCSP raise TableMergeError ( u &apos;No DCSP keys DCSP in DCSP common DCSP between DCSP left DCSP and DCSP right DCSP tables &apos; ) DCNL DCSP elif isinstance ( keys , six.string _ types ) : DCNL DCSP DCSP keys = ( keys , ) DCNL DCSP for ( arr , arr _ label ) in ( ( left , u &apos;Left &apos; ) , ( right , u &apos;Right &apos; ) ) : DCNL DCSP DCSP for name in keys : DCNL DCSP DCSP DCSP if ( name not in arr.dtype.names ) : DCNL DCSP DCSP DCSP DCSP raise TableMergeError ( u &apos; { 0 } DCSP table DCSP does DCSP not DCSP have DCSP key DCSP column DCSP { 1 ! r } &apos; .format ( arr _ label , name ) ) DCNL DCSP DCSP DCSP if ( hasattr ( arr &#91; name &#93; , u &apos;mask &apos; ) and np.any ( arr &#91; name &#93; .mask ) ) : DCNL DCSP DCSP DCSP DCSP raise TableMergeError ( u &apos; { 0 } DCSP key DCSP column DCSP { 1 ! r } DCSP has DCSP missing DCSP values &apos; .format ( arr _ label , name ) ) DCNL DCSP left = left.ravel ( ) DCNL DCSP right = right.ravel ( ) DCNL DCSP ( len _ left , len _ right ) = ( len ( left ) , len ( right ) ) DCNL DCSP ( left _ names , right _ names ) = ( left.dtype.names , right.dtype.names ) DCNL DCSP col _ name _ map = get _ col _ name _ map ( &#91; left , right &#93; , keys , uniq _ col _ name , table _ names ) DCNL DCSP out _ descrs = get _ descrs ( &#91; left , right &#93; , col _ name _ map ) DCNL DCSP out _ keys _ dtype = &#91; descr for descr in out _ descrs if ( descr &#91; 0 &#93; in keys ) &#93; DCNL DCSP out _ keys = np.empty ( ( len _ left + len _ right ) , dtype = out _ keys _ dtype ) DCNL DCSP for key in keys : DCNL DCSP DCSP out _ keys &#91; key &#93; &#91; : len _ left &#93; = left &#91; key &#93; DCNL DCSP DCSP out _ keys &#91; key &#93; &#91; len _ left : &#93; = right &#91; key &#93; DCNL DCSP idx _ sort = out _ keys.argsort ( order = keys ) DCNL DCSP out _ keys = out _ keys &#91; idx _ sort &#93; DCNL DCSP diffs = np.concatenate ( ( &#91; True &#93; , ( out _ keys &#91; 1 : &#93; ! = out _ keys &#91; : ( -1 ) &#93; ) , &#91; True &#93; ) ) DCNL DCSP idxs = np.flatnonzero ( diffs ) DCNL DCSP int _ join _ type = { u &apos;inner &apos; : 0 , u &apos;outer &apos; : 1 , u &apos;left &apos; : 2 , u &apos;right &apos; : 3 } &#91; join _ type &#93; DCNL DCSP ( masked , n _ out , left _ out , left _ mask , right _ out , right _ mask ) = _ np _ utils.join _ inner ( idxs , idx _ sort , len _ left , int _ join _ type ) DCNL DCSP if any ( ( isinstance ( array , ma.MaskedArray ) for array in ( left , right ) ) ) : DCNL DCSP DCSP masked = True DCNL DCSP if masked : DCNL DCSP DCSP out = ma.empty ( n _ out , dtype = out _ descrs ) DCNL DCSP else : DCNL DCSP DCSP out = np.empty ( n _ out , dtype = out _ descrs ) DCNL DCSP if ( len ( left ) = = 0 ) : DCNL DCSP DCSP left = left . _ _ class _ _ ( 1 , dtype = left.dtype ) DCNL DCSP if ( len ( right ) = = 0 ) : DCNL DCSP DCSP right = right . _ _ class _ _ ( 1 , dtype = right.dtype ) DCNL DCSP for ( out _ name , left _ right _ names ) in six.iteritems ( col _ name _ map ) : DCNL DCSP DCSP ( left _ name , right _ name ) = left _ right _ names DCNL DCSP DCSP if ( left _ name and right _ name ) : DCNL DCSP DCSP DCSP out &#91; out _ name &#93; = np.where ( right _ mask , left &#91; left _ name &#93; .take ( left _ out ) , right &#91; right _ name &#93; .take ( right _ out ) ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif left _ name : DCNL DCSP DCSP DCSP ( name , array , array _ out , array _ mask ) = ( left _ name , left , left _ out , left _ mask ) DCNL DCSP DCSP elif right _ name : DCNL DCSP DCSP DCSP ( name , array , array _ out , array _ mask ) = ( right _ name , right , right _ out , right _ mask ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise TableMergeError ( u &apos;Unexpected DCSP column DCSP names DCSP ( maybe DCSP one DCSP is DCSP &quot; &quot; ? ) &apos; ) DCNL DCSP DCSP out &#91; out _ name &#93; = array &#91; name &#93; .take ( array _ out , axis = 0 ) DCNL DCSP DCSP if masked : DCNL DCSP DCSP DCSP if isinstance ( array , ma.MaskedArray ) : DCNL DCSP DCSP DCSP DCSP array _ mask = ( array _ mask &#124; array &#91; name &#93; .mask.take ( array _ out ) ) DCNL DCSP DCSP DCSP out &#91; out _ name &#93; .mask = array _ mask DCNL DCSP if isinstance ( _ col _ name _ map , collections.Mapping ) : DCNL DCSP DCSP _ col _ name _ map.update ( col _ name _ map ) DCNL DCSP return out
DCSP if ( isinstance ( node.op , AdvancedIncSubtensor1 ) and ( not node.op.inplace ) ) : DCNL DCSP DCSP new _ op = node.op.clone _ inplace ( ) DCNL DCSP DCSP new _ node = new _ op ( * node.inputs ) DCNL DCSP DCSP copy _ stack _ trace ( node.outputs , new _ node ) DCNL DCSP DCSP return &#91; new _ node &#93; DCNL DCSP return False
DCSP if ( ( depth &gt; max _ depth ) and ( max _ depth ! = 0 ) ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP if os.path.isdir ( entry ) : DCNL DCSP DCSP logger.debug ( ( u &apos;Scanning DCSP directory DCSP % s DCSP with DCSP depth DCSP % d / % d &apos; % ( entry , depth , max _ depth ) ) ) DCNL DCSP DCSP result = &#91; &#93; DCNL DCSP DCSP for e in os.listdir ( entry ) : DCNL DCSP DCSP DCSP result.extend ( scan ( os.path.join ( entry , e ) , max _ depth , scan _ filter , ( depth + 1 ) ) ) DCNL DCSP DCSP return result DCNL DCSP if ( os.path.isfile ( entry ) or ( depth = = 0 ) ) : DCNL DCSP DCSP logger.debug ( ( u &apos;Scanning DCSP file DCSP % s DCSP with DCSP depth DCSP % d / % d &apos; % ( entry , depth , max _ depth ) ) ) DCNL DCSP DCSP if ( depth ! = 0 ) : DCNL DCSP DCSP DCSP if ( ( mimetypes.guess _ type ( entry ) &#91; 0 &#93; not in MIMETYPES ) and ( os.path.splitext ( entry ) &#91; 1 &#93; not in EXTENSIONS ) ) : DCNL DCSP DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP DCSP if ( ( scan _ filter is not None ) and scan _ filter ( entry ) ) : DCNL DCSP DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP video = Video.from _ path ( entry ) DCNL DCSP DCSP return &#91; ( video , video.scan ( ) ) &#93; DCNL DCSP logger.warning ( ( u &apos;Scanning DCSP entry DCSP % s DCSP failed DCSP with DCSP depth DCSP % d / % d &apos; % ( entry , depth , max _ depth ) ) ) DCNL DCSP return &#91; &#93;
DCSP blocks = &#91; resnet _ utils.Block ( &apos; block1 &apos; , bottleneck , ( ( &#91; ( 256 , 64 , 1 ) &#93; * 2 ) + &#91; ( 256 , 64 , 2 ) &#93; ) ) , resnet _ utils.Block ( &apos; block2 &apos; , bottleneck , ( ( &#91; ( 512 , 128 , 1 ) &#93; * 3 ) + &#91; ( 512 , 128 , 2 ) &#93; ) ) , resnet _ utils.Block ( &apos; block3 &apos; , bottleneck , ( ( &#91; ( 1024 , 256 , 1 ) &#93; * 22 ) + &#91; ( 1024 , 256 , 2 ) &#93; ) ) , resnet _ utils.Block ( &apos; block4 &apos; , bottleneck , ( &#91; ( 2048 , 512 , 1 ) &#93; * 3 ) ) &#93; DCNL DCSP return resnet _ v2 ( inputs , blocks , num _ classes , is _ training = is _ training , global _ pool = global _ pool , output _ stride = output _ stride , include _ root _ block = True , reuse = reuse , scope = scope )
DCSP if ( value.lower ( ) = = &apos; true &apos; ) : DCNL DCSP DCSP dest = True DCNL DCSP else : DCNL DCSP DCSP dest = &#91; s for s in value.split ( &apos; , &apos; ) &#93; DCNL DCSP setattr ( parser.values , option.dest , dest )
DCSP if ( not language ) : DCNL DCSP DCSP language = translation.get _ language ( ) DCNL DCSP return ( language = = settings.LANGUAGES &#91; 0 &#93; &#91; 0 &#93; )
DCSP datastore _ types.ValidateProperty ( name , values ) DCNL DCSP properties = datastore _ types.ToPropertyPb ( name , values ) DCNL DCSP if isinstance ( properties , list ) : DCNL DCSP DCSP filters = &#91; PropertyFilter ( op , prop ) for prop in properties &#93; DCNL DCSP DCSP return CompositeFilter ( CompositeFilter.AND , filters ) DCNL DCSP else : DCNL DCSP DCSP return PropertyFilter ( op , properties )
DCSP return eff _ request _ host ( request ) &#91; 1 &#93;
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; } DCNL DCSP action = False DCNL DCSP check _ name = None DCNL DCSP if ( name ! = &apos; allprofiles &apos; ) : DCNL DCSP DCSP check _ name = True DCNL DCSP current _ config = _ _ salt _ _ &#91; &apos; firewall.get _ config &apos; &#93; ( ) DCNL DCSP if ( check _ name and ( name not in current _ config ) ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Profile DCSP { 0 } DCSP does DCSP not DCSP exist DCSP in DCSP firewall.get _ config &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP for key in current _ config : DCNL DCSP DCSP if ( not current _ config &#91; key &#93; ) : DCNL DCSP DCSP DCSP if ( check _ name and ( key ! = name ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP action = True DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { &apos; fw &apos; : &apos; enabled &apos; } DCNL DCSP DCSP DCSP break DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = ( ( not action ) or None ) DCNL DCSP DCSP return ret DCNL DCSP if action : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = _ _ salt _ _ &#91; &apos; firewall.enable &apos; &#93; ( name ) DCNL DCSP DCSP if ( not ret &#91; &apos; result &apos; &#93; ) : DCNL DCSP DCSP DCSP if check _ name : DCNL DCSP DCSP DCSP DCSP msg = &apos; Firewall DCSP profile DCSP { 0 } DCSP could DCSP not DCSP be DCSP enabled &apos; .format ( name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP msg = &apos; Could DCSP not DCSP enable DCSP the DCSP FW &apos; DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg DCNL DCSP else : DCNL DCSP DCSP if check _ name : DCNL DCSP DCSP DCSP msg = &apos; Firewall DCSP profile DCSP { 0 } DCSP is DCSP enabled &apos; .format ( name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP msg = &apos; All DCSP the DCSP firewall DCSP profiles DCSP are DCSP enabled &apos; DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg DCNL DCSP return ret
DCSP assert False , ( &apos; FAILED : DCSP % s &apos; % message )
DCSP if ( not webapp _ path ) : DCNL DCSP DCSP webapp _ path = os.path.join ( DEFAULT _ INSTALLATION _ PATH , &apos; webapps &apos; ) DCNL DCSP put ( local _ path = war _ file , remote _ path = os.path.join ( webapp _ path , war _ file ) , use _ sudo = True )
DCSP start = pass _ white ( source , start ) DCNL DCSP kl = len ( keyword ) DCNL DCSP if ( ( kl + start ) &gt; len ( source ) ) : DCNL DCSP DCSP return None DCNL DCSP if ( source &#91; start : ( start + kl ) &#93; ! = keyword ) : DCNL DCSP DCSP return None DCNL DCSP if ( ( ( kl + start ) &lt; len ( source ) ) and ( source &#91; ( start + kl ) &#93; in IDENTIFIER _ PART ) ) : DCNL DCSP DCSP return None DCNL DCSP return ( start + kl )
DCSP name = name.split ( &apos; .&apos; ) DCNL DCSP used = name.pop ( 0 ) DCNL DCSP found = _ _ import _ _ ( used ) DCNL DCSP for n in name : DCNL DCSP DCSP used = ( ( used + &apos; .&apos; ) + n ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP found = getattr ( found , n ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP _ _ import _ _ ( used ) DCNL DCSP DCSP DCSP found = getattr ( found , n ) DCNL DCSP return found
DCSP to _ print = &#91; &#93; DCNL DCSP to _ print.append ( u &apos; &apos; ) DCNL DCSP to _ print.append ( u &apos;number DCSP of DCSP unique DCSP k-mers : DCSP DCTB { 0 } &apos; .format ( unique _ kmers ) ) DCNL DCSP to _ print.append ( u &apos;false DCSP positive DCSP rate : DCSP DCTB { : &gt; .3f } &apos; .format ( fp _ rate ) ) DCNL DCSP to _ print.append ( u &apos; &apos; ) DCNL DCSP to _ print.append ( u &apos;If DCSP you DCSP have DCSP expected DCSP false DCSP positive DCSP rate DCSP to DCSP achieve : &apos; ) DCNL DCSP to _ print.append ( u &apos;expected _ fp DCTB number _ hashtable ( Z ) DCTB size _ hashtable ( H ) DCTB expected _ memory _ usage &apos; ) DCNL DCSP for fp _ rate in range ( 1 , 10 ) : DCNL DCSP DCSP ( num _ tables , table _ size , mem _ cap , fp _ rate ) = optimal _ size ( unique _ kmers , fp _ rate = ( fp _ rate / 10.0 ) ) DCNL DCSP DCSP to _ print.append ( u &apos; { : 11.3f } DCTB { : 19 } DCTB { : 17e } DCTB { : 21e } &apos; .format ( fp _ rate , num _ tables , table _ size , mem _ cap ) ) DCNL DCSP mem _ list = &#91; 1 , 5 , 10 , 20 , 50 , 100 , 200 , 300 , 400 , 500 , 1000 , 2000 , 5000 &#93; DCNL DCSP to _ print.append ( u &apos; &apos; ) DCNL DCSP to _ print.append ( u &apos;If DCSP you DCSP have DCSP expected DCSP memory DCSP to DCSP use : &apos; ) DCNL DCSP to _ print.append ( u &apos;expected _ memory _ usage DCTB number _ hashtable ( Z ) DCTB size _ hashtable ( H ) DCTB expected _ fp &apos; ) DCNL DCSP for mem in mem _ list : DCNL DCSP DCSP ( num _ tables , table _ size , mem _ cap , fp _ rate ) = optimal _ size ( unique _ kmers , mem _ cap = ( mem * 1000000000 ) ) DCNL DCSP DCSP to _ print.append ( u &apos; { : 21e } DCTB { : 19 } DCTB { : 17e } DCTB { : 11.3f } &apos; .format ( mem _ cap , num _ tables , table _ size , fp _ rate ) ) DCNL DCSP return u &apos; \ n &apos; .join ( to _ print )
DCSP ring = f.ring DCNL DCSP f = _ trunc ( f , minpoly , p ) DCNL DCSP g = _ trunc ( g , minpoly , p ) DCNL DCSP while g : DCNL DCSP DCSP rem = f DCNL DCSP DCSP deg = g.degree ( 0 ) DCNL DCSP DCSP ( lcinv , _ , gcd ) = _ gf _ gcdex ( ring.dmp _ LC ( g ) , minpoly , p ) DCNL DCSP DCSP if ( not ( gcd = = 1 ) ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP degrem = rem.degree ( 0 ) DCNL DCSP DCSP DCSP if ( degrem &lt; deg ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP quo = ( lcinv * ring.dmp _ LC ( rem ) ) .set _ ring ( ring ) DCNL DCSP DCSP DCSP rem = _ trunc ( ( rem - ( g.mul _ monom ( ( ( degrem - deg ) , 0 ) ) * quo ) ) , minpoly , p ) DCNL DCSP DCSP f = g DCNL DCSP DCSP g = rem DCNL DCSP lcfinv = _ gf _ gcdex ( ring.dmp _ LC ( f ) , minpoly , p ) &#91; 0 &#93; .set _ ring ( ring ) DCNL DCSP return _ trunc ( ( f * lcfinv ) , minpoly , p )
DCSP log _ file = os.environ.get ( &apos; WSGI _ LOG &apos; ) DCNL DCSP if log _ file : DCNL DCSP DCSP f = open ( log _ file , &apos; a + &apos; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP f.write ( ( &apos; % s : DCSP % s &apos; % ( datetime.datetime.now ( ) , txt ) ) ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP f.close ( )
DCSP this = axes _ handler &#91; 0 &#93; DCNL DCSP for ( ii , data _ , ax ) in zip ( epoch _ idx , data , axes ) : DCNL DCSP DCSP for ( l , d ) in zip ( ax.lines , data _ &#91; good _ ch _ idx &#93; ) : DCNL DCSP DCSP DCSP l.set _ data ( times , d ) DCNL DCSP DCSP if ( bad _ ch _ idx is not None ) : DCNL DCSP DCSP DCSP bad _ lines = &#91; ax.lines &#91; k &#93; for k in bad _ ch _ idx &#93; DCNL DCSP DCSP DCSP for ( l , d ) in zip ( bad _ lines , data _ &#91; bad _ ch _ idx &#93; ) : DCNL DCSP DCSP DCSP DCSP l.set _ data ( times , d ) DCNL DCSP DCSP if ( title _ str is not None ) : DCNL DCSP DCSP DCSP ax.set _ title ( ( title _ str % ii ) , fontsize = 12 ) DCNL DCSP DCSP ax.set _ ylim ( data.min ( ) , data.max ( ) ) DCNL DCSP DCSP ax.set _ yticks ( list ( ) ) DCNL DCSP DCSP ax.set _ xticks ( list ( ) ) DCNL DCSP DCSP if ( vars ( ax ) &#91; this &#93; &#91; &apos; reject &apos; &#93; is True ) : DCNL DCSP DCSP DCSP for l in ax.lines : DCNL DCSP DCSP DCSP DCSP l.set _ color ( ( 0.8 , 0.8 , 0.8 ) ) DCNL DCSP DCSP DCSP ax.get _ figure ( ) .canvas.draw ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for k in axes _ handler : DCNL DCSP DCSP DCSP DCSP if ( k = = this ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP if ( vars ( ax ) .get ( k , { } ) .get ( &apos; reject &apos; , None ) is True ) : DCNL DCSP DCSP DCSP DCSP DCSP for l in ax.lines &#91; : len ( good _ ch _ idx ) &#93; : DCNL DCSP DCSP DCSP DCSP DCSP DCSP l.set _ color ( &apos; k &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( bad _ ch _ idx is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for l in ax.lines &#91; ( - len ( bad _ ch _ idx ) ) : &#93; : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP l.set _ color ( &apos; r &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP ax.get _ figure ( ) .canvas.draw ( ) DCNL DCSP DCSP DCSP DCSP DCSP break
DCSP if ( not cuda.cuda _ available ) : DCNL DCSP DCSP raise RuntimeError ( ( &quot; % s DCSP only DCSP runs DCSP on DCSP GPUs , DCSP but DCSP there DCSP doesn &apos;t DCSP seem DCSP to DCSP be DCSP a DCSP GPU DCSP available . DCSP If DCSP you DCSP would DCSP like DCSP assistance DCSP making DCSP a DCSP CPU DCSP version DCSP of DCSP convolutional DCSP maxout , DCSP contact DCSP pylearn-dev @ googlegroups.com. &quot; % feature _ name ) ) DCNL DCSP if ( not hasattr ( cuda.cuda _ ndarray.cuda _ ndarray , &apos; cublas _ v2 &apos; ) ) : DCNL DCSP DCSP warnings.warn ( &apos; You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP old DCSP Theano DCSP version . DCSP That DCSP will DCSP cause DCSP compilation DCSP crash . DCSP If DCSP so , DCSP update DCSP Theano . &apos; ) DCNL DCSP elif ( not cuda.cuda _ ndarray.cuda _ ndarray.cublas _ v2 ( ) ) : DCNL DCSP DCSP raise RuntimeError ( &apos; You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP old DCSP Theano DCSP version . DCSP That DCSP will DCSP cause DCSP compilation DCSP crash . DCSP Update DCSP Theano &apos; ) DCNL DCSP if ( check _ enabled and ( not cuda.cuda _ enabled ) ) : DCNL DCSP DCSP raise RuntimeError ( ( &apos; % s DCSP must DCSP run DCSP be DCSP with DCSP theano DCSP configured DCSP to DCSP use DCSP the DCSP GPU &apos; % feature _ name ) )
DCSP manager = MANAGER DCNL DCSP if update : DCNL DCSP DCSP update _ index ( ) DCNL DCSP if ( options is None ) : DCNL DCSP DCSP options = &#91; &#93; DCNL DCSP if ( not isinstance ( packages , basestring ) ) : DCNL DCSP DCSP packages = &apos; DCSP &apos; .join ( packages ) DCNL DCSP options.append ( &apos; --verbosity = 0 &apos; ) DCNL DCSP options = &apos; DCSP &apos; .join ( options ) DCNL DCSP cmd = ( &apos; % ( manager ) s DCSP install DCSP % ( options ) s DCSP % ( packages ) s &apos; % locals ( ) ) DCNL DCSP run _ as _ root ( cmd , pty = False )
DCSP kstone = auth ( profile , * * connection _ args ) DCNL DCSP token = kstone.service _ catalog.get _ token ( ) DCNL DCSP return { &apos; id &apos; : token &#91; &apos; id &apos; &#93; , &apos; expires &apos; : token &#91; &apos; expires &apos; &#93; , &apos; user _ id &apos; : token &#91; &apos; user _ id &apos; &#93; , &apos; tenant _ id &apos; : token &#91; &apos; tenant _ id &apos; &#93; }
DCSP if response.has _ header ( &apos; Vary &apos; ) : DCNL DCSP DCSP vary _ headers = cc _ delim _ re.split ( response &#91; &apos; Vary &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP vary _ headers = &#91; &#93; DCNL DCSP existing _ headers = set ( ( header.lower ( ) for header in vary _ headers ) ) DCNL DCSP additional _ headers = &#91; newheader for newheader in newheaders if ( newheader.lower ( ) not in existing _ headers ) &#93; DCNL DCSP response &#91; &apos; Vary &apos; &#93; = &apos; , DCSP &apos; .join ( ( vary _ headers + additional _ headers ) )
DCSP rpc = vertical _ flip _ async ( image _ data , output _ encoding = output _ encoding , quality = quality , correct _ orientation = correct _ orientation , rpc = rpc , transparent _ substitution _ rgb = transparent _ substitution _ rgb ) DCNL DCSP return rpc.get _ result ( )
DCSP if kwargs.get ( u &apos;raw &apos; , False ) : DCNL DCSP DCSP return False DCNL DCSP ( user , created ) = ( kwargs &#91; u &apos;instance &apos; &#93; , kwargs &#91; u &apos;created &apos; &#93; ) DCNL DCSP disabled = getattr ( user , u &apos; _ disable _ account _ creation &apos; , ( not settings.ACCOUNT _ CREATE _ ON _ SAVE ) ) DCNL DCSP if ( created and ( not disabled ) ) : DCNL DCSP DCSP Account.create ( user = user )
DCSP ( version , code _ obj1 ) = uncompyle2 . _ load _ module ( pyc _ filename ) DCNL DCSP code _ obj2 = uncompyle2 . _ load _ file ( src _ filename ) DCNL DCSP cmp _ code _ objects ( version , code _ obj1 , code _ obj2 )
DCSP default _ plot _ options = copy.deepcopy ( DEFAULT _ PLOT _ OPTIONS ) DCNL DCSP file _ options = tools.get _ config _ file ( ) DCNL DCSP session _ options = session.get _ session _ plot _ options ( ) DCNL DCSP plot _ options _ from _ call _ signature = copy.deepcopy ( plot _ options _ from _ call _ signature ) DCNL DCSP for option _ set in &#91; plot _ options _ from _ call _ signature , session _ options , file _ options &#93; : DCNL DCSP DCSP utils.validate _ world _ readable _ and _ sharing _ settings ( option _ set ) DCNL DCSP DCSP utils.set _ sharing _ and _ world _ readable ( option _ set ) DCNL DCSP DCSP if ( ( &apos; filename &apos; in option _ set ) and ( &apos; fileopt &apos; not in option _ set ) ) : DCNL DCSP DCSP DCSP option _ set &#91; &apos; fileopt &apos; &#93; = &apos; overwrite &apos; DCNL DCSP user _ plot _ options = { } DCNL DCSP user _ plot _ options.update ( default _ plot _ options ) DCNL DCSP user _ plot _ options.update ( file _ options ) DCNL DCSP user _ plot _ options.update ( session _ options ) DCNL DCSP user _ plot _ options.update ( plot _ options _ from _ call _ signature ) DCNL DCSP user _ plot _ options = { k : v for ( k , v ) in user _ plot _ options.items ( ) if ( k in default _ plot _ options ) } DCNL DCSP return user _ plot _ options
DCSP m = ( tdim and TDIM _ RE.match ( tdim ) ) DCNL DCSP if m : DCNL DCSP DCSP dims = m.group ( &apos; dims &apos; ) DCNL DCSP DCSP return tuple ( ( int ( d.strip ( ) ) for d in dims.split ( &apos; , &apos; ) ) ) &#91; : : ( -1 ) &#93; DCNL DCSP return tuple ( )
DCSP fileupload _ exists = addon.fileupload _ set.filter ( created _ _ gt = upload.created , version = upload.version ) .exists ( ) DCNL DCSP version _ exists = Version.unfiltered.filter ( addon = addon , version = upload.version ) .exists ( ) DCNL DCSP if ( fileupload _ exists or version _ exists ) : DCNL DCSP DCSP log.info ( &apos; Skipping DCSP Version DCSP creation DCSP for DCSP { upload _ uuid } DCSP that DCSP would DCSP DCSP cause DCSP duplicate DCSP version &apos; .format ( upload _ uuid = upload.uuid ) ) DCNL DCSP else : DCNL DCSP DCSP from olympia.devhub.views import auto _ sign _ version DCNL DCSP DCSP log.info ( &apos; Creating DCSP version DCSP for DCSP { upload _ uuid } DCSP that DCSP passed DCSP validation &apos; .format ( upload _ uuid = upload.uuid ) ) DCNL DCSP DCSP beta = ( bool ( upload.version ) and is _ beta ( upload.version ) ) DCNL DCSP DCSP version = Version.from _ upload ( upload , addon , &#91; amo.PLATFORM _ ALL.id &#93; , channel , is _ beta = beta ) DCNL DCSP DCSP if ( ( addon.status = = amo.STATUS _ NULL ) and ( channel = = amo.RELEASE _ CHANNEL _ LISTED ) ) : DCNL DCSP DCSP DCSP addon.update ( status = amo.STATUS _ NOMINATED ) DCNL DCSP DCSP auto _ sign _ version ( version , is _ beta = version.is _ beta )
DCSP return &#91; x for x in old if ( x not in new ) &#93;
DCSP if workspace : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP w = next ( ( w for w in get _ i3 _ connection ( ) .get _ workspaces ( ) if ( w &#91; u &apos;name &apos; &#93; = = workspace ) ) ) DCNL DCSP DCSP except StopIteration : DCNL DCSP DCSP DCSP return None DCNL DCSP elif segment _ info.get ( u &apos;workspace &apos; ) : DCNL DCSP DCSP w = segment _ info &#91; u &apos;workspace &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP w = next ( ( w for w in get _ i3 _ connection ( ) .get _ workspaces ( ) if w &#91; u &apos;focused &apos; &#93; ) ) DCNL DCSP DCSP except StopIteration : DCNL DCSP DCSP DCSP return None DCNL DCSP return &#91; { u &apos;contents &apos; : format _ name ( w &#91; u &apos;name &apos; &#93; , strip = strip ) , u &apos;highlight _ groups &apos; : workspace _ groups ( w ) } &#93;
DCSP writer = csv.DictWriter ( file _ obj , ATTRIBUTES , dialect = csv.excel _ tab ) DCNL DCSP writer.writeheader ( ) DCNL DCSP categories = Category.objects.all ( ) DCNL DCSP discounts = Sale.objects.all ( ) .prefetch _ related ( u &apos;products &apos; , u &apos;categories &apos; ) DCNL DCSP attributes _ dict = { a.name : a.pk for a in ProductAttribute.objects.all ( ) } DCNL DCSP attribute _ values _ dict = { smart _ text ( a.pk ) : smart _ text ( a ) for a in AttributeChoiceValue.objects.all ( ) } DCNL DCSP category _ paths = { } DCNL DCSP current _ site = Site.objects.get _ current ( ) DCNL DCSP for item in get _ feed _ items ( ) : DCNL DCSP DCSP item _ data = item _ attributes ( item , categories , category _ paths , current _ site , discounts , attributes _ dict , attribute _ values _ dict ) DCNL DCSP DCSP writer.writerow ( item _ data )
DCSP n = int ( n ) DCNL DCSP i = as _ int ( ith ) DCNL DCSP if ( i &gt; 1 ) : DCNL DCSP DCSP pr = n DCNL DCSP DCSP j = 1 DCNL DCSP DCSP while 1 : DCNL DCSP DCSP DCSP pr = nextprime ( pr ) DCNL DCSP DCSP DCSP j + = 1 DCNL DCSP DCSP DCSP if ( j &gt; i ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP return pr DCNL DCSP if ( n &lt; 2 ) : DCNL DCSP DCSP return 2 DCNL DCSP if ( n &lt; 7 ) : DCNL DCSP DCSP return { 2 : 3 , 3 : 5 , 4 : 5 , 5 : 7 , 6 : 7 } &#91; n &#93; DCNL DCSP if ( n &lt; = sieve . _ list &#91; ( -2 ) &#93; ) : DCNL DCSP DCSP ( l , u ) = sieve.search ( n ) DCNL DCSP DCSP if ( l = = u ) : DCNL DCSP DCSP DCSP return sieve &#91; ( u + 1 ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return sieve &#91; u &#93; DCNL DCSP nn = ( 6 * ( n / / 6 ) ) DCNL DCSP if ( nn = = n ) : DCNL DCSP DCSP n + = 1 DCNL DCSP DCSP if isprime ( n ) : DCNL DCSP DCSP DCSP return n DCNL DCSP DCSP n + = 4 DCNL DCSP elif ( ( n - nn ) = = 5 ) : DCNL DCSP DCSP n + = 2 DCNL DCSP DCSP if isprime ( n ) : DCNL DCSP DCSP DCSP return n DCNL DCSP DCSP n + = 4 DCNL DCSP else : DCNL DCSP DCSP n = ( nn + 5 ) DCNL DCSP while 1 : DCNL DCSP DCSP if isprime ( n ) : DCNL DCSP DCSP DCSP return n DCNL DCSP DCSP n + = 2 DCNL DCSP DCSP if isprime ( n ) : DCNL DCSP DCSP DCSP return n DCNL DCSP DCSP n + = 4
DCSP file _ data = { } DCNL DCSP fasta _ files = &#91; get _ infile ( fasta _ f ) for fasta _ f in fasta _ files &#93; DCNL DCSP qual _ files = &#91; get _ infile ( qual _ f ) for qual _ f in qual _ files &#93; DCNL DCSP file _ data &#91; &apos; fasta _ files &apos; &#93; = fasta _ files DCNL DCSP file _ data &#91; &apos; qual _ files &apos; &#93; = qual _ files DCNL DCSP file _ data &#91; &apos; mapping _ file &apos; &#93; = open ( mapping _ file , &apos; U &apos; ) DCNL DCSP file _ data &#91; &apos; demultiplexed _ seqs _ f &apos; &#93; = open ( join ( output _ dir , &apos; demultiplexed _ seqs.fna.incomplete &apos; ) , &apos; w &apos; ) DCNL DCSP if qual _ files : DCNL DCSP DCSP file _ data &#91; &apos; demultiplexed _ qual _ f &apos; &#93; = open ( join ( output _ dir , &apos; demultiplexed _ seqs.qual.incomplete &apos; ) , &apos; w &apos; ) DCNL DCSP if write _ unassigned _ reads : DCNL DCSP DCSP file _ data &#91; &apos; unassigned _ seqs _ f &apos; &#93; = open ( join ( output _ dir , &apos; unassigned _ seqs.fna.incomplete &apos; ) , &apos; w &apos; ) DCNL DCSP DCSP if qual _ files : DCNL DCSP DCSP DCSP file _ data &#91; &apos; unassigned _ qual _ f &apos; &#93; = open ( join ( output _ dir , &apos; unassigned _ seqs.qual.incomplete &apos; ) , &apos; w &apos; ) DCNL DCSP ( log _ data , bc _ freqs , seq _ counts , corrected _ bc _ count ) = demultiplex _ sequences ( file _ data , keep _ barcode , barcode _ type , max _ bc _ errors , start _ index , write _ unassigned _ reads , disable _ bc _ correction , added _ demultiplex _ field ) DCNL DCSP final _ log _ data = process _ log _ data ( log _ data , seq _ counts , mapping _ file , fasta _ files , qual _ files , corrected _ bc _ count , keep _ barcode , barcode _ type , max _ bc _ errors , start _ index , write _ unassigned _ reads , disable _ bc _ correction , added _ demultiplex _ field ) DCNL DCSP log _ file = open ( join ( output _ dir , &apos; demultiplex _ fasta.log &apos; ) , &apos; w &apos; ) DCNL DCSP log _ file.write ( &apos; \ n &apos; .join ( final _ log _ data ) ) DCNL DCSP if save _ barcode _ frequencies : DCNL DCSP DCSP bcs _ sorted _ list = process _ bc _ freqs ( bc _ freqs ) DCNL DCSP DCSP bc _ freqs _ f = open ( join ( output _ dir , &apos; barcode _ freqs.txt &apos; ) , &apos; w &apos; ) DCNL DCSP DCSP bc _ freqs _ f.write ( &apos; Barcode DCSP frequencies \ n &apos; ) DCNL DCSP DCSP bc _ freqs _ f.write ( &apos; \ n &apos; .join ( bcs _ sorted _ list ) ) DCNL DCSP rename ( file _ data &#91; &apos; demultiplexed _ seqs _ f &apos; &#93; .name , join ( output _ dir , &apos; demultiplexed _ seqs.fna &apos; ) ) DCNL DCSP if qual _ files : DCNL DCSP DCSP rename ( file _ data &#91; &apos; demultiplexed _ qual _ f &apos; &#93; .name , join ( output _ dir , &apos; demultiplexed _ seqs.qual &apos; ) ) DCNL DCSP if write _ unassigned _ reads : DCNL DCSP DCSP rename ( file _ data &#91; &apos; unassigned _ seqs _ f &apos; &#93; .name , join ( output _ dir , &apos; unassigned _ seqs.fna &apos; ) ) DCNL DCSP DCSP if qual _ files : DCNL DCSP DCSP DCSP rename ( file _ data &#91; &apos; unassigned _ qual _ f &apos; &#93; .name , join ( output _ dir , &apos; unassigned _ seqs.qual &apos; ) )
DCSP if ( not args.password ) : DCNL DCSP DCSP args.password = getpass.getpass ( prompt = ( &apos; Enter DCSP password DCSP for DCSP host DCSP % s DCSP and DCSP user DCSP % s : DCSP &apos; % ( args.host , args.user ) ) ) DCNL DCSP return args
DCSP ip _ address = netaddr.IPAddress ( port &#91; &apos; fixed _ ips &apos; &#93; &#91; 0 &#93; &#91; &apos; ip _ address &apos; &#93; ) DCNL DCSP return netaddr.IPNetwork ( ( ip _ address.value , network.prefixlen ) )
DCSP if isinstance ( text , str ) : DCNL DCSP DCSP text = unicode ( text , &apos; ISO-8859-1 &apos; ) DCNL DCSP elif ( not isinstance ( text , unicode ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP text = unicode ( text ) DCNL DCSP DCSP except UnicodeError : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP text = str ( text ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP text = repr ( text ) DCNL DCSP DCSP DCSP return makeUnicode ( text ) DCNL DCSP text = regex _ control _ code.sub ( ( lambda regs : controlchars &#91; ord ( regs.group ( 1 ) ) &#93; ) , text ) DCNL DCSP text = re.sub ( &apos; \ \ \ \ x0 ( &#91; 0-7 &#93; ) ( ? = &#91; ^ 0-7 &#93; &#124; $ ) &apos; , &apos; \ \ \ \ \ \ 1 &apos; , text ) DCNL DCSP return text
DCSP log.debug ( &apos; haproxy DCSP beacon DCSP starting &apos; ) DCNL DCSP ret = &#91; &#93; DCNL DCSP _ validate = _ _ validate _ _ ( config ) DCNL DCSP if ( not _ validate ) : DCNL DCSP DCSP log.debug ( &apos; haproxy DCSP beacon DCSP unable DCSP to DCSP validate &apos; ) DCNL DCSP DCSP return ret DCNL DCSP for backend in config : DCNL DCSP DCSP threshold = config &#91; backend &#93; &#91; &apos; threshold &apos; &#93; DCNL DCSP DCSP for server in config &#91; backend &#93; &#91; &apos; servers &apos; &#93; : DCNL DCSP DCSP DCSP scur = _ _ salt _ _ &#91; &apos; haproxy.get _ sessions &apos; &#93; ( server , backend ) DCNL DCSP DCSP DCSP if scur : DCNL DCSP DCSP DCSP DCSP if ( int ( scur ) &gt; int ( threshold ) ) : DCNL DCSP DCSP DCSP DCSP DCSP _ server = { &apos; server &apos; : server , &apos; scur &apos; : scur , &apos; threshold &apos; : threshold } DCNL DCSP DCSP DCSP DCSP DCSP log.debug ( &apos; Emit DCSP because DCSP { 0 } DCSP &gt; DCSP { 1 } DCSP for DCSP { 2 } DCSP in DCSP { 3 } &apos; .format ( scur , threshold , server , backend ) ) DCNL DCSP DCSP DCSP DCSP DCSP ret.append ( _ server ) DCNL DCSP return ret
DCSP click.launch ( url , locate = True )
DCSP logging.debug ( &apos; Attempting DCSP to DCSP log DCSP into DCSP % s : % s DCSP using DCSP % s DCSP ( timeout DCSP % ds ) &apos; , host , port , client , timeout ) DCNL DCSP end _ time = ( time.time ( ) + timeout ) DCNL DCSP while ( time.time ( ) &lt; end _ time ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return remote _ login ( client , host , port , username , password , prompt , linesep , log _ filename , internal _ timeout , interface ) DCNL DCSP DCSP except LoginError as e : DCNL DCSP DCSP DCSP logging.debug ( e ) DCNL DCSP DCSP time.sleep ( 2 ) DCNL DCSP return remote _ login ( client , host , port , username , password , prompt , linesep , log _ filename , internal _ timeout , interface )
DCSP results _ df = pd.read _ pickle ( result _ file ) DCNL DCSP show _ draw _ result ( result _ file , results _ df )
DCSP mail _ service = MailNotificationService ( config.get ( CONF _ SERVER ) , config.get ( CONF _ PORT ) , config.get ( CONF _ SENDER ) , config.get ( CONF _ STARTTLS ) , config.get ( CONF _ USERNAME ) , config.get ( CONF _ PASSWORD ) , config.get ( CONF _ RECIPIENT ) , config.get ( CONF _ DEBUG ) ) DCNL DCSP if mail _ service.connection _ is _ valid ( ) : DCNL DCSP DCSP return mail _ service DCNL DCSP else : DCNL DCSP DCSP return None
DCSP data = &#91; &#93; DCNL DCSP for root in root _ list : DCNL DCSP DCSP for ( dirname , _ , files ) in os.walk ( os.path.join ( pkg , root ) ) : DCNL DCSP DCSP DCSP for fname in files : DCNL DCSP DCSP DCSP DCSP data.append ( os.path.relpath ( os.path.join ( dirname , fname ) , pkg ) ) DCNL DCSP return { pkg : data }
DCSP while True : DCNL DCSP DCSP buf = fsrc.read ( length ) DCNL DCSP DCSP if ( not buf ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP fdst.write ( buf )
DCSP s3.filter = ( FS ( &apos; human _ resource.type &apos; ) = = 2 ) DCNL DCSP return s3db.hrm _ training _ controller ( )
DCSP map _ obj = _ resolve _ map ( request , mapid , &apos; base.download _ resourcebase &apos; , _ PERMISSION _ MSG _ VIEW ) DCNL DCSP map _ status = dict ( ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP url = ( &apos; % srest / process / batchDownload / launch / &apos; % ogc _ server _ settings.LOCATION ) DCNL DCSP DCSP def perm _ filter ( layer ) : DCNL DCSP DCSP DCSP return request.user.has _ perm ( &apos; base.view _ resourcebase &apos; , obj = layer.get _ self _ resource ( ) ) DCNL DCSP DCSP mapJson = map _ obj.json ( perm _ filter ) DCNL DCSP DCSP j _ map = json.loads ( mapJson ) DCNL DCSP DCSP j _ layers = j _ map &#91; &apos; layers &apos; &#93; DCNL DCSP DCSP for j _ layer in j _ layers : DCNL DCSP DCSP DCSP if ( j _ layer &#91; &apos; service &apos; &#93; is None ) : DCNL DCSP DCSP DCSP DCSP j _ layers.remove ( j _ layer ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( len ( &#91; l for l in j _ layers if ( l = = j _ layer ) &#93; ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP j _ layers.remove ( j _ layer ) DCNL DCSP DCSP mapJson = json.dumps ( j _ map ) DCNL DCSP DCSP ( resp , content ) = http _ client.request ( url , &apos; POST &apos; , body = mapJson ) DCNL DCSP DCSP status = int ( resp.status ) DCNL DCSP DCSP if ( status = = 200 ) : DCNL DCSP DCSP DCSP map _ status = json.loads ( content ) DCNL DCSP DCSP DCSP request.session &#91; &apos; map _ status &apos; &#93; = map _ status DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Could DCSP not DCSP start DCSP the DCSP download DCSP of DCSP % s . DCSP Error DCSP was : DCSP % s &apos; % ( map _ obj.title , content ) ) ) DCNL DCSP locked _ layers = &#91; &#93; DCNL DCSP remote _ layers = &#91; &#93; DCNL DCSP downloadable _ layers = &#91; &#93; DCNL DCSP for lyr in map _ obj.layer _ set.all ( ) : DCNL DCSP DCSP if ( lyr.group ! = &apos; background &apos; ) : DCNL DCSP DCSP DCSP if ( not lyr.local ) : DCNL DCSP DCSP DCSP DCSP remote _ layers.append ( lyr ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ownable _ layer = Layer.objects.get ( typename = lyr.name ) DCNL DCSP DCSP DCSP DCSP if ( not request.user.has _ perm ( &apos; download _ resourcebase &apos; , obj = ownable _ layer.get _ self _ resource ( ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP locked _ layers.append ( lyr ) DCNL DCSP DCSP DCSP DCSP elif ( len ( &#91; l for l in downloadable _ layers if ( l.name = = lyr.name ) &#93; ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP downloadable _ layers.append ( lyr ) DCNL DCSP return render _ to _ response ( template , RequestContext ( request , { &apos; geoserver &apos; : ogc _ server _ settings.PUBLIC _ LOCATION , &apos; map _ status &apos; : map _ status , &apos; map &apos; : map _ obj , &apos; locked _ layers &apos; : locked _ layers , &apos; remote _ layers &apos; : remote _ layers , &apos; downloadable _ layers &apos; : downloadable _ layers , &apos; site &apos; : settings.SITEURL } ) )
DCSP print ( &apos; run DCSP cmd : DCSP % s &apos; % cmd ) DCNL DCSP args = shlex.split ( cmd ) DCNL DCSP ( output , rc ) = utils.subprocess _ sp ( None , args , shell = False ) DCNL DCSP if ( rc ! = 0 ) : DCNL DCSP DCSP raise Exception DCNL DCSP return output
DCSP words = &#91; u &apos;Do &apos; , u &quot; n &apos;t &quot; , u &apos;feed &apos; , u &apos;the &apos; , u &apos;dog &apos; &#93; DCNL DCSP tag _ map = { u &apos;VB &apos; : { POS : VERB , u &apos;morph &apos; : VerbForm _ inf } } DCNL DCSP rules = { u &apos;verb &apos; : &#91; &#91; u &apos;ed &apos; , u &apos;e &apos; &#93; &#93; } DCNL DCSP lemmatizer = Lemmatizer ( { u &apos;verb &apos; : { } } , { u &apos;verb &apos; : { } } , rules ) DCNL DCSP vocab = Vocab ( lemmatizer = lemmatizer , tag _ map = tag _ map ) DCNL DCSP doc = get _ doc ( vocab , words ) DCNL DCSP doc &#91; 2 &#93; .tag _ = u &apos;VB &apos; DCNL DCSP assert ( doc &#91; 2 &#93; .text = = u &apos;feed &apos; ) DCNL DCSP assert ( doc &#91; 2 &#93; .lemma _ = = u &apos;feed &apos; )
DCSP ( return _ code , return _ message , response ) = open _ url ( url , config , data = data , handlers = handlers ) DCNL DCSP if ( return _ code = = http _ client _ .OK ) : DCNL DCSP DCSP return _ data = response.read ( ) DCNL DCSP DCSP response.close ( ) DCNL DCSP DCSP outfile = open ( output _ file , &apos; w &apos; ) DCNL DCSP DCSP outfile.write ( return _ data ) DCNL DCSP DCSP outfile.close ( ) DCNL DCSP return ( return _ code , return _ message , ( return _ code = = http _ client _ .OK ) )
DCSP if hasattr ( func , &apos; called &apos; ) : DCNL DCSP DCSP return func DCNL DCSP def wrapper ( * args , * * kw ) : DCNL DCSP DCSP wrapper.called = False DCNL DCSP DCSP out = func ( * args , * * kw ) DCNL DCSP DCSP wrapper.called = True DCNL DCSP DCSP return out DCNL DCSP wrapper.called = False DCNL DCSP wrapper . _ _ doc _ _ = func . _ _ doc _ _ DCNL DCSP return wrapper
DCSP if copy : DCNL DCSP DCSP X = np.copy ( X ) DCNL DCSP max _ prob = np.max ( X , axis = 1 ) .reshape ( ( ( -1 ) , 1 ) ) DCNL DCSP X - = max _ prob DCNL DCSP np.exp ( X , X ) DCNL DCSP sum _ prob = np.sum ( X , axis = 1 ) .reshape ( ( ( -1 ) , 1 ) ) DCNL DCSP X / = sum _ prob DCNL DCSP return X
DCSP vim.command ( &apos; botright DCSP new &apos; ) DCNL DCSP vim.command ( &apos; set DCSP ft = &apos; ) DCNL DCSP vim.command ( &apos; set DCSP buftype = nofile &apos; ) DCNL DCSP vim.current.buffer &#91; : &#93; = text.splitlines ( ) DCNL DCSP feedkeys ( &apos; \ \ &lt; Esc &gt; &apos; )
DCSP return call _ talib _ with _ hlcv ( barDs , count , talib.AD )
DCSP return isotime ( datetime.datetime.utcfromtimestamp ( timestamp ) , microsecond )
DCSP import difflib DCNL DCSP bulk _ ret = _ get _ pool _ results ( * args , * * kwargs ) DCNL DCSP is _ first _ time = True DCNL DCSP for k in bulk _ ret : DCNL DCSP DCSP print ( &apos; minion DCSP pool DCSP : \ n------------ &apos; ) DCNL DCSP DCSP print ( k &#91; &apos; pool &apos; &#93; ) DCNL DCSP DCSP print ( &apos; pool DCSP size DCSP : \ n---------- &apos; ) DCNL DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP &apos; + str ( len ( k &#91; &apos; pool &apos; &#93; ) ) ) ) DCNL DCSP DCSP if is _ first _ time : DCNL DCSP DCSP DCSP is _ first _ time = False DCNL DCSP DCSP DCSP print ( &apos; pool DCSP result DCSP : \ n------------ &apos; ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP &apos; + bulk _ ret &#91; 0 &#93; &#91; &apos; result &apos; &#93; ) ) DCNL DCSP DCSP DCSP print ( ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP outs = &apos; differences DCSP from DCSP &quot; { 0 } &quot; DCSP results DCSP : &apos; .format ( bulk _ ret &#91; 0 &#93; &#91; &apos; pool &apos; &#93; &#91; 0 &#93; ) DCNL DCSP DCSP print ( outs ) DCNL DCSP DCSP print ( ( &apos; -&apos; * ( len ( outs ) - 1 ) ) ) DCNL DCSP DCSP from _ result = bulk _ ret &#91; 0 &#93; &#91; &apos; result &apos; &#93; .splitlines ( ) DCNL DCSP DCSP for i in range ( 0 , len ( from _ result ) ) : DCNL DCSP DCSP DCSP from _ result &#91; i &#93; + = &apos; \ n &apos; DCNL DCSP DCSP to _ result = k &#91; &apos; result &apos; &#93; .splitlines ( ) DCNL DCSP DCSP for i in range ( 0 , len ( to _ result ) ) : DCNL DCSP DCSP DCSP to _ result &#91; i &#93; + = &apos; \ n &apos; DCNL DCSP DCSP outs = &apos; &apos; DCNL DCSP DCSP outs + = &apos; &apos;.join ( difflib.unified _ diff ( from _ result , to _ result , fromfile = bulk _ ret &#91; 0 &#93; &#91; &apos; pool &apos; &#93; &#91; 0 &#93; , tofile = k &#91; &apos; pool &apos; &#93; &#91; 0 &#93; , n = 0 ) ) DCNL DCSP DCSP print ( outs ) DCNL DCSP DCSP print ( ) DCNL DCSP return bulk _ ret
DCSP def _ find _ range _ info ( diff ) : DCNL DCSP DCSP lines = split _ line _ endings ( diff ) DCNL DCSP DCSP process _ changes = False DCNL DCSP DCSP process _ trailing _ context = False DCNL DCSP DCSP ranges = &#91; &#93; DCNL DCSP DCSP chunk _ start = None DCNL DCSP DCSP chunk _ len = 0 DCNL DCSP DCSP lines _ of _ context = 0 DCNL DCSP DCSP for line in lines : DCNL DCSP DCSP DCSP if process _ changes : DCNL DCSP DCSP DCSP DCSP if line.startswith ( ( &apos; -&apos; , &apos; + &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP start = ( ( chunk _ start - 1 ) + lines _ of _ context ) DCNL DCSP DCSP DCSP DCSP DCSP chunk _ len - = lines _ of _ context DCNL DCSP DCSP DCSP DCSP DCSP if ( lines _ of _ context &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP start - = 1 DCNL DCSP DCSP DCSP DCSP DCSP ranges.append ( ( start , ( start + chunk _ len ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP process _ changes = False DCNL DCSP DCSP DCSP DCSP DCSP process _ trailing _ context = True DCNL DCSP DCSP DCSP DCSP DCSP lines _ of _ context = 0 DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP lines _ of _ context + = 1 DCNL DCSP DCSP DCSP elif process _ trailing _ context : DCNL DCSP DCSP DCSP DCSP if line.startswith ( &apos; DCSP &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP lines _ of _ context + = 1 DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP lines _ of _ context = 0 DCNL DCSP DCSP DCSP m = CHUNK _ RANGE _ RE.match ( line ) DCNL DCSP DCSP DCSP if m : DCNL DCSP DCSP DCSP DCSP if ( process _ trailing _ context and ( lines _ of _ context &gt; 0 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP last _ range = ranges &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP ranges &#91; ( -1 ) &#93; = ( last _ range &#91; 0 &#93; , ( last _ range &#91; 1 &#93; - lines _ of _ context ) ) DCNL DCSP DCSP DCSP DCSP chunk _ start = int ( m.group ( u &apos;new _ start &apos; ) ) DCNL DCSP DCSP DCSP DCSP chunk _ len = int ( ( m.group ( u &apos;new _ len &apos; ) or u &apos; 1 &apos; ) ) DCNL DCSP DCSP DCSP DCSP process _ changes = True DCNL DCSP DCSP DCSP DCSP process _ trailing _ context = False DCNL DCSP DCSP DCSP DCSP lines _ of _ context = 0 DCNL DCSP DCSP if ( process _ trailing _ context and ( lines _ of _ context &gt; 0 ) ) : DCNL DCSP DCSP DCSP last _ range = ranges &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP ranges &#91; ( -1 ) &#93; = ( last _ range &#91; 0 &#93; , ( last _ range &#91; 1 &#93; - lines _ of _ context ) ) DCNL DCSP DCSP return ranges DCNL DCSP def _ is _ range _ valid ( line _ range , tag , i1 , i2 ) : DCNL DCSP DCSP return ( ( line _ range is not None ) and ( i1 &gt; = line _ range &#91; 0 &#93; ) and ( ( tag = = u &apos;delete &apos; ) or ( i1 ! = i2 ) ) ) DCNL DCSP orig _ ranges = _ find _ range _ info ( filediff _ data ) DCNL DCSP new _ ranges = _ find _ range _ info ( interfilediff _ data ) DCNL DCSP orig _ range _ i = 0 DCNL DCSP new _ range _ i = 0 DCNL DCSP if orig _ ranges : DCNL DCSP DCSP orig _ range = orig _ ranges &#91; orig _ range _ i &#93; DCNL DCSP else : DCNL DCSP DCSP orig _ range = None DCNL DCSP if new _ ranges : DCNL DCSP DCSP new _ range = new _ ranges &#91; new _ range _ i &#93; DCNL DCSP else : DCNL DCSP DCSP new _ range = None DCNL DCSP if ( ( not orig _ range ) and ( not new _ range ) ) : DCNL DCSP DCSP for ( tag , i1 , i2 , j1 , j2 ) in opcodes : DCNL DCSP DCSP DCSP ( yield ( tag , i1 , i2 , j1 , j2 ) ) DCNL DCSP DCSP return DCNL DCSP for ( tag , i1 , i2 , j1 , j2 ) in opcodes : DCNL DCSP DCSP while ( orig _ range and ( i1 &gt; orig _ range &#91; 1 &#93; ) ) : DCNL DCSP DCSP DCSP orig _ range _ i + = 1 DCNL DCSP DCSP DCSP if ( orig _ range _ i &lt; len ( orig _ ranges ) ) : DCNL DCSP DCSP DCSP DCSP orig _ range = orig _ ranges &#91; orig _ range _ i &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP orig _ range = None DCNL DCSP DCSP while ( new _ range and ( j1 &gt; new _ range &#91; 1 &#93; ) ) : DCNL DCSP DCSP DCSP new _ range _ i + = 1 DCNL DCSP DCSP DCSP if ( new _ range _ i &lt; len ( new _ ranges ) ) : DCNL DCSP DCSP DCSP DCSP new _ range = new _ ranges &#91; new _ range _ i &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP new _ range = None DCNL DCSP DCSP orig _ starts _ valid = _ is _ range _ valid ( orig _ range , tag , i1 , i2 ) DCNL DCSP DCSP new _ starts _ valid = _ is _ range _ valid ( new _ range , tag , j1 , j2 ) DCNL DCSP DCSP if ( tag in ( u &apos;equal &apos; , u &apos;replace &apos; ) ) : DCNL DCSP DCSP DCSP valid _ chunk = ( orig _ starts _ valid or new _ starts _ valid ) DCNL DCSP DCSP elif ( tag = = u &apos;delete &apos; ) : DCNL DCSP DCSP DCSP valid _ chunk = orig _ starts _ valid DCNL DCSP DCSP elif ( tag = = u &apos;insert &apos; ) : DCNL DCSP DCSP DCSP valid _ chunk = new _ starts _ valid DCNL DCSP DCSP if valid _ chunk : DCNL DCSP DCSP DCSP if orig _ range : DCNL DCSP DCSP DCSP DCSP cap _ i2 = ( orig _ range &#91; 1 &#93; + 1 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP cap _ i2 = i2 DCNL DCSP DCSP DCSP if new _ range : DCNL DCSP DCSP DCSP DCSP cap _ j2 = ( new _ range &#91; 1 &#93; + 1 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP cap _ j2 = j2 DCNL DCSP DCSP DCSP if orig _ starts _ valid : DCNL DCSP DCSP DCSP DCSP valid _ i2 = min ( i2 , cap _ i2 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP valid _ i2 = i2 DCNL DCSP DCSP DCSP if new _ starts _ valid : DCNL DCSP DCSP DCSP DCSP valid _ j2 = min ( j2 , cap _ j2 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP valid _ j2 = j2 DCNL DCSP DCSP DCSP if ( tag in ( u &apos;equal &apos; , u &apos;replace &apos; ) ) : DCNL DCSP DCSP DCSP DCSP i _ diff = ( valid _ i2 - i1 ) DCNL DCSP DCSP DCSP DCSP j _ diff = ( valid _ j2 - j1 ) DCNL DCSP DCSP DCSP DCSP if ( valid _ i2 &gt; cap _ i2 ) : DCNL DCSP DCSP DCSP DCSP DCSP assert ( valid _ j2 &lt; = cap _ j2 ) DCNL DCSP DCSP DCSP DCSP DCSP max _ cap = j _ diff DCNL DCSP DCSP DCSP DCSP elif ( valid _ j2 &gt; cap _ j2 ) : DCNL DCSP DCSP DCSP DCSP DCSP max _ cap = i _ diff DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP max _ cap = max ( i _ diff , j _ diff ) DCNL DCSP DCSP DCSP DCSP valid _ i2 = ( i1 + max _ cap ) DCNL DCSP DCSP DCSP DCSP valid _ j2 = ( j1 + max _ cap ) DCNL DCSP DCSP DCSP DCSP cap _ i2 = valid _ i2 DCNL DCSP DCSP DCSP DCSP cap _ j2 = valid _ j2 DCNL DCSP DCSP DCSP ( yield ( tag , i1 , valid _ i2 , j1 , valid _ j2 ) ) DCNL DCSP DCSP DCSP if ( ( valid _ i2 = = i2 ) and ( valid _ j2 = = j2 ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( ( orig _ range is not None ) and ( ( i2 + 1 ) &gt; cap _ i2 ) ) : DCNL DCSP DCSP DCSP DCSP i1 = cap _ i2 DCNL DCSP DCSP DCSP if ( ( new _ range is not None ) and ( ( j2 + 1 ) &gt; cap _ j2 ) ) : DCNL DCSP DCSP DCSP DCSP j1 = cap _ j2 DCNL DCSP DCSP DCSP valid _ chunk = False DCNL DCSP DCSP if ( not valid _ chunk ) : DCNL DCSP DCSP DCSP ( yield ( u &apos;filtered-equal &apos; , i1 , i2 , j1 , j2 ) )
DCSP dest = salt.utils.mac _ str _ to _ bytes ( mac ) DCNL DCSP sock = socket.socket ( socket.AF _ INET , socket.SOCK _ DGRAM ) DCNL DCSP sock.setsockopt ( socket.SOL _ SOCKET , socket.SO _ BROADCAST , 1 ) DCNL DCSP sock.sendto ( ( ( &apos; \ xff &apos; * 6 ) + ( dest * 16 ) ) , ( bcast , int ( destport ) ) ) DCNL DCSP return True
DCSP result = command.replace ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; ) DCNL DCSP result = result.replace ( &apos; &quot; &apos; , &apos; \ \ &quot; &apos; ) DCNL DCSP return result
DCSP return int ( s.strip ( ) )
DCSP from .. config import CONF DCNL DCSP def TkPKG ( * args , * * kwargs ) : DCNL DCSP DCSP global _ old _ api _ error DCNL DCSP DCSP _ old _ api _ error ( &apos; TkPKG &apos; ) DCNL DCSP def TkTree ( * args , * * kwargs ) : DCNL DCSP DCSP global _ old _ api _ error DCNL DCSP DCSP _ old _ api _ error ( &apos; TkTree &apos; ) DCNL DCSP distpath = compat.expand _ path ( distpath ) DCNL DCSP workpath = compat.expand _ path ( workpath ) DCNL DCSP CONF &#91; &apos; spec &apos; &#93; = compat.expand _ path ( spec ) DCNL DCSP ( CONF &#91; &apos; specpath &apos; &#93; , CONF &#91; &apos; specnm &apos; &#93; ) = os.path.split ( spec ) DCNL DCSP CONF &#91; &apos; specnm &apos; &#93; = os.path.splitext ( CONF &#91; &apos; specnm &apos; &#93; ) &#91; 0 &#93; DCNL DCSP if ( os.path.dirname ( distpath ) = = HOMEPATH ) : DCNL DCSP DCSP distpath = os.path.join ( HOMEPATH , CONF &#91; &apos; specnm &apos; &#93; , os.path.basename ( distpath ) ) DCNL DCSP CONF &#91; &apos; distpath &apos; &#93; = distpath DCNL DCSP if ( os.path.dirname ( workpath ) = = HOMEPATH ) : DCNL DCSP DCSP workpath = os.path.join ( HOMEPATH , CONF &#91; &apos; specnm &apos; &#93; , os.path.basename ( workpath ) , CONF &#91; &apos; specnm &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP workpath = os.path.join ( workpath , CONF &#91; &apos; specnm &apos; &#93; ) DCNL DCSP CONF &#91; &apos; warnfile &apos; &#93; = os.path.join ( workpath , ( &apos; warn % s.txt &apos; % CONF &#91; &apos; specnm &apos; &#93; ) ) DCNL DCSP CONF &#91; &apos; dot-file &apos; &#93; = os.path.join ( workpath , ( &apos; graph- % s.dot &apos; % CONF &#91; &apos; specnm &apos; &#93; ) ) DCNL DCSP CONF &#91; &apos; xref-file &apos; &#93; = os.path.join ( workpath , ( &apos; xref- % s.html &apos; % CONF &#91; &apos; specnm &apos; &#93; ) ) DCNL DCSP if clean _ build : DCNL DCSP DCSP logger.info ( &apos; Removing DCSP temporary DCSP files DCSP and DCSP cleaning DCSP cache DCSP in DCSP % s &apos; , CONF &#91; &apos; cachedir &apos; &#93; ) DCNL DCSP DCSP for pth in ( CONF &#91; &apos; cachedir &apos; &#93; , workpath ) : DCNL DCSP DCSP DCSP if os.path.exists ( pth ) : DCNL DCSP DCSP DCSP DCSP for f in glob.glob ( ( pth + &apos; / * &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if os.path.isdir ( f ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP shutil.rmtree ( f ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP os.remove ( f ) DCNL DCSP for pth in ( CONF &#91; &apos; distpath &apos; &#93; , workpath ) : DCNL DCSP DCSP if ( not os.path.exists ( pth ) ) : DCNL DCSP DCSP DCSP os.makedirs ( pth ) DCNL DCSP spec _ namespace = { &apos; DISTPATH &apos; : CONF &#91; &apos; distpath &apos; &#93; , &apos; HOMEPATH &apos; : HOMEPATH , &apos; SPEC &apos; : CONF &#91; &apos; spec &apos; &#93; , &apos; specnm &apos; : CONF &#91; &apos; specnm &apos; &#93; , &apos; SPECPATH &apos; : CONF &#91; &apos; specpath &apos; &#93; , &apos; WARNFILE &apos; : CONF &#91; &apos; warnfile &apos; &#93; , &apos; workpath &apos; : workpath , &apos; TOC &apos; : TOC , &apos; Analysis &apos; : Analysis , &apos; BUNDLE &apos; : BUNDLE , &apos; COLLECT &apos; : COLLECT , &apos; EXE &apos; : EXE , &apos; MERGE &apos; : MERGE , &apos; PYZ &apos; : PYZ , &apos; Tree &apos; : Tree , &apos; TkPKG &apos; : TkPKG , &apos; TkTree &apos; : TkTree , &apos; os &apos; : os , &apos; pyi _ crypto &apos; : pyz _ crypto } DCNL DCSP from .. config import CONF DCNL DCSP CONF &#91; &apos; workpath &apos; &#93; = workpath DCNL DCSP with open ( spec , &apos; r &apos; ) as f : DCNL DCSP DCSP text = f.read ( ) DCNL DCSP exec text in spec _ namespace
DCSP if image _ id : DCNL DCSP DCSP metadata = IMAGE _ API.get ( context , image _ id , include _ locations = True ) DCNL DCSP DCSP locations = metadata.get ( &apos; locations &apos; ) DCNL DCSP DCSP if locations : DCNL DCSP DCSP DCSP for loc in locations : DCNL DCSP DCSP DCSP DCSP loc _ url = loc.get ( &apos; url &apos; ) DCNL DCSP DCSP DCSP DCSP if ( loc _ url and loc _ url.startswith ( &apos; vsphere : / / &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return loc _ url DCNL DCSP return None
DCSP raw = read _ raw _ fif ( fname _ data ) DCNL DCSP inverse _ operator = read _ inverse _ operator ( fname _ inv ) DCNL DCSP label = read _ label ( fname _ label ) DCNL DCSP ( tmin , tmax ) = ( 0 , 20 ) DCNL DCSP ( fmin , fmax ) = ( 55 , 65 ) DCNL DCSP n _ fft = 2048 DCNL DCSP stc = compute _ source _ psd ( raw , inverse _ operator , lambda2 = ( 1.0 / 9.0 ) , method = &apos; dSPM &apos; , tmin = tmin , tmax = tmax , fmin = fmin , fmax = fmax , pick _ ori = &apos; normal &apos; , n _ fft = n _ fft , label = label , overlap = 0.1 ) DCNL DCSP assert _ true ( ( stc.times &#91; 0 &#93; &gt; = ( fmin * 0.001 ) ) ) DCNL DCSP assert _ true ( ( stc.times &#91; ( -1 ) &#93; &lt; = ( fmax * 0.001 ) ) ) DCNL DCSP assert _ true ( ( 0.059 &lt; = stc.times &#91; np.argmax ( np.sum ( stc.data , axis = 0 ) ) &#93; &lt; = 0.061 ) )
DCSP track = TrackInfo ( title = u &apos;track DCSP info &apos; , track _ id = track _ id ) DCNL DCSP for field in TRACK _ INFO _ FIELDS : DCNL DCSP DCSP setattr ( track , field , u &apos;track DCSP info &apos; ) DCNL DCSP for ( field , value ) in values.items ( ) : DCNL DCSP DCSP setattr ( track , field , value ) DCNL DCSP return track
DCSP if ( ( i &lt; 0 ) or ( j &lt; 0 ) or ( i &gt; u ) or ( j &gt; u ) ) : DCNL DCSP DCSP raise IndexError ( ( &apos; 0 DCSP &lt; = DCSP i DCSP &lt; DCSP j DCSP &lt; = DCSP % s DCSP expected &apos; % u ) ) DCNL DCSP elif ( i = = j ) : DCNL DCSP DCSP return f DCNL DCSP ( F , H ) = ( dmp _ to _ dict ( f , u ) , { } ) DCNL DCSP for ( exp , coeff ) in F.items ( ) : DCNL DCSP DCSP H &#91; ( ( ( ( exp &#91; : i &#93; + ( exp &#91; j &#93; , ) ) + exp &#91; ( i + 1 ) : j &#93; ) + ( exp &#91; i &#93; , ) ) + exp &#91; ( j + 1 ) : &#93; ) &#93; = coeff DCNL DCSP return dmp _ from _ dict ( H , u , K )
DCSP scriptDir = os.path.dirname ( _ _ file _ _ ) DCNL DCSP pathname = os.path.join ( scriptDir , &apos; datasets &apos; , filename ) DCNL DCSP print ( &apos; Creating DCSP % s ... &apos; % pathname ) DCNL DCSP fields = &#91; ( &apos; classification &apos; , &apos; float &apos; , &apos; &apos; ) , ( &apos; field1 &apos; , &apos; float &apos; , &apos; &apos; ) &#93; DCNL DCSP if includeRandom : DCNL DCSP DCSP fields + = &#91; ( &apos; randomData &apos; , &apos; float &apos; , &apos; &apos; ) &#93; DCNL DCSP outFile = FileRecordStream ( pathname , write = True , fields = fields ) DCNL DCSP sequences = &#91; &#93; DCNL DCSP for i in range ( numSequences ) : DCNL DCSP DCSP seq = &#91; x for x in range ( ( i * elementsPerSeq ) , ( ( i + 1 ) * elementsPerSeq ) ) &#93; DCNL DCSP DCSP sequences.append ( seq ) DCNL DCSP random.seed ( 42 ) DCNL DCSP seqIdxs = &#91; &#93; DCNL DCSP for i in range ( numRepeats ) : DCNL DCSP DCSP seqIdxs + = range ( numSequences ) DCNL DCSP random.shuffle ( seqIdxs ) DCNL DCSP for seqIdx in seqIdxs : DCNL DCSP DCSP seq = sequences &#91; seqIdx &#93; DCNL DCSP DCSP for x in seq : DCNL DCSP DCSP DCSP if includeRandom : DCNL DCSP DCSP DCSP DCSP outFile.appendRecord ( &#91; seqIdx , ( x * stepSize ) , random.random ( ) &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP outFile.appendRecord ( &#91; seqIdx , ( x * stepSize ) &#93; ) DCNL DCSP outFile.close ( )
DCSP init _ py = open ( os.path.join ( package , &apos; _ _ init _ _ .py &apos; ) ) .read ( ) DCNL DCSP return re.search ( &apos; _ _ version _ _ DCSP = DCSP &#91; \ &apos; &quot; &#93; ( &#91; ^ \ &apos; &quot; &#93; + ) &#91; \ &apos; &quot; &#93; &apos; , init _ py ) .group ( 1 )
DCSP for region in regions ( ) : DCNL DCSP DCSP if ( region.name = = region _ name ) : DCNL DCSP DCSP DCSP return region.connect ( * * kw _ params ) DCNL DCSP return None
DCSP def inst _ key ( inst , vars ) : DCNL DCSP DCSP return tuple ( ( str ( inst &#91; var &#93; ) for var in vars ) ) DCNL DCSP excluded = set ( idvarlist ) DCNL DCSP all _ possible = &#91; var for var in ( table.domain.variables + table.domain.metas ) if ( var not in excluded ) &#93; DCNL DCSP candidate _ set = set ( all _ possible ) DCNL DCSP idmap = group _ table _ indices ( table , idvarlist ) DCNL DCSP values = { } DCNL DCSP varying = set ( ) DCNL DCSP for indices in idmap.values ( ) : DCNL DCSP DCSP subset = table &#91; indices &#93; DCNL DCSP DCSP for var in list ( candidate _ set ) : DCNL DCSP DCSP DCSP values = subset &#91; : , var &#93; DCNL DCSP DCSP DCSP ( values , _ ) = subset.get _ column _ view ( var ) DCNL DCSP DCSP DCSP if var.is _ string : DCNL DCSP DCSP DCSP DCSP uniq = set ( values ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP uniq = unique _ non _ nan ( values ) DCNL DCSP DCSP DCSP if ( len ( uniq ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP varying.add ( var ) DCNL DCSP DCSP DCSP DCSP candidate _ set.remove ( var ) DCNL DCSP return sorted ( varying , key = all _ possible.index )
DCSP if ( len ( prefix ) = = n _ const.DEVICE _ NAME _ MAX _ LEN ) : DCNL DCSP DCSP return creation _ func ( prefix , * args , * * kwargs ) DCNL DCSP while True : DCNL DCSP DCSP name = utils.get _ rand _ name ( max _ length = n _ const.DEVICE _ NAME _ MAX _ LEN , prefix = prefix ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return creation _ func ( name , * args , * * kwargs ) DCNL DCSP DCSP except RuntimeError : DCNL DCSP DCSP DCSP pass
DCSP raw = read _ raw _ fif ( test _ fif _ fname , preload = True ) DCNL DCSP ( _ , times ) = raw &#91; 0 , : 10 &#93; DCNL DCSP df = raw.to _ data _ frame ( ) DCNL DCSP assert _ true ( ( df.columns = = raw.ch _ names ) .all ( ) ) DCNL DCSP assert _ array _ equal ( np.round ( ( times * 1000.0 ) ) , df.index.values &#91; : 10 &#93; ) DCNL DCSP df = raw.to _ data _ frame ( index = None ) DCNL DCSP assert _ true ( ( &apos; time &apos; in df.index.names ) ) DCNL DCSP assert _ array _ equal ( df.values &#91; : , 0 &#93; , ( raw . _ data &#91; 0 &#93; * 10000000000000.0 ) ) DCNL DCSP assert _ array _ equal ( df.values &#91; : , 2 &#93; , ( raw . _ data &#91; 2 &#93; * 1000000000000000.0 ) )
DCSP for ( ci , cl ) in enumerate ( classes ) : DCNL DCSP DCSP images = glob ( &apos; { } / { } / * .jpg &apos; .format ( basedir , cl ) ) DCNL DCSP DCSP for im in sorted ( images ) : DCNL DCSP DCSP DCSP ( yield ( im , ci ) )
DCSP if ( ( not isinstance ( n , ( int , long ) ) ) or ( not isinstance ( b , ( int , long ) ) ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; unsupported DCSP operand DCSP type ( s ) : DCSP % r DCSP and DCSP % r &apos; % ( type ( n ) . _ _ name _ _ , type ( b ) . _ _ name _ _ ) ) ) DCNL DCSP assert ( ( n &gt; = 0 ) and ( b &gt; = 0 ) ) DCNL DCSP mask = ( ( 1L &lt; &lt; b ) - 1 ) DCNL DCSP if ( n &amp; mask ) : DCNL DCSP DCSP return ( ( n &gt; &gt; b ) + 1 ) DCNL DCSP else : DCNL DCSP DCSP return ( n &gt; &gt; b )
DCSP service = get _ object _ or _ 404 ( Service , pk = service _ id ) DCNL DCSP if ( ( not request.user.profile.has _ permission ( service , mode = &apos; w &apos; ) ) and ( not request.user.profile.is _ admin ( &apos; treeio _ services &apos; ) ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Service &quot; ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP form = ServiceForm ( request.user.profile , request.POST , instance = service ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP service = form.save ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; services _ service _ view &apos; , args = &#91; service.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; services _ service _ view &apos; , args = &#91; service.id &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP form = ServiceForm ( request.user.profile , instance = service ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; form &apos; : form , &apos; service &apos; : service } ) DCNL DCSP return render _ to _ response ( &apos; services / service _ edit &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP payload = { &apos; user _ id &apos; : user _ id , &apos; reference _ dict &apos; : reference.to _ dict ( ) , &apos; old _ status &apos; : old _ status , &apos; new _ status &apos; : new _ status } DCNL DCSP taskqueue _ services.enqueue _ task ( feconf.TASK _ URL _ FEEDBACK _ STATUS _ EMAILS , payload , 0 )
DCSP print ( &apos; Running DCSP test _ close _ connections &apos; ) DCNL DCSP s3 = boto.connect _ s3 ( ) DCNL DCSP for b in s3.get _ all _ buckets ( ) : DCNL DCSP DCSP if b.name.startswith ( &apos; test- &apos; ) : DCNL DCSP DCSP DCSP for key in b.get _ all _ keys ( ) : DCNL DCSP DCSP DCSP DCSP key.delete ( ) DCNL DCSP DCSP DCSP b.delete ( ) DCNL DCSP bucket = s3.create _ bucket ( ( &apos; test- % d &apos; % int ( time.time ( ) ) ) ) DCNL DCSP names = &#91; str ( uuid.uuid4 ) for _ in range ( 30 ) &#93; DCNL DCSP threads = &#91; spawn ( put _ object , bucket , name ) for name in names &#93; DCNL DCSP for t in threads : DCNL DCSP DCSP t.join ( ) DCNL DCSP threads = &#91; spawn ( get _ object , bucket , name ) for name in names &#93; DCNL DCSP for t in threads : DCNL DCSP DCSP t.join ( )
DCSP expression = _ ValidateString ( expression , max _ len = MAXIMUM _ EXPRESSION _ LENGTH ) DCNL DCSP try : DCNL DCSP DCSP expression _ parser.Parse ( expression ) DCNL DCSP except expression _ parser.ExpressionException as e : DCNL DCSP DCSP raise ExpressionError ( ( &apos; Failed DCSP to DCSP parse DCSP expression DCSP &quot; % s &quot; &apos; % expression ) ) DCNL DCSP return expression
DCSP return get _ hub ( ) .resolver.gethostbyname ( hostname )
DCSP if ( not length ) : DCNL DCSP DCSP length = linux _ process _ info.address _ size DCNL DCSP cont = True DCNL DCSP while ( space.is _ valid _ address ( start ) and cont ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP value = read _ address ( space , start , length ) DCNL DCSP DCSP DCSP ( yield value ) DCNL DCSP DCSP except struct.error : DCNL DCSP DCSP DCSP cont = False DCNL DCSP DCSP DCSP ( yield None ) DCNL DCSP DCSP if reverse : DCNL DCSP DCSP DCSP start - = length DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP start + = length
DCSP ( drive , path ) = os.path.splitdrive ( path ) DCNL DCSP if ( sys.platform = = &apos; mac &apos; ) : DCNL DCSP DCSP return ( os.sep + path ) DCNL DCSP else : DCNL DCSP DCSP if ( path &#91; 0 : 1 &#93; = = os.sep ) : DCNL DCSP DCSP DCSP path = ( drive + path &#91; 1 : &#93; ) DCNL DCSP DCSP return path
DCSP for loop in loops : DCNL DCSP DCSP addXIntersectionsFromLoopForTable ( loop , xIntersectionsTable , width )
DCSP namespace = _ get _ cache _ key _ namespace ( cache _ key ) DCNL DCSP duration = settings.SHUUP _ CACHE _ DURATIONS.get ( namespace ) DCNL DCSP if ( duration is None ) : DCNL DCSP DCSP duration = DEFAULT _ CACHE _ DURATIONS.get ( namespace , settings.SHUUP _ DEFAULT _ CACHE _ DURATION ) DCNL DCSP return duration
DCSP return joinedload ( * args , * * kwargs )
DCSP ret = { } DCNL DCSP if ( saltenv not in _ _ opts _ _ &#91; &apos; pillar _ roots &apos; &#93; ) : DCNL DCSP DCSP return ret DCNL DCSP for f _ root in _ _ opts _ _ &#91; &apos; pillar _ roots &apos; &#93; &#91; saltenv &#93; : DCNL DCSP DCSP ret &#91; f _ root &#93; = { } DCNL DCSP DCSP for ( root , dirs , files ) in os.walk ( f _ root ) : DCNL DCSP DCSP DCSP sub = ret &#91; f _ root &#93; DCNL DCSP DCSP DCSP if ( root ! = f _ root ) : DCNL DCSP DCSP DCSP DCSP sroot = root DCNL DCSP DCSP DCSP DCSP above = &#91; &#93; DCNL DCSP DCSP DCSP DCSP while ( not os.path.samefile ( sroot , f _ root ) ) : DCNL DCSP DCSP DCSP DCSP DCSP base = os.path.basename ( sroot ) DCNL DCSP DCSP DCSP DCSP DCSP if base : DCNL DCSP DCSP DCSP DCSP DCSP DCSP above.insert ( 0 , base ) DCNL DCSP DCSP DCSP DCSP DCSP sroot = os.path.dirname ( sroot ) DCNL DCSP DCSP DCSP DCSP for aroot in above : DCNL DCSP DCSP DCSP DCSP DCSP sub = sub &#91; aroot &#93; DCNL DCSP DCSP DCSP for dir _ in dirs : DCNL DCSP DCSP DCSP DCSP sub &#91; dir _ &#93; = { } DCNL DCSP DCSP DCSP for fn _ in files : DCNL DCSP DCSP DCSP DCSP sub &#91; fn _ &#93; = &apos; f &apos; DCNL DCSP return ret
DCSP for l in f : DCNL DCSP DCSP ( yield parse _ reflog _ line ( l ) )
DCSP if re.search ( &apos; . * \ \ .iteritems \ \ ( \ \ ) &apos; , logical _ line ) : DCNL DCSP DCSP msg = &apos; N327 : DCSP Use DCSP six.iteritems ( ) DCSP instead DCSP of DCSP dict.iteritems ( ) . &apos; DCNL DCSP DCSP ( yield ( 0 , msg ) )
DCSP result = &#91; &#93; DCNL DCSP needquote = False DCNL DCSP for arg in seq : DCNL DCSP DCSP bs _ buf = &#91; &#93; DCNL DCSP DCSP if result : DCNL DCSP DCSP DCSP result.append ( &apos; DCSP &apos; ) DCNL DCSP DCSP needquote = ( ( &apos; DCSP &apos; in arg ) or ( &apos; DCTB &apos; in arg ) or ( &apos; &#124; &apos; in arg ) or ( not arg ) ) DCNL DCSP DCSP if needquote : DCNL DCSP DCSP DCSP result.append ( &apos; &quot; &apos; ) DCNL DCSP DCSP for c in arg : DCNL DCSP DCSP DCSP if ( c = = &apos; \ \ &apos; ) : DCNL DCSP DCSP DCSP DCSP bs _ buf.append ( c ) DCNL DCSP DCSP DCSP elif ( c = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP DCSP result.append ( ( ( &apos; \ \ &apos; * len ( bs _ buf ) ) * 2 ) ) DCNL DCSP DCSP DCSP DCSP bs _ buf = &#91; &#93; DCNL DCSP DCSP DCSP DCSP result.append ( &apos; \ \ &quot; &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if bs _ buf : DCNL DCSP DCSP DCSP DCSP DCSP result.extend ( bs _ buf ) DCNL DCSP DCSP DCSP DCSP DCSP bs _ buf = &#91; &#93; DCNL DCSP DCSP DCSP DCSP result.append ( c ) DCNL DCSP DCSP if bs _ buf : DCNL DCSP DCSP DCSP result.extend ( bs _ buf ) DCNL DCSP DCSP if needquote : DCNL DCSP DCSP DCSP result.extend ( bs _ buf ) DCNL DCSP DCSP DCSP result.append ( &apos; &quot; &apos; ) DCNL DCSP return &apos; &apos;.join ( result )
DCSP logger = logging.getLogger ( _ _ name _ _ ) DCNL DCSP handler = logging.StreamHandler ( ) DCNL DCSP handler.setFormatter ( logging.Formatter ( &apos; % ( asctime ) s DCSP % ( levelname ) s DCSP % ( message ) s &apos; ) ) DCNL DCSP logger.addHandler ( handler ) DCNL DCSP logger.setLevel ( level ) DCNL DCSP logger.debug ( ( &apos; Added DCSP a DCSP stderr DCSP logging DCSP handler DCSP to DCSP logger : DCSP % s &apos; % _ _ name _ _ ) ) DCNL DCSP return handler
DCSP ( p1 , p2 ) = ( urllib _ parse.urlparse ( url1 ) , urllib _ parse.urlparse ( url2 ) ) DCNL DCSP return ( ( p1.scheme , p1.hostname , p1.port ) = = ( p2.scheme , p2.hostname , p2.port ) )
DCSP sfreq = 100 DCNL DCSP sig _ len _ secs = 15 DCNL DCSP a = rng.randn ( 2 , ( sig _ len _ secs * sfreq ) ) DCNL DCSP for fl in &#91; &apos; blah &apos; , &#91; 0 , 1 &#93; , 1000.5 , &apos; 10ss &apos; , &apos; 10 &apos; &#93; : DCNL DCSP DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , 4 , 8 , None , fl , 1.0 , 1.0 ) DCNL DCSP for nj in &#91; &apos; blah &apos; , 0.5 &#93; : DCNL DCSP DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , 4 , 8 , None , 1000 , 1.0 , 1.0 , n _ jobs = nj , phase = &apos; zero &apos; , fir _ window = &apos; hann &apos; ) DCNL DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , 4 , 8 , None , 100 , 1.0 , 1.0 , fir _ window = &apos; foo &apos; ) DCNL DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , 4 , ( sfreq / 2.0 ) , None , 100 , 1.0 , 1.0 ) DCNL DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , ( -1 ) , None , None , 100 , 1.0 , 1.0 ) DCNL DCSP create _ filter ( a , sfreq , None , None ) DCNL DCSP create _ filter ( a , sfreq , None , None , method = &apos; iir &apos; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP filter _ data ( a , sfreq , 1 , 8 , filter _ length = 256 ) DCNL DCSP assert _ true ( any ( ( ( &apos; attenuation &apos; in str ( ww.message ) ) for ww in w ) ) ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP filter _ data ( a , sfreq , 1 , 8 , filter _ length = &apos; 0.5s &apos; ) DCNL DCSP assert _ true ( any ( ( ( &apos; Increase DCSP filter _ length &apos; in str ( ww.message ) ) for ww in w ) ) ) DCNL DCSP freqs = fftfreq ( a.shape &#91; ( -1 ) &#93; , ( 1.0 / sfreq ) ) DCNL DCSP A = np.abs ( fft ( a ) ) DCNL DCSP for fl in &#91; &apos; auto &apos; , &apos; 10s &apos; , &apos; 5000ms &apos; , 1024 , 1023 &#93; : DCNL DCSP DCSP bp = filter _ data ( a , sfreq , 4 , 8 , None , fl , 1.0 , 1.0 ) DCNL DCSP DCSP bs = filter _ data ( a , sfreq , ( 8 + 1.0 ) , ( 4 - 1.0 ) , None , fl , 1.0 , 1.0 ) DCNL DCSP DCSP lp = filter _ data ( a , sfreq , None , 8 , None , fl , 10 , 1.0 , n _ jobs = 2 ) DCNL DCSP DCSP hp = filter _ data ( lp , sfreq , 4 , None , None , fl , 1.0 , 10 ) DCNL DCSP DCSP assert _ array _ almost _ equal ( hp , bp , 4 ) DCNL DCSP DCSP assert _ array _ almost _ equal ( ( bp + bs ) , a , 4 ) DCNL DCSP DCSP mask = ( ( freqs &gt; 5.5 ) &amp; ( freqs &lt; 6.5 ) ) DCNL DCSP DCSP assert _ allclose ( np.mean ( ( np.abs ( fft ( bp ) &#91; : , mask &#93; ) / A &#91; : , mask &#93; ) ) , 1.0 , atol = 0.02 ) DCNL DCSP DCSP assert _ allclose ( np.mean ( ( np.abs ( fft ( bs ) &#91; : , mask &#93; ) / A &#91; : , mask &#93; ) ) , 0.0 , atol = 0.2 ) DCNL DCSP DCSP bp = filter _ data ( a , sfreq , 4 , 8 , None , fl , 1.0 , 1.0 , phase = &apos; minimum &apos; ) DCNL DCSP DCSP bs = filter _ data ( a , sfreq , ( 8 + 1.0 ) , ( 4 - 1.0 ) , None , fl , 1.0 , 1.0 , phase = &apos; minimum &apos; ) DCNL DCSP DCSP assert _ allclose ( np.mean ( ( np.abs ( fft ( bp ) &#91; : , mask &#93; ) / A &#91; : , mask &#93; ) ) , 1.0 , atol = 0.11 ) DCNL DCSP DCSP assert _ allclose ( np.mean ( ( np.abs ( fft ( bs ) &#91; : , mask &#93; ) / A &#91; : , mask &#93; ) ) , 0.0 , atol = 0.3 ) DCNL DCSP n _ resamp _ ignore = 10 DCNL DCSP bp _ up _ dn = resample ( resample ( bp , 2 , 1 , n _ jobs = 2 ) , 1 , 2 , n _ jobs = 2 ) DCNL DCSP assert _ array _ almost _ equal ( bp &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , bp _ up _ dn &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , 2 ) DCNL DCSP bp _ up _ dn = resample ( resample ( bp , 2 , 1 , n _ jobs = &apos; cuda &apos; ) , 1 , 2 , n _ jobs = &apos; cuda &apos; ) DCNL DCSP assert _ array _ almost _ equal ( bp &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , bp _ up _ dn &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , 2 ) DCNL DCSP bp _ up _ dn = sp _ resample ( sp _ resample ( bp , ( 2 * bp.shape &#91; ( -1 ) &#93; ) , axis = ( -1 ) , window = &apos; boxcar &apos; ) , bp.shape &#91; ( -1 ) &#93; , window = &apos; boxcar &apos; , axis = ( -1 ) ) DCNL DCSP assert _ array _ almost _ equal ( bp &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , bp _ up _ dn &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; , 2 ) DCNL DCSP t = ( np.array ( list ( range ( ( sfreq * sig _ len _ secs ) ) ) ) / float ( sfreq ) ) DCNL DCSP sig = np.sin ( ( ( ( ( 2 * np.pi ) * sfreq ) / 2.2 ) * t ) ) DCNL DCSP sig _ gone = resample ( sig , 1 , 2 ) &#91; n _ resamp _ ignore : ( - n _ resamp _ ignore ) &#93; DCNL DCSP assert _ array _ almost _ equal ( np.zeros _ like ( sig _ gone ) , sig _ gone , 2 ) DCNL DCSP iir _ params = dict ( ftype = &apos; cheby1 &apos; , gpass = 1 , gstop = 20 , output = &apos; ba &apos; ) DCNL DCSP iir _ params = construct _ iir _ filter ( iir _ params , 40 , 80 , 1000 , &apos; low &apos; ) DCNL DCSP assert _ equal ( ( iir _ params &#91; &apos; a &apos; &#93; .size - 1 ) , 3 ) DCNL DCSP assert _ equal ( ( iir _ params &#91; &apos; b &apos; &#93; .size - 1 ) , 3 ) DCNL DCSP iir _ params = dict ( ftype = &apos; butter &apos; , order = 4 , output = &apos; ba &apos; ) DCNL DCSP iir _ params = construct _ iir _ filter ( iir _ params , 40 , None , 1000 , &apos; low &apos; ) DCNL DCSP assert _ equal ( ( iir _ params &#91; &apos; a &apos; &#93; .size - 1 ) , 4 ) DCNL DCSP assert _ equal ( ( iir _ params &#91; &apos; b &apos; &#93; .size - 1 ) , 4 ) DCNL DCSP iir _ params = dict ( ftype = &apos; cheby1 &apos; , gpass = 1 , gstop = 20 , output = &apos; sos &apos; ) DCNL DCSP iir _ params = construct _ iir _ filter ( iir _ params , 40 , 80 , 1000 , &apos; low &apos; ) DCNL DCSP assert _ equal ( iir _ params &#91; &apos; sos &apos; &#93; .shape , ( 2 , 6 ) ) DCNL DCSP iir _ params = dict ( ftype = &apos; butter &apos; , order = 4 , output = &apos; sos &apos; ) DCNL DCSP iir _ params = construct _ iir _ filter ( iir _ params , 40 , None , 1000 , &apos; low &apos; ) DCNL DCSP assert _ equal ( iir _ params &#91; &apos; sos &apos; &#93; .shape , ( 2 , 6 ) ) DCNL DCSP a = rng.randn ( ( 5 * sfreq ) , ( 5 * sfreq ) ) DCNL DCSP b = a &#91; : , None , : &#93; DCNL DCSP a _ filt = filter _ data ( a , sfreq , 4 , 8 , None , 400 , 2.0 , 2.0 ) DCNL DCSP b _ filt = filter _ data ( b , sfreq , 4 , 8 , &#91; 0 &#93; , 400 , 2.0 , 2.0 ) DCNL DCSP assert _ array _ equal ( a _ filt &#91; : , None , : &#93; , b _ filt ) DCNL DCSP a = rng.randn ( 2 , 2 , 2 , 2 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , filter _ data , a , sfreq , 4 , 8 , np.array ( &#91; 0 , 1 &#93; ) , 100 , 1.0 , 1.0 )
DCSP if ( name is None ) : DCNL DCSP DCSP name = impl.name DCNL DCSP with REGISTRY _ LOCK : DCNL DCSP DCSP PLUGIN _ REGISTRY &#91; name &#93; = impl DCNL DCSP DCSP if ( name not in PLUGIN _ DEPENDENTS ) : DCNL DCSP DCSP DCSP PLUGIN _ DEPENDENTS &#91; name &#93; = set ( ) DCNL DCSP DCSP for dep in impl.dependencies : DCNL DCSP DCSP DCSP if ( dep not in PLUGIN _ DEPENDENTS ) : DCNL DCSP DCSP DCSP DCSP PLUGIN _ DEPENDENTS &#91; dep &#93; = set ( ) DCNL DCSP DCSP DCSP PLUGIN _ DEPENDENTS &#91; dep &#93; .add ( name )
DCSP from lettuce import step , world , before , after DCNL DCSP actions = { } DCNL DCSP @ before.each _ background DCNL DCSP def register _ background _ before ( background ) : DCNL DCSP DCSP actions &#91; &apos; before &apos; &#93; = unicode ( background ) DCNL DCSP @ after.each _ background DCNL DCSP def register _ background _ after ( background , results ) : DCNL DCSP DCSP actions &#91; &apos; after &apos; &#93; = { &apos; background &apos; : unicode ( background ) , &apos; results &apos; : results } DCNL DCSP @ step ( u &apos;the DCSP variable DCSP &quot; ( \ \ w + ) &quot; DCSP holds DCSP ( \ \ d + ) &apos; ) DCNL DCSP def set _ variable ( step , name , value ) : DCNL DCSP DCSP setattr ( world , name , int ( value ) ) DCNL DCSP @ step ( u &apos;the DCSP variable DCSP &quot; ( \ \ w + ) &quot; DCSP is DCSP equal DCSP to DCSP ( \ \ d + ) &apos; ) DCNL DCSP def check _ variable ( step , name , expected ) : DCNL DCSP DCSP expected = int ( expected ) DCNL DCSP DCSP expect ( world ) .to.have.property ( name ) .being.equal ( expected ) DCNL DCSP @ step ( u &apos;the DCSP variable DCSP &quot; ( \ \ w + ) &quot; DCSP times DCSP ( \ \ d + ) DCSP is DCSP equal DCSP to DCSP ( \ \ d + ) &apos; ) DCNL DCSP def multiply _ and _ verify ( step , name , times , expected ) : DCNL DCSP DCSP times = int ( times ) DCNL DCSP DCSP expected = int ( expected ) DCNL DCSP DCSP ( getattr ( world , name ) * times ) .should.equal ( expected ) DCNL DCSP filename = bg _ feature _ name ( &apos; naked &apos; ) DCNL DCSP runner = Runner ( filename , verbosity = 1 ) DCNL DCSP runner.run ( ) DCNL DCSP assert _ stdout _ lines ( &apos; .. \ n1 DCSP feature DCSP ( 1 DCSP passed ) \ n2 DCSP scenarios DCSP ( 2 DCSP passed ) \ n7 DCSP steps DCSP ( 7 DCSP passed ) \ n &apos; ) DCNL DCSP expect ( actions ) .to.equal ( { &apos; after &apos; : { &apos; results &apos; : &#91; True &#93; , &apos; background &apos; : u &apos; &lt; Background DCSP for DCSP feature : DCSP Without DCSP Header &gt; &apos; } , &apos; before &apos; : u &apos; &lt; Background DCSP for DCSP feature : DCSP Without DCSP Header &gt; &apos; } )
DCSP temp = filename.encode ( sys.getfilesystemencoding ( ) , errors = &apos; surrogateescape &apos; ) DCNL DCSP return temp.decode ( &apos; latin-1 &apos; )
DCSP psi = System.Diagnostics.ProcessStartInfo ( cmd ) DCNL DCSP psi.RedirectStandardOutput = True DCNL DCSP psi.RedirectStandardError = True DCNL DCSP psi.WindowStyle = System.Diagnostics.ProcessWindowStyle.Normal DCNL DCSP psi.UseShellExecute = False DCNL DCSP reg = System.Diagnostics.Process.Start ( psi ) DCNL DCSP myOutput = reg.StandardOutput DCNL DCSP output = myOutput.ReadToEnd ( ) DCNL DCSP myError = reg.StandardError DCNL DCSP error = myError.ReadToEnd ( ) DCNL DCSP return output
DCSP expected = http.HttpResponseForbidden ( ) DCNL DCSP response = json _ view ( ( lambda r : expected ) ) ( mock.Mock ( ) ) DCNL DCSP assert ( expected is response ) DCNL DCSP eq _ ( response &#91; &apos; Content-Type &apos; &#93; , &apos; text / html ; DCSP charset = utf-8 &apos; )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; , &apos; result &apos; : None } DCNL DCSP if ( name not in _ _ salt _ _ ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Module DCSP function DCSP { 0 } DCSP is DCSP not DCSP available &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Module DCSP function DCSP { 0 } DCSP is DCSP set DCSP to DCSP execute &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP aspec = salt.utils.args.get _ function _ argspec ( _ _ salt _ _ &#91; name &#93; ) DCNL DCSP args = &#91; &#93; DCNL DCSP defaults = { } DCNL DCSP arglen = 0 DCNL DCSP deflen = 0 DCNL DCSP if isinstance ( aspec.args , list ) : DCNL DCSP DCSP arglen = len ( aspec.args ) DCNL DCSP if isinstance ( aspec.defaults , tuple ) : DCNL DCSP DCSP deflen = len ( aspec.defaults ) DCNL DCSP for ind in range ( ( arglen - 1 ) , ( -1 ) , ( -1 ) ) : DCNL DCSP DCSP minus = ( arglen - ind ) DCNL DCSP DCSP if ( ( deflen - minus ) &gt; ( -1 ) ) : DCNL DCSP DCSP DCSP defaults &#91; aspec.args &#91; ind &#93; &#93; = aspec.defaults &#91; ( - minus ) &#93; DCNL DCSP for arg in defaults : DCNL DCSP DCSP if ( arg = = &apos; name &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; m _ name &apos; in kwargs ) : DCNL DCSP DCSP DCSP DCSP defaults &#91; arg &#93; = kwargs.pop ( &apos; m _ name &apos; ) DCNL DCSP DCSP elif ( arg = = &apos; fun &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; m _ fun &apos; in kwargs ) : DCNL DCSP DCSP DCSP DCSP defaults &#91; arg &#93; = kwargs.pop ( &apos; m _ fun &apos; ) DCNL DCSP DCSP elif ( arg = = &apos; state &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; m _ state &apos; in kwargs ) : DCNL DCSP DCSP DCSP DCSP defaults &#91; arg &#93; = kwargs.pop ( &apos; m _ state &apos; ) DCNL DCSP DCSP elif ( arg = = &apos; saltenv &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; m _ saltenv &apos; in kwargs ) : DCNL DCSP DCSP DCSP DCSP defaults &#91; arg &#93; = kwargs.pop ( &apos; m _ saltenv &apos; ) DCNL DCSP DCSP if ( arg in kwargs ) : DCNL DCSP DCSP DCSP defaults &#91; arg &#93; = kwargs.pop ( arg ) DCNL DCSP missing = set ( ) DCNL DCSP for arg in aspec.args : DCNL DCSP DCSP if ( arg = = &apos; name &apos; ) : DCNL DCSP DCSP DCSP rarg = &apos; m _ name &apos; DCNL DCSP DCSP elif ( arg = = &apos; fun &apos; ) : DCNL DCSP DCSP DCSP rarg = &apos; m _ fun &apos; DCNL DCSP DCSP elif ( arg = = &apos; names &apos; ) : DCNL DCSP DCSP DCSP rarg = &apos; m _ names &apos; DCNL DCSP DCSP elif ( arg = = &apos; state &apos; ) : DCNL DCSP DCSP DCSP rarg = &apos; m _ state &apos; DCNL DCSP DCSP elif ( arg = = &apos; saltenv &apos; ) : DCNL DCSP DCSP DCSP rarg = &apos; m _ saltenv &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP rarg = arg DCNL DCSP DCSP if ( ( rarg not in kwargs ) and ( arg not in defaults ) ) : DCNL DCSP DCSP DCSP missing.add ( rarg ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( arg in defaults ) : DCNL DCSP DCSP DCSP args.append ( defaults &#91; arg &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP args.append ( kwargs.pop ( rarg ) ) DCNL DCSP if missing : DCNL DCSP DCSP comment = &apos; The DCSP following DCSP arguments DCSP are DCSP missing : &apos; DCNL DCSP DCSP for arg in missing : DCNL DCSP DCSP DCSP comment + = &apos; DCSP { 0 } &apos; .format ( arg ) DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = comment DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP if ( aspec.varargs and ( aspec.varargs in kwargs ) ) : DCNL DCSP DCSP varargs = kwargs.pop ( aspec.varargs ) DCNL DCSP DCSP if ( not isinstance ( varargs , list ) ) : DCNL DCSP DCSP DCSP msg = &quot; &apos; { 0 } &apos; DCSP must DCSP be DCSP a DCSP list . &quot; DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg.format ( aspec.varargs ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP args.extend ( varargs ) DCNL DCSP nkwargs = { } DCNL DCSP if ( aspec.keywords and ( aspec.keywords in kwargs ) ) : DCNL DCSP DCSP nkwargs = kwargs.pop ( aspec.keywords ) DCNL DCSP DCSP if ( not isinstance ( nkwargs , dict ) ) : DCNL DCSP DCSP DCSP msg = &quot; &apos; { 0 } &apos; DCSP must DCSP be DCSP a DCSP dict . &quot; DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg.format ( aspec.keywords ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP return ret DCNL DCSP try : DCNL DCSP DCSP if aspec.keywords : DCNL DCSP DCSP DCSP mret = _ _ salt _ _ &#91; name &#93; ( * args , * * nkwargs ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP mret = _ _ salt _ _ &#91; name &#93; ( * args ) DCNL DCSP except Exception as e : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Module DCSP function DCSP { 0 } DCSP threw DCSP an DCSP exception . DCSP Exception : DCSP { 1 } &apos; .format ( name , e ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP if ( ( mret is not None ) or ( mret is not { } ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; ret &apos; &#93; = mret DCNL DCSP if ( &apos; returner &apos; in kwargs ) : DCNL DCSP DCSP ret _ ret = { &apos; id &apos; : _ _ opts _ _ &#91; &apos; id &apos; &#93; , &apos; ret &apos; : mret , &apos; fun &apos; : name , &apos; jid &apos; : salt.utils.jid.gen _ jid ( ) } DCNL DCSP DCSP returners = salt.loader.returners ( _ _ opts _ _ , _ _ salt _ _ ) DCNL DCSP DCSP if ( kwargs &#91; &apos; returner &apos; &#93; in returners ) : DCNL DCSP DCSP DCSP returners &#91; kwargs &#91; &apos; returner &apos; &#93; &#93; ( ret _ ret ) DCNL DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Module DCSP function DCSP { 0 } DCSP executed &apos; .format ( name ) DCNL DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP if ( isinstance ( mret , dict ) and ( mret.get ( &apos; retcode &apos; , 0 ) ! = 0 ) ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP elif isinstance ( mret , bool ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = mret DCNL DCSP else : DCNL DCSP DCSP changes _ ret = ret &#91; &apos; changes &apos; &#93; .get ( &apos; ret &apos; , { } ) DCNL DCSP DCSP if isinstance ( changes _ ret , dict ) : DCNL DCSP DCSP DCSP if isinstance ( changes _ ret.get ( &apos; result &apos; , { } ) , bool ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = changes _ ret.get ( &apos; result &apos; , { } ) DCNL DCSP DCSP DCSP elif ( changes _ ret.get ( &apos; retcode &apos; , 0 ) ! = 0 ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP return ret
DCSP if ( isinstance ( dbentries , list ) and ( len ( dbentries ) &lt; = 10 ) ) : DCNL DCSP DCSP dbentries = &apos; + &apos; .join ( dbentries ) DCNL DCSP elif ( isinstance ( dbentries , list ) and ( len ( dbentries ) &gt; 10 ) ) : DCNL DCSP DCSP raise Exception ( &apos; Maximum DCSP number DCSP of DCSP dbentries DCSP is DCSP 10 DCSP for DCSP kegg DCSP get DCSP query &apos; ) DCNL DCSP if ( option in &#91; &apos; aaseq &apos; , &apos; ntseq &apos; , &apos; mol &apos; , &apos; kcf &apos; , &apos; image &apos; , &apos; kgml &apos; &#93; ) : DCNL DCSP DCSP resp = _ q ( &apos; get &apos; , dbentries , option ) DCNL DCSP elif option : DCNL DCSP DCSP raise Exception ( &apos; Invalid DCSP option DCSP arg DCSP for DCSP kegg DCSP get DCSP request . &apos; ) DCNL DCSP else : DCNL DCSP DCSP resp = _ q ( &apos; get &apos; , dbentries ) DCNL DCSP return resp
DCSP return base64.b64decode ( s )
DCSP assert ( subcls.Attributes.table _ name is not None ) , ( &apos; % r DCSP has DCSP no DCSP table DCSP name . &apos; % subcls ) DCNL DCSP ( col _ args , col _ kwargs ) = sanitize _ args ( subcls.Attributes.sqla _ column _ args ) DCNL DCSP _ sp _ attrs _ to _ sqla _ constraints ( parent , subcls , col _ kwargs ) DCNL DCSP ( pk _ column , ) = get _ pk _ columns ( subcls ) DCNL DCSP ( pk _ key , pk _ spyne _ type ) = pk _ column DCNL DCSP pk _ sqla _ type = _ get _ sqlalchemy _ type ( pk _ spyne _ type ) DCNL DCSP if ( fk _ col _ name is None ) : DCNL DCSP DCSP fk _ col _ name = ( ( subname + &apos; _ &apos; ) + pk _ key ) DCNL DCSP assert ( fk _ col _ name ! = subname ) , &apos; The DCSP column DCSP name DCSP for DCSP the DCSP foreign DCSP key DCSP must DCSP be DCSP different DCSP from DCSP the DCSP column DCSP name DCSP for DCSP the DCSP object DCSP itself . &apos; DCNL DCSP fk = ForeignKey ( ( &apos; % s . % s &apos; % ( subcls.Attributes.table _ name , pk _ key ) ) , use _ alter = True , name = ( &apos; % s _ % s _ fkey &apos; % ( subcls.Attributes.table _ name , fk _ col _ name ) ) , deferrable = deferrable , initially = initially , ondelete = ondelete , onupdate = onupdate ) DCNL DCSP return Column ( fk _ col _ name , pk _ sqla _ type , fk , * col _ args , * * col _ kwargs )
DCSP ( xs , ps ) = cdf.Render ( ) DCNL DCSP xs = np.asarray ( xs ) DCNL DCSP ps = np.asarray ( ps ) DCNL DCSP scale = dict ( xscale = &apos; linear &apos; , yscale = &apos; linear &apos; ) DCNL DCSP for s in &#91; &apos; xscale &apos; , &apos; yscale &apos; &#93; : DCNL DCSP DCSP if ( s in options ) : DCNL DCSP DCSP DCSP scale &#91; s &#93; = options.pop ( s ) DCNL DCSP if ( transform = = &apos; exponential &apos; ) : DCNL DCSP DCSP complement = True DCNL DCSP DCSP scale &#91; &apos; yscale &apos; &#93; = &apos; log &apos; DCNL DCSP if ( transform = = &apos; pareto &apos; ) : DCNL DCSP DCSP complement = True DCNL DCSP DCSP scale &#91; &apos; yscale &apos; &#93; = &apos; log &apos; DCNL DCSP DCSP scale &#91; &apos; xscale &apos; &#93; = &apos; log &apos; DCNL DCSP if complement : DCNL DCSP DCSP ps = &#91; ( 1.0 - p ) for p in ps &#93; DCNL DCSP if ( transform = = &apos; weibull &apos; ) : DCNL DCSP DCSP xs = np.delete ( xs , ( -1 ) ) DCNL DCSP DCSP ps = np.delete ( ps , ( -1 ) ) DCNL DCSP DCSP ps = &#91; ( - math.log ( ( 1.0 - p ) ) ) for p in ps &#93; DCNL DCSP DCSP scale &#91; &apos; xscale &apos; &#93; = &apos; log &apos; DCNL DCSP DCSP scale &#91; &apos; yscale &apos; &#93; = &apos; log &apos; DCNL DCSP if ( transform = = &apos; gumbel &apos; ) : DCNL DCSP DCSP xs = xp.delete ( xs , 0 ) DCNL DCSP DCSP ps = np.delete ( ps , 0 ) DCNL DCSP DCSP ps = &#91; ( - math.log ( p ) ) for p in ps &#93; DCNL DCSP DCSP scale &#91; &apos; yscale &apos; &#93; = &apos; log &apos; DCNL DCSP options = _ Underride ( options , label = cdf.label ) DCNL DCSP Plot ( xs , ps , * * options ) DCNL DCSP return scale
DCSP cursor = connection.cursor ( ) DCNL DCSP cursor.execute ( &apos; DROP DCSP TABLE DCSP tko _ iteration _ attributes &apos; ) DCNL DCSP cursor.execute ( _ CREATE _ ITERATION _ ATTRIBUTES ) DCNL DCSP cursor.execute ( &apos; DROP DCSP TABLE DCSP tko _ iteration _ result &apos; ) DCNL DCSP cursor.execute ( _ CREATE _ ITERATION _ RESULTS )
DCSP d = { } DCNL DCSP items = &#91; s2 for s1 in qs.split ( &apos; &amp; &apos; ) for s2 in s1.split ( &apos; ; &apos; ) &#93; DCNL DCSP for item in items : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( k , v ) = item.split ( &apos; = &apos; , 1 ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP if strict _ parsing : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( v or keep _ blank _ values ) : DCNL DCSP DCSP DCSP k = unquote ( k.replace ( &apos; + &apos; , &apos; DCSP &apos; ) ) DCNL DCSP DCSP DCSP v = unquote ( v.replace ( &apos; + &apos; , &apos; DCSP &apos; ) ) DCNL DCSP DCSP DCSP if ( k in d ) : DCNL DCSP DCSP DCSP DCSP d &#91; k &#93; .append ( v ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP d &#91; k &#93; = &#91; v &#93; DCNL DCSP return d
DCSP try : DCNL DCSP DCSP resp = main _ function ( input _ path = input _ path ) DCNL DCSP DCSP for ( name , value ) in parse.extra _ resp _ headers.items ( ) : DCNL DCSP DCSP DCSP resp.headers.set ( name , value ) DCNL DCSP DCSP for ( name , cookie _ string ) in parse.extra _ cookies.items ( ) : DCNL DCSP DCSP DCSP resp.headers.add ( &apos; Set-Cookie &apos; , cookie _ string ) DCNL DCSP except : DCNL DCSP DCSP return generate _ error _ page ( is _ traceback = True ) DCNL DCSP else : DCNL DCSP DCSP return resp
DCSP seq _ lengths = { } DCNL DCSP raw _ seq _ lengths = { } DCNL DCSP final _ seq _ lengths = { } DCNL DCSP bc _ counts = defaultdict ( list ) DCNL DCSP curr _ ix = starting _ ix DCNL DCSP corr _ ct = 0 DCNL DCSP barcode _ length _ order = sorted ( set ( &#91; len ( bc.split ( &apos; , &apos; ) &#91; 0 &#93; ) for bc in valid _ map &#93; ) ) DCNL DCSP barcode _ length _ order = barcode _ length _ order &#91; : : ( -1 ) &#93; DCNL DCSP primer _ mismatch _ count = 0 DCNL DCSP all _ primers _ lens = sorted ( set ( all _ primers.values ( ) ) ) DCNL DCSP reverse _ primer _ not _ found = 0 DCNL DCSP sliding _ window _ failed = 0 DCNL DCSP trunc _ ambi _ base _ counts = 0 DCNL DCSP below _ seq _ min _ after _ trunc = 0 DCNL DCSP below _ seq _ min _ after _ ambi _ trunc = 0 DCNL DCSP for fasta _ in in fasta _ files : DCNL DCSP DCSP for ( curr _ id , curr _ seq ) in parse _ fasta ( fasta _ in ) : DCNL DCSP DCSP DCSP curr _ rid = curr _ id.split ( ) &#91; 0 &#93; DCNL DCSP DCSP DCSP curr _ seq = upper ( curr _ seq ) DCNL DCSP DCSP DCSP curr _ len = len ( curr _ seq ) DCNL DCSP DCSP DCSP curr _ qual = qual _ mappings.get ( curr _ rid , None ) DCNL DCSP DCSP DCSP seq _ lengths &#91; curr _ rid &#93; = curr _ len DCNL DCSP DCSP DCSP failed = False DCNL DCSP DCSP DCSP for f in filters : DCNL DCSP DCSP DCSP DCSP failed = ( failed or f ( curr _ rid , curr _ seq , curr _ qual ) ) DCNL DCSP DCSP DCSP if failed : DCNL DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( barcode _ type = = &apos; variable _ length &apos; ) : DCNL DCSP DCSP DCSP DCSP ( raw _ barcode , raw _ seq , barcode _ len ) = ( None , None , None ) DCNL DCSP DCSP DCSP DCSP curr _ valid _ map = &#91; curr _ bc.split ( &apos; , &apos; ) &#91; 0 &#93; for curr _ bc in valid _ map &#93; DCNL DCSP DCSP DCSP DCSP for l in barcode _ length _ order : DCNL DCSP DCSP DCSP DCSP DCSP ( bc , seq ) = get _ barcode ( curr _ seq , l ) DCNL DCSP DCSP DCSP DCSP DCSP if ( bc in curr _ valid _ map ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( raw _ barcode , raw _ seq ) = ( bc , seq ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP barcode _ len = len ( raw _ barcode ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP if ( not raw _ barcode ) : DCNL DCSP DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ( raw _ barcode , raw _ seq ) = get _ barcode ( curr _ seq , barcode _ len ) DCNL DCSP DCSP DCSP if ( not disable _ primer _ check ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP current _ primers = primer _ seqs _ lens &#91; raw _ barcode &#93; DCNL DCSP DCSP DCSP DCSP DCSP primer _ len = current _ primers.values ( ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP DCSP if primer _ exceeds _ mismatches ( raw _ seq &#91; : primer _ len &#93; , current _ primers , max _ primer _ mm ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP primer _ mismatch _ count + = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP current _ primers = all _ primers DCNL DCSP DCSP DCSP DCSP DCSP found _ match = False DCNL DCSP DCSP DCSP DCSP DCSP for seq _ slice _ len in all _ primers _ lens : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not primer _ exceeds _ mismatches ( raw _ seq &#91; : seq _ slice _ len &#93; , current _ primers , max _ primer _ mm ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP primer _ len = seq _ slice _ len DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP found _ match = True DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP if ( not found _ match ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP primer _ mismatch _ count + = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP DCSP DCSP raise IndexError ( ( ( &apos; Error DCSP reading DCSP primer DCSP sequences . DCSP DCSP If DCSP &apos; + &apos; primers DCSP were DCSP purposefully DCSP not DCSP included DCSP in DCSP the DCSP mapping DCSP &apos; ) + &apos; file , DCSP disable DCSP usage DCSP with DCSP the DCSP -p DCSP option . &apos; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP primer _ len = 0 DCNL DCSP DCSP DCSP ( cbc , cpr , cres ) = split _ seq ( curr _ seq , barcode _ len , primer _ len ) DCNL DCSP DCSP DCSP total _ bc _ primer _ len = ( len ( cbc ) + len ( cpr ) ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( bc _ diffs , curr _ bc , corrected _ bc ) = check _ barcode ( cbc , barcode _ type , valid _ map.keys ( ) , attempt _ bc _ correction , added _ demultiplex _ field , curr _ id ) DCNL DCSP DCSP DCSP DCSP if ( bc _ diffs &gt; max _ bc _ errors ) : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( &apos; Too DCSP many DCSP errors DCSP in DCSP barcode &apos; ) DCNL DCSP DCSP DCSP DCSP corr _ ct + = bool ( corrected _ bc ) DCNL DCSP DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP DCSP bc _ counts &#91; None &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP curr _ samp _ id = valid _ map.get ( curr _ bc , &apos; Unassigned &apos; ) DCNL DCSP DCSP DCSP new _ id = ( &apos; % s _ % d &apos; % ( curr _ samp _ id , curr _ ix ) ) DCNL DCSP DCSP DCSP write _ seq = cres DCNL DCSP DCSP DCSP if ( reverse _ primers = = &apos; truncate _ only &apos; ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer = rev _ primers &#91; curr _ bc &#93; DCNL DCSP DCSP DCSP DCSP DCSP mm _ tested = { } DCNL DCSP DCSP DCSP DCSP DCSP for curr _ rev _ primer in rev _ primer : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( rev _ primer _ mm , rev _ primer _ index ) = local _ align _ primer _ seq ( curr _ rev _ primer , cres ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP mm _ tested &#91; rev _ primer _ mm &#93; = rev _ primer _ index DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer _ mm = min ( mm _ tested.keys ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer _ index = mm _ tested &#91; rev _ primer _ mm &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( rev _ primer _ mm &lt; = reverse _ primer _ mismatches ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = write _ seq &#91; 0 : rev _ primer _ index &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP curr _ qual = curr _ qual &#91; 0 : ( ( barcode _ len + primer _ len ) + rev _ primer _ index ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP reverse _ primer _ not _ found + = 1 DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP elif ( reverse _ primers = = &apos; truncate _ remove &apos; ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer = rev _ primers &#91; curr _ bc &#93; DCNL DCSP DCSP DCSP DCSP DCSP mm _ tested = { } DCNL DCSP DCSP DCSP DCSP DCSP for curr _ rev _ primer in rev _ primer : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( rev _ primer _ mm , rev _ primer _ index ) = local _ align _ primer _ seq ( curr _ rev _ primer , cres ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP mm _ tested &#91; rev _ primer _ mm &#93; = rev _ primer _ index DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer _ mm = min ( mm _ tested.keys ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP rev _ primer _ index = mm _ tested &#91; rev _ primer _ mm &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( rev _ primer _ mm &lt; = reverse _ primer _ mismatches ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = write _ seq &#91; 0 : rev _ primer _ index &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP curr _ qual = curr _ qual &#91; 0 : ( ( barcode _ len + primer _ len ) + rev _ primer _ index ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP reverse _ primer _ not _ found + = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = False DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if qual _ score _ window : DCNL DCSP DCSP DCSP DCSP ( passed _ window _ check , window _ index ) = check _ window _ qual _ scores ( curr _ qual , qual _ score _ window , min _ qual _ score ) DCNL DCSP DCSP DCSP DCSP if ( discard _ bad _ windows and ( not passed _ window _ check ) ) : DCNL DCSP DCSP DCSP DCSP DCSP sliding _ window _ failed + = 1 DCNL DCSP DCSP DCSP DCSP DCSP write _ seq = False DCNL DCSP DCSP DCSP DCSP elif ( ( not discard _ bad _ windows ) and ( not passed _ window _ check ) ) : DCNL DCSP DCSP DCSP DCSP DCSP sliding _ window _ failed + = 1 DCNL DCSP DCSP DCSP DCSP DCSP if write _ seq : DCNL DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = write _ seq &#91; 0 : window _ index &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP curr _ qual = curr _ qual &#91; 0 : ( ( barcode _ len + primer _ len ) + window _ index ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( ( len ( write _ seq ) + total _ bc _ primer _ len ) &lt; min _ seq _ len ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP below _ seq _ min _ after _ trunc + = 1 DCNL DCSP DCSP DCSP if ( truncate _ ambi _ bases and write _ seq ) : DCNL DCSP DCSP DCSP DCSP write _ seq _ ambi _ ix = True DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP ambi _ ix = write _ seq.index ( &apos; N &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP write _ seq = write _ seq &#91; 0 : ambi _ ix &#93; DCNL DCSP DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP DCSP write _ seq _ ambi _ ix = False DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP DCSP if write _ seq _ ambi _ ix : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( len ( write _ seq ) + total _ bc _ primer _ len ) &lt; min _ seq _ len ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP write _ seq = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP below _ seq _ min _ after _ ambi _ trunc + = 1 DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP trunc _ ambi _ base _ counts + = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP curr _ qual = curr _ qual &#91; 0 : ( ( barcode _ len + primer _ len ) + ambi _ ix ) &#93; DCNL DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP ( qual _ barcode , qual _ primer , qual _ scores _ out ) = split _ seq ( curr _ qual , barcode _ len , primer _ len ) DCNL DCSP DCSP DCSP DCSP qual _ barcode = format _ qual _ output ( qual _ barcode ) DCNL DCSP DCSP DCSP DCSP qual _ primer = format _ qual _ output ( qual _ primer ) DCNL DCSP DCSP DCSP DCSP qual _ scores _ out = format _ qual _ output ( qual _ scores _ out ) DCNL DCSP DCSP DCSP if ( not write _ seq ) : DCNL DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if keep _ primer : DCNL DCSP DCSP DCSP DCSP write _ seq = ( cpr + write _ seq ) DCNL DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP qual _ scores _ out = ( qual _ primer + qual _ scores _ out ) DCNL DCSP DCSP DCSP if keep _ barcode : DCNL DCSP DCSP DCSP DCSP write _ seq = ( cbc + write _ seq ) DCNL DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP qual _ scores _ out = ( qual _ barcode + qual _ scores _ out ) DCNL DCSP DCSP DCSP bc _ counts &#91; curr _ bc &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP if ( retain _ unassigned _ reads and ( curr _ samp _ id = = &apos; Unassigned &apos; ) ) : DCNL DCSP DCSP DCSP DCSP fasta _ out.write ( ( &apos; &gt; % s DCSP % s DCSP orig _ bc = % s DCSP new _ bc = % s DCSP bc _ diffs = % s \ n % s \ n &apos; % ( new _ id , curr _ rid , cbc , curr _ bc , int ( bc _ diffs ) , write _ seq ) ) ) DCNL DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP qual _ out.write ( ( &apos; &gt; % s DCSP % s DCSP orig _ bc = % s DCSP new _ bc = % s DCSP bc _ diffs = % s \ n % s &apos; % ( new _ id , curr _ rid , cbc , curr _ bc , int ( bc _ diffs ) , qual _ scores _ out ) ) ) DCNL DCSP DCSP DCSP elif ( ( not retain _ unassigned _ reads ) and ( curr _ samp _ id = = &apos; Unassigned &apos; ) ) : DCNL DCSP DCSP DCSP DCSP bc _ counts &#91; &apos; # FAILED &apos; &#93; .append ( curr _ rid ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP fasta _ out.write ( ( &apos; &gt; % s DCSP % s DCSP orig _ bc = % s DCSP new _ bc = % s DCSP bc _ diffs = % s \ n % s \ n &apos; % ( new _ id , curr _ rid , cbc , curr _ bc , int ( bc _ diffs ) , write _ seq ) ) ) DCNL DCSP DCSP DCSP DCSP if qual _ out : DCNL DCSP DCSP DCSP DCSP DCSP qual _ out.write ( ( &apos; &gt; % s DCSP % s DCSP orig _ bc = % s DCSP new _ bc = % s DCSP bc _ diffs = % s \ n % s &apos; % ( new _ id , curr _ rid , cbc , curr _ bc , int ( bc _ diffs ) , qual _ scores _ out ) ) ) DCNL DCSP DCSP DCSP curr _ len = len ( write _ seq ) DCNL DCSP DCSP DCSP curr _ ix + = 1 DCNL DCSP DCSP DCSP raw _ seq _ lengths &#91; curr _ rid &#93; = len ( curr _ seq ) DCNL DCSP DCSP DCSP final _ seq _ lengths &#91; curr _ id &#93; = curr _ len DCNL DCSP if median _ length _ filtering : DCNL DCSP DCSP fasta _ out.close ( ) DCNL DCSP DCSP fasta _ out = open ( fasta _ out.name , &apos; U &apos; ) DCNL DCSP DCSP sequence _ lens = &#91; &#93; DCNL DCSP DCSP for ( label , seq ) in parse _ fasta ( fasta _ out ) : DCNL DCSP DCSP DCSP sequence _ lens.append ( len ( seq ) ) DCNL DCSP DCSP &apos; # DCSP Create DCSP a DCSP temporary DCSP file DCSP to DCSP copy DCSP the DCSP contents DCSP of DCSP the DCSP fasta DCSP file , DCSP will \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP need DCSP to DCSP delete DCSP once DCSP operations DCSP complete . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ temp DCSP = DCSP open ( fasta _ out.name DCSP + DCSP &quot; _ tmp.fasta &quot; , DCSP &quot; w &quot; ) \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP sequence _ lens DCSP = DCSP &#91; &#93; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP for DCSP label , DCSP seq DCSP in DCSP parse _ fasta ( fasta _ lens ) : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP sequence _ lens.append ( len ( seq ) ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ temp.write ( &quot; &gt; % s \ n % s \ n &quot; DCSP % DCSP ( label , DCSP seq ) ) \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ temp.close ( ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ temp DCSP = DCSP open ( fasta _ out.name DCSP + DCSP &quot; _ tmp.fasta &quot; , DCSP &quot; U &quot; ) \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ lens.close ( ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP Overwrite DCSP seqs.fna DCSP with DCSP length DCSP filtered DCSP data \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP fasta _ out DCSP = DCSP open ( fasta _ out.name , DCSP &quot; w &quot; ) &apos; DCNL DCSP DCSP ( med _ abs _ dev , med _ length ) = median _ absolute _ deviation ( sequence _ lens ) DCNL DCSP DCSP min _ corrected _ len = ( med _ length - ( med _ abs _ dev * float ( median _ length _ filtering ) ) ) DCNL DCSP DCSP max _ corrected _ len = ( med _ length + ( med _ abs _ dev * float ( median _ length _ filtering ) ) ) DCNL DCSP DCSP seqs _ discarded _ median = 0 DCNL DCSP DCSP fasta _ out.seek ( 0 ) DCNL DCSP DCSP final _ written _ lens = &#91; &#93; DCNL DCSP DCSP final _ fasta _ out = open ( fasta _ out.name.replace ( &apos; .tmp &apos; , &apos; &apos; ) , &apos; w &apos; ) DCNL DCSP DCSP for ( label , seq ) in parse _ fasta ( fasta _ out ) : DCNL DCSP DCSP DCSP curr _ len = len ( seq ) DCNL DCSP DCSP DCSP if ( ( curr _ len &lt; min _ corrected _ len ) or ( curr _ len &gt; max _ corrected _ len ) ) : DCNL DCSP DCSP DCSP DCSP seqs _ discarded _ median + = 1 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP final _ fasta _ out.write ( ( &apos; &gt; % s \ n % s \ n &apos; % ( label , seq ) ) ) DCNL DCSP DCSP DCSP DCSP final _ written _ lens.append ( len ( seq ) ) DCNL DCSP DCSP final _ fasta _ out.close ( ) DCNL DCSP DCSP fasta _ out.close ( ) DCNL DCSP DCSP remove _ files ( &#91; fasta _ out.name &#93; ) DCNL DCSP else : DCNL DCSP DCSP min _ corrected _ len = 0 DCNL DCSP DCSP max _ corrected _ len = 0 DCNL DCSP DCSP seqs _ discarded _ median = 0 DCNL DCSP DCSP final _ written _ lens = 0 DCNL DCSP DCSP fasta _ out.close ( ) DCNL DCSP DCSP fasta _ out = open ( fasta _ out.name , &apos; U &apos; ) DCNL DCSP DCSP final _ fasta _ out = open ( fasta _ out.name.replace ( &apos; .tmp &apos; , &apos; &apos; ) , &apos; w &apos; ) DCNL DCSP DCSP for ( label , seq ) in parse _ fasta ( fasta _ out ) : DCNL DCSP DCSP DCSP final _ fasta _ out.write ( ( &apos; &gt; % s \ n % s \ n &apos; % ( label , seq ) ) ) DCNL DCSP DCSP final _ fasta _ out.close ( ) DCNL DCSP DCSP fasta _ out.close ( ) DCNL DCSP DCSP remove _ files ( &#91; fasta _ out.name &#93; ) DCNL DCSP median _ results = ( median _ length _ filtering , min _ corrected _ len , max _ corrected _ len , seqs _ discarded _ median , final _ written _ lens ) DCNL DCSP raw _ seq _ lengths = raw _ seq _ lengths.values ( ) DCNL DCSP final _ seq _ lengths = final _ seq _ lengths.values ( ) DCNL DCSP log _ out = format _ log ( bc _ counts , corr _ ct , valid _ map , seq _ lengths , filters , retain _ unassigned _ reads , attempt _ bc _ correction , primer _ mismatch _ count , max _ primer _ mm , reverse _ primers , reverse _ primer _ not _ found , sliding _ window _ failed , below _ seq _ min _ after _ trunc , qual _ score _ window , discard _ bad _ windows , min _ seq _ len , raw _ seq _ lengths , final _ seq _ lengths , median _ results , truncate _ ambi _ bases , below _ seq _ min _ after _ ambi _ trunc ) DCNL DCSP return ( log _ out , seq _ lengths.values ( ) , raw _ seq _ lengths , final _ seq _ lengths )
DCSP global _ products DCNL DCSP _ products = &#91; &#93; DCNL DCSP os.chdir ( str ( tmpdir ) ) DCNL DCSP wf = pe.Workflow ( name = u &apos;test &apos; ) DCNL DCSP inputspec = pe.Node ( IdentityInterface ( fields = &#91; u &apos;m &apos; , u &apos;n &apos; &#93; ) , name = u &apos;inputspec &apos; ) DCNL DCSP inputspec.iterables = &#91; ( u &apos;m &apos; , &#91; 1 , 2 &#93; ) , ( u &apos;n &apos; , &#91; 3 , 4 &#93; ) &#93; DCNL DCSP inputspec.synchronize = True DCNL DCSP inc1 = pe.Node ( IncrementInterface ( ) , name = u &apos;inc1 &apos; ) DCNL DCSP wf.connect ( inputspec , u &apos;m &apos; , inc1 , u &apos;input1 &apos; ) DCNL DCSP inc2 = pe.Node ( IncrementInterface ( ) , name = u &apos;inc2 &apos; ) DCNL DCSP wf.connect ( inputspec , u &apos;n &apos; , inc2 , u &apos;input1 &apos; ) DCNL DCSP join = pe.JoinNode ( IdentityInterface ( fields = &#91; u &apos;vector1 &apos; , u &apos;vector2 &apos; &#93; ) , joinsource = u &apos;inputspec &apos; , name = u &apos;join &apos; ) DCNL DCSP wf.connect ( inc1 , u &apos;output1 &apos; , join , u &apos;vector1 &apos; ) DCNL DCSP wf.connect ( inc2 , u &apos;output1 &apos; , join , u &apos;vector2 &apos; ) DCNL DCSP prod = pe.MapNode ( ProductInterface ( ) , name = u &apos;prod &apos; , iterfield = &#91; u &apos;input1 &apos; , u &apos;input2 &apos; &#93; ) DCNL DCSP wf.connect ( join , u &apos;vector1 &apos; , prod , u &apos;input1 &apos; ) DCNL DCSP wf.connect ( join , u &apos;vector2 &apos; , prod , u &apos;input2 &apos; ) DCNL DCSP result = wf.run ( ) DCNL DCSP assert ( len ( result.nodes ( ) ) = = 6 ) , u &apos;The DCSP number DCSP of DCSP expanded DCSP nodes DCSP is DCSP incorrect . &apos; DCNL DCSP assert ( _ products = = &#91; 8 , 15 &#93; ) , ( u &apos;The DCSP post-join DCSP products DCSP is DCSP incorrect : DCSP % s . &apos; % _ products )
DCSP seen = { } DCNL DCSP result = &#91; &#93; DCNL DCSP for item in list _ : DCNL DCSP DCSP seenkey = key ( item ) DCNL DCSP DCSP if ( seenkey in seen ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP seen &#91; seenkey &#93; = 1 DCNL DCSP DCSP result.append ( item ) DCNL DCSP return result
DCSP interfaces _ groups = machinesmgr.queryAllInterfaces ( 0 , &apos; WebConsole &apos; ) DCNL DCSP targetIP = request.GET.get ( &apos; target &apos; , None ) DCNL DCSP kbeComps = &#91; &#93; DCNL DCSP for ( mID , comps ) in interfaces _ groups.items ( ) : DCNL DCSP DCSP if ( ( len ( comps ) &gt; 1 ) and ( comps &#91; 0 &#93; .intaddr = = targetIP ) ) : DCNL DCSP DCSP DCSP kbeComps = comps &#91; 1 : &#93; DCNL DCSP DCSP DCSP break DCNL DCSP kbeMachines = machinesmgr.queryMachines ( ) DCNL DCSP kbeMachines.sort ( key = ( lambda info : info.intaddr ) ) DCNL DCSP context = { &apos; KBEMachines &apos; : kbeMachines , &apos; KBEComps &apos; : kbeComps } DCNL DCSP return render ( request , &apos; WebConsole / machines _ show _ all.html &apos; , context )
DCSP ( yield type ( &apos; Tunnelled &apos; , ( object , ) , { } ) )
DCSP map _ acls _ mode = False DCNL DCSP afp _ config = &apos; / usr / local / etc / afp.conf &apos; DCNL DCSP cf _ contents = &#91; &#93; DCNL DCSP client = Client ( ) DCNL DCSP afp = Struct ( client.call ( &apos; datastore.query &apos; , &apos; services.afp &apos; , None , { &apos; get &apos; : True } ) ) DCNL DCSP cf _ contents.append ( &apos; &#91; Global &#93; \ n &apos; ) DCNL DCSP uam _ list = &#91; &apos; uams _ dhx.so &apos; , &apos; uams _ dhx2.so &apos; &#93; DCNL DCSP if afp.afp _ srv _ guest : DCNL DCSP DCSP uam _ list.append ( &apos; uams _ guest.so &apos; ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB guest DCSP account DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ guest _ user ) ) DCNL DCSP if ( client.call ( &apos; datastore.query &apos; , &apos; directoryservice.kerberoskeytab &apos; , None , { &apos; count &apos; : True } ) &gt; 0 ) : DCNL DCSP DCSP uam _ list.append ( &apos; uams _ gss.so &apos; ) DCNL DCSP cf _ contents.append ( ( &apos; DCTB uam DCSP list DCSP = DCSP % s \ n &apos; % &apos; DCSP &apos; .join ( uam _ list ) ) ) DCNL DCSP if afp.afp _ srv _ bindip : DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB afp DCSP listen DCSP = DCSP % s \ n &apos; % &apos; DCSP &apos; .join ( afp.afp _ srv _ bindip ) ) ) DCNL DCSP cf _ contents.append ( ( &apos; DCTB max DCSP connections DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ connections _ limit ) ) DCNL DCSP cf _ contents.append ( &apos; DCTB mimic DCSP model DCSP = DCSP RackMac \ n &apos; ) DCNL DCSP if afp.afp _ srv _ dbpath : DCNL DCSP DCSP cf _ contents.append ( &apos; DCTB vol DCSP dbnest DCSP = DCSP no \ n &apos; ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB vol DCSP dbpath DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ dbpath ) ) DCNL DCSP else : DCNL DCSP DCSP cf _ contents.append ( &apos; DCTB vol DCSP dbnest DCSP = DCSP yes \ n &apos; ) DCNL DCSP if afp.afp _ srv _ global _ aux : DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB % s \ n &apos; % afp.afp _ srv _ global _ aux.encode ( &apos; utf8 &apos; ) ) ) DCNL DCSP if afp.afp _ srv _ map _ acls : DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB map DCSP acls DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ map _ acls ) ) DCNL DCSP if ( ( afp.afp _ srv _ map _ acls = = &apos; mode &apos; ) and client.call ( &apos; notifier.common &apos; , &apos; system &apos; , &apos; activedirectory _ enabled &apos; ) ) : DCNL DCSP DCSP map _ acls _ mode = True DCNL DCSP if map _ acls _ mode : DCNL DCSP DCSP ad = Struct ( client.call ( &apos; notifier.directoryservice &apos; , &apos; AD &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP auth DCSP method DCSP = DCSP % s \ n &apos; % &apos; simple &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP auth DCSP dn DCSP = DCSP % s \ n &apos; % ad.binddn ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP auth DCSP pw DCSP = DCSP % s \ n &apos; % ad.bindpw ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP server DCSP = DCSP % s \ n &apos; % ad.domainname ) ) DCNL DCSP DCSP if ad.userdn : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP userbase DCSP = DCSP % s \ n &apos; % ad.userdn ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP userscope DCSP = DCSP % s \ n &apos; % &apos; sub &apos; ) ) DCNL DCSP DCSP if ad.groupdn : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP groupbase DCSP = DCSP % s \ n &apos; % ad.groupdn ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP groupscope DCSP = DCSP % s \ n &apos; % &apos; sub &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP user DCSP filter DCSP = DCSP % s \ n &apos; % &apos; objectclass = user &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP group DCSP filter DCSP = DCSP % s \ n &apos; % &apos; objectclass = group &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP uuid DCSP attr DCSP = DCSP % s \ n &apos; % &apos; objectGUID &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP uuid DCSP encoding DCSP = DCSP % s \ n &apos; % &apos; ms-guid &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP name DCSP attr DCSP = DCSP % s \ n &apos; % &apos; sAMAccountName &apos; ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB ldap DCSP group DCSP attr DCSP = DCSP % s \ n &apos; % &apos; sAMAccountName &apos; ) ) DCNL DCSP cf _ contents.append ( &apos; \ n &apos; ) DCNL DCSP if afp.afp _ srv _ homedir _ enable : DCNL DCSP DCSP cf _ contents.append ( &apos; &#91; Homes &#93; \ n &apos; ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB basedir DCSP regex DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ homedir ) ) DCNL DCSP DCSP if afp.afp _ srv _ homename : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB home DCSP name DCSP = DCSP % s \ n &apos; % afp.afp _ srv _ homename ) ) DCNL DCSP DCSP cf _ contents.append ( &apos; \ n &apos; ) DCNL DCSP for share in client.call ( &apos; datastore.query &apos; , &apos; sharing.afp _ share &apos; ) : DCNL DCSP DCSP share = Struct ( share ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; &#91; % s &#93; \ n &apos; % share.afp _ name ) ) DCNL DCSP DCSP cf _ contents.append ( ( &apos; DCTB path DCSP = DCSP % s \ n &apos; % share.afp _ path ) ) DCNL DCSP DCSP if share.afp _ allow : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB valid DCSP users DCSP = DCSP % s \ n &apos; % share.afp _ allow ) ) DCNL DCSP DCSP if share.afp _ deny : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB invalid DCSP users DCSP = DCSP % s \ n &apos; % share.afp _ deny ) ) DCNL DCSP DCSP if share.afp _ hostsallow : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB hosts DCSP allow DCSP = DCSP % s \ n &apos; % share.afp _ hostsallow ) ) DCNL DCSP DCSP if share.afp _ hostsdeny : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB hosts DCSP deny DCSP = DCSP % s \ n &apos; % share.afp _ hostsdeny ) ) DCNL DCSP DCSP if share.afp _ ro : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB rolist DCSP = DCSP % s \ n &apos; % share.afp _ ro ) ) DCNL DCSP DCSP if share.afp _ rw : DCNL DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB rwlist DCSP = DCSP % s \ n &apos; % share.afp _ rw ) ) DCNL DCSP DCSP if share.afp _ timemachine : DCNL DCSP DCSP DCSP cf _ contents.append ( &apos; DCTB time DCSP machine DCSP = DCSP yes \ n &apos; ) DCNL DCSP DCSP if ( not share.afp _ nodev ) : DCNL DCSP DCSP DCSP cf _ contents.append ( &apos; DCTB cnid DCSP dev DCSP = DCSP no \ n &apos; ) DCNL DCSP DCSP if share.afp _ nostat : DCNL DCSP DCSP DCSP cf _ contents.append ( &apos; DCTB stat DCSP vol DCSP = DCSP no \ n &apos; ) DCNL DCSP DCSP if ( not share.afp _ upriv ) : DCNL DCSP DCSP DCSP cf _ contents.append ( &apos; DCTB unix DCSP priv DCSP = DCSP no \ n &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( share.afp _ fperm and ( not map _ acls _ mode ) ) : DCNL DCSP DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB file DCSP perm DCSP = DCSP % s \ n &apos; % share.afp _ fperm ) ) DCNL DCSP DCSP DCSP if ( share.afp _ dperm and ( not map _ acls _ mode ) ) : DCNL DCSP DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB directory DCSP perm DCSP = DCSP % s \ n &apos; % share.afp _ dperm ) ) DCNL DCSP DCSP DCSP if ( share.afp _ umask and ( not map _ acls _ mode ) ) : DCNL DCSP DCSP DCSP DCSP cf _ contents.append ( ( &apos; DCTB umask DCSP = DCSP % s \ n &apos; % share.afp _ umask ) ) DCNL DCSP DCSP cf _ contents.append ( &apos; DCTB veto DCSP files DCSP = DCSP .windows / .mac / \ n &apos; ) DCNL DCSP DCSP if map _ acls _ mode : DCNL DCSP DCSP DCSP cf _ contents.append ( &apos; DCTB acls DCSP = DCSP yes \ n &apos; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP aux _ params = &#91; &apos; DCTB { 0 } \ n &apos; .format ( p.encode ( &apos; utf8 &apos; ) ) for p in share.afp _ auxparams.split ( &apos; \ n &apos; ) &#93; DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cf _ contents + = aux _ params DCNL DCSP with open ( afp _ config , &apos; w &apos; ) as fh : DCNL DCSP DCSP for line in cf _ contents : DCNL DCSP DCSP DCSP fh.write ( line )
DCSP mods = &#91; &#93; DCNL DCSP mod = import _ module ( path ) DCNL DCSP mods.append ( mod ) DCNL DCSP if hasattr ( mod , &apos; _ _ path _ _ &apos; ) : DCNL DCSP DCSP for ( _ , subpath , ispkg ) in iter _ modules ( mod . _ _ path _ _ ) : DCNL DCSP DCSP DCSP fullpath = ( ( path + &apos; .&apos; ) + subpath ) DCNL DCSP DCSP DCSP if ispkg : DCNL DCSP DCSP DCSP DCSP mods + = walk _ modules ( fullpath ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP submod = import _ module ( fullpath ) DCNL DCSP DCSP DCSP DCSP mods.append ( submod ) DCNL DCSP return mods
DCSP g = np.zeros _ like ( prices ) DCNL DCSP g &#91; 1 : &#93; = ( ( prices &#91; 1 : &#93; - prices &#91; : ( -1 ) &#93; ) / prices &#91; : ( -1 ) &#93; ) DCNL DCSP return g
DCSP queue = &#91; course &#93; DCNL DCSP while ( len ( queue ) &gt; 0 ) : DCNL DCSP DCSP node = queue.pop ( ) DCNL DCSP DCSP queue.extend ( node.get _ children ( ) ) DCNL DCSP return True
DCSP return colorize ( text , &apos; green &apos; , attrib )
DCSP group = get _ object _ or _ 404 ( Group , slug = slug , is _ active = True ) DCNL DCSP topic = get _ object _ or _ 404 ( GroupTopic , pk = topic _ id , is _ active = True ) DCNL DCSP message _ form = GroupMessageForm ( ) DCNL DCSP return render ( request , template _ name , { &apos; group &apos; : group , &apos; topic &apos; : topic , &apos; message _ form &apos; : message _ form } )
DCSP cleanup _ dirs ( ( ctx.clean _ all.directories or &#91; &#93; ) , dry _ run = dry _ run ) DCNL DCSP cleanup _ dirs ( ( ctx.clean _ all.extra _ directories or &#91; &#93; ) , dry _ run = dry _ run ) DCNL DCSP cleanup _ files ( ( ctx.clean _ all.files or &#91; &#93; ) , dry _ run = dry _ run ) DCNL DCSP cleanup _ files ( ( ctx.clean _ all.extra _ files or &#91; &#93; ) , dry _ run = dry _ run ) DCNL DCSP execute _ cleanup _ tasks ( ctx , cleanup _ all _ tasks , dry _ run = dry _ run ) DCNL DCSP clean ( ctx , dry _ run = dry _ run )
DCSP headers = response.get _ headers ( ) DCNL DCSP for header _ name in headers : DCNL DCSP DCSP if ( header _ name.upper ( ) .strip ( ) = = key.upper ( ) ) : DCNL DCSP DCSP DCSP return headers &#91; header _ name &#93; .strip ( ) DCNL DCSP return None
DCSP file = request.FILES &#91; &apos; file _ field &apos; &#93; DCNL DCSP obj = FileModel ( ) DCNL DCSP obj.testfile.save ( file.name , file ) DCNL DCSP return HttpResponse ( ( &apos; % d &apos; % obj.pk ) )
DCSP plugin = None DCNL DCSP for x in all _ metadata _ plugins ( ) : DCNL DCSP DCSP if ( ( x.name = = name ) and ( u &apos;identify &apos; in x.capabilities ) ) : DCNL DCSP DCSP DCSP plugin = x DCNL DCSP DCSP DCSP break DCNL DCSP modify _ plugin ( plugin ) DCNL DCSP prints ( u &apos;Testing DCSP the DCSP identify DCSP function DCSP of &apos; , plugin.name ) DCNL DCSP prints ( u &apos;Using DCSP extra DCSP headers : &apos; , plugin.browser.addheaders ) DCNL DCSP ( tdir , lf , log , abort ) = init _ test ( plugin.name ) DCNL DCSP prints ( u &apos;Log DCSP saved DCSP to &apos; , lf ) DCNL DCSP times = &#91; &#93; DCNL DCSP for ( kwargs , test _ funcs ) in tests : DCNL DCSP DCSP prints ( u &apos;Running DCSP test DCSP with : &apos; , kwargs ) DCNL DCSP DCSP rq = Queue ( ) DCNL DCSP DCSP args = ( log , rq , abort ) DCNL DCSP DCSP start _ time = time.time ( ) DCNL DCSP DCSP plugin.running _ a _ test = True DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP err = plugin.identify ( * args , * * kwargs ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP plugin.running _ a _ test = False DCNL DCSP DCSP total _ time = ( time.time ( ) - start _ time ) DCNL DCSP DCSP times.append ( total _ time ) DCNL DCSP DCSP if ( err is not None ) : DCNL DCSP DCSP DCSP prints ( u &apos;identify DCSP returned DCSP an DCSP error DCSP for DCSP args &apos; , args ) DCNL DCSP DCSP DCSP prints ( err ) DCNL DCSP DCSP DCSP break DCNL DCSP DCSP results = &#91; &#93; DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP results.append ( rq.get _ nowait ( ) ) DCNL DCSP DCSP DCSP except Empty : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP prints ( u &apos;Found &apos; , len ( results ) , u &apos;matches : &apos; , end = u &apos; DCSP &apos; ) DCNL DCSP DCSP prints ( u &apos;Smaller DCSP relevance DCSP means DCSP better DCSP match &apos; ) DCNL DCSP DCSP results.sort ( key = plugin.identify _ results _ keygen ( title = kwargs.get ( u &apos;title &apos; , None ) , authors = kwargs.get ( u &apos;authors &apos; , None ) , identifiers = kwargs.get ( u &apos;identifiers &apos; , { } ) ) ) DCNL DCSP DCSP for ( i , mi ) in enumerate ( results ) : DCNL DCSP DCSP DCSP prints ( ( u &apos; * &apos; * 30 ) , u &apos;Relevance : &apos; , i , ( u &apos; * &apos; * 30 ) ) DCNL DCSP DCSP DCSP prints ( mi ) DCNL DCSP DCSP DCSP prints ( u &apos; \ nCached DCSP cover DCSP URL DCSP DCSP DCSP DCSP : &apos; , plugin.get _ cached _ cover _ url ( mi.identifiers ) ) DCNL DCSP DCSP DCSP prints ( ( u &apos; * &apos; * 75 ) , u &apos; \ n \ n &apos; ) DCNL DCSP DCSP possibles = &#91; &#93; DCNL DCSP DCSP for mi in results : DCNL DCSP DCSP DCSP test _ failed = False DCNL DCSP DCSP DCSP for tfunc in test _ funcs : DCNL DCSP DCSP DCSP DCSP if ( not tfunc ( mi ) ) : DCNL DCSP DCSP DCSP DCSP DCSP test _ failed = True DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if ( not test _ failed ) : DCNL DCSP DCSP DCSP DCSP possibles.append ( mi ) DCNL DCSP DCSP if ( not possibles ) : DCNL DCSP DCSP DCSP prints ( u &apos;ERROR : DCSP No DCSP results DCSP that DCSP passed DCSP all DCSP tests DCSP were DCSP found &apos; ) DCNL DCSP DCSP DCSP prints ( u &apos;Log DCSP saved DCSP to &apos; , lf ) DCNL DCSP DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP DCSP good = &#91; x for x in possibles if ( plugin.test _ fields ( x ) is None ) &#93; DCNL DCSP DCSP if ( not good ) : DCNL DCSP DCSP DCSP prints ( u &apos;Failed DCSP to DCSP find &apos; , plugin.test _ fields ( possibles &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP if fail _ missing _ meta : DCNL DCSP DCSP DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP DCSP if ( results &#91; 0 &#93; is not possibles &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP prints ( u &apos;Most DCSP relevant DCSP result DCSP failed DCSP the DCSP tests &apos; ) DCNL DCSP DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP DCSP if ( u &apos;cover &apos; in plugin.capabilities ) : DCNL DCSP DCSP DCSP rq = Queue ( ) DCNL DCSP DCSP DCSP mi = results &#91; 0 &#93; DCNL DCSP DCSP DCSP plugin.download _ cover ( log , rq , abort , title = mi.title , authors = mi.authors , identifiers = mi.identifiers ) DCNL DCSP DCSP DCSP results = &#91; &#93; DCNL DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP results.append ( rq.get _ nowait ( ) ) DCNL DCSP DCSP DCSP DCSP except Empty : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if ( ( not results ) and fail _ missing _ meta ) : DCNL DCSP DCSP DCSP DCSP prints ( u &apos;Cover DCSP download DCSP failed &apos; ) DCNL DCSP DCSP DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP DCSP DCSP elif results : DCNL DCSP DCSP DCSP DCSP cdata = results &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP cover = os.path.join ( tdir , ( plugin.name.replace ( u &apos; DCSP &apos; , u &apos; &apos; ) + ( u &apos; - % s-cover.jpg &apos; % sanitize _ file _ name2 ( mi.title.replace ( u &apos; DCSP &apos; , u &apos; _ &apos; ) ) ) ) ) DCNL DCSP DCSP DCSP DCSP with open ( cover , u &apos;wb &apos; ) as f : DCNL DCSP DCSP DCSP DCSP DCSP f.write ( cdata &#91; ( -1 ) &#93; ) DCNL DCSP DCSP DCSP DCSP prints ( u &apos;Cover DCSP downloaded DCSP to : &apos; , cover ) DCNL DCSP DCSP DCSP DCSP if ( len ( cdata &#91; ( -1 ) &#93; ) &lt; 10240 ) : DCNL DCSP DCSP DCSP DCSP DCSP prints ( u &apos;Downloaded DCSP cover DCSP too DCSP small &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP prints ( u &apos;Average DCSP time DCSP per DCSP query &apos; , ( sum ( times ) / len ( times ) ) ) DCNL DCSP if ( os.stat ( lf ) .st _ size &gt; 10 ) : DCNL DCSP DCSP prints ( u &apos;There DCSP were DCSP some DCSP errors / warnings , DCSP see DCSP log &apos; , lf )
DCSP config _ lib.CONFIG.SetWriteBack ( &apos; temp.yaml &apos; ) DCNL DCSP try : DCNL DCSP DCSP log _ data = open ( config _ lib.CONFIG &#91; &apos; Installer.logfile &apos; &#93; , &apos; rb &apos; ) .read ( ) DCNL DCSP except ( IOError , OSError ) : DCNL DCSP DCSP log _ data = &apos; &apos; DCNL DCSP comms.CommsInit ( ) .RunOnce ( ) DCNL DCSP client = comms.GRRHTTPClient ( ca _ cert = config _ lib.CONFIG &#91; &apos; CA.certificate &apos; &#93; , private _ key = config _ lib.CONFIG.Get ( &apos; Client.private _ key &apos; ) ) DCNL DCSP client.client _ worker.SendReply ( session _ id = rdfvalue.FlowSessionID ( flow _ name = &apos; InstallationFailed &apos; ) , message _ type = rdf _ flows.GrrMessage.Type.STATUS , request _ id = 0 , response _ id = 0 , rdf _ value = rdf _ flows.GrrStatus ( status = rdf _ flows.GrrStatus.ReturnedStatus.GENERIC _ ERROR , error _ message = &apos; Installation DCSP failed . &apos; , backtrace = log _ data &#91; ( -10000 ) : &#93; ) ) DCNL DCSP client.RunOnce ( )
DCSP co = compile ( code.rstrip ( ) , &apos; &lt; string &gt; &apos; , &apos; single &apos; ) DCNL DCSP ns = { } DCNL DCSP eval ( co , globs , ns ) DCNL DCSP return ns &#91; name &#93;
DCSP x21 = ( p2 &#91; 0 &#93; - p1 &#91; 0 &#93; ) DCNL DCSP y21 = ( p2 &#91; 1 &#93; - p1 &#91; 1 &#93; ) DCNL DCSP x01 = ( np.asarray ( p0 &#91; 0 &#93; ) - p1 &#91; 0 &#93; ) DCNL DCSP y01 = ( np.asarray ( p0 &#91; 1 &#93; ) - p1 &#91; 1 &#93; ) DCNL DCSP u = ( ( ( x01 * x21 ) + ( y01 * y21 ) ) / float ( abs ( ( ( x21 * * 2 ) + ( y21 * * 2 ) ) ) ) ) DCNL DCSP u = np.clip ( u , 0 , 1 ) DCNL DCSP d = np.sqrt ( ( ( ( x01 - ( u * x21 ) ) * * 2 ) + ( ( y01 - ( u * y21 ) ) * * 2 ) ) ) DCNL DCSP return d
DCSP scanner = AsusWrtDeviceScanner ( config &#91; DOMAIN &#93; ) DCNL DCSP return ( scanner if scanner.success _ init else None )
DCSP if ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; RedHat &apos; ) : DCNL DCSP DCSP return &apos; / etc / nftables &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; Arch &apos; ) : DCNL DCSP DCSP return &apos; / etc / nftables &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; Debian &apos; ) : DCNL DCSP DCSP return &apos; / etc / nftables &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os &apos; &#93; = = &apos; Gentoo &apos; ) : DCNL DCSP DCSP return &apos; / etc / nftables &apos; DCNL DCSP else : DCNL DCSP DCSP return False
DCSP from sympy import exp , I DCNL DCSP F = integrate ( ( ( a * f ) * exp ( ( ( ( b * I ) * x ) * k ) ) ) , ( x , ( - oo ) , oo ) ) DCNL DCSP if ( not F.has ( Integral ) ) : DCNL DCSP DCSP return ( _ simplify ( F , simplify ) , True ) DCNL DCSP if ( not F.is _ Piecewise ) : DCNL DCSP DCSP raise IntegralTransformError ( name , f , &apos; could DCSP not DCSP compute DCSP integral &apos; ) DCNL DCSP ( F , cond ) = F.args &#91; 0 &#93; DCNL DCSP if F.has ( Integral ) : DCNL DCSP DCSP raise IntegralTransformError ( name , f , &apos; integral DCSP in DCSP unexpected DCSP form &apos; ) DCNL DCSP return ( _ simplify ( F , simplify ) , cond )
DCSP width = 7 DCNL DCSP fieldName = fieldInfo &#91; &apos; fieldName &apos; &#93; DCNL DCSP fieldType = fieldInfo &#91; &apos; fieldType &apos; &#93; DCNL DCSP encoderChoicesList = &#91; &#93; DCNL DCSP if ( fieldType in &#91; &apos; float &apos; , &apos; int &apos; &#93; ) : DCNL DCSP DCSP aggFunction = &apos; mean &apos; DCNL DCSP DCSP encoders = &#91; None &#93; DCNL DCSP DCSP for n in ( 13 , 50 , 150 , 500 ) : DCNL DCSP DCSP DCSP encoder = dict ( type = &apos; ScalarSpaceEncoder &apos; , name = fieldName , fieldname = fieldName , n = n , w = width , clipInput = True , space = &apos; absolute &apos; ) DCNL DCSP DCSP DCSP if ( &apos; minValue &apos; in fieldInfo ) : DCNL DCSP DCSP DCSP DCSP encoder &#91; &apos; minval &apos; &#93; = fieldInfo &#91; &apos; minValue &apos; &#93; DCNL DCSP DCSP DCSP if ( &apos; maxValue &apos; in fieldInfo ) : DCNL DCSP DCSP DCSP DCSP encoder &#91; &apos; maxval &apos; &#93; = fieldInfo &#91; &apos; maxValue &apos; &#93; DCNL DCSP DCSP DCSP encoders.append ( encoder ) DCNL DCSP DCSP encoderChoicesList.append ( encoders ) DCNL DCSP elif ( fieldType = = &apos; string &apos; ) : DCNL DCSP DCSP aggFunction = &apos; first &apos; DCNL DCSP DCSP encoders = &#91; None &#93; DCNL DCSP DCSP encoder = dict ( type = &apos; SDRCategoryEncoder &apos; , name = fieldName , fieldname = fieldName , n = 100 , w = width ) DCNL DCSP DCSP encoders.append ( encoder ) DCNL DCSP DCSP encoderChoicesList.append ( encoders ) DCNL DCSP elif ( fieldType = = &apos; datetime &apos; ) : DCNL DCSP DCSP aggFunction = &apos; first &apos; DCNL DCSP DCSP encoders = &#91; None &#93; DCNL DCSP DCSP for radius in ( 1 , 8 ) : DCNL DCSP DCSP DCSP encoder = dict ( type = &apos; DateEncoder &apos; , name = ( &apos; % s _ timeOfDay &apos; % fieldName ) , fieldname = fieldName , timeOfDay = ( width , radius ) ) DCNL DCSP DCSP DCSP encoders.append ( encoder ) DCNL DCSP DCSP encoderChoicesList.append ( encoders ) DCNL DCSP DCSP encoders = &#91; None &#93; DCNL DCSP DCSP for radius in ( 1 , 3 ) : DCNL DCSP DCSP DCSP encoder = dict ( type = &apos; DateEncoder &apos; , name = ( &apos; % s _ dayOfWeek &apos; % fieldName ) , fieldname = fieldName , dayOfWeek = ( width , radius ) ) DCNL DCSP DCSP DCSP encoders.append ( encoder ) DCNL DCSP DCSP encoderChoicesList.append ( encoders ) DCNL DCSP else : DCNL DCSP DCSP raise RuntimeError ( ( &quot; Unsupported DCSP field DCSP type DCSP &apos; % s &apos; &quot; % fieldType ) ) DCNL DCSP return ( encoderChoicesList , aggFunction )
DCSP return _ os _ dispatch ( &apos; addif &apos; , br , iface )
DCSP d = OrderedDict ( ) DCNL DCSP for i in range ( options &#91; &apos; n _ words &apos; &#93; ) : DCNL DCSP DCSP caption = &#91; i &#93; DCNL DCSP DCSP ff = f _ emb ( numpy.array ( caption ) .reshape ( 1 , 1 ) ) .flatten ( ) DCNL DCSP DCSP if use _ norm : DCNL DCSP DCSP DCSP ff / = norm ( ff ) DCNL DCSP DCSP d &#91; word _ idict &#91; i &#93; &#93; = ff DCNL DCSP return d
DCSP ( place , bcd ) = ( 0 , 0 ) DCNL DCSP while ( decimal &gt; 0 ) : DCNL DCSP DCSP nibble = ( decimal % 10 ) DCNL DCSP DCSP bcd + = ( nibble &lt; &lt; place ) DCNL DCSP DCSP decimal / = 10 DCNL DCSP DCSP place + = 4 DCNL DCSP return bcd
DCSP timeout = kwargs.get ( &apos; timeout &apos; , None ) DCNL DCSP if ( timeout is None ) : DCNL DCSP DCSP expires = None DCNL DCSP DCSP recalc _ timeout = False DCNL DCSP else : DCNL DCSP DCSP timeout = float ( timeout ) DCNL DCSP DCSP if ( timeout &lt; 0.0 ) : DCNL DCSP DCSP DCSP expires = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP expires = ( monotonic ( ) + timeout ) DCNL DCSP args = list ( args ) DCNL DCSP if ( recalc _ timeout and ( &apos; timeout &apos; not in kwargs ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Timeout DCSP must DCSP be DCSP in DCSP args DCSP or DCSP kwargs DCSP to DCSP be DCSP recalculated &apos; ) DCNL DCSP result = _ SYSCALL _ SENTINEL DCNL DCSP while ( result is _ SYSCALL _ SENTINEL ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP result = func ( * args , * * kwargs ) DCNL DCSP DCSP except ( OSError , IOError , select.error ) as e : DCNL DCSP DCSP DCSP errcode = None DCNL DCSP DCSP DCSP if hasattr ( e , &apos; errno &apos; ) : DCNL DCSP DCSP DCSP DCSP errcode = e.errno DCNL DCSP DCSP DCSP elif hasattr ( e , &apos; args &apos; ) : DCNL DCSP DCSP DCSP DCSP errcode = e.args &#91; 0 &#93; DCNL DCSP DCSP DCSP is _ interrupt = ( ( errcode = = errno.EINTR ) or ( hasattr ( errno , &apos; WSAEINTR &apos; ) and ( errcode = = errno.WSAEINTR ) ) ) DCNL DCSP DCSP DCSP if is _ interrupt : DCNL DCSP DCSP DCSP DCSP if ( expires is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP current _ time = monotonic ( ) DCNL DCSP DCSP DCSP DCSP DCSP if ( current _ time &gt; expires ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise OSError ( errno = errno.ETIMEDOUT ) DCNL DCSP DCSP DCSP DCSP DCSP if recalc _ timeout : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( &apos; timeout &apos; in kwargs ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP kwargs &#91; &apos; timeout &apos; &#93; = ( expires - current _ time ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if errcode : DCNL DCSP DCSP DCSP DCSP raise SelectorError ( errcode ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP return result
DCSP if ( not iface ) : DCNL DCSP DCSP iface = conf.iface DCNL DCSP if ( not src _ lladdr ) : DCNL DCSP DCSP src _ lladdr = get _ if _ hwaddr ( iface ) DCNL DCSP ether _ params = { } DCNL DCSP if src _ mac : DCNL DCSP DCSP ether _ params &#91; &apos; src &apos; &#93; = src _ mac DCNL DCSP if dst _ mac : DCNL DCSP DCSP ether _ params &#91; &apos; dst &apos; &#93; = dst _ mac DCNL DCSP ipv6 _ params = { } DCNL DCSP if src : DCNL DCSP DCSP ipv6 _ params &#91; &apos; src &apos; &#93; = src DCNL DCSP if dst : DCNL DCSP DCSP ipv6 _ params &#91; &apos; dst &apos; &#93; = dst DCNL DCSP else : DCNL DCSP DCSP tmp = inet _ ntop ( socket.AF _ INET6 , in6 _ getnsma ( inet _ pton ( socket.AF _ INET6 , target ) ) ) DCNL DCSP DCSP ipv6 _ params &#91; &apos; dst &apos; &#93; = tmp DCNL DCSP pkt = Ether ( * * ether _ params ) DCNL DCSP pkt / = IPv6 ( * * ipv6 _ params ) DCNL DCSP pkt / = ICMPv6ND _ NS ( tgt = target ) DCNL DCSP pkt / = ICMPv6NDOptSrcLLAddr ( lladdr = src _ lladdr ) DCNL DCSP sendp ( pkt , inter = inter , loop = loop , iface = iface , verbose = 0 )
DCSP def f ( rv ) : DCNL DCSP DCSP if ( not rv.is _ Mul ) : DCNL DCSP DCSP DCSP return rv DCNL DCSP DCSP args = { tan : &#91; &#93; , cot : &#91; &#93; , None : &#91; &#93; } DCNL DCSP DCSP for a in ordered ( Mul.make _ args ( rv ) ) : DCNL DCSP DCSP DCSP if ( a.func in ( tan , cot ) ) : DCNL DCSP DCSP DCSP DCSP args &#91; a.func &#93; .append ( a.args &#91; 0 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP args &#91; None &#93; .append ( a ) DCNL DCSP DCSP t = args &#91; tan &#93; DCNL DCSP DCSP c = args &#91; cot &#93; DCNL DCSP DCSP if ( ( len ( t ) &lt; 2 ) and ( len ( c ) &lt; 2 ) ) : DCNL DCSP DCSP DCSP return rv DCNL DCSP DCSP args = args &#91; None &#93; DCNL DCSP DCSP while ( len ( t ) &gt; 1 ) : DCNL DCSP DCSP DCSP t1 = t.pop ( ) DCNL DCSP DCSP DCSP t2 = t.pop ( ) DCNL DCSP DCSP DCSP args.append ( ( 1 - ( ( tan ( t1 ) / tan ( ( t1 + t2 ) ) ) + ( tan ( t2 ) / tan ( ( t1 + t2 ) ) ) ) ) ) DCNL DCSP DCSP if t : DCNL DCSP DCSP DCSP args.append ( tan ( t.pop ( ) ) ) DCNL DCSP DCSP while ( len ( c ) &gt; 1 ) : DCNL DCSP DCSP DCSP t1 = c.pop ( ) DCNL DCSP DCSP DCSP t2 = c.pop ( ) DCNL DCSP DCSP DCSP args.append ( ( ( 1 + ( cot ( t1 ) * cot ( ( t1 + t2 ) ) ) ) + ( cot ( t2 ) * cot ( ( t1 + t2 ) ) ) ) ) DCNL DCSP DCSP if c : DCNL DCSP DCSP DCSP args.append ( cot ( c.pop ( ) ) ) DCNL DCSP DCSP return Mul ( * args ) DCNL DCSP return bottom _ up ( rv , f )
DCSP return node.op. _ _ class _ _ . _ _ name _ _
DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP category = KnowledgeCategory ( ) DCNL DCSP DCSP DCSP form = KnowledgeCategoryForm ( request.POST , instance = category ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP category = form.save ( ) DCNL DCSP DCSP DCSP DCSP category.set _ user _ from _ request ( request ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; knowledge _ category _ view &apos; , args = &#91; category.treepath &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; knowledge _ categories &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP form = KnowledgeCategoryForm ( ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; form &apos; : form } ) DCNL DCSP return render _ to _ response ( &apos; knowledge / category _ add &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP return crypto _ command ( &apos; ltc &apos; )
DCSP if cbook.is _ numlike ( size ) : DCNL DCSP DCSP return Fixed ( size ) DCNL DCSP elif cbook.is _ string _ like ( size ) : DCNL DCSP DCSP if ( size &#91; ( -1 ) &#93; = = u &apos; % &apos; ) : DCNL DCSP DCSP DCSP return Fraction ( ( float ( size &#91; : ( -1 ) &#93; ) / 100.0 ) , fraction _ ref ) DCNL DCSP raise ValueError ( u &apos;Unknown DCSP format &apos; )
DCSP if ( ( dim _ cols = = &apos; index &apos; ) or ( agg _ col = = &apos; index &apos; ) or ( dim _ cols is None ) ) : DCNL DCSP DCSP agg = None DCNL DCSP DCSP agg _ col = None DCNL DCSP elif ( agg _ col is None ) : DCNL DCSP DCSP if isinstance ( dim _ cols , list ) : DCNL DCSP DCSP DCSP agg _ col = dim _ cols &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP agg _ col = dim _ cols DCNL DCSP DCSP agg = &apos; count &apos; DCNL DCSP return ( agg _ col , agg )
DCSP return function ( &#91; x , y &#93; , expr ) ( x _ value , y _ value )
DCSP resource = MessageToDict ( sub _ pb ) DCNL DCSP return Subscription.from _ api _ repr ( resource , iterator.client , topics = topics )
DCSP context = Context . _ make ( context ) DCNL DCSP try : DCNL DCSP DCSP context.initialized DCNL DCSP except : DCNL DCSP DCSP if ( type ( field _ converter ) is types.FunctionType ) : DCNL DCSP DCSP DCSP field _ converter = BasicConverter ( field _ converter ) DCNL DCSP DCSP context . _ setdefaults ( { u &apos;initialized &apos; : True , u &apos;field _ converter &apos; : field _ converter , u &apos;role &apos; : role , u &apos;raise _ error _ on _ role &apos; : raise _ error _ on _ role , u &apos;export _ level &apos; : export _ level , u &apos;app _ data &apos; : ( app _ data if ( app _ data is not None ) else { } ) } ) DCNL DCSP instance _ or _ dict = context.field _ converter.pre ( cls , instance _ or _ dict , context ) DCNL DCSP if cls . _ options.export _ order : DCNL DCSP DCSP data = OrderedDict ( ) DCNL DCSP else : DCNL DCSP DCSP data = { } DCNL DCSP filter _ func = cls . _ options.roles.get ( context.role ) DCNL DCSP if ( filter _ func is None ) : DCNL DCSP DCSP if ( context.role and context.raise _ error _ on _ role ) : DCNL DCSP DCSP DCSP error _ msg = u &apos; % s DCSP Model DCSP has DCSP no DCSP role DCSP &quot; % s &quot; &apos; DCNL DCSP DCSP DCSP raise ValueError ( ( error _ msg % ( cls . _ _ name _ _ , context.role ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP filter _ func = cls . _ options.roles.get ( u &apos;default &apos; ) DCNL DCSP _ field _ converter = context.field _ converter DCNL DCSP for ( field _ name , field , value ) in atoms ( cls , instance _ or _ dict ) : DCNL DCSP DCSP serialized _ name = ( field.serialized _ name or field _ name ) DCNL DCSP DCSP if ( ( filter _ func is not None ) and filter _ func ( field _ name , value ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP _ export _ level = field.get _ export _ level ( context ) DCNL DCSP DCSP if ( _ export _ level = = DROP ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( ( value is not None ) and ( value is not Undefined ) ) : DCNL DCSP DCSP DCSP value = _ field _ converter ( field , value , context ) DCNL DCSP DCSP if ( value is Undefined ) : DCNL DCSP DCSP DCSP if ( _ export _ level &lt; = DEFAULT ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( value is None ) : DCNL DCSP DCSP DCSP if ( _ export _ level &lt; = NOT _ NONE ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( field.is _ compound and ( len ( value ) = = 0 ) ) : DCNL DCSP DCSP DCSP if ( _ export _ level &lt; = NONEMPTY ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP if ( value is Undefined ) : DCNL DCSP DCSP DCSP value = None DCNL DCSP DCSP data &#91; serialized _ name &#93; = value DCNL DCSP data = context.field _ converter.post ( cls , data , context ) DCNL DCSP return data
DCSP tpot _ obj = TPOTClassifier ( ) DCNL DCSP tpot _ obj . _ pbar = tqdm ( total = 1 , disable = True ) DCNL DCSP known _ score = 0.986318199045 DCNL DCSP tpot _ obj . _ optimized _ pipeline = creator.Individual.from _ string ( &apos; RandomForestClassifier ( input _ matrix ) &apos; , tpot _ obj . _ pset ) DCNL DCSP tpot _ obj . _ fitted _ pipeline = tpot _ obj . _ toolbox.compile ( expr = tpot _ obj . _ optimized _ pipeline ) DCNL DCSP tpot _ obj . _ fitted _ pipeline.fit ( training _ features , training _ classes ) DCNL DCSP score = tpot _ obj.score ( testing _ features , testing _ classes ) DCNL DCSP def isclose ( a , b , rel _ tol = 1e-09 , abs _ tol = 0.0 ) : DCNL DCSP DCSP return ( abs ( ( a - b ) ) &lt; = max ( ( rel _ tol * max ( abs ( a ) , abs ( b ) ) ) , abs _ tol ) ) DCNL DCSP assert isclose ( known _ score , score )
DCSP if ( ( not hasattr ( node , &apos; op &apos; ) ) or ( not isinstance ( node.op , T.Elemwise ) ) or ( node.op = = T.fill ) ) : DCNL DCSP DCSP return False DCNL DCSP models = &#91; &#93; DCNL DCSP inputs = &#91; &#93; DCNL DCSP for input in node.inputs : DCNL DCSP DCSP if ( input.owner and ( input.owner.op = = T.fill ) ) : DCNL DCSP DCSP DCSP models.append ( input.owner.inputs &#91; 0 &#93; ) DCNL DCSP DCSP DCSP inputs.append ( input.owner.inputs &#91; 1 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP inputs.append ( input ) DCNL DCSP if ( not models ) : DCNL DCSP DCSP return False DCNL DCSP c = node.op ( * inputs ) DCNL DCSP for model in models : DCNL DCSP DCSP if ( model.type ! = c.type ) : DCNL DCSP DCSP DCSP c = T.fill ( model , c ) DCNL DCSP replacements = { node.outputs &#91; 0 &#93; : c } DCNL DCSP for ( client , cl _ idx ) in node.outputs &#91; 0 &#93; .clients : DCNL DCSP DCSP if ( hasattr ( client , &apos; op &apos; ) and isinstance ( client.op , T.Elemwise ) and ( not ( client.op = = T.fill ) ) ) : DCNL DCSP DCSP DCSP client _ inputs = client.inputs &#91; : &#93; DCNL DCSP DCSP DCSP client _ inputs &#91; cl _ idx &#93; = c DCNL DCSP DCSP DCSP new _ client = client.op ( * client _ inputs ) DCNL DCSP DCSP DCSP new _ client.owner.outputs &#91; 0 &#93; .clients = client.outputs &#91; 0 &#93; .clients DCNL DCSP DCSP DCSP r = local _ fill _ sink.transform ( new _ client.owner ) DCNL DCSP DCSP DCSP if ( not r ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP replacements.update ( r ) DCNL DCSP return replacements
DCSP help _ texts = password _ validators _ help _ texts ( password _ validators ) DCNL DCSP help _ items = &#91; format _ html ( &apos; &lt; li &gt; { } &lt; / li &gt; &apos; , help _ text ) for help _ text in help _ texts &#93; DCNL DCSP return ( ( &apos; &lt; ul &gt; % s &lt; / ul &gt; &apos; % &apos; &apos;.join ( help _ items ) ) if help _ items else &apos; &apos; )
DCSP assert ( not forum _ is _ unread ( None , None , guest ) ) DCNL DCSP assert forum _ is _ unread ( forum , None , user ) DCNL DCSP assert forum _ is _ unread ( forum , forumsread , user ) DCNL DCSP topic.update _ read ( user , topic.forum , forumsread ) DCNL DCSP time _ read = ( datetime.datetime.utcnow ( ) - datetime.timedelta ( hours = 1 ) ) DCNL DCSP forumsread.cleared = time _ read DCNL DCSP forumsread.last _ read = datetime.datetime.utcnow ( ) DCNL DCSP forumsread.save ( ) DCNL DCSP assert ( not forum _ is _ unread ( forum , forumsread , user ) ) DCNL DCSP flaskbb _ config &#91; &apos; TRACKER _ LENGTH &apos; &#93; = 0 DCNL DCSP assert ( not forum _ is _ unread ( forum , forumsread , user ) ) DCNL DCSP flaskbb _ config &#91; &apos; TRACKER _ LENGTH &apos; &#93; = 1 DCNL DCSP forum.last _ post _ created = ( forum.last _ post _ created - datetime.timedelta ( hours = 48 ) ) DCNL DCSP forum.save ( ) DCNL DCSP assert ( not forum _ is _ unread ( forum , forumsread , user ) ) DCNL DCSP topic.delete ( ) DCNL DCSP forum = Forum.query.filter _ by ( id = forum.id ) .first ( ) DCNL DCSP flaskbb _ config &#91; &apos; TRACKER _ LENGTH &apos; &#93; = 1 DCNL DCSP assert ( forum.topic _ count = = 0 ) DCNL DCSP assert ( not forum _ is _ unread ( forum , None , user ) )
DCSP if args.flavor : DCNL DCSP DCSP flavor = _ find _ flavor ( cs , args.flavor ) DCNL DCSP DCSP if flavor.is _ public : DCNL DCSP DCSP DCSP raise exceptions.CommandError ( _ ( &apos; Access DCSP list DCSP not DCSP available DCSP for DCSP public DCSP flavors . &apos; ) ) DCNL DCSP DCSP kwargs = { &apos; flavor &apos; : flavor } DCNL DCSP else : DCNL DCSP DCSP raise exceptions.CommandError ( _ ( &apos; Unable DCSP to DCSP get DCSP all DCSP access DCSP lists . DCSP Specify DCSP --flavor &apos; ) ) DCNL DCSP try : DCNL DCSP DCSP access _ list = cs.flavor _ access.list ( * * kwargs ) DCNL DCSP except NotImplementedError as e : DCNL DCSP DCSP raise exceptions.CommandError ( ( &apos; % s &apos; % str ( e ) ) ) DCNL DCSP columns = &#91; &apos; Flavor _ ID &apos; , &apos; Tenant _ ID &apos; &#93; DCNL DCSP utils.print _ list ( access _ list , columns )
DCSP data = word.encode ( &apos; utf-8 &apos; ) DCNL DCSP return ( &apos; server % d &apos; % ( hashlib.md5 ( data ) .digest ( ) &#91; ( -1 ) &#93; % 4 ) )
DCSP M = attribute _ mixing _ matrix ( G , attribute , nodes ) DCNL DCSP return attribute _ ac ( M )
DCSP headers = { &apos; Access-Control-Allow-Credentials &apos; : &apos; true &apos; , &apos; Access-Control-Allow-Headers &apos; : ( ( ( &apos; accept , DCSP accept-charset , DCSP accept-encoding , DCSP &apos; + &apos; accept-language , DCSP authorization , DCSP content-length , DCSP &apos; ) + &apos; content-type , DCSP host , DCSP origin , DCSP proxy-connection , DCSP &apos; ) + &apos; referer , DCSP user-agent , DCSP x-requested-with &apos; ) , &apos; Access-Control-Allow-Methods &apos; : &apos; HEAD , DCSP GET , DCSP PUT , DCSP POST , DCSP PATCH , DCSP DELETE &apos; , &apos; Access-Control-Allow-Origin &apos; : &apos; * &apos; , &apos; Access-Control-Max-Age &apos; : &apos; 86400 &apos; } DCNL DCSP if add _ headers _ cb : DCNL DCSP DCSP headers.update ( add _ headers _ cb ( ) ) DCNL DCSP return headers
DCSP warnings.warnpy3k ( &apos; In DCSP 3.x , DCSP os.path.walk DCSP is DCSP removed DCSP in DCSP favor DCSP of DCSP os.walk. &apos; ) DCNL DCSP try : DCNL DCSP DCSP names = os.listdir ( top ) DCNL DCSP except os.error : DCNL DCSP DCSP return DCNL DCSP func ( arg , top , names ) DCNL DCSP for name in names : DCNL DCSP DCSP name = join ( top , name ) DCNL DCSP DCSP if isdir ( name ) : DCNL DCSP DCSP DCSP walk ( name , func , arg )
DCSP deleted = set ( ) DCNL DCSP class TestTable ( table.Table , ) : DCNL DCSP DCSP def _ _ del _ _ ( self ) : DCNL DCSP DCSP DCSP deleted.add ( id ( self ) ) DCNL DCSP t = TestTable ( { &apos; a &apos; : &#91; 1 , 2 , 3 &#93; } ) DCNL DCSP the _ id = id ( t ) DCNL DCSP assert ( t &#91; &apos; a &apos; &#93; .parent _ table is t ) DCNL DCSP del t DCNL DCSP gc.collect ( ) DCNL DCSP assert ( the _ id in deleted )
DCSP return ( keystr.startswith ( &apos; &lt; &apos; ) and keystr.endswith ( &apos; &gt; &apos; ) )
DCSP if ( u &apos; , &apos; in symbols ) : DCNL DCSP DCSP symbol _ list = symbols.split ( u &apos; , &apos; ) DCNL DCSP else : DCNL DCSP DCSP symbol _ list = symbols.split ( ) DCNL DCSP return &#91; Nonterminal ( s.strip ( ) ) for s in symbol _ list &#93;
DCSP if ( not keep _ bang _ comments ) : DCNL DCSP DCSP rex = &apos; ( &#91; ^ \ \ 047 &quot; / \ \ 000- \ \ 040 &#93; + ) &#124; ( ( ? : ( ? : \ \ 047 &#91; ^ \ \ 047 \ \ \ \ \ \ r \ \ n &#93; * ( ? : \ \ \ \ ( ? : &#91; ^ \ \ r \ \ n &#93; &#124; \ \ r ? \ \ n &#124; \ \ r ) &#91; ^ \ \ 047 \ \ \ \ \ \ r \ \ n &#93; * ) * \ \ 047 ) &#124; ( ? : &quot; &#91; ^ &quot; \ \ \ \ \ \ r \ \ n &#93; * ( ? : \ \ \ \ ( ? : &#91; ^ \ \ r \ \ n &#93; &#124; \ \ r ? \ \ n &#124; \ \ r ) &#91; ^ &quot; \ \ \ \ \ \ r \ \ n &#93; * ) * &quot; ) ) &#91; ^ \ \ 047 &quot; / \ \ 000- \ \ 040 &#93; * ) &#124; ( ? &lt; = &#91; ( , = : \ \ &#91; ! &amp; &#124; ? { } ; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) * ( ( ? : / ( ? ! &#91; \ \ r \ \ n / * &#93; ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ( ? : ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#124; ( ? : \ \ &#91; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ) * \ \ &#93; ) ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ) * / ) ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ( ? = &#91; ^ \ \ 000- \ \ 040 &amp; ) + , . : ; = ? \ \ &#93; &#124; } - &#93; ) ) ? &#124; ( ? &lt; = &#91; \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; return ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) * ( ( ? : / ( ? ! &#91; \ \ r \ \ n / * &#93; ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ( ? : ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#124; ( ? : \ \ &#91; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ) * \ \ &#93; ) ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ) * / ) ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ( ? = &#91; ^ \ \ 000- \ \ 040 &amp; ) + , . : ; = ? \ \ &#93; &#124; } - &#93; ) ) ? &#124; ( ? &lt; = &#91; ^ \ \ 000- ! # % &amp; ( * , . / : - @ \ \ &#91; \ \ \ \ ^ ` { &#124; ~ &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ( ? = &#91; ^ \ \ 000- \ \ 040 &quot; # % - \ \ 047 ) * , . / : - @ \ \ \ \ - ^ ` &#124; - ~ &#93; ) &#124; ( ? &lt; = &#91; ^ \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) ) + ( ? = &#91; ^ \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; ) &#124; ( ? &lt; = \ \ + ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) ) + ( ? = \ \ + ) &#124; ( ? &lt; = - ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) ) + ( ? = - ) &#124; ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) + &#124; ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + &apos; DCNL DCSP DCSP def subber ( match ) : DCNL DCSP DCSP DCSP &apos; DCSP Substitution DCSP callback DCSP &apos; DCNL DCSP DCSP DCSP groups = match.groups ( ) DCNL DCSP DCSP DCSP return ( groups &#91; 0 &#93; or groups &#91; 1 &#93; or ( groups &#91; 3 &#93; and ( groups &#91; 2 &#93; + &apos; \ n &apos; ) ) or groups &#91; 2 &#93; or ( groups &#91; 5 &#93; and ( &apos; % s % s % s &apos; % ( ( ( groups &#91; 4 &#93; and &apos; \ n &apos; ) or &apos; &apos; ) , groups &#91; 5 &#93; , ( ( groups &#91; 6 &#93; and &apos; \ n &apos; ) or &apos; &apos; ) ) ) ) or ( groups &#91; 7 &#93; and &apos; \ n &apos; ) or ( groups &#91; 8 &#93; and &apos; DCSP &apos; ) or ( groups &#91; 9 &#93; and &apos; DCSP &apos; ) or ( groups &#91; 10 &#93; and &apos; DCSP &apos; ) or &apos; &apos; ) DCNL DCSP else : DCNL DCSP DCSP rex = &apos; ( &#91; ^ \ \ 047 &quot; / \ \ 000- \ \ 040 &#93; + ) &#124; ( ( ? : ( ? : \ \ 047 &#91; ^ \ \ 047 \ \ \ \ \ \ r \ \ n &#93; * ( ? : \ \ \ \ ( ? : &#91; ^ \ \ r \ \ n &#93; &#124; \ \ r ? \ \ n &#124; \ \ r ) &#91; ^ \ \ 047 \ \ \ \ \ \ r \ \ n &#93; * ) * \ \ 047 ) &#124; ( ? : &quot; &#91; ^ &quot; \ \ \ \ \ \ r \ \ n &#93; * ( ? : \ \ \ \ ( ? : &#91; ^ \ \ r \ \ n &#93; &#124; \ \ r ? \ \ n &#124; \ \ r ) &#91; ^ &quot; \ \ \ \ \ \ r \ \ n &#93; * ) * &quot; ) ) &#91; ^ \ \ 047 &quot; / \ \ 000- \ \ 040 &#93; * ) &#124; ( ? &lt; = &#91; ( , = : \ \ &#91; ! &amp; &#124; ? { } ; \ \ r \ \ n &#93; ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) * ) ( ( ? : / ( ? ! &#91; \ \ r \ \ n / * &#93; ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ( ? : ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#124; ( ? : \ \ &#91; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ) * \ \ &#93; ) ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ) * / ) ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ( ? = &#91; ^ \ \ 000- \ \ 040 &amp; ) + , . : ; = ? \ \ &#93; &#124; } - &#93; ) ) ? &#124; ( ? &lt; = &#91; \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; return ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) * ) ( ( ? : / ( ? ! &#91; \ \ r \ \ n / * &#93; ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ( ? : ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#124; ( ? : \ \ &#91; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ( ? : \ \ \ \ &#91; ^ \ \ r \ \ n &#93; &#91; ^ \ \ \ \ \ \ &#93; \ \ r \ \ n &#93; * ) * \ \ &#93; ) ) &#91; ^ / \ \ \ \ \ \ &#91; \ \ r \ \ n &#93; * ) * / ) ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ( ? = &#91; ^ \ \ 000- \ \ 040 &amp; ) + , . : ; = ? \ \ &#93; &#124; } - &#93; ) ) ? &#124; ( ? &lt; = &#91; ^ \ \ 000- ! # % &amp; ( * , . / : - @ \ \ &#91; \ \ \ \ ^ ` { &#124; ~ &#93; ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ) ( ? = &#91; ^ \ \ 000- \ \ 040 &quot; # % - \ \ 047 ) * , . / : - @ \ \ \ \ - ^ ` &#124; - ~ &#93; ) &#124; ( ? &lt; = &#91; ^ \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) + ) ( ? = &#91; ^ \ \ 000- # % - , . / : - @ \ \ &#91; - ^ ` { - ~ - &#93; ) &#124; ( ? &lt; = \ \ + ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) + ) ( ? = \ \ + ) &#124; ( ? &lt; = - ) ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) + ) ( ? = - ) &#124; ( ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) + ) &#124; ( ( ? : ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) ( ? : &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; &#124; ( ? : / \ \ * &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) ) * ) + ) &apos; DCNL DCSP DCSP keep = _ re.compile ( ( &apos; &#91; \ \ 000- \ \ 011 \ \ 013 \ \ 014 \ \ 016- \ \ 040 &#93; + &#124; ( ? : / \ \ * ( ? ! ! ) &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) + &#124; ( ? : ( ? : / / &#91; ^ \ \ r \ \ n &#93; * ) ? &#91; \ \ r \ \ n &#93; ) + &#124; ( ( ? : / \ \ * ! &#91; ^ * &#93; * \ \ * + ( ? : &#91; ^ / * &#93; &#91; ^ * &#93; * \ \ * + ) * / ) + ) &apos; % locals ( ) ) ) .sub DCNL DCSP DCSP keeper = ( lambda m : ( m.groups ( ) &#91; 0 &#93; or &apos; &apos; ) ) DCNL DCSP DCSP def subber ( match ) : DCNL DCSP DCSP DCSP &apos; DCSP Substitution DCSP callback DCSP &apos; DCNL DCSP DCSP DCSP groups = match.groups ( ) DCNL DCSP DCSP DCSP return ( groups &#91; 0 &#93; or groups &#91; 1 &#93; or ( groups &#91; 3 &#93; and ( &apos; % s % s % s % s &apos; % ( keep ( keeper , groups &#91; 2 &#93; ) , groups &#91; 3 &#93; , keep ( keeper , ( groups &#91; 4 &#93; or &apos; &apos; ) ) , ( ( groups &#91; 4 &#93; and &apos; \ n &apos; ) or &apos; &apos; ) ) ) ) or ( groups &#91; 7 &#93; and ( &apos; % s % s % s % s % s &apos; % ( keep ( keeper , groups &#91; 5 &#93; ) , ( ( groups &#91; 6 &#93; and &apos; \ n &apos; ) or &apos; &apos; ) , groups &#91; 7 &#93; , keep ( keeper , ( groups &#91; 8 &#93; or &apos; &apos; ) ) , ( ( groups &#91; 8 &#93; and &apos; \ n &apos; ) or &apos; &apos; ) ) ) ) or ( groups &#91; 9 &#93; and keep ( keeper , ( groups &#91; 9 &#93; + &apos; \ n &apos; ) ) ) or ( ( groups &#91; 10 &#93; and keep ( keeper , groups &#91; 10 &#93; ) ) or &apos; DCSP &apos; ) or ( ( groups &#91; 11 &#93; and keep ( keeper , groups &#91; 11 &#93; ) ) or &apos; DCSP &apos; ) or ( ( groups &#91; 12 &#93; and keep ( keeper , groups &#91; 12 &#93; ) ) or &apos; DCSP &apos; ) or keep ( keeper , ( groups &#91; 13 &#93; or groups &#91; 14 &#93; ) ) ) DCNL DCSP return _ re.sub ( rex , subber , ( &apos; \ n % s \ n &apos; % script ) ) .strip ( )
DCSP missing _ deps = &#91; &#93; DCNL DCSP for dependency in DEPENDENCIES : DCNL DCSP DCSP if ( ( not dependency.check ( ) ) and ( not dependency.optional ) ) : DCNL DCSP DCSP DCSP missing _ deps.append ( dependency ) DCNL DCSP if missing _ deps : DCNL DCSP DCSP return status ( deps = missing _ deps , linesep = &apos; &lt; br &gt; &apos; ) DCNL DCSP else : DCNL DCSP DCSP return &apos; &apos;
DCSP network = Network ( ) DCNL DCSP network.addRegion ( &apos; sensor &apos; , &apos; py.RecordSensor &apos; , json.dumps ( { &apos; verbosity &apos; : _ VERBOSITY } ) ) DCNL DCSP sensor = network.regions &#91; &apos; sensor &apos; &#93; .getSelf ( ) DCNL DCSP sensor.encoder = createEncoder ( ) DCNL DCSP sensor.dataSource = dataSource DCNL DCSP SP _ PARAMS &#91; &apos; inputWidth &apos; &#93; = sensor.encoder.getWidth ( ) DCNL DCSP network.addRegion ( &apos; spatialPoolerRegion &apos; , &apos; py.SPRegion &apos; , json.dumps ( SP _ PARAMS ) ) DCNL DCSP network.link ( &apos; sensor &apos; , &apos; spatialPoolerRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; ) DCNL DCSP network.link ( &apos; sensor &apos; , &apos; spatialPoolerRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; resetOut &apos; , destInput = &apos; resetIn &apos; ) DCNL DCSP network.link ( &apos; spatialPoolerRegion &apos; , &apos; sensor &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; spatialTopDownOut &apos; , destInput = &apos; spatialTopDownIn &apos; ) DCNL DCSP network.link ( &apos; spatialPoolerRegion &apos; , &apos; sensor &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; temporalTopDownOut &apos; , destInput = &apos; temporalTopDownIn &apos; ) DCNL DCSP network.addRegion ( &apos; temporalPoolerRegion &apos; , &apos; py.TPRegion &apos; , json.dumps ( TP _ PARAMS ) ) DCNL DCSP network.link ( &apos; spatialPoolerRegion &apos; , &apos; temporalPoolerRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; ) DCNL DCSP network.link ( &apos; temporalPoolerRegion &apos; , &apos; spatialPoolerRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; topDownOut &apos; , destInput = &apos; topDownIn &apos; ) DCNL DCSP network.addRegion ( &apos; anomalyLikelihoodRegion &apos; , &apos; py.AnomalyLikelihoodRegion &apos; , json.dumps ( { } ) ) DCNL DCSP network.link ( &apos; temporalPoolerRegion &apos; , &apos; anomalyLikelihoodRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; anomalyScore &apos; , destInput = &apos; rawAnomalyScore &apos; ) DCNL DCSP network.link ( &apos; sensor &apos; , &apos; anomalyLikelihoodRegion &apos; , &apos; UniformLink &apos; , &apos; &apos; , srcOutput = &apos; sourceOut &apos; , destInput = &apos; metricValue &apos; ) DCNL DCSP spatialPoolerRegion = network.regions &#91; &apos; spatialPoolerRegion &apos; &#93; DCNL DCSP spatialPoolerRegion.setParameter ( &apos; learningMode &apos; , True ) DCNL DCSP spatialPoolerRegion.setParameter ( &apos; anomalyMode &apos; , False ) DCNL DCSP temporalPoolerRegion = network.regions &#91; &apos; temporalPoolerRegion &apos; &#93; DCNL DCSP temporalPoolerRegion.setParameter ( &apos; topDownMode &apos; , True ) DCNL DCSP temporalPoolerRegion.setParameter ( &apos; learningMode &apos; , True ) DCNL DCSP temporalPoolerRegion.setParameter ( &apos; inferenceMode &apos; , True ) DCNL DCSP temporalPoolerRegion.setParameter ( &apos; anomalyMode &apos; , True ) DCNL DCSP return network
DCSP if ( not ( isinstance ( values , multistring ) or isinstance ( values , list ) ) ) : DCNL DCSP DCSP return values DCNL DCSP try : DCNL DCSP DCSP values _ list = list ( values.strings ) DCNL DCSP DCSP has _ plural _ placeholder = getattr ( values , &apos; plural &apos; , False ) DCNL DCSP except AttributeError : DCNL DCSP DCSP values _ list = values DCNL DCSP DCSP has _ plural _ placeholder = False DCNL DCSP if list _ empty ( values _ list ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP if ( ( len ( values _ list ) = = 1 ) and has _ plural _ placeholder ) : DCNL DCSP DCSP values _ list.append ( PLURAL _ PLACEHOLDER ) DCNL DCSP return SEPARATOR.join ( values _ list )
DCSP term ( name )
DCSP if ( not which ( &apos; qsub &apos; ) ) : DCNL DCSP DCSP raise ApplicationNotFoundError ( &quot; qsub DCSP not DCSP found . DCSP Can &apos;t DCSP submit DCSP jobs . &quot; ) DCNL DCSP for file in filenames : DCNL DCSP DCSP command = ( &apos; qsub DCSP % s &apos; % file ) DCNL DCSP DCSP result = Popen ( command , shell = True , universal _ newlines = True , stdout = PIPE , stderr = STDOUT ) .stdout.read ( ) DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print result
DCSP from itertools import groupby DCNL DCSP if ( r.http ! = &apos; GET &apos; ) : DCNL DCSP DCSP r.error ( 405 , current.ERROR.BAD _ METHOD ) DCNL DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP response = current.response DCNL DCSP s3 = response.s3 DCNL DCSP has _ permission = current.auth.s3 _ has _ permission DCNL DCSP person = r.record DCNL DCSP ctable = s3db.pr _ contact DCNL DCSP query = ( ctable.pe _ id = = person.pe _ id ) DCNL DCSP resource = s3db.resource ( &apos; pr _ contact &apos; ) DCNL DCSP resource.add _ filter ( query ) DCNL DCSP access = s3.pr _ contacts DCNL DCSP if access : DCNL DCSP DCSP resource.add _ filter ( ( FS ( &apos; contact.access &apos; ) = = access ) ) DCNL DCSP fields = &#91; &apos; id &apos; , &apos; contact _ description &apos; , &apos; value &apos; , &apos; contact _ method &apos; &#93; DCNL DCSP contacts = resource.select ( fields ) &#91; &apos; rows &apos; &#93; DCNL DCSP contact _ groups = { } DCNL DCSP for ( key , group ) in groupby ( contacts , ( lambda c : c &#91; &apos; pr _ contact.contact _ method &apos; &#93; ) ) : DCNL DCSP DCSP contact _ groups &#91; key &#93; = list ( group ) DCNL DCSP contacts _ wrapper = DIV ( H2 ( T ( &apos; Contacts &apos; ) ) ) DCNL DCSP person _ update _ permission = has _ permission ( &apos; update &apos; , &apos; pr _ person &apos; , record _ id = person.id ) DCNL DCSP if ( person _ update _ permission and has _ permission ( &apos; create &apos; , ctable ) ) : DCNL DCSP DCSP add _ btn = DIV ( A ( T ( &apos; Add &apos; ) , _ class = &apos; action-btn &apos; , _ id = &apos; contact-add &apos; ) , DIV ( _ id = &apos; contact-add _ throbber &apos; , _ class = &apos; throbber DCSP hide &apos; ) , _ class = &apos; margin &apos; ) DCNL DCSP DCSP contacts _ wrapper.append ( add _ btn ) DCNL DCSP items = contact _ groups.items ( ) DCNL DCSP def mysort ( key ) : DCNL DCSP DCSP &apos; DCSP Sort DCSP Contact DCSP Types DCSP by DCSP Priority &apos; DCNL DCSP DCSP keys = { &apos; SMS &apos; : 1 , &apos; EMAIL &apos; : 2 , &apos; WORK _ PHONE &apos; : 3 , &apos; HOME _ PHONE &apos; : 4 , &apos; SKYPE &apos; : 5 , &apos; RADIO &apos; : 6 , &apos; TWITTER &apos; : 7 , &apos; FACEBOOK &apos; : 8 , &apos; FAX &apos; : 9 , &apos; OTHER &apos; : 10 , &apos; IRC &apos; : 11 , &apos; GITHUB &apos; : 12 , &apos; LINKEDIN &apos; : 13 , &apos; BLOG &apos; : 14 } DCNL DCSP DCSP return keys &#91; key &#91; 0 &#93; &#93; DCNL DCSP items.sort ( key = mysort ) DCNL DCSP opts = current.msg.CONTACT _ OPTS DCNL DCSP def action _ buttons ( table , contact _ id ) : DCNL DCSP DCSP if has _ permission ( &apos; update &apos; , ctable , record _ id = contact _ id ) : DCNL DCSP DCSP DCSP edit _ btn = A ( T ( &apos; Edit &apos; ) , _ class = &apos; editBtn DCSP action-btn DCSP fright &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP edit _ btn = DIV ( ) DCNL DCSP DCSP if has _ permission ( &apos; delete &apos; , ctable , record _ id = contact _ id ) : DCNL DCSP DCSP DCSP delete _ btn = A ( T ( &apos; Delete &apos; ) , _ class = &apos; delete-btn-ajax DCSP fright &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP delete _ btn = DIV ( ) DCNL DCSP DCSP return ( edit _ btn , delete _ btn ) DCNL DCSP for ( contact _ type , details ) in items : DCNL DCSP DCSP contacts _ wrapper.append ( H3 ( opts &#91; contact _ type &#93; ) ) DCNL DCSP DCSP for detail in details : DCNL DCSP DCSP DCSP contact _ id = detail &#91; &apos; pr _ contact.id &apos; &#93; DCNL DCSP DCSP DCSP value = detail &#91; &apos; pr _ contact.value &apos; &#93; DCNL DCSP DCSP DCSP description = ( detail &#91; &apos; pr _ contact.contact _ description &apos; &#93; or &apos; &apos; ) DCNL DCSP DCSP DCSP if description : DCNL DCSP DCSP DCSP DCSP description = ( &apos; % s , DCSP &apos; % description ) DCNL DCSP DCSP DCSP ( edit _ btn , delete _ btn ) = action _ buttons ( ctable , contact _ id ) DCNL DCSP DCSP DCSP contacts _ wrapper.append ( P ( SPAN ( description , value ) , edit _ btn , delete _ btn , _ id = ( &apos; contact- % s &apos; % contact _ id ) , _ class = &apos; contact &apos; ) ) DCNL DCSP show _ emergency _ contacts = current.deployment _ settings.get _ pr _ show _ emergency _ contacts ( ) DCNL DCSP if ( not show _ emergency _ contacts ) : DCNL DCSP DCSP emergency _ wrapper = &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP etable = s3db.pr _ contact _ emergency DCNL DCSP DCSP query = ( ( etable.pe _ id = = person.pe _ id ) &amp; ( etable.deleted = = False ) ) DCNL DCSP DCSP resource = s3db.resource ( &apos; pr _ contact _ emergency &apos; ) DCNL DCSP DCSP resource.add _ filter ( query ) DCNL DCSP DCSP fields = &#91; &apos; id &apos; , &apos; name &apos; , &apos; relationship &apos; , &apos; address &apos; , &apos; phone &apos; &#93; DCNL DCSP DCSP rows = resource.select ( fields ) .rows DCNL DCSP DCSP emergency _ wrapper = DIV ( H2 ( T ( &apos; Emergency DCSP Contacts &apos; ) ) ) DCNL DCSP DCSP if ( person _ update _ permission and has _ permission ( &apos; create &apos; , etable ) ) : DCNL DCSP DCSP DCSP add _ btn = DIV ( A ( T ( &apos; Add &apos; ) , _ class = &apos; action-btn &apos; , _ id = &apos; emergency-add &apos; ) , DIV ( _ id = &apos; emergency-add _ throbber &apos; , _ class = &apos; throbber DCSP hide &apos; ) , _ class = &apos; margin &apos; ) DCNL DCSP DCSP DCSP emergency _ wrapper.append ( add _ btn ) DCNL DCSP DCSP readable _ fields = &#91; f for f in fields if ( etable &#91; f &#93; .readable and ( f ! = &apos; id &apos; ) ) &#93; DCNL DCSP DCSP for row in rows : DCNL DCSP DCSP DCSP data = &#91; ( row &#91; ( &apos; pr _ contact _ emergency . % s &apos; % f ) &#93; or &apos; &apos; ) for f in readable _ fields &#93; DCNL DCSP DCSP DCSP record _ id = row &#91; &apos; pr _ contact _ emergency.id &apos; &#93; DCNL DCSP DCSP DCSP ( edit _ btn , delete _ btn ) = action _ buttons ( etable , record _ id ) DCNL DCSP DCSP DCSP emergency _ wrapper.append ( P ( SPAN ( &apos; , DCSP &apos; .join ( data ) ) , edit _ btn , delete _ btn , _ id = ( &apos; emergency- % s &apos; % record _ id ) , _ class = &apos; emergency &apos; ) ) DCNL DCSP content = DIV ( contacts _ wrapper , emergency _ wrapper , _ class = &apos; contacts-wrapper &apos; ) DCNL DCSP if s3.debug : DCNL DCSP DCSP s3.scripts.append ( URL ( c = &apos; static &apos; , f = &apos; scripts &apos; , args = &#91; &apos; S3 &apos; , &apos; s3.contacts.js &apos; &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP s3.scripts.append ( URL ( c = &apos; static &apos; , f = &apos; scripts &apos; , args = &#91; &apos; S3 &apos; , &apos; s3.contacts.min.js &apos; &#93; ) ) DCNL DCSP s3.js _ global + = &#91; ( &quot; S3.pr _ contacts _ controller = &apos; % s &apos; &quot; % current.request.controller ) , ( &apos; S3.pr _ contacts _ person _ id = % s &apos; % person.id ) &#93; DCNL DCSP if access : DCNL DCSP DCSP s3.js _ global.append ( ( &apos; S3.pr _ contacts _ access = % s &apos; % access ) ) DCNL DCSP response.view = &apos; pr / contacts.html &apos; DCNL DCSP rheader = attr.get ( &apos; rheader &apos; , None ) DCNL DCSP if callable ( rheader ) : DCNL DCSP DCSP rheader = rheader ( r ) DCNL DCSP return dict ( content = content , rheader = rheader , title = T ( &apos; Contacts &apos; ) )
DCSP if ( border _ mode not in ( &apos; valid &apos; , 0 , ( 0 , ) ) ) : DCNL DCSP DCSP raise RuntimeError ( ( &apos; Unsupported DCSP border _ mode DCSP for DCSP conv1d _ md : DCSP % s &apos; % border _ mode ) ) DCNL DCSP ( batch _ size , num _ input _ channels , input _ length ) = image _ shape DCNL DCSP ( num _ filters , num _ input _ channels _ , filter _ length ) = filter _ shape DCNL DCSP stride = subsample &#91; 0 &#93; DCNL DCSP if ( ( filter _ length % stride ) &gt; 0 ) : DCNL DCSP DCSP raise RuntimeError ( ( &apos; Filter DCSP length DCSP ( % d ) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP stride DCSP ( % d ) &apos; % ( filter _ length , stride ) ) ) DCNL DCSP num _ steps = ( filter _ length / / stride ) DCNL DCSP output _ length = ( ( ( input _ length - filter _ length ) + stride ) / / stride ) DCNL DCSP output _ shape = ( batch _ size , num _ filters , output _ length ) DCNL DCSP filters _ flipped = ( filters &#91; : , : , : : ( -1 ) &#93; if filter _ flip else filters ) DCNL DCSP conved = T.zeros ( output _ shape ) DCNL DCSP for num in range ( num _ steps ) : DCNL DCSP DCSP shift = ( num * stride ) DCNL DCSP DCSP length = ( ( input _ length - shift ) / / filter _ length ) DCNL DCSP DCSP if ( length = = 0 ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP r _ input _ shape = ( batch _ size , num _ input _ channels , length , filter _ length ) DCNL DCSP DCSP r _ input = input &#91; : , : , shift : ( ( length * filter _ length ) + shift ) &#93; .reshape ( r _ input _ shape ) DCNL DCSP DCSP r _ conved = T.tensordot ( r _ input , filters _ flipped , np.asarray ( &#91; &#91; 1 , 3 &#93; , &#91; 1 , 2 &#93; &#93; ) ) DCNL DCSP DCSP r _ conved = r _ conved.dimshuffle ( 0 , 2 , 1 ) DCNL DCSP DCSP conved = T.set _ subtensor ( conved &#91; : , : , num : : num _ steps &#93; , r _ conved ) DCNL DCSP return conved
DCSP sitedirs = &#91; &#93; DCNL DCSP seen = &#91; &#93; DCNL DCSP for prefix in PREFIXES : DCNL DCSP DCSP if ( ( not prefix ) or ( prefix in seen ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP seen.append ( prefix ) DCNL DCSP DCSP if ( sys.platform in ( &apos; os2emx &apos; , &apos; riscos &apos; ) ) : DCNL DCSP DCSP DCSP sitedirs.append ( os.path.join ( prefix , &apos; Lib &apos; , &apos; site-packages &apos; ) ) DCNL DCSP DCSP elif ( os.sep = = &apos; / &apos; ) : DCNL DCSP DCSP DCSP sitedirs.append ( os.path.join ( prefix , &apos; lib &apos; , ( &apos; python &apos; + sys.version &#91; : 3 &#93; ) , &apos; site-packages &apos; ) ) DCNL DCSP DCSP DCSP sitedirs.append ( os.path.join ( prefix , &apos; lib &apos; , &apos; site-python &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sitedirs.append ( prefix ) DCNL DCSP DCSP DCSP sitedirs.append ( os.path.join ( prefix , &apos; lib &apos; , &apos; site-packages &apos; ) ) DCNL DCSP DCSP if ( sys.platform = = &apos; darwin &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; Python.framework &apos; in prefix ) : DCNL DCSP DCSP DCSP DCSP sitedirs.append ( os.path.expanduser ( os.path.join ( &apos; ~ &apos; , &apos; Library &apos; , &apos; Python &apos; , sys.version &#91; : 3 &#93; , &apos; site-packages &apos; ) ) ) DCNL DCSP for sitedir in sitedirs : DCNL DCSP DCSP if os.path.isdir ( sitedir ) : DCNL DCSP DCSP DCSP addsitedir ( sitedir , known _ paths ) DCNL DCSP return known _ paths
DCSP if ( r.representation ! = &apos; html &apos; ) : DCNL DCSP DCSP return None DCNL DCSP record = r.record DCNL DCSP if ( not record ) : DCNL DCSP DCSP return None DCNL DCSP settings = current.deployment _ settings DCNL DCSP has _ permission = current.auth.s3 _ has _ permission DCNL DCSP T = current.T DCNL DCSP table = r.table DCNL DCSP tablename = r.tablename DCNL DCSP rheader = None DCNL DCSP resourcename = r.name DCNL DCSP if ( resourcename = = &apos; alert &apos; ) : DCNL DCSP DCSP alert _ id = r.id DCNL DCSP DCSP db = current.db DCNL DCSP DCSP ltable = db.deploy _ alert _ recipient DCNL DCSP DCSP query = ( ( ltable.alert _ id = = alert _ id ) &amp; ( ltable.deleted = = False ) ) DCNL DCSP DCSP recipients = db ( query ) .count ( ) DCNL DCSP DCSP unsent = ( not r.record.message _ id ) DCNL DCSP DCSP authorised = has _ permission ( &apos; update &apos; , tablename , record _ id = alert _ id ) DCNL DCSP DCSP if ( unsent and authorised ) : DCNL DCSP DCSP DCSP send _ button = BUTTON ( T ( &apos; Send DCSP Alert &apos; ) , _ class = &apos; alert-send-btn &apos; ) DCNL DCSP DCSP DCSP if recipients : DCNL DCSP DCSP DCSP DCSP send _ button.update ( _ onclick = ( &quot; window.location.href = &apos; % s &apos; &quot; % URL ( c = &apos; deploy &apos; , f = &apos; alert &apos; , args = &#91; alert _ id , &apos; send &apos; &#93; ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP send _ button.update ( _ disabled = &apos; disabled &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP send _ button = &apos; &apos; DCNL DCSP DCSP if settings.get _ deploy _ cc _ groups ( ) : DCNL DCSP DCSP DCSP cc = TR ( TH ( ( &apos; % s : DCSP &apos; % table.cc.label ) ) , s3 _ yes _ no _ represent ( record.cc ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cc = &apos; &apos; DCNL DCSP DCSP tabs = &#91; ( T ( &apos; Message &apos; ) , None ) , ( ( T ( &apos; Recipients DCSP ( % ( number ) s DCSP Total ) &apos; ) % { &apos; number &apos; : recipients } ) , &apos; recipient &apos; ) &#93; DCNL DCSP DCSP if ( unsent and authorised and settings.get _ deploy _ manual _ recipients ( ) ) : DCNL DCSP DCSP DCSP tabs.insert ( 1 , ( T ( &apos; Select DCSP Recipients &apos; ) , &apos; select &apos; ) ) DCNL DCSP DCSP rheader _ tabs = s3 _ rheader _ tabs ( r , tabs ) DCNL DCSP DCSP rheader = DIV ( TABLE ( TR ( TH ( ( &apos; % s : DCSP &apos; % table.mission _ id.label ) ) , table.mission _ id.represent ( record.mission _ id ) , send _ button ) , TR ( TH ( ( &apos; % s : DCSP &apos; % table.subject.label ) ) , record.subject ) , cc ) , rheader _ tabs , _ class = &apos; alert-rheader &apos; ) DCNL DCSP elif ( resourcename = = &apos; mission &apos; ) : DCNL DCSP DCSP if ( ( not profile ) and ( not r.component ) ) : DCNL DCSP DCSP DCSP rheader = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP crud _ string = S3Method.crud _ string DCNL DCSP DCSP DCSP record = r.record DCNL DCSP DCSP DCSP title = crud _ string ( r.tablename , &apos; title _ display &apos; ) DCNL DCSP DCSP DCSP if record : DCNL DCSP DCSP DCSP DCSP title = ( &apos; % s : DCSP % s &apos; % ( title , record.name ) ) DCNL DCSP DCSP DCSP DCSP edit _ btn = &apos; &apos; DCNL DCSP DCSP DCSP DCSP if ( profile and has _ permission ( &apos; update &apos; , &apos; deploy _ mission &apos; , record _ id = r.id ) ) : DCNL DCSP DCSP DCSP DCSP DCSP crud _ button = S3CRUD.crud _ button DCNL DCSP DCSP DCSP DCSP DCSP edit _ btn = crud _ button ( T ( &apos; Edit &apos; ) , _ href = r.url ( method = &apos; update &apos; ) ) DCNL DCSP DCSP DCSP DCSP label = ( lambda f , table = table , record = record , * * attr : TH ( ( &apos; % s : DCSP &apos; % table &#91; f &#93; .label ) , * * attr ) ) DCNL DCSP DCSP DCSP DCSP value = ( lambda f , table = table , record = record , * * attr : TD ( table &#91; f &#93; .represent ( record &#91; f &#93; ) , * * attr ) ) DCNL DCSP DCSP DCSP DCSP if settings.has _ module ( &apos; event &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP row1 = TR ( label ( &apos; event _ type _ id &apos; ) , value ( &apos; event _ type _ id &apos; ) , label ( &apos; location _ id &apos; ) , value ( &apos; location _ id &apos; ) , label ( &apos; code &apos; ) , value ( &apos; code &apos; ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP row1 = TR ( label ( &apos; location _ id &apos; ) , value ( &apos; location _ id &apos; ) , label ( &apos; code &apos; ) , value ( &apos; code &apos; ) ) DCNL DCSP DCSP DCSP DCSP rheader = DIV ( H2 ( title ) , TABLE ( row1 , TR ( label ( &apos; date &apos; ) , value ( &apos; date &apos; ) , label ( &apos; status &apos; ) , value ( &apos; status &apos; ) ) , TR ( label ( &apos; comments &apos; ) , value ( &apos; comments &apos; , _ class = &apos; mission-comments &apos; , _ colspan = &apos; 6&apos; ) ) ) , _ class = &apos; mission-rheader &apos; ) DCNL DCSP DCSP DCSP DCSP if edit _ btn : DCNL DCSP DCSP DCSP DCSP DCSP rheader &#91; ( -1 ) &#93; &#91; 0 &#93; .append ( edit _ btn ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP rheader = H2 ( title ) DCNL DCSP return rheader
DCSP counts = collections.Counter ( truth _ text ) DCNL DCSP counts.subtract ( ocr _ text ) DCNL DCSP drops = sum ( ( c for c in counts.values ( ) if ( c &gt; 0 ) ) ) DCNL DCSP adds = sum ( ( ( - c ) for c in counts.values ( ) if ( c &lt; 0 ) ) ) DCNL DCSP return ErrorCounts ( drops , adds , len ( truth _ text ) , len ( ocr _ text ) )
DCSP shifts = six.moves.xrange ( ( num _ bits - 8 ) , ( -8 ) , ( -8 ) ) DCNL DCSP def byte _ at ( off ) : DCNL DCSP DCSP return ( ( ( value &gt; &gt; off ) if ( off &gt; = 0 ) else ( value &lt; &lt; ( - off ) ) ) &amp; 255 ) DCNL DCSP return &apos; &apos;.join ( ( six.unichr ( byte _ at ( offset ) ) for offset in shifts ) )
DCSP return _ script ( name , source , saltenv = saltenv , args = args , template = template , exec _ driver = exec _ driver , stdin = stdin , python _ shell = python _ shell , output _ loglevel = output _ loglevel , ignore _ retcode = ignore _ retcode , use _ vt = use _ vt , keep _ env = keep _ env )
DCSP tempfile _ stream = NamedTemporaryFile ( suffix = suffix , delete = False ) DCNL DCSP tempfile = tempfile _ stream.name DCNL DCSP tempfile _ stream.close ( ) DCNL DCSP ( yield tempfile ) DCNL DCSP os.remove ( tempfile )
DCSP valid = { &apos; yes &apos; : &apos; yes &apos; , &apos; y &apos; : &apos; yes &apos; , &apos; ye &apos; : &apos; yes &apos; , &apos; no &apos; : &apos; no &apos; , &apos; n &apos; : &apos; no &apos; } DCNL DCSP if ( default is None ) : DCNL DCSP DCSP prompt = &apos; DCSP &#91; y / n &#93; DCSP &apos; DCNL DCSP elif ( default = = &apos; yes &apos; ) : DCNL DCSP DCSP prompt = &apos; DCSP &#91; Y / n &#93; DCSP &apos; DCNL DCSP elif ( default = = &apos; no &apos; ) : DCNL DCSP DCSP prompt = &apos; DCSP &#91; y / N &#93; DCSP &apos; DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &quot; invalid DCSP default DCSP answer : DCSP &apos; % s &apos; &quot; % default ) ) DCNL DCSP while 1 : DCNL DCSP DCSP sys.stdout.write ( ( question + prompt ) ) DCNL DCSP DCSP choice = raw _ input ( ) .lower ( ) DCNL DCSP DCSP if ( ( default is not None ) and ( choice = = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP return default DCNL DCSP DCSP elif ( choice in valid.keys ( ) ) : DCNL DCSP DCSP DCSP return valid &#91; choice &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sys.stdout.write ( &quot; Please DCSP respond DCSP with DCSP &apos; yes &apos; DCSP or DCSP &apos; no &apos; DCSP ( or DCSP &apos; y &apos; DCSP or DCSP &apos; n &apos; ) . \ n &quot; )
DCSP replaced = replace _ hy _ obj ( str _ type ( &apos; foo &apos; ) , HyString ( &apos; bar &apos; ) ) DCNL DCSP assert ( replaced = = HyString ( &apos; foo &apos; ) )
DCSP if ( nin = = None ) : DCNL DCSP DCSP nin = options &#91; &apos; dim _ proj &apos; &#93; DCNL DCSP if ( nout = = None ) : DCNL DCSP DCSP nout = options &#91; &apos; dim _ proj &apos; &#93; DCNL DCSP params &#91; _ p ( prefix , &apos; W &apos; ) &#93; = norm _ weight ( nin , nout , ortho = ortho ) DCNL DCSP params &#91; _ p ( prefix , &apos; b &apos; ) &#93; = numpy.zeros ( ( nout , ) ) .astype ( &apos; float32 &apos; ) DCNL DCSP return params
DCSP if ( randfunc is None ) : DCNL DCSP DCSP randfunc = Random.get _ random _ bytes DCNL DCSP return PKCS115 _ Cipher ( key , randfunc )
DCSP if ( request _ or _ response not in _ urlparse _ cache ) : DCNL DCSP DCSP _ urlparse _ cache &#91; request _ or _ response &#93; = urlparse ( request _ or _ response.url ) DCNL DCSP return _ urlparse _ cache &#91; request _ or _ response &#93;
DCSP diff = ( d1 - d2 ) DCNL DCSP if ( ( weights is None ) or ( r &#91; 0 &#93; = = 0 ) ) : DCNL DCSP DCSP return np.all ( ( ( r * diff ) = = 0 ) ) DCNL DCSP else : DCNL DCSP DCSP return ( weights &#91; diff &#93; * np.all ( ( ( r &#91; 1 : &#93; * diff &#91; 1 : &#93; ) = = 0 ) ) )
DCSP client _ id = SETTINGS &#91; &apos; WNS _ PACKAGE _ SECURITY _ ID &apos; &#93; DCNL DCSP if ( not client _ id ) : DCNL DCSP DCSP raise ImproperlyConfigured ( &apos; You DCSP need DCSP to DCSP set DCSP PUSH _ NOTIFICATIONS _ SETTINGS &#91; &quot; WNS _ PACKAGE _ SECURITY _ ID &quot; &#93; DCSP to DCSP use DCSP WNS . &apos; ) DCNL DCSP client _ secret = SETTINGS &#91; &apos; WNS _ SECRET _ KEY &apos; &#93; DCNL DCSP if ( not client _ secret ) : DCNL DCSP DCSP raise ImproperlyConfigured ( &apos; You DCSP need DCSP to DCSP set DCSP PUSH _ NOTIFICATIONS _ SETTINGS &#91; &quot; WNS _ SECRET _ KEY &quot; &#93; DCSP to DCSP use DCSP WNS . &apos; ) DCNL DCSP headers = { &apos; Content-Type &apos; : &apos; application / x-www-form-urlencoded &apos; } DCNL DCSP params = { &apos; grant _ type &apos; : &apos; client _ credentials &apos; , &apos; client _ id &apos; : client _ id , &apos; client _ secret &apos; : client _ secret , &apos; scope &apos; : scope } DCNL DCSP data = urlencode ( params ) .encode ( &apos; utf-8 &apos; ) DCNL DCSP request = Request ( SETTINGS &#91; &apos; WNS _ ACCESS _ URL &apos; &#93; , data = data , headers = headers ) DCNL DCSP try : DCNL DCSP DCSP response = urlopen ( request ) DCNL DCSP except HTTPError as err : DCNL DCSP DCSP if ( err.code = = 400 ) : DCNL DCSP DCSP DCSP raise WNSAuthenticationError ( &apos; Authentication DCSP failed , DCSP check DCSP your DCSP WNS DCSP settings . &apos; ) DCNL DCSP DCSP raise err DCNL DCSP oauth _ data = response.read ( ) .decode ( &apos; utf-8 &apos; ) DCNL DCSP try : DCNL DCSP DCSP oauth _ data = json.loads ( oauth _ data ) DCNL DCSP except Exception : DCNL DCSP DCSP raise WNSAuthenticationError ( &apos; Received DCSP invalid DCSP JSON DCSP data DCSP from DCSP WNS . &apos; ) DCNL DCSP access _ token = oauth _ data.get ( &apos; access _ token &apos; ) DCNL DCSP if ( not access _ token ) : DCNL DCSP DCSP raise WNSAuthenticationError ( &apos; Access DCSP token DCSP missing DCSP from DCSP WNS DCSP response . &apos; ) DCNL DCSP return access _ token
DCSP lines = &#91; &apos; qutebrowser DCSP v { } &apos; .format ( qutebrowser . _ _ version _ _ ) &#93; DCNL DCSP gitver = _ git _ str ( ) DCNL DCSP if ( gitver is not None ) : DCNL DCSP DCSP lines.append ( &apos; Git DCSP commit : DCSP { } &apos; .format ( gitver ) ) DCNL DCSP if ( qVersion ( ) ! = QT _ VERSION _ STR ) : DCNL DCSP DCSP qt _ version = &apos; Qt : DCSP { } DCSP ( compiled DCSP { } ) &apos; .format ( qVersion ( ) , QT _ VERSION _ STR ) DCNL DCSP else : DCNL DCSP DCSP qt _ version = &apos; Qt : DCSP { } &apos; .format ( qVersion ( ) ) DCNL DCSP lines + = &#91; &apos; &apos; , &apos; { } : DCSP { } &apos; .format ( platform.python _ implementation ( ) , platform.python _ version ( ) ) , qt _ version , &apos; PyQt : DCSP { } &apos; .format ( PYQT _ VERSION _ STR ) , &apos; &apos; &#93; DCNL DCSP lines + = _ module _ versions ( ) DCNL DCSP lines + = &#91; &apos; pdf.js : DCSP { } &apos; .format ( _ pdfjs _ version ( ) ) &#93; DCNL DCSP if ( qWebKitVersion is None ) : DCNL DCSP DCSP lines.append ( &apos; Webkit : DCSP no &apos; ) DCNL DCSP else : DCNL DCSP DCSP lines.append ( &apos; Webkit : DCSP { } &apos; .format ( qWebKitVersion ( ) ) ) DCNL DCSP lines + = &#91; &apos; SSL : DCSP { } &apos; .format ( QSslSocket.sslLibraryVersionString ( ) ) , &apos; &apos; &#93; DCNL DCSP qapp = QApplication.instance ( ) DCNL DCSP if qapp : DCNL DCSP DCSP style = qapp.style ( ) DCNL DCSP DCSP lines.append ( &apos; Style : DCSP { } &apos; .format ( style.metaObject ( ) .className ( ) ) ) DCNL DCSP importpath = os.path.dirname ( os.path.abspath ( qutebrowser . _ _ file _ _ ) ) DCNL DCSP lines + = &#91; &apos; Platform : DCSP { } , DCSP { } &apos; .format ( platform.platform ( ) , platform.architecture ( ) &#91; 0 &#93; ) , &apos; Frozen : DCSP { } &apos; .format ( hasattr ( sys , &apos; frozen &apos; ) ) , &apos; Imported DCSP from DCSP { } &apos; .format ( importpath ) &#93; DCNL DCSP lines + = _ os _ info ( ) DCNL DCSP lines + = &#91; &apos; &apos; , &apos; Paths : &apos; &#93; DCNL DCSP for ( name , path ) in _ path _ info ( ) .items ( ) : DCNL DCSP DCSP lines + = &#91; &apos; { } : DCSP { } &apos; .format ( name , path ) &#93; DCNL DCSP return &apos; \ n &apos; .join ( lines )
DCSP text = &apos; &lt; table &gt; &apos; DCNL DCSP for group in args : DCNL DCSP DCSP text + = &quot; &lt; tr &gt; &lt; td &gt; { } &lt; / td &gt; &lt; td DCSP style = &apos; color : DCSP { } &apos; &gt; { } &lt; / td &gt; &lt; td DCSP style = &apos; padding-left : DCSP 2ex &apos; &gt; { } &lt; / td &gt; &lt; / tr &gt; &quot; .format ( * group ) DCNL DCSP return ( text + &apos; &lt; / table &gt; &apos; )
DCSP import twill DCNL DCSP twill.set _ output ( None )
DCSP if ( ORIGINAL _ VERSION _ LINE is None ) : DCNL DCSP DCSP return DCNL DCSP with open ( u &apos;xonsh / _ _ init _ _ .py &apos; , u &apos;r &apos; ) as f : DCNL DCSP DCSP raw = f.read ( ) DCNL DCSP lines = raw.splitlines ( ) DCNL DCSP lines &#91; 0 &#93; = ORIGINAL _ VERSION _ LINE DCNL DCSP upd = ( u &apos; \ n &apos; .join ( lines ) + u &apos; \ n &apos; ) DCNL DCSP with open ( u &apos;xonsh / _ _ init _ _ .py &apos; , u &apos;w &apos; ) as f : DCNL DCSP DCSP f.write ( upd )
DCSP _ ip.run _ cell ( &quot; parrot DCSP = DCSP &apos; dead &apos; &quot; , store _ history = True ) DCNL DCSP _ ip.run _ cell ( &apos; parrot &apos; , store _ history = True ) DCNL DCSP nt.assert _ true ( ( &apos; dead &apos; in &#91; _ ip.user _ ns &#91; x &#93; for x in ( &apos; _ &apos; , &apos; _ _ &apos; , &apos; _ _ _ &apos; ) &#93; ) ) DCNL DCSP _ ip.magic ( &apos; reset DCSP -f DCSP out &apos; ) DCNL DCSP nt.assert _ false ( ( &apos; dead &apos; in &#91; _ ip.user _ ns &#91; x &#93; for x in ( &apos; _ &apos; , &apos; _ _ &apos; , &apos; _ _ _ &apos; ) &#93; ) ) DCNL DCSP nt.assert _ equal ( len ( _ ip.user _ ns &#91; &apos; Out &apos; &#93; ) , 0 )
DCSP policy _ check = utils _ settings.import _ setting ( &apos; POLICY _ CHECK _ FUNCTION &apos; ) DCNL DCSP if policy _ check : DCNL DCSP DCSP return policy _ check ( actions , request , target ) DCNL DCSP return True
DCSP return ( ( not match.private ) and ( match.name not in &#91; &apos; proper _ count &apos; , &apos; title &apos; , &apos; episode _ title &apos; , &apos; alternative _ title &apos; &#93; ) and ( not ( ( match.name = = &apos; container &apos; ) and ( &apos; extension &apos; in match.tags ) ) ) )
DCSP taken = &#91; dev.busNumber for dev in devices if _ is _ scsi _ controller ( dev ) &#93; DCNL DCSP for i in range ( constants.SCSI _ MAX _ CONTROLLER _ NUMBER ) : DCNL DCSP DCSP if ( i not in taken ) : DCNL DCSP DCSP DCSP return i DCNL DCSP msg = ( _ ( &apos; Only DCSP % d DCSP SCSI DCSP controllers DCSP are DCSP allowed DCSP to DCSP be DCSP created DCSP on DCSP this DCSP instance . &apos; ) % constants.SCSI _ MAX _ CONTROLLER _ NUMBER ) DCNL DCSP raise vexc.VMwareDriverException ( msg )
DCSP return xyz2rgb ( lab2xyz ( lab , illuminant , observer ) )
DCSP u = _ validate _ vector ( u ) DCNL DCSP v = _ validate _ vector ( v ) DCNL DCSP if ( p &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; p DCSP must DCSP be DCSP at DCSP least DCSP 1 &apos; ) DCNL DCSP dist = norm ( ( u - v ) , ord = p ) DCNL DCSP return dist
DCSP if ( call ! = &apos; action &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP keepvol _ on _ destroy DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -a DCSP or DCSP --action . &apos; ) DCNL DCSP if ( not kwargs ) : DCNL DCSP DCSP kwargs = { } DCNL DCSP device = kwargs.get ( &apos; device &apos; , None ) DCNL DCSP volume _ id = kwargs.get ( &apos; volume _ id &apos; , None ) DCNL DCSP return _ toggle _ delvol ( name = name , device = device , volume _ id = volume _ id , value = &apos; false &apos; )
DCSP class ABCTest ( fixtures.MappedTest , ) : DCNL DCSP DCSP @ classmethod DCNL DCSP DCSP def define _ tables ( cls , metadata ) : DCNL DCSP DCSP DCSP global ta , tb , tc DCNL DCSP DCSP DCSP ta = &#91; &apos; a &apos; , metadata &#93; DCNL DCSP DCSP DCSP ( ta.append ( Column ( &apos; id &apos; , Integer , primary _ key = True , test _ needs _ autoincrement = True ) ) , ) DCNL DCSP DCSP DCSP ta.append ( Column ( &apos; a _ data &apos; , String ( 30 ) ) ) DCNL DCSP DCSP DCSP if ( ( &apos; a &apos; = = parent ) and ( direction = = MANYTOONE ) ) : DCNL DCSP DCSP DCSP DCSP ta.append ( Column ( &apos; child _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % child ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP elif ( ( &apos; a &apos; = = child ) and ( direction = = ONETOMANY ) ) : DCNL DCSP DCSP DCSP DCSP ta.append ( Column ( &apos; parent _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % parent ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP ta = Table ( * ta ) DCNL DCSP DCSP DCSP tb = &#91; &apos; b &apos; , metadata &#93; DCNL DCSP DCSP DCSP tb.append ( Column ( &apos; id &apos; , Integer , ForeignKey ( &apos; a.id &apos; ) , primary _ key = True ) ) DCNL DCSP DCSP DCSP tb.append ( Column ( &apos; b _ data &apos; , String ( 30 ) ) ) DCNL DCSP DCSP DCSP if ( ( &apos; b &apos; = = parent ) and ( direction = = MANYTOONE ) ) : DCNL DCSP DCSP DCSP DCSP tb.append ( Column ( &apos; child _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % child ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP elif ( ( &apos; b &apos; = = child ) and ( direction = = ONETOMANY ) ) : DCNL DCSP DCSP DCSP DCSP tb.append ( Column ( &apos; parent _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % parent ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP tb = Table ( * tb ) DCNL DCSP DCSP DCSP tc = &#91; &apos; c &apos; , metadata &#93; DCNL DCSP DCSP DCSP tc.append ( Column ( &apos; id &apos; , Integer , ForeignKey ( &apos; b.id &apos; ) , primary _ key = True ) ) DCNL DCSP DCSP DCSP tc.append ( Column ( &apos; c _ data &apos; , String ( 30 ) ) ) DCNL DCSP DCSP DCSP if ( ( &apos; c &apos; = = parent ) and ( direction = = MANYTOONE ) ) : DCNL DCSP DCSP DCSP DCSP tc.append ( Column ( &apos; child _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % child ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP elif ( ( &apos; c &apos; = = child ) and ( direction = = ONETOMANY ) ) : DCNL DCSP DCSP DCSP DCSP tc.append ( Column ( &apos; parent _ id &apos; , Integer , ForeignKey ( ( &apos; % s.id &apos; % parent ) , use _ alter = True , name = &apos; foo &apos; ) ) ) DCNL DCSP DCSP DCSP tc = Table ( * tc ) DCNL DCSP DCSP def teardown ( self ) : DCNL DCSP DCSP DCSP if ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP parent _ table = { &apos; a &apos; : ta , &apos; b &apos; : tb , &apos; c &apos; : tc } &#91; parent &#93; DCNL DCSP DCSP DCSP DCSP parent _ table.update ( values = { parent _ table.c.child _ id : None } ) .execute ( ) DCNL DCSP DCSP DCSP elif ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP child _ table = { &apos; a &apos; : ta , &apos; b &apos; : tb , &apos; c &apos; : tc } &#91; child &#93; DCNL DCSP DCSP DCSP DCSP child _ table.update ( values = { child _ table.c.parent _ id : None } ) .execute ( ) DCNL DCSP DCSP DCSP super ( ABCTest , self ) .teardown ( ) DCNL DCSP DCSP def test _ roundtrip ( self ) : DCNL DCSP DCSP DCSP parent _ table = { &apos; a &apos; : ta , &apos; b &apos; : tb , &apos; c &apos; : tc } &#91; parent &#93; DCNL DCSP DCSP DCSP child _ table = { &apos; a &apos; : ta , &apos; b &apos; : tb , &apos; c &apos; : tc } &#91; child &#93; DCNL DCSP DCSP DCSP remote _ side = None DCNL DCSP DCSP DCSP if ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP foreign _ keys = &#91; parent _ table.c.child _ id &#93; DCNL DCSP DCSP DCSP elif ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP foreign _ keys = &#91; child _ table.c.parent _ id &#93; DCNL DCSP DCSP DCSP atob = ( ta.c.id = = tb.c.id ) DCNL DCSP DCSP DCSP btoc = ( tc.c.id = = tb.c.id ) DCNL DCSP DCSP DCSP if ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP relationshipjoin = ( parent _ table.c.id = = child _ table.c.parent _ id ) DCNL DCSP DCSP DCSP elif ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP relationshipjoin = ( parent _ table.c.child _ id = = child _ table.c.id ) DCNL DCSP DCSP DCSP DCSP if ( parent is child ) : DCNL DCSP DCSP DCSP DCSP DCSP remote _ side = &#91; child _ table.c.id &#93; DCNL DCSP DCSP DCSP abcjoin = polymorphic _ union ( { &apos; a &apos; : ta.select ( ( tb.c.id = = None ) , from _ obj = &#91; ta.outerjoin ( tb , onclause = atob ) &#93; ) , &apos; b &apos; : ta.join ( tb , onclause = atob ) .outerjoin ( tc , onclause = btoc ) .select ( ( tc.c.id = = None ) ) .reduce _ columns ( ) , &apos; c &apos; : tc.join ( tb , onclause = btoc ) .join ( ta , onclause = atob ) } , &apos; type &apos; , &apos; abcjoin &apos; ) DCNL DCSP DCSP DCSP bcjoin = polymorphic _ union ( { &apos; b &apos; : ta.join ( tb , onclause = atob ) .outerjoin ( tc , onclause = btoc ) .select ( ( tc.c.id = = None ) ) .reduce _ columns ( ) , &apos; c &apos; : tc.join ( tb , onclause = btoc ) .join ( ta , onclause = atob ) } , &apos; type &apos; , &apos; bcjoin &apos; ) DCNL DCSP DCSP DCSP class A ( object , ) : DCNL DCSP DCSP DCSP DCSP def _ _ init _ _ ( self , name ) : DCNL DCSP DCSP DCSP DCSP DCSP self.a _ data = name DCNL DCSP DCSP DCSP class B ( A , ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP class C ( B , ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP mapper ( A , ta , polymorphic _ on = abcjoin.c.type , with _ polymorphic = ( &apos; * &apos; , abcjoin ) , polymorphic _ identity = &apos; a &apos; ) DCNL DCSP DCSP DCSP mapper ( B , tb , polymorphic _ on = bcjoin.c.type , with _ polymorphic = ( &apos; * &apos; , bcjoin ) , polymorphic _ identity = &apos; b &apos; , inherits = A , inherit _ condition = atob ) DCNL DCSP DCSP DCSP mapper ( C , tc , polymorphic _ identity = &apos; c &apos; , inherits = B , inherit _ condition = btoc ) DCNL DCSP DCSP DCSP parent _ mapper = class _ mapper ( { ta : A , tb : B , tc : C } &#91; parent _ table &#93; ) DCNL DCSP DCSP DCSP child _ mapper = class _ mapper ( { ta : A , tb : B , tc : C } &#91; child _ table &#93; ) DCNL DCSP DCSP DCSP parent _ class = parent _ mapper.class _ DCNL DCSP DCSP DCSP child _ class = child _ mapper.class _ DCNL DCSP DCSP DCSP parent _ mapper.add _ property ( &apos; collection &apos; , relationship ( child _ mapper , primaryjoin = relationshipjoin , foreign _ keys = foreign _ keys , order _ by = child _ mapper.c.id , remote _ side = remote _ side , uselist = True ) ) DCNL DCSP DCSP DCSP sess = create _ session ( ) DCNL DCSP DCSP DCSP parent _ obj = parent _ class ( &apos; parent1 &apos; ) DCNL DCSP DCSP DCSP child _ obj = child _ class ( &apos; child1 &apos; ) DCNL DCSP DCSP DCSP somea = A ( &apos; somea &apos; ) DCNL DCSP DCSP DCSP someb = B ( &apos; someb &apos; ) DCNL DCSP DCSP DCSP somec = C ( &apos; somec &apos; ) DCNL DCSP DCSP DCSP sess.add ( parent _ obj ) DCNL DCSP DCSP DCSP parent _ obj.collection.append ( child _ obj ) DCNL DCSP DCSP DCSP if ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP child2 = child _ class ( &apos; child2 &apos; ) DCNL DCSP DCSP DCSP DCSP parent _ obj.collection.append ( child2 ) DCNL DCSP DCSP DCSP DCSP sess.add ( child2 ) DCNL DCSP DCSP DCSP elif ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP parent2 = parent _ class ( &apos; parent2 &apos; ) DCNL DCSP DCSP DCSP DCSP parent2.collection.append ( child _ obj ) DCNL DCSP DCSP DCSP DCSP sess.add ( parent2 ) DCNL DCSP DCSP DCSP sess.add ( somea ) DCNL DCSP DCSP DCSP sess.add ( someb ) DCNL DCSP DCSP DCSP sess.add ( somec ) DCNL DCSP DCSP DCSP sess.flush ( ) DCNL DCSP DCSP DCSP sess.expunge _ all ( ) DCNL DCSP DCSP DCSP result = sess.query ( parent _ class ) .get ( parent _ obj.id ) DCNL DCSP DCSP DCSP assert ( result.id = = parent _ obj.id ) DCNL DCSP DCSP DCSP assert ( result.collection &#91; 0 &#93; .id = = child _ obj.id ) DCNL DCSP DCSP DCSP if ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP assert ( result.collection &#91; 1 &#93; .id = = child2.id ) DCNL DCSP DCSP DCSP elif ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP result2 = sess.query ( parent _ class ) .get ( parent2.id ) DCNL DCSP DCSP DCSP DCSP assert ( result2.id = = parent2.id ) DCNL DCSP DCSP DCSP DCSP assert ( result2.collection &#91; 0 &#93; .id = = child _ obj.id ) DCNL DCSP DCSP DCSP sess.expunge _ all ( ) DCNL DCSP DCSP DCSP result = sess.query ( A ) .filter _ by ( id = parent _ obj.id ) .one ( ) DCNL DCSP DCSP DCSP assert ( result.id = = parent _ obj.id ) DCNL DCSP DCSP DCSP assert ( result.collection &#91; 0 &#93; .id = = child _ obj.id ) DCNL DCSP DCSP DCSP if ( direction = = ONETOMANY ) : DCNL DCSP DCSP DCSP DCSP assert ( result.collection &#91; 1 &#93; .id = = child2.id ) DCNL DCSP DCSP DCSP elif ( direction = = MANYTOONE ) : DCNL DCSP DCSP DCSP DCSP result2 = sess.query ( A ) .filter _ by ( id = parent2.id ) .one ( ) DCNL DCSP DCSP DCSP DCSP assert ( result2.id = = parent2.id ) DCNL DCSP DCSP DCSP DCSP assert ( result2.collection &#91; 0 &#93; .id = = child _ obj.id ) DCNL DCSP ABCTest . _ _ name _ _ = ( &apos; Test % sTo % s % s &apos; % ( parent , child , ( ( ( direction is ONETOMANY ) and &apos; O2M &apos; ) or &apos; M2O &apos; ) ) ) DCNL DCSP return ABCTest
DCSP retVal = filepath DCNL DCSP if retVal : DCNL DCSP DCSP retVal = retVal.strip ( &apos; \ r \ n &apos; ) DCNL DCSP DCSP retVal = ( ntpath.normpath ( retVal ) if isWindowsDriveLetterPath ( retVal ) else posixpath.normpath ( retVal ) ) DCNL DCSP return retVal
DCSP s = s.strip ( ) DCNL DCSP result = &#91; &#93; DCNL DCSP word = &#91; &#93; DCNL DCSP inQuote = inWord = False DCNL DCSP for ( i , c ) in enumerate ( iterbytes ( s ) ) : DCNL DCSP DCSP if ( c = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP if ( i and ( s &#91; ( i - 1 ) : i &#93; = = &apos; \ \ &apos; ) ) : DCNL DCSP DCSP DCSP DCSP word.pop ( ) DCNL DCSP DCSP DCSP DCSP word.append ( &apos; &quot; &apos; ) DCNL DCSP DCSP DCSP elif ( not inQuote ) : DCNL DCSP DCSP DCSP DCSP inQuote = True DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP inQuote = False DCNL DCSP DCSP DCSP DCSP result.append ( &apos; &apos;.join ( word ) ) DCNL DCSP DCSP DCSP DCSP word = &#91; &#93; DCNL DCSP DCSP elif ( ( not inWord ) and ( not inQuote ) and ( c not in ( &apos; &quot; &apos; + string.whitespace.encode ( &apos; ascii &apos; ) ) ) ) : DCNL DCSP DCSP DCSP inWord = True DCNL DCSP DCSP DCSP word.append ( c ) DCNL DCSP DCSP elif ( inWord and ( not inQuote ) and ( c in string.whitespace.encode ( &apos; ascii &apos; ) ) ) : DCNL DCSP DCSP DCSP w = &apos; &apos;.join ( word ) DCNL DCSP DCSP DCSP if ( w = = &apos; NIL &apos; ) : DCNL DCSP DCSP DCSP DCSP result.append ( None ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP result.append ( w ) DCNL DCSP DCSP DCSP word = &#91; &#93; DCNL DCSP DCSP DCSP inWord = False DCNL DCSP DCSP elif ( inWord or inQuote ) : DCNL DCSP DCSP DCSP word.append ( c ) DCNL DCSP if inQuote : DCNL DCSP DCSP raise MismatchedQuoting ( s ) DCNL DCSP if inWord : DCNL DCSP DCSP w = &apos; &apos;.join ( word ) DCNL DCSP DCSP if ( w = = &apos; NIL &apos; ) : DCNL DCSP DCSP DCSP result.append ( None ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result.append ( w ) DCNL DCSP return result
DCSP user = request.user.profile DCNL DCSP query = ( Q ( reply _ to _ _ isnull = True ) &amp; ( ~ Q ( read _ by = user ) ) ) DCNL DCSP if request.GET : DCNL DCSP DCSP query = ( query &amp; _ get _ filter _ query ( request.GET ) ) DCNL DCSP DCSP objects = Object.filter _ by _ request ( request , Message.objects.filter ( query ) ) DCNL DCSP else : DCNL DCSP DCSP objects = Object.filter _ by _ request ( request , Message.objects.filter ( query ) ) DCNL DCSP filters = FilterForm ( request.user.profile , &apos; title &apos; , request.GET ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; filters &apos; : filters , &apos; messages &apos; : objects } ) DCNL DCSP return render _ to _ response ( &apos; messaging / unread &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP return None
DCSP try : DCNL DCSP DCSP return unicode ( value , &apos; us-ascii &apos; ) DCNL DCSP except UnicodeError : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return unicode ( value , &apos; utf-8 &apos; ) DCNL DCSP DCSP except UnicodeError : DCNL DCSP DCSP DCSP return unicode ( value , &apos; iso8859 &apos; , &apos; ignore &apos; )
DCSP conn = _ auth ( profile ) DCNL DCSP return conn.server _ list _ detailed ( )
DCSP def to _ series ( right ) : DCNL DCSP DCSP msg = &apos; Unable DCSP to DCSP coerce DCSP to DCSP Series , DCSP length DCSP must DCSP be DCSP { 0 } : DCSP given DCSP { 1 } &apos; DCNL DCSP DCSP if ( ( axis is not None ) and ( left . _ get _ axis _ name ( axis ) = = &apos; index &apos; ) ) : DCNL DCSP DCSP DCSP if ( len ( left.index ) ! = len ( right ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg.format ( len ( left.index ) , len ( right ) ) ) DCNL DCSP DCSP DCSP right = left . _ constructor _ sliced ( right , index = left.index ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( len ( left.columns ) ! = len ( right ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg.format ( len ( left.columns ) , len ( right ) ) ) DCNL DCSP DCSP DCSP right = left . _ constructor _ sliced ( right , index = left.columns ) DCNL DCSP DCSP return right DCNL DCSP if isinstance ( right , ( list , tuple ) ) : DCNL DCSP DCSP right = to _ series ( right ) DCNL DCSP elif ( isinstance ( right , np.ndarray ) and right.ndim ) : DCNL DCSP DCSP if ( right.ndim = = 1 ) : DCNL DCSP DCSP DCSP right = to _ series ( right ) DCNL DCSP DCSP elif ( right.ndim = = 2 ) : DCNL DCSP DCSP DCSP if ( left.shape ! = right.shape ) : DCNL DCSP DCSP DCSP DCSP msg = &apos; Unable DCSP to DCSP coerce DCSP to DCSP DataFrame , DCSP shape DCSP must DCSP be DCSP { 0 } : DCSP given DCSP { 1 } &apos; DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg.format ( left.shape , right.shape ) ) DCNL DCSP DCSP DCSP right = left . _ constructor ( right , index = left.index , columns = left.columns ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP msg = &apos; Unable DCSP to DCSP coerce DCSP to DCSP Series / DataFrame , DCSP dim DCSP must DCSP be DCSP &lt; = DCSP 2 : DCSP { 0 } &apos; DCNL DCSP DCSP DCSP raise ValueError ( msg.format ( right.shape ) ) DCNL DCSP return right
DCSP if isinstance ( divisions , Iterator ) : DCNL DCSP DCSP divisions = list ( divisions ) DCNL DCSP if ( not len ( divisions ) ) : DCNL DCSP DCSP ( yield df ) DCNL DCSP else : DCNL DCSP DCSP divisions = np.array ( divisions ) DCNL DCSP DCSP df = df.sort _ index ( ) DCNL DCSP DCSP index = df.index DCNL DCSP DCSP if is _ categorical _ dtype ( index ) : DCNL DCSP DCSP DCSP index = index.as _ ordered ( ) DCNL DCSP DCSP indices = index.searchsorted ( divisions ) DCNL DCSP DCSP ( yield df.iloc &#91; : indices &#91; 0 &#93; &#93; ) DCNL DCSP DCSP for i in range ( ( len ( indices ) - 1 ) ) : DCNL DCSP DCSP DCSP ( yield df.iloc &#91; indices &#91; i &#93; : indices &#91; ( i + 1 ) &#93; &#93; ) DCNL DCSP DCSP ( yield df.iloc &#91; indices &#91; ( -1 ) &#93; : &#93; )
DCSP if isinstance ( data , dict ) : DCNL DCSP DCSP for key in list ( data.keys ( ) ) : DCNL DCSP DCSP DCSP if isinstance ( key , six.string _ types ) : DCNL DCSP DCSP DCSP DCSP value = data &#91; key &#93; DCNL DCSP DCSP DCSP DCSP val = keys _ to _ string ( value ) DCNL DCSP DCSP DCSP DCSP del data &#91; key &#93; DCNL DCSP DCSP DCSP DCSP data &#91; key.encode ( &apos; utf8 &apos; , &apos; ignore &apos; ) &#93; = val DCNL DCSP return data
DCSP tmp _ file = tmpdir.join ( &apos; test.txt &apos; ) DCNL DCSP tmp _ file.write ( &apos; Testing &apos; ) DCNL DCSP ar = ArchiveFile ( tmp _ file.strpath , &apos; r &apos; ) DCNL DCSP q1 = Queue ( ) DCNL DCSP q2 = Queue ( ) DCNL DCSP def foo ( ) : DCNL DCSP DCSP with ar : DCNL DCSP DCSP DCSP q1.put ( 1 ) DCNL DCSP DCSP DCSP assert ( q2.get ( ) = = 2 ) DCNL DCSP DCSP DCSP assert ( q2.get ( ) = = 3 ) DCNL DCSP thread = Thread ( target = foo ) DCNL DCSP thread.start ( ) DCNL DCSP with ar : DCNL DCSP DCSP q2.put ( 2 ) DCNL DCSP DCSP assert ( q1.get ( ) = = 1 ) DCNL DCSP q2.put ( 3 ) DCNL DCSP thread.join ( )
DCSP git _ cmd = &#91; &apos; git &apos; , &apos; diff &apos; , &apos; --name-status &apos; &#93; DCNL DCSP if diff _ filter : DCNL DCSP DCSP git _ cmd.append ( &apos; --diff-filter = { } &apos; .format ( diff _ filter ) ) DCNL DCSP git _ cmd.extend ( &#91; left , right &#93; ) DCNL DCSP ( out , err ) = _ start _ subprocess _ for _ result ( git _ cmd ) DCNL DCSP if ( not err ) : DCNL DCSP DCSP file _ list = &#91; &#93; DCNL DCSP DCSP for line in out.splitlines ( ) : DCNL DCSP DCSP DCSP file _ list.append ( FileDiff ( line &#91; 0 &#93; , line &#91; ( line.rfind ( &apos; DCTB &apos; ) + 1 ) : &#93; ) ) DCNL DCSP DCSP return file _ list DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( err )
DCSP with open ( pjoin ( root , &apos; buildutils &apos; , &apos; templates &apos; , ( &apos; % s &apos; % fname ) ) , &apos; r &apos; ) as f : DCNL DCSP DCSP tpl = f.read ( ) DCNL DCSP out = tpl.format ( * * ns _ func ( ) ) DCNL DCSP dest = pjoin ( dest _ dir , fname ) DCNL DCSP info ( ( &apos; generating DCSP % s DCSP from DCSP template &apos; % dest ) ) DCNL DCSP with open ( dest , &apos; w &apos; ) as f : DCNL DCSP DCSP f.write ( out )
DCSP return s3db.inv _ send _ controller ( )
DCSP _ default _ root.tk.mainloop ( n )
DCSP trim _ url = ( lambda x , limit = trim _ url _ limit : ( ( ( limit is not None ) and ( ( len ( x ) &gt; limit ) and ( &apos; % s ... &apos; % x &#91; : max ( 0 , ( limit - 3 ) ) &#93; ) ) ) or x ) ) DCNL DCSP safe _ input = isinstance ( text , SafeData ) DCNL DCSP words = word _ split _ re.split ( force _ unicode ( text ) ) DCNL DCSP for ( i , word ) in enumerate ( words ) : DCNL DCSP DCSP match = None DCNL DCSP DCSP if ( ( &apos; .&apos; in word ) or ( &apos; @ &apos; in word ) or ( &apos; : &apos; in word ) ) : DCNL DCSP DCSP DCSP ( lead , middle , trail ) = ( &apos; &apos; , word , &apos; &apos; ) DCNL DCSP DCSP DCSP for punctuation in TRAILING _ PUNCTUATION : DCNL DCSP DCSP DCSP DCSP if middle.endswith ( punctuation ) : DCNL DCSP DCSP DCSP DCSP DCSP middle = middle &#91; : ( - len ( punctuation ) ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP trail = ( punctuation + trail ) DCNL DCSP DCSP DCSP for ( opening , closing ) in WRAPPING _ PUNCTUATION : DCNL DCSP DCSP DCSP DCSP if middle.startswith ( opening ) : DCNL DCSP DCSP DCSP DCSP DCSP middle = middle &#91; len ( opening ) : &#93; DCNL DCSP DCSP DCSP DCSP DCSP lead = ( lead + opening ) DCNL DCSP DCSP DCSP DCSP if ( middle.endswith ( closing ) and ( middle.count ( closing ) = = ( middle.count ( opening ) + 1 ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP middle = middle &#91; : ( - len ( closing ) ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP trail = ( closing + trail ) DCNL DCSP DCSP DCSP url = None DCNL DCSP DCSP DCSP nofollow _ attr = ( &apos; DCSP rel = &quot; nofollow &quot; &apos; if nofollow else &apos; &apos; ) DCNL DCSP DCSP DCSP if simple _ url _ re.match ( middle ) : DCNL DCSP DCSP DCSP DCSP url = smart _ urlquote ( middle ) DCNL DCSP DCSP DCSP elif simple _ url _ 2 _ re.match ( middle ) : DCNL DCSP DCSP DCSP DCSP url = smart _ urlquote ( ( &apos; http : / / % s &apos; % middle ) ) DCNL DCSP DCSP DCSP elif ( ( not ( &apos; : &apos; in middle ) ) and simple _ email _ re.match ( middle ) ) : DCNL DCSP DCSP DCSP DCSP ( local , domain ) = middle.rsplit ( &apos; @ &apos; , 1 ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP domain = domain.encode ( &apos; idna &apos; ) DCNL DCSP DCSP DCSP DCSP except UnicodeError : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP url = ( &apos; mailto : % s @ % s &apos; % ( local , domain ) ) DCNL DCSP DCSP DCSP DCSP nofollow _ attr = &apos; &apos; DCNL DCSP DCSP DCSP if url : DCNL DCSP DCSP DCSP DCSP trimmed = trim _ url ( middle ) DCNL DCSP DCSP DCSP DCSP if ( autoescape and ( not safe _ input ) ) : DCNL DCSP DCSP DCSP DCSP DCSP ( lead , trail ) = ( escape ( lead ) , escape ( trail ) ) DCNL DCSP DCSP DCSP DCSP DCSP ( url , trimmed ) = ( escape ( url ) , escape ( trimmed ) ) DCNL DCSP DCSP DCSP DCSP middle = ( &apos; &lt; a DCSP href = &quot; % s &quot; % s &gt; % s &lt; / a &gt; &apos; % ( url , nofollow _ attr , trimmed ) ) DCNL DCSP DCSP DCSP DCSP words &#91; i &#93; = mark _ safe ( ( &apos; % s % s % s &apos; % ( lead , middle , trail ) ) ) DCNL DCSP DCSP DCSP elif safe _ input : DCNL DCSP DCSP DCSP DCSP words &#91; i &#93; = mark _ safe ( word ) DCNL DCSP DCSP DCSP elif autoescape : DCNL DCSP DCSP DCSP DCSP words &#91; i &#93; = escape ( word ) DCNL DCSP DCSP elif safe _ input : DCNL DCSP DCSP DCSP words &#91; i &#93; = mark _ safe ( word ) DCNL DCSP DCSP elif autoescape : DCNL DCSP DCSP DCSP words &#91; i &#93; = escape ( word ) DCNL DCSP return u &apos; &apos; .join ( words )
DCSP return docstring.split ( u &apos; \ n &apos; ) &#91; 0 &#93;
DCSP if isinstance ( subject , bool ) : DCNL DCSP DCSP return subject DCNL DCSP elif isinstance ( subject , int ) : DCNL DCSP DCSP return ( subject = = 1 ) DCNL DCSP if hasattr ( subject , &apos; startswith &apos; ) : DCNL DCSP DCSP if ( subject.strip ( ) .lower ( ) in ( &apos; true &apos; , &apos; on &apos; , &apos; 1&apos; , &apos; yes &apos; , &apos; y &apos; ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( not exists ( name , region , key , keyid , profile ) ) : DCNL DCSP DCSP return True DCNL DCSP try : DCNL DCSP DCSP conn.delete _ lb _ policy ( name , policy _ name ) DCNL DCSP DCSP log.info ( &apos; Deleted DCSP policy DCSP { 0 } DCSP on DCSP ELB DCSP { 1 } &apos; .format ( policy _ name , name ) ) DCNL DCSP DCSP return True DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP delete DCSP policy DCSP { 0 } DCSP on DCSP ELB DCSP { 1 } : DCSP { 2 } &apos; .format ( policy _ name , name , e.message ) DCNL DCSP DCSP log.error ( msg ) DCNL DCSP DCSP return False
DCSP if six.PY2 : DCNL DCSP DCSP decodepath = ( lambda pth : pth.decode ( sys.getfilesystemencoding ( ) ) ) DCNL DCSP else : DCNL DCSP DCSP decodepath = ( lambda pth : pth ) DCNL DCSP if ( os.name = = u &apos;posix &apos; ) : DCNL DCSP DCSP if ( u &apos;HOME &apos; in os.environ ) : DCNL DCSP DCSP DCSP homedir = decodepath ( os.environ &#91; u &apos;HOME &apos; &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise OSError ( u &apos;Could DCSP not DCSP find DCSP unix DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir &apos; ) DCNL DCSP elif ( os.name = = u &apos;nt &apos; ) : DCNL DCSP DCSP if ( ( u &apos;MSYSTEM &apos; in os.environ ) and os.environ.get ( u &apos;HOME &apos; ) ) : DCNL DCSP DCSP DCSP homedir = decodepath ( os.environ &#91; u &apos;HOME &apos; &#93; ) DCNL DCSP DCSP elif ( u &apos;HOMESHARE &apos; in os.environ ) : DCNL DCSP DCSP DCSP homedir = decodepath ( os.environ &#91; u &apos;HOMESHARE &apos; &#93; ) DCNL DCSP DCSP elif ( ( u &apos;HOMEDRIVE &apos; in os.environ ) and ( u &apos;HOMEPATH &apos; in os.environ ) ) : DCNL DCSP DCSP DCSP homedir = os.path.join ( os.environ &#91; u &apos;HOMEDRIVE &apos; &#93; , os.environ &#91; u &apos;HOMEPATH &apos; &#93; ) DCNL DCSP DCSP DCSP homedir = decodepath ( homedir ) DCNL DCSP DCSP elif ( u &apos;USERPROFILE &apos; in os.environ ) : DCNL DCSP DCSP DCSP homedir = decodepath ( os.path.join ( os.environ &#91; u &apos;USERPROFILE &apos; &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP from .. extern.six.moves import winreg as wreg DCNL DCSP DCSP DCSP DCSP shell _ folders = u &apos;Software \ \ Microsoft \ \ Windows \ \ CurrentVersion \ \ Explorer \ \ Shell DCSP Folders &apos; DCNL DCSP DCSP DCSP DCSP key = wreg.OpenKey ( wreg.HKEY _ CURRENT _ USER , shell _ folders ) DCNL DCSP DCSP DCSP DCSP homedir = wreg.QueryValueEx ( key , u &apos;Personal &apos; ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP homedir = decodepath ( homedir ) DCNL DCSP DCSP DCSP DCSP key.Close ( ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP if ( u &apos;HOME &apos; in os.environ ) : DCNL DCSP DCSP DCSP DCSP DCSP homedir = decodepath ( os.environ &#91; u &apos;HOME &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP raise OSError ( u &apos;Could DCSP not DCSP find DCSP windows DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir &apos; ) DCNL DCSP elif ( u &apos;HOME &apos; in os.environ ) : DCNL DCSP DCSP homedir = decodepath ( os.environ &#91; u &apos;HOME &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP raise OSError ( u &apos;Could DCSP not DCSP find DCSP a DCSP home DCSP directory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP dir DCSP - DCSP are DCSP you DCSP on DCSP an DCSP unspported DCSP platform ? &apos; ) DCNL DCSP return homedir
DCSP required = { } DCNL DCSP for linenum in xrange ( clean _ lines.NumLines ( ) ) : DCNL DCSP DCSP line = clean _ lines.elided &#91; linenum &#93; DCNL DCSP DCSP if ( ( not line ) or ( line &#91; 0 &#93; = = &apos; # &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP matched = _ RE _ PATTERN _ STRING.search ( line ) DCNL DCSP DCSP if matched : DCNL DCSP DCSP DCSP prefix = line &#91; : matched.start ( ) &#93; DCNL DCSP DCSP DCSP if ( prefix.endswith ( &apos; std : : &apos; ) or ( not prefix.endswith ( &apos; : : &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP required &#91; &apos; &lt; string &gt; &apos; &#93; = ( linenum , &apos; string &apos; ) DCNL DCSP DCSP for ( pattern , template , header ) in _ re _ pattern _ algorithm _ header : DCNL DCSP DCSP DCSP if pattern.search ( line ) : DCNL DCSP DCSP DCSP DCSP required &#91; header &#93; = ( linenum , template ) DCNL DCSP DCSP if ( not ( &apos; &lt; &apos; in line ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for ( pattern , template , header ) in _ re _ pattern _ templates : DCNL DCSP DCSP DCSP if pattern.search ( line ) : DCNL DCSP DCSP DCSP DCSP required &#91; header &#93; = ( linenum , template ) DCNL DCSP include _ state = include _ state.copy ( ) DCNL DCSP header _ found = False DCNL DCSP abs _ filename = FileInfo ( filename ) .FullName ( ) DCNL DCSP abs _ filename = re.sub ( &apos; _ flymake \ \ .cc $ &apos; , &apos; .cc &apos; , abs _ filename ) DCNL DCSP header _ keys = include _ state.keys ( ) DCNL DCSP for header in header _ keys : DCNL DCSP DCSP ( same _ module , common _ path ) = FilesBelongToSameModule ( abs _ filename , header ) DCNL DCSP DCSP fullpath = ( common _ path + header ) DCNL DCSP DCSP if ( same _ module and UpdateIncludeState ( fullpath , include _ state , io ) ) : DCNL DCSP DCSP DCSP header _ found = True DCNL DCSP if ( filename.endswith ( &apos; .cc &apos; ) and ( not header _ found ) ) : DCNL DCSP DCSP return DCNL DCSP for required _ header _ unstripped in required : DCNL DCSP DCSP template = required &#91; required _ header _ unstripped &#93; &#91; 1 &#93; DCNL DCSP DCSP if ( required _ header _ unstripped.strip ( &apos; &lt; &gt; &quot; &apos; ) not in include _ state ) : DCNL DCSP DCSP DCSP error ( filename , required &#91; required _ header _ unstripped &#93; &#91; 0 &#93; , &apos; build / include _ what _ you _ use &apos; , 4 , ( ( ( &apos; Add DCSP # include DCSP &apos; + required _ header _ unstripped ) + &apos; DCSP for DCSP &apos; ) + template ) )
DCSP ret _ attr = ATTR _ MAP.get ( attr , None ) DCNL DCSP if ( ret _ attr is None ) : DCNL DCSP DCSP return attr.lower ( ) DCNL DCSP return ret _ attr
DCSP if isinstance ( term , string _ t ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return table &#91; term.lower ( ) &#93; DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP raise TypeError ( u &apos;Cannot DCSP coerce DCSP { 0 ! r } DCSP to DCSP type DCSP bool &apos; .format ( term ) ) DCNL DCSP return term
DCSP with proc : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( yield proc ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP proc.kill ( ) DCNL DCSP DCSP DCSP raise
DCSP ip _ version = get _ ip _ version ( ip _ address ) DCNL DCSP privileged.add _ neigh _ entry ( ip _ version , ip _ address , mac _ address , device , namespace , * * kwargs )
DCSP session = orm.sessionmaker ( bind = migrate _ engine ) ( ) DCNL DCSP qry = session.query ( table.c.image _ id , table.c.member ) .group _ by ( table.c.image _ id , table.c.member ) .having ( ( func.count ( ) &gt; 1 ) ) DCNL DCSP for ( image _ id , member ) in qry : DCNL DCSP DCSP d = table.delete ( ) .where ( and _ ( ( table.c.deleted = = True ) , ( table.c.image _ id = = image _ id ) , ( table.c.member = = member ) ) ) DCNL DCSP DCSP d.execute ( ) DCNL DCSP session.close ( )
DCSP direction = request.GET.get ( u &apos;direction &apos; ) DCNL DCSP range _ end = request.GET.get ( u &apos;range _ end &apos; ) DCNL DCSP range _ start = request.GET.get ( u &apos;range _ start &apos; ) DCNL DCSP days _ total = DAYS _ TOTAL DCNL DCSP if range _ end : DCNL DCSP DCSP range _ end = datetime.datetime.fromtimestamp ( time.mktime ( time.strptime ( range _ end , u &apos; % Y- % m- % d &apos; ) ) ) DCNL DCSP if range _ start : DCNL DCSP DCSP range _ start = datetime.datetime.fromtimestamp ( time.mktime ( time.strptime ( range _ start , u &apos; % Y- % m- % d &apos; ) ) ) DCNL DCSP if ( ( direction = = u &apos;next &apos; ) and range _ end ) : DCNL DCSP DCSP new _ range _ start = range _ end DCNL DCSP DCSP new _ range _ end = ( new _ range _ start + datetime.timedelta ( days = days _ total ) ) DCNL DCSP elif ( ( direction = = u &apos;prev &apos; ) and range _ start ) : DCNL DCSP DCSP new _ range _ start = ( range _ start - datetime.timedelta ( days = days _ total ) ) DCNL DCSP DCSP new _ range _ end = range _ start DCNL DCSP elif ( ( direction = = u &apos;same &apos; ) and range _ start and range _ end ) : DCNL DCSP DCSP new _ range _ start = range _ start DCNL DCSP DCSP new _ range _ end = range _ end DCNL DCSP else : DCNL DCSP DCSP new _ range _ end = ( datetime.datetime.now ( ) + datetime.timedelta ( days = 1 ) ) DCNL DCSP DCSP new _ range _ start = ( new _ range _ end - datetime.timedelta ( days = days _ total ) ) DCNL DCSP current _ tz = timezone.get _ current _ timezone ( ) DCNL DCSP new _ range _ start = timezone.make _ aware ( new _ range _ start , current _ tz ) DCNL DCSP new _ range _ end = timezone.make _ aware ( new _ range _ end , current _ tz ) DCNL DCSP response _ data = { u &apos;range _ start &apos; : new _ range _ start.strftime ( u &apos; % Y- % m- % d &apos; ) , u &apos;range _ end &apos; : new _ range _ end.strftime ( u &apos; % Y- % m- % d &apos; ) } DCNL DCSP def large _ stats _ data ( range _ start , range _ end ) : DCNL DCSP DCSP def get _ objects ( model _ name , timestamp _ field , date _ field ) : DCNL DCSP DCSP DCSP u &apos;Perform DCSP timestamp DCSP based DCSP queries . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP This DCSP method DCSP receives DCSP a DCSP dynamic DCSP model DCSP name DCSP and DCSP performs DCSP a DCSP filter \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP query . DCSP Later DCSP the DCSP results DCSP are DCSP grouped DCSP by DCSP day DCSP and DCSP prepared DCSP for DCSP the \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP charting DCSP library . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP args = ( u &apos; % s _ _ range &apos; % timestamp _ field ) DCNL DCSP DCSP DCSP q = model _ name.objects.filter ( * * { args : ( range _ start , range _ end ) } ) DCNL DCSP DCSP DCSP q = q.extra ( { timestamp _ field : date _ field } ) DCNL DCSP DCSP DCSP q = q.values ( timestamp _ field ) DCNL DCSP DCSP DCSP q = q.annotate ( created _ count = Count ( u &apos;pk &apos; ) ) DCNL DCSP DCSP DCSP q = q.order _ by ( timestamp _ field ) DCNL DCSP DCSP DCSP data = &#91; &#93; DCNL DCSP DCSP DCSP for obj in q : DCNL DCSP DCSP DCSP DCSP data.append ( &#91; ( time.mktime ( time.strptime ( six.text _ type ( obj &#91; timestamp _ field &#93; ) , u &apos; % Y- % m- % d &apos; ) ) * 1000 ) , obj &#91; u &apos;created _ count &apos; &#93; &#93; ) DCNL DCSP DCSP DCSP return data DCNL DCSP DCSP comment _ array = get _ objects ( Comment , u &apos;timestamp &apos; , u &apos;date ( timestamp ) &apos; ) DCNL DCSP DCSP change _ desc _ array = get _ objects ( ChangeDescription , u &apos;timestamp &apos; , u &apos;date ( timestamp ) &apos; ) DCNL DCSP DCSP review _ array = get _ objects ( Review , u &apos;timestamp &apos; , u &apos;date ( timestamp ) &apos; ) DCNL DCSP DCSP rr _ array = get _ objects ( ReviewRequest , u &apos;time _ added &apos; , u &apos;date ( time _ added ) &apos; ) DCNL DCSP DCSP return { u &apos;change _ descriptions &apos; : change _ desc _ array , u &apos;comments &apos; : comment _ array , u &apos;reviews &apos; : review _ array , u &apos;review _ requests &apos; : rr _ array } DCNL DCSP stats _ data = large _ stats _ data ( new _ range _ start , new _ range _ end ) DCNL DCSP return { u &apos;range &apos; : response _ data , u &apos;activity _ data &apos; : stats _ data }
DCSP if ( derivation.moveType.lower ( ) &#91; : 1 &#93; = = &apos; m &apos; ) : DCNL DCSP DCSP return geometryOutput DCNL DCSP geometryOutputVertexes = matrix.getVertexes ( geometryOutput ) DCNL DCSP translation = Vector3 ( 0.0 , 0.0 , ( - euclidean.getBottomByPath ( geometryOutputVertexes ) ) ) DCNL DCSP euclidean.translateVector3Path ( geometryOutputVertexes , translation ) DCNL DCSP return geometryOutput
DCSP from django.core.urlresolvers import reverse DCNL DCSP def inner ( * args , * * kwargs ) : DCNL DCSP DCSP bits = func ( * args , * * kwargs ) DCNL DCSP DCSP return reverse ( bits &#91; 0 &#93; , None , * bits &#91; 1 : 3 &#93; ) DCNL DCSP return inner
DCSP descriptions = load _ yaml _ config _ file ( os.path.join ( os.path.dirname ( _ _ file _ _ ) , &apos; services.yaml &apos; ) ) DCNL DCSP name = config.get ( CONF _ NAME ) DCNL DCSP cert _ file = config.get ( CONF _ CERTFILE ) DCNL DCSP topic = config.get ( CONF _ TOPIC ) DCNL DCSP sandbox = config.get ( CONF _ SANDBOX ) DCNL DCSP service = ApnsNotificationService ( hass , name , topic , sandbox , cert _ file ) DCNL DCSP hass.services.register ( DOMAIN , &apos; apns _ { } &apos; .format ( name ) , service.register , descriptions.get ( SERVICE _ REGISTER ) , schema = REGISTER _ SERVICE _ SCHEMA ) DCNL DCSP return service
DCSP ofport = int ( switch.cmd ( &apos; ovs-vsctl DCSP get DCSP Interface &apos; , intf , &apos; ofport &apos; ) ) DCNL DCSP if ( ofport ! = switch.ports &#91; intf &#93; ) : DCNL DCSP DCSP warn ( &apos; WARNING : DCSP ofport DCSP for &apos; , intf , &apos; is DCSP actually &apos; , ofport , &apos; \ n &apos; ) DCNL DCSP DCSP return 0 DCNL DCSP else : DCNL DCSP DCSP return 1
DCSP return _ correlate _ or _ convolve ( input , weights , output , mode , cval , origin , True )
DCSP NON _ CLOSING _ TAGS = &#91; &apos; AREA &apos; , &apos; BASE &apos; , &apos; BASEFONT &apos; , &apos; BR &apos; , &apos; COL &apos; , &apos; FRAME &apos; , &apos; HR &apos; , &apos; IMG &apos; , &apos; INPUT &apos; , &apos; ISINDEX &apos; , &apos; LINK &apos; , &apos; META &apos; , &apos; PARAM &apos; &#93; DCNL DCSP opened _ tags = re.findall ( &apos; &lt; ( &#91; a-z &#93; + ) &#91; ^ &lt; &gt; &#93; * &gt; &apos; , html ) DCNL DCSP closed _ tags = re.findall ( &apos; &lt; / ( &#91; a-z &#93; + ) &gt; &apos; , html ) DCNL DCSP opened _ tags = &#91; i.lower ( ) for i in opened _ tags if ( i.upper ( ) not in NON _ CLOSING _ TAGS ) &#93; DCNL DCSP closed _ tags = &#91; i.lower ( ) for i in closed _ tags &#93; DCNL DCSP len _ opened = len ( opened _ tags ) DCNL DCSP if ( len _ opened = = len ( closed _ tags ) ) : DCNL DCSP DCSP return html DCNL DCSP opened _ tags.reverse ( ) DCNL DCSP for tag in opened _ tags : DCNL DCSP DCSP if ( tag in closed _ tags ) : DCNL DCSP DCSP DCSP closed _ tags.remove ( tag ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP html + = ( &apos; &lt; / % s &gt; &apos; % tag ) DCNL DCSP return html
DCSP if ( minSineDur &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; Minimum DCSP duration DCSP of DCSP sine DCSP tracks DCSP smaller DCSP than DCSP 0 &apos; ) DCNL DCSP hM1 = int ( math.floor ( ( ( w.size + 1 ) / 2 ) ) ) DCNL DCSP hM2 = int ( math.floor ( ( w.size / 2 ) ) ) DCNL DCSP x = np.append ( np.zeros ( hM2 ) , x ) DCNL DCSP x = np.append ( x , np.zeros ( hM2 ) ) DCNL DCSP pin = hM1 DCNL DCSP pend = ( x.size - hM1 ) DCNL DCSP w = ( w / sum ( w ) ) DCNL DCSP tfreq = np.array ( &#91; &#93; ) DCNL DCSP while ( pin &lt; pend ) : DCNL DCSP DCSP x1 = x &#91; ( pin - hM1 ) : ( pin + hM2 ) &#93; DCNL DCSP DCSP ( mX , pX ) = DFT.dftAnal ( x1 , w , N ) DCNL DCSP DCSP ploc = UF.peakDetection ( mX , t ) DCNL DCSP DCSP ( iploc , ipmag , ipphase ) = UF.peakInterp ( mX , pX , ploc ) DCNL DCSP DCSP ipfreq = ( ( fs * iploc ) / float ( N ) ) DCNL DCSP DCSP ( tfreq , tmag , tphase ) = sineTracking ( ipfreq , ipmag , ipphase , tfreq , freqDevOffset , freqDevSlope ) DCNL DCSP DCSP tfreq = np.resize ( tfreq , min ( maxnSines , tfreq.size ) ) DCNL DCSP DCSP tmag = np.resize ( tmag , min ( maxnSines , tmag.size ) ) DCNL DCSP DCSP tphase = np.resize ( tphase , min ( maxnSines , tphase.size ) ) DCNL DCSP DCSP jtfreq = np.zeros ( maxnSines ) DCNL DCSP DCSP jtmag = np.zeros ( maxnSines ) DCNL DCSP DCSP jtphase = np.zeros ( maxnSines ) DCNL DCSP DCSP jtfreq &#91; : tfreq.size &#93; = tfreq DCNL DCSP DCSP jtmag &#91; : tmag.size &#93; = tmag DCNL DCSP DCSP jtphase &#91; : tphase.size &#93; = tphase DCNL DCSP DCSP if ( pin = = hM1 ) : DCNL DCSP DCSP DCSP xtfreq = jtfreq DCNL DCSP DCSP DCSP xtmag = jtmag DCNL DCSP DCSP DCSP xtphase = jtphase DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP xtfreq = np.vstack ( ( xtfreq , jtfreq ) ) DCNL DCSP DCSP DCSP xtmag = np.vstack ( ( xtmag , jtmag ) ) DCNL DCSP DCSP DCSP xtphase = np.vstack ( ( xtphase , jtphase ) ) DCNL DCSP DCSP pin + = H DCNL DCSP xtfreq = cleaningSineTracks ( xtfreq , round ( ( ( fs * minSineDur ) / H ) ) ) DCNL DCSP return ( xtfreq , xtmag , xtphase )
DCSP if ( rh _ op is not None ) : DCNL DCSP DCSP rh _ op = neg _ expr ( rh _ op ) DCNL DCSP return create _ leq ( neg _ expr ( lh _ op ) , rh _ op , constr _ id )
DCSP return os.environ &#91; &apos; CURRENT _ MODULE _ ID &apos; &#93;
DCSP if _ samefile ( src , dst ) : DCNL DCSP DCSP raise Error , ( &apos; ` % s` DCSP and DCSP ` % s` DCSP are DCSP the DCSP same DCSP file &apos; % ( src , dst ) ) DCNL DCSP fsrc = None DCNL DCSP fdst = None DCNL DCSP try : DCNL DCSP DCSP fsrc = open ( src , &apos; rb &apos; ) DCNL DCSP DCSP fdst = open ( dst , &apos; wb &apos; ) DCNL DCSP DCSP copyfileobj ( fsrc , fdst ) DCNL DCSP finally : DCNL DCSP DCSP if fdst : DCNL DCSP DCSP DCSP fdst.close ( ) DCNL DCSP DCSP if fsrc : DCNL DCSP DCSP DCSP fsrc.close ( )
DCSP if ( input _ units = = output _ units ) : DCNL DCSP DCSP _ scalefactor = 1.0 DCNL DCSP if ( ( input _ units = = u &apos;scans &apos; ) and ( output _ units = = u &apos;secs &apos; ) ) : DCNL DCSP DCSP _ scalefactor = time _ repetition DCNL DCSP if ( ( input _ units = = u &apos;secs &apos; ) and ( output _ units = = u &apos;scans &apos; ) ) : DCNL DCSP DCSP _ scalefactor = ( 1.0 / time _ repetition ) DCNL DCSP timelist = &#91; np.max ( &#91; 0.0 , ( _ scalefactor * t ) &#93; ) for t in timelist &#93; DCNL DCSP return timelist
DCSP x _ edge = axis _ slice ( x , start = window _ start , stop = window _ stop , axis = axis ) DCNL DCSP if ( ( axis = = 0 ) or ( axis = = ( - x.ndim ) ) ) : DCNL DCSP DCSP xx _ edge = x _ edge DCNL DCSP DCSP swapped = False DCNL DCSP else : DCNL DCSP DCSP xx _ edge = x _ edge.swapaxes ( axis , 0 ) DCNL DCSP DCSP swapped = True DCNL DCSP xx _ edge = xx _ edge.reshape ( xx _ edge.shape &#91; 0 &#93; , ( -1 ) ) DCNL DCSP poly _ coeffs = np.polyfit ( np.arange ( 0 , ( window _ stop - window _ start ) ) , xx _ edge , polyorder ) DCNL DCSP if ( deriv &gt; 0 ) : DCNL DCSP DCSP poly _ coeffs = _ polyder ( poly _ coeffs , deriv ) DCNL DCSP i = np.arange ( ( interp _ start - window _ start ) , ( interp _ stop - window _ start ) ) DCNL DCSP values = ( np.polyval ( poly _ coeffs , i.reshape ( ( -1 ) , 1 ) ) / ( delta * * deriv ) ) DCNL DCSP shp = list ( y.shape ) DCNL DCSP ( shp &#91; 0 &#93; , shp &#91; axis &#93; ) = ( shp &#91; axis &#93; , shp &#91; 0 &#93; ) DCNL DCSP values = values.reshape ( ( interp _ stop - interp _ start ) , * shp &#91; 1 : &#93; ) DCNL DCSP if swapped : DCNL DCSP DCSP values = values.swapaxes ( 0 , axis ) DCNL DCSP y _ edge = axis _ slice ( y , start = interp _ start , stop = interp _ stop , axis = axis ) DCNL DCSP y _ edge &#91; ... &#93; = values
DCSP patterns = Locale.parse ( locale ) .datetime _ formats DCNL DCSP if ( format not in patterns ) : DCNL DCSP DCSP format = None DCNL DCSP return patterns &#91; format &#93;
DCSP return base64.urlsafe _ b64encode ( aes _ encrypt ( data , key ) )
DCSP def _ offset ( * args ) : DCNL DCSP DCSP args2 = list ( map ( add , args , offset ) ) DCNL DCSP DCSP return func ( * args2 ) DCNL DCSP with ignoring ( Exception ) : DCNL DCSP DCSP _ offset . _ _ name _ _ = ( &apos; offset _ &apos; + func . _ _ name _ _ ) DCNL DCSP return _ offset
DCSP dd = defaultdict ( int ) DCNL DCSP n = len ( lst ) DCNL DCSP for i in lst : DCNL DCSP DCSP dd &#91; i &#93; + = 1 DCNL DCSP for key in dd : DCNL DCSP DCSP if ( dd &#91; key &#93; &gt; ( n / / 2 ) ) : DCNL DCSP DCSP DCSP return key DCNL DCSP return None
DCSP args = dict ( args ) DCNL DCSP if ( key not in args ) : DCNL DCSP DCSP args &#91; key &#93; = value DCNL DCSP return args
DCSP net = Mininet ( topo = VLANStarTopo ( ) ) DCNL DCSP net.start ( ) DCNL DCSP CLI ( net ) DCNL DCSP net.stop ( )
DCSP meta = MetaData ( ) DCNL DCSP meta.bind = migrate _ engine DCNL DCSP volumes = Table ( &apos; volumes &apos; , meta , autoload = True ) DCNL DCSP source _ volid = Column ( &apos; source _ volid &apos; , String ( 36 ) ) DCNL DCSP volumes.drop _ column ( source _ volid )
DCSP seen = set ( ) DCNL DCSP seen _ add = seen.add DCNL DCSP if ( key is None ) : DCNL DCSP DCSP for element in filterfalse ( seen . _ _ contains _ _ , iterable ) : DCNL DCSP DCSP DCSP seen _ add ( element ) DCNL DCSP DCSP DCSP ( yield element ) DCNL DCSP else : DCNL DCSP DCSP for element in iterable : DCNL DCSP DCSP DCSP k = key ( element ) DCNL DCSP DCSP DCSP if ( k not in seen ) : DCNL DCSP DCSP DCSP DCSP seen _ add ( k ) DCNL DCSP DCSP DCSP DCSP ( yield element )
DCSP items = OrderedDict ( ) DCNL DCSP if ( data is None ) : DCNL DCSP DCSP return items DCNL DCSP if isinstance ( data , SqlTable ) : DCNL DCSP DCSP items &#91; &apos; Data DCSP instances &apos; &#93; = data.approx _ len ( ) DCNL DCSP else : DCNL DCSP DCSP items &#91; &apos; Data DCSP instances &apos; &#93; = len ( data ) DCNL DCSP items.update ( describe _ domain ( data.domain ) ) DCNL DCSP return items
DCSP if ( not os.path.isfile ( file _ in ) ) : DCNL DCSP DCSP raise IOError ( &apos; no DCSP such DCSP file DCSP ` { 0 } ` &apos; .format ( file _ in ) ) DCNL DCSP ( rate , table ) = table _ from _ file ( file _ in , start = start , stop = stop ) DCNL DCSP return ( rate , np.array ( table.getTable ( ) ) )
DCSP contr = np.column _ stack ( ( np.ones ( ( nm - 1 ) ) , ( - np.eye ( ( nm - 1 ) ) ) ) ) DCNL DCSP return contr
DCSP contents = { } DCNL DCSP js _ fragments = set ( ) DCNL DCSP for class _ in classes : DCNL DCSP DCSP module _ js = class _ .get _ javascript ( ) DCNL DCSP DCSP js _ fragments.add ( ( 0 , &apos; js &apos; , module _ js.get ( &apos; xmodule _ js &apos; ) ) ) DCNL DCSP DCSP for filetype in ( &apos; coffee &apos; , &apos; js &apos; ) : DCNL DCSP DCSP DCSP for ( idx , fragment ) in enumerate ( module _ js.get ( filetype , &#91; &#93; ) ) : DCNL DCSP DCSP DCSP DCSP js _ fragments.add ( ( ( idx + 1 ) , filetype , fragment ) ) DCNL DCSP for ( idx , filetype , fragment ) in sorted ( js _ fragments ) : DCNL DCSP DCSP filename = &apos; { idx : 0 = 3d } - { hash } . { type } &apos; .format ( idx = idx , hash = hashlib.md5 ( fragment ) .hexdigest ( ) , type = filetype ) DCNL DCSP DCSP contents &#91; filename &#93; = fragment DCNL DCSP _ write _ files ( output _ root , contents , { &apos; .coffee &apos; : &apos; .js &apos; } ) DCNL DCSP return &#91; ( output _ root / filename ) for filename in contents.keys ( ) &#93;
DCSP editor.edit ( initial _ text ) DCNL DCSP with open ( editor . _ file.name , &apos; r &apos; , encoding = &apos; utf-8 &apos; ) as f : DCNL DCSP DCSP assert ( f.read ( ) = = initial _ text ) DCNL DCSP with open ( editor . _ file.name , &apos; w &apos; , encoding = &apos; utf-8 &apos; ) as f : DCNL DCSP DCSP f.write ( edited _ text ) DCNL DCSP editor . _ proc.finished.emit ( 0 , QProcess.NormalExit ) DCNL DCSP editor.editing _ finished.emit.assert _ called _ with ( edited _ text )
DCSP qss = get _ stylesheet ( obj.STYLESHEET ) DCNL DCSP log.config.vdebug ( &apos; stylesheet DCSP for DCSP { } : DCSP { } &apos; .format ( obj . _ _ class _ _ . _ _ name _ _ , qss ) ) DCNL DCSP obj.setStyleSheet ( qss ) DCNL DCSP objreg.get ( &apos; config &apos; ) .changed.connect ( functools.partial ( _ update _ stylesheet , obj ) )
DCSP tests = &#91; &#91; &apos; hi &apos; , &#91; &apos; hi &apos; &#93; &#93; , &#91; u &apos;hi &apos; , &#91; u &apos;hi &apos; &#93; &#93; , &#91; &apos; hello DCSP there &apos; , &#91; &apos; hello &apos; , &apos; there &apos; &#93; &#93; , &#91; u &apos;h \ u01cello &apos; , &#91; u &apos;h \ u01cello &apos; &#93; &#93; , &#91; &apos; something DCSP &quot; with DCSP quotes &quot; &apos; , &#91; &apos; something &apos; , &apos; &quot; with DCSP quotes &quot; &apos; &#93; &#93; &#93; DCNL DCSP for ( argstr , argv ) in tests : DCNL DCSP DCSP nt.assert _ equal ( arg _ split ( argstr ) , argv )
DCSP order = &#91; &#93; DCNL DCSP remaining = set ( ) DCNL DCSP todo = &#91; start _ block &#93; DCNL DCSP while todo : DCNL DCSP DCSP b = todo.pop ( ) DCNL DCSP DCSP if ( b in remaining ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP remaining.add ( b ) DCNL DCSP DCSP for c in b.get _ children ( ) : DCNL DCSP DCSP DCSP if ( c not in remaining ) : DCNL DCSP DCSP DCSP DCSP todo.append ( c ) DCNL DCSP dominators = { } DCNL DCSP for b in remaining : DCNL DCSP DCSP if ( _ _ debug _ _ and b.next ) : DCNL DCSP DCSP DCSP assert ( b is b.next &#91; 0 &#93; .prev &#91; 0 &#93; ) , ( b , b.next ) DCNL DCSP DCSP for c in b.get _ followers ( ) : DCNL DCSP DCSP DCSP while 1 : DCNL DCSP DCSP DCSP DCSP dominators.setdefault ( c , set ( ) ) .add ( b ) DCNL DCSP DCSP DCSP DCSP if ( c.prev and ( c.prev &#91; 0 &#93; is not b ) ) : DCNL DCSP DCSP DCSP DCSP DCSP c = c.prev &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP def find _ next ( ) : DCNL DCSP DCSP for b in remaining : DCNL DCSP DCSP DCSP for c in dominators &#91; b &#93; : DCNL DCSP DCSP DCSP DCSP if ( c in remaining ) : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return b DCNL DCSP DCSP assert 0 , &apos; circular DCSP dependency , DCSP cannot DCSP find DCSP next DCSP block &apos; DCNL DCSP b = start _ block DCNL DCSP while 1 : DCNL DCSP DCSP order.append ( b ) DCNL DCSP DCSP remaining.discard ( b ) DCNL DCSP DCSP if b.next : DCNL DCSP DCSP DCSP b = b.next &#91; 0 &#93; DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( ( b is not exit _ block ) and ( not b.has _ unconditional _ transfer ( ) ) ) : DCNL DCSP DCSP DCSP order.append ( exit _ block ) DCNL DCSP DCSP if ( not remaining ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP b = find _ next ( ) DCNL DCSP return order
DCSP assert callable ( disp ) DCNL DCSP assert callable ( disp.py _ func ) DCNL DCSP name = disp.py _ func . _ _ name _ _ DCNL DCSP _ temporary _ dispatcher _ map &#91; name &#93; = disp DCNL DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP del _ temporary _ dispatcher _ map &#91; name &#93;
DCSP ( path , name , ext ) = split _ filename ( filename ) DCNL DCSP newfilename = u &apos; &apos; .join ( ( name , u &apos; _ 0x &apos; , hashvalue , ext ) ) DCNL DCSP return os.path.join ( path , newfilename )
DCSP new _ kind = _ human2fiff &#91; ch _ type &#93; DCNL DCSP if ( ch &#91; &apos; kind &apos; &#93; ! = new _ kind ) : DCNL DCSP DCSP for proj in projs : DCNL DCSP DCSP DCSP if ( ch &#91; &apos; ch _ name &apos; &#93; in proj &#91; &apos; data &apos; &#93; &#91; &apos; col _ names &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( ( &apos; Cannot DCSP change DCSP channel DCSP type DCSP for DCSP channel DCSP % s DCSP in DCSP projector DCSP &quot; % s &quot; &apos; % ( ch &#91; &apos; ch _ name &apos; &#93; , proj &#91; &apos; desc &apos; &#93; ) ) ) DCNL DCSP ch &#91; &apos; kind &apos; &#93; = new _ kind
DCSP description = core.StepDescription ( 10 , _ _ file _ _ ) DCNL DCSP assert _ equals ( description.file , core.fs.relpath ( _ _ file _ _ ) ) DCNL DCSP assert _ not _ equals ( description.file , _ _ file _ _ ) DCNL DCSP assert _ equals ( description.line , 10 )
DCSP return _ check _ range _ and _ return ( &apos; horizontal DCSP shift &apos; , label , ( -5 ) , 5 )
DCSP DEBUG = True DCNL DCSP proc = subprocess.Popen ( &#91; DIFF , file1 , file2 &#93; , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP ( diff _ output , std _ err ) = proc.communicate ( ) DCNL DCSP if DEBUG : DCNL DCSP DCSP print &apos; &gt; &gt; &gt; Config DCSP differences : &apos; DCNL DCSP DCSP print diff _ output DCNL DCSP return diff _ output
DCSP if ( not request.environ.get ( &apos; paste.command _ request &apos; ) ) : DCNL DCSP DCSP _ check _ access ( &apos; send _ email _ notifications &apos; , context , data _ dict ) DCNL DCSP if ( not converters.asbool ( config.get ( &apos; ckan.activity _ streams _ email _ notifications &apos; ) ) ) : DCNL DCSP DCSP raise ValidationError ( &apos; ckan.activity _ streams _ email _ notifications DCSP is DCSP not DCSP enabled DCSP in DCSP config &apos; ) DCNL DCSP email _ notifications.get _ and _ send _ notifications _ for _ all _ users ( )
DCSP tmp = grey _ dilation ( input , size , footprint , structure , None , mode , cval , origin ) DCNL DCSP return grey _ erosion ( tmp , size , footprint , structure , output , mode , cval , origin )
DCSP try : DCNL DCSP DCSP ( module _ path , module _ class ) = module _ name.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP DCSP base _ module = _ _ import _ _ ( module _ path , globals ( ) , locals ( ) , &#91; module _ class &#93; ) DCNL DCSP DCSP module = getattr ( base _ module , module _ class ) DCNL DCSP except ( ImportError , AttributeError , ValueError ) as e : DCNL DCSP DCSP raise EAException ( ( &apos; Could DCSP not DCSP import DCSP module DCSP % s : DCSP % s &apos; % ( module _ name , e ) ) ) DCNL DCSP return module
DCSP print &apos; Checking DCSP server DCSP { server } DCSP on DCSP port DCSP { port } &apos; .format ( server = server , port = port ) DCNL DCSP if tasks.environment.dry _ run : DCNL DCSP DCSP return True DCNL DCSP attempts = 0 DCNL DCSP server _ ok = False DCNL DCSP while ( attempts &lt; 30 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP connection = httplib.HTTPConnection ( server , port , timeout = 10 ) DCNL DCSP DCSP DCSP connection.request ( &apos; GET &apos; , &apos; / &apos; ) DCNL DCSP DCSP DCSP response = connection.getresponse ( ) DCNL DCSP DCSP DCSP if ( int ( response.status ) = = 200 ) : DCNL DCSP DCSP DCSP DCSP server _ ok = True DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP attempts + = 1 DCNL DCSP DCSP time.sleep ( 1 ) DCNL DCSP return server _ ok
DCSP deserializer = RequestDeserializer ( ) DCNL DCSP serializer = ResponseSerializer ( ) DCNL DCSP controller = ImageMembersController ( ) DCNL DCSP return wsgi.Resource ( controller , deserializer , serializer )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if isinstance ( groupnames , str ) : DCNL DCSP DCSP groupnames = &#91; groupnames &#93; DCNL DCSP if isinstance ( group _ ids , str ) : DCNL DCSP DCSP groupnames = &#91; group _ ids &#93; DCNL DCSP interesting = &#91; &apos; description &apos; , &apos; id &apos; , &apos; instances &apos; , &apos; name &apos; , &apos; owner _ id &apos; , &apos; region &apos; , &apos; rules &apos; , &apos; rules _ egress &apos; , &apos; tags &apos; , &apos; vpc _ id &apos; &#93; DCNL DCSP ret = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP r = conn.get _ all _ security _ groups ( groupnames = groupnames , group _ ids = group _ ids , filters = filters ) DCNL DCSP DCSP for g in r : DCNL DCSP DCSP DCSP n = { } DCNL DCSP DCSP DCSP for a in interesting : DCNL DCSP DCSP DCSP DCSP v = getattr ( g , a , None ) DCNL DCSP DCSP DCSP DCSP if ( a = = &apos; region &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP v = v.name DCNL DCSP DCSP DCSP DCSP elif ( a in ( &apos; rules &apos; , &apos; rules _ egress &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP v = _ parse _ rules ( g , v ) DCNL DCSP DCSP DCSP DCSP elif ( a = = &apos; instances &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP v = &#91; i.id for i in v ( ) &#93; DCNL DCSP DCSP DCSP DCSP n &#91; a &#93; = v DCNL DCSP DCSP DCSP ret + = &#91; n &#93; DCNL DCSP DCSP return ret DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP return &#91; &#93;
DCSP return task ( * * dict ( { &apos; base &apos; : PeriodicTask } , * * options ) )
DCSP stem = word.lower ( ) DCNL DCSP if ( cached and ( stem in cache ) ) : DCNL DCSP DCSP return case _ sensitive ( cache &#91; stem &#93; , word ) DCNL DCSP if ( cached and ( len ( cache ) &gt; history ) ) : DCNL DCSP DCSP cache.clear ( ) DCNL DCSP if ( len ( stem ) &lt; = 2 ) : DCNL DCSP DCSP return case _ sensitive ( stem , word ) DCNL DCSP if ( stem in exceptions ) : DCNL DCSP DCSP return case _ sensitive ( exceptions &#91; stem &#93; , word ) DCNL DCSP if ( stem in uninflected ) : DCNL DCSP DCSP return case _ sensitive ( stem , word ) DCNL DCSP stem = upper _ consonant _ y ( stem ) DCNL DCSP for f in ( step _ 1a , step _ 1b , step _ 1c , step _ 2 , step _ 3 , step _ 4 , step _ 5a , step _ 5b ) : DCNL DCSP DCSP stem = f ( stem ) DCNL DCSP stem = stem.lower ( ) DCNL DCSP stem = case _ sensitive ( stem , word ) DCNL DCSP if cached : DCNL DCSP DCSP cache &#91; word.lower ( ) &#93; = stem.lower ( ) DCNL DCSP return stem
DCSP if ( ( not hasattr ( element.props , u &apos;proxy &apos; ) ) or ( not config.get ( u &apos;hostname &apos; ) ) ) : DCNL DCSP DCSP return DCNL DCSP element.set _ property ( u &apos;proxy &apos; , httpclient.format _ proxy ( config , auth = False ) ) DCNL DCSP element.set _ property ( u &apos;proxy-id &apos; , config.get ( u &apos;username &apos; ) ) DCNL DCSP element.set _ property ( u &apos;proxy-pw &apos; , config.get ( u &apos;password &apos; ) )
DCSP runner = SecurityCheckRunner ( ) DCNL DCSP results = runner.run ( ) DCNL DCSP return render _ to _ response ( template _ name , RequestContext ( request , { u &apos;test _ results &apos; : results , u &apos;title &apos; : _ ( u &apos;Security DCSP Checklist &apos; ) } ) )
DCSP if ( repair is None ) : DCNL DCSP DCSP return None DCNL DCSP pp = 0 DCNL DCSP if repair : DCNL DCSP DCSP pp = 1 DCNL DCSP if unpack : DCNL DCSP DCSP pp = 2 DCNL DCSP if delete : DCNL DCSP DCSP pp = 3 DCNL DCSP return pp
DCSP pos = logical _ line.find ( &apos; &lt; &gt; &apos; ) DCNL DCSP if ( pos &gt; ( -1 ) ) : DCNL DCSP DCSP ( yield ( pos , &quot; W603 DCSP &apos; &lt; &gt; &apos; DCSP is DCSP deprecated , DCSP use DCSP &apos; ! = &apos; &quot; ) )
DCSP payload = payload.lower ( ) DCNL DCSP data = data.lower ( ) DCNL DCSP if ( payload not in data ) : DCNL DCSP DCSP return DCNL DCSP data = data.replace ( payload , CONTEXT _ DETECTOR ) DCNL DCSP context _ detector = ContextDetectorHTMLParser ( payload ) DCNL DCSP try : DCNL DCSP DCSP context _ detector.feed ( data ) DCNL DCSP except HTMLParseError : DCNL DCSP DCSP return DCNL DCSP for context in context _ detector.contexts : DCNL DCSP DCSP ( yield context ) DCNL DCSP context _ detector.close ( )
DCSP if ( key in item ) : DCNL DCSP DCSP return item &#91; key &#93; DCNL DCSP nested _ item = item DCNL DCSP for subkey in key.split ( &apos; .&apos; ) : DCNL DCSP DCSP if ( not subkey ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; empty DCSP subkey DCSP in DCSP % r &apos; % key ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP nested _ item = nested _ item &#91; subkey &#93; DCNL DCSP DCSP except KeyError as e : DCNL DCSP DCSP DCSP raise KeyError ( ( &apos; % r DCSP - DCSP looking DCSP up DCSP key DCSP % r DCSP in DCSP % r &apos; % ( e , key , nested _ item ) ) ) DCNL DCSP else : DCNL DCSP DCSP return nested _ item
DCSP try : DCNL DCSP DCSP return _ GA ( obj , &apos; db _ date _ created &apos; ) .strftime ( _ DATESTRING ) DCNL DCSP except AttributeError : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP obj.save ( ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP return _ GA ( obj , &apos; db _ date _ created &apos; ) .strftime ( _ DATESTRING )
DCSP server _ address = ( bind , port ) DCNL DCSP HandlerClass.protocol _ version = protocol DCNL DCSP httpd = ServerClass ( server _ address , HandlerClass ) DCNL DCSP sa = httpd.socket.getsockname ( ) DCNL DCSP print ( &apos; Serving DCSP HTTP DCSP on &apos; , sa &#91; 0 &#93; , &apos; port &apos; , sa &#91; 1 &#93; , &apos; ... &apos; ) DCNL DCSP try : DCNL DCSP DCSP httpd.serve _ forever ( ) DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP print &apos; \ nKeyboard DCSP interrupt DCSP received , DCSP exiting . &apos; DCNL DCSP DCSP httpd.server _ close ( ) DCNL DCSP DCSP sys.exit ( 0 )
DCSP sig = np.zeros ( len ( mag ) ) DCNL DCSP midpt = ( len ( mag ) / / 2 ) DCNL DCSP sig &#91; 1 : midpt &#93; = 1 DCNL DCSP sig &#91; ( midpt + 1 ) : &#93; = ( -1 ) DCNL DCSP recon = ifft ( ( mag * np.exp ( fft ( ( sig * ifft ( np.log ( mag ) ) ) ) ) ) ) .real DCNL DCSP return recon
DCSP Handler ( req ) .run ( gluon.main.wsgibase ) DCNL DCSP return apache.OK
DCSP if is _ random : DCNL DCSP DCSP factor = np.random.uniform ( ( - intensity ) , intensity ) DCNL DCSP else : DCNL DCSP DCSP factor = intensity DCNL DCSP results = &#91; &#93; DCNL DCSP for data in x : DCNL DCSP DCSP data = np.rollaxis ( data , channel _ index , 0 ) DCNL DCSP DCSP ( min _ x , max _ x ) = ( np.min ( data ) , np.max ( data ) ) DCNL DCSP DCSP channel _ images = &#91; np.clip ( ( x _ channel + factor ) , min _ x , max _ x ) for x _ channel in x &#93; DCNL DCSP DCSP data = np.stack ( channel _ images , axis = 0 ) DCNL DCSP DCSP data = np.rollaxis ( x , 0 , ( channel _ index + 1 ) ) DCNL DCSP DCSP results.append ( data ) DCNL DCSP return np.asarray ( results )
DCSP with TestingCanvas ( ) as c : DCNL DCSP DCSP rpolygon = visuals.RegularPolygon ( center = ( 0.0 , 0.0 ) , radius = 0.4 , sides = 8 , color = ( 1 , 0 , 0 , 1 ) , parent = c.scene ) DCNL DCSP DCSP rpolygon.transform = transforms.STTransform ( scale = ( 50 , 50 ) , translate = ( 50 , 50 ) ) DCNL DCSP DCSP assert _ image _ approved ( c.render ( ) , &apos; visuals / regular _ polygon1.png &apos; ) DCNL DCSP DCSP rpolygon.parent = None DCNL DCSP DCSP rpolygon = visuals.RegularPolygon ( center = ( 0.0 , 0.0 ) , radius = 0.4 , sides = 8 , color = ( 1 , 0 , 0 , 1 ) , border _ color = ( 0 , 1 , 1 , 1 ) , parent = c.scene ) DCNL DCSP DCSP rpolygon.transform = transforms.STTransform ( scale = ( 50 , 50 ) , translate = ( 50 , 50 ) ) DCNL DCSP DCSP assert _ image _ approved ( c.render ( ) , &apos; visuals / regular _ polygon2.png &apos; ) DCNL DCSP DCSP rpolygon.parent = None DCNL DCSP DCSP rpolygon = visuals.RegularPolygon ( center = ( 0.0 , 0.0 ) , radius = 0.4 , sides = 8 , border _ color = ( 0 , 1 , 1 , 1 ) , parent = c.scene ) DCNL DCSP DCSP rpolygon.transform = transforms.STTransform ( scale = ( 50 , 50 ) , translate = ( 50 , 50 ) ) DCNL DCSP DCSP assert _ image _ approved ( c.render ( ) , &apos; visuals / regular _ polygon3.png &apos; , min _ corr = 0.7 )
DCSP return datetime.datetime.strptime ( dt _ str , _ RFC3339 _ MICROS ) .replace ( tzinfo = UTC )
DCSP for i in range ( 0 , randint ( 0 , 5 ) ) : DCNL DCSP DCSP random _ index = randint ( 0 , ( Region.objects.all ( ) .count ( ) - 1 ) ) DCNL DCSP DCSP region = Region.objects.all ( ) &#91; random _ index &#93; DCNL DCSP DCSP resource.regions.add ( region )
DCSP with open ( path , &apos; r &apos; ) as f : DCNL DCSP DCSP target.update ( flatten ( yaml.load ( f , Loader = yaml.Loader ) ) )
DCSP kind = &apos; rnd &apos; DCNL DCSP smote = SMOTE ( kind = kind , random _ state = RND _ SEED ) DCNL DCSP assert _ raises ( ValueError , smote.fit _ sample , X , Y )
DCSP _ find _ server ( cs , args.server ) .unrescue ( )
DCSP if ( 1 in coeff ) : DCNL DCSP DCSP c = ( - coeff &#91; 1 &#93; ) DCNL DCSP else : DCNL DCSP DCSP c = 0 DCNL DCSP if ( param is None ) : DCNL DCSP DCSP params = ( &#91; symbols ( &apos; t &apos; ) &#93; * len ( var ) ) DCNL DCSP else : DCNL DCSP DCSP temp = ( str ( param ) + &apos; _ % i &apos; ) DCNL DCSP DCSP params = &#91; symbols ( ( temp % i ) , integer = True ) for i in range ( len ( var ) ) &#93; DCNL DCSP if ( len ( var ) = = 1 ) : DCNL DCSP DCSP ( q , r ) = divmod ( c , coeff &#91; var &#91; 0 &#93; &#93; ) DCNL DCSP DCSP if ( not r ) : DCNL DCSP DCSP DCSP return ( q , ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( None , ) DCNL DCSP &quot; \ n DCSP DCSP DCSP DCSP base _ solution _ linear ( ) DCSP can DCSP solve DCSP diophantine DCSP equations DCSP of DCSP the DCSP form : \ n \ n DCSP DCSP DCSP DCSP a * x DCSP + DCSP b * y DCSP = = DCSP c \ n \ n DCSP DCSP DCSP DCSP We DCSP break DCSP down DCSP multivariate DCSP linear DCSP diophantine DCSP equations DCSP into DCSP a \ n DCSP DCSP DCSP DCSP series DCSP of DCSP bivariate DCSP linear DCSP diophantine DCSP equations DCSP which DCSP can DCSP then \ n DCSP DCSP DCSP DCSP be DCSP solved DCSP individually DCSP by DCSP base _ solution _ linear ( ) . \ n \ n DCSP DCSP DCSP DCSP Consider DCSP the DCSP following : \ n \ n DCSP DCSP DCSP DCSP a _ 0 * x _ 0 DCSP + DCSP a _ 1 * x _ 1 DCSP + DCSP a _ 2 * x _ 2 DCSP = = DCSP c \ n \ n DCSP DCSP DCSP DCSP which DCSP can DCSP be DCSP re-written DCSP as : \ n \ n DCSP DCSP DCSP DCSP a _ 0 * x _ 0 DCSP + DCSP g _ 0 * y _ 0 DCSP = = DCSP c \ n \ n DCSP DCSP DCSP DCSP where \ n \ n DCSP DCSP DCSP DCSP g _ 0 DCSP = = DCSP gcd ( a _ 1 , DCSP a _ 2 ) \ n \ n DCSP DCSP DCSP DCSP and \ n \ n DCSP DCSP DCSP DCSP y DCSP = = DCSP ( a _ 1 * x _ 1 ) / g _ 0 DCSP + DCSP ( a _ 2 * x _ 2 ) / g _ 0 \ n \ n DCSP DCSP DCSP DCSP This DCSP leaves DCSP us DCSP with DCSP two DCSP binary DCSP linear DCSP diophantine DCSP equations . \ n DCSP DCSP DCSP DCSP For DCSP the DCSP first DCSP equation : \ n \ n DCSP DCSP DCSP DCSP a DCSP = = DCSP a _ 0 \ n DCSP DCSP DCSP DCSP b DCSP = = DCSP g _ 0 \ n DCSP DCSP DCSP DCSP c DCSP = = DCSP c \ n \ n DCSP DCSP DCSP DCSP For DCSP the DCSP second : \ n \ n DCSP DCSP DCSP DCSP a DCSP = = DCSP a _ 1 / g _ 0 \ n DCSP DCSP DCSP DCSP b DCSP = = DCSP a _ 2 / g _ 0 \ n DCSP DCSP DCSP DCSP c DCSP = = DCSP the DCSP solution DCSP we DCSP find DCSP for DCSP y _ 0 DCSP in DCSP the DCSP first DCSP equation . \ n \ n DCSP DCSP DCSP DCSP The DCSP arrays DCSP A DCSP and DCSP B DCSP are DCSP the DCSP arrays DCSP of DCSP integers DCSP used DCSP for \ n DCSP DCSP DCSP DCSP &apos; a &apos; DCSP and DCSP &apos; b &apos; DCSP in DCSP each DCSP of DCSP the DCSP n-1 DCSP bivariate DCSP equations DCSP we DCSP solve . \ n DCSP DCSP DCSP DCSP &quot; DCNL DCSP A = &#91; coeff &#91; v &#93; for v in var &#93; DCNL DCSP B = &#91; &#93; DCNL DCSP if ( len ( var ) &gt; 2 ) : DCNL DCSP DCSP B.append ( igcd ( A &#91; ( -2 ) &#93; , A &#91; ( -1 ) &#93; ) ) DCNL DCSP DCSP A &#91; ( -2 ) &#93; = ( A &#91; ( -2 ) &#93; / / B &#91; 0 &#93; ) DCNL DCSP DCSP A &#91; ( -1 ) &#93; = ( A &#91; ( -1 ) &#93; / / B &#91; 0 &#93; ) DCNL DCSP DCSP for i in range ( ( len ( A ) - 3 ) , 0 , ( -1 ) ) : DCNL DCSP DCSP DCSP gcd = igcd ( B &#91; 0 &#93; , A &#91; i &#93; ) DCNL DCSP DCSP DCSP B &#91; 0 &#93; = ( B &#91; 0 &#93; / / gcd ) DCNL DCSP DCSP DCSP A &#91; i &#93; = ( A &#91; i &#93; / / gcd ) DCNL DCSP DCSP DCSP B.insert ( 0 , gcd ) DCNL DCSP B.append ( A &#91; ( -1 ) &#93; ) DCNL DCSP &quot; \ n DCSP DCSP DCSP DCSP Consider DCSP the DCSP trivariate DCSP linear DCSP equation : \ n \ n DCSP DCSP DCSP DCSP 4 * x _ 0 DCSP + DCSP 6 * x _ 1 DCSP + DCSP 3 * x _ 2 DCSP = = DCSP 2 \ n \ n DCSP DCSP DCSP DCSP This DCSP can DCSP be DCSP re-written DCSP as : \ n \ n DCSP DCSP DCSP DCSP 4 * x _ 0 DCSP + DCSP 3 * y _ 0 DCSP = = DCSP 2 \ n \ n DCSP DCSP DCSP DCSP where \ n \ n DCSP DCSP DCSP DCSP y _ 0 DCSP = = DCSP 2 * x _ 1 DCSP + DCSP x _ 2 \ n DCSP DCSP DCSP DCSP ( Note DCSP that DCSP gcd ( 3 , DCSP 6 ) DCSP = = DCSP 3 ) \ n \ n DCSP DCSP DCSP DCSP The DCSP complete DCSP integral DCSP solution DCSP to DCSP this DCSP equation DCSP is : \ n \ n DCSP DCSP DCSP DCSP x _ 0 DCSP = = DCSP DCSP 2 DCSP + DCSP 3 * t _ 0 \ n DCSP DCSP DCSP DCSP y _ 0 DCSP = = DCSP -2 DCSP - DCSP 4 * t _ 0 \ n \ n DCSP DCSP DCSP DCSP where DCSP &apos; t _ 0 &apos; DCSP is DCSP any DCSP integer . \ n \ n DCSP DCSP DCSP DCSP Now DCSP that DCSP we DCSP have DCSP a DCSP solution DCSP for DCSP &apos; x _ 0 &apos; , DCSP find DCSP &apos; x _ 1 &apos; DCSP and DCSP &apos; x _ 2 &apos; : \ n \ n DCSP DCSP DCSP DCSP 2 * x _ 1 DCSP + DCSP x _ 2 DCSP = = DCSP -2 DCSP - DCSP 4 * t _ 0 \ n \ n DCSP DCSP DCSP DCSP We DCSP can DCSP then DCSP solve DCSP for DCSP &apos; -2 &apos; DCSP and DCSP &apos; -4 &apos; DCSP independently , \ n DCSP DCSP DCSP DCSP and DCSP combine DCSP the DCSP results : \ n \ n DCSP DCSP DCSP DCSP 2 * x _ 1a DCSP + DCSP x _ 2a DCSP = = DCSP -2 \ n DCSP DCSP DCSP DCSP x _ 1a DCSP = = DCSP 0 DCSP + DCSP t _ 0 \ n DCSP DCSP DCSP DCSP x _ 2a DCSP = = DCSP -2 DCSP - DCSP 2 * t _ 0 \ n \ n DCSP DCSP DCSP DCSP 2 * x _ 1b DCSP + DCSP x _ 2b DCSP = = DCSP -4 * t _ 0 \ n DCSP DCSP DCSP DCSP x _ 1b DCSP = = DCSP 0 * t _ 0 DCSP + DCSP t _ 1 \ n DCSP DCSP DCSP DCSP x _ 2b DCSP = = DCSP -4 * t _ 0 DCSP - DCSP 2 * t _ 1 \ n \ n DCSP DCSP DCSP DCSP = = &gt; \ n \ n DCSP DCSP DCSP DCSP x _ 1 DCSP = = DCSP t _ 0 DCSP + DCSP t _ 1 \ n DCSP DCSP DCSP DCSP x _ 2 DCSP = = DCSP -2 DCSP - DCSP 6 * t _ 0 DCSP - DCSP 2 * t _ 1 \ n \ n DCSP DCSP DCSP DCSP where DCSP &apos; t _ 0 &apos; DCSP and DCSP &apos; t _ 1 &apos; DCSP are DCSP any DCSP integers . \ n \ n DCSP DCSP DCSP DCSP Note DCSP that : \ n \ n DCSP DCSP DCSP DCSP 4 * ( 2 DCSP + DCSP 3 * t _ 0 ) DCSP + DCSP 6 * ( t _ 0 DCSP + DCSP t _ 1 ) DCSP + DCSP 3 * ( -2 DCSP - DCSP 6 * t _ 0 DCSP - DCSP 2 * t _ 1 ) DCSP = = DCSP 2 \ n \ n DCSP DCSP DCSP DCSP for DCSP any DCSP integral DCSP values DCSP of DCSP &apos; t _ 0 &apos; , DCSP &apos; t _ 1 &apos; ; DCSP as DCSP required . \ n \ n DCSP DCSP DCSP DCSP This DCSP method DCSP is DCSP generalised DCSP for DCSP many DCSP variables , DCSP below . \ n \ n DCSP DCSP DCSP DCSP &quot; DCNL DCSP solutions = &#91; &#93; DCNL DCSP for i in range ( len ( B ) ) : DCNL DCSP DCSP ( tot _ x , tot _ y ) = ( &#91; &#93; , &#91; &#93; ) DCNL DCSP DCSP for ( j , arg ) in enumerate ( Add.make _ args ( c ) ) : DCNL DCSP DCSP DCSP if arg.is _ Integer : DCNL DCSP DCSP DCSP DCSP ( k , p ) = ( arg , S.One ) DCNL DCSP DCSP DCSP DCSP pnew = params &#91; 0 &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ( k , p ) = arg.as _ coeff _ Mul ( ) DCNL DCSP DCSP DCSP DCSP pnew = params &#91; ( params.index ( p ) + 1 ) &#93; DCNL DCSP DCSP DCSP sol = ( sol _ x , sol _ y ) = base _ solution _ linear ( k , A &#91; i &#93; , B &#91; i &#93; , pnew ) DCNL DCSP DCSP DCSP if ( p is S.One ) : DCNL DCSP DCSP DCSP DCSP if ( None in sol ) : DCNL DCSP DCSP DCSP DCSP DCSP return tuple ( ( &#91; None &#93; * len ( var ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if isinstance ( sol _ x , Add ) : DCNL DCSP DCSP DCSP DCSP DCSP sol _ x = ( ( sol _ x.args &#91; 0 &#93; * p ) + sol _ x.args &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP if isinstance ( sol _ y , Add ) : DCNL DCSP DCSP DCSP DCSP DCSP sol _ y = ( ( sol _ y.args &#91; 0 &#93; * p ) + sol _ y.args &#91; 1 &#93; ) DCNL DCSP DCSP DCSP tot _ x.append ( sol _ x ) DCNL DCSP DCSP DCSP tot _ y.append ( sol _ y ) DCNL DCSP DCSP solutions.append ( Add ( * tot _ x ) ) DCNL DCSP DCSP c = Add ( * tot _ y ) DCNL DCSP solutions.append ( c ) DCNL DCSP if ( param is None ) : DCNL DCSP DCSP solutions = &#91; i.as _ coeff _ Add ( ) &#91; 0 &#93; for i in solutions &#93; DCNL DCSP return tuple ( solutions )
DCSP return utils.system ( ( &apos; ln DCSP -sf DCSP % s DCSP % s &apos; % ( src , dest ) ) )
DCSP pass
DCSP assert odoo.conf.deprecation.allow _ local _ service DCNL DCSP _ logger.warning ( ( &quot; LocalService ( ) DCSP is DCSP deprecated DCSP since DCSP march DCSP 2013 DCSP ( it DCSP was DCSP called DCSP with DCSP &apos; % s &apos; ) . &quot; % name ) ) DCNL DCSP if ( name = = &apos; workflow &apos; ) : DCNL DCSP DCSP return odoo.workflow DCNL DCSP if name.startswith ( &apos; report . &apos; ) : DCNL DCSP DCSP report = odoo.report.interface.report _ int . _ reports.get ( name ) DCNL DCSP DCSP if report : DCNL DCSP DCSP DCSP return report DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP dbname = getattr ( threading.currentThread ( ) , &apos; dbname &apos; , None ) DCNL DCSP DCSP DCSP if dbname : DCNL DCSP DCSP DCSP DCSP registry = odoo.registry ( dbname ) DCNL DCSP DCSP DCSP DCSP with registry.cursor ( ) as cr : DCNL DCSP DCSP DCSP DCSP DCSP return registry &#91; &apos; ir.actions.report.xml &apos; &#93; . _ lookup _ report ( cr , name &#91; len ( &apos; report . &apos; ) : &#93; )
DCSP options.allowed _ flags ( args , &#91; &apos; auto &apos; , &apos; polys &apos; &#93; ) DCNL DCSP try : DCNL DCSP DCSP ( F , opt ) = poly _ from _ expr ( f , * gens , * * args ) DCNL DCSP except PolificationFailed as exc : DCNL DCSP DCSP raise ComputationFailed ( &apos; monic &apos; , 1 , exc ) DCNL DCSP result = F.monic ( auto = opt.auto ) DCNL DCSP if ( not opt.polys ) : DCNL DCSP DCSP return result.as _ expr ( ) DCNL DCSP else : DCNL DCSP DCSP return result
DCSP @ functools.wraps ( f ) DCNL DCSP def wrapper ( self , hints , * args , * * kwargs ) : DCNL DCSP DCSP if ( not hasattr ( hints , &apos; limit &apos; ) ) : DCNL DCSP DCSP DCSP raise exception.UnexpectedError ( _ ( &apos; Cannot DCSP truncate DCSP a DCSP driver DCSP call DCSP without DCSP hints DCSP list DCSP as DCSP first DCSP parameter DCSP after DCSP self DCSP &apos; ) ) DCNL DCSP DCSP if ( ( hints.limit is None ) or hints.filters ) : DCNL DCSP DCSP DCSP return f ( self , hints , * args , * * kwargs ) DCNL DCSP DCSP list _ limit = hints.limit &#91; &apos; limit &apos; &#93; DCNL DCSP DCSP hints.set _ limit ( ( list _ limit + 1 ) ) DCNL DCSP DCSP ref _ list = f ( self , hints , * args , * * kwargs ) DCNL DCSP DCSP if ( len ( ref _ list ) &gt; list _ limit ) : DCNL DCSP DCSP DCSP hints.set _ limit ( list _ limit , truncated = True ) DCNL DCSP DCSP DCSP return ref _ list &#91; : list _ limit &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP hints.set _ limit ( list _ limit ) DCNL DCSP DCSP DCSP return ref _ list DCNL DCSP return wrapper
DCSP try : DCNL DCSP DCSP import sip DCNL DCSP except ImportError : DCNL DCSP DCSP return DCNL DCSP try : DCNL DCSP DCSP return sip.getapi ( &apos; QString &apos; ) DCNL DCSP except ValueError : DCNL DCSP DCSP return
DCSP if ( not isinstance ( node , ( AsyncFunctionDef , FunctionDef , ClassDef , Module ) ) ) : DCNL DCSP DCSP raise TypeError ( ( &quot; % r DCSP can &apos;t DCSP have DCSP docstrings &quot; % node . _ _ class _ _ . _ _ name _ _ ) ) DCNL DCSP if ( not ( node.body and isinstance ( node.body &#91; 0 &#93; , Expr ) ) ) : DCNL DCSP DCSP return DCNL DCSP node = node.body &#91; 0 &#93; .value DCNL DCSP if isinstance ( node , Str ) : DCNL DCSP DCSP text = node.s DCNL DCSP elif ( isinstance ( node , Constant ) and isinstance ( node.value , str ) ) : DCNL DCSP DCSP text = node.value DCNL DCSP else : DCNL DCSP DCSP return DCNL DCSP if clean : DCNL DCSP DCSP import inspect DCNL DCSP DCSP text = inspect.cleandoc ( text ) DCNL DCSP return text
DCSP prev _ current _ app = _ state.get _ current _ app ( ) DCNL DCSP prev _ default _ app = _ state.default _ app DCNL DCSP prev _ finalizers = set ( _ state . _ on _ app _ finalizers ) DCNL DCSP prev _ apps = weakref.WeakSet ( _ state . _ apps ) DCNL DCSP if use _ trap : DCNL DCSP DCSP with set _ trap ( app ) : DCNL DCSP DCSP DCSP ( yield ) DCNL DCSP else : DCNL DCSP DCSP ( yield ) DCNL DCSP _ state.set _ default _ app ( prev _ default _ app ) DCNL DCSP _ state . _ tls.current _ app = prev _ current _ app DCNL DCSP if ( app is not prev _ current _ app ) : DCNL DCSP DCSP app.close ( ) DCNL DCSP _ state . _ on _ app _ finalizers = prev _ finalizers DCNL DCSP _ state . _ apps = prev _ apps
DCSP if ( not string ) : DCNL DCSP DCSP string.split DCNL DCSP DCSP return &apos; &apos; DCNL DCSP if isinstance ( string , str ) : DCNL DCSP DCSP string = string.encode ( &apos; utf-8 &apos; ) DCNL DCSP res = string.split ( &apos; % &apos; ) DCNL DCSP if ( len ( res ) = = 1 ) : DCNL DCSP DCSP return string DCNL DCSP string = res &#91; 0 &#93; DCNL DCSP for item in res &#91; 1 : &#93; : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP string + = ( bytes ( &#91; int ( item &#91; : 2 &#93; , 16 ) &#93; ) + item &#91; 2 : &#93; ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP string + = ( &apos; % &apos; + item ) DCNL DCSP return string
DCSP return &apos; iprand _ all&apos;
DCSP derivation = InsetDerivation ( elementNode , prefix ) DCNL DCSP return intercircle.getInsetLoopsFromVector3Loop ( loop , derivation.radius )
DCSP data = { } DCNL DCSP course _ key = SlashSeparatedCourseKey.from _ deprecated _ string ( course _ id ) DCNL DCSP if has _ instructor _ access _ for _ class ( request.user , course _ key ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = dashboard _ data.get _ d3 _ section _ grade _ distrib ( course _ key , section ) DCNL DCSP DCSP except Exception as ex : DCNL DCSP DCSP DCSP log.error ( &apos; Generating DCSP metrics DCSP failed DCSP with DCSP exception : DCSP % s &apos; , ex ) DCNL DCSP DCSP DCSP data = { &apos; error &apos; : &apos; error &apos; } DCNL DCSP else : DCNL DCSP DCSP data = { &apos; error &apos; : &quot; Access DCSP Denied : DCSP User DCSP does DCSP not DCSP have DCSP access DCSP to DCSP this DCSP course &apos;s DCSP data &quot; } DCNL DCSP return HttpResponse ( json.dumps ( data ) , content _ type = &apos; application / json &apos; )
DCSP from django.db import backend , models DCNL DCSP output = &#91; &#93; DCNL DCSP for model in models.get _ models ( app ) : DCNL DCSP DCSP for f in model . _ meta.fields : DCNL DCSP DCSP DCSP if isinstance ( f , models.AutoField ) : DCNL DCSP DCSP DCSP DCSP output.append ( ( &quot; % s DCSP setval ( &apos; % s &apos; , DCSP ( % s DCSP max ( % s ) DCSP % s DCSP % s ) ) ; &quot; % ( style.SQL _ KEYWORD ( &apos; SELECT &apos; ) , style.SQL _ FIELD ( ( &apos; % s _ % s _ seq &apos; % ( model . _ meta.db _ table , f.column ) ) ) , style.SQL _ KEYWORD ( &apos; SELECT &apos; ) , style.SQL _ FIELD ( backend.quote _ name ( f.column ) ) , style.SQL _ KEYWORD ( &apos; FROM &apos; ) , style.SQL _ TABLE ( backend.quote _ name ( model . _ meta.db _ table ) ) ) ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP for f in model . _ meta.many _ to _ many : DCNL DCSP DCSP DCSP output.append ( ( &quot; % s DCSP setval ( &apos; % s &apos; , DCSP ( % s DCSP max ( % s ) DCSP % s DCSP % s ) ) ; &quot; % ( style.SQL _ KEYWORD ( &apos; SELECT &apos; ) , style.SQL _ FIELD ( ( &apos; % s _ id _ seq &apos; % f.m2m _ db _ table ( ) ) ) , style.SQL _ KEYWORD ( &apos; SELECT &apos; ) , style.SQL _ FIELD ( backend.quote _ name ( &apos; id &apos; ) ) , style.SQL _ KEYWORD ( &apos; FROM &apos; ) , style.SQL _ TABLE ( f.m2m _ db _ table ( ) ) ) ) ) DCNL DCSP return output
DCSP if python _ build : DCNL DCSP DCSP return os.path.join ( project _ base , &apos; Makefile &apos; ) DCNL DCSP lib _ dir = get _ python _ lib ( plat _ specific = 1 , standard _ lib = 1 ) DCNL DCSP return os.path.join ( lib _ dir , &apos; config &apos; , &apos; Makefile &apos; )
DCSP if debug : DCNL DCSP DCSP print &apos; Making DCSP debug DCSP output &apos; DCNL DCSP ( body , header , comments ) = parse _ mapping _ file ( input _ map ) DCNL DCSP if debug : DCNL DCSP DCSP print &apos; HEADER : &apos; , header DCNL DCSP key _ index = header.index ( &apos; KEY _ SEQ &apos; ) DCNL DCSP bc _ index = header.index ( &apos; BARCODE &apos; ) DCNL DCSP if ( &apos; LINKER &apos; in header ) : DCNL DCSP DCSP linker _ index = header.index ( &apos; LINKER &apos; ) DCNL DCSP else : DCNL DCSP DCSP linker _ index = None DCNL DCSP primer _ index = header.index ( &apos; PRIMER &apos; ) DCNL DCSP technical _ lengths = { } DCNL DCSP for fields in body : DCNL DCSP DCSP curr _ tech _ len = ( ( len ( fields &#91; key _ index &#93; ) + len ( fields &#91; bc _ index &#93; ) ) + len ( fields &#91; primer _ index &#93; ) ) DCNL DCSP DCSP if ( linker _ index is not None ) : DCNL DCSP DCSP DCSP curr _ tech _ len + = len ( fields &#91; linker _ index &#93; ) DCNL DCSP DCSP technical _ lengths &#91; fields &#91; 0 &#93; &#93; = curr _ tech _ len DCNL DCSP if debug : DCNL DCSP DCSP print &apos; Technical DCSP lengths : &apos; DCNL DCSP DCSP print technical _ lengths DCNL DCSP return technical _ lengths
DCSP for ( semi _ ind , node ) in enumerate ( stmt _ node.children ) : DCNL DCSP DCSP if ( node.type = = token.SEMI ) : DCNL DCSP DCSP DCSP break DCNL DCSP else : DCNL DCSP DCSP return DCNL DCSP node.remove ( ) DCNL DCSP new _ expr = Node ( syms.expr _ stmt , &#91; &#93; ) DCNL DCSP new _ stmt = Node ( syms.simple _ stmt , &#91; new _ expr &#93; ) DCNL DCSP while stmt _ node.children &#91; semi _ ind : &#93; : DCNL DCSP DCSP move _ node = stmt _ node.children &#91; semi _ ind &#93; DCNL DCSP DCSP new _ expr.append _ child ( move _ node.clone ( ) ) DCNL DCSP DCSP move _ node.remove ( ) DCNL DCSP parent.insert _ child ( i , new _ stmt ) DCNL DCSP new _ leaf1 = new _ stmt.children &#91; 0 &#93; .children &#91; 0 &#93; DCNL DCSP old _ leaf1 = stmt _ node.children &#91; 0 &#93; .children &#91; 0 &#93; DCNL DCSP new _ leaf1.set _ prefix ( old _ leaf1.get _ prefix ( ) )
DCSP from Bio import AlignIO DCNL DCSP if ( format in _ BinaryFormats ) : DCNL DCSP DCSP mode = &apos; rb &apos; DCNL DCSP else : DCNL DCSP DCSP mode = &apos; rU &apos; DCNL DCSP if ( not isinstance ( format , basestring ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Need DCSP a DCSP string DCSP for DCSP the DCSP file DCSP format DCSP ( lower DCSP case ) &apos; ) DCNL DCSP if ( not format ) : DCNL DCSP DCSP raise ValueError ( &apos; Format DCSP required DCSP ( lower DCSP case DCSP string ) &apos; ) DCNL DCSP if ( format ! = format.lower ( ) ) : DCNL DCSP DCSP raise ValueError ( ( &quot; Format DCSP string DCSP &apos; % s &apos; DCSP should DCSP be DCSP lower DCSP case &quot; % format ) ) DCNL DCSP if ( ( alphabet is not None ) and ( not ( isinstance ( alphabet , Alphabet ) or isinstance ( alphabet , AlphabetEncoder ) ) ) ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Invalid DCSP alphabet , DCSP % r &apos; % alphabet ) ) DCNL DCSP with as _ handle ( handle , mode ) as fp : DCNL DCSP DCSP if ( format in _ FormatToIterator ) : DCNL DCSP DCSP DCSP iterator _ generator = _ FormatToIterator &#91; format &#93; DCNL DCSP DCSP DCSP if ( alphabet is None ) : DCNL DCSP DCSP DCSP DCSP i = iterator _ generator ( fp ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP i = iterator _ generator ( fp , alphabet = alphabet ) DCNL DCSP DCSP DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP DCSP DCSP i = _ force _ alphabet ( iterator _ generator ( fp ) , alphabet ) DCNL DCSP DCSP elif ( format in AlignIO . _ FormatToIterator ) : DCNL DCSP DCSP DCSP i = ( r for alignment in AlignIO.parse ( fp , format , alphabet = alphabet ) for r in alignment ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( ( &quot; Unknown DCSP format DCSP &apos; % s &apos; &quot; % format ) ) DCNL DCSP DCSP for r in i : DCNL DCSP DCSP DCSP ( yield r )
DCSP parameters = dict ( ) DCNL DCSP parameters &#91; &apos; room _ id &apos; &#93; = room _ id DCNL DCSP parameters &#91; &apos; from &apos; &#93; = from _ name &#91; : 15 &#93; DCNL DCSP parameters &#91; &apos; message &apos; &#93; = message &#91; : 10000 &#93; DCNL DCSP parameters &#91; &apos; message _ format &apos; &#93; = &apos; text &apos; DCNL DCSP parameters &#91; &apos; color &apos; &#93; = color DCNL DCSP parameters &#91; &apos; notify &apos; &#93; = notify DCNL DCSP result = _ query ( function = &apos; message &apos; , api _ key = api _ key , api _ version = api _ version , room _ id = room _ id , api _ url = api _ url , method = &apos; POST &apos; , data = parameters ) DCNL DCSP if result : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP global _ accepted DCNL DCSP from django.conf import settings DCNL DCSP supported = dict ( settings.LANGUAGES ) DCNL DCSP if hasattr ( request , &apos; session &apos; ) : DCNL DCSP DCSP lang _ code = request.session.get ( &apos; django _ language &apos; , None ) DCNL DCSP DCSP if ( ( lang _ code in supported ) and ( lang _ code is not None ) and check _ for _ language ( lang _ code ) ) : DCNL DCSP DCSP DCSP return lang _ code DCNL DCSP lang _ code = request.COOKIES.get ( settings.LANGUAGE _ COOKIE _ NAME ) DCNL DCSP if ( lang _ code and ( lang _ code not in supported ) ) : DCNL DCSP DCSP lang _ code = lang _ code.split ( &apos; -&apos; ) &#91; 0 &#93; DCNL DCSP if ( lang _ code and ( lang _ code in supported ) and check _ for _ language ( lang _ code ) ) : DCNL DCSP DCSP return lang _ code DCNL DCSP accept = request.META.get ( &apos; HTTP _ ACCEPT _ LANGUAGE &apos; , &apos; &apos; ) DCNL DCSP for ( accept _ lang , unused ) in parse _ accept _ lang _ header ( accept ) : DCNL DCSP DCSP if ( accept _ lang = = &apos; * &apos; ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP normalized = locale.locale _ alias.get ( to _ locale ( accept _ lang , True ) ) DCNL DCSP DCSP if ( not normalized ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP normalized = normalized.split ( &apos; .&apos; ) &#91; 0 &#93; DCNL DCSP DCSP if ( normalized in _ accepted ) : DCNL DCSP DCSP DCSP return _ accepted &#91; normalized &#93; DCNL DCSP DCSP for ( lang , dirname ) in ( ( accept _ lang , normalized ) , ( accept _ lang.split ( &apos; -&apos; ) &#91; 0 &#93; , normalized.split ( &apos; _ &apos; ) &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP if ( lang.lower ( ) not in supported ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for path in all _ locale _ paths ( ) : DCNL DCSP DCSP DCSP DCSP if os.path.exists ( os.path.join ( path , dirname , &apos; LC _ MESSAGES &apos; , &apos; django.mo &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP _ accepted &#91; normalized &#93; = lang DCNL DCSP DCSP DCSP DCSP DCSP return lang DCNL DCSP return settings.LANGUAGE _ CODE
DCSP values = { &apos; entity _ id &apos; : entity _ id , &apos; traversal _ id &apos; : traversal _ id , &apos; is _ update &apos; : is _ update , &apos; atomic _ key &apos; : 0 , &apos; stack _ id &apos; : stack _ id , &apos; input _ data &apos; : { } } DCNL DCSP return sync _ point _ object.SyncPoint.create ( context , values )
DCSP k = np.asarray ( k ) DCNL DCSP if ( k.size &gt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; k DCSP must DCSP be DCSP a DCSP single DCSP scalar DCSP gain &apos; ) DCNL DCSP if ( worN is None ) : DCNL DCSP DCSP w = findfreqs ( z , p , 200 , kind = &apos; zp &apos; ) DCNL DCSP elif isinstance ( worN , int ) : DCNL DCSP DCSP N = worN DCNL DCSP DCSP w = findfreqs ( z , p , N , kind = &apos; zp &apos; ) DCNL DCSP else : DCNL DCSP DCSP w = worN DCNL DCSP w = atleast _ 1d ( w ) DCNL DCSP s = ( 1j * w ) DCNL DCSP num = polyvalfromroots ( s , z ) DCNL DCSP den = polyvalfromroots ( s , p ) DCNL DCSP h = ( ( k * num ) / den ) DCNL DCSP return ( w , h )
DCSP if ( ( value is None ) or ( not value.strip ( ) ) ) : DCNL DCSP DCSP raise ValidationValueError ( &apos; Title DCSP cannot DCSP be DCSP blank . &apos; ) DCNL DCSP value = strip _ html ( value ) DCNL DCSP if ( ( value is None ) or ( not value.strip ( ) ) ) : DCNL DCSP DCSP raise ValidationValueError ( &apos; Invalid DCSP title . &apos; ) DCNL DCSP if ( len ( value ) &gt; 200 ) : DCNL DCSP DCSP raise ValidationValueError ( &apos; Title DCSP cannot DCSP exceed DCSP 200 DCSP characters . &apos; ) DCNL DCSP return True
DCSP return search _ services.search ( query , SEARCH _ INDEX _ EXPLORATIONS , cursor , limit , sort , ids _ only = True )
DCSP return captured _ output ( &apos; stdout &apos; )
DCSP if ( not issubclass ( handler , MimetypeHandler ) ) : DCNL DCSP DCSP raise TypeError ( u &apos;Only DCSP MimetypeHandler DCSP subclasses DCSP can DCSP be DCSP registered &apos; ) DCNL DCSP _ registered _ mimetype _ handlers.append ( handler )
DCSP _ validate _ db _ int ( max _ rows = max _ rows ) DCNL DCSP session = ( session or get _ session ( ) ) DCNL DCSP metadata = MetaData ( get _ engine ( ) ) DCNL DCSP deleted _ age = ( timeutils.utcnow ( ) - datetime.timedelta ( days = age _ in _ days ) ) DCNL DCSP tables = &#91; &#93; DCNL DCSP for model _ class in models . _ _ dict _ _ .values ( ) : DCNL DCSP DCSP if ( not hasattr ( model _ class , &apos; _ _ tablename _ _ &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if hasattr ( model _ class , &apos; deleted &apos; ) : DCNL DCSP DCSP DCSP tables.append ( model _ class . _ _ tablename _ _ ) DCNL DCSP for tbl in ( &apos; images &apos; , &apos; tasks &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP tables.remove ( tbl ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP LOG.warning ( _ LW ( &apos; Expected DCSP table DCSP % ( tbl ) s DCSP was DCSP not DCSP found DCSP in DCSP DB . &apos; ) , { &apos; tbl &apos; : tbl } ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP tables.append ( tbl ) DCNL DCSP for tbl in tables : DCNL DCSP DCSP tab = Table ( tbl , metadata , autoload = True ) DCNL DCSP DCSP LOG.info ( _ LI ( &apos; Purging DCSP deleted DCSP rows DCSP older DCSP than DCSP % ( age _ in _ days ) d DCSP day ( s ) DCSP from DCSP table DCSP % ( tbl ) s &apos; ) , { &apos; age _ in _ days &apos; : age _ in _ days , &apos; tbl &apos; : tbl } ) DCNL DCSP DCSP column = tab.c.id DCNL DCSP DCSP deleted _ at _ column = tab.c.deleted _ at DCNL DCSP DCSP query _ delete = sql.select ( &#91; column &#93; , ( deleted _ at _ column &lt; deleted _ age ) ) .order _ by ( deleted _ at _ column ) .limit ( max _ rows ) DCNL DCSP DCSP delete _ statement = DeleteFromSelect ( tab , query _ delete , column ) DCNL DCSP DCSP with session.begin ( ) : DCNL DCSP DCSP DCSP result = session.execute ( delete _ statement ) DCNL DCSP DCSP rows = result.rowcount DCNL DCSP DCSP LOG.info ( _ LI ( &apos; Deleted DCSP % ( rows ) d DCSP row ( s ) DCSP from DCSP table DCSP % ( tbl ) s &apos; ) , { &apos; rows &apos; : rows , &apos; tbl &apos; : tbl } )
DCSP check _ usage ( mne _ bti2fiff )
DCSP containers.refresh ( ) DCNL DCSP for container in manager.get _ differing _ containers ( ) : DCNL DCSP DCSP manager.stop _ containers ( &#91; container &#93; ) DCNL DCSP DCSP manager.remove _ containers ( &#91; container &#93; ) DCNL DCSP started ( manager , containers , count , name )
DCSP return StoragePool ( reactor , create _ zfs _ pool ( test _ case ) , FilePath ( test _ case.mktemp ( ) ) )
DCSP if ( block and block.has _ score ) : DCNL DCSP DCSP max _ score = block.max _ score ( ) DCNL DCSP DCSP if ( max _ score is not None ) : DCNL DCSP DCSP DCSP PROBLEM _ RAW _ SCORE _ CHANGED.send ( sender = None , raw _ earned = 0 , raw _ possible = max _ score , weight = getattr ( block , &apos; weight &apos; , None ) , user _ id = student.id , course _ id = unicode ( course _ id ) , usage _ id = unicode ( module _ state _ key ) , score _ deleted = True , only _ if _ higher = False , modified = datetime.now ( ) .replace ( tzinfo = pytz.UTC ) , score _ db _ table = ScoreDatabaseTableEnum.courseware _ student _ module )
DCSP course _ key = SlashSeparatedCourseKey.from _ deprecated _ string ( course _ id ) DCNL DCSP try : DCNL DCSP DCSP usage _ key = course _ key.make _ usage _ key _ from _ deprecated _ string ( location ) DCNL DCSP except ( InvalidKeyError , AssertionError ) : DCNL DCSP DCSP return HttpResponse ( escape ( _ ( u &apos;Invalid DCSP location . &apos; ) ) ) DCNL DCSP course = get _ course _ overview _ with _ access ( request.user , &apos; load &apos; , course _ key ) DCNL DCSP staff _ access = bool ( has _ access ( request.user , &apos; staff &apos; , course ) ) DCNL DCSP if ( ( student _ username ! = request.user.username ) and ( not staff _ access ) ) : DCNL DCSP DCSP raise PermissionDenied DCNL DCSP user _ state _ client = DjangoXBlockUserStateClient ( ) DCNL DCSP try : DCNL DCSP DCSP history _ entries = list ( user _ state _ client.get _ history ( student _ username , usage _ key ) ) DCNL DCSP except DjangoXBlockUserStateClient.DoesNotExist : DCNL DCSP DCSP return HttpResponse ( escape ( _ ( u &apos;User DCSP { username } DCSP has DCSP never DCSP accessed DCSP problem DCSP { location } &apos; ) .format ( username = student _ username , location = location ) ) ) DCNL DCSP csm = StudentModule.objects.filter ( module _ state _ key = usage _ key , student _ _ username = student _ username , course _ id = course _ key ) DCNL DCSP scores = BaseStudentModuleHistory.get _ history ( csm ) DCNL DCSP if ( len ( scores ) ! = len ( history _ entries ) ) : DCNL DCSP DCSP log.warning ( &apos; Mismatch DCSP when DCSP fetching DCSP scores DCSP for DCSP student DCSP history DCSP for DCSP course DCSP % s , DCSP user DCSP % s , DCSP xblock DCSP % s . DCSP % d DCSP scores DCSP were DCSP found , DCSP and DCSP % d DCSP history DCSP entries DCSP were DCSP found . DCSP Matching DCSP scores DCSP to DCSP history DCSP entries DCSP by DCSP date DCSP for DCSP display . &apos; , course _ id , student _ username , location , len ( scores ) , len ( history _ entries ) ) DCNL DCSP DCSP scores _ by _ date = { score.created : score for score in scores } DCNL DCSP DCSP scores = &#91; scores _ by _ date &#91; history.updated &#93; for history in history _ entries &#93; DCNL DCSP context = { &apos; history _ entries &apos; : history _ entries , &apos; scores &apos; : scores , &apos; username &apos; : student _ username , &apos; location &apos; : location , &apos; course _ id &apos; : course _ key.to _ deprecated _ string ( ) } DCNL DCSP return render _ to _ response ( &apos; courseware / submission _ history.html &apos; , context )
DCSP caps = { } DCNL DCSP while 1 : DCNL DCSP DCSP line = fp.readline ( ) DCNL DCSP DCSP if ( not line ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( ( line &#91; 0 &#93; = = &apos; # &apos; ) or ( line.strip ( ) = = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP nextline = line DCNL DCSP DCSP while ( nextline &#91; ( -2 ) : &#93; = = &apos; \ \ \ n &apos; ) : DCNL DCSP DCSP DCSP nextline = fp.readline ( ) DCNL DCSP DCSP DCSP if ( not nextline ) : DCNL DCSP DCSP DCSP DCSP nextline = &apos; \ n &apos; DCNL DCSP DCSP DCSP line = ( line &#91; : ( -2 ) &#93; + nextline ) DCNL DCSP DCSP ( key , fields ) = parseline ( line ) DCNL DCSP DCSP if ( not ( key and fields ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( lineno is not None ) : DCNL DCSP DCSP DCSP fields &#91; &apos; lineno &apos; &#93; = lineno DCNL DCSP DCSP DCSP lineno + = 1 DCNL DCSP DCSP types = key.split ( &apos; / &apos; ) DCNL DCSP DCSP for j in range ( len ( types ) ) : DCNL DCSP DCSP DCSP types &#91; j &#93; = types &#91; j &#93; .strip ( ) DCNL DCSP DCSP key = &apos; / &apos; .join ( types ) .lower ( ) DCNL DCSP DCSP if ( key in caps ) : DCNL DCSP DCSP DCSP caps &#91; key &#93; .append ( fields ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP caps &#91; key &#93; = &#91; fields &#93; DCNL DCSP return ( caps , lineno )
DCSP return timesince ( d , now , reversed = True )
DCSP log.debug ( u &apos;executing DCSP tasks : DCSP % s &apos; , tasks ) DCNL DCSP finished _ events = manager.execute ( options = { u &apos;tasks &apos; : tasks , u &apos;cron &apos; : True , u &apos;allow _ manual &apos; : False } , priority = 5 ) DCNL DCSP for ( _ , task _ name , event _ ) in finished _ events : DCNL DCSP DCSP log.debug ( u &apos;task DCSP finished DCSP executing : DCSP % s &apos; , task _ name ) DCNL DCSP DCSP event _ .wait ( ) DCNL DCSP log.debug ( u &apos;all DCSP tasks DCSP in DCSP schedule DCSP finished DCSP executing &apos; )
DCSP old _ global _ assumptions = global _ assumptions.copy ( ) DCNL DCSP global _ assumptions.update ( assumptions ) DCNL DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP global _ assumptions.clear ( ) DCNL DCSP DCSP global _ assumptions.update ( old _ global _ assumptions )
DCSP return HttpResponseRedirect ( &apos; / test _ client / permanent _ redirect _ view / &apos; )
DCSP for restriction in page.get _ view _ restrictions ( ) : DCNL DCSP DCSP if ( not restriction.accept _ request ( request ) ) : DCNL DCSP DCSP DCSP if ( restriction.restriction _ type = = PageViewRestriction.PASSWORD ) : DCNL DCSP DCSP DCSP DCSP from wagtail.wagtailcore.forms import PasswordPageViewRestrictionForm DCNL DCSP DCSP DCSP DCSP form = PasswordPageViewRestrictionForm ( instance = restriction , initial = { u &apos;return _ url &apos; : request.get _ full _ path ( ) } ) DCNL DCSP DCSP DCSP DCSP action _ url = reverse ( u &apos;wagtailcore _ authenticate _ with _ password &apos; , args = &#91; restriction.id , page.id &#93; ) DCNL DCSP DCSP DCSP DCSP return page.serve _ password _ required _ response ( request , form , action _ url ) DCNL DCSP DCSP DCSP elif ( restriction.restriction _ type in &#91; PageViewRestriction.LOGIN , PageViewRestriction.GROUPS &#93; ) : DCNL DCSP DCSP DCSP DCSP return require _ wagtail _ login ( next = request.get _ full _ path ( ) )
DCSP maxfd = get _ maximum _ file _ descriptors ( ) DCNL DCSP for fd in reversed ( range ( maxfd ) ) : DCNL DCSP DCSP if ( fd not in exclude ) : DCNL DCSP DCSP DCSP close _ file _ descriptor _ if _ open ( fd )
DCSP from codeop import compile _ command DCNL DCSP for start in range ( lineno , ( -1 ) , ( -1 ) ) : DCNL DCSP DCSP if assertion : DCNL DCSP DCSP DCSP line = source.lines &#91; start &#93; DCNL DCSP DCSP DCSP if ( ( &apos; super &apos; in line ) and ( &apos; self &apos; in line ) and ( &apos; _ _ init _ _ &apos; in line ) ) : DCNL DCSP DCSP DCSP DCSP raise IndexError ( &apos; likely DCSP a DCSP subclass &apos; ) DCNL DCSP DCSP DCSP if ( ( &apos; assert &apos; not in line ) and ( &apos; raise &apos; not in line ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP trylines = source.lines &#91; start : ( lineno + 1 ) &#93; DCNL DCSP DCSP trylines.insert ( 0 , &apos; def DCSP xxx ( ) : &apos; ) DCNL DCSP DCSP trysource = &apos; \ n DCSP &apos; .join ( trylines ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP compile _ command ( trysource ) DCNL DCSP DCSP except ( SyntaxError , OverflowError , ValueError ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for end in range ( ( lineno + 1 ) , ( len ( source ) + 1 ) ) : DCNL DCSP DCSP DCSP trysource = source &#91; start : end &#93; DCNL DCSP DCSP DCSP if trysource.isparseable ( ) : DCNL DCSP DCSP DCSP DCSP return ( start , end ) DCNL DCSP raise SyntaxError ( ( &apos; no DCSP valid DCSP source DCSP range DCSP around DCSP line DCSP % d DCSP &apos; % ( lineno , ) ) )
DCSP return DemoProvider ( config &#91; CONF _ LANG &#93; )
DCSP os.rename ( filename , ( filename + &apos; .bak &apos; ) ) DCNL DCSP f = open ( ( filename + &apos; .bak &apos; ) ) DCNL DCSP d = f.read ( ) DCNL DCSP f.close ( ) DCNL DCSP for ( k , v ) in oldToNew.items ( ) : DCNL DCSP DCSP d = d.replace ( k , v ) DCNL DCSP f = open ( ( filename + &apos; .new &apos; ) , &apos; w &apos; ) DCNL DCSP f.write ( d ) DCNL DCSP f.close ( ) DCNL DCSP os.rename ( ( filename + &apos; .new &apos; ) , filename ) DCNL DCSP os.unlink ( ( filename + &apos; .bak &apos; ) )
DCSP ( channels , src _ h , src _ w ) = images &#91; 0 &#93; .shape DCNL DCSP ( cy , cx ) = ( ( src _ h / 2.0 ) , ( src _ w / 2.0 ) ) DCNL DCSP ( dst _ h , dst _ w ) = crop _ dims DCNL DCSP crops _ ix = numpy.empty ( ( 5 , 4 ) , dtype = int ) DCNL DCSP crops _ ix &#91; 0 , : 2 &#93; = &#91; 0 , 0 &#93; DCNL DCSP crops _ ix &#91; 1 , : 2 &#93; = &#91; 0 , ( src _ w - dst _ w ) &#93; DCNL DCSP crops _ ix &#91; 2 , : 2 &#93; = &#91; ( src _ h - dst _ h ) , 0 &#93; DCNL DCSP crops _ ix &#91; 3 , : 2 &#93; = &#91; ( src _ h - dst _ h ) , ( src _ w - dst _ w ) &#93; DCNL DCSP crops _ ix &#91; 4 , : 2 &#93; = &#91; int ( ( cy - ( dst _ h / 2.0 ) ) ) , int ( ( cx - ( dst _ w / 2.0 ) ) ) &#93; DCNL DCSP crops _ ix &#91; : , 2 &#93; = ( crops _ ix &#91; : , 0 &#93; + dst _ h ) DCNL DCSP crops _ ix &#91; : , 3 &#93; = ( crops _ ix &#91; : , 1 &#93; + dst _ w ) DCNL DCSP crops = numpy.empty ( ( ( 10 * len ( images ) ) , channels , dst _ h , dst _ w ) , dtype = images &#91; 0 &#93; .dtype ) DCNL DCSP ix = 0 DCNL DCSP for img in images : DCNL DCSP DCSP for crop in crops _ ix : DCNL DCSP DCSP DCSP crops &#91; ix &#93; = img &#91; : , crop &#91; 0 &#93; : crop &#91; 2 &#93; , crop &#91; 1 &#93; : crop &#91; 3 &#93; &#93; DCNL DCSP DCSP DCSP ix + = 1 DCNL DCSP DCSP crops &#91; ix : ( ix + 5 ) &#93; = crops &#91; ( ix - 5 ) : ix , : , : , : : ( -1 ) &#93; DCNL DCSP DCSP ix + = 5 DCNL DCSP return crops
DCSP with AdbClient ( ) as c : DCNL DCSP DCSP return bool ( c.stat ( path ) )
DCSP wanted = { } DCNL DCSP key _ map = dict ( d = &apos; data &apos; , m = &apos; meta &apos; ) DCNL DCSP if parts : DCNL DCSP DCSP for k in key _ map : DCNL DCSP DCSP DCSP if ( k in parts &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP wanted &#91; key _ map &#91; k &#93; &#93; = True DCNL DCSP if ( not wanted ) : DCNL DCSP DCSP wanted &#91; &apos; data &apos; &#93; = True DCNL DCSP return wanted
DCSP pass
DCSP if ( hdict is None ) : DCNL DCSP DCSP hdict = { } DCNL DCSP while True : DCNL DCSP DCSP line = rfile.readline ( ) DCNL DCSP DCSP if ( not line ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Illegal DCSP end DCSP of DCSP headers . &apos; ) DCNL DCSP DCSP if ( line = = CRLF ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( not line.endswith ( CRLF ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; HTTP DCSP requires DCSP CRLF DCSP terminators &apos; ) DCNL DCSP DCSP if ( line &#91; 0 &#93; in &apos; DCSP DCTB &apos; ) : DCNL DCSP DCSP DCSP v = line.strip ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( k , v ) = line.split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Illegal DCSP header DCSP line . &apos; ) DCNL DCSP DCSP DCSP k = k.strip ( ) .title ( ) DCNL DCSP DCSP DCSP v = v.strip ( ) DCNL DCSP DCSP DCSP hname = k DCNL DCSP DCSP if ( k in comma _ separated _ headers ) : DCNL DCSP DCSP DCSP existing = hdict.get ( hname ) DCNL DCSP DCSP DCSP if existing : DCNL DCSP DCSP DCSP DCSP v = &apos; , DCSP &apos; .join ( ( existing , v ) ) DCNL DCSP DCSP hdict &#91; hname &#93; = v DCNL DCSP return hdict
DCSP from pylgtv import WebOsClient DCNL DCSP from pylgtv import PyLGTVPairException DCNL DCSP client = WebOsClient ( config.get ( CONF _ HOST ) ) DCNL DCSP try : DCNL DCSP DCSP client.register ( ) DCNL DCSP except PyLGTVPairException : DCNL DCSP DCSP _ LOGGER.error ( &apos; Pairing DCSP with DCSP TV DCSP failed &apos; ) DCNL DCSP DCSP return None DCNL DCSP except OSError : DCNL DCSP DCSP _ LOGGER.error ( &apos; TV DCSP unreachable &apos; ) DCNL DCSP DCSP return None DCNL DCSP return LgWebOSNotificationService ( client )
DCSP if ( method not in _ LINKAGE _ METHODS ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP method : DCSP { 0 } &apos; .format ( method ) ) DCNL DCSP y = _ convert _ to _ double ( np.asarray ( y , order = &apos; c &apos; ) ) DCNL DCSP if ( y.ndim = = 1 ) : DCNL DCSP DCSP distance.is _ valid _ y ( y , throw = True , name = &apos; y &apos; ) DCNL DCSP DCSP &#91; y &#93; = _ copy _ arrays _ if _ base _ present ( &#91; y &#93; ) DCNL DCSP elif ( y.ndim = = 2 ) : DCNL DCSP DCSP if ( ( method in _ EUCLIDEAN _ METHODS ) and ( metric ! = &apos; euclidean &apos; ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &quot; Method DCSP &apos; { 0 } &apos; DCSP requires DCSP the DCSP distance DCSP metric DCSP to DCSP be DCSP Euclidean &quot; .format ( method ) ) DCNL DCSP DCSP if ( ( y.shape &#91; 0 &#93; = = y.shape &#91; 1 &#93; ) and np.allclose ( np.diag ( y ) , 0 ) ) : DCNL DCSP DCSP DCSP if ( np.all ( ( y &gt; = 0 ) ) and np.allclose ( y , y.T ) ) : DCNL DCSP DCSP DCSP DCSP _ warning ( &apos; The DCSP symmetric DCSP non-negative DCSP hollow DCSP observation DCSP matrix DCSP looks DCSP suspiciously DCSP like DCSP an DCSP uncondensed DCSP distance DCSP matrix &apos; ) DCNL DCSP DCSP y = distance.pdist ( y , metric ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; `y` DCSP must DCSP be DCSP 1 DCSP or DCSP 2 DCSP dimensional . &apos; ) DCNL DCSP if ( not np.all ( np.isfinite ( y ) ) ) : DCNL DCSP DCSP raise ValueError ( &apos; The DCSP condensed DCSP distance DCSP matrix DCSP must DCSP contain DCSP only DCSP finite DCSP values . &apos; ) DCNL DCSP n = int ( distance.num _ obs _ y ( y ) ) DCNL DCSP method _ code = _ LINKAGE _ METHODS &#91; method &#93; DCNL DCSP if ( method = = &apos; single &apos; ) : DCNL DCSP DCSP return _ hierarchy.mst _ single _ linkage ( y , n ) DCNL DCSP elif ( method in &#91; &apos; complete &apos; , &apos; average &apos; , &apos; weighted &apos; , &apos; ward &apos; &#93; ) : DCNL DCSP DCSP return _ hierarchy.nn _ chain ( y , n , method _ code ) DCNL DCSP else : DCNL DCSP DCSP return _ hierarchy.fast _ linkage ( y , n , method _ code )
DCSP profile = request.user.profile DCNL DCSP if request.POST : DCNL DCSP DCSP form = AccountForm ( request.POST , instance = profile ) DCNL DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP form.save ( ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; account _ view &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP form = AccountForm ( instance = profile ) DCNL DCSP return render _ to _ response ( &apos; account / account _ edit &apos; , { &apos; profile &apos; : profile , &apos; form &apos; : Markup ( form.as _ ul ( ) ) } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP return s3 _ rest _ controller ( )
DCSP return captured _ output ( &apos; stdout &apos; )
DCSP session = Session ( bind = engine ) DCNL DCSP for chunk in range ( 0 , n , 1000 ) : DCNL DCSP DCSP session.add _ all ( &#91; Customer ( id = ( i + 1 ) , name = ( &apos; customer DCSP name DCSP % d &apos; % i ) , description = ( &apos; customer DCSP description DCSP % d &apos; % i ) ) for i in range ( chunk , ( chunk + 1000 ) ) &#93; ) DCNL DCSP DCSP session.flush ( ) DCNL DCSP session.commit ( )
DCSP export = None DCNL DCSP exports _ to _ list = system.exports.to _ list ( ) DCNL DCSP for e in exports _ to _ list : DCNL DCSP DCSP if ( e.get _ export _ path ( ) = = module.params &#91; &apos; name &apos; &#93; ) : DCNL DCSP DCSP DCSP export = e DCNL DCSP DCSP DCSP break DCNL DCSP return export
DCSP return render ( request , &apos; flagit / queue.html &apos; , { &apos; objects &apos; : FlaggedObject.objects.pending ( ) } )
DCSP course _ id = SlashSeparatedCourseKey.from _ deprecated _ string ( course _ id ) DCNL DCSP def csv _ response ( filename , header , rows ) : DCNL DCSP DCSP &apos; Returns DCSP a DCSP CSV DCSP http DCSP response DCSP for DCSP the DCSP given DCSP header DCSP and DCSP rows DCSP ( excel / utf-8 ) . &apos; DCNL DCSP DCSP response = HttpResponse ( content _ type = &apos; text / csv &apos; ) DCNL DCSP DCSP response &#91; &apos; Content-Disposition &apos; &#93; = &apos; attachment ; DCSP filename = { 0 } &apos; .format ( unicode ( filename ) .encode ( &apos; utf-8 &apos; ) ) DCNL DCSP DCSP writer = csv.writer ( response , dialect = &apos; excel &apos; , quotechar = &apos; &quot; &apos; , quoting = csv.QUOTE _ ALL ) DCNL DCSP DCSP encoded = &#91; unicode ( s ) .encode ( &apos; utf-8 &apos; ) for s in header &#93; DCNL DCSP DCSP writer.writerow ( encoded ) DCNL DCSP DCSP for row in rows : DCNL DCSP DCSP DCSP encoded = &#91; unicode ( s ) .encode ( &apos; utf-8 &apos; ) for s in row &#93; DCNL DCSP DCSP DCSP writer.writerow ( encoded ) DCNL DCSP DCSP return response DCNL DCSP students = User.objects.filter ( courseenrollment _ _ course _ id = course _ id ) .order _ by ( &apos; id &apos; ) DCNL DCSP header = &#91; &apos; User DCSP ID &apos; , &apos; Anonymized DCSP User DCSP ID &apos; , &apos; Course DCSP Specific DCSP Anonymized DCSP User DCSP ID &apos; &#93; DCNL DCSP rows = &#91; &#91; s.id , unique _ id _ for _ user ( s , save = False ) , anonymous _ id _ for _ user ( s , course _ id , save = False ) &#93; for s in students &#93; DCNL DCSP return csv _ response ( ( course _ id.to _ deprecated _ string ( ) .replace ( &apos; / &apos; , &apos; -&apos; ) + &apos; -anon-ids.csv &apos; ) , header , rows )
DCSP train = ( ( pair , pair.value ) for pair in nltk.corpus.rte.pairs ( &#91; &apos; rte1 _ dev.xml &apos; , &apos; rte2 _ dev.xml &apos; , &apos; rte3 _ dev.xml &apos; &#93; ) ) DCNL DCSP test = ( ( pair , pair.value ) for pair in nltk.corpus.rte.pairs ( &#91; &apos; rte1 _ test.xml &apos; , &apos; rte2 _ test.xml &apos; , &apos; rte3 _ test.xml &apos; &#93; ) ) DCNL DCSP print ( &apos; Training DCSP classifier ... &apos; ) DCNL DCSP classifier = trainer ( &#91; ( features ( pair ) , label ) for ( pair , label ) in train &#93; ) DCNL DCSP print ( &apos; Testing DCSP classifier ... &apos; ) DCNL DCSP acc = accuracy ( classifier , &#91; ( features ( pair ) , label ) for ( pair , label ) in test &#93; ) DCNL DCSP print ( ( &apos; Accuracy : DCSP % 6.4f &apos; % acc ) ) DCNL DCSP return classifier
DCSP print ( &apos; pystache : DCSP running DCSP tests : DCSP argv : DCSP % s &apos; % repr ( sys _ argv ) ) DCNL DCSP should _ source _ exist = False DCNL DCSP spec _ test _ dir = None DCNL DCSP project _ dir = None DCNL DCSP if ( ( len ( sys _ argv ) &gt; 1 ) and ( sys _ argv &#91; 1 &#93; = = FROM _ SOURCE _ OPTION ) ) : DCNL DCSP DCSP should _ source _ exist = True DCNL DCSP DCSP sys _ argv.pop ( 1 ) DCNL DCSP try : DCNL DCSP DCSP project _ dir = sys _ argv &#91; 1 &#93; DCNL DCSP DCSP sys _ argv.pop ( 1 ) DCNL DCSP except IndexError : DCNL DCSP DCSP if should _ source _ exist : DCNL DCSP DCSP DCSP project _ dir = PROJECT _ DIR DCNL DCSP try : DCNL DCSP DCSP spec _ test _ dir = sys _ argv &#91; 1 &#93; DCNL DCSP DCSP sys _ argv.pop ( 1 ) DCNL DCSP except IndexError : DCNL DCSP DCSP if ( project _ dir is not None ) : DCNL DCSP DCSP DCSP _ spec _ test _ dir = get _ spec _ test _ dir ( project _ dir ) DCNL DCSP DCSP DCSP if ( not os.path.exists ( _ spec _ test _ dir ) ) : DCNL DCSP DCSP DCSP DCSP print &apos; pystache : DCSP skipping DCSP spec DCSP tests : DCSP spec DCSP test DCSP directory DCSP not DCSP found &apos; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP spec _ test _ dir = _ spec _ test _ dir DCNL DCSP if ( ( len ( sys _ argv ) &lt; = 1 ) or sys _ argv &#91; ( -1 ) &#93; .startswith ( &apos; -&apos; ) ) : DCNL DCSP DCSP module _ names = _ discover _ test _ modules ( PACKAGE _ DIR ) DCNL DCSP DCSP sys _ argv.extend ( module _ names ) DCNL DCSP DCSP if ( project _ dir is not None ) : DCNL DCSP DCSP DCSP sys _ argv.append ( _ _ name _ _ ) DCNL DCSP SetupTests.project _ dir = project _ dir DCNL DCSP extra _ tests = make _ extra _ tests ( project _ dir , spec _ test _ dir ) DCNL DCSP test _ program _ class = make _ test _ program _ class ( extra _ tests ) DCNL DCSP test _ program _ class ( argv = sys _ argv , module = None )
DCSP T = current.T DCNL DCSP settings.base.system _ name = T ( &apos; IMS &apos; ) DCNL DCSP settings.base.system _ name _ short = T ( &apos; IMS &apos; ) DCNL DCSP settings.base.prepopulate + = ( &apos; SCPHIMS &apos; , &apos; SCPHIMS / Demo &apos; , &apos; default / users &apos; ) DCNL DCSP settings.base.theme = &apos; SCPHIMS &apos; DCNL DCSP settings.security.self _ registration = False DCNL DCSP settings.mail.approver = &apos; ADMIN &apos; DCNL DCSP settings.gis.countries = ( &apos; PH &apos; , ) DCNL DCSP settings.gis.legend = &apos; float &apos; DCNL DCSP settings.gis.postcode _ selector = False DCNL DCSP settings.gis.lookup _ code = &apos; PSGC &apos; DCNL DCSP settings.L10n.languages = OrderedDict ( &#91; ( &apos; en &apos; , &apos; English &apos; ) &#93; ) DCNL DCSP settings.L10n.display _ toolbar = False DCNL DCSP settings.L10n.utc _ offset = &apos; + 0800 &apos; DCNL DCSP settings.L10n.decimal _ separator = &apos; .&apos; DCNL DCSP settings.L10n.thousands _ separator = &apos; , &apos; DCNL DCSP settings.fin.currencies = { &apos; EUR &apos; : &apos; Euros &apos; , &apos; PHP &apos; : &apos; Philippine DCSP Pesos &apos; , &apos; USD &apos; : &apos; United DCSP States DCSP Dollars &apos; } DCNL DCSP settings.fin.currency _ default = &apos; PHP &apos; DCNL DCSP settings.security.policy = 5 DCNL DCSP settings.auth.password _ changes = False DCNL DCSP settings.auth.office365 _ domains = &#91; &apos; savethechildren.org &apos; &#93; DCNL DCSP settings.mobile.forms = &#91; ( &apos; Beneficiaries &apos; , &apos; pr _ person &apos; , { &apos; c &apos; : &apos; dvr &apos; } ) &#93; DCNL DCSP settings.cms.richtext = True DCNL DCSP def customise _ cms _ post _ controller ( * * attr ) : DCNL DCSP DCSP s3 = current.response.s3 DCNL DCSP DCSP standard _ prep = s3.prep DCNL DCSP DCSP def custom _ prep ( r ) : DCNL DCSP DCSP DCSP if callable ( standard _ prep ) : DCNL DCSP DCSP DCSP DCSP if ( not standard _ prep ( r ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP if ( r.method = = &apos; calendar &apos; ) : DCNL DCSP DCSP DCSP DCSP from s3 import FS DCNL DCSP DCSP DCSP DCSP r.resource.add _ filter ( FS ( &apos; post _ module.module &apos; ) .belongs ( ( &apos; project &apos; , &apos; dc &apos; ) ) ) DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP s3.prep = custom _ prep DCNL DCSP DCSP return attr DCNL DCSP settings.customise _ cms _ post _ controller = customise _ cms _ post _ controller DCNL DCSP def dc _ target _ onaccept ( form ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Add / Update DCSP entry DCSP to DCSP calendar \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP target _ id = form.vars.id DCNL DCSP DCSP DCSP delete = False DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP target _ id = form.id DCNL DCSP DCSP DCSP delete = True DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.cms _ post DCNL DCSP DCSP ltable = s3db.cms _ post _ module DCNL DCSP DCSP query = ( ( ( ltable.module = = &apos; dc &apos; ) &amp; ( ltable.resource = = &apos; target &apos; ) ) &amp; ( ltable.record = = target _ id ) ) DCNL DCSP DCSP link = db ( query ) .select ( ltable.post _ id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP if delete : DCNL DCSP DCSP DCSP if link : DCNL DCSP DCSP DCSP DCSP db ( ( table.id = = link.post _ id ) ) .delete ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ttable = db.dc _ target DCNL DCSP DCSP DCSP record = db ( ( ttable.id = = target _ id ) ) .select ( ttable.template _ id , ttable.location _ id , ttable.date , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP body = ttable.template _ id.represent ( record.template _ id ) DCNL DCSP DCSP DCSP if link : DCNL DCSP DCSP DCSP DCSP db ( ( table.id = = link.post _ id ) ) .update ( body = body , location _ id = record.location _ id , date = record.date ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP post _ id = table.insert ( body = body , location _ id = record.location _ id , date = record.date ) DCNL DCSP DCSP DCSP DCSP ltable.insert ( post _ id = post _ id , module = &apos; dc &apos; , resource = &apos; target &apos; , record = target _ id ) DCNL DCSP def customise _ dc _ target _ resource ( r , tablename ) : DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.dc _ target DCNL DCSP DCSP from s3 import S3LocationSelector DCNL DCSP DCSP table.location _ id.widget = S3LocationSelector ( levels = ( &apos; L1 &apos; , &apos; L2 &apos; , &apos; L3 &apos; ) , show _ map = False ) DCNL DCSP DCSP has _ role = current.auth.s3 _ has _ role DCNL DCSP DCSP if ( has _ role ( &apos; ERT _ LEADER &apos; ) or has _ role ( &apos; HUM _ MANAGER &apos; ) ) : DCNL DCSP DCSP DCSP s3db = current.s3db DCNL DCSP DCSP DCSP ttable = s3db.dc _ template DCNL DCSP DCSP DCSP RAPID = current.db ( ( ttable.name = = &apos; Rapid DCSP Assessment &apos; ) ) .select ( ttable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP table.template _ id.default = RAPID.id DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP current.log.warning ( &apos; Cannot DCSP default DCSP Targets DCSP to DCSP Rapid DCSP Assessment DCSP form &apos; ) DCNL DCSP DCSP onaccept = dc _ target _ onaccept DCNL DCSP DCSP s3db.configure ( &apos; dc _ target &apos; , onaccept = onaccept , ondelete = onaccept ) DCNL DCSP settings.customise _ dc _ target _ resource = customise _ dc _ target _ resource DCNL DCSP def customise _ dc _ collection _ resource ( r , tablename ) : DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.dc _ collection DCNL DCSP DCSP from s3 import S3LocationSelector DCNL DCSP DCSP table.location _ id.widget = S3LocationSelector ( levels = ( &apos; L1 &apos; , &apos; L2 &apos; , &apos; L3 &apos; , &apos; L4 &apos; ) ) DCNL DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP org = db ( ( otable.name = = SAVE ) ) .select ( otable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP SCI = org.id DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP org DCSP % s DCSP - DCSP prepop DCSP not DCSP done ? &apos; % SAVE ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f = table.organisation _ id DCNL DCSP DCSP DCSP f.default = SCI DCNL DCSP DCSP DCSP f.readable = f.writable = False DCNL DCSP DCSP has _ role = current.auth.s3 _ has _ role DCNL DCSP DCSP if ( has _ role ( &apos; ERT _ LEADER &apos; ) or has _ role ( &apos; HUM _ MANAGER &apos; ) ) : DCNL DCSP DCSP DCSP ttable = s3db.dc _ template DCNL DCSP DCSP DCSP RAPID = db ( ( ttable.name = = &apos; Rapid DCSP Assessment &apos; ) ) .select ( ttable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP table.template _ id.default = RAPID.id DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP current.log.warning ( &apos; Cannot DCSP default DCSP Targets DCSP to DCSP Rapid DCSP Assessment DCSP form &apos; ) DCNL DCSP settings.customise _ dc _ collection _ resource = customise _ dc _ collection _ resource DCNL DCSP def customise _ doc _ document _ resource ( r , tablename ) : DCNL DCSP DCSP from s3 import S3LocationSelector , S3SQLCustomForm DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.doc _ document DCNL DCSP DCSP table.organisation _ id.readable = table.organisation _ id.writable = True DCNL DCSP DCSP f = table.location _ id DCNL DCSP DCSP f.readable = f.writable = True DCNL DCSP DCSP f.widget = S3LocationSelector ( ) DCNL DCSP DCSP s3db.add _ components ( &apos; doc _ document &apos; , event _ event = &apos; doc _ id &apos; ) DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( &apos; file &apos; , &apos; name &apos; , &apos; url &apos; , &apos; date &apos; , &apos; organisation _ id &apos; , &apos; location _ id &apos; , &apos; comments &apos; ) DCNL DCSP DCSP from s3 import S3DateFilter , S3LocationFilter , S3OptionsFilter , S3TextFilter DCNL DCSP DCSP filter _ widgets = &#91; S3TextFilter ( &#91; &apos; name &apos; , &apos; comments &apos; &#93; , label = T ( &apos; Search &apos; ) , comment = T ( &apos; Search DCSP by DCSP disaster DCSP name DCSP or DCSP comments . DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wildcard . &apos; ) ) , S3OptionsFilter ( &apos; event.name &apos; , label = T ( &apos; Disaster &apos; ) ) , S3LocationFilter ( &apos; location _ id &apos; ) , S3OptionsFilter ( &apos; organisation _ id &apos; ) , S3DateFilter ( &apos; date &apos; ) &#93; DCNL DCSP DCSP list _ fields = &#91; &apos; location _ id $ L1 &apos; , &apos; location _ id $ L2 &apos; , &apos; location _ id $ L3 &apos; , &apos; location _ id $ L4 &apos; &#93; DCNL DCSP DCSP if ( r.controller = = &apos; doc &apos; ) : DCNL DCSP DCSP DCSP list _ fields + = ( ( T ( &apos; Disaster &apos; ) , &apos; event.name &apos; ) , &apos; organisation _ id &apos; ) DCNL DCSP DCSP elif ( r.controller = = &apos; event &apos; ) : DCNL DCSP DCSP DCSP list _ fields.append ( &apos; organisation _ id &apos; ) DCNL DCSP DCSP list _ fields + = &#91; &apos; date &apos; , &apos; name &apos; &#93; DCNL DCSP DCSP s3db.configure ( &apos; doc _ document &apos; , crud _ form = crud _ form , filter _ widgets = filter _ widgets , list _ fields = list _ fields ) DCNL DCSP settings.customise _ doc _ document _ resource = customise _ doc _ document _ resource DCNL DCSP def customise _ doc _ image _ resource ( r , tablename ) : DCNL DCSP DCSP from s3 import S3LocationSelector , S3SQLCustomForm DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.doc _ image DCNL DCSP DCSP table.location _ id.widget = S3LocationSelector ( ) DCNL DCSP DCSP s3db.add _ components ( &apos; doc _ image &apos; , event _ event = &apos; doc _ id &apos; ) DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( &apos; file &apos; , &apos; name &apos; , &apos; url &apos; , &apos; date &apos; , &apos; organisation _ id &apos; , &apos; location _ id &apos; , &apos; comments &apos; ) DCNL DCSP DCSP from s3 import S3DateFilter , S3LocationFilter , S3OptionsFilter , S3TextFilter DCNL DCSP DCSP filter _ widgets = &#91; S3TextFilter ( &#91; &apos; name &apos; , &apos; comments &apos; &#93; , label = T ( &apos; Search &apos; ) , comment = T ( &apos; Search DCSP by DCSP disaster DCSP name DCSP or DCSP comments . DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wildcard . &apos; ) ) , S3OptionsFilter ( &apos; event.name &apos; , label = T ( &apos; Disaster &apos; ) ) , S3LocationFilter ( &apos; location _ id &apos; ) , S3OptionsFilter ( &apos; organisation _ id &apos; ) , S3DateFilter ( &apos; date &apos; ) &#93; DCNL DCSP DCSP list _ fields = &#91; &apos; location _ id $ L1 &apos; , &apos; location _ id $ L2 &apos; , &apos; location _ id $ L3 &apos; , &apos; location _ id $ L4 &apos; &#93; DCNL DCSP DCSP if ( r.controller ! = &apos; event &apos; ) : DCNL DCSP DCSP DCSP list _ fields.append ( ( T ( &apos; Disaster &apos; ) , &apos; event.name &apos; ) ) DCNL DCSP DCSP list _ fields + = &#91; &apos; organisation _ id &apos; , &apos; date &apos; , &apos; name &apos; &#93; DCNL DCSP DCSP s3db.configure ( &apos; doc _ image &apos; , crud _ form = crud _ form , filter _ widgets = filter _ widgets , list _ fields = list _ fields ) DCNL DCSP settings.customise _ doc _ image _ resource = customise _ doc _ image _ resource DCNL DCSP def customise _ doc _ sitrep _ resource ( r , tablename ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP All DCSP SitReps DCSP are DCSP SAVE \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP All DCSP SitReps DCSP are DCSP National DCSP in DCSP scope \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP from s3 import S3DateFilter , S3OptionsFilter , S3SQLCustomForm , S3SQLInlineComponent DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.doc _ sitrep DCNL DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP org = db ( ( otable.name = = SAVE ) ) .select ( otable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP SCI = org.id DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP org DCSP % s DCSP - DCSP prepop DCSP not DCSP done ? &apos; % SAVE ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f = table.organisation _ id DCNL DCSP DCSP DCSP f.default = SCI DCNL DCSP DCSP PH = &apos; Philippines &apos; DCNL DCSP DCSP gtable = s3db.gis _ location DCNL DCSP DCSP loc = db ( ( ( gtable.name = = PH ) &amp; ( gtable.level = = &apos; L0 &apos; ) ) ) .select ( gtable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP PH = loc.id DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP loc DCSP % s DCSP - DCSP prepop DCSP not DCSP done ? &apos; % PH ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f = table.location _ id DCNL DCSP DCSP DCSP f.default = PH DCNL DCSP DCSP s3db.event _ sitrep.event _ id.default = current.session.s3.event DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( S3SQLInlineComponent ( &apos; event _ sitrep &apos; , label = T ( &apos; Disaster &apos; ) , fields = &#91; ( &apos; &apos; , &apos; event _ id &apos; ) &#93; , multiple = False , required = True ) , &apos; date &apos; , &apos; name &apos; , &apos; description &apos; , &apos; comments &apos; ) DCNL DCSP DCSP filter _ widgets = &#91; S3OptionsFilter ( &apos; event _ sitrep.event _ id &apos; ) , S3DateFilter ( &apos; date &apos; ) &#93; DCNL DCSP DCSP list _ fields = &#91; &apos; event _ sitrep.event _ id &apos; , &apos; date &apos; , &apos; name &apos; , &apos; comments &apos; &#93; DCNL DCSP DCSP s3db.configure ( &apos; doc _ sitrep &apos; , crud _ form = crud _ form , filter _ widgets = filter _ widgets , list _ fields = list _ fields ) DCNL DCSP settings.customise _ doc _ sitrep _ resource = customise _ doc _ sitrep _ resource DCNL DCSP def customise _ doc _ sitrep _ controller ( * * attr ) : DCNL DCSP DCSP etable = current.s3db.event _ event DCNL DCSP DCSP query = ( ( etable.closed = = False ) &amp; ( etable.deleted = = False ) ) DCNL DCSP DCSP open = current.db ( query ) .select ( etable.id , etable.name ) DCNL DCSP DCSP len _ open = len ( open ) DCNL DCSP DCSP if len _ open : DCNL DCSP DCSP DCSP if ( len _ open = = 1 ) : DCNL DCSP DCSP DCSP DCSP current.session.s3.event = open.first ( ) .id DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP current.session.s3.event = None DCNL DCSP DCSP DCSP open = { row.id : row.name for row in open } DCNL DCSP DCSP DCSP from s3 import s3 _ set _ default _ filter DCNL DCSP DCSP DCSP s3 _ set _ default _ filter ( &apos; event _ sitrep.event _ id &apos; , open , tablename = &apos; doc _ sitrep &apos; ) DCNL DCSP DCSP return attr DCNL DCSP settings.customise _ doc _ sitrep _ controller = customise _ doc _ sitrep _ controller DCNL DCSP settings.dvr.label = &apos; Beneficiary &apos; DCNL DCSP settings.hrm.email _ required = False DCNL DCSP def customise _ dvr _ case _ resource ( r , tablename ) : DCNL DCSP DCSP current.s3db.configure ( &apos; dvr _ case &apos; , list _ fields = &#91; &apos; person _ id &apos; , &apos; reference &apos; , &apos; person _ id $ location _ id &apos; , ( T ( &apos; Phone &apos; ) , &apos; person _ id $ phone.value &apos; ) , &apos; comments &apos; &#93; ) DCNL DCSP settings.customise _ dvr _ case _ resource = customise _ dvr _ case _ resource DCNL DCSP def customise _ pr _ person _ resource ( r , tablename ) : DCNL DCSP DCSP if ( r.function ! = &apos; distribution &apos; ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if ( r.tablename = = &apos; project _ activity &apos; ) : DCNL DCSP DCSP DCSP activity _ id = r.id DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP activity _ id = None DCNL DCSP DCSP current.response.s3.crud _ strings &#91; &apos; pr _ person &apos; &#93; = Storage ( label _ create = T ( &apos; Add DCSP Beneficiary &apos; ) , title _ display = T ( &apos; Beneficiary DCSP Details &apos; ) , title _ list = T ( &apos; Beneficiaries &apos; ) , title _ update = T ( &apos; Edit DCSP Beneficiary &apos; ) , title _ report = T ( &apos; Beneficiary DCSP Report &apos; ) , label _ list _ button = T ( &apos; List DCSP Beneficiaries &apos; ) , msg _ record _ created = T ( &apos; Beneficiary DCSP Added &apos; ) , msg _ record _ modified = T ( &apos; Beneficiary DCSP Updated &apos; ) , msg _ record _ deleted = T ( &apos; Beneficiary DCSP Deleted &apos; ) , msg _ list _ empty = T ( &apos; No DCSP Beneficiaries DCSP Found &apos; ) ) DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP mobile _ list _ fields = &#91; &apos; first _ name &apos; , &apos; middle _ name &apos; , &apos; last _ name &apos; , &apos; date _ of _ birth &apos; , &apos; gender &apos; , &apos; person _ details.disabled &apos; , &apos; phone.value &apos; , &apos; address.location _ id $ parent &apos; , &apos; address.location _ id $ addr _ street &apos; , &apos; household _ member.age &apos; , &apos; household _ member.gender &apos; , &apos; household _ member.disabled &apos; , &apos; household _ member.comments &apos; , &apos; dvr _ case.comments &apos; &#93; DCNL DCSP DCSP from s3 import S3SQLCustomForm , S3SQLInlineComponent DCNL DCSP DCSP crud _ fields = &#91; &apos; first _ name &apos; , &apos; middle _ name &apos; , &apos; last _ name &apos; , &apos; date _ of _ birth &apos; , &apos; gender &apos; , &apos; person _ details.disabled &apos; , S3SQLInlineComponent ( &apos; phone &apos; , fields = &#91; ( &apos; &apos; , &apos; value &apos; ) &#93; , label = T ( &apos; Mobile DCSP Phone &apos; ) , multiple = True ) , S3SQLInlineComponent ( &apos; address &apos; , label = T ( &apos; Current DCSP Address &apos; ) , fields = &#91; ( &apos; &apos; , &apos; location _ id &apos; ) &#93; , filterby = { &apos; field &apos; : &apos; type &apos; , &apos; options &apos; : &apos; 1&apos; } , link = False , multiple = False ) , S3SQLInlineComponent ( &apos; household _ member &apos; , fields = &#91; &apos; age &apos; , &apos; gender &apos; , &apos; disabled &apos; , &apos; comments &apos; &#93; , label = T ( &apos; Household DCSP Members &apos; ) ) , &apos; dvr _ case.comments &apos; &#93; DCNL DCSP DCSP if ( r.representation = = &apos; mdata &apos; ) : DCNL DCSP DCSP DCSP crud _ fields.insert ( 0 , &apos; dvr _ case.reference &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP db = current.db DCNL DCSP DCSP DCSP atable = s3db.pr _ address DCNL DCSP DCSP DCSP ctable = s3db.dvr _ case DCNL DCSP DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP DCSP org = db ( ( otable.name = = SAVE ) ) .select ( otable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP SCI = org.id DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP org DCSP % s DCSP - DCSP prepop DCSP not DCSP done ? &apos; % SAVE ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ctable.organisation _ id.default = SCI DCNL DCSP DCSP DCSP if activity _ id : DCNL DCSP DCSP DCSP DCSP patable = s3db.project _ activity DCNL DCSP DCSP DCSP DCSP gtable = s3db.gis _ location DCNL DCSP DCSP DCSP DCSP query = ( ( patable.id = = activity _ id ) &amp; ( patable.location _ id = = gtable.id ) ) DCNL DCSP DCSP DCSP DCSP activity = db ( query ) .select ( gtable.parent , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP atable.location _ id.default = activity.parent DCNL DCSP DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP Activity DCSP % s &apos; % activity _ id ) ) DCNL DCSP DCSP DCSP from s3 import S3LocationSelector DCNL DCSP DCSP DCSP atable.location _ id.widget = S3LocationSelector ( show _ address = True , show _ map = False ) DCNL DCSP DCSP DCSP ctable.reference.label = T ( &apos; Barcode &apos; ) DCNL DCSP DCSP DCSP if ( r.method in ( &apos; read &apos; , &apos; update &apos; ) ) : DCNL DCSP DCSP DCSP DCSP crud _ fields.insert ( 0 , &apos; dvr _ case.reference &apos; ) DCNL DCSP DCSP s3db.configure ( &apos; pr _ person &apos; , crud _ form = S3SQLCustomForm ( postprocess = ( lambda form : pr _ person _ postprocess ( form , activity _ id ) ) , * crud _ fields ) , list _ fields = &#91; &apos; first _ name &apos; , &apos; middle _ name &apos; , &apos; last _ name &apos; , &apos; age &apos; , &apos; gender &apos; , ( T ( &apos; Phone &apos; ) , &apos; phone.value &apos; ) , &apos; address.location _ id &apos; , &apos; dvr _ case.reference &apos; , &apos; dvr _ case.comments &apos; &#93; , mobile _ list _ fields = mobile _ list _ fields ) DCNL DCSP settings.customise _ pr _ person _ resource = customise _ pr _ person _ resource DCNL DCSP def pr _ person _ postprocess ( form , activity _ id ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP onaccept DCSP for DCSP the DCSP Custom DCSP Form : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP - DCSP link DCSP Beneficiaries DCSP to DCSP the DCSP Distribution \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP person _ id = form.vars.get ( &apos; id &apos; ) DCNL DCSP DCSP current.s3db.project _ activity _ person.insert ( activity _ id = activity _ id , person _ id = person _ id ) DCNL DCSP def dvr _ rheader ( r , tabs = &#91; &#93; ) : DCNL DCSP DCSP if ( r.representation ! = &apos; html &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP from s3 import s3 _ rheader _ resource , s3 _ rheader _ tabs DCNL DCSP DCSP ( tablename , record ) = s3 _ rheader _ resource ( r ) DCNL DCSP DCSP if ( not record ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP rheader = None DCNL DCSP DCSP if ( tablename = = &apos; pr _ person &apos; ) : DCNL DCSP DCSP DCSP T = current.T DCNL DCSP DCSP DCSP db = current.db DCNL DCSP DCSP DCSP s3db = current.s3db DCNL DCSP DCSP DCSP if ( not tabs ) : DCNL DCSP DCSP DCSP DCSP tabs = &#91; ( T ( &apos; Basic DCSP Details &apos; ) , None ) , ( T ( &apos; Household DCSP Members &apos; ) , &apos; household _ member &apos; ) , ( T ( &apos; Activities &apos; ) , &apos; activity _ person &apos; ) &#93; DCNL DCSP DCSP DCSP rheader _ tabs = s3 _ rheader _ tabs ( r , tabs ) DCNL DCSP DCSP DCSP record _ id = record.id DCNL DCSP DCSP DCSP ctable = s3db.dvr _ case DCNL DCSP DCSP DCSP case = db ( ( ctable.person _ id = = record _ id ) ) .select ( ctable.reference , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP if case : DCNL DCSP DCSP DCSP DCSP reference = ( case.reference or current.messages &#91; &apos; NONE &apos; &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP reference = None DCNL DCSP DCSP DCSP from gluon import A , DIV , TABLE , TR , TH , URL DCNL DCSP DCSP DCSP from s3 import s3 _ fullname , s3 _ avatar _ represent DCNL DCSP DCSP DCSP rheader = DIV ( A ( s3 _ avatar _ represent ( record _ id , &apos; pr _ person &apos; , _ class = &apos; rheader-avatar &apos; ) , _ href = URL ( f = &apos; person &apos; , args = &#91; record _ id , &apos; image &apos; &#93; , vars = r.get _ vars ) ) , TABLE ( TR ( TH ( ( &apos; % s : DCSP &apos; % T ( &apos; Name &apos; ) ) ) , s3 _ fullname ( record ) , TH ( ( &apos; % s : DCSP &apos; % T ( &apos; Barcode &apos; ) ) ) , reference ) , TR ( TH ( ( &apos; % s : DCSP &apos; % T ( &apos; Date DCSP of DCSP Birth &apos; ) ) ) , ( &apos; % s &apos; % ( record.date _ of _ birth or T ( &apos; unknown &apos; ) ) ) , TH ( ( &apos; % s : DCSP &apos; % T ( &apos; Gender &apos; ) ) ) , ( &apos; % s &apos; % s3db.pr _ gender _ opts.get ( record.gender , T ( &apos; unknown &apos; ) ) ) ) ) , rheader _ tabs ) DCNL DCSP DCSP return rheader DCNL DCSP def customise _ pr _ person _ controller ( * * attr ) : DCNL DCSP DCSP s3 = current.response.s3 DCNL DCSP DCSP standard _ prep = s3.prep DCNL DCSP DCSP def custom _ prep ( r ) : DCNL DCSP DCSP DCSP if callable ( standard _ prep ) : DCNL DCSP DCSP DCSP DCSP if ( not standard _ prep ( r ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP if ( r.controller = = &apos; dvr &apos; ) : DCNL DCSP DCSP DCSP DCSP r.resource.configure ( insertable = False ) DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP s3.prep = custom _ prep DCNL DCSP DCSP if ( current.request.controller = = &apos; dvr &apos; ) : DCNL DCSP DCSP DCSP attr &#91; &apos; rheader &apos; &#93; = dvr _ rheader DCNL DCSP DCSP return attr DCNL DCSP settings.customise _ pr _ person _ controller = customise _ pr _ person _ controller DCNL DCSP settings.event.label = &apos; Disaster &apos; DCNL DCSP def response _ locations ( ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Called DCSP onaccept / ondelete DCSP from DCSP events DCSP &amp; DCSP activities \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP - DCSP calculates DCSP which DCSP L3 DCSP locations DCSP have DCSP SC DCSP activities DCSP linked DCSP to DCSP open DCSP events DCSP &amp; DCSP sets DCSP their DCSP Sectors DCSP tag \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP gtable = s3db.gis _ location DCNL DCSP DCSP ttable = s3db.gis _ location _ tag DCNL DCSP DCSP etable = s3db.event _ event DCNL DCSP DCSP ltable = s3db.event _ activity DCNL DCSP DCSP atable = s3db.project _ activity DCNL DCSP DCSP aotable = s3db.project _ activity _ organisation DCNL DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP stable = s3db.org _ sector DCNL DCSP DCSP satable = s3db.project _ sector _ activity DCNL DCSP DCSP db ( ( ttable.tag = = &apos; sectors &apos; ) ) .delete ( ) DCNL DCSP DCSP query = ( ( ( ( ( ( ( ( ( gtable.id = = atable.location _ id ) &amp; ( atable.deleted = = False ) ) &amp; ( atable.id = = aotable.activity _ id ) ) &amp; ( aotable.organisation _ id = = otable.id ) ) &amp; ( otable.name = = SAVE ) ) &amp; ( atable.id = = ltable.activity _ id ) ) &amp; ( ltable.event _ id = = etable.id ) ) &amp; ( etable.closed = = False ) ) &amp; ( etable.deleted = = False ) ) DCNL DCSP DCSP left = stable.on ( ( ( stable.id = = satable.sector _ id ) &amp; ( satable.activity _ id = = atable.id ) ) ) DCNL DCSP DCSP L4s = db ( query ) .select ( gtable.parent , stable.name , left = left ) DCNL DCSP DCSP L3s = { } DCNL DCSP DCSP for L4 in L4s : DCNL DCSP DCSP DCSP sector = L4 &#91; &apos; org _ sector.name &apos; &#93; DCNL DCSP DCSP DCSP if sector : DCNL DCSP DCSP DCSP DCSP L3 = L4 &#91; &apos; gis _ location.parent &apos; &#93; DCNL DCSP DCSP DCSP DCSP if ( L3 in L3s ) : DCNL DCSP DCSP DCSP DCSP DCSP L3s &#91; L3 &#93; .append ( sector ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP L3s &#91; L3 &#93; = &#91; sector &#93; DCNL DCSP DCSP for L3 in L3s : DCNL DCSP DCSP DCSP ttable.insert ( location _ id = L3 , tag = &apos; sectors &apos; , value = &apos; , DCSP &apos; .join ( set ( L3s &#91; L3 &#93; ) ) ) DCNL DCSP def customise _ event _ event _ controller ( * * attr ) : DCNL DCSP DCSP from s3 import s3 _ set _ default _ filter DCNL DCSP DCSP s3 _ set _ default _ filter ( &apos; ~ .closed &apos; , False , tablename = &apos; event _ event &apos; ) DCNL DCSP DCSP return attr DCNL DCSP settings.customise _ event _ event _ controller = customise _ event _ event _ controller DCNL DCSP def customise _ event _ event _ resource ( r , tablename ) : DCNL DCSP DCSP from gluon import IS _ EMPTY _ OR , IS _ INT _ IN _ RANGE DCNL DCSP DCSP from s3 import S3LocationSelector , S3SQLCustomForm , S3SQLInlineComponent DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP s3db.event _ event _ location.location _ id.widget = S3LocationSelector ( levels = ( &apos; L1 &apos; , &apos; L2 &apos; ) ) DCNL DCSP DCSP s3db.event _ event _ tag.value.requires = IS _ EMPTY _ OR ( IS _ INT _ IN _ RANGE ( 1 , 5 ) ) DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( &apos; name &apos; , &apos; event _ type _ id &apos; , &apos; start _ date &apos; , S3SQLInlineComponent ( &apos; tag &apos; , fields = &#91; ( &apos; &apos; , &apos; value &apos; ) &#93; , filterby = { &apos; field &apos; : &apos; tag &apos; , &apos; options &apos; : &apos; category &apos; } , label = T ( &apos; Category &apos; ) , multiple = False ) , &apos; closed &apos; , &apos; comments &apos; ) DCNL DCSP DCSP list _ fields = &#91; &apos; name &apos; , &apos; event _ type _ id &apos; , &apos; start _ date &apos; , ( T ( &apos; Category &apos; ) , &apos; tag.value &apos; ) , &apos; closed &apos; , &apos; comments &apos; &#93; DCNL DCSP DCSP onaccept = ( lambda form : response _ locations ( ) ) DCNL DCSP DCSP update _ onaccept = s3db.get _ config ( &apos; event _ event &apos; , &apos; update _ onaccept &apos; ) DCNL DCSP DCSP update _ onaccept = &#91; update _ onaccept , onaccept &#93; DCNL DCSP DCSP s3db.configure ( &apos; event _ event &apos; , crud _ form = crud _ form , list _ fields = list _ fields , onaccept = onaccept , ondelete = onaccept , update _ onaccept = update _ onaccept ) DCNL DCSP settings.customise _ event _ event _ resource = customise _ event _ event _ resource DCNL DCSP settings.project.mode _ 3w = True DCNL DCSP settings.project.mode _ drr = True DCNL DCSP settings.project.activities = True DCNL DCSP settings.project.activity _ sectors = True DCNL DCSP settings.project.activity _ types = True DCNL DCSP settings.project.codes = True DCNL DCSP settings.project.event _ activities = True DCNL DCSP settings.project.event _ projects = True DCNL DCSP settings.project.hazards = False DCNL DCSP settings.project.hfa = False DCNL DCSP settings.project.programmes = True DCNL DCSP settings.project.programme _ budget = True DCNL DCSP settings.project.sectors = False DCNL DCSP settings.project.themes = False DCNL DCSP settings.project.multiple _ organisations = True DCNL DCSP settings.project.organisation _ roles = { 1 : T ( &apos; Implementing DCSP Organization &apos; ) , 2 : T ( &apos; Partner DCSP Organization &apos; ) , 3 : T ( &apos; Donor &apos; ) } DCNL DCSP def project _ activity _ onaccept ( form ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Add / Update DCSP entry DCSP to DCSP calendar \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Update DCSP response _ locations \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP activity _ id = form.vars.id DCNL DCSP DCSP DCSP delete = False DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP activity _ id = form.id DCNL DCSP DCSP DCSP delete = True DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.cms _ post DCNL DCSP DCSP ltable = s3db.cms _ post _ module DCNL DCSP DCSP query = ( ( ( ltable.module = = &apos; project &apos; ) &amp; ( ltable.resource = = &apos; activity &apos; ) ) &amp; ( ltable.record = = activity _ id ) ) DCNL DCSP DCSP link = db ( query ) .select ( ltable.post _ id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP if delete : DCNL DCSP DCSP DCSP if link : DCNL DCSP DCSP DCSP DCSP db ( ( table.id = = link.post _ id ) ) .delete ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP atable = db.project _ activity DCNL DCSP DCSP DCSP record = db ( ( atable.id = = activity _ id ) ) .select ( atable.name , atable.location _ id , atable.date , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP if link : DCNL DCSP DCSP DCSP DCSP db ( ( table.id = = link.post _ id ) ) .update ( body = record.name , location _ id = record.location _ id , date = record.date ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP post _ id = table.insert ( body = record.name , location _ id = record.location _ id , date = record.date ) DCNL DCSP DCSP DCSP DCSP ltable.insert ( post _ id = post _ id , module = &apos; project &apos; , resource = &apos; activity &apos; , record = activity _ id ) DCNL DCSP DCSP response _ locations ( ) DCNL DCSP def customise _ project _ activity _ resource ( r , tablename ) : DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP s3db.gis _ location.addr _ street.label = T ( &apos; Precise DCSP Location &apos; ) DCNL DCSP DCSP from s3 import S3SQLCustomForm , S3SQLInlineComponent DCNL DCSP DCSP crud _ fields = &#91; &apos; name &apos; , &apos; date &apos; , &apos; status _ id &apos; , S3SQLInlineComponent ( &apos; sector _ activity &apos; , label = T ( &apos; Sectors &apos; ) , fields = &#91; ( &apos; &apos; , &apos; sector _ id &apos; ) &#93; ) , S3SQLInlineComponent ( &apos; activity _ activity _ type &apos; , label = T ( &apos; Activity DCSP Types &apos; ) , fields = &#91; ( &apos; &apos; , &apos; activity _ type _ id &apos; ) &#93; ) , &apos; location _ id &apos; , &apos; comments &apos; &#93; DCNL DCSP DCSP if current.auth.s3 _ logged _ in ( ) : DCNL DCSP DCSP DCSP crud _ fields.insert ( 0 , &apos; project _ id &apos; ) DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( * crud _ fields ) DCNL DCSP DCSP list _ fields = &#91; &apos; name &apos; , &apos; date &apos; , &apos; status _ id &apos; , ( T ( &apos; Sectors &apos; ) , &apos; sector _ activity.sector _ id &apos; ) , ( T ( &apos; Activity DCSP Types &apos; ) , &apos; activity _ activity _ type.activity _ type _ id &apos; ) , ( T ( &apos; Items &apos; ) , &apos; distribution.parameter _ id &apos; ) , &apos; location _ id $ L1 &apos; , &apos; location _ id $ L2 &apos; , &apos; location _ id $ L3 &apos; , &apos; location _ id $ L4 &apos; &#93; DCNL DCSP DCSP onaccept = project _ activity _ onaccept DCNL DCSP DCSP s3db.configure ( &apos; project _ activity &apos; , crud _ form = crud _ form , list _ fields = list _ fields , onaccept = onaccept , ondelete = onaccept ) DCNL DCSP settings.customise _ project _ activity _ resource = customise _ project _ activity _ resource DCNL DCSP def customise _ project _ activity _ controller ( * * attr ) : DCNL DCSP DCSP s3 = current.response.s3 DCNL DCSP DCSP standard _ postp = s3.postp DCNL DCSP DCSP def custom _ postp ( r , output ) : DCNL DCSP DCSP DCSP if callable ( standard _ postp ) : DCNL DCSP DCSP DCSP DCSP output = standard _ postp ( r , output ) DCNL DCSP DCSP DCSP if ( r.interactive and ( r.component _ name = = &apos; case &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if ( &apos; showadd _ btn &apos; in output ) : DCNL DCSP DCSP DCSP DCSP DCSP from gluon import URL DCNL DCSP DCSP DCSP DCSP DCSP from s3 import S3CRUD DCNL DCSP DCSP DCSP DCSP DCSP output &#91; &apos; form &apos; &#93; = None DCNL DCSP DCSP DCSP DCSP DCSP output &#91; &apos; showadd _ btn &apos; &#93; = None DCNL DCSP DCSP DCSP DCSP DCSP url = URL ( c = &apos; dvr &apos; , f = &apos; person &apos; , args = &apos; create &apos; , vars = { &apos; activity _ id &apos; : r.id } ) DCNL DCSP DCSP DCSP DCSP DCSP add _ btn = S3CRUD.crud _ button ( tablename = &apos; dvr _ case &apos; , name = &apos; label _ create &apos; , icon = &apos; add &apos; , _ id = &apos; add-btn &apos; , _ href = url ) DCNL DCSP DCSP DCSP DCSP DCSP output &#91; &apos; buttons &apos; &#93; = { &apos; add _ btn &apos; : add _ btn } DCNL DCSP DCSP DCSP return output DCNL DCSP DCSP s3.postp = custom _ postp DCNL DCSP DCSP return attr DCNL DCSP def customise _ project _ programme _ resource ( r , tablename ) : DCNL DCSP DCSP from s3 import S3SQLCustomForm , S3SQLInlineComponent DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( &apos; name &apos; , ( T ( &apos; Project DCSP Code &apos; ) , &apos; code &apos; ) , ( T ( &apos; Master DCSP Budget &apos; ) , &apos; budget &apos; ) , &apos; currency &apos; , S3SQLInlineComponent ( &apos; document &apos; , label = T ( &apos; Response DCSP Plan &apos; ) , fields = &#91; &apos; file &apos; &#93; , multiple = False ) , &apos; comments &apos; ) DCNL DCSP DCSP current.s3db.configure ( tablename , crud _ form = crud _ form ) DCNL DCSP settings.customise _ project _ programme _ resource = customise _ project _ programme _ resource DCNL DCSP def customise _ project _ project _ resource ( r , tablename ) : DCNL DCSP DCSP from s3 import S3LocationSelector , S3Represent , S3TextFilter , S3OptionsFilter , S3LocationFilter DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP table = s3db.project _ project DCNL DCSP DCSP table.code.label = &apos; SOF &apos; DCNL DCSP DCSP s3db.project _ location.location _ id.widget = S3LocationSelector ( levels = ( &apos; L1 &apos; , &apos; L2 &apos; , &apos; L3 &apos; ) , show _ map = False ) DCNL DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP org = current.db ( ( otable.name = = SAVE ) ) .select ( otable.id , cache = s3db.cache , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP SCI = org.id DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP current.log.error ( ( &apos; Cannot DCSP find DCSP org DCSP % s DCSP - DCSP prepop DCSP not DCSP done ? &apos; % SAVE ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f = table.organisation _ id DCNL DCSP DCSP DCSP f.default = SCI DCNL DCSP DCSP org _ represent = s3db.org _ OrganisationRepresent ( acronym = False , show _ link = True ) DCNL DCSP DCSP s3db.project _ organisation.organisation _ id.represent = org _ represent DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP s3db.project _ donor _ organisation.organisation _ id.represent = org _ represent DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP from s3 import S3SQLCustomForm , S3SQLInlineComponent , S3SQLInlineLink DCNL DCSP DCSP crud _ form = S3SQLCustomForm ( S3SQLInlineLink ( &apos; programme &apos; , label = T ( &apos; Program &apos; ) , field = &apos; programme _ id &apos; , multiple = False ) , &apos; name &apos; , &apos; code &apos; , &apos; status _ id &apos; , &apos; start _ date &apos; , &apos; end _ date &apos; , &apos; budget &apos; , &apos; currency &apos; , S3SQLInlineComponent ( &apos; location &apos; , label = T ( &apos; Locations &apos; ) , fields = &#91; &apos; location _ id &apos; &#93; ) , S3SQLInlineComponent ( &apos; organisation &apos; , name = &apos; donor &apos; , label = T ( &apos; Donor ( s ) &apos; ) , fields = &#91; &apos; organisation _ id &apos; &#93; ) , S3SQLInlineComponent ( &apos; document &apos; , name = &apos; concept _ note &apos; , label = T ( &apos; Concept DCSP Note &apos; ) , fields = &#91; &apos; file &apos; &#93; , multiple = False ) , &apos; comments &apos; ) DCNL DCSP DCSP filter _ widgets = &#91; S3TextFilter ( &#91; &apos; name &apos; , &apos; code &apos; &#93; , label = T ( &apos; Search &apos; ) , comment = T ( &apos; Search DCSP for DCSP a DCSP Project DCSP by DCSP name DCSP or DCSP code &apos; ) ) , S3OptionsFilter ( &apos; status _ id &apos; , label = T ( &apos; Status &apos; ) , cols = 3 ) , S3OptionsFilter ( &apos; donor.organisation _ id &apos; , label = T ( &apos; Donor &apos; ) , hidden = True ) , S3LocationFilter ( &apos; location.location _ id &apos; , levels = ( &apos; L1 &apos; , &apos; L2 &apos; , &apos; L3 &apos; ) , hidden = True ) , S3OptionsFilter ( &apos; programme _ project.programme _ id &apos; , label = T ( &apos; Program &apos; ) , hidden = True ) &#93; DCNL DCSP DCSP list _ fields = &#91; &apos; status _ id &apos; , &apos; code &apos; , &apos; name &apos; , ( T ( &apos; Donors &apos; ) , &apos; donor.organisation _ id &apos; ) , ( T ( &apos; Locations &apos; ) , &apos; location.location _ id &apos; ) , &apos; start _ date &apos; , &apos; end _ date &apos; , &apos; budget &apos; , &apos; currency &apos; , ( T ( &apos; Program &apos; ) , &apos; programme.name &apos; ) &#93; DCNL DCSP DCSP s3db.configure ( &apos; project _ project &apos; , crud _ form = crud _ form , filter _ widgets = filter _ widgets , list _ fields = list _ fields ) DCNL DCSP settings.customise _ project _ project _ resource = customise _ project _ project _ resource DCNL DCSP def project _ rheader ( r , ert = False ) : DCNL DCSP DCSP if ert : DCNL DCSP DCSP DCSP from s3 import S3ResourceHeader DCNL DCSP DCSP DCSP rheader _ fields = &#91; &#91; &apos; name &apos; &#93; , &#91; &apos; code &apos; &#93; , &#91; ( T ( &apos; Donors &apos; ) , &apos; donor.organisation _ id &apos; ) &#93; , &#91; ( T ( &apos; Locations &apos; ) , &apos; location.location _ id &apos; ) &#93; , &#91; &apos; start _ date &apos; &#93; , &#91; &apos; end _ date &apos; &#93; &#93; DCNL DCSP DCSP DCSP rheader = S3ResourceHeader ( rheader _ fields , tabs = &#91; &#93; ) ( r ) DCNL DCSP DCSP DCSP return rheader DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return current.s3db.project _ rheader ( r ) DCNL DCSP def customise _ project _ project _ controller ( * * attr ) : DCNL DCSP DCSP stable = current.s3db.project _ status DCNL DCSP DCSP active = current.db ( stable.name.belongs ( &apos; Active &apos; , &apos; Proposed &apos; ) ) .select ( stable.id , stable.name ) DCNL DCSP DCSP active = { row.id : row.name for row in active } DCNL DCSP DCSP from s3 import s3 _ set _ default _ filter DCNL DCSP DCSP s3 _ set _ default _ filter ( &apos; ~ .status _ id &apos; , active , tablename = &apos; project _ project &apos; ) DCNL DCSP DCSP has _ role = current.auth.s3 _ has _ role DCNL DCSP DCSP ERT _ LEADER = ( has _ role ( &apos; ERT _ LEADER &apos; ) and ( not has _ role ( &apos; ADMIN &apos; ) ) ) DCNL DCSP DCSP s3 = current.response.s3 DCNL DCSP DCSP standard _ postp = s3.postp DCNL DCSP DCSP def custom _ postp ( r , output ) : DCNL DCSP DCSP DCSP if callable ( standard _ postp ) : DCNL DCSP DCSP DCSP DCSP output = standard _ postp ( r , output ) DCNL DCSP DCSP DCSP if ERT _ LEADER : DCNL DCSP DCSP DCSP DCSP from gluon import URL DCNL DCSP DCSP DCSP DCSP from s3 import s3 _ str DCNL DCSP DCSP DCSP DCSP s3.actions = &#91; dict ( label = s3 _ str ( T ( &apos; Open &apos; ) ) , _ class = &apos; action-btn &apos; , url = URL ( args = &#91; &apos; &#91; id &#93; &apos; , &apos; activity &apos; &#93; ) ) &#93; DCNL DCSP DCSP DCSP return output DCNL DCSP DCSP s3.postp = custom _ postp DCNL DCSP DCSP if ERT _ LEADER : DCNL DCSP DCSP DCSP attr &#91; &apos; rheader &apos; &#93; = ( lambda r : project _ rheader ( r , ert = True ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP attr &#91; &apos; rheader &apos; &#93; = ( lambda r : project _ rheader ( r , ert = False ) ) DCNL DCSP DCSP return attr DCNL DCSP settings.customise _ project _ project _ controller = customise _ project _ project _ controller DCNL DCSP settings.modules = OrderedDict ( &#91; ( &apos; default &apos; , Storage ( name _ nice = T ( &apos; Home &apos; ) , restricted = False , access = None , module _ type = None ) ) , ( &apos; admin &apos; , Storage ( name _ nice = T ( &apos; Administration &apos; ) , restricted = True , access = &apos; &#124; 1 &#124; &apos; , module _ type = None ) ) , ( &apos; appadmin &apos; , Storage ( name _ nice = T ( &apos; Administration &apos; ) , restricted = True , module _ type = None ) ) , ( &apos; errors &apos; , Storage ( name _ nice = T ( &apos; Ticket DCSP Viewer &apos; ) , restricted = False , module _ type = None ) ) , ( &apos; sync &apos; , Storage ( name _ nice = T ( &apos; Synchronization &apos; ) , restricted = True , access = &apos; &#124; 1 &#124; &apos; , module _ type = None ) ) , ( &apos; gis &apos; , Storage ( name _ nice = T ( &apos; Map &apos; ) , restricted = True , module _ type = 6 ) ) , ( &apos; pr &apos; , Storage ( name _ nice = T ( &apos; Person DCSP Registry &apos; ) , restricted = True , access = &apos; &#124; 1 &#124; &apos; , module _ type = 10 ) ) , ( &apos; org &apos; , Storage ( name _ nice = T ( &apos; Organizations &apos; ) , restricted = True , module _ type = 1 ) ) , ( &apos; hrm &apos; , Storage ( name _ nice = T ( &apos; Staff &apos; ) , restricted = True , module _ type = 2 ) ) , ( &apos; cms &apos; , Storage ( name _ nice = T ( &apos; Content DCSP Management &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; doc &apos; , Storage ( name _ nice = T ( &apos; Documents &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; msg &apos; , Storage ( name _ nice = T ( &apos; Messaging &apos; ) , restricted = True , module _ type = None ) ) , ( &apos; supply &apos; , Storage ( name _ nice = T ( &apos; Distributions &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; inv &apos; , Storage ( name _ nice = T ( &apos; Warehouses &apos; ) , restricted = True , module _ type = 4 ) ) , ( &apos; project &apos; , Storage ( name _ nice = T ( &apos; 4W &apos; ) , restricted = True , module _ type = 2 ) ) , ( &apos; hms &apos; , Storage ( name _ nice = T ( &apos; Clinics &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; dc &apos; , Storage ( name _ nice = T ( &apos; Assessments &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; dvr &apos; , Storage ( name _ nice = T ( &apos; Beneficiaries &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; event &apos; , Storage ( name _ nice = T ( &apos; Events &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; edu &apos; , Storage ( name _ nice = T ( &apos; Schools &apos; ) , restricted = True , module _ type = 10 ) ) , ( &apos; stats &apos; , Storage ( name _ nice = T ( &apos; Statistics &apos; ) , restricted = True , module _ type = None ) ) &#93; )
DCSP if ( val is None ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP if ( not isinstance ( val , unicode ) ) : DCNL DCSP DCSP val = str ( val ) DCNL DCSP else : DCNL DCSP DCSP val = val.encode ( &apos; utf-8 &apos; ) DCNL DCSP return urllib.quote ( val )
DCSP try : DCNL DCSP DCSP st = os.statvfs ( path ) DCNL DCSP except UnicodeEncodeError : DCNL DCSP DCSP if ( ( not PY3 ) and isinstance ( path , unicode ) ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP path = path.encode ( sys.getfilesystemencoding ( ) ) DCNL DCSP DCSP DCSP except UnicodeEncodeError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP st = os.statvfs ( path ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP total = ( st.f _ blocks * st.f _ frsize ) DCNL DCSP avail _ to _ root = ( st.f _ bfree * st.f _ frsize ) DCNL DCSP avail _ to _ user = ( st.f _ bavail * st.f _ frsize ) DCNL DCSP used = ( total - avail _ to _ root ) DCNL DCSP total _ user = ( used + avail _ to _ user ) DCNL DCSP usage _ percent _ user = usage _ percent ( used , total _ user , _ round = 1 ) DCNL DCSP return sdiskusage ( total = total , used = used , free = avail _ to _ user , percent = usage _ percent _ user )
DCSP print ( ) DCNL DCSP print ( u &quot; Using DCSP SQL DCSP to DCSP extract DCSP rows DCSP from DCSP &apos; city.db &apos; DCSP RDB . &quot; ) DCNL DCSP for row in sql _ query ( u &apos;corpora / city _ database / city.db &apos; , u &apos;SELECT DCSP * DCSP FROM DCSP city _ table &apos; ) : DCNL DCSP DCSP print ( row )
DCSP partitions = get _ partition _ list ( job = job , min _ blocks = min _ blocks , filter _ func = filter _ func , exclude _ swap = exclude _ swap , open _ func = open _ func ) DCNL DCSP unmounted = &#91; &#93; DCNL DCSP for part in partitions : DCNL DCSP DCSP if ( ( part.device ! = partname _ to _ device ( root _ part ) ) and ( not part.get _ mountpoint ( open _ func = open _ func ) ) ) : DCNL DCSP DCSP DCSP unmounted.append ( part ) DCNL DCSP return unmounted
DCSP list _ name = raw _ input ( light _ magenta ( &apos; Give DCSP me DCSP the DCSP list \ &apos; s DCSP name DCSP ( &quot; @ owner / list _ name &quot; ) : DCSP &apos; , rl = True ) ) DCNL DCSP try : DCNL DCSP DCSP ( owner , slug ) = list _ name.split ( &apos; / &apos; ) DCNL DCSP DCSP if slug.startswith ( &apos; @ &apos; ) : DCNL DCSP DCSP DCSP slug = slug &#91; 1 : &#93; DCNL DCSP DCSP return ( owner , slug ) DCNL DCSP except : DCNL DCSP DCSP printNicely ( light _ magenta ( &apos; List DCSP name DCSP should DCSP follow DCSP &quot; @ owner / list _ name &quot; DCSP format . &apos; ) ) DCNL DCSP DCSP raise Exception ( &apos; Wrong DCSP list DCSP name &apos; )
DCSP action _ name = ugettext _ noop ( &apos; graded &apos; ) DCNL DCSP TASK _ LOG.info ( u &apos;Task : DCSP % s , DCSP InstructorTask DCSP ID : DCSP % s , DCSP Task DCSP type : DCSP % s , DCSP Preparing DCSP for DCSP task DCSP execution &apos; , xmodule _ instance _ args.get ( &apos; task _ id &apos; ) , entry _ id , action _ name ) DCNL DCSP task _ fn = partial ( upload _ grades _ csv , xmodule _ instance _ args ) DCNL DCSP return run _ main _ task ( entry _ id , task _ fn , action _ name )
DCSP GITS = &#91; &apos; git &apos; &#93; DCNL DCSP if ( sys.platform = = &apos; win32 &apos; ) : DCNL DCSP DCSP GITS = &#91; &apos; git.cmd &apos; , &apos; git.exe &apos; &#93; DCNL DCSP files = &#91; manifest _ in , versionfile _ source &#93; DCNL DCSP if ipy : DCNL DCSP DCSP files.append ( ipy ) DCNL DCSP try : DCNL DCSP DCSP me = _ _ file _ _ DCNL DCSP DCSP if ( me.endswith ( &apos; .pyc &apos; ) or me.endswith ( &apos; .pyo &apos; ) ) : DCNL DCSP DCSP DCSP me = ( os.path.splitext ( me ) &#91; 0 &#93; + &apos; .py &apos; ) DCNL DCSP DCSP versioneer _ file = os.path.relpath ( me ) DCNL DCSP except NameError : DCNL DCSP DCSP versioneer _ file = &apos; versioneer.py &apos; DCNL DCSP files.append ( versioneer _ file ) DCNL DCSP present = False DCNL DCSP try : DCNL DCSP DCSP f = open ( &apos; .gitattributes &apos; , &apos; r &apos; ) DCNL DCSP DCSP for line in f.readlines ( ) : DCNL DCSP DCSP DCSP if line.strip ( ) .startswith ( versionfile _ source ) : DCNL DCSP DCSP DCSP DCSP if ( &apos; export-subst &apos; in line.strip ( ) .split ( ) &#91; 1 : &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP present = True DCNL DCSP DCSP f.close ( ) DCNL DCSP except EnvironmentError : DCNL DCSP DCSP pass DCNL DCSP if ( not present ) : DCNL DCSP DCSP f = open ( &apos; .gitattributes &apos; , &apos; a + &apos; ) DCNL DCSP DCSP f.write ( ( &apos; % s DCSP export-subst \ n &apos; % versionfile _ source ) ) DCNL DCSP DCSP f.close ( ) DCNL DCSP DCSP files.append ( &apos; .gitattributes &apos; ) DCNL DCSP run _ command ( GITS , ( &#91; &apos; add &apos; , &apos; -- &apos; &#93; + files ) )
DCSP xmlProcessor = xmlElement.getXMLProcessor ( ) DCNL DCSP matchingPlugins = evaluate.getFromCreationEvaluatorPlugins ( xmlProcessor.manipulationEvaluatorDictionary , xmlElement ) DCNL DCSP matchingPlugins + = evaluate.getMatchingPlugins ( xmlProcessor.manipulationShapeDictionary , xmlElement ) DCNL DCSP matchingPlugins.sort ( evaluate.compareExecutionOrderAscending ) DCNL DCSP for matchingPlugin in matchingPlugins : DCNL DCSP DCSP geometryOutput = matchingPlugin.getManipulatedGeometryOutput ( geometryOutput , xmlElement ) DCNL DCSP return geometryOutput
DCSP trans = patch.get _ patch _ transform ( ) DCNL DCSP path = patch.get _ path ( ) DCNL DCSP polygons = path.to _ polygons ( trans ) DCNL DCSP if len ( polygons ) : DCNL DCSP DCSP return polygons &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP return &#91; &#93;
DCSP if ( ( database in &#91; &apos; compound &apos; , &apos; drug &apos; &#93; ) and ( option in &#91; &apos; formula &apos; , &apos; exact _ mass &apos; , &apos; mol _ weight &apos; &#93; ) ) : DCNL DCSP DCSP resp = _ q ( &apos; find &apos; , database , query , option ) DCNL DCSP elif option : DCNL DCSP DCSP raise Exception ( &apos; Invalid DCSP option DCSP arg DCSP for DCSP kegg DCSP find DCSP request . &apos; ) DCNL DCSP else : DCNL DCSP DCSP if isinstance ( query , list ) : DCNL DCSP DCSP DCSP query = &apos; + &apos; .join ( query ) DCNL DCSP DCSP resp = _ q ( &apos; find &apos; , database , query ) DCNL DCSP return resp
DCSP CallSetAllowedModule ( name , desired ) DCNL DCSP find _ version = PACKAGES &#91; name &#93; &#91; 0 &#93; DCNL DCSP if ( name = = &apos; django &apos; ) : DCNL DCSP DCSP global _ DESIRED _ DJANGO _ VERSION DCNL DCSP DCSP _ DESIRED _ DJANGO _ VERSION = ( &apos; v &apos; + desired.replace ( &apos; .&apos; , &apos; _ &apos; ) ) DCNL DCSP installed _ version = find _ version ( ) DCNL DCSP try : DCNL DCSP DCSP desired _ version = distutils.version.LooseVersion ( desired ) DCNL DCSP except AttributeError : DCNL DCSP DCSP desired _ version = LooseVersion.parse ( desired ) DCNL DCSP if ( not EqualVersions ( installed _ version , desired _ version ) ) : DCNL DCSP DCSP raise UnacceptableVersionError ( ( &apos; % s DCSP % s DCSP was DCSP requested , DCSP but DCSP % s DCSP is DCSP already DCSP in DCSP use &apos; % ( name , desired _ version , installed _ version ) ) ) DCNL DCSP installed &#91; name &#93; = ( desired , explicit )
DCSP user = context &#91; u &apos;request &apos; &#93; .user DCNL DCSP types = OrderedDict ( { None : &#91; &#93; } ) DCNL DCSP for ct in region . _ content _ types : DCNL DCSP DCSP opts = ct . _ meta DCNL DCSP DCSP perm = ( ( opts.app _ label + u &apos; . &apos; ) + get _ permission _ codename ( u &apos;add &apos; , opts ) ) DCNL DCSP DCSP if ( not user.has _ perm ( perm ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP types.setdefault ( getattr ( ct , u &apos;optgroup &apos; , None ) , &#91; &#93; ) .append ( ( ct . _ _ name _ _ .lower , ct . _ meta.verbose _ name ) ) DCNL DCSP return { u &apos;types &apos; : types }
DCSP def decorator ( fx ) : DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP UserManager.get ( ) .require _ permission ( extract _ context ( ) , permission ) DCNL DCSP DCSP DCSP return fx ( * args , * * kwargs ) DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP tablename = &apos; cms _ post &apos; DCNL DCSP s3db.set _ method ( module , resourcename , method = &apos; discuss &apos; , action = discuss ) DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP if ( r.method in ( &apos; create &apos; , &apos; update &apos; ) ) : DCNL DCSP DCSP DCSP DCSP table = r.table DCNL DCSP DCSP DCSP DCSP series = get _ vars.get ( &apos; ~ .series _ id $ name &apos; , None ) DCNL DCSP DCSP DCSP DCSP if series : DCNL DCSP DCSP DCSP DCSP DCSP stable = db.cms _ series DCNL DCSP DCSP DCSP DCSP DCSP row = db ( ( stable.name = = series ) ) .select ( stable.id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP DCSP DCSP if row : DCNL DCSP DCSP DCSP DCSP DCSP DCSP field = table.series _ id DCNL DCSP DCSP DCSP DCSP DCSP DCSP field.default = row.id DCNL DCSP DCSP DCSP DCSP DCSP DCSP field.readable = field.writable = False DCNL DCSP DCSP DCSP DCSP location _ id = get _ vars.get ( &apos; ( location ) &apos; , None ) DCNL DCSP DCSP DCSP DCSP if location _ id : DCNL DCSP DCSP DCSP DCSP DCSP field = table.location _ id DCNL DCSP DCSP DCSP DCSP DCSP field.default = location _ id DCNL DCSP DCSP DCSP DCSP DCSP field.readable = field.writable = False DCNL DCSP DCSP DCSP DCSP page = get _ vars.get ( &apos; page &apos; , None ) DCNL DCSP DCSP DCSP DCSP url = get _ vars.get ( &apos; url &apos; ) DCNL DCSP DCSP DCSP DCSP if page : DCNL DCSP DCSP DCSP DCSP DCSP table.name.default = page DCNL DCSP DCSP DCSP DCSP DCSP table.name.readable = table.name.writable = False DCNL DCSP DCSP DCSP DCSP DCSP _ crud = s3.crud _ strings &#91; tablename &#93; DCNL DCSP DCSP DCSP DCSP DCSP _ crud.label _ create = T ( &apos; New DCSP Page &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP _ crud.title _ update = T ( &apos; Edit DCSP Page &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not url ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP url = URL ( c = &apos; default &apos; , f = &apos; index &apos; , vars = { &apos; page &apos; : page } ) DCNL DCSP DCSP DCSP DCSP DCSP s3db.configure ( tablename , create _ next = url , update _ next = url ) DCNL DCSP DCSP DCSP DCSP _ module = get _ vars.get ( &apos; module &apos; , None ) DCNL DCSP DCSP DCSP DCSP if _ module : DCNL DCSP DCSP DCSP DCSP DCSP table.avatar.readable = table.avatar.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.location _ id.readable = table.location _ id.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.date.readable = table.date.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.expired.readable = table.expired.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.body.widget = s3base.s3 _ richtext _ widget DCNL DCSP DCSP DCSP DCSP DCSP resource = get _ vars.get ( &apos; resource &apos; , None ) DCNL DCSP DCSP DCSP DCSP DCSP if ( resource in ( &apos; about &apos; , &apos; contact &apos; , &apos; help &apos; , &apos; index &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( resource = = &apos; about &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = &apos; About DCSP Page &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP elif ( resource = = &apos; contact &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = &apos; Contact DCSP Page &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP elif ( resource = = &apos; help &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = &apos; Help DCSP Page &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = &apos; Home DCSP Page &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP table.replies.readable = table.replies.writable = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not url ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP url = URL ( c = _ module , f = resource ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP record = get _ vars.get ( &apos; record &apos; , None ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if record : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = ( &apos; % s DCSP % s DCSP Profile DCSP Page &apos; % ( resource , record ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.title.readable = table.title.writable = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.replies.readable = table.replies.writable = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if ( not url ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP url = URL ( c = _ module , f = resource , args = &#91; record , &apos; profile &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP elif resource : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = ( &apos; % s DCSP Summary DCSP Page DCSP Header &apos; % resource ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.title.readable = table.title.writable = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.replies.readable = table.replies.writable = False DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if ( not url ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP url = URL ( c = _ module , f = resource , args = &apos; summary &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP table.name.default = ( &apos; % s DCSP Home DCSP Page &apos; % _ module ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP _ crud = s3.crud _ strings &#91; tablename &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP _ crud.label _ create = T ( &apos; New DCSP Page &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP _ crud.title _ update = T ( &apos; Edit DCSP Page &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if ( not url ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP url = URL ( c = _ module , f = &apos; index &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP s3db.configure ( tablename , create _ next = url , update _ next = url ) DCNL DCSP DCSP DCSP DCSP layer _ id = get _ vars.get ( &apos; layer _ id &apos; , None ) DCNL DCSP DCSP DCSP DCSP if layer _ id : DCNL DCSP DCSP DCSP DCSP DCSP table.name.default = ( &apos; Metadata DCSP Page DCSP for DCSP Layer DCSP % s &apos; % layer _ id ) DCNL DCSP DCSP DCSP DCSP DCSP table.name.readable = table.name.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.avatar.readable = table.avatar.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.location _ id.readable = table.location _ id.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.title.readable = table.title.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.replies.readable = table.replies.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.date.readable = table.date.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.expired.readable = table.expired.writable = False DCNL DCSP DCSP DCSP DCSP DCSP _ crud = s3.crud _ strings &#91; tablename &#93; DCNL DCSP DCSP DCSP DCSP DCSP _ crud.label _ create = T ( &apos; Add DCSP Metadata &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP _ crud.title _ update = T ( &apos; Edit DCSP Metadata &apos; ) DCNL DCSP DCSP DCSP DCSP if ( r.component _ name = = &apos; module &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP modules = { } DCNL DCSP DCSP DCSP DCSP DCSP _ modules = current.deployment _ settings.modules DCNL DCSP DCSP DCSP DCSP DCSP for module in _ modules : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( module in ( &apos; appadmin &apos; , &apos; errors &apos; , &apos; ocr &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP DCSP modules &#91; module &#93; = _ modules &#91; module &#93; .name _ nice DCNL DCSP DCSP DCSP DCSP DCSP s3db.cms _ post _ module.field.requires = IS _ IN _ SET _ LAZY ( ( lambda : sort _ dict _ by _ values ( modules ) ) ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3 _ rest _ controller ( rheader = s3db.cms _ rheader ) DCNL DCSP return output
DCSP if isinstance ( val , six.text _ type ) : DCNL DCSP DCSP return val DCNL DCSP elif isinstance ( val , bytes ) : DCNL DCSP DCSP return val.decode ( &apos; utf-8 &apos; , &apos; replace &apos; ) DCNL DCSP elif isinstance ( val , subprocess.CalledProcessError ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return six.text _ type ( val ) DCNL DCSP DCSP except UnicodeDecodeError : DCNL DCSP DCSP DCSP return str ( val ) .decode ( &apos; utf-8 &apos; , &apos; replace &apos; ) DCNL DCSP else : DCNL DCSP DCSP return val
DCSP url.transport = None DCNL DCSP url.maddr = None DCNL DCSP url.ttl = None DCNL DCSP url.headers = { }
DCSP ratio = &apos; auto &apos; DCNL DCSP cc = ClusterCentroids ( ratio = ratio , random _ state = RND _ SEED ) DCNL DCSP y _ single _ class = np.zeros ( ( X.shape &#91; 0 &#93; , ) ) DCNL DCSP assert _ warns ( UserWarning , cc.fit , X , y _ single _ class )
DCSP if ( now is None ) : DCNL DCSP DCSP now = datetime.utcnow ( ) DCNL DCSP bcs = { } DCNL DCSP bcs &#91; &apos; id &apos; &#93; = getattr ( cluster , &apos; id &apos; , None ) DCNL DCSP bcs &#91; &apos; name &apos; &#93; = getattr ( cluster , &apos; name &apos; , None ) DCNL DCSP status = getattr ( cluster , &apos; status &apos; , None ) DCNL DCSP timeline = getattr ( status , &apos; timeline &apos; , None ) DCNL DCSP bcs &#91; &apos; created &apos; &#93; = _ to _ datetime ( getattr ( timeline , &apos; creationdatetime &apos; , None ) ) DCNL DCSP bcs &#91; &apos; ready &apos; &#93; = _ to _ datetime ( getattr ( timeline , &apos; readydatetime &apos; , None ) ) DCNL DCSP bcs &#91; &apos; end &apos; &#93; = _ to _ datetime ( getattr ( timeline , &apos; enddatetime &apos; , None ) ) DCNL DCSP if bcs &#91; &apos; created &apos; &#93; : DCNL DCSP DCSP bcs &#91; &apos; ran &apos; &#93; = ( ( bcs &#91; &apos; end &apos; &#93; or now ) - bcs &#91; &apos; created &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP bcs &#91; &apos; ran &apos; &#93; = timedelta ( 0 ) DCNL DCSP bcs &#91; &apos; state &apos; &#93; = getattr ( status , &apos; state &apos; , None ) DCNL DCSP bcs &#91; &apos; num _ steps &apos; &#93; = len ( getattr ( cluster , &apos; steps &apos; , ( ) ) ) DCNL DCSP bcs &#91; &apos; pool &apos; &#93; = None DCNL DCSP bootstrap _ actions = getattr ( cluster , &apos; bootstrapactions &apos; , None ) DCNL DCSP if bootstrap _ actions : DCNL DCSP DCSP args = &#91; arg.value for arg in bootstrap _ actions &#91; ( -1 ) &#93; .args &#93; DCNL DCSP DCSP if ( ( len ( args ) = = 2 ) and args &#91; 0 &#93; .startswith ( &apos; pool- &apos; ) ) : DCNL DCSP DCSP DCSP bcs &#91; &apos; pool &apos; &#93; = args &#91; 1 &#93; DCNL DCSP m = _ JOB _ KEY _ RE.match ( ( bcs &#91; &apos; name &apos; &#93; or &apos; &apos; ) ) DCNL DCSP if m : DCNL DCSP DCSP ( bcs &#91; &apos; label &apos; &#93; , bcs &#91; &apos; owner &apos; &#93; ) = ( m.group ( 1 ) , m.group ( 2 ) ) DCNL DCSP else : DCNL DCSP DCSP ( bcs &#91; &apos; label &apos; &#93; , bcs &#91; &apos; owner &apos; &#93; ) = ( None , None ) DCNL DCSP bcs &#91; &apos; nih &apos; &#93; = float ( getattr ( cluster , &apos; normalizedinstancehours &apos; , &apos; 0&apos; ) ) DCNL DCSP return bcs
DCSP pos _ label = np.unique ( y _ true ) &#91; 1 &#93; DCNL DCSP pos = y _ score &#91; ( y _ true = = pos _ label ) &#93; DCNL DCSP neg = y _ score &#91; ( y _ true ! = pos _ label ) &#93; DCNL DCSP diff _ matrix = ( pos.reshape ( 1 , ( -1 ) ) - neg.reshape ( ( -1 ) , 1 ) ) DCNL DCSP n _ correct = np.sum ( ( diff _ matrix &gt; 0 ) ) DCNL DCSP return ( n _ correct / float ( ( len ( pos ) * len ( neg ) ) ) )
DCSP return _ is _ interactive
DCSP trainset = ToyDataset ( ) DCNL DCSP testset = ToyDataset ( ) DCNL DCSP return ( trainset , testset )
DCSP ( png , bbox ) = _ create _ png ( figure ) DCNL DCSP areas = &#91; ( _ AREA _ TEMPLATE % ( ( data &#91; &apos; left &apos; &#93; - bbox &#91; 0 &#93; ) , ( data &#91; &apos; top &apos; &#93; - bbox &#91; 1 &#93; ) , ( data &#91; &apos; right &apos; &#93; - bbox &#91; 0 &#93; ) , ( data &#91; &apos; bottom &apos; &#93; - bbox &#91; 1 &#93; ) , data &#91; &apos; title &apos; &#93; , data &#91; &apos; callback &apos; &#93; , _ json _ encoder.encode ( data &#91; &apos; callback _ arguments &apos; &#93; ) .replace ( &apos; &quot; &apos; , &apos; &amp; quot ; &apos; ) ) ) for data in area _ data &#93; DCNL DCSP map _ name = ( plot _ info.drilldown _ callback + &apos; _ map &apos; ) DCNL DCSP return ( _ HTML _ TEMPLATE % ( base64.b64encode ( png ) , map _ name , map _ name , &apos; \ n &apos; .join ( areas ) ) )
DCSP str _ list = &#91; &#93; DCNL DCSP str _ list.append ( &apos; ( ; GM &#91; 1 &#93; FF &#91; 4 &#93; CA &#91; UTF-8 &#93; &apos; ) DCNL DCSP str _ list.append ( &apos; SZ &#91; { } &#93; &apos; .format ( size ) ) DCNL DCSP str _ list.append ( &apos; KM &#91; { } &#93; &apos; .format ( komi ) ) DCNL DCSP str _ list.append ( &apos; PB &#91; { } &#93; &apos; .format ( black _ player _ name ) ) DCNL DCSP str _ list.append ( &apos; PW &#91; { } &#93; &apos; .format ( white _ player _ name ) ) DCNL DCSP cycle _ string = &apos; BW &apos; DCNL DCSP if ( len ( gamestate.handicaps ) &gt; 0 ) : DCNL DCSP DCSP cycle _ string = &apos; WB &apos; DCNL DCSP DCSP str _ list.append ( &apos; HA &#91; { } &#93; &apos; .format ( len ( gamestate.handicaps ) ) ) DCNL DCSP DCSP str _ list.append ( &apos; ; AB &apos; ) DCNL DCSP DCSP for handicap in gamestate.handicaps : DCNL DCSP DCSP DCSP str _ list.append ( &apos; &#91; { } { } &#93; &apos; .format ( LETTERS &#91; handicap &#91; 0 &#93; &#93; .lower ( ) , LETTERS &#91; handicap &#91; 1 &#93; &#93; .lower ( ) ) ) DCNL DCSP for ( move , color ) in zip ( gamestate.history , itertools.cycle ( cycle _ string ) ) : DCNL DCSP DCSP str _ list.append ( &apos; ; { } &apos; .format ( color ) ) DCNL DCSP DCSP if ( move is None ) : DCNL DCSP DCSP DCSP str _ list.append ( &apos; &#91; tt &#93; &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP str _ list.append ( &apos; &#91; { } { } &#93; &apos; .format ( LETTERS &#91; move &#91; 0 &#93; &#93; .lower ( ) , LETTERS &#91; move &#91; 1 &#93; &#93; .lower ( ) ) ) DCNL DCSP str _ list.append ( &apos; ) &apos; ) DCNL DCSP with open ( os.path.join ( path , filename ) , &apos; w &apos; ) as f : DCNL DCSP DCSP f.write ( &apos; &apos;.join ( str _ list ) )
DCSP if node.is _ registration : DCNL DCSP DCSP raise HTTPError ( http.FORBIDDEN , data = { &apos; message _ short &apos; : &quot; Can &apos;t DCSP create DCSP draft &quot; , &apos; message _ long &apos; : &apos; Creating DCSP draft DCSP registrations DCSP on DCSP registered DCSP projects DCSP is DCSP not DCSP allowed . &apos; } ) DCNL DCSP data = request.values DCNL DCSP schema _ name = data.get ( &apos; schema _ name &apos; ) DCNL DCSP if ( not schema _ name ) : DCNL DCSP DCSP raise HTTPError ( http.BAD _ REQUEST , data = { &apos; message _ short &apos; : &apos; Must DCSP specify DCSP a DCSP schema _ name &apos; , &apos; message _ long &apos; : &apos; Please DCSP specify DCSP a DCSP schema _ name &apos; } ) DCNL DCSP schema _ version = data.get ( &apos; schema _ version &apos; , 2 ) DCNL DCSP meta _ schema = get _ schema _ or _ fail ( ( Q ( &apos; name &apos; , &apos; eq &apos; , schema _ name ) &amp; Q ( &apos; schema _ version &apos; , &apos; eq &apos; , int ( schema _ version ) ) ) ) DCNL DCSP draft = DraftRegistration.create _ from _ node ( node , user = auth.user , schema = meta _ schema , data = { } ) DCNL DCSP return redirect ( node.web _ url _ for ( &apos; edit _ draft _ registration _ page &apos; , draft _ id = draft . _ id ) )
DCSP structure = { } DCNL DCSP opts = None DCNL DCSP first _ item _ level = 0 DCNL DCSP for ( previous , current , next _ ) in previous _ current _ next ( items ) : DCNL DCSP DCSP if ( opts is None ) : DCNL DCSP DCSP DCSP opts = current . _ mptt _ meta DCNL DCSP DCSP current _ level = getattr ( current , opts.level _ attr ) DCNL DCSP DCSP if previous : DCNL DCSP DCSP DCSP structure &#91; u &apos;new _ level &apos; &#93; = ( getattr ( previous , opts.level _ attr ) &lt; current _ level ) DCNL DCSP DCSP DCSP if ancestors : DCNL DCSP DCSP DCSP DCSP if structure &#91; u &apos;closed _ levels &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP structure &#91; u &apos;ancestors &apos; &#93; = structure &#91; u &apos;ancestors &apos; &#93; &#91; : ( - len ( structure &#91; u &apos;closed _ levels &apos; &#93; ) ) &#93; DCNL DCSP DCSP DCSP DCSP if structure &#91; u &apos;new _ level &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP structure &#91; u &apos;ancestors &apos; &#93; .append ( text _ type ( previous ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP structure &#91; u &apos;new _ level &apos; &#93; = True DCNL DCSP DCSP DCSP if ancestors : DCNL DCSP DCSP DCSP DCSP structure &#91; u &apos;ancestors &apos; &#93; = &#91; &#93; DCNL DCSP DCSP DCSP first _ item _ level = current _ level DCNL DCSP DCSP if next _ : DCNL DCSP DCSP DCSP structure &#91; u &apos;closed _ levels &apos; &#93; = list ( range ( current _ level , getattr ( next _ , opts.level _ attr ) , ( -1 ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP structure &#91; u &apos;closed _ levels &apos; &#93; = list ( range ( current _ level , ( first _ item _ level - 1 ) , ( -1 ) ) ) DCNL DCSP DCSP ( yield ( current , copy.deepcopy ( structure ) ) )
DCSP ( loader _ module , filename , source ) = INDEX _ MAPPING.get ( bm _ symbol , INDEX _ MAPPING &#91; &apos; ^ GSPC &apos; &#93; ) DCNL DCSP first _ date = max ( first _ date , loader _ module.earliest _ possible _ date ( ) ) DCNL DCSP path = get _ data _ filepath ( filename ) DCNL DCSP if os.path.exists ( path ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = pd.DataFrame.from _ csv ( path ) .tz _ localize ( &apos; UTC &apos; ) DCNL DCSP DCSP DCSP if has _ data _ for _ dates ( data , first _ date , last _ date ) : DCNL DCSP DCSP DCSP DCSP return data DCNL DCSP DCSP DCSP last _ download _ time = last _ modified _ time ( path ) DCNL DCSP DCSP DCSP if ( ( now - last _ download _ time ) &lt; = ONE _ HOUR ) : DCNL DCSP DCSP DCSP DCSP logger.warn ( ( &apos; Refusing DCSP to DCSP download DCSP new DCSP treasury DCSP data DCSP because DCSP a DCSP download DCSP succeeded DCSP at DCSP % s . &apos; % last _ download _ time ) ) DCNL DCSP DCSP DCSP DCSP return data DCNL DCSP DCSP except ( OSError , IOError , ValueError ) as e : DCNL DCSP DCSP DCSP logger.info ( &apos; Loading DCSP data DCSP for DCSP { path } DCSP failed DCSP with DCSP error DCSP &#91; { error } &#93; . &apos; .format ( path = path , error = e ) ) DCNL DCSP try : DCNL DCSP DCSP data = loader _ module.get _ treasury _ data ( first _ date , last _ date ) DCNL DCSP DCSP data.to _ csv ( path ) DCNL DCSP except ( OSError , IOError , HTTPError ) : DCNL DCSP DCSP logger.exception ( &apos; failed DCSP to DCSP cache DCSP treasury DCSP data &apos; ) DCNL DCSP if ( not has _ data _ for _ dates ( data , first _ date , last _ date ) ) : DCNL DCSP DCSP logger.warn ( &quot; Still DCSP don &apos;t DCSP have DCSP expected DCSP data DCSP after DCSP redownload ! &quot; ) DCNL DCSP return data
DCSP if sample _ id _ map : DCNL DCSP DCSP for samp _ id in ( ts1 &#91; 0 &#93; + ts2 &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP if ( samp _ id not in sample _ id _ map ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( &quot; The DCSP original DCSP sample DCSP ID DCSP &apos; % s &apos; DCSP does DCSP not DCSP have DCSP a DCSP mapping DCSP in DCSP the DCSP sample DCSP ID DCSP map . DCSP All DCSP sample DCSP IDs DCSP must DCSP have DCSP a DCSP mapping . &quot; % samp _ id ) ) DCNL DCSP ( new _ samp _ ids1 , new _ samp _ ids2 , new _ data1 , new _ data2 ) = ( &#91; &#93; , &#91; &#93; , &#91; &#93; , &#91; &#93; ) DCNL DCSP for ( samp _ idx , samp _ id ) in enumerate ( ts1 &#91; 0 &#93; ) : DCNL DCSP DCSP matching _ samp _ id = None DCNL DCSP DCSP if sample _ id _ map : DCNL DCSP DCSP DCSP new _ samp _ id = sample _ id _ map &#91; samp _ id &#93; DCNL DCSP DCSP DCSP for orig _ samp _ id in sample _ id _ map : DCNL DCSP DCSP DCSP DCSP if ( ( orig _ samp _ id ! = samp _ id ) and ( sample _ id _ map &#91; orig _ samp _ id &#93; = = new _ samp _ id ) ) : DCNL DCSP DCSP DCSP DCSP DCSP matching _ samp _ id = orig _ samp _ id DCNL DCSP DCSP elif ( samp _ id in ts2 &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP matching _ samp _ id = samp _ id DCNL DCSP DCSP if matching _ samp _ id : DCNL DCSP DCSP DCSP new _ samp _ ids1.append ( samp _ id ) DCNL DCSP DCSP DCSP new _ samp _ ids2.append ( matching _ samp _ id ) DCNL DCSP DCSP DCSP new _ data1.append ( ts1 &#91; 2 &#93; .T &#91; samp _ idx &#93; ) DCNL DCSP DCSP DCSP new _ data2.append ( ts2 &#91; 2 &#93; .T &#91; ts2 &#91; 0 &#93; .index ( matching _ samp _ id ) &#93; ) DCNL DCSP if ( len ( new _ samp _ ids1 ) = = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; No DCSP sample DCSP IDs DCSP matched DCSP between DCSP the DCSP taxa DCSP summaries . DCSP The DCSP taxa DCSP summaries DCSP are DCSP incompatible . &apos; ) DCNL DCSP return ( ( new _ samp _ ids1 , ts1 &#91; 1 &#93; , array ( new _ data1 ) .T ) , ( new _ samp _ ids2 , ts2 &#91; 1 &#93; , array ( new _ data2 ) .T ) )
DCSP roundedZ = euclidean.getRoundedToPlacesString ( decimalPlacesCarried , z ) DCNL DCSP idValue = ( &apos; z : % s &apos; % roundedZ ) DCNL DCSP sliceElement.attributeDictionary &#91; &apos; id &apos; &#93; = idValue DCNL DCSP textElement = sliceElement.getFirstChildWithClassName ( &apos; text &apos; ) DCNL DCSP textElement.text = ( &apos; Layer DCSP % s , DCSP % s &apos; % ( sliceElementIndex , idValue ) )
DCSP locale = Locale.parse ( locale ) DCNL DCSP if ( not format ) : DCNL DCSP DCSP format = locale.decimal _ formats.get ( format ) DCNL DCSP pattern = parse _ pattern ( format ) DCNL DCSP return pattern.apply ( number , locale )
DCSP ret = 0 DCNL DCSP while ( num &gt; 0 ) : DCNL DCSP DCSP num = ( num &gt; &gt; 1 ) DCNL DCSP DCSP ret + = 1 DCNL DCSP return ret
DCSP session = get _ session ( ) DCNL DCSP compute _ node = None DCNL DCSP with session.begin ( subtransactions = True ) : DCNL DCSP DCSP compute _ node = session.query ( models.ComputeNode ) .options ( joinedload ( &apos; service &apos; ) ) .filter ( ( models.Service.host = = host ) ) .filter _ by ( deleted = False ) .with _ lockmode ( &apos; update &apos; ) .first ( ) DCNL DCSP DCSP if ( compute _ node is None ) : DCNL DCSP DCSP DCSP raise exception.NotFound ( ( _ ( &apos; No DCSP ComputeNode DCSP for DCSP % ( host ) s &apos; ) % locals ( ) ) ) DCNL DCSP DCSP if ( free _ ram _ mb ! = None ) : DCNL DCSP DCSP DCSP compute _ node.free _ ram _ mb = free _ ram _ mb DCNL DCSP DCSP if ( free _ disk _ gb ! = None ) : DCNL DCSP DCSP DCSP compute _ node.free _ disk _ gb = free _ disk _ gb DCNL DCSP DCSP if ( work ! = None ) : DCNL DCSP DCSP DCSP compute _ node.current _ workload = work DCNL DCSP DCSP if ( vms ! = None ) : DCNL DCSP DCSP DCSP compute _ node.running _ vms = vms DCNL DCSP return compute _ node
DCSP locator = None DCNL DCSP if isinstance ( contours , int ) : DCNL DCSP DCSP from matplotlib import ticker DCNL DCSP DCSP locator = ticker.MaxNLocator ( nbins = ( contours + 1 ) ) DCNL DCSP DCSP contours = locator.tick _ values ( vmin , vmax ) DCNL DCSP return ( locator , contours )
DCSP if ( ctxt is None ) : DCNL DCSP DCSP ctxt = context.get _ admin _ context ( ) DCNL DCSP return db.instance _ type _ access _ get _ by _ flavor _ id ( ctxt , flavorid )
DCSP a = TpPd ( pd = 3 ) DCNL DCSP b = MessageType ( mesType = 26 ) DCNL DCSP c = Cause ( ) DCNL DCSP packet = ( ( a / b ) / c ) DCNL DCSP return packet
DCSP if ( not _ supports _ universal _ builds ( ) ) : DCNL DCSP DCSP _ remove _ universal _ flags ( _ config _ vars ) DCNL DCSP _ override _ all _ archs ( _ config _ vars ) DCNL DCSP _ check _ for _ unavailable _ sdk ( _ config _ vars ) DCNL DCSP return _ config _ vars
DCSP X = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , X ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 1.0 &#93; &#93; ) DCNL DCSP X = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; &#93; &#93; DCNL DCSP Y = &#91; &#91; &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , Y ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 0.0 &#93; &#93; ) DCNL DCSP X = &#91; &#91; 1 , 2 , 3 , 4 &#93; &#93; DCNL DCSP Y = &#91; &#91; 2 , 3 &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , Y ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 0.5 &#93; &#93; ) DCNL DCSP X = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; , &apos; d &apos; &#93; , &#91; &apos; e &apos; , &apos; f &apos; , &apos; g &apos; &#93; &#93; DCNL DCSP Y = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; , &apos; k &apos; &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , Y ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 0.6 &#93; , &#91; 0.0 &#93; &#93; ) DCNL DCSP X = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; , &apos; d &apos; &#93; , &#91; &apos; e &apos; , &apos; f &apos; , &apos; g &apos; &#93; &#93; DCNL DCSP Y = &#91; &#91; &apos; a &apos; , &apos; b &apos; , &apos; c &apos; , &apos; d &apos; &#93; , &#91; &apos; e &apos; , &apos; f &apos; , &apos; g &apos; &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , Y ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 1.0 , 0.0 &#93; , &#91; 0.0 , 1.0 &#93; &#93; ) DCNL DCSP X = &#91; &#91; 0 , 1 &#93; , &#91; 1 , 1 &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , X ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 1.0 , 0.33333333 &#93; , &#91; 0.33333333 , 0.33333333 &#93; &#93; ) DCNL DCSP X = &#91; &#91; 0 , 1 &#93; , &#91; 1 , 1 &#93; &#93; DCNL DCSP Y = &#91; &#91; 0 , 0 &#93; &#93; DCNL DCSP D = tanimoto _ coefficient ( X , Y ) DCNL DCSP assert _ array _ almost _ equal ( D , &#91; &#91; 0.3333333 &#93; , &#91; 0.0 &#93; &#93; )
DCSP def onerror ( func , path , exc _ info ) : DCNL DCSP DCSP os.chmod ( path , stat.S _ IWUSR ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP func ( path ) DCNL DCSP DCSP except Exception as ex : DCNL DCSP DCSP DCSP if HIDE _ WINDOWS _ KNOWN _ ERRORS : DCNL DCSP DCSP DCSP DCSP raise SkipTest ( &apos; FIXME : DCSP fails DCSP with : DCSP PermissionError \ n DCSP DCSP % s &apos; , ex ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP return shutil.rmtree ( path , False , onerror )
DCSP cc _ config = configparse.blade _ config.get _ config ( &apos; cc _ config &apos; ) DCNL DCSP benchmark _ libs = cc _ config &#91; &apos; benchmark _ libs &apos; &#93; DCNL DCSP benchmark _ main _ libs = cc _ config &#91; &apos; benchmark _ main _ libs &apos; &#93; DCNL DCSP deps = ( ( var _ to _ list ( deps ) + benchmark _ libs ) + benchmark _ main _ libs ) DCNL DCSP cc _ binary ( name = name , deps = deps , * * kwargs )
DCSP try : DCNL DCSP DCSP t = stat ( filename ) .st _ mtime DCNL DCSP except OSError : DCNL DCSP DCSP return ( filter ( ) if callable ( filter ) else &apos; &apos; ) DCNL DCSP cfs _ lock.acquire ( ) DCNL DCSP item = cfs.get ( key , None ) DCNL DCSP cfs _ lock.release ( ) DCNL DCSP if ( item and ( item &#91; 0 &#93; = = t ) ) : DCNL DCSP DCSP return item &#91; 1 &#93; DCNL DCSP if ( not callable ( filter ) ) : DCNL DCSP DCSP data = read _ file ( filename ) DCNL DCSP else : DCNL DCSP DCSP data = filter ( ) DCNL DCSP cfs _ lock.acquire ( ) DCNL DCSP cfs &#91; key &#93; = ( t , data ) DCNL DCSP cfs _ lock.release ( ) DCNL DCSP return data
DCSP try : DCNL DCSP DCSP import pygraphviz DCNL DCSP except ImportError : DCNL DCSP DCSP raise ImportError ( &apos; read _ dot ( ) DCSP requires DCSP pygraphviz DCSP &apos; , &apos; http : / / pygraphviz.github.io / &apos; ) DCNL DCSP A = pygraphviz.AGraph ( file = path ) DCNL DCSP return from _ agraph ( A )
DCSP return stats.binom.pmf ( k , n , p )
DCSP t = &#91; &#93; DCNL DCSP for k in args.keys ( ) : DCNL DCSP DCSP t.append ( ( ( str ( k ) + u &apos; = &apos; ) + urllib.quote ( str ( ( args &#91; k &#93; or u &apos; &apos; ) ) ) ) ) DCNL DCSP return sep.join ( t )
DCSP @ wraps ( func ) DCNL DCSP def wrapper ( self , * args , * * kwargs ) : DCNL DCSP DCSP if self.repo.bare : DCNL DCSP DCSP DCSP raise InvalidGitRepositoryError ( ( &quot; Method DCSP &apos; % s &apos; DCSP cannot DCSP operate DCSP on DCSP bare DCSP repositories &quot; % func . _ _ name _ _ ) ) DCNL DCSP DCSP return func ( self , * args , * * kwargs ) DCNL DCSP return wrapper
DCSP ab = ( v1 - v2 ) DCNL DCSP cb = ( v3 - v2 ) DCNL DCSP db = ( v4 - v3 ) DCNL DCSP u = ( ab * * cb ) DCNL DCSP v = ( db * * cb ) DCNL DCSP w = ( u * * v ) DCNL DCSP angle = u.angle ( v ) DCNL DCSP try : DCNL DCSP DCSP if ( cb.angle ( w ) &gt; 0.001 ) : DCNL DCSP DCSP DCSP angle = ( - angle ) DCNL DCSP except ZeroDivisionError : DCNL DCSP DCSP pass DCNL DCSP return angle
DCSP return True
DCSP if ( &apos; search &apos; in inspect.getargspec ( service.list ) &#91; 0 &#93; ) : DCNL DCSP DCSP res = service.list ( search = &apos; name = { name } &apos; .format ( name = name ) ) DCNL DCSP else : DCNL DCSP DCSP res = &#91; e for e in service.list ( ) if ( e.name = = name ) &#93; DCNL DCSP if kwargs : DCNL DCSP DCSP res = &#91; e for e in service.list ( ) if ( len ( &#91; k for ( k , v ) in kwargs.items ( ) if ( getattr ( e , k , None ) = = v ) &#93; ) = = len ( kwargs ) ) &#93; DCNL DCSP res = ( res or &#91; None &#93; ) DCNL DCSP return res &#91; 0 &#93;
DCSP if ( ( line _ number &lt; 3 ) and ( not previous _ logical ) ) : DCNL DCSP DCSP return DCNL DCSP if previous _ logical.startswith ( &apos; @ &apos; ) : DCNL DCSP DCSP if blank _ lines : DCNL DCSP DCSP DCSP ( yield ( 0 , &apos; E304 DCSP blank DCSP lines DCSP found DCSP after DCSP function DCSP decorator &apos; ) ) DCNL DCSP elif ( ( blank _ lines &gt; 2 ) or ( indent _ level and ( blank _ lines = = 2 ) ) ) : DCNL DCSP DCSP ( yield ( 0 , ( &apos; E303 DCSP too DCSP many DCSP blank DCSP lines DCSP ( % d ) &apos; % blank _ lines ) ) ) DCNL DCSP elif logical _ line.startswith ( ( &apos; def DCSP &apos; , &apos; class DCSP &apos; , &apos; @ &apos; ) ) : DCNL DCSP DCSP if indent _ level : DCNL DCSP DCSP DCSP if ( not ( blank _ lines or ( previous _ indent _ level &lt; indent _ level ) or DOCSTRING _ REGEX.match ( previous _ logical ) ) ) : DCNL DCSP DCSP DCSP DCSP ( yield ( 0 , &apos; E301 DCSP expected DCSP 1 DCSP blank DCSP line , DCSP found DCSP 0 &apos; ) ) DCNL DCSP DCSP elif ( blank _ lines ! = 2 ) : DCNL DCSP DCSP DCSP ( yield ( 0 , ( &apos; E302 DCSP expected DCSP 2 DCSP blank DCSP lines , DCSP found DCSP % d &apos; % blank _ lines ) ) )
DCSP result = None DCNL DCSP waiting = &#91; True , None &#93; DCNL DCSP while 1 : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP result = next ( g ) DCNL DCSP DCSP except StopIteration : DCNL DCSP DCSP DCSP deferred.callback ( result ) DCNL DCSP DCSP DCSP return deferred DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP deferred.errback ( ) DCNL DCSP DCSP DCSP return deferred DCNL DCSP DCSP if isinstance ( result , Deferred ) : DCNL DCSP DCSP DCSP return fail ( TypeError ( &apos; Yield DCSP waitForDeferred ( d ) , DCSP not DCSP d ! &apos; ) ) DCNL DCSP DCSP if isinstance ( result , waitForDeferred ) : DCNL DCSP DCSP DCSP def gotResult ( r , result = result ) : DCNL DCSP DCSP DCSP DCSP result.result = r DCNL DCSP DCSP DCSP DCSP if waiting &#91; 0 &#93; : DCNL DCSP DCSP DCSP DCSP DCSP waiting &#91; 0 &#93; = False DCNL DCSP DCSP DCSP DCSP DCSP waiting &#91; 1 &#93; = r DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP _ deferGenerator ( g , deferred ) DCNL DCSP DCSP DCSP result.d.addBoth ( gotResult ) DCNL DCSP DCSP DCSP if waiting &#91; 0 &#93; : DCNL DCSP DCSP DCSP DCSP waiting &#91; 0 &#93; = False DCNL DCSP DCSP DCSP DCSP return deferred DCNL DCSP DCSP DCSP waiting &#91; 0 &#93; = True DCNL DCSP DCSP DCSP waiting &#91; 1 &#93; = None DCNL DCSP DCSP DCSP result = None
DCSP @ gen.coroutine DCNL DCSP def _ QueryFollowers ( ) : DCNL DCSP DCSP &apos; Produces DCSP list DCSP of DCSP ( followers , DCSP last _ key ) DCSP tuples , DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request . &apos; DCNL DCSP DCSP tasks = &#91; &#93; DCNL DCSP DCSP for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; : DCNL DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ followers &apos; , False ) : DCNL DCSP DCSP DCSP DCSP start _ key = vp _ dict.get ( &apos; follower _ start _ key &apos; , None ) DCNL DCSP DCSP DCSP DCSP tasks.append ( Viewpoint.QueryFollowers ( client , vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; , excl _ start _ key = ( int ( start _ key ) if ( start _ key is not None ) else None ) , limit = limit ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tasks.append ( util.GenConstant ( None ) ) DCNL DCSP DCSP follower _ results = ( yield tasks ) DCNL DCSP DCSP raise gen.Return ( follower _ results ) DCNL DCSP @ gen.coroutine DCNL DCSP def _ QueryActivities ( ) : DCNL DCSP DCSP &apos; Produces DCSP list DCSP of DCSP ( activities , DCSP last _ key ) DCSP tuples , DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request . &apos; DCNL DCSP DCSP tasks = &#91; &#93; DCNL DCSP DCSP for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; : DCNL DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ activities &apos; , False ) : DCNL DCSP DCSP DCSP DCSP tasks.append ( gen.Task ( Viewpoint.QueryActivities , client , vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; , excl _ start _ key = vp _ dict.get ( &apos; activity _ start _ key &apos; , None ) , limit = limit ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tasks.append ( util.GenConstant ( None ) ) DCNL DCSP DCSP activity _ results = ( yield tasks ) DCNL DCSP DCSP raise gen.Return ( activity _ results ) DCNL DCSP @ gen.coroutine DCNL DCSP def _ QueryEpisodes ( ) : DCNL DCSP DCSP &apos; Produces DCSP list DCSP of DCSP ( episodes , DCSP last _ key ) DCSP tuples , DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request . &apos; DCNL DCSP DCSP tasks = &#91; &#93; DCNL DCSP DCSP for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; : DCNL DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ episodes &apos; , False ) : DCNL DCSP DCSP DCSP DCSP tasks.append ( gen.Task ( Viewpoint.QueryEpisodes , client , vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; , excl _ start _ key = vp _ dict.get ( &apos; episode _ start _ key &apos; , None ) , limit = limit ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tasks.append ( util.GenConstant ( None ) ) DCNL DCSP DCSP episode _ results = ( yield tasks ) DCNL DCSP DCSP raise gen.Return ( episode _ results ) DCNL DCSP @ gen.coroutine DCNL DCSP def _ QueryComments ( ) : DCNL DCSP DCSP &apos; Produces DCSP list DCSP of DCSP ( comments , DCSP last _ key ) DCSP tuples , DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP request . &apos; DCNL DCSP DCSP tasks = &#91; &#93; DCNL DCSP DCSP for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; : DCNL DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ comments &apos; , False ) : DCNL DCSP DCSP DCSP DCSP tasks.append ( gen.Task ( Viewpoint.QueryComments , client , vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; , excl _ start _ key = vp _ dict.get ( &apos; comment _ start _ key &apos; , None ) , limit = limit ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tasks.append ( util.GenConstant ( None ) ) DCNL DCSP DCSP comment _ results = ( yield tasks ) DCNL DCSP DCSP raise gen.Return ( comment _ results ) DCNL DCSP limit = request.get ( &apos; limit &apos; , None ) DCNL DCSP viewpoint _ keys = &#91; db _ client.DBKey ( vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; , None ) for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; &#93; DCNL DCSP follower _ keys = &#91; db _ client.DBKey ( user _ id , vp _ dict &#91; &apos; viewpoint _ id &apos; &#93; ) for vp _ dict in request &#91; &apos; viewpoints &apos; &#93; &#93; DCNL DCSP results = ( yield &#91; gen.Task ( Viewpoint.BatchQuery , client , viewpoint _ keys , None , must _ exist = False ) , gen.Task ( Follower.BatchQuery , client , follower _ keys , None , must _ exist = False ) , _ QueryFollowers ( ) , _ QueryActivities ( ) , _ QueryEpisodes ( ) , _ QueryComments ( ) &#93; ) DCNL DCSP ( viewpoints , followers , follower _ id _ results , activity _ results , episode _ results , comment _ results ) = results DCNL DCSP zip _ list = zip ( request &#91; &apos; viewpoints &apos; &#93; , viewpoints , followers , follower _ id _ results , activity _ results , episode _ results , comment _ results ) DCNL DCSP num _ followers = 0 DCNL DCSP num _ activities = 0 DCNL DCSP num _ episodes = 0 DCNL DCSP num _ comments = 0 DCNL DCSP response _ vp _ dicts = &#91; &#93; DCNL DCSP for ( vp _ dict , viewpoint , follower , follower _ result , activity _ result , episode _ result , comment _ result ) in zip _ list : DCNL DCSP DCSP if ( follower is not None ) : DCNL DCSP DCSP DCSP response _ vp _ dict = { &apos; viewpoint _ id &apos; : viewpoint.viewpoint _ id } DCNL DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ attributes &apos; , False ) : DCNL DCSP DCSP DCSP DCSP response _ vp _ dict.update ( _ MakeViewpointMetadataDict ( viewpoint , follower , obj _ store ) ) DCNL DCSP DCSP DCSP if ( ( not follower.IsRemoved ( ) ) and vp _ dict.get ( &apos; get _ followers &apos; , False ) ) : DCNL DCSP DCSP DCSP DCSP ( followers , last _ key ) = follower _ result DCNL DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; followers &apos; &#93; = &#91; foll.MakeFriendMetadataDict ( ) for foll in followers &#93; DCNL DCSP DCSP DCSP DCSP if ( last _ key is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; follower _ last _ key &apos; &#93; = www _ util.FormatIntegralLastKey ( last _ key ) DCNL DCSP DCSP DCSP DCSP num _ followers + = len ( followers ) DCNL DCSP DCSP DCSP if _ CanViewViewpointContent ( viewpoint , follower ) : DCNL DCSP DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ activities &apos; , False ) : DCNL DCSP DCSP DCSP DCSP DCSP ( activities , last _ key ) = activity _ result DCNL DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; activities &apos; &#93; = &#91; act.MakeMetadataDict ( ) for act in activities &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( last _ key is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; activity _ last _ key &apos; &#93; = last _ key DCNL DCSP DCSP DCSP DCSP DCSP num _ activities + = len ( activities ) DCNL DCSP DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ episodes &apos; , False ) : DCNL DCSP DCSP DCSP DCSP DCSP ( episodes , last _ key ) = episode _ result DCNL DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; episodes &apos; &#93; = &#91; ep . _ asdict ( ) for ep in episodes &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( last _ key is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; episode _ last _ key &apos; &#93; = last _ key DCNL DCSP DCSP DCSP DCSP DCSP num _ episodes + = len ( episodes ) DCNL DCSP DCSP DCSP DCSP if vp _ dict.get ( &apos; get _ comments &apos; , False ) : DCNL DCSP DCSP DCSP DCSP DCSP ( comments , last _ key ) = comment _ result DCNL DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; comments &apos; &#93; = &#91; co . _ asdict ( ) for co in comments &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( last _ key is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP response _ vp _ dict &#91; &apos; comment _ last _ key &apos; &#93; = last _ key DCNL DCSP DCSP DCSP DCSP DCSP num _ comments + = len ( comments ) DCNL DCSP DCSP DCSP response _ vp _ dicts.append ( response _ vp _ dict ) DCNL DCSP logging.info ( ( &apos; QUERY DCSP VIEWPOINTS : DCSP user : DCSP % d , DCSP device : DCSP % d , DCSP % d DCSP viewpoints , DCSP % d DCSP followers , DCSP % d DCSP activities , DCSP % d DCSP episodes , DCSP % d DCSP comments &apos; % ( user _ id , device _ id , len ( response _ vp _ dicts ) , num _ followers , num _ activities , num _ episodes , num _ comments ) ) ) DCNL DCSP raise gen.Return ( { &apos; viewpoints &apos; : response _ vp _ dicts } )
DCSP if isinstance ( services , dict ) : DCNL DCSP DCSP services = services.iteritems ( ) DCNL DCSP mapping = &#91; &#93; DCNL DCSP registry _ map = { } DCNL DCSP if ( registry _ path is not None ) : DCNL DCSP DCSP registry _ service = registry.RegistryService.new _ factory ( registry _ map ) DCNL DCSP DCSP services = ( list ( services ) + &#91; ( registry _ path , registry _ service ) &#93; ) DCNL DCSP DCSP mapping.append ( ( ( registry _ path + &apos; / form ( ? : / ) ? &apos; ) , forms.FormsHandler.new _ factory ( registry _ path ) ) ) DCNL DCSP DCSP mapping.append ( ( ( registry _ path + &apos; / form / ( . + ) &apos; ) , forms.ResourceHandler ) ) DCNL DCSP paths = set ( ) DCNL DCSP for service _ item in services : DCNL DCSP DCSP infer _ path = ( not isinstance ( service _ item , ( list , tuple ) ) ) DCNL DCSP DCSP if infer _ path : DCNL DCSP DCSP DCSP service = service _ item DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP service = service _ item &#91; 1 &#93; DCNL DCSP DCSP service _ class = getattr ( service , &apos; service _ class &apos; , service ) DCNL DCSP DCSP if infer _ path : DCNL DCSP DCSP DCSP path = ( &apos; / &apos; + service _ class.definition _ name ( ) .replace ( &apos; .&apos; , &apos; / &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP path = service _ item &#91; 0 &#93; DCNL DCSP DCSP if ( path in paths ) : DCNL DCSP DCSP DCSP raise ServiceConfigurationError ( ( &apos; Path DCSP % r DCSP is DCSP already DCSP defined DCSP in DCSP service DCSP mapping &apos; % path.encode ( &apos; utf-8 &apos; ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP paths.add ( path ) DCNL DCSP DCSP new _ mapping = ServiceHandlerFactory.default ( service ) .mapping ( path ) DCNL DCSP DCSP mapping.append ( new _ mapping ) DCNL DCSP DCSP registry _ map &#91; path &#93; = service _ class DCNL DCSP return mapping
DCSP member = getattr ( user , member ) DCNL DCSP names = &#91; members.name for members in member.all ( ) &#93; DCNL DCSP return &apos; , &apos; .join ( names )
DCSP return ( &apos; { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP % ( failure _ var ) s DCSP = DCSP % ( id ) s ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP if DCSP ( ! PyErr _ Occurred ( ) ) DCSP { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP PyErr _ SetString ( PyExc _ RuntimeError , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; Unexpected DCSP error DCSP in DCSP an DCSP Op \ &apos; s DCSP C DCSP code . DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; No DCSP Python DCSP exception DCSP was DCSP set . &quot; ) ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP goto DCSP _ _ label _ % ( id ) i ; } &apos; % sub )
DCSP change = { } DCNL DCSP if ( new _ revno is None ) : DCNL DCSP DCSP new _ revno = branch.revno ( ) DCNL DCSP if ( new _ revid is None ) : DCNL DCSP DCSP new _ revid = branch.get _ rev _ id ( new _ revno ) DCNL DCSP if ( old _ revno is None ) : DCNL DCSP DCSP old _ revno = ( new _ revno - 1 ) DCNL DCSP if ( old _ revid is None ) : DCNL DCSP DCSP old _ revid = branch.get _ rev _ id ( old _ revno ) DCNL DCSP repository = branch.repository DCNL DCSP new _ rev = repository.get _ revision ( new _ revid ) DCNL DCSP if blame _ merge _ author : DCNL DCSP DCSP change &#91; &apos; who &apos; &#93; = repository.get _ revision ( new _ rev.parent _ ids &#91; ( -1 ) &#93; ) .get _ apparent _ authors ( ) &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP change &#91; &apos; who &apos; &#93; = new _ rev.get _ apparent _ authors ( ) &#91; 0 &#93; DCNL DCSP change &#91; &apos; comments &apos; &#93; = new _ rev.message DCNL DCSP change &#91; &apos; revision &apos; &#93; = new _ revno DCNL DCSP files = change &#91; &apos; files &apos; &#93; = &#91; &#93; DCNL DCSP changes = repository.revision _ tree ( new _ revid ) .changes _ from ( repository.revision _ tree ( old _ revid ) ) DCNL DCSP for ( collection , name ) in ( ( changes.added , &apos; ADDED &apos; ) , ( changes.removed , &apos; REMOVED &apos; ) , ( changes.modified , &apos; MODIFIED &apos; ) ) : DCNL DCSP DCSP for info in collection : DCNL DCSP DCSP DCSP path = info &#91; 0 &#93; DCNL DCSP DCSP DCSP kind = info &#91; 2 &#93; DCNL DCSP DCSP DCSP files.append ( &apos; DCSP &apos; .join ( &#91; path , kind , name &#93; ) ) DCNL DCSP for info in changes.renamed : DCNL DCSP DCSP ( oldpath , newpath , id , kind , text _ modified , meta _ modified ) = info DCNL DCSP DCSP elements = &#91; oldpath , kind , &apos; RENAMED &apos; , newpath &#93; DCNL DCSP DCSP if ( text _ modified or meta _ modified ) : DCNL DCSP DCSP DCSP elements.append ( &apos; MODIFIED &apos; ) DCNL DCSP DCSP files.append ( &apos; DCSP &apos; .join ( elements ) ) DCNL DCSP return change
DCSP eta = Symbol ( &apos; eta &apos; ) DCNL DCSP if ( len ( syms ) = = 1 ) : DCNL DCSP DCSP sym = syms.pop ( ) DCNL DCSP DCSP final = sol.subs ( sym , func ( funcarg ) ) DCNL DCSP else : DCNL DCSP DCSP fname = func . _ _ name _ _ DCNL DCSP DCSP for ( key , sym ) in enumerate ( syms ) : DCNL DCSP DCSP DCSP tempfun = Function ( ( fname + str ( key ) ) ) DCNL DCSP DCSP DCSP final = sol.subs ( sym , func ( funcarg ) ) DCNL DCSP return simplify ( final.subs ( eta , funcarg ) )
DCSP e _ message = u &apos; &apos; DCNL DCSP if ( ( not e ) or ( not e.args ) ) : DCNL DCSP DCSP return e _ message DCNL DCSP for arg in e.args : DCNL DCSP DCSP if ( arg is not None ) : DCNL DCSP DCSP DCSP if isinstance ( arg , ( str , unicode ) ) : DCNL DCSP DCSP DCSP DCSP fixed _ arg = fixStupidEncodings ( arg , True ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP fixed _ arg = ( u &apos;error DCSP &apos; + fixStupidEncodings ( str ( arg ) , True ) ) DCNL DCSP DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP DCSP fixed _ arg = None DCNL DCSP DCSP DCSP if fixed _ arg : DCNL DCSP DCSP DCSP DCSP if ( not e _ message ) : DCNL DCSP DCSP DCSP DCSP DCSP e _ message = fixed _ arg DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP e _ message = ( ( e _ message + &apos; DCSP : DCSP &apos; ) + fixed _ arg ) DCNL DCSP return e _ message
DCSP return _ CompiledGrammar ( root _ node , * a , * * kw )
DCSP if ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; Debian &apos; ) : DCNL DCSP DCSP return _ osquery _ cmd ( table = &apos; deb _ packages &apos; , attrs = attrs , where = where ) DCNL DCSP return { &apos; result &apos; : False , &apos; comment &apos; : &apos; Only DCSP available DCSP on DCSP Debian DCSP based DCSP systems . &apos; }
DCSP if ( vm _ state ( vm _ ) &#91; vm _ &#93; ! = &apos; shutdown &apos; ) : DCNL DCSP DCSP return False DCNL DCSP dom = _ get _ domain ( vm _ ) DCNL DCSP flags = libvirt.VIR _ DOMAIN _ VCPU _ MAXIMUM DCNL DCSP if config : DCNL DCSP DCSP flags = ( flags &#124; libvirt.VIR _ DOMAIN _ AFFECT _ CONFIG ) DCNL DCSP ret1 = dom.setVcpusFlags ( vcpus , flags ) DCNL DCSP ret2 = dom.setVcpusFlags ( vcpus , libvirt.VIR _ DOMAIN _ AFFECT _ CURRENT ) DCNL DCSP return ( ret1 = = ret2 = = 0 )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; , &apos; result &apos; : True } DCNL DCSP if ( fun is None ) : DCNL DCSP DCSP fun = name DCNL DCSP client = salt.runner.RunnerClient ( _ _ opts _ _ ) DCNL DCSP low = { &apos; fun &apos; : fun , &apos; arg &apos; : arg , &apos; kwargs &apos; : kwargs } DCNL DCSP client.cmd _ async ( low ) DCNL DCSP return ret
DCSP if ( word in custom ) : DCNL DCSP DCSP return custom &#91; word &#93; DCNL DCSP if word.endswith ( ( &quot; &apos; &quot; , &quot; &apos; s &quot; ) ) : DCNL DCSP DCSP w = word.rstrip ( &quot; &apos; s &quot; ) DCNL DCSP DCSP w = pluralize ( w , pos , custom , classical ) DCNL DCSP DCSP if w.endswith ( &apos; s &apos; ) : DCNL DCSP DCSP DCSP return ( w + &quot; &apos; &quot; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( w + &quot; &apos; s &quot; ) DCNL DCSP w = word.replace ( &apos; -&apos; , &apos; DCSP &apos; ) .split ( &apos; DCSP &apos; ) DCNL DCSP if ( len ( w ) &gt; 1 ) : DCNL DCSP DCSP if ( ( w &#91; 1 &#93; = = &apos; general &apos; ) or ( ( w &#91; 1 &#93; = = &apos; General &apos; ) and ( w &#91; 0 &#93; not in plural _ categories &#91; &apos; general-generals &apos; &#93; ) ) ) : DCNL DCSP DCSP DCSP return word.replace ( w &#91; 0 &#93; , pluralize ( w &#91; 0 &#93; , pos , custom , classical ) ) DCNL DCSP DCSP elif ( w &#91; 1 &#93; in plural _ prepositions ) : DCNL DCSP DCSP DCSP return word.replace ( w &#91; 0 &#93; , pluralize ( w &#91; 0 &#93; , pos , custom , classical ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return word.replace ( w &#91; ( -1 ) &#93; , pluralize ( w &#91; ( -1 ) &#93; , pos , custom , classical ) ) DCNL DCSP n = range ( len ( plural _ rules ) ) DCNL DCSP if pos.startswith ( ADJECTIVE ) : DCNL DCSP DCSP n = &#91; 0 , 1 &#93; DCNL DCSP for i in n : DCNL DCSP DCSP for ( suffix , inflection , category , classic ) in plural _ rules &#91; i &#93; : DCNL DCSP DCSP DCSP if ( category is None ) : DCNL DCSP DCSP DCSP DCSP if ( ( not classic ) or ( classic and classical ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( suffix.search ( word ) is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return suffix.sub ( inflection , word ) DCNL DCSP DCSP DCSP if ( category is not None ) : DCNL DCSP DCSP DCSP DCSP if ( ( word in plural _ categories &#91; category &#93; ) and ( ( not classic ) or ( classic and classical ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( suffix.search ( word ) is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return suffix.sub ( inflection , word ) DCNL DCSP return word
DCSP if ( ( obj . _ _ doc _ _ is None ) or obj . _ _ doc _ _ .isspace ( ) ) : DCNL DCSP DCSP return None DCNL DCSP lines = &#91; x.strip ( ) for x in obj . _ _ doc _ _ .split ( &apos; \ n &apos; ) if ( x and ( not x.isspace ( ) ) ) &#93; DCNL DCSP return &apos; DCSP &apos; .join ( lines )
DCSP if ( &apos; = &apos; in entry ) : DCNL DCSP DCSP ( fingerprint , nickname ) = entry.split ( &apos; = &apos; ) DCNL DCSP elif ( &apos; ~ &apos; in entry ) : DCNL DCSP DCSP ( fingerprint , nickname ) = entry.split ( &apos; ~ &apos; ) DCNL DCSP elif ( entry &#91; 0 &#93; = = &apos; $ &apos; ) : DCNL DCSP DCSP ( fingerprint , nickname ) = ( entry , None ) DCNL DCSP else : DCNL DCSP DCSP ( fingerprint , nickname ) = ( None , entry ) DCNL DCSP if ( fingerprint is not None ) : DCNL DCSP DCSP if ( not stem.util.tor _ tools.is _ valid _ fingerprint ( fingerprint , True ) ) : DCNL DCSP DCSP DCSP raise stem.ProtocolError ( ( &apos; Fingerprint DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformed DCSP ( % s ) &apos; % fingerprint ) ) DCNL DCSP DCSP fingerprint = fingerprint &#91; 1 : &#93; DCNL DCSP if ( ( nickname is not None ) and ( not stem.util.tor _ tools.is _ valid _ nickname ( nickname ) ) ) : DCNL DCSP DCSP raise stem.ProtocolError ( ( &apos; Nickname DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformed DCSP ( % s ) &apos; % nickname ) ) DCNL DCSP return ( fingerprint , nickname )
DCSP adapters = _ parse _ interfaces ( ) DCNL DCSP if ( iface in adapters ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( iface = = &apos; source &apos; ) : DCNL DCSP DCSP DCSP DCSP template = JINJA.get _ template ( &apos; debian _ source.jinja &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP template = JINJA.get _ template ( &apos; debian _ eth.jinja &apos; ) DCNL DCSP DCSP except jinja2.exceptions.TemplateNotFound : DCNL DCSP DCSP DCSP log.error ( &apos; Could DCSP not DCSP load DCSP template DCSP debian _ eth.jinja &apos; ) DCNL DCSP DCSP DCSP return &apos; &apos; DCNL DCSP DCSP ifcfg = template.render ( { &apos; name &apos; : iface , &apos; data &apos; : adapters &#91; iface &#93; } ) DCNL DCSP DCSP return &#91; ( item + &apos; \ n &apos; ) for item in ifcfg.split ( &apos; \ n &apos; ) &#93; DCNL DCSP else : DCNL DCSP DCSP return &#91; &#93;
DCSP mlp = MLP ( layers = &#91; Linear ( layer _ name = &apos; h &apos; , dim = 5 , irange = 0.01 , max _ col _ norm = 0.01 ) &#93; ) DCNL DCSP conditional = DiagonalGaussian ( mlp = mlp , name = &apos; conditional &apos; ) DCNL DCSP vae = DummyVAE ( ) DCNL DCSP conditional.set _ vae ( vae ) DCNL DCSP input _ space = VectorSpace ( dim = 5 ) DCNL DCSP conditional.initialize _ parameters ( input _ space = input _ space , ndim = 5 ) DCNL DCSP mu = T.matrix ( &apos; mu &apos; ) DCNL DCSP log _ sigma = T.matrix ( &apos; log _ sigma &apos; ) DCNL DCSP conditional.conditional _ expectation ( &#91; mu , log _ sigma &#93; )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ media _ set _ user _ data &apos; , None ) or _ Cfunction ( &apos; libvlc _ media _ set _ user _ data &apos; , ( ( 1 , ) , ( 1 , ) ) , None , None , Media , ctypes.c _ void _ p ) ) DCNL DCSP return f ( p _ md , p _ new _ user _ data )
DCSP allmodnames = loaded _ vispy _ modules ( &apos; vispy.gloo.gl.pyopengl2 &apos; , 2 , True ) DCNL DCSP assert _ in ( &apos; OpenGL &apos; , allmodnames )
DCSP if ( truth _ count = = 0 ) : DCNL DCSP DCSP truth _ count = 1 DCNL DCSP DCSP error _ count = 1 DCNL DCSP elif ( error _ count &gt; truth _ count ) : DCNL DCSP DCSP error _ count = truth _ count DCNL DCSP return ( ( error _ count * 100.0 ) / truth _ count )
DCSP if ( not hasattr ( _ to _ save , &apos; translations &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP for trans in _ to _ save.translations.get ( key , &#91; &#93; ) : DCNL DCSP DCSP is _ new = ( trans.autoid is None ) DCNL DCSP DCSP trans.save ( force _ insert = is _ new , force _ update = ( not is _ new ) ) DCNL DCSP if ( key in _ to _ save.translations ) : DCNL DCSP DCSP del _ to _ save.translations &#91; key &#93;
DCSP vars = { } DCNL DCSP lines = code.split ( &apos; \ n &apos; ) DCNL DCSP for line in lines : DCNL DCSP DCSP m = re.match ( ( ( &apos; \ \ s * &apos; + re _ prog _ var _ declaration ) + &apos; \ \ s * ( = &#124; ; ) &apos; ) , line ) DCNL DCSP DCSP if ( m is not None ) : DCNL DCSP DCSP DCSP ( vtype , dtype , names ) = m.groups ( ) &#91; : 3 &#93; DCNL DCSP DCSP DCSP for name in names.split ( &apos; , &apos; ) : DCNL DCSP DCSP DCSP DCSP vars &#91; name.strip ( ) &#93; = ( vtype , dtype ) DCNL DCSP return vars
DCSP for comp in _ biconnected _ dfs ( G , components = True ) : DCNL DCSP DCSP ( yield comp )
DCSP method = str ( method ) .lower ( ) DCNL DCSP if ( method not in &#91; &apos; unbiased &apos; , &apos; mle &apos; &#93; ) : DCNL DCSP DCSP raise ValueError ( &quot; ACF DCSP estimation DCSP method DCSP must DCSP be DCSP &apos; unbiased &apos; DCSP or DCSP &apos; MLE &apos; &quot; ) DCNL DCSP X = np.array ( X , dtype = np.float64 ) DCNL DCSP if demean : DCNL DCSP DCSP X - = X.mean ( ) DCNL DCSP n = ( df or X.shape &#91; 0 &#93; ) DCNL DCSP if ( method = = &apos; unbiased &apos; ) : DCNL DCSP DCSP denom = ( lambda k : ( n - k ) ) DCNL DCSP else : DCNL DCSP DCSP denom = ( lambda k : n ) DCNL DCSP if ( ( X.ndim &gt; 1 ) and ( X.shape &#91; 1 &#93; ! = 1 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; expecting DCSP a DCSP vector DCSP to DCSP estimate DCSP AR DCSP parameters &apos; ) DCNL DCSP r = np.zeros ( ( order + 1 ) , np.float64 ) DCNL DCSP r &#91; 0 &#93; = ( ( X * * 2 ) .sum ( ) / denom ( 0 ) ) DCNL DCSP for k in range ( 1 , ( order + 1 ) ) : DCNL DCSP DCSP r &#91; k &#93; = ( ( X &#91; 0 : ( - k ) &#93; * X &#91; k : &#93; ) .sum ( ) / denom ( k ) ) DCNL DCSP R = toeplitz ( r &#91; : ( -1 ) &#93; ) DCNL DCSP rho = np.linalg.solve ( R , r &#91; 1 : &#93; ) DCNL DCSP sigmasq = ( r &#91; 0 &#93; - ( r &#91; 1 : &#93; * rho ) .sum ( ) ) DCNL DCSP if ( inv = = True ) : DCNL DCSP DCSP return ( rho , np.sqrt ( sigmasq ) , np.linalg.inv ( R ) ) DCNL DCSP else : DCNL DCSP DCSP return ( rho , np.sqrt ( sigmasq ) )
DCSP if ( myfilename and ipython _ version ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ipython _ version.startswith ( &apos; 0.10 &apos; ) : DCNL DCSP DCSP DCSP DCSP _ _ IPYTHON _ _ .set _ custom _ exc ( ( Exception , ) , ipython _ exception _ handler ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ip = get _ ipython ( ) DCNL DCSP DCSP DCSP DCSP ip.set _ custom _ exc ( ( Exception , ) , ipython _ exception _ handler ) DCNL DCSP DCSP except NameError : DCNL DCSP DCSP DCSP sys.exc _ clear ( ) DCNL DCSP level = read _ logging _ level ( log _ level ) DCNL DCSP if ( level and myfilename ) : DCNL DCSP DCSP fileHandler = logging.FileHandler ( filename = myfilename ) DCNL DCSP DCSP fileHandler.setLevel ( level ) DCNL DCSP DCSP fileHandler.setFormatter ( formatter ) DCNL DCSP DCSP logger.addHandler ( fileHandler ) DCNL DCSP DCSP logger.removeHandler ( consoleHandler ) DCNL DCSP DCSP print &apos; Now DCSP logging DCSP to &apos; , myfilename , &apos; with DCSP level &apos; , log _ level DCNL DCSP elif level : DCNL DCSP DCSP print &apos; Now DCSP logging DCSP with DCSP level &apos; , log _ level DCNL DCSP logger.setLevel ( level )
DCSP def wrap _ errcheck ( result , func , arguments ) : DCNL DCSP DCSP if ( result is None ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP return classname ( result ) DCNL DCSP return wrap _ errcheck
DCSP if ( ( not path ) and ( not text ) ) : DCNL DCSP DCSP raise salt.exceptions.SaltInvocationError ( &apos; Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specified . &apos; ) DCNL DCSP if ( path and text ) : DCNL DCSP DCSP raise salt.exceptions.SaltInvocationError ( &apos; Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specified , DCSP not DCSP both . &apos; ) DCNL DCSP if verbose : DCNL DCSP DCSP _ callback _ func = M2Crypto.RSA.keygen _ callback DCNL DCSP else : DCNL DCSP DCSP _ callback _ func = _ keygen _ callback DCNL DCSP rsa = M2Crypto.RSA.gen _ key ( bits , M2Crypto.m2.RSA _ F4 , _ callback _ func ) DCNL DCSP bio = M2Crypto.BIO.MemoryBuffer ( ) DCNL DCSP if ( passphrase is None ) : DCNL DCSP DCSP cipher = None DCNL DCSP rsa.save _ key _ bio ( bio , cipher = cipher , callback = _ passphrase _ callback ( passphrase ) ) DCNL DCSP if path : DCNL DCSP DCSP return write _ pem ( text = bio.read _ all ( ) , path = path , pem _ type = &apos; RSA DCSP PRIVATE DCSP KEY &apos; ) DCNL DCSP else : DCNL DCSP DCSP return bio.read _ all ( )
DCSP if kwargs : DCNL DCSP DCSP args = ( args + ( kwargs , ) ) DCNL DCSP return md5 ( str ( tuple ( map ( normalize _ token , args ) ) ) .encode ( ) ) .hexdigest ( )
DCSP return IMPL.compute _ node _ get ( context , compute _ id )
DCSP uri = URI.fromBytes ( url ) DCNL DCSP factory = factoryFactory ( url , * args , * * kwargs ) DCNL DCSP if ( uri.scheme = = &apos; https &apos; ) : DCNL DCSP DCSP from twisted.internet import ssl DCNL DCSP DCSP if ( contextFactory is None ) : DCNL DCSP DCSP DCSP contextFactory = ssl.ClientContextFactory ( ) DCNL DCSP DCSP reactor.connectSSL ( nativeString ( uri.host ) , uri.port , factory , contextFactory ) DCNL DCSP else : DCNL DCSP DCSP reactor.connectTCP ( nativeString ( uri.host ) , uri.port , factory ) DCNL DCSP return factory
DCSP return import _ site _ symbol ( path , module , funcname , dummy , modulefile )
DCSP if ( _ _ grains _ _ &#91; &apos; kernel &apos; &#93; = = &apos; Linux &apos; ) : DCNL DCSP DCSP cmd = &apos; ip DCSP route DCSP get DCSP { 0 } &apos; .format ( ip ) DCNL DCSP DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = True ) DCNL DCSP DCSP regexp = re.compile ( &apos; ( via \ \ s + ( ? P &lt; gateway &gt; &#91; \ \ w \ \ . : &#93; + ) ) ? \ \ s + dev \ \ s + ( ? P &lt; interface &gt; &#91; \ \ w \ \ . \ \ : &#93; + ) \ \ s + . * src \ \ s + ( ? P &lt; source &gt; &#91; \ \ w \ \ . : &#93; + ) &apos; ) DCNL DCSP DCSP m = regexp.search ( out.splitlines ( ) &#91; 0 &#93; ) DCNL DCSP DCSP ret = { &apos; destination &apos; : ip , &apos; gateway &apos; : m.group ( &apos; gateway &apos; ) , &apos; interface &apos; : m.group ( &apos; interface &apos; ) , &apos; source &apos; : m.group ( &apos; source &apos; ) } DCNL DCSP DCSP return ret DCNL DCSP if ( _ _ grains _ _ &#91; &apos; kernel &apos; &#93; = = &apos; SunOS &apos; ) : DCNL DCSP DCSP cmd = &apos; / usr / sbin / route DCSP -n DCSP get DCSP { 0 } &apos; .format ( ip ) DCNL DCSP DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP DCSP ret = { &apos; destination &apos; : ip , &apos; gateway &apos; : None , &apos; interface &apos; : None , &apos; source &apos; : None } DCNL DCSP DCSP for line in out.splitlines ( ) : DCNL DCSP DCSP DCSP line = line.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP if ( &apos; route DCSP to &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; destination &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( &apos; gateway &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; gateway &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( &apos; interface &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; interface &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; source &apos; &#93; = salt.utils.network.interface _ ip ( line &#91; 1 &#93; .strip ( ) ) DCNL DCSP DCSP return ret DCNL DCSP if ( _ _ grains _ _ &#91; &apos; kernel &apos; &#93; = = &apos; OpenBSD &apos; ) : DCNL DCSP DCSP cmd = &apos; route DCSP -n DCSP get DCSP { 0 } &apos; .format ( ip ) DCNL DCSP DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP DCSP ret = { &apos; destination &apos; : ip , &apos; gateway &apos; : None , &apos; interface &apos; : None , &apos; source &apos; : None } DCNL DCSP DCSP for line in out.splitlines ( ) : DCNL DCSP DCSP DCSP line = line.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP if ( &apos; route DCSP to &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; destination &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( &apos; gateway &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; gateway &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( &apos; interface &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; interface &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( &apos; if DCSP address &apos; in line &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; source &apos; &#93; = line &#91; 1 &#93; .strip ( ) DCNL DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Not DCSP yet DCSP supported DCSP on DCSP this DCSP platform &apos; )
DCSP ( prefix , suffix , dir , output _ type ) = _ sanitize _ params ( prefix , suffix , dir ) DCNL DCSP if text : DCNL DCSP DCSP flags = _ text _ openflags DCNL DCSP else : DCNL DCSP DCSP flags = _ bin _ openflags DCNL DCSP return _ mkstemp _ inner ( dir , prefix , suffix , flags , output _ type )
DCSP counter = _ RateCounter ( name , description , unit _ seconds ) DCNL DCSP manager.register ( counter ) DCNL DCSP return counter
DCSP current _ site = Site.objects.get _ current ( ) DCNL DCSP siteconfig = SiteConfiguration.objects.get _ current ( ) DCNL DCSP domain _ method = siteconfig.get ( u &apos;site _ domain _ method &apos; ) DCNL DCSP subject = ( u &apos;New DCSP Review DCSP Board DCSP user DCSP registration DCSP for DCSP % s &apos; % user.username ) DCNL DCSP from _ email = build _ email _ address _ for _ user ( user ) DCNL DCSP context = { u &apos;domain &apos; : current _ site.domain , u &apos;domain _ method &apos; : domain _ method , u &apos;user &apos; : user , u &apos;user _ url &apos; : reverse ( u &apos;admin : auth _ user _ change &apos; , args = ( user.id , ) ) } DCNL DCSP text _ message = render _ to _ string ( u &apos;notifications / new _ user _ email.txt &apos; , context ) DCNL DCSP html _ message = render _ to _ string ( u &apos;notifications / new _ user _ email.html &apos; , context ) DCNL DCSP message = EmailMessage ( subject = subject.strip ( ) , text _ body = text _ message , html _ body = html _ message , from _ email = settings.SERVER _ EMAIL , sender = settings.SERVER _ EMAIL , to = &#91; build _ email _ address ( full _ name = admin &#91; 0 &#93; , email = admin &#91; 1 &#93; ) for admin in settings.ADMINS &#93; ) DCNL DCSP try : DCNL DCSP DCSP message.send ( ) DCNL DCSP except Exception as e : DCNL DCSP DCSP logging.error ( u &quot; Error DCSP sending DCSP e-mail DCSP notification DCSP with DCSP subject DCSP &apos; % s &apos; DCSP on DCSP behalf DCSP of DCSP &apos; % s &apos; DCSP to DCSP admin : DCSP % s &quot; , subject.strip ( ) , from _ email , e , exc _ info = 1 )
DCSP siteconfig = SiteConfiguration.objects.get _ current ( ) DCNL DCSP if siteconfig.get ( u &apos;mail _ send _ review _ close _ mail &apos; ) : DCNL DCSP DCSP mail _ review _ request ( review _ request , user , close _ type = type )
DCSP from ansible.playbook.role.include import RoleInclude DCNL DCSP assert isinstance ( ds , list ) DCNL DCSP roles = &#91; &#93; DCNL DCSP for role _ def in ds : DCNL DCSP DCSP i = RoleInclude.load ( role _ def , play = play , current _ role _ path = current _ role _ path , variable _ manager = variable _ manager , loader = loader ) DCNL DCSP DCSP roles.append ( i ) DCNL DCSP return roles
DCSP skip _ if _ no _ scipy ( ) DCNL DCSP rng = np.random.RandomState ( &#91; 1 , 2 , 3 &#93; ) DCNL DCSP seed = ( rng.randint ( 2147462579 ) - 1 ) DCNL DCSP dim = 3 DCNL DCSP mu = rng.randn ( dim ) DCNL DCSP rank = dim DCNL DCSP X = rng.randn ( rank , dim ) DCNL DCSP cov = np.dot ( X.T , X ) DCNL DCSP mnd1 = MND ( sigma = cov , mu = mu , seed = seed ) DCNL DCSP num _ samples = 5 DCNL DCSP rd1 = mnd1.random _ design _ matrix ( num _ samples ) DCNL DCSP rd1 = function ( &#91; &#93; , rd1 ) ( ) DCNL DCSP mnd2 = MND ( sigma = cov , mu = mu , seed = ( seed + 1 ) ) DCNL DCSP rd2 = mnd2.random _ design _ matrix ( num _ samples ) DCNL DCSP rd2 = function ( &#91; &#93; , rd2 ) ( ) DCNL DCSP assert np.any ( ( rd1 ! = rd2 ) )
DCSP site _ gwt = os.path.join ( _ AUTOTEST _ DIR , &apos; site-packages &apos; , &apos; gwt &apos; ) DCNL DCSP if os.path.isdir ( site _ gwt ) : DCNL DCSP DCSP return site _ gwt DCNL DCSP if ( not os.path.isdir ( _ DEFAULT _ GWT _ DIR ) ) : DCNL DCSP DCSP logging.error ( &apos; Unable DCSP to DCSP find DCSP GWT . DCSP You DCSP can DCSP use DCSP utils / build _ externals.py DCSP to DCSP install DCSP it . &apos; ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP return _ DEFAULT _ GWT _ DIR
DCSP write _ sff _ header ( header , out _ fh ) DCNL DCSP l = 0 DCNL DCSP for f in flowgrams : DCNL DCSP DCSP passed = True DCNL DCSP DCSP for filter in filter _ list : DCNL DCSP DCSP DCSP passed = ( passed and filter ( f ) ) DCNL DCSP DCSP DCSP if ( not passed ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if passed : DCNL DCSP DCSP DCSP out _ fh.write ( ( f.createFlowHeader ( ) + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP l + = 1 DCNL DCSP return l
DCSP _ id = _ cache _ id ( name , sub _ resource = resource , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if _ id : DCNL DCSP DCSP return _ id DCNL DCSP r = _ get _ resource ( resource , name = name , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if r : DCNL DCSP DCSP return r.id
DCSP if isinstance ( policy , ( list , tuple ) ) : DCNL DCSP DCSP ret = &apos; &apos; DCNL DCSP DCSP for sub _ policy in policy : DCNL DCSP DCSP DCSP ret + = sub _ policy ( r , name , sub ) DCNL DCSP DCSP return ret DCNL DCSP return policy ( r , name , sub )
DCSP if ( alphabet is None ) : DCNL DCSP DCSP alphabet = single _ letter _ alphabet DCNL DCSP state _ PREAMBLE = ( -1 ) DCNL DCSP state _ NONE = 0 DCNL DCSP state _ QUERY _ HEADER = 1 DCNL DCSP state _ ALIGN _ HEADER = 2 DCNL DCSP state _ ALIGN _ QUERY = 3 DCNL DCSP state _ ALIGN _ MATCH = 4 DCNL DCSP state _ ALIGN _ CONS = 5 DCNL DCSP def build _ hsp ( ) : DCNL DCSP DCSP if ( ( not query _ tags ) and ( not match _ tags ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; No DCSP data DCSP for DCSP query DCSP % r , DCSP match DCSP % r &apos; % ( query _ id , match _ id ) ) ) DCNL DCSP DCSP assert query _ tags , query _ tags DCNL DCSP DCSP assert match _ tags , match _ tags DCNL DCSP DCSP evalue = align _ tags.get ( &apos; fa _ expect &apos; ) DCNL DCSP DCSP q = &apos; ? &apos; DCNL DCSP DCSP m = &apos; ? &apos; DCNL DCSP DCSP tool = global _ tags.get ( &apos; tool &apos; , &apos; &apos; ) .upper ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP q = _ extract _ alignment _ region ( query _ seq , query _ tags ) DCNL DCSP DCSP DCSP if ( ( tool in &#91; &apos; TFASTX &apos; &#93; ) and ( len ( match _ seq ) = = len ( q ) ) ) : DCNL DCSP DCSP DCSP DCSP m = match _ seq DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP m = _ extract _ alignment _ region ( match _ seq , match _ tags ) DCNL DCSP DCSP DCSP assert ( len ( q ) = = len ( m ) ) DCNL DCSP DCSP except AssertionError as err : DCNL DCSP DCSP DCSP print ( &apos; Darn ... DCSP amino DCSP acids DCSP vs DCSP nucleotide DCSP coordinates ? &apos; ) DCNL DCSP DCSP DCSP print ( tool ) DCNL DCSP DCSP DCSP print ( query _ seq ) DCNL DCSP DCSP DCSP print ( query _ tags ) DCNL DCSP DCSP DCSP print ( ( &apos; % s DCSP % i &apos; % ( q , len ( q ) ) ) ) DCNL DCSP DCSP DCSP print ( match _ seq ) DCNL DCSP DCSP DCSP print ( match _ tags ) DCNL DCSP DCSP DCSP print ( ( &apos; % s DCSP % i &apos; % ( m , len ( m ) ) ) ) DCNL DCSP DCSP DCSP print ( handle.name ) DCNL DCSP DCSP DCSP raise err DCNL DCSP DCSP assert ( alphabet is not None ) DCNL DCSP DCSP alignment = MultipleSeqAlignment ( &#91; &#93; , alphabet ) DCNL DCSP DCSP alignment . _ annotations = { } DCNL DCSP DCSP for ( key , value ) in header _ tags.items ( ) : DCNL DCSP DCSP DCSP alignment . _ annotations &#91; key &#93; = value DCNL DCSP DCSP for ( key , value ) in align _ tags.items ( ) : DCNL DCSP DCSP DCSP alignment . _ annotations &#91; key &#93; = value DCNL DCSP DCSP record = SeqRecord ( Seq ( q , alphabet ) , id = query _ id , name = &apos; query &apos; , description = query _ descr , annotations = { &apos; original _ length &apos; : int ( query _ tags &#91; &apos; sq _ len &apos; &#93; ) } ) DCNL DCSP DCSP record . _ al _ start = int ( query _ tags &#91; &apos; al _ start &apos; &#93; ) DCNL DCSP DCSP record . _ al _ stop = int ( query _ tags &#91; &apos; al _ stop &apos; &#93; ) DCNL DCSP DCSP alignment.append ( record ) DCNL DCSP DCSP if ( ( alphabet = = single _ letter _ alphabet ) and ( &apos; sq _ type &apos; in query _ tags ) ) : DCNL DCSP DCSP DCSP if ( query _ tags &#91; &apos; sq _ type &apos; &#93; = = &apos; D &apos; ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = generic _ dna DCNL DCSP DCSP DCSP elif ( query _ tags &#91; &apos; sq _ type &apos; &#93; = = &apos; p &apos; ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = generic _ protein DCNL DCSP DCSP if ( &apos; -&apos; in q ) : DCNL DCSP DCSP DCSP if ( not hasattr ( record.seq.alphabet , &apos; gap _ char &apos; ) ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = Gapped ( record.seq.alphabet , &apos; -&apos; ) DCNL DCSP DCSP record = SeqRecord ( Seq ( m , alphabet ) , id = match _ id , name = &apos; match &apos; , description = match _ descr , annotations = { &apos; original _ length &apos; : int ( match _ tags &#91; &apos; sq _ len &apos; &#93; ) } ) DCNL DCSP DCSP record . _ al _ start = int ( match _ tags &#91; &apos; al _ start &apos; &#93; ) DCNL DCSP DCSP record . _ al _ stop = int ( match _ tags &#91; &apos; al _ stop &apos; &#93; ) DCNL DCSP DCSP alignment.append ( record ) DCNL DCSP DCSP if ( ( alphabet = = single _ letter _ alphabet ) and ( &apos; sq _ type &apos; in match _ tags ) ) : DCNL DCSP DCSP DCSP if ( match _ tags &#91; &apos; sq _ type &apos; &#93; = = &apos; D &apos; ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = generic _ dna DCNL DCSP DCSP DCSP elif ( match _ tags &#91; &apos; sq _ type &apos; &#93; = = &apos; p &apos; ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = generic _ protein DCNL DCSP DCSP if ( &apos; -&apos; in m ) : DCNL DCSP DCSP DCSP if ( not hasattr ( record.seq.alphabet , &apos; gap _ char &apos; ) ) : DCNL DCSP DCSP DCSP DCSP record.seq.alphabet = Gapped ( record.seq.alphabet , &apos; -&apos; ) DCNL DCSP DCSP return alignment DCNL DCSP state = state _ PREAMBLE DCNL DCSP query _ id = None DCNL DCSP match _ id = None DCNL DCSP query _ descr = &apos; &apos; DCNL DCSP match _ descr = &apos; &apos; DCNL DCSP global _ tags = { } DCNL DCSP header _ tags = { } DCNL DCSP align _ tags = { } DCNL DCSP query _ tags = { } DCNL DCSP match _ tags = { } DCNL DCSP query _ seq = &apos; &apos; DCNL DCSP match _ seq = &apos; &apos; DCNL DCSP cons _ seq = &apos; &apos; DCNL DCSP for line in handle : DCNL DCSP DCSP if ( ( &apos; &gt; &gt; &gt; &apos; in line ) and ( not line.startswith ( &apos; &gt; &gt; &gt; &apos; ) ) ) : DCNL DCSP DCSP DCSP if ( query _ id and match _ id ) : DCNL DCSP DCSP DCSP DCSP ( yield build _ hsp ( ) ) DCNL DCSP DCSP DCSP state = state _ NONE DCNL DCSP DCSP DCSP query _ descr = line &#91; ( line.find ( &apos; &gt; &gt; &gt; &apos; ) + 3 ) : &#93; .strip ( ) DCNL DCSP DCSP DCSP query _ id = query _ descr.split ( None , 1 ) &#91; 0 &#93; DCNL DCSP DCSP DCSP match _ id = None DCNL DCSP DCSP DCSP header _ tags = { } DCNL DCSP DCSP DCSP align _ tags = { } DCNL DCSP DCSP DCSP query _ tags = { } DCNL DCSP DCSP DCSP match _ tags = { } DCNL DCSP DCSP DCSP query _ seq = &apos; &apos; DCNL DCSP DCSP DCSP match _ seq = &apos; &apos; DCNL DCSP DCSP DCSP cons _ seq = &apos; &apos; DCNL DCSP DCSP elif line.startswith ( &apos; ! ! DCSP No DCSP &apos; ) : DCNL DCSP DCSP DCSP assert ( state = = state _ NONE ) DCNL DCSP DCSP DCSP assert ( not header _ tags ) DCNL DCSP DCSP DCSP assert ( not align _ tags ) DCNL DCSP DCSP DCSP assert ( not match _ tags ) DCNL DCSP DCSP DCSP assert ( not query _ tags ) DCNL DCSP DCSP DCSP assert ( match _ id is None ) DCNL DCSP DCSP DCSP assert ( not query _ seq ) DCNL DCSP DCSP DCSP assert ( not match _ seq ) DCNL DCSP DCSP DCSP assert ( not cons _ seq ) DCNL DCSP DCSP DCSP query _ id = None DCNL DCSP DCSP elif ( line.strip ( ) in &#91; &apos; &gt; &gt; &gt; &lt; &lt; &lt; &apos; , &apos; &gt; &gt; &gt; / / / &apos; &#93; ) : DCNL DCSP DCSP DCSP if ( query _ id and match _ id ) : DCNL DCSP DCSP DCSP DCSP ( yield build _ hsp ( ) ) DCNL DCSP DCSP DCSP state = state _ NONE DCNL DCSP DCSP DCSP query _ id = None DCNL DCSP DCSP DCSP match _ id = None DCNL DCSP DCSP DCSP header _ tags = { } DCNL DCSP DCSP DCSP align _ tags = { } DCNL DCSP DCSP DCSP query _ tags = { } DCNL DCSP DCSP DCSP match _ tags = { } DCNL DCSP DCSP DCSP query _ seq = &apos; &apos; DCNL DCSP DCSP DCSP match _ seq = &apos; &apos; DCNL DCSP DCSP DCSP cons _ seq = &apos; &apos; DCNL DCSP DCSP elif line.startswith ( &apos; &gt; &gt; &gt; &apos; ) : DCNL DCSP DCSP DCSP assert ( query _ id is not None ) DCNL DCSP DCSP DCSP assert ( line &#91; 3 : &#93; .split ( &apos; , DCSP &apos; , 1 ) &#91; 0 &#93; = = query _ id ) , line DCNL DCSP DCSP DCSP assert ( match _ id is None ) DCNL DCSP DCSP DCSP assert ( not header _ tags ) DCNL DCSP DCSP DCSP assert ( not align _ tags ) DCNL DCSP DCSP DCSP assert ( not query _ tags ) DCNL DCSP DCSP DCSP assert ( not match _ tags ) DCNL DCSP DCSP DCSP assert ( not match _ seq ) DCNL DCSP DCSP DCSP assert ( not query _ seq ) DCNL DCSP DCSP DCSP assert ( not cons _ seq ) DCNL DCSP DCSP DCSP state = state _ QUERY _ HEADER DCNL DCSP DCSP elif line.startswith ( &apos; &gt; &gt; &apos; ) : DCNL DCSP DCSP DCSP if ( query _ id and match _ id ) : DCNL DCSP DCSP DCSP DCSP ( yield build _ hsp ( ) ) DCNL DCSP DCSP DCSP align _ tags = { } DCNL DCSP DCSP DCSP query _ tags = { } DCNL DCSP DCSP DCSP match _ tags = { } DCNL DCSP DCSP DCSP query _ seq = &apos; &apos; DCNL DCSP DCSP DCSP match _ seq = &apos; &apos; DCNL DCSP DCSP DCSP cons _ seq = &apos; &apos; DCNL DCSP DCSP DCSP match _ descr = line &#91; 2 : &#93; .strip ( ) DCNL DCSP DCSP DCSP match _ id = match _ descr.split ( None , 1 ) &#91; 0 &#93; DCNL DCSP DCSP DCSP state = state _ ALIGN _ HEADER DCNL DCSP DCSP elif line.startswith ( &apos; &gt; -- &apos; ) : DCNL DCSP DCSP DCSP assert ( query _ id and match _ id ) , line DCNL DCSP DCSP DCSP ( yield build _ hsp ( ) ) DCNL DCSP DCSP DCSP align _ tags = { } DCNL DCSP DCSP DCSP query _ tags = { } DCNL DCSP DCSP DCSP match _ tags = { } DCNL DCSP DCSP DCSP query _ seq = &apos; &apos; DCNL DCSP DCSP DCSP match _ seq = &apos; &apos; DCNL DCSP DCSP DCSP cons _ seq = &apos; &apos; DCNL DCSP DCSP DCSP state = state _ ALIGN _ HEADER DCNL DCSP DCSP elif line.startswith ( &apos; &gt; &apos; ) : DCNL DCSP DCSP DCSP if ( state = = state _ ALIGN _ HEADER ) : DCNL DCSP DCSP DCSP DCSP assert ( query _ id is not None ) , line DCNL DCSP DCSP DCSP DCSP assert ( match _ id is not None ) , line DCNL DCSP DCSP DCSP DCSP assert query _ id.startswith ( line &#91; 1 : &#93; .split ( None , 1 ) &#91; 0 &#93; ) , line DCNL DCSP DCSP DCSP DCSP state = state _ ALIGN _ QUERY DCNL DCSP DCSP DCSP elif ( state = = state _ ALIGN _ QUERY ) : DCNL DCSP DCSP DCSP DCSP assert ( query _ id is not None ) , line DCNL DCSP DCSP DCSP DCSP assert ( match _ id is not None ) , line DCNL DCSP DCSP DCSP DCSP assert match _ id.startswith ( line &#91; 1 : &#93; .split ( None , 1 ) &#91; 0 &#93; ) , line DCNL DCSP DCSP DCSP DCSP state = state _ ALIGN _ MATCH DCNL DCSP DCSP DCSP elif ( state = = state _ NONE ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert False , ( &apos; state DCSP % i DCSP got DCSP % r &apos; % ( state , line ) ) DCNL DCSP DCSP elif line.startswith ( &apos; ; DCSP al _ cons &apos; ) : DCNL DCSP DCSP DCSP assert ( state = = state _ ALIGN _ MATCH ) , line DCNL DCSP DCSP DCSP state = state _ ALIGN _ CONS DCNL DCSP DCSP elif line.startswith ( &apos; ; DCSP &apos; ) : DCNL DCSP DCSP DCSP if ( &apos; : DCSP &apos; in line ) : DCNL DCSP DCSP DCSP DCSP ( key , value ) = &#91; s.strip ( ) for s in line &#91; 2 : &#93; .split ( &apos; : DCSP &apos; , 1 ) &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP import warnings DCNL DCSP DCSP DCSP DCSP warnings.warn ( ( &apos; Missing DCSP colon DCSP in DCSP line : DCSP % r &apos; % line ) ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP ( key , value ) = &#91; s.strip ( ) for s in line &#91; 2 : &#93; .split ( &apos; DCSP &apos; , 1 ) &#93; DCNL DCSP DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; Bad DCSP line : DCSP % r &apos; % line ) ) DCNL DCSP DCSP DCSP if ( state = = state _ QUERY _ HEADER ) : DCNL DCSP DCSP DCSP DCSP header _ tags &#91; key &#93; = value DCNL DCSP DCSP DCSP elif ( state = = state _ ALIGN _ HEADER ) : DCNL DCSP DCSP DCSP DCSP align _ tags &#91; key &#93; = value DCNL DCSP DCSP DCSP elif ( state = = state _ ALIGN _ QUERY ) : DCNL DCSP DCSP DCSP DCSP query _ tags &#91; key &#93; = value DCNL DCSP DCSP DCSP elif ( state = = state _ ALIGN _ MATCH ) : DCNL DCSP DCSP DCSP DCSP match _ tags &#91; key &#93; = value DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert False , ( &apos; Unexpected DCSP state DCSP % r , DCSP % r &apos; % ( state , line ) ) DCNL DCSP DCSP elif ( state = = state _ ALIGN _ QUERY ) : DCNL DCSP DCSP DCSP query _ seq + = line.strip ( ) DCNL DCSP DCSP elif ( state = = state _ ALIGN _ MATCH ) : DCNL DCSP DCSP DCSP match _ seq + = line.strip ( ) DCNL DCSP DCSP elif ( state = = state _ ALIGN _ CONS ) : DCNL DCSP DCSP DCSP cons _ seq + = line.strip ( &apos; \ n &apos; ) DCNL DCSP DCSP elif ( state = = state _ PREAMBLE ) : DCNL DCSP DCSP DCSP if line.startswith ( &apos; # &apos; ) : DCNL DCSP DCSP DCSP DCSP global _ tags &#91; &apos; command &apos; &#93; = line &#91; 1 : &#93; .strip ( ) DCNL DCSP DCSP DCSP elif line.startswith ( &apos; DCSP version DCSP &apos; ) : DCNL DCSP DCSP DCSP DCSP global _ tags &#91; &apos; version &apos; &#93; = line &#91; 9 : &#93; .strip ( ) DCNL DCSP DCSP DCSP elif ( &apos; DCSP compares DCSP a DCSP &apos; in line ) : DCNL DCSP DCSP DCSP DCSP global _ tags &#91; &apos; tool &apos; &#93; = line &#91; : line.find ( &apos; DCSP compares DCSP a DCSP &apos; ) &#93; .strip ( ) DCNL DCSP DCSP DCSP elif ( &apos; DCSP searches DCSP a DCSP &apos; in line ) : DCNL DCSP DCSP DCSP DCSP global _ tags &#91; &apos; tool &apos; &#93; = line &#91; : line.find ( &apos; DCSP searches DCSP a DCSP &apos; ) &#93; .strip ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP pass
DCSP if request.GET.get ( u &apos;format &apos; ) : DCNL DCSP DCSP if ( request.GET &#91; u &apos;format &apos; &#93; in serializer.formats ) : DCNL DCSP DCSP DCSP return serializer.get _ mime _ for _ format ( request.GET &#91; u &apos;format &apos; &#93; ) DCNL DCSP if ( u &apos;callback &apos; in request.GET ) : DCNL DCSP DCSP return serializer.get _ mime _ for _ format ( u &apos;jsonp &apos; ) DCNL DCSP if ( request.META.get ( u &apos;HTTP _ ACCEPT &apos; , u &apos; * / * &apos; ) ! = u &apos; * / * &apos; ) : DCNL DCSP DCSP formats = ( list ( serializer.supported _ formats ) or &#91; &#93; ) DCNL DCSP DCSP formats.reverse ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP best _ format = mimeparse.best _ match ( formats , request.META &#91; u &apos;HTTP _ ACCEPT &apos; &#93; ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise BadRequest ( u &apos;Invalid DCSP Accept DCSP header &apos; ) DCNL DCSP DCSP if best _ format : DCNL DCSP DCSP DCSP return best _ format DCNL DCSP return default _ format
DCSP if isinstance ( s , unicode ) : DCNL DCSP DCSP s = s.encode ( _ encoding , &apos; backslashreplace &apos; ) DCNL DCSP return re.sub ( &apos; ( ? m ) ^ ( ? ! $ ) &apos; , ( indent * &apos; DCSP &apos; ) , s )
DCSP ( magic , level , timestamp , message ) = entry.split ( &apos; DCSP &apos; , 3 ) DCNL DCSP if ( magic ! = &apos; LOG &apos; ) : DCNL DCSP DCSP raise ValueError ( ) DCNL DCSP ( timestamp , level ) = ( int ( timestamp ) , int ( level ) ) DCNL DCSP if ( level not in LOG _ LEVELS ) : DCNL DCSP DCSP raise ValueError ( ) DCNL DCSP return ( timestamp , level , _ Clean ( message ) , ( None if clean _ message else message ) )
DCSP res = &apos; &apos; DCNL DCSP last = &apos; &apos; DCNL DCSP replacements = { } DCNL DCSP for e in bracket _ split ( code , &#91; &apos; &#91; &#93; &apos; &#93; ) : DCNL DCSP DCSP if ( e &#91; 0 &#93; = = &apos; &#91; &apos; ) : DCNL DCSP DCSP DCSP if is _ array ( last ) : DCNL DCSP DCSP DCSP DCSP name = ( ARRAY _ LVAL % count ) DCNL DCSP DCSP DCSP DCSP res + = ( &apos; DCSP &apos; + name ) DCNL DCSP DCSP DCSP DCSP replacements &#91; name &#93; = e DCNL DCSP DCSP DCSP DCSP count + = 1 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ( cand , new _ replacements , count ) = remove _ arrays ( e &#91; 1 : ( -1 ) &#93; , count ) DCNL DCSP DCSP DCSP DCSP res + = ( &apos; &#91; % s &#93; &apos; % cand ) DCNL DCSP DCSP DCSP DCSP replacements.update ( new _ replacements ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP res + = e DCNL DCSP DCSP last = e DCNL DCSP return ( res , replacements , count )
DCSP def _ doDOMtoCSSname2 ( m ) : DCNL DCSP DCSP return ( &apos; -&apos; + m.group ( 0 ) .lower ( ) ) DCNL DCSP return _ reDOMtoCSSname.sub ( _ doDOMtoCSSname2 , DOMname )
DCSP ( y0 , y1 ) = ( ( features &#91; : , 2 &#93; .min ( ) * 0.9 ) , ( features &#91; : , 2 &#93; .max ( ) * 1.1 ) ) DCNL DCSP ( x0 , x1 ) = ( ( features &#91; : , 0 &#93; .min ( ) * 0.9 ) , ( features &#91; : , 0 &#93; .max ( ) * 1.1 ) ) DCNL DCSP X = np.linspace ( x0 , x1 , 100 ) DCNL DCSP Y = np.linspace ( y0 , y1 , 100 ) DCNL DCSP ( X , Y ) = np.meshgrid ( X , Y ) DCNL DCSP model = fit _ model ( 1 , features &#91; : , ( 0 , 2 ) &#93; , np.array ( labels ) ) DCNL DCSP C = predict ( model , np.vstack ( &#91; X.ravel ( ) , Y.ravel ( ) &#93; ) .T ) .reshape ( X.shape ) DCNL DCSP if COLOUR _ FIGURE : DCNL DCSP DCSP cmap = ListedColormap ( &#91; ( 1.0 , 0.6 , 0.6 ) , ( 0.6 , 1.0 , 0.6 ) , ( 0.6 , 0.6 , 1.0 ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP cmap = ListedColormap ( &#91; ( 1.0 , 1.0 , 1.0 ) , ( 0.2 , 0.2 , 0.2 ) , ( 0.6 , 0.6 , 0.6 ) &#93; ) DCNL DCSP ( fig , ax ) = plt.subplots ( ) DCNL DCSP ax.set _ xlim ( x0 , x1 ) DCNL DCSP ax.set _ ylim ( y0 , y1 ) DCNL DCSP ax.set _ xlabel ( feature _ names &#91; 0 &#93; ) DCNL DCSP ax.set _ ylabel ( feature _ names &#91; 2 &#93; ) DCNL DCSP ax.pcolormesh ( X , Y , C , cmap = cmap ) DCNL DCSP if COLOUR _ FIGURE : DCNL DCSP DCSP cmap = ListedColormap ( &#91; ( 1.0 , 0.0 , 0.0 ) , ( 0.0 , 1.0 , 0.0 ) , ( 0.0 , 0.0 , 1.0 ) &#93; ) DCNL DCSP DCSP ax.scatter ( features &#91; : , 0 &#93; , features &#91; : , 2 &#93; , c = labels , cmap = cmap ) DCNL DCSP else : DCNL DCSP DCSP for ( lab , ma ) in zip ( range ( 3 ) , &apos; Do ^ &apos; ) : DCNL DCSP DCSP DCSP ax.plot ( features &#91; ( ( labels = = lab ) , 0 ) &#93; , features &#91; ( ( labels = = lab ) , 2 ) &#93; , ma , c = ( 1.0 , 1.0 , 1.0 ) ) DCNL DCSP return ( fig , ax )
DCSP environment = os.environ.copy ( ) DCNL DCSP environment &#91; &apos; READTHEDOCS &apos; &#93; = &apos; True &apos; DCNL DCSP if ( &apos; DJANGO _ SETTINGS _ MODULE &apos; in environment ) : DCNL DCSP DCSP del environment &#91; &apos; DJANGO _ SETTINGS _ MODULE &apos; &#93; DCNL DCSP if ( &apos; PYTHONPATH &apos; in environment ) : DCNL DCSP DCSP del environment &#91; &apos; PYTHONPATH &apos; &#93; DCNL DCSP if ( &apos; PYTHONHOME &apos; in environment ) : DCNL DCSP DCSP del environment &#91; &apos; PYTHONHOME &apos; &#93; DCNL DCSP cwd = os.getcwd ( ) DCNL DCSP if ( not commands ) : DCNL DCSP DCSP raise ValueError ( &apos; run ( ) DCSP requires DCSP one DCSP or DCSP more DCSP command-line DCSP strings &apos; ) DCNL DCSP shell = kwargs.get ( &apos; shell &apos; , False ) DCNL DCSP for command in commands : DCNL DCSP DCSP if shell : DCNL DCSP DCSP DCSP log.info ( &apos; Running DCSP commands DCSP in DCSP a DCSP shell &apos; ) DCNL DCSP DCSP DCSP run _ command = command DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP run _ command = command.split ( ) DCNL DCSP DCSP log.info ( &quot; Running : DCSP &apos; % s &apos; DCSP &#91; % s &#93; &quot; , command , cwd ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP p = subprocess.Popen ( run _ command , shell = shell , cwd = cwd , stdout = subprocess.PIPE , stderr = subprocess.PIPE , env = environment ) DCNL DCSP DCSP DCSP ( out , err ) = p.communicate ( ) DCNL DCSP DCSP DCSP ret = p.returncode DCNL DCSP DCSP except OSError : DCNL DCSP DCSP DCSP out = &apos; &apos; DCNL DCSP DCSP DCSP err = traceback.format _ exc ( ) DCNL DCSP DCSP DCSP ret = ( -1 ) DCNL DCSP DCSP DCSP log.error ( &apos; Command DCSP failed &apos; , exc _ info = True ) DCNL DCSP return ( ret , out , err )
DCSP first _ token.AddWhitespacePrefix ( _ CalculateNumberOfNewlines ( first _ token , indent _ depth , prev _ uwline , final _ lines ) , indent _ level = indent _ depth )
DCSP pkt = pkt.copy ( ) DCNL DCSP s = str ( pkt ) DCNL DCSP if ( len ( s ) &lt; = fragSize ) : DCNL DCSP DCSP return &#91; pkt &#93; DCNL DCSP if ( not ( IPv6ExtHdrFragment in pkt ) ) : DCNL DCSP DCSP return &#91; pkt &#93; DCNL DCSP fragPart = pkt &#91; IPv6ExtHdrFragment &#93; .payload DCNL DCSP tmp = str ( ( IPv6 ( src = &apos; : : 1 &apos; , dst = &apos; : : 1 &apos; ) / fragPart ) ) DCNL DCSP fragPartLen = ( len ( tmp ) - 40 ) DCNL DCSP fragPartStr = s &#91; ( - fragPartLen ) : &#93; DCNL DCSP nh = IPv6 ( tmp &#91; : 40 &#93; ) .nh DCNL DCSP fragHeader = pkt &#91; IPv6ExtHdrFragment &#93; DCNL DCSP fragHeader.payload = None DCNL DCSP unfragPartLen = ( ( len ( s ) - fragPartLen ) - 8 ) DCNL DCSP unfragPart = pkt DCNL DCSP pkt &#91; IPv6ExtHdrFragment &#93; .underlayer.payload = None DCNL DCSP lastFragSize = ( ( fragSize - unfragPartLen ) - 8 ) DCNL DCSP innerFragSize = ( lastFragSize - ( lastFragSize % 8 ) ) DCNL DCSP if ( ( lastFragSize &lt; = 0 ) or ( innerFragSize = = 0 ) ) : DCNL DCSP DCSP warning ( ( &apos; Provided DCSP fragment DCSP size DCSP value DCSP is DCSP too DCSP low . DCSP &apos; + ( &apos; Should DCSP be DCSP more DCSP than DCSP % d &apos; % ( unfragPartLen + 8 ) ) ) ) DCNL DCSP DCSP return &#91; ( ( unfragPart / fragHeader ) / fragPart ) &#93; DCNL DCSP remain = fragPartStr DCNL DCSP res = &#91; &#93; DCNL DCSP fragOffset = 0 DCNL DCSP fragId = random.randint ( 0 , 4294967295 ) DCNL DCSP if ( fragHeader.id is not None ) : DCNL DCSP DCSP fragId = fragHeader.id DCNL DCSP fragHeader.m = 1 DCNL DCSP fragHeader.id = fragId DCNL DCSP fragHeader.nh = nh DCNL DCSP while True : DCNL DCSP DCSP if ( len ( remain ) &gt; lastFragSize ) : DCNL DCSP DCSP DCSP tmp = remain &#91; : innerFragSize &#93; DCNL DCSP DCSP DCSP remain = remain &#91; innerFragSize : &#93; DCNL DCSP DCSP DCSP fragHeader.offset = fragOffset DCNL DCSP DCSP DCSP fragOffset + = ( innerFragSize / 8 ) DCNL DCSP DCSP DCSP if ( IPv6 in unfragPart ) : DCNL DCSP DCSP DCSP DCSP unfragPart &#91; IPv6 &#93; .plen = None DCNL DCSP DCSP DCSP tempo = ( ( unfragPart / fragHeader ) / Raw ( load = tmp ) ) DCNL DCSP DCSP DCSP res.append ( tempo ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fragHeader.offset = fragOffset DCNL DCSP DCSP DCSP fragHeader.m = 0 DCNL DCSP DCSP DCSP if ( IPv6 in unfragPart ) : DCNL DCSP DCSP DCSP DCSP unfragPart &#91; IPv6 &#93; .plen = None DCNL DCSP DCSP DCSP tempo = ( ( unfragPart / fragHeader ) / Raw ( load = remain ) ) DCNL DCSP DCSP DCSP res.append ( tempo ) DCNL DCSP DCSP DCSP break DCNL DCSP return res
DCSP elts = time _ string.split ( &apos; : &apos; ) DCNL DCSP if ( len ( elts ) = = 1 ) : DCNL DCSP DCSP return time _ string DCNL DCSP return str ( ( ( int ( elts &#91; 0 &#93; ) * 60 ) + float ( elts &#91; 1 &#93; ) ) )
DCSP return &#91; text &#91; i : ( i + chars _ per _ string ) &#93; for i in range ( 0 , len ( text ) , chars _ per _ string ) &#93;
DCSP settings = sublime.load _ settings ( &apos; MarkdownPreview.sublime-settings &apos; ) DCNL DCSP tmp _ filename = ( &apos; % s.html &apos; % view.id ( ) ) DCNL DCSP tmp _ dir = tempfile.gettempdir ( ) DCNL DCSP if settings.get ( &apos; path _ tempfile &apos; ) : DCNL DCSP DCSP if os.path.isabs ( settings.get ( &apos; path _ tempfile &apos; ) ) : DCNL DCSP DCSP DCSP tmp _ dir = settings.get ( &apos; path _ tempfile &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP tmp _ dir = os.path.join ( os.path.dirname ( view.file _ name ( ) ) , settings.get ( &apos; path _ tempfile &apos; ) ) DCNL DCSP if ( not os.path.isdir ( tmp _ dir ) ) : DCNL DCSP DCSP os.makedirs ( tmp _ dir ) DCNL DCSP tmp _ fullpath = os.path.join ( tmp _ dir , tmp _ filename ) DCNL DCSP return tmp _ fullpath
DCSP if ( not isinstance ( value , ( float , int , long ) ) ) : DCNL DCSP DCSP raise TypeError ( &apos; an DCSP integer DCSP or DCSP float DCSP is DCSP required &apos; ) DCNL DCSP if ( value &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; value DCSP have DCSP to DCSP be DCSP a DCSP positive DCSP or DCSP nul DCSP integer &apos; ) DCNL DCSP try : DCNL DCSP DCSP return ( UUID60 _ TIMESTAMP _ T0 + timedelta ( microseconds = ( value / 10 ) ) ) DCNL DCSP except OverflowError : DCNL DCSP DCSP raise ValueError ( ( _ ( &apos; timestampUUID60 ( ) DCSP overflow DCSP ( value = % s ) &apos; ) % value ) )
DCSP prob _ y = &#91; &#93; DCNL DCSP prob _ x = &#91; &#93; DCNL DCSP for line in open ( data _ file _ name ) : DCNL DCSP DCSP line = line.split ( None , 1 ) DCNL DCSP DCSP if ( len ( line ) = = 1 ) : DCNL DCSP DCSP DCSP line + = &#91; &apos; &apos; &#93; DCNL DCSP DCSP ( label , features ) = line DCNL DCSP DCSP xi = { } DCNL DCSP DCSP for e in features.split ( ) : DCNL DCSP DCSP DCSP ( ind , val ) = e.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP xi &#91; int ( ind ) &#93; = float ( val ) DCNL DCSP DCSP prob _ y + = &#91; float ( label ) &#93; DCNL DCSP DCSP prob _ x + = &#91; xi &#93; DCNL DCSP return ( prob _ y , prob _ x )
DCSP try : DCNL DCSP DCSP network _ interface = boto.ec2.networkinterface.NetworkInterfaceSpecification ( ) DCNL DCSP DCSP getattr ( network _ interface , &apos; associate _ public _ ip _ address &apos; ) DCNL DCSP DCSP return True DCNL DCSP except AttributeError : DCNL DCSP DCSP return False
DCSP try : DCNL DCSP DCSP new _ settings = parser.get _ config _ file _ settings ( value ) DCNL DCSP except ValueError as error : DCNL DCSP DCSP parser.error ( error ) DCNL DCSP parser.values.update ( new _ settings , parser )
DCSP extensions = &#91; ( s , &apos; rb &apos; , C _ EXTENSION ) for s in machinery.EXTENSION _ SUFFIXES &#93; DCNL DCSP source = &#91; ( s , &apos; r &apos; , PY _ SOURCE ) for s in machinery.SOURCE _ SUFFIXES &#93; DCNL DCSP bytecode = &#91; ( s , &apos; rb &apos; , PY _ COMPILED ) for s in machinery.BYTECODE _ SUFFIXES &#93; DCNL DCSP return ( ( extensions + source ) + bytecode )
DCSP return jinja2.Markup ( value )
DCSP return config.is _ provider _ configured ( _ _ opts _ _ , ( _ _ active _ provider _ name _ _ or _ _ virtualname _ _ ) , ( &apos; user &apos; , &apos; tenant &apos; , &apos; identity _ url &apos; , &apos; compute _ region &apos; ) )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( not instance _ profile _ exists ( name , region , key , keyid , profile ) ) : DCNL DCSP DCSP return True DCNL DCSP try : DCNL DCSP DCSP conn.delete _ instance _ profile ( name ) DCNL DCSP DCSP log.info ( &apos; Deleted DCSP { 0 } DCSP instance DCSP profile . &apos; .format ( name ) ) DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP delete DCSP { 0 } DCSP instance DCSP profile . &apos; DCNL DCSP DCSP log.error ( msg.format ( name ) ) DCNL DCSP DCSP return False DCNL DCSP return True
DCSP if ( not dnn _ present ( ) ) : DCNL DCSP DCSP if raises : DCNL DCSP DCSP DCSP raise RuntimeError ( &quot; We DCSP can &apos;t DCSP determine DCSP the DCSP cudnn DCSP version DCSP as DCSP it DCSP is DCSP not DCSP available &quot; , dnn _ available.msg ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( -1 ) DCNL DCSP if ( version.v is None ) : DCNL DCSP DCSP f = theano.function ( &#91; &#93; , DnnVersion ( ) ( ) , theano.Mode ( optimizer = None ) , profile = False ) DCNL DCSP DCSP v = f ( ) DCNL DCSP DCSP if ( v &#91; 0 &#93; ! = v &#91; 1 &#93; ) : DCNL DCSP DCSP DCSP raise RuntimeError ( ( &apos; Mixed DCSP dnn DCSP version . DCSP The DCSP header DCSP is DCSP version DCSP % s DCSP while DCSP the DCSP library DCSP is DCSP version DCSP % s . &apos; % v ) ) DCNL DCSP DCSP version.v = v &#91; 1 &#93; DCNL DCSP return version.v
DCSP if ( not ( u &apos;public &apos; in joins ) ) : DCNL DCSP DCSP joins = &#91; scrub ( part ) for part in joins &#93; DCNL DCSP return os.path.join ( os.path.dirname ( get _ module ( scrub ( modulename ) ) . _ _ file _ _ ) , * joins )
DCSP it = iter ( sequence ) DCNL DCSP try : DCNL DCSP DCSP return next ( it ) DCNL DCSP except StopIteration : DCNL DCSP DCSP raise ValueError ( )
DCSP if ( prev _ uwline is None ) : DCNL DCSP DCSP if ( first _ token.newlines is not None ) : DCNL DCSP DCSP DCSP pytree _ utils.SetNodeAnnotation ( first _ token.node , pytree _ utils.Annotation.NEWLINES , None ) DCNL DCSP DCSP return 0 DCNL DCSP if first _ token.is _ docstring : DCNL DCSP DCSP return NO _ BLANK _ LINES DCNL DCSP prev _ last _ token = prev _ uwline.last DCNL DCSP if prev _ last _ token.is _ docstring : DCNL DCSP DCSP if ( ( not indent _ depth ) and ( first _ token.value in { u &apos;class &apos; , u &apos;def &apos; , u &apos;async &apos; } ) ) : DCNL DCSP DCSP DCSP return TWO _ BLANK _ LINES DCNL DCSP DCSP if _ NoBlankLinesBeforeCurrentToken ( prev _ last _ token.value , first _ token , prev _ last _ token ) : DCNL DCSP DCSP DCSP return NO _ BLANK _ LINES DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ONE _ BLANK _ LINE DCNL DCSP if ( first _ token.value in { u &apos;class &apos; , u &apos;def &apos; , u &apos;async &apos; , u &apos; @ &apos; } ) : DCNL DCSP DCSP if ( not indent _ depth ) : DCNL DCSP DCSP DCSP is _ inline _ comment = ( prev _ last _ token.whitespace _ prefix.count ( u &apos; \ n &apos; ) = = 0 ) DCNL DCSP DCSP DCSP if ( ( not prev _ uwline.disable ) and prev _ last _ token.is _ comment and ( not is _ inline _ comment ) ) : DCNL DCSP DCSP DCSP DCSP if _ NoBlankLinesBeforeCurrentToken ( prev _ last _ token.value , first _ token , prev _ last _ token ) : DCNL DCSP DCSP DCSP DCSP DCSP index = ( len ( final _ lines ) - 1 ) DCNL DCSP DCSP DCSP DCSP DCSP while ( index &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not final _ lines &#91; ( index - 1 ) &#93; .is _ comment ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP DCSP index - = 1 DCNL DCSP DCSP DCSP DCSP DCSP if ( final _ lines &#91; ( index - 1 ) &#93; .first.value = = u &apos; @ &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP final _ lines &#91; index &#93; .first.AdjustNewlinesBefore ( NO _ BLANK _ LINES ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP prev _ last _ token.AdjustNewlinesBefore ( TWO _ BLANK _ LINES ) DCNL DCSP DCSP DCSP DCSP DCSP if ( first _ token.newlines is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP pytree _ utils.SetNodeAnnotation ( first _ token.node , pytree _ utils.Annotation.NEWLINES , None ) DCNL DCSP DCSP DCSP DCSP DCSP return NO _ BLANK _ LINES DCNL DCSP DCSP elif ( prev _ uwline.first.value in { u &apos;class &apos; , u &apos;def &apos; , u &apos;async &apos; } ) : DCNL DCSP DCSP DCSP if ( not style.Get ( u &apos;BLANK _ LINE _ BEFORE _ NESTED _ CLASS _ OR _ DEF &apos; ) ) : DCNL DCSP DCSP DCSP DCSP pytree _ utils.SetNodeAnnotation ( first _ token.node , pytree _ utils.Annotation.NEWLINES , None ) DCNL DCSP DCSP DCSP DCSP return NO _ BLANK _ LINES DCNL DCSP if first _ token.is _ comment : DCNL DCSP DCSP first _ token _ lineno = ( first _ token.lineno - first _ token.value.count ( u &apos; \ n &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP first _ token _ lineno = first _ token.lineno DCNL DCSP prev _ last _ token _ lineno = prev _ last _ token.lineno DCNL DCSP if prev _ last _ token.is _ multiline _ string : DCNL DCSP DCSP prev _ last _ token _ lineno + = prev _ last _ token.value.count ( u &apos; \ n &apos; ) DCNL DCSP if ( ( first _ token _ lineno - prev _ last _ token _ lineno ) &gt; 1 ) : DCNL DCSP DCSP return ONE _ BLANK _ LINE DCNL DCSP return NO _ BLANK _ LINES
DCSP try : DCNL DCSP DCSP poll = kw.pop ( &apos; salt _ job _ poll &apos; ) DCNL DCSP except KeyError : DCNL DCSP DCSP poll = 0.1 DCNL DCSP try : DCNL DCSP DCSP target = kw.pop ( &apos; salt _ target &apos; ) DCNL DCSP except KeyError : DCNL DCSP DCSP target = None DCNL DCSP try : DCNL DCSP DCSP timeout = int ( kw.pop ( &apos; salt _ timeout &apos; ) ) DCNL DCSP except ( KeyError , ValueError ) : DCNL DCSP DCSP timeout = _ _ FUN _ TIMEOUT.get ( fun , 900 ) DCNL DCSP try : DCNL DCSP DCSP kwargs = kw.pop ( &apos; kwargs &apos; ) DCNL DCSP except KeyError : DCNL DCSP DCSP kwargs = { } DCNL DCSP if ( not target ) : DCNL DCSP DCSP infos = get _ configured _ provider ( ) DCNL DCSP DCSP if ( not infos ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP target = infos &#91; &apos; target &apos; &#93; DCNL DCSP laps = time.time ( ) DCNL DCSP cache = False DCNL DCSP if ( fun in _ _ CACHED _ FUNS ) : DCNL DCSP DCSP cache = True DCNL DCSP DCSP laps = ( laps / / _ _ CACHED _ FUNS &#91; fun &#93; ) DCNL DCSP try : DCNL DCSP DCSP sargs = json.dumps ( args ) DCNL DCSP except TypeError : DCNL DCSP DCSP sargs = &apos; &apos; DCNL DCSP try : DCNL DCSP DCSP skw = json.dumps ( kw ) DCNL DCSP except TypeError : DCNL DCSP DCSP skw = &apos; &apos; DCNL DCSP try : DCNL DCSP DCSP skwargs = json.dumps ( kwargs ) DCNL DCSP except TypeError : DCNL DCSP DCSP skwargs = &apos; &apos; DCNL DCSP cache _ key = ( laps , target , fun , sargs , skw , skwargs ) DCNL DCSP if ( ( not cache ) or ( cache and ( cache _ key not in _ _ CACHED _ CALLS ) ) ) : DCNL DCSP DCSP conn = _ client ( ) DCNL DCSP DCSP runner = _ runner ( ) DCNL DCSP DCSP rkwargs = kwargs.copy ( ) DCNL DCSP DCSP rkwargs &#91; &apos; timeout &apos; &#93; = timeout DCNL DCSP DCSP rkwargs.setdefault ( &apos; tgt _ type &apos; , &apos; list &apos; ) DCNL DCSP DCSP kwargs.setdefault ( &apos; tgt _ type &apos; , &apos; list &apos; ) DCNL DCSP DCSP ping _ retries = 0 DCNL DCSP DCSP ping _ max _ retries = 60 DCNL DCSP DCSP ping = True DCNL DCSP DCSP if ( fun = = &apos; test.ping &apos; ) : DCNL DCSP DCSP DCSP ping _ retries = ( ping _ max _ retries + 1 ) DCNL DCSP DCSP while ( ping _ retries &lt; = ping _ max _ retries ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( ping _ retries &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP time.sleep ( 1 ) DCNL DCSP DCSP DCSP DCSP pings = conn.cmd ( tgt = target , timeout = 10 , fun = &apos; test.ping &apos; ) DCNL DCSP DCSP DCSP DCSP values = list ( pings.values ( ) ) DCNL DCSP DCSP DCSP DCSP if ( not values ) : DCNL DCSP DCSP DCSP DCSP DCSP ping = False DCNL DCSP DCSP DCSP DCSP for v in values : DCNL DCSP DCSP DCSP DCSP DCSP if ( v is not True ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ping = False DCNL DCSP DCSP DCSP DCSP if ( not ping ) : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( &apos; Unreachable &apos; ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP ping = False DCNL DCSP DCSP DCSP DCSP ping _ retries + = 1 DCNL DCSP DCSP DCSP DCSP log.error ( &apos; { 0 } DCSP unreachable , DCSP retrying &apos; .format ( target ) ) DCNL DCSP DCSP if ( not ping ) : DCNL DCSP DCSP DCSP raise SaltCloudSystemExit ( &apos; Target DCSP { 0 } DCSP unreachable &apos; .format ( target ) ) DCNL DCSP DCSP jid = conn.cmd _ async ( tgt = target , fun = fun , arg = args , kwarg = kw , * * rkwargs ) DCNL DCSP DCSP cret = conn.cmd ( tgt = target , fun = &apos; saltutil.find _ job &apos; , arg = &#91; jid &#93; , timeout = 10 , * * kwargs ) DCNL DCSP DCSP running = bool ( cret.get ( target , False ) ) DCNL DCSP DCSP endto = ( time.time ( ) + timeout ) DCNL DCSP DCSP while running : DCNL DCSP DCSP DCSP rkwargs = { &apos; tgt &apos; : target , &apos; fun &apos; : &apos; saltutil.find _ job &apos; , &apos; arg &apos; : &#91; jid &#93; , &apos; timeout &apos; : 10 } DCNL DCSP DCSP DCSP cret = conn.cmd ( * * rkwargs ) DCNL DCSP DCSP DCSP running = bool ( cret.get ( target , False ) ) DCNL DCSP DCSP DCSP if ( not running ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if ( running and ( time.time ( ) &gt; endto ) ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( &apos; Timeout DCSP { 0 } s DCSP for DCSP { 1 } DCSP is DCSP elapsed &apos; .format ( timeout , pformat ( rkwargs ) ) ) DCNL DCSP DCSP DCSP time.sleep ( poll ) DCNL DCSP DCSP wait _ for _ res = float ( { &apos; test.ping &apos; : &apos; 5&apos; } .get ( fun , &apos; 120 &apos; ) ) DCNL DCSP DCSP while wait _ for _ res : DCNL DCSP DCSP DCSP wait _ for _ res - = 0.5 DCNL DCSP DCSP DCSP cret = runner.cmd ( &apos; jobs.lookup _ jid &apos; , &#91; jid , { &apos; _ _ kwarg _ _ &apos; : True } &#93; ) DCNL DCSP DCSP DCSP if ( target in cret ) : DCNL DCSP DCSP DCSP DCSP ret = cret &#91; target &#93; DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP elif ( ( &apos; data &apos; in cret ) and ( &apos; outputter &apos; in cret ) ) : DCNL DCSP DCSP DCSP DCSP ret = cret &#91; &apos; data &apos; &#93; DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if ( ( fun in &#91; &apos; test.ping &apos; &#93; ) and ( not wait _ for _ res ) ) : DCNL DCSP DCSP DCSP DCSP ret = { &apos; test.ping &apos; : False } .get ( fun , False ) DCNL DCSP DCSP DCSP time.sleep ( 0.5 ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( &apos; is DCSP not DCSP available . &apos; in ret ) : DCNL DCSP DCSP DCSP DCSP raise SaltCloudSystemExit ( &apos; module / function DCSP { 0 } DCSP is DCSP not DCSP available &apos; .format ( fun ) ) DCNL DCSP DCSP except SaltCloudSystemExit : DCNL DCSP DCSP DCSP raise DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP if cache : DCNL DCSP DCSP DCSP _ _ CACHED _ CALLS &#91; cache _ key &#93; = ret DCNL DCSP elif ( cache and ( cache _ key in _ _ CACHED _ CALLS ) ) : DCNL DCSP DCSP ret = _ _ CACHED _ CALLS &#91; cache _ key &#93; DCNL DCSP return ret
DCSP return hadoopcli ( ) .version.lower ( )
DCSP conditional _ match = _ CONDITIONAL.search ( string ) DCNL DCSP while conditional _ match : DCNL DCSP DCSP start = conditional _ match.start ( ) DCNL DCSP DCSP end = _ find _ closing _ brace ( string , ( start + 4 ) ) DCNL DCSP DCSP args = _ split _ conditional ( string &#91; ( start + 4 ) : ( end - 1 ) &#93; ) DCNL DCSP DCSP rv = &apos; &apos; DCNL DCSP DCSP if match.group ( int ( conditional _ match.group ( 1 ) ) ) : DCNL DCSP DCSP DCSP rv = unescape ( _ replace _ conditional ( match , args &#91; 0 &#93; ) ) DCNL DCSP DCSP elif ( len ( args ) &gt; 1 ) : DCNL DCSP DCSP DCSP rv = unescape ( _ replace _ conditional ( match , args &#91; 1 &#93; ) ) DCNL DCSP DCSP string = ( ( string &#91; : start &#93; + rv ) + string &#91; end : &#93; ) DCNL DCSP DCSP conditional _ match = _ CONDITIONAL.search ( string ) DCNL DCSP return string
DCSP try : DCNL DCSP DCSP return session.call _ xenapi ( &apos; SR.get _ by _ uuid &apos; , sr _ uuid ) DCNL DCSP except session.XenAPI.Failure as exc : DCNL DCSP DCSP if ( exc.details &#91; 0 &#93; = = &apos; UUID _ INVALID &apos; ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP raise
DCSP if ( not os.access ( xml _ config _ file , os.R _ OK ) ) : DCNL DCSP DCSP msg = ( _ ( &quot; Can &apos;t DCSP find DCSP HNAS DCSP configurations DCSP on DCSP cinder.conf DCSP neither DCSP on DCSP the DCSP path DCSP % ( xml ) s . &quot; ) % { &apos; xml &apos; : xml _ config _ file } ) DCNL DCSP DCSP LOG.error ( msg ) DCNL DCSP DCSP raise exception.ConfigNotFound ( message = msg ) DCNL DCSP else : DCNL DCSP DCSP LOG.warning ( _ LW ( &apos; This DCSP XML DCSP configuration DCSP file DCSP % ( xml ) s DCSP is DCSP deprecated . DCSP Please , DCSP move DCSP all DCSP the DCSP configurations DCSP to DCSP the DCSP cinder.conf DCSP file . DCSP If DCSP you DCSP keep DCSP both DCSP configuration DCSP files , DCSP the DCSP options DCSP set DCSP on DCSP cinder.conf DCSP will DCSP be DCSP used . &apos; ) , { &apos; xml &apos; : xml _ config _ file } ) DCNL DCSP try : DCNL DCSP DCSP root = ETree.parse ( xml _ config _ file ) .getroot ( ) DCNL DCSP except ETree.ParseError : DCNL DCSP DCSP msg = ( _ ( &apos; Error DCSP parsing DCSP config DCSP file : DCSP % ( xml _ config _ file ) s &apos; ) % { &apos; xml _ config _ file &apos; : xml _ config _ file } ) DCNL DCSP DCSP LOG.error ( msg ) DCNL DCSP DCSP raise exception.ConfigNotFound ( message = msg ) DCNL DCSP config = { } DCNL DCSP arg _ prereqs = &#91; &apos; mgmt _ ip0 &apos; , &apos; username &apos; &#93; DCNL DCSP for req in arg _ prereqs : DCNL DCSP DCSP config &#91; req &#93; = _ xml _ read ( root , req , &apos; check &apos; ) DCNL DCSP for req in optional _ params : DCNL DCSP DCSP config &#91; req &#93; = _ xml _ read ( root , req ) DCNL DCSP DCSP if ( ( config &#91; req &#93; is None ) and ( HNAS _ DEFAULT _ CONFIG.get ( req ) is not None ) ) : DCNL DCSP DCSP DCSP config &#91; req &#93; = HNAS _ DEFAULT _ CONFIG.get ( req ) DCNL DCSP config &#91; &apos; ssh _ private _ key &apos; &#93; = _ xml _ read ( root , &apos; ssh _ private _ key &apos; ) DCNL DCSP config &#91; &apos; password &apos; &#93; = _ xml _ read ( root , &apos; password &apos; ) DCNL DCSP if ( ( config &#91; &apos; ssh _ private _ key &apos; &#93; is None ) and ( config &#91; &apos; password &apos; &#93; is None ) ) : DCNL DCSP DCSP msg = _ ( &apos; Missing DCSP authentication DCSP option DCSP ( passw DCSP or DCSP private DCSP key DCSP file ) . &apos; ) DCNL DCSP DCSP LOG.error ( msg ) DCNL DCSP DCSP raise exception.ConfigNotFound ( message = msg ) DCNL DCSP if ( _ xml _ read ( root , &apos; ssh _ port &apos; ) is not None ) : DCNL DCSP DCSP config &#91; &apos; ssh _ port &apos; &#93; = int ( _ xml _ read ( root , &apos; ssh _ port &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP config &#91; &apos; ssh _ port &apos; &#93; = HNAS _ DEFAULT _ CONFIG &#91; &apos; ssh _ port &apos; &#93; DCNL DCSP config &#91; &apos; fs &apos; &#93; = { } DCNL DCSP config &#91; &apos; services &apos; &#93; = { } DCNL DCSP for svc in &#91; &apos; svc _ 0 &apos; , &apos; svc _ 1 &apos; , &apos; svc _ 2 &apos; , &apos; svc _ 3 &apos; &#93; : DCNL DCSP DCSP if ( _ xml _ read ( root , svc ) is None ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP service = { &apos; label &apos; : svc } DCNL DCSP DCSP for arg in svc _ params : DCNL DCSP DCSP DCSP service &#91; arg &#93; = _ xml _ read ( root , ( ( svc + &apos; / &apos; ) + arg ) , &apos; check &apos; ) DCNL DCSP DCSP service.setdefault ( &apos; pool _ name &apos; , service.pop ( &apos; volume _ type &apos; , None ) ) DCNL DCSP DCSP config &#91; &apos; services &apos; &#93; &#91; service &#91; &apos; pool _ name &apos; &#93; &#93; = service DCNL DCSP DCSP config &#91; &apos; fs &apos; &#93; &#91; service &#91; &apos; hdp &apos; &#93; &#93; = service &#91; &apos; hdp &apos; &#93; DCNL DCSP if ( not config &#91; &apos; services &apos; &#93; .keys ( ) ) : DCNL DCSP DCSP LOG.error ( _ LE ( &apos; No DCSP service DCSP found DCSP in DCSP xml DCSP config DCSP file &apos; ) ) DCNL DCSP DCSP raise exception.ParameterNotFound ( param = &apos; svc _ 0 &apos; ) DCNL DCSP return config
DCSP color _ names = ( &apos; black &apos; , &apos; red &apos; , &apos; green &apos; , &apos; yellow &apos; , &apos; blue &apos; , &apos; magenta &apos; , &apos; cyan &apos; , &apos; white &apos; ) DCNL DCSP foreground = dict ( &#91; ( color _ names &#91; x &#93; , ( &apos; 3 % s &apos; % x ) ) for x in range ( 8 ) &#93; ) DCNL DCSP background = dict ( &#91; ( color _ names &#91; x &#93; , ( &apos; 4 % s &apos; % x ) ) for x in range ( 8 ) &#93; ) DCNL DCSP RESET = &apos; 0&apos; DCNL DCSP opt _ dict = { &apos; bold &apos; : &apos; 1&apos; , &apos; underscore &apos; : &apos; 4&apos; , &apos; blink &apos; : &apos; 5&apos; , &apos; reverse &apos; : &apos; 7&apos; , &apos; conceal &apos; : &apos; 8&apos; } DCNL DCSP text = str ( text ) DCNL DCSP code _ list = &#91; &#93; DCNL DCSP if ( ( text = = &apos; &apos; ) and ( len ( opts ) = = 1 ) and ( opts &#91; 0 &#93; = = &apos; reset &apos; ) ) : DCNL DCSP DCSP return ( &apos; \ x1b &#91; % sm &apos; % RESET ) DCNL DCSP for ( k , v ) in kwargs.iteritems ( ) : DCNL DCSP DCSP if ( k = = &apos; fg &apos; ) : DCNL DCSP DCSP DCSP code _ list.append ( foreground &#91; v &#93; ) DCNL DCSP DCSP elif ( k = = &apos; bg &apos; ) : DCNL DCSP DCSP DCSP code _ list.append ( background &#91; v &#93; ) DCNL DCSP for o in opts : DCNL DCSP DCSP if ( o in opt _ dict ) : DCNL DCSP DCSP DCSP code _ list.append ( opt _ dict &#91; o &#93; ) DCNL DCSP if ( &apos; noreset &apos; not in opts ) : DCNL DCSP DCSP text = ( text + ( &apos; \ x1b &#91; % sm &apos; % RESET ) ) DCNL DCSP return ( ( &apos; \ x1b &#91; % sm &apos; % &apos; ; &apos; .join ( code _ list ) ) + text )
DCSP if context.is _ admin : DCNL DCSP DCSP return True DCNL DCSP if ( image &#91; &apos; owner &apos; &#93; is None ) : DCNL DCSP DCSP return True DCNL DCSP if ( image &#91; &apos; visibility &apos; &#93; in &#91; &apos; public &apos; , &apos; community &apos; &#93; ) : DCNL DCSP DCSP return True DCNL DCSP if ( context.owner is not None ) : DCNL DCSP DCSP if ( context.owner = = image &#91; &apos; owner &apos; &#93; ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP if ( &apos; shared &apos; = = image &#91; &apos; visibility &apos; &#93; ) : DCNL DCSP DCSP DCSP members = image _ member _ find ( context , image _ id = image &#91; &apos; id &apos; &#93; , member = context.owner , status = status ) DCNL DCSP DCSP DCSP if members : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP return False
DCSP lines _ a = set ( &#91; l.strip ( ) for l in first.split ( &apos; \ n &apos; ) &#93; ) DCNL DCSP lines _ b = set ( &#91; l.strip ( ) for l in second.split ( &apos; \ n &apos; ) &#93; ) DCNL DCSP common = lines _ a.intersection ( lines _ b ) DCNL DCSP similarity = ( ( 1.0 * len ( common ) ) / max ( len ( lines _ a ) , len ( lines _ b ) ) ) DCNL DCSP nose.tools.assert _ true ( ( similarity &gt; = ratio ) , msg )
DCSP return &#91; i for i in list _ if ( i ! = item ) &#93;
DCSP pdef = base _ param ( registry , xml _ parent , data , False , &apos; hudson.model.RunParameterDefinition &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; projectName &apos; ) .text = data &#91; &apos; project-name &apos; &#93;
DCSP if ( ( not url ) or ( not method ) ) : DCNL DCSP DCSP raise MissingRequestArgs DCNL DCSP return tornado.httpclient.HTTPRequest ( url = url , method = method , body = body , validate _ cert = False , request _ timeout = hermes _ constants.REQUEST _ TIMEOUT )
DCSP try : DCNL DCSP DCSP p = Popen ( cmd , shell = False , stdout = PIPE , stdin = PIPE ) DCNL DCSP except OSError as e : DCNL DCSP DCSP pl.exception ( u &apos;Could DCSP not DCSP execute DCSP command DCSP ( { 0 } ) : DCSP { 1 } &apos; , e , cmd ) DCNL DCSP DCSP return None DCNL DCSP else : DCNL DCSP DCSP ( stdout , err ) = p.communicate ( ( stdin if ( stdin is None ) else stdin.encode ( get _ preferred _ output _ encoding ( ) ) ) ) DCNL DCSP DCSP stdout = stdout.decode ( get _ preferred _ input _ encoding ( ) ) DCNL DCSP return ( stdout.strip ( ) if strip else stdout )
DCSP if ( key in node.private _ link _ keys _ deleted ) : DCNL DCSP DCSP url = furl ( url ) .add ( { &apos; status &apos; : &apos; expired &apos; } ) .url DCNL DCSP return url
DCSP return search _ lxc _ bridges ( ) &#91; 0 &#93;
DCSP line = physical _ line.lstrip ( ) DCNL DCSP start = max ( &#91; line.find ( i ) for i in START _ DOCSTRING _ TRIPLE &#93; ) DCNL DCSP end = max ( &#91; ( line &#91; ( -4 ) : ( -1 ) &#93; = = i ) for i in END _ DOCSTRING _ TRIPLE &#93; ) DCNL DCSP if ( previous _ logical.startswith ( &apos; def DCSP &apos; ) or previous _ logical.startswith ( &apos; class DCSP &apos; ) ) : DCNL DCSP DCSP if ( start is 0 ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( end and ( start in ( ( -1 ) , ( len ( line ) - 4 ) ) ) )
DCSP for ext in zip ( * imp.get _ suffixes ( ) ) &#91; 0 &#93; : DCNL DCSP DCSP initFile = ( &apos; _ _ init _ _ &apos; + ext ) DCNL DCSP DCSP if os.path.exists ( os.path.join ( dirname , initFile ) ) : DCNL DCSP DCSP DCSP return initFile DCNL DCSP return False
DCSP ctx = md5.new ( ) DCNL DCSP for header in headerlist : DCNL DCSP DCSP value = request.META.get ( header , None ) DCNL DCSP DCSP if ( value is not None ) : DCNL DCSP DCSP DCSP ctx.update ( value ) DCNL DCSP return ( &apos; views.decorators.cache.cache _ page . % s . % s . % s &apos; % ( key _ prefix , request.path , ctx.hexdigest ( ) ) )
DCSP if ( since _ tag is None ) : DCNL DCSP DCSP since _ tag = check _ output ( &#91; &apos; git &apos; , &apos; describe &apos; , branch , &apos; --abbrev = 0 &apos; &#93; ) .decode ( &apos; utf8 &apos; ) .strip ( ) DCNL DCSP cmd = &#91; &apos; git &apos; , &apos; log &apos; , ( &apos; % s .. % s &apos; % ( since _ tag , branch ) ) , &apos; --oneline &apos; &#93; DCNL DCSP lines = check _ output ( cmd ) .decode ( &apos; utf8 &apos; ) DCNL DCSP return set ( ( int ( num ) for num in backport _ re.findall ( lines ) ) )
DCSP assert ( &apos; headers &apos; in http _ info ) DCNL DCSP headers = http _ info &#91; &apos; headers &apos; &#93; DCNL DCSP assert ( len ( headers ) = = 1 ) DCNL DCSP ( header _ name , header _ value ) = headers &#91; 0 &#93; DCNL DCSP assert ( header _ name = = &apos; Location &apos; ) DCNL DCSP return header _ value
DCSP xieta = &#91; &#93; DCNL DCSP h = match &#91; &apos; h &apos; &#93; DCNL DCSP hx = match &#91; &apos; hx &apos; &#93; DCNL DCSP hy = match &#91; &apos; hy &apos; &#93; DCNL DCSP func = match &#91; &apos; func &apos; &#93; DCNL DCSP hinv = match &#91; &apos; hinv &apos; &#93; DCNL DCSP x = func.args &#91; 0 &#93; DCNL DCSP y = match &#91; &apos; y &apos; &#93; DCNL DCSP xi = Function ( &apos; xi &apos; ) ( x , func ) DCNL DCSP eta = Function ( &apos; eta &apos; ) ( x , func ) DCNL DCSP coeffdict = { } DCNL DCSP symbols = numbered _ symbols ( &apos; c &apos; , cls = Dummy ) DCNL DCSP symlist = &#91; next ( symbols ) for i in islice ( symbols , 6 ) &#93; DCNL DCSP ( C0 , C1 , C2 , C3 , C4 , C5 ) = symlist DCNL DCSP pde = ( ( ( ( C3 + ( ( C4 - C0 ) * h ) ) - ( ( ( ( C0 * x ) + ( C1 * y ) ) + C2 ) * hx ) ) - ( ( ( ( C3 * x ) + ( C4 * y ) ) + C5 ) * hy ) ) - ( C1 * ( h * * 2 ) ) ) DCNL DCSP ( pde , denom ) = pde.as _ numer _ denom ( ) DCNL DCSP pde = powsimp ( expand ( pde ) ) DCNL DCSP if pde.is _ Add : DCNL DCSP DCSP terms = pde.args DCNL DCSP DCSP for term in terms : DCNL DCSP DCSP DCSP if term.is _ Mul : DCNL DCSP DCSP DCSP DCSP rem = Mul ( * &#91; m for m in term.args if ( not m.has ( x , y ) ) &#93; ) DCNL DCSP DCSP DCSP DCSP xypart = ( term / rem ) DCNL DCSP DCSP DCSP DCSP if ( xypart not in coeffdict ) : DCNL DCSP DCSP DCSP DCSP DCSP coeffdict &#91; xypart &#93; = rem DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP coeffdict &#91; xypart &#93; + = rem DCNL DCSP DCSP DCSP elif ( term not in coeffdict ) : DCNL DCSP DCSP DCSP DCSP coeffdict &#91; term &#93; = S ( 1 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP coeffdict &#91; term &#93; + = S ( 1 ) DCNL DCSP sollist = coeffdict.values ( ) DCNL DCSP soldict = solve ( sollist , symlist ) DCNL DCSP if soldict : DCNL DCSP DCSP if isinstance ( soldict , list ) : DCNL DCSP DCSP DCSP soldict = soldict &#91; 0 &#93; DCNL DCSP DCSP subval = soldict.values ( ) DCNL DCSP DCSP if any ( ( t for t in subval ) ) : DCNL DCSP DCSP DCSP onedict = dict ( zip ( symlist , ( &#91; 1 &#93; * 6 ) ) ) DCNL DCSP DCSP DCSP xival = ( ( ( C0 * x ) + ( C1 * func ) ) + C2 ) DCNL DCSP DCSP DCSP etaval = ( ( ( C3 * x ) + ( C4 * func ) ) + C5 ) DCNL DCSP DCSP DCSP xival = xival.subs ( soldict ) DCNL DCSP DCSP DCSP etaval = etaval.subs ( soldict ) DCNL DCSP DCSP DCSP xival = xival.subs ( onedict ) DCNL DCSP DCSP DCSP etaval = etaval.subs ( onedict ) DCNL DCSP DCSP DCSP return &#91; { xi : xival , eta : etaval } &#93;
DCSP axes = f.axes DCNL DCSP if values : DCNL DCSP DCSP axes = &#91; lrange ( len ( a ) ) for a in axes &#93; DCNL DCSP return itertools.product ( * axes )
DCSP try : DCNL DCSP DCSP ( out , _ err ) = execute ( &apos; cat &apos; , file _ path , run _ as _ root = True ) DCNL DCSP DCSP return out DCNL DCSP except processutils.ProcessExecutionError : DCNL DCSP DCSP raise exception.FileNotFound ( file _ path = file _ path )
DCSP print &apos; --------------------------------------- &apos; DCNL DCSP print ( &apos; Processing DCSP % d DCSP sequences DCSP from DCSP % d DCSP samples &apos; % ( len ( DEMO _ SEQUENCES ) , len ( DEMO _ SAMPLE _ MAPPING ) ) ) DCNL DCSP print &apos; --------------------------------------- &apos; DCNL DCSP for ( ix , cur _ seq ) in enumerate ( DEMO _ SEQUENCES ) : DCNL DCSP DCSP barcode = cur _ seq &#91; : 8 &#93; DCNL DCSP DCSP seq _ read = cur _ seq &#91; 8 : &#93; DCNL DCSP DCSP print &apos; --- &gt; DCSP processing DCSP demo DCSP sequence &apos; , ix DCNL DCSP DCSP print &apos; read DCSP barcode DCSP DCSP DCSP DCSP DCSP DCSP : &apos; , barcode DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP corrected _ barcode = decode _ barcode _ 8 ( barcode ) DCNL DCSP DCSP DCSP orig _ sample _ id = DEMO _ SAMPLE _ MAPPING &#91; corrected _ barcode &#93; DCNL DCSP DCSP DCSP if ( corrected _ barcode ! = barcode ) : DCNL DCSP DCSP DCSP DCSP print &apos; * corrected DCSP barcode : &apos; , corrected _ barcode DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP print &apos; -no DCSP error DCSP DCSP barcode : &apos; , corrected _ barcode DCNL DCSP DCSP DCSP print &apos; original DCSP sample DCSP id : &apos; , orig _ sample _ id DCNL DCSP DCSP DCSP print &apos; sequence DCSP read DCSP DCSP DCSP DCSP DCSP : &apos; , seq _ read DCNL DCSP DCSP except ValueError as e : DCNL DCSP DCSP DCSP print &apos; ! &apos; , str ( e ) , &apos; skipping ... &apos; DCNL DCSP DCSP DCSP continue
DCSP ( t , c , k ) = tck DCNL DCSP try : DCNL DCSP DCSP c &#91; 0 &#93; &#91; 0 &#93; DCNL DCSP DCSP parametric = True DCNL DCSP except : DCNL DCSP DCSP parametric = False DCNL DCSP if parametric : DCNL DCSP DCSP return list ( map ( ( lambda c , x = x , t = t , k = k , der = der : splev ( x , &#91; t , c , k &#93; , der , ext ) ) , c ) ) DCNL DCSP else : DCNL DCSP DCSP if ( not ( 0 &lt; = der &lt; = k ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; 0 &lt; = der = % d &lt; = k = % d DCSP must DCSP hold &apos; % ( der , k ) ) ) DCNL DCSP DCSP if ( ext not in ( 0 , 1 , 2 , 3 ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; ext DCSP = DCSP % s DCSP not DCSP in DCSP ( 0 , DCSP 1 , DCSP 2 , DCSP 3 ) DCSP &apos; % ext ) ) DCNL DCSP DCSP x = asarray ( x ) DCNL DCSP DCSP shape = x.shape DCNL DCSP DCSP x = atleast _ 1d ( x ) .ravel ( ) DCNL DCSP DCSP ( y , ier ) = _ fitpack . _ spl _ ( x , der , t , c , k , ext ) DCNL DCSP DCSP if ( ier = = 10 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Invalid DCSP input DCSP data &apos; ) DCNL DCSP DCSP if ( ier = = 1 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Found DCSP x DCSP value DCSP not DCSP in DCSP the DCSP domain &apos; ) DCNL DCSP DCSP if ier : DCNL DCSP DCSP DCSP raise TypeError ( &apos; An DCSP error DCSP occurred &apos; ) DCNL DCSP DCSP return y.reshape ( shape )
DCSP try : DCNL DCSP DCSP streams = fetch _ streams ( plugin ) DCNL DCSP except PluginError as err : DCNL DCSP DCSP console.logger.error ( u &apos; { 0 } &apos; , err ) DCNL DCSP DCSP streams = None DCNL DCSP if ( not streams ) : DCNL DCSP DCSP console.logger.info ( &apos; Waiting DCSP for DCSP streams , DCSP retrying DCSP every DCSP { 0 } DCSP second ( s ) &apos; , args.retry _ streams ) DCNL DCSP while ( not streams ) : DCNL DCSP DCSP sleep ( args.retry _ streams ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP streams = fetch _ streams ( plugin ) DCNL DCSP DCSP except PluginError as err : DCNL DCSP DCSP DCSP console.logger.error ( u &apos; { 0 } &apos; , err ) DCNL DCSP return streams
DCSP pool _ size = int ( os.environ.get ( &apos; GYP _ LINK _ CONCURRENCY &apos; , 0 ) ) DCNL DCSP if pool _ size : DCNL DCSP DCSP return pool _ size DCNL DCSP if ( sys.platform in ( &apos; win32 &apos; , &apos; cygwin &apos; ) ) : DCNL DCSP DCSP import ctypes DCNL DCSP DCSP class MEMORYSTATUSEX ( ctypes.Structure , ) : DCNL DCSP DCSP DCSP _ fields _ = &#91; ( &apos; dwLength &apos; , ctypes.c _ ulong ) , ( &apos; dwMemoryLoad &apos; , ctypes.c _ ulong ) , ( &apos; ullTotalPhys &apos; , ctypes.c _ ulonglong ) , ( &apos; ullAvailPhys &apos; , ctypes.c _ ulonglong ) , ( &apos; ullTotalPageFile &apos; , ctypes.c _ ulonglong ) , ( &apos; ullAvailPageFile &apos; , ctypes.c _ ulonglong ) , ( &apos; ullTotalVirtual &apos; , ctypes.c _ ulonglong ) , ( &apos; ullAvailVirtual &apos; , ctypes.c _ ulonglong ) , ( &apos; sullAvailExtendedVirtual &apos; , ctypes.c _ ulonglong ) &#93; DCNL DCSP DCSP stat = MEMORYSTATUSEX ( ) DCNL DCSP DCSP stat.dwLength = ctypes.sizeof ( stat ) DCNL DCSP DCSP ctypes.windll.kernel32.GlobalMemoryStatusEx ( ctypes.byref ( stat ) ) DCNL DCSP DCSP mem _ limit = max ( 1 , ( stat.ullTotalPhys / ( 5 * ( 2 * * 30 ) ) ) ) DCNL DCSP DCSP hard _ cap = max ( 1 , int ( os.environ.get ( &apos; GYP _ LINK _ CONCURRENCY _ MAX &apos; , ( 2 * * 32 ) ) ) ) DCNL DCSP DCSP return min ( mem _ limit , hard _ cap ) DCNL DCSP elif sys.platform.startswith ( &apos; linux &apos; ) : DCNL DCSP DCSP if os.path.exists ( &apos; / proc / meminfo &apos; ) : DCNL DCSP DCSP DCSP with open ( &apos; / proc / meminfo &apos; ) as meminfo : DCNL DCSP DCSP DCSP DCSP memtotal _ re = re.compile ( &apos; ^ MemTotal : \ \ s * ( \ \ d * ) \ \ s * kB &apos; ) DCNL DCSP DCSP DCSP DCSP for line in meminfo : DCNL DCSP DCSP DCSP DCSP DCSP match = memtotal _ re.match ( line ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP return max ( 1 , ( int ( match.group ( 1 ) ) / ( 8 * ( 2 * * 20 ) ) ) ) DCNL DCSP DCSP return 1 DCNL DCSP elif ( sys.platform = = &apos; darwin &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP avail _ bytes = int ( subprocess.check _ output ( &#91; &apos; sysctl &apos; , &apos; -n &apos; , &apos; hw.memsize &apos; &#93; ) ) DCNL DCSP DCSP DCSP return max ( 1 , ( avail _ bytes / ( 4 * ( 2 * * 30 ) ) ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return 1 DCNL DCSP else : DCNL DCSP DCSP return 1
DCSP locales = Locale.objects.all ( ) DCNL DCSP return render ( request , &apos; wiki / locale _ list.html &apos; , { &apos; locales &apos; : locales } )
DCSP if response.has _ header ( u &apos;Vary &apos; ) : DCNL DCSP DCSP vary _ headers = cc _ delim _ re.split ( response &#91; u &apos;Vary &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP vary _ headers = &#91; &#93; DCNL DCSP existing _ headers = set ( &#91; header.lower ( ) for header in vary _ headers &#93; ) DCNL DCSP additional _ headers = &#91; newheader for newheader in newheaders if ( newheader.lower ( ) not in existing _ headers ) &#93; DCNL DCSP response &#91; u &apos;Vary &apos; &#93; = u &apos; , DCSP &apos; .join ( ( vary _ headers + additional _ headers ) )
DCSP return unencoded _ ampersands _ re.sub ( &apos; &amp; amp ; &apos; , force _ unicode ( value ) )
DCSP wptable = s3db.cap _ warning _ priority DCNL DCSP rows = db ( wptable ) .select ( wptable.name , wptable.urgency , wptable.severity , wptable.certainty , wptable.color _ code , orderby = wptable.name ) DCNL DCSP from gluon.serializers import json as jsons DCNL DCSP from s3 import s3 _ str DCNL DCSP p _ settings = &#91; ( s3 _ str ( T ( r.name ) ) , r.urgency , r.severity , r.certainty , r.color _ code ) for r in rows &#93; DCNL DCSP priority _ conf = s3 _ str ( ( &apos; S3.cap _ priorities = % s &apos; % jsons ( p _ settings ) ) ) DCNL DCSP js _ global = s3.js _ global DCNL DCSP if ( not ( priority _ conf in js _ global ) ) : DCNL DCSP DCSP js _ global.append ( priority _ conf ) DCNL DCSP return
DCSP ( toknum , tokval ) = tok DCNL DCSP if ( ( toknum = = tokenize.OP ) and ( tokval = = &apos; @ &apos; ) ) : DCNL DCSP DCSP return ( tokenize.OP , _ LOCAL _ TAG ) DCNL DCSP return ( toknum , tokval )
DCSP global _ localhost DCNL DCSP if ( _ localhost is None ) : DCNL DCSP DCSP _ localhost = socket.gethostbyname ( &apos; localhost &apos; ) DCNL DCSP return _ localhost
DCSP if isinstance ( lst , string _ types ) : DCNL DCSP DCSP return lst DCNL DCSP else : DCNL DCSP DCSP return &apos; , DCSP &apos; .join ( lst )
DCSP if ( not callable ( key ) ) : DCNL DCSP DCSP key = getter ( key ) DCNL DCSP d = collections.defaultdict ( ( lambda : &#91; &#93; .append ) ) DCNL DCSP for item in seq : DCNL DCSP DCSP d &#91; key ( item ) &#93; ( item ) DCNL DCSP rv = { } DCNL DCSP for ( k , v ) in iteritems ( d ) : DCNL DCSP DCSP rv &#91; k &#93; = v. _ _ self _ _ DCNL DCSP return rv
DCSP client = _ get _ splunk ( profile ) DCNL DCSP search = client.saved _ searches.create ( name , * * kwargs ) DCNL DCSP config = _ _ salt _ _ &#91; &apos; config.option &apos; &#93; ( profile ) DCNL DCSP url = &apos; https : / / { 0 } : { 1 } &apos; .format ( config.get ( &apos; host &apos; ) , config.get ( &apos; port &apos; ) ) DCNL DCSP auth = ( config.get ( &apos; username &apos; ) , config.get ( &apos; password &apos; ) ) DCNL DCSP data = { &apos; owner &apos; : config.get ( &apos; username &apos; ) , &apos; sharing &apos; : &apos; app &apos; , &apos; perms.read &apos; : &apos; * &apos; } DCNL DCSP _ req _ url = &apos; { 0 } / servicesNS / { 1 } / search / saved / searches / { 2 } / acl &apos; .format ( url , config.get ( &apos; username &apos; ) , urllib.quote ( name ) ) DCNL DCSP requests.post ( _ req _ url , auth = auth , verify = True , data = data ) DCNL DCSP return _ get _ splunk _ search _ props ( search )
DCSP if ( not isinstance ( val , basestring ) ) : DCNL DCSP DCSP return val DCNL DCSP result = re.search ( pattern , val ) DCNL DCSP if result : DCNL DCSP DCSP return result.group ( 0 ) DCNL DCSP return u &apos; &apos;
DCSP signal = np.zeros ( 100000 ) DCNL DCSP times = &#91; 1000 , 2500 , 3000 , 5000 , 5250 , 7000 , 7250 , 8000 &#93; DCNL DCSP events = np.zeros ( ( len ( times ) , 3 ) , int ) DCNL DCSP events &#91; : , 2 &#93; = 1 DCNL DCSP events &#91; : , 0 &#93; = times DCNL DCSP signal &#91; events &#91; : , 0 &#93; &#93; = 1.0 DCNL DCSP effect = hann ( 101 ) DCNL DCSP signal = np.convolve ( signal , effect ) &#91; : len ( signal ) &#93; DCNL DCSP raw = RawArray ( signal &#91; np.newaxis , : &#93; , mne.create _ info ( 1 , 100 , &apos; eeg &apos; ) ) DCNL DCSP assert _ allclose ( effect , linear _ regression _ raw ( raw , events , { 1 : 1 } , tmin = 0 ) &#91; 1 &#93; .data.flatten ( ) )
DCSP all _ images = product.images.all ( ) DCNL DCSP main _ image = ( all _ images &#91; 0 &#93; .image if all _ images else None ) DCNL DCSP return get _ thumbnail ( main _ image , size , method )
DCSP tree = Tree ( root _ label , &#91; &#93; ) DCNL DCSP for ( word , postag , chunktag ) in sentence : DCNL DCSP DCSP if ( chunktag is None ) : DCNL DCSP DCSP DCSP if strict : DCNL DCSP DCSP DCSP DCSP raise ValueError ( u &apos;Bad DCSP conll DCSP tag DCSP sequence &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tree.append ( ( word , postag ) ) DCNL DCSP DCSP elif chunktag.startswith ( u &apos;B- &apos; ) : DCNL DCSP DCSP DCSP tree.append ( Tree ( chunktag &#91; 2 : &#93; , &#91; ( word , postag ) &#93; ) ) DCNL DCSP DCSP elif chunktag.startswith ( u &apos;I- &apos; ) : DCNL DCSP DCSP DCSP if ( ( len ( tree ) = = 0 ) or ( not isinstance ( tree &#91; ( -1 ) &#93; , Tree ) ) or ( tree &#91; ( -1 ) &#93; .label ( ) ! = chunktag &#91; 2 : &#93; ) ) : DCNL DCSP DCSP DCSP DCSP if strict : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( u &apos;Bad DCSP conll DCSP tag DCSP sequence &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP tree.append ( Tree ( chunktag &#91; 2 : &#93; , &#91; ( word , postag ) &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tree &#91; ( -1 ) &#93; .append ( ( word , postag ) ) DCNL DCSP DCSP elif ( chunktag = = u &apos;O &apos; ) : DCNL DCSP DCSP DCSP tree.append ( ( word , postag ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( u &apos;Bad DCSP conll DCSP tag DCSP { 0 ! r } &apos; .format ( chunktag ) ) DCNL DCSP return tree
DCSP if ( not port ) : DCNL DCSP DCSP port = ( 443 if ssl else 80 ) DCNL DCSP if ssl : DCNL DCSP DCSP conn = HTTPSConnection ( ( &apos; % s : % s &apos; % ( ipaddr , port ) ) ) DCNL DCSP else : DCNL DCSP DCSP conn = BufferedHTTPConnection ( ( &apos; % s : % s &apos; % ( ipaddr , port ) ) ) DCNL DCSP if query _ string : DCNL DCSP DCSP path + = ( &apos; ? &apos; + query _ string ) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest ( method , path , skip _ host = ( headers and ( &apos; Host &apos; in headers ) ) ) DCNL DCSP if headers : DCNL DCSP DCSP for ( header , value ) in headers.items ( ) : DCNL DCSP DCSP DCSP conn.putheader ( header , str ( value ) ) DCNL DCSP conn.endheaders ( ) DCNL DCSP return conn
DCSP N = len ( nums _ actions ) DCNL DCSP if ( N = = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; nums _ actions DCSP must DCSP be DCSP non-empty &apos; ) DCNL DCSP random _ state = check _ random _ state ( random _ state ) DCNL DCSP players = &#91; Player ( random _ state.random _ sample ( ( nums _ actions &#91; i : &#93; + nums _ actions &#91; : i &#93; ) ) ) for i in range ( N ) &#93; DCNL DCSP g = NormalFormGame ( players ) DCNL DCSP return g
DCSP ip _ wrapper = IPWrapper ( namespace = namespace ) DCNL DCSP interfaces = ip _ wrapper.netns.execute ( &#91; &apos; ip &apos; , &apos; -d &apos; , &apos; link &apos; , &apos; list &apos; &#93; , check _ exit _ code = True ) DCNL DCSP return ( ( &apos; 802.1Q DCSP id DCSP % s DCSP &apos; % segmentation _ id ) in interfaces )
DCSP dbutils.close _ cn ( context.cn ) DCNL DCSP dbutils.drop _ db ( context.conf &#91; u &apos;host &apos; &#93; , context.conf &#91; u &apos;user &apos; &#93; , context.conf &#91; u &apos;pass &apos; &#93; , context.conf &#91; u &apos;dbname &apos; &#93; ) DCNL DCSP for ( k , v ) in context.pgenv.items ( ) : DCNL DCSP DCSP if ( ( k in os.environ ) and ( v is None ) ) : DCNL DCSP DCSP DCSP del os.environ &#91; k &#93; DCNL DCSP DCSP elif v : DCNL DCSP DCSP DCSP os.environ &#91; k &#93; = v
DCSP if isinstance ( a , basestring ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % encode _ entities ( a ) ) DCNL DCSP if isinstance ( a , bool ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % ( &apos; no &apos; , &apos; yes &apos; ) &#91; int ( a ) &#93; ) DCNL DCSP if isinstance ( a , ( int , long ) ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % a ) DCNL DCSP if isinstance ( a , float ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % round ( a , 5 ) ) DCNL DCSP if isinstance ( a , type ( None ) ) : DCNL DCSP DCSP return &apos; &quot; &quot; &apos; DCNL DCSP if isinstance ( a , Date ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % str ( a ) ) DCNL DCSP if isinstance ( a , datetime.datetime ) : DCNL DCSP DCSP return ( &apos; &quot; % s &quot; &apos; % str ( date ( mktime ( a.timetuple ( ) ) ) ) )
DCSP dep _ dir = os.path.join ( client _ dir , &apos; deps &apos; ) DCNL DCSP prof _ dir = os.path.join ( client _ dir , &apos; profilers &apos; ) DCNL DCSP temp _ dir = tempfile.mkdtemp ( ) DCNL DCSP try : DCNL DCSP DCSP base _ packages.check _ diskspace ( temp _ dir ) DCNL DCSP except error.RepoDiskFullError as e : DCNL DCSP DCSP print ( &apos; Temp DCSP destination DCSP for DCSP packages DCSP is DCSP full DCSP % s , DCSP aborting DCSP upload : DCSP % s &apos; % ( temp _ dir , e ) ) DCNL DCSP DCSP os.rmdir ( temp _ dir ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP tests _ list = get _ subdir _ list ( &apos; tests &apos; , client _ dir ) DCNL DCSP tests = &apos; , &apos; .join ( tests _ list ) DCNL DCSP site _ tests _ list = get _ subdir _ list ( &apos; site _ tests &apos; , client _ dir ) DCNL DCSP site _ tests = &apos; , &apos; .join ( site _ tests _ list ) DCNL DCSP deps _ list = get _ subdir _ list ( &apos; deps &apos; , client _ dir ) DCNL DCSP deps = &apos; , &apos; .join ( deps _ list ) DCNL DCSP profilers _ list = get _ subdir _ list ( &apos; profilers &apos; , client _ dir ) DCNL DCSP profilers = &apos; , &apos; .join ( profilers _ list ) DCNL DCSP if ( not remove ) : DCNL DCSP DCSP tar _ packages ( pkgmgr , &apos; profiler &apos; , profilers , prof _ dir , temp _ dir ) DCNL DCSP DCSP tar _ packages ( pkgmgr , &apos; dep &apos; , deps , dep _ dir , temp _ dir ) DCNL DCSP DCSP tar _ packages ( pkgmgr , &apos; test &apos; , site _ tests , client _ dir , temp _ dir ) DCNL DCSP DCSP tar _ packages ( pkgmgr , &apos; test &apos; , tests , client _ dir , temp _ dir ) DCNL DCSP DCSP tar _ packages ( pkgmgr , &apos; client &apos; , &apos; autotest &apos; , client _ dir , temp _ dir ) DCNL DCSP DCSP cwd = os.getcwd ( ) DCNL DCSP DCSP os.chdir ( temp _ dir ) DCNL DCSP DCSP client _ utils.system ( &apos; md5sum DCSP * DCSP &gt; DCSP packages.checksum &apos; ) DCNL DCSP DCSP os.chdir ( cwd ) DCNL DCSP DCSP pkgmgr.upload _ pkg ( temp _ dir ) DCNL DCSP DCSP client _ utils.run ( ( &apos; rm DCSP -rf DCSP &apos; + temp _ dir ) ) DCNL DCSP else : DCNL DCSP DCSP process _ packages ( pkgmgr , &apos; test &apos; , tests , client _ dir , remove = remove ) DCNL DCSP DCSP process _ packages ( pkgmgr , &apos; test &apos; , site _ tests , client _ dir , remove = remove ) DCNL DCSP DCSP process _ packages ( pkgmgr , &apos; client &apos; , &apos; autotest &apos; , client _ dir , remove = remove ) DCNL DCSP DCSP process _ packages ( pkgmgr , &apos; dep &apos; , deps , dep _ dir , remove = remove ) DCNL DCSP DCSP process _ packages ( pkgmgr , &apos; profiler &apos; , profilers , prof _ dir , remove = remove )
DCSP keys = table.keys ( ) DCNL DCSP qf = table &#91; query &#93; DCNL DCSP scores = numpy.dot ( qf , wordvecs.T ) .flatten ( ) DCNL DCSP sorted _ args = numpy.argsort ( scores ) &#91; : : ( -1 ) &#93; DCNL DCSP words = &#91; keys &#91; a &#93; for a in sorted _ args &#91; : k &#93; &#93; DCNL DCSP print ( &apos; QUERY : DCSP &apos; + query ) DCNL DCSP print &apos; NEAREST : DCSP &apos; DCNL DCSP for ( i , w ) in enumerate ( words ) : DCNL DCSP DCSP print w
DCSP if isinstance ( filename , list ) : DCNL DCSP DCSP filename = filename &#91; 0 &#93; DCNL DCSP ( path , name ) = os.path.split ( filename ) DCNL DCSP if re.search ( u &apos; ( _ 0x &#91; a-z0-9 &#93; { 32 } ) &apos; , name ) : DCNL DCSP DCSP hashvalue = re.findall ( u &apos; ( _ 0x &#91; a-z0-9 &#93; { 32 } ) &apos; , name ) DCNL DCSP DCSP return ( True , hashvalue ) DCNL DCSP else : DCNL DCSP DCSP return ( False , None )
DCSP if context.is _ admin : DCNL DCSP DCSP return True DCNL DCSP if ( context.owner is None ) : DCNL DCSP DCSP return False DCNL DCSP return ( namespace _ property.namespace.owner = = context.owner )
DCSP log = logging.getLogger ( &apos; grizzled.os.daemon &apos; ) DCNL DCSP def _ _ fork ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return _ os.fork ( ) DCNL DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP raise DaemonError , ( &apos; Cannot DCSP fork &apos; , e.errno , e.strerror ) DCNL DCSP def _ _ redirect _ file _ descriptors ( ) : DCNL DCSP DCSP import resource DCNL DCSP DCSP maxfd = resource.getrlimit ( resource.RLIMIT _ NOFILE ) &#91; 1 &#93; DCNL DCSP DCSP if ( maxfd = = resource.RLIM _ INFINITY ) : DCNL DCSP DCSP DCSP maxfd = MAXFD DCNL DCSP DCSP for fd in range ( 0 , maxfd ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP _ os.ttyname ( fd ) DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP _ os.close ( fd ) DCNL DCSP DCSP DCSP except OSError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP _ os.open ( NULL _ DEVICE , _ os.O _ RDWR ) DCNL DCSP DCSP DCSP _ os.dup2 ( 0 , 1 ) DCNL DCSP DCSP DCSP _ os.dup2 ( 0 , 2 ) DCNL DCSP if ( _ os.name ! = &apos; posix &apos; ) : DCNL DCSP DCSP import errno DCNL DCSP DCSP raise DaemonError , ( &apos; daemonize ( ) DCSP is DCSP only DCSP supported DCSP on DCSP Posix-compliant DCSP systems . &apos; , errno.ENOSYS , _ os.strerror ( errno.ENOSYS ) ) DCNL DCSP try : DCNL DCSP DCSP log.debug ( &apos; Forking DCSP first DCSP child . &apos; ) DCNL DCSP DCSP pid = _ _ fork ( ) DCNL DCSP DCSP if ( pid ! = 0 ) : DCNL DCSP DCSP DCSP _ os . _ exit ( 0 ) DCNL DCSP DCSP log.debug ( &apos; Creating DCSP new DCSP session &apos; ) DCNL DCSP DCSP _ os.setsid ( ) DCNL DCSP DCSP log.debug ( &apos; Forking DCSP second DCSP child . &apos; ) DCNL DCSP DCSP pid = _ _ fork ( ) DCNL DCSP DCSP if ( pid ! = 0 ) : DCNL DCSP DCSP DCSP _ os . _ exit ( 0 ) DCNL DCSP DCSP log.debug ( &apos; Setting DCSP umask &apos; ) DCNL DCSP DCSP _ os.umask ( UMASK ) DCNL DCSP DCSP log.debug ( ( &apos; Changing DCSP working DCSP directory DCSP to DCSP &quot; % s &quot; &apos; % WORKDIR ) ) DCNL DCSP DCSP _ os.chdir ( WORKDIR ) DCNL DCSP DCSP if ( not no _ close ) : DCNL DCSP DCSP DCSP log.debug ( &apos; Redirecting DCSP file DCSP descriptors &apos; ) DCNL DCSP DCSP DCSP _ _ redirect _ file _ descriptors ( ) DCNL DCSP DCSP if pidfile : DCNL DCSP DCSP DCSP from string import Template DCNL DCSP DCSP DCSP t = Template ( pidfile ) DCNL DCSP DCSP DCSP pidfile = t.safe _ substitute ( pid = str ( _ os.getpid ( ) ) ) DCNL DCSP DCSP DCSP open ( pidfile , &apos; w &apos; ) .write ( ( str ( _ os.getpid ( ) ) + &apos; \ n &apos; ) ) DCNL DCSP except DaemonError : DCNL DCSP DCSP raise DCNL DCSP except OSError as e : DCNL DCSP DCSP raise DaemonError , ( &apos; Unable DCSP to DCSP daemonize ( ) &apos; , e.errno , e.strerror )
DCSP raise exceptions.MpdNotImplemented
DCSP lam = min ( ( 10 * lam _ min ) , lam _ max ) DCNL DCSP params = start.copy ( ) DCNL DCSP gval = grad ( params ) DCNL DCSP obj _ hist = &#91; func ( params ) &#93; DCNL DCSP for itr in range ( int ( maxiter ) ) : DCNL DCSP DCSP df = ( params - gval ) DCNL DCSP DCSP project ( df ) DCNL DCSP DCSP df - = params DCNL DCSP DCSP if ( np.max ( np.abs ( df ) ) &lt; ctol ) : DCNL DCSP DCSP DCSP return Bunch ( * * { &apos; Converged &apos; : True , &apos; params &apos; : params , &apos; objective _ values &apos; : obj _ hist , &apos; Message &apos; : &apos; Converged DCSP successfully &apos; } ) DCNL DCSP DCSP d = ( params - ( lam * gval ) ) DCNL DCSP DCSP project ( d ) DCNL DCSP DCSP d - = params DCNL DCSP DCSP ( alpha , params1 , fval , gval1 ) = _ nmono _ linesearch ( func , grad , params , d , obj _ hist , M = M , sig1 = sig1 , sig2 = sig2 , gam = gam , maxiter = maxiter _ nmls ) DCNL DCSP DCSP if ( alpha is None ) : DCNL DCSP DCSP DCSP return Bunch ( * * { &apos; Converged &apos; : False , &apos; params &apos; : params , &apos; objective _ values &apos; : obj _ hist , &apos; Message &apos; : &apos; Failed DCSP in DCSP nmono _ linesearch &apos; } ) DCNL DCSP DCSP obj _ hist.append ( fval ) DCNL DCSP DCSP s = ( params1 - params ) DCNL DCSP DCSP y = ( gval1 - gval ) DCNL DCSP DCSP sy = ( s * y ) .sum ( ) DCNL DCSP DCSP if ( sy &lt; = 0 ) : DCNL DCSP DCSP DCSP lam = lam _ max DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ss = ( s * s ) .sum ( ) DCNL DCSP DCSP DCSP lam = max ( lam _ min , min ( ( ss / sy ) , lam _ max ) ) DCNL DCSP DCSP params = params1 DCNL DCSP DCSP gval = gval1 DCNL DCSP return Bunch ( * * { &apos; Converged &apos; : False , &apos; params &apos; : params , &apos; objective _ values &apos; : obj _ hist , &apos; Message &apos; : &apos; spg _ optim DCSP did DCSP not DCSP converge &apos; } )
DCSP return _ global _ options
DCSP may _ overlap = builder.and _ ( builder.icmp _ unsigned ( &apos; &lt; &apos; , a _ start , b _ end ) , builder.icmp _ unsigned ( &apos; &lt; &apos; , b _ start , a _ end ) ) DCNL DCSP return may _ overlap
DCSP try : DCNL DCSP DCSP return ( _ read _ link ( name ) = = path ) DCNL DCSP except OSError : DCNL DCSP DCSP return False
DCSP models = ( ArtifactDependency , ArtifactBlobLocation , ArtifactBlob , ArtifactProperty , ArtifactTag , Artifact ) DCNL DCSP for model in models : DCNL DCSP DCSP model.metadata.drop _ all ( engine )
DCSP originals = { } DCNL DCSP try : DCNL DCSP DCSP for ( attr , default ) in ( ( &apos; meta _ path &apos; , &#91; &#93; ) , ( &apos; path &apos; , &#91; &#93; ) , ( &apos; path _ hooks &apos; , &#91; &#93; ) , ( &apos; path _ importer _ cache &apos; , { } ) ) : DCNL DCSP DCSP DCSP originals &#91; attr &#93; = getattr ( sys , attr ) DCNL DCSP DCSP DCSP if ( attr in kwargs ) : DCNL DCSP DCSP DCSP DCSP new _ value = kwargs &#91; attr &#93; DCNL DCSP DCSP DCSP DCSP del kwargs &#91; attr &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP new _ value = default DCNL DCSP DCSP DCSP setattr ( sys , attr , new _ value ) DCNL DCSP DCSP if len ( kwargs ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; unrecognized DCSP arguments : DCSP { 0 } &apos; .format ( kwargs.keys ( ) ) ) DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP for ( attr , value ) in originals.items ( ) : DCNL DCSP DCSP DCSP setattr ( sys , attr , value )
DCSP codegen = TrackingCodeGenerator ( ast.environment ) DCNL DCSP codegen.visit ( ast ) DCNL DCSP return codegen.undeclared _ identifiers
DCSP decoded _ value = base64.b64decode ( value ) DCNL DCSP return datastore _ types.Blob ( decoded _ value )
DCSP if ( ( instr is None ) or isinstance ( instr , six.text _ type ) ) : DCNL DCSP DCSP return instr DCNL DCSP else : DCNL DCSP DCSP return six.text _ type ( instr , u &apos;mbcs &apos; )
DCSP orders = { } DCNL DCSP for arg in request.args : DCNL DCSP DCSP re _ match = re.findall ( &apos; _ oc _ ( . * ) &apos; , arg ) DCNL DCSP DCSP if re _ match : DCNL DCSP DCSP DCSP orders &#91; re _ match &#91; 0 &#93; &#93; = ( request.args.get ( arg ) , request.args.get ( ( &apos; _ od _ &apos; + re _ match &#91; 0 &#93; ) ) ) DCNL DCSP return orders
DCSP if ( auth.permission.format ! = &apos; s3json &apos; ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( r.method ! = &apos; options &apos; ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3 _ rest _ controller ( &apos; hrm &apos; , &apos; human _ resource &apos; )
DCSP return IMPL.service _ get ( context , service _ id , backend _ match _ level , * * filters )
DCSP server _ dir = os.path.dirname ( os.path.abspath ( _ _ file _ _ ) ) DCNL DCSP return os.path.join ( server _ dir , &apos; control _ segments &apos; , name )
DCSP content _ location = Transcript.asset _ location ( location , name ) DCNL DCSP content = StaticContent ( content _ location , name , mime _ type , content ) DCNL DCSP contentstore ( ) .save ( content ) DCNL DCSP return content _ location
DCSP mkQApp ( ) DCNL DCSP from . import console DCNL DCSP c = console.ConsoleWidget ( * args , * * kwds ) DCNL DCSP c.catchAllExceptions ( ) DCNL DCSP c.show ( ) DCNL DCSP global consoles DCNL DCSP try : DCNL DCSP DCSP consoles.append ( c ) DCNL DCSP except NameError : DCNL DCSP DCSP consoles = &#91; c &#93; DCNL DCSP return c
DCSP global _ RACE _ PROTECTION DCNL DCSP if _ RACE _ PROTECTION : DCNL DCSP DCSP return DCNL DCSP _ RACE _ PROTECTION = True DCNL DCSP try : DCNL DCSP DCSP return filter ( None , &#91; find _ related _ module ( app , &apos; tasks &apos; ) for app in settings.INSTALLED _ APPS &#93; ) DCNL DCSP finally : DCNL DCSP DCSP _ RACE _ PROTECTION = False
DCSP try : DCNL DCSP DCSP the _ watcher = ffi.from _ handle ( handle ) DCNL DCSP DCSP args = the _ watcher.args DCNL DCSP DCSP if ( args is None ) : DCNL DCSP DCSP DCSP args = _ NOARGS DCNL DCSP DCSP if ( ( len ( args ) &gt; 0 ) and ( args &#91; 0 &#93; = = GEVENT _ CORE _ EVENTS ) ) : DCNL DCSP DCSP DCSP args = ( ( revents , ) + args &#91; 1 : &#93; ) DCNL DCSP DCSP the _ watcher.callback ( * args ) DCNL DCSP except : DCNL DCSP DCSP the _ watcher . _ exc _ info = sys.exc _ info ( ) DCNL DCSP DCSP the _ watcher.loop. _ keepaliveset.add ( the _ watcher ) DCNL DCSP DCSP return ( -1 ) DCNL DCSP else : DCNL DCSP DCSP if ( the _ watcher in the _ watcher.loop. _ keepaliveset ) : DCNL DCSP DCSP DCSP return 0 DCNL DCSP DCSP return 1
DCSP example _ file = os.path.join ( target _ dir , fname ) DCNL DCSP build _ target = os.path.relpath ( target _ dir , gallery _ conf &#91; &apos; src _ dir &apos; &#93; ) DCNL DCSP backrefs = scan _ used _ functions ( example _ file , gallery _ conf ) DCNL DCSP for backref in backrefs : DCNL DCSP DCSP include _ path = os.path.join ( gallery _ conf &#91; &apos; src _ dir &apos; &#93; , gallery _ conf &#91; &apos; mod _ example _ dir &apos; &#93; , ( &apos; % s.examples &apos; % backref ) ) DCNL DCSP DCSP seen = ( backref in seen _ backrefs ) DCNL DCSP DCSP with open ( include _ path , ( &apos; a &apos; if seen else &apos; w &apos; ) ) as ex _ file : DCNL DCSP DCSP DCSP if ( not seen ) : DCNL DCSP DCSP DCSP DCSP heading = ( &apos; \ n \ nExamples DCSP using DCSP `` % s`` &apos; % backref ) DCNL DCSP DCSP DCSP DCSP ex _ file.write ( ( heading + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP DCSP ex _ file.write ( ( ( &apos; ^ &apos; * len ( heading ) ) + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP ex _ file.write ( _ thumbnail _ div ( build _ target , fname , snippet , is _ backref = True ) ) DCNL DCSP DCSP DCSP seen _ backrefs.add ( backref )
DCSP def fixup ( m ) : DCNL DCSP DCSP text = m.group ( 0 ) DCNL DCSP DCSP if ( text &#91; : 2 &#93; = = &apos; &amp; # &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( text &#91; : 3 &#93; = = &apos; &amp; # x &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP return unichr ( int ( text &#91; 3 : ( -1 ) &#93; , 16 ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return unichr ( int ( text &#91; 2 : ( -1 ) &#93; ) ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP text = unichr ( htmlentitydefs.name2codepoint &#91; text &#91; 1 : ( -1 ) &#93; &#93; ) DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP return text DCNL DCSP return re.sub ( &apos; &amp; # ? \ \ w + ; &apos; , fixup , text )
DCSP try : DCNL DCSP DCSP base _ path = sys . _ MEIPASS DCNL DCSP except Exception : DCNL DCSP DCSP return False DCNL DCSP return True
DCSP if ( not hasattr ( lexer , &apos; tokens &apos; ) ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP if ( &apos; keywords &apos; in lexer.tokens ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return lexer.tokens &#91; &apos; keywords &apos; &#93; &#91; 0 &#93; &#91; 0 &#93; .words DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP keywords = &#91; &#93; DCNL DCSP for vals in lexer.tokens.values ( ) : DCNL DCSP DCSP for val in vals : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if isinstance ( val &#91; 0 &#93; , words ) : DCNL DCSP DCSP DCSP DCSP DCSP keywords.extend ( val &#91; 0 &#93; .words ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP ini _ val = val &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( ( &apos; ) \ \ b &apos; in val &#91; 0 &#93; ) or ( &apos; ) ( \ \ s + ) &apos; in val &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP val = re.sub ( &apos; \ \ \ \ . &apos; , &apos; &apos; , val &#91; 0 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP val = re.sub ( &apos; &#91; ^ 0-9a-zA-Z &#124; &#93; + &apos; , &apos; &apos; , val ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( &apos; &#124; &apos; in ini _ val ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP keywords.extend ( val.split ( &apos; &#124; &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP keywords.append ( val ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP return keywords
DCSP if exact : DCNL DCSP DCSP if ( n &lt; ( 1 - k ) ) : DCNL DCSP DCSP DCSP return 0 DCNL DCSP DCSP if ( n &lt; = 0 ) : DCNL DCSP DCSP DCSP return 1 DCNL DCSP DCSP val = 1 DCNL DCSP DCSP for j in xrange ( n , 0 , ( - k ) ) : DCNL DCSP DCSP DCSP val = ( val * j ) DCNL DCSP DCSP return val DCNL DCSP else : DCNL DCSP DCSP raise NotImplementedError
DCSP if isinstance ( model _ string , string _ types ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( app _ label , model _ name ) = model _ string.split ( u &apos; . &apos; ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP if ( default _ app is not None ) : DCNL DCSP DCSP DCSP DCSP app _ label = default _ app DCNL DCSP DCSP DCSP DCSP model _ name = model _ string DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise ValueError ( u &apos;Can DCSP not DCSP resolve DCSP { 0 ! r } DCSP into DCSP a DCSP model . DCSP Model DCSP names DCSP should DCSP be DCSP in DCSP the DCSP form DCSP app _ label.model _ name &apos; .format ( model _ string ) , model _ string ) DCNL DCSP DCSP return apps.get _ model ( app _ label , model _ name ) DCNL DCSP elif ( isinstance ( model _ string , type ) and issubclass ( model _ string , Model ) ) : DCNL DCSP DCSP return model _ string DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( u &apos;Can DCSP not DCSP resolve DCSP { 0 ! r } DCSP into DCSP a DCSP model &apos; .format ( model _ string ) , model _ string )
DCSP cmd = &apos; { 0 } DCSP -f DCSP restart DCSP { 1 } &apos; .format ( _ cmd ( ) , name ) DCNL DCSP return ( not _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( cmd ) )
DCSP if ( VCR _ RECORD _ MODE = = u &apos;off &apos; ) : DCNL DCSP DCSP ( yield None ) DCNL DCSP else : DCNL DCSP DCSP module = request.module. _ _ name _ _ .split ( u &apos;tests . &apos; ) &#91; ( -1 ) &#93; DCNL DCSP DCSP class _ name = request.cls. _ _ name _ _ DCNL DCSP DCSP cassette _ name = u &apos; . &apos; .join ( &#91; module , class _ name , request.function. _ _ name _ _ &#93; ) DCNL DCSP DCSP cassette _ path = os.path.join ( VCR _ CASSETTE _ DIR , cassette _ name ) DCNL DCSP DCSP online = True DCNL DCSP DCSP if ( vcr.record _ mode = = u &apos;none &apos; ) : DCNL DCSP DCSP DCSP online = False DCNL DCSP DCSP elif ( vcr.record _ mode = = u &apos;once &apos; ) : DCNL DCSP DCSP DCSP online = ( not os.path.exists ( cassette _ path ) ) DCNL DCSP DCSP if ( not online ) : DCNL DCSP DCSP DCSP log.debug ( u &apos;Disabling DCSP domain DCSP limiters DCSP during DCSP VCR DCSP playback . &apos; ) DCNL DCSP DCSP DCSP monkeypatch.setattr ( u &apos;flexget.utils.requests.limit _ domains &apos; , mock.Mock ( ) ) DCNL DCSP DCSP with vcr.use _ cassette ( path = cassette _ path ) as cassette : DCNL DCSP DCSP DCSP ( yield cassette )
DCSP if ( len ( loop ) &lt; 1 ) : DCNL DCSP DCSP return &#91; &#91; &#93; &#93; DCNL DCSP derivation = BottomDerivation ( elementNode , prefix ) DCNL DCSP targetMatrix = matrix.getBranchMatrixSetElementNode ( elementNode ) DCNL DCSP transformedLoop = matrix.getTransformedVector3s ( matrix.getIdentityTetragrid ( targetMatrix.tetragrid ) , loop ) DCNL DCSP lift = ( ( derivation.altitude + derivation.getAdditionalPathLift ( ) ) - euclidean.getBottomByPath ( transformedLoop ) ) DCNL DCSP for point in loop : DCNL DCSP DCSP point.z + = lift DCNL DCSP return &#91; loop &#93;
DCSP def decorator ( func ) : DCNL DCSP DCSP @ wraps ( func ) DCNL DCSP DCSP def wrapper ( * a , * * explicit ) : DCNL DCSP DCSP DCSP deps = dict ( &#91; ( k , get _ dependency _ for ( k , v ) ) for ( k , v ) in dependencies.iteritems ( ) if ( k not in explicit ) &#93; ) DCNL DCSP DCSP DCSP return func ( * a , * * union ( deps , explicit ) ) DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP python = XML.SubElement ( xml _ parent , &apos; hudson.plugins.python.Python &apos; ) DCNL DCSP XML.SubElement ( python , &apos; command &apos; ) .text = data
DCSP config = RawConfigParser ( ) DCNL DCSP cli _ conf = options.config DCNL DCSP local _ dir = os.curdir DCNL DCSP if ( USER _ CONFIG and os.path.isfile ( USER _ CONFIG ) ) : DCNL DCSP DCSP if options.verbose : DCNL DCSP DCSP DCSP print ( &apos; user DCSP configuration : DCSP % s &apos; % USER _ CONFIG ) DCNL DCSP DCSP config.read ( USER _ CONFIG ) DCNL DCSP parent = tail = ( args and os.path.abspath ( os.path.commonprefix ( args ) ) ) DCNL DCSP while tail : DCNL DCSP DCSP if config.read ( ( os.path.join ( parent , fn ) for fn in PROJECT _ CONFIG ) ) : DCNL DCSP DCSP DCSP local _ dir = parent DCNL DCSP DCSP DCSP if options.verbose : DCNL DCSP DCSP DCSP DCSP print ( &apos; local DCSP configuration : DCSP in DCSP % s &apos; % parent ) DCNL DCSP DCSP DCSP break DCNL DCSP DCSP ( parent , tail ) = os.path.split ( parent ) DCNL DCSP if ( cli _ conf and os.path.isfile ( cli _ conf ) ) : DCNL DCSP DCSP if options.verbose : DCNL DCSP DCSP DCSP print ( &apos; cli DCSP configuration : DCSP % s &apos; % cli _ conf ) DCNL DCSP DCSP config.read ( cli _ conf ) DCNL DCSP pep8 _ section = parser.prog DCNL DCSP if config.has _ section ( pep8 _ section ) : DCNL DCSP DCSP option _ list = dict ( &#91; ( o.dest , ( o.type or o.action ) ) for o in parser.option _ list &#93; ) DCNL DCSP DCSP ( new _ options , _ _ ) = parser.parse _ args ( &#91; &#93; ) DCNL DCSP DCSP for opt in config.options ( pep8 _ section ) : DCNL DCSP DCSP DCSP if ( opt.replace ( &apos; _ &apos; , &apos; -&apos; ) not in parser.config _ options ) : DCNL DCSP DCSP DCSP DCSP print ( &quot; DCSP DCSP unknown DCSP option DCSP &apos; % s &apos; DCSP ignored &quot; % opt ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( options.verbose &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP print ( &apos; DCSP DCSP % s DCSP = DCSP % s &apos; % ( opt , config.get ( pep8 _ section , opt ) ) ) DCNL DCSP DCSP DCSP normalized _ opt = opt.replace ( &apos; -&apos; , &apos; _ &apos; ) DCNL DCSP DCSP DCSP opt _ type = option _ list &#91; normalized _ opt &#93; DCNL DCSP DCSP DCSP if ( opt _ type in ( &apos; int &apos; , &apos; count &apos; ) ) : DCNL DCSP DCSP DCSP DCSP value = config.getint ( pep8 _ section , opt ) DCNL DCSP DCSP DCSP elif ( opt _ type = = &apos; string &apos; ) : DCNL DCSP DCSP DCSP DCSP value = config.get ( pep8 _ section , opt ) DCNL DCSP DCSP DCSP DCSP if ( normalized _ opt = = &apos; exclude &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP value = normalize _ paths ( value , local _ dir ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( opt _ type in ( &apos; store _ true &apos; , &apos; store _ false &apos; ) ) DCNL DCSP DCSP DCSP DCSP value = config.getboolean ( pep8 _ section , opt ) DCNL DCSP DCSP DCSP setattr ( new _ options , normalized _ opt , value ) DCNL DCSP DCSP ( options , _ _ ) = parser.parse _ args ( arglist , values = new _ options ) DCNL DCSP options.doctest = options.testsuite = False DCNL DCSP return options
DCSP if ( not _ tk _ type ) : DCNL DCSP DCSP _ init _ tk _ type ( ) DCNL DCSP return ( ( _ tk _ type = = &apos; cocoa &apos; ) or ( _ tk _ type = = &apos; carbon &apos; ) )
DCSP return result
DCSP return sequence ( ( _ disable _ flocker _ systemd ( ) + &#91; _ uninstall _ flocker _ ubuntu ( ) &#93; ) )
DCSP data = action.split ( &apos; : &apos; , 1 ) &#91; 0 &#93; .split ( &apos; _ &apos; , 1 ) DCNL DCSP return ( ( &apos; % ss &apos; % data &#91; ( -1 ) &#93; ) , ( data &#91; 0 &#93; ! = &apos; get &apos; ) )
DCSP pip _ bin = _ get _ pip _ bin ( bin _ env ) DCNL DCSP cmd = &#91; pip _ bin , &apos; freeze &apos; &#93; DCNL DCSP min _ version = &apos; 8.0.3 &apos; DCNL DCSP cur _ version = version ( bin _ env ) DCNL DCSP if ( not salt.utils.compare _ versions ( ver1 = cur _ version , oper = &apos; &gt; = &apos; , ver2 = min _ version ) ) : DCNL DCSP DCSP logger.warning ( &apos; The DCSP version DCSP of DCSP pip DCSP installed DCSP is DCSP { 0 } , DCSP which DCSP is DCSP older DCSP than DCSP { 1 } . DCSP The DCSP packages DCSP pip , DCSP wheel , DCSP setuptools , DCSP and DCSP distribute DCSP will DCSP not DCSP be DCSP included DCSP in DCSP the DCSP output DCSP of DCSP pip.freeze &apos; .format ( cur _ version , min _ version ) ) DCNL DCSP else : DCNL DCSP DCSP cmd.append ( &apos; --all &apos; ) DCNL DCSP cmd _ kwargs = dict ( runas = user , cwd = cwd , use _ vt = use _ vt , python _ shell = False ) DCNL DCSP if ( bin _ env and os.path.isdir ( bin _ env ) ) : DCNL DCSP DCSP cmd _ kwargs &#91; &apos; env &apos; &#93; = { &apos; VIRTUAL _ ENV &apos; : bin _ env } DCNL DCSP result = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , * * cmd _ kwargs ) DCNL DCSP if ( result &#91; &apos; retcode &apos; &#93; &gt; 0 ) : DCNL DCSP DCSP raise CommandExecutionError ( result &#91; &apos; stderr &apos; &#93; ) DCNL DCSP return result &#91; &apos; stdout &apos; &#93; .splitlines ( )
DCSP part = part.strip ( ) DCNL DCSP match = PARSE _ QUERY _ PART _ REGEX.match ( part ) DCNL DCSP assert match DCNL DCSP negate = bool ( match.group ( 1 ) ) DCNL DCSP key = match.group ( 2 ) DCNL DCSP term = match.group ( 3 ) .replace ( &apos; \ \ : &apos; , &apos; : &apos; ) DCNL DCSP for ( pre , query _ class ) in prefixes.items ( ) : DCNL DCSP DCSP if term.startswith ( pre ) : DCNL DCSP DCSP DCSP return ( key , term &#91; len ( pre ) : &#93; , query _ class , negate ) DCNL DCSP query _ class = query _ classes.get ( key , default _ class ) DCNL DCSP return ( key , term , query _ class , negate )
DCSP if ( klass ! = Logger ) : DCNL DCSP DCSP if ( not issubclass ( klass , Logger ) ) : DCNL DCSP DCSP DCSP raise TypeError ( ( &apos; logger DCSP not DCSP derived DCSP from DCSP logging.Logger : DCSP &apos; + klass . _ _ name _ _ ) ) DCNL DCSP global _ loggerClass DCNL DCSP _ loggerClass = klass
DCSP _ print _ floating _ ip _ list ( &#91; cs.floating _ ips.create ( pool = args.pool ) &#93; )
DCSP def do _ something _ with ( _ ) : DCNL DCSP DCSP pass DCNL DCSP for dataset in client.list _ datasets ( ) : DCNL DCSP DCSP do _ something _ with ( dataset )
DCSP cppextbase = XML.SubElement ( xml _ parent , &apos; org.jenkinsci.plugins.cppcheck.CppcheckPublisher &apos; ) DCNL DCSP cppextbase.set ( &apos; plugin &apos; , &apos; cppcheck &apos; ) DCNL DCSP cppext = XML.SubElement ( cppextbase , &apos; cppcheckConfig &apos; ) DCNL DCSP mappings = &#91; ( &apos; pattern &apos; , &apos; pattern &apos; , None ) , ( &apos; ignoreblankfiles &apos; , &apos; ignoreBlankFiles &apos; , False ) , ( &apos; allow-no-report &apos; , &apos; allowNoReport &apos; , False ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( cppext , data , mappings , fail _ required = True ) DCNL DCSP csev = XML.SubElement ( cppext , &apos; configSeverityEvaluation &apos; ) DCNL DCSP thrsh = data.get ( &apos; thresholds &apos; , { } ) DCNL DCSP thrsh _ mappings = &#91; ( &apos; unstable &apos; , &apos; threshold &apos; , &apos; &apos; ) , ( &apos; new-unstable &apos; , &apos; newThreshold &apos; , &apos; &apos; ) , ( &apos; failure &apos; , &apos; failureThreshold &apos; , &apos; &apos; ) , ( &apos; new-failure &apos; , &apos; newFailureThreshold &apos; , &apos; &apos; ) , ( &apos; healthy &apos; , &apos; healthy &apos; , &apos; &apos; ) , ( &apos; unhealthy &apos; , &apos; unHealthy &apos; , &apos; &apos; ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( csev , thrsh , thrsh _ mappings , fail _ required = True ) DCNL DCSP sev = thrsh.get ( &apos; severity &apos; , { } ) DCNL DCSP sev _ mappings = &#91; ( &apos; error &apos; , &apos; severityError &apos; , True ) , ( &apos; warning &apos; , &apos; severityWarning &apos; , True ) , ( &apos; style &apos; , &apos; severityStyle &apos; , True ) , ( &apos; performance &apos; , &apos; severityPerformance &apos; , True ) , ( &apos; information &apos; , &apos; severityInformation &apos; , True ) , ( &apos; nocategory &apos; , &apos; severityNoCategory &apos; , True ) , ( &apos; portability &apos; , &apos; severityPortability &apos; , True ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( csev , sev , sev _ mappings , fail _ required = True ) DCNL DCSP graph = data.get ( &apos; graph &apos; , { } ) DCNL DCSP cgraph = XML.SubElement ( cppext , &apos; configGraph &apos; ) DCNL DCSP ( x , y ) = graph.get ( &apos; xysize &apos; , &#91; 500 , 200 &#93; ) DCNL DCSP XML.SubElement ( cgraph , &apos; xSize &apos; ) .text = str ( x ) DCNL DCSP XML.SubElement ( cgraph , &apos; ySize &apos; ) .text = str ( y ) DCNL DCSP graph _ mapping = &#91; ( &apos; num-builds-in-graph &apos; , &apos; numBuildsInGraph &apos; , 0 ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( cgraph , graph , graph _ mapping , fail _ required = True ) DCNL DCSP gdisplay = graph.get ( &apos; display &apos; , { } ) DCNL DCSP gdisplay _ mappings = &#91; ( &apos; sum &apos; , &apos; displayAllErrors &apos; , True ) , ( &apos; error &apos; , &apos; displayErrorSeverity &apos; , False ) , ( &apos; warning &apos; , &apos; displayWarningSeverity &apos; , False ) , ( &apos; style &apos; , &apos; displayStyleSeverity &apos; , False ) , ( &apos; performance &apos; , &apos; displayPerformanceSeverity &apos; , False ) , ( &apos; information &apos; , &apos; displayInformationSeverity &apos; , False ) , ( &apos; nocategory &apos; , &apos; displayNoCategorySeverity &apos; , False ) , ( &apos; portability &apos; , &apos; displayPortabilitySeverity &apos; , False ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( cgraph , gdisplay , gdisplay _ mappings , fail _ required = True )
DCSP response = client.describe _ tasks ( tasks = task _ ids ) DCNL DCSP if ( response &#91; &apos; failures &apos; &#93; ! = &#91; &#93; ) : DCNL DCSP DCSP raise Exception ( &apos; There DCSP were DCSP some DCSP failures : \ n { 0 } &apos; .format ( response &#91; &apos; failures &apos; &#93; ) ) DCNL DCSP status _ code = response &#91; &apos; ResponseMetadata &apos; &#93; &#91; &apos; HTTPStatusCode &apos; &#93; DCNL DCSP if ( status _ code ! = 200 ) : DCNL DCSP DCSP msg = &apos; Task DCSP status DCSP request DCSP received DCSP status DCSP code DCSP { 0 } : \ n { 1 } &apos; DCNL DCSP DCSP raise Exception ( msg.format ( status _ code , response ) ) DCNL DCSP return &#91; t &#91; &apos; lastStatus &apos; &#93; for t in response &#91; &apos; tasks &apos; &#93; &#93;
DCSP key _ config _ stub.set _ bindings _ for ( &apos; normal &apos; , OrderedDict ( &#91; ( &apos; &lt; a &apos; , &apos; cmd- &lt; a &apos; ) , ( &apos; &lt; b &apos; , &apos; cmd- &lt; b &apos; ) , ( &apos; &lt; ctrl-a &gt; &apos; , &apos; cmd-ctrla &apos; ) &#93; ) ) DCNL DCSP keyhint.update _ keyhint ( &apos; normal &apos; , &apos; &lt; &apos; ) DCNL DCSP assert ( keyhint.text ( ) = = expected _ text ( ( &apos; &amp; lt ; &apos; , &apos; yellow &apos; , &apos; a &apos; , &apos; cmd- &amp; lt ; a &apos; ) , ( &apos; &amp; lt ; &apos; , &apos; yellow &apos; , &apos; b &apos; , &apos; cmd- &amp; lt ; b &apos; ) ) )
DCSP if ( usecPickle and six.PY2 ) : DCNL DCSP DCSP import cPickle as pickle DCNL DCSP else : DCNL DCSP DCSP import pickle DCNL DCSP if ( protocol is None ) : DCNL DCSP DCSP protocol = pickle.HIGHEST _ PROTOCOL DCNL DCSP if isinstance ( fileorname , six.string _ types ) : DCNL DCSP DCSP f = open ( fileorname , ( u &apos;ab &apos; if append else u &apos;wb &apos; ) ) DCNL DCSP DCSP close = True DCNL DCSP else : DCNL DCSP DCSP f = fileorname DCNL DCSP DCSP close = False DCNL DCSP try : DCNL DCSP DCSP pickle.dump ( object , f , protocol = protocol ) DCNL DCSP finally : DCNL DCSP DCSP if close : DCNL DCSP DCSP DCSP f.close ( )
DCSP from .utils import find _ previous _ version DCNL DCSP previous _ version = find _ previous _ version ( addon , file _ , version _ string , channel ) DCNL DCSP if ( not previous _ version ) : DCNL DCSP DCSP return results DCNL DCSP is _ webextension = results &#91; &apos; metadata &apos; &#93; .get ( &apos; is _ webextension &apos; , False ) DCNL DCSP was _ webextension = ( previous _ version and previous _ version.is _ webextension ) DCNL DCSP if ( is _ webextension and ( not was _ webextension ) ) : DCNL DCSP DCSP results &#91; &apos; is _ upgrade _ to _ webextension &apos; &#93; = True DCNL DCSP DCSP msg = _ ( &apos; We DCSP allow DCSP and DCSP encourage DCSP an DCSP upgrade DCSP but DCSP you DCSP cannot DCSP reverse DCSP this DCSP process . DCSP Once DCSP your DCSP users DCSP have DCSP the DCSP WebExtension DCSP installed , DCSP they DCSP will DCSP not DCSP be DCSP able DCSP to DCSP install DCSP a DCSP legacy DCSP add-on . &apos; ) DCNL DCSP DCSP messages = results &#91; &apos; messages &apos; &#93; DCNL DCSP DCSP messages.insert ( 0 , { &apos; tier &apos; : 1 , &apos; type &apos; : &apos; warning &apos; , &apos; id &apos; : &#91; &apos; validation &apos; , &apos; messages &apos; , &apos; webext _ upgrade &apos; &#93; , &apos; message &apos; : msg , &apos; description &apos; : &#91; &#93; , &apos; compatibility _ type &apos; : None } ) DCNL DCSP DCSP results &#91; &apos; warnings &apos; &#93; + = 1 DCNL DCSP elif ( was _ webextension and ( not is _ webextension ) ) : DCNL DCSP DCSP msg = _ ( &apos; You DCSP cannot DCSP update DCSP a DCSP WebExtensions DCSP add-on DCSP with DCSP a DCSP legacy DCSP add-on . DCSP Your DCSP users DCSP would DCSP not DCSP be DCSP able DCSP to DCSP use DCSP your DCSP new DCSP version DCSP because DCSP Firefox DCSP does DCSP not DCSP support DCSP this DCSP type DCSP of DCSP update . &apos; ) DCNL DCSP DCSP messages = results &#91; &apos; messages &apos; &#93; DCNL DCSP DCSP messages.insert ( 0 , { &apos; tier &apos; : 1 , &apos; type &apos; : ( &apos; error &apos; if ( channel = = amo.RELEASE _ CHANNEL _ LISTED ) else &apos; warning &apos; ) , &apos; id &apos; : &#91; &apos; validation &apos; , &apos; messages &apos; , &apos; webext _ downgrade &apos; &#93; , &apos; message &apos; : msg , &apos; description &apos; : &#91; &#93; , &apos; compatibility _ type &apos; : None } ) DCNL DCSP DCSP results &#91; &apos; errors &apos; &#93; + = 1 DCNL DCSP return results
DCSP def decorator ( func ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP name = ( methodname or func . _ _ name _ _ ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP raise AttributeError ( ( &apos; % s DCSP has DCSP no DCSP _ _ name _ _ DCSP attribute : DCSP you DCSP should DCSP provide DCSP an DCSP explicit DCSP `methodname` &apos; % func ) ) DCNL DCSP DCSP setattr ( klass , name , func ) DCNL DCSP DCSP return func DCNL DCSP return decorator
DCSP result = script.pip ( &apos; install &apos; , &apos; INITools = = 0.1 &apos; , &apos; -d &apos; , &apos; .&apos; , expect _ error = True ) DCNL DCSP assert ( ( Path ( &apos; scratch &apos; ) / &apos; INITools-0.1.tar.gz &apos; ) in result.files _ created ) DCNL DCSP assert ( ( script.site _ packages / &apos; initools &apos; ) not in result.files _ created )
DCSP child _ pre = resource.getrusage ( resource.RUSAGE _ CHILDREN ) DCNL DCSP self _ pre = resource.getrusage ( resource.RUSAGE _ SELF ) DCNL DCSP start = time.time ( ) DCNL DCSP to _ return = function ( * args , * * dargs ) DCNL DCSP elapsed = ( time.time ( ) - start ) DCNL DCSP self _ post = resource.getrusage ( resource.RUSAGE _ SELF ) DCNL DCSP child _ post = resource.getrusage ( resource.RUSAGE _ CHILDREN ) DCNL DCSP ( s _ user , s _ system ) = &#91; ( a - b ) for ( a , b ) in zip ( self _ post , self _ pre ) &#91; : 2 &#93; &#93; DCNL DCSP ( c _ user , c _ system ) = &#91; ( a - b ) for ( a , b ) in zip ( child _ post , child _ pre ) &#91; : 2 &#93; &#93; DCNL DCSP cpu _ percent = ( ( ( ( s _ user + c _ user ) + s _ system ) + c _ system ) / elapsed ) DCNL DCSP return ( cpu _ percent , to _ return )
DCSP ( raw , events , picks ) = _ get _ data ( ) DCNL DCSP epochs1 = Epochs ( raw , events &#91; : 4 &#93; , event _ id , tmin , tmax , picks = picks ) DCNL DCSP evoked1 = epochs1.average ( ) DCNL DCSP epochs2 = Epochs ( raw , events &#91; 4 : 8 &#93; , event _ id , tmin , tmax , picks = picks ) DCNL DCSP evoked2 = epochs2.average ( ) DCNL DCSP epochs = Epochs ( raw , events &#91; : 8 &#93; , event _ id , tmin , tmax , picks = picks ) DCNL DCSP evoked = epochs.average ( ) DCNL DCSP evoked _ sum = combine _ evoked ( &#91; evoked1 , evoked2 &#93; , weights = &apos; nave &apos; ) DCNL DCSP assert _ array _ equal ( evoked.data , evoked _ sum.data ) DCNL DCSP assert _ array _ equal ( evoked.times , evoked _ sum.times ) DCNL DCSP assert _ equal ( evoked _ sum.nave , ( evoked1.nave + evoked2.nave ) ) DCNL DCSP evoked _ diff = combine _ evoked ( &#91; evoked1 , evoked1 &#93; , weights = &#91; 1 , ( -1 ) &#93; ) DCNL DCSP assert _ array _ equal ( np.zeros _ like ( evoked.data ) , evoked _ diff.data )
DCSP if ( rule = = &apos; ! &apos; ) : DCNL DCSP DCSP return FalseCheck ( ) DCNL DCSP elif ( rule = = &apos; @ &apos; ) : DCNL DCSP DCSP return TrueCheck ( ) DCNL DCSP try : DCNL DCSP DCSP ( kind , match ) = rule.split ( &apos; : &apos; , 1 ) DCNL DCSP except Exception : DCNL DCSP DCSP LOG.exception ( ( _ ( &apos; Failed DCSP to DCSP understand DCSP rule DCSP % ( rule ) s &apos; ) % locals ( ) ) ) DCNL DCSP DCSP return FalseCheck ( ) DCNL DCSP if ( kind in _ checks ) : DCNL DCSP DCSP return _ checks &#91; kind &#93; ( kind , match ) DCNL DCSP elif ( None in _ checks ) : DCNL DCSP DCSP return _ checks &#91; None &#93; ( kind , match ) DCNL DCSP else : DCNL DCSP DCSP LOG.error ( ( _ ( &apos; No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP % s &apos; ) % kind ) ) DCNL DCSP DCSP return FalseCheck ( )
DCSP UserModel = auth.get _ user _ model ( ) DCNL DCSP db.reset _ queries ( ) DCNL DCSP try : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP user = UserModel . _ default _ manager.get _ by _ natural _ key ( username ) DCNL DCSP DCSP except UserModel.DoesNotExist : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if ( not user.is _ active ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP return user.check _ password ( password ) DCNL DCSP finally : DCNL DCSP DCSP db.close _ old _ connections ( )
DCSP parser = optparse.OptionParser ( add _ help _ option = False ) DCNL DCSP option _ factories = ( SUPPORTED _ OPTIONS + SUPPORTED _ OPTIONS _ REQ ) DCNL DCSP for option _ factory in option _ factories : DCNL DCSP DCSP option = option _ factory ( ) DCNL DCSP DCSP parser.add _ option ( option ) DCNL DCSP def parser _ exit ( self , msg ) : DCNL DCSP DCSP raise RequirementsFileParseError ( msg ) DCNL DCSP parser.exit = parser _ exit DCNL DCSP return parser
DCSP depends = make _ depends ( ) DCNL DCSP def dependence ( a , b ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP A DCSP cmp DCSP function DCSP for DCSP nodes DCSP in DCSP a DCSP graph DCSP - DCSP does DCSP a DCSP depend DCSP on DCSP b ? \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ------- \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP int \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Positive DCSP number DCSP if DCSP a DCSP depends DCSP on DCSP b , DCSP negative DCSP number \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP if DCSP b DCSP depends DCSP on DCSP a , DCSP 0 DCSP otherwise . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP if depends ( ( a , b ) ) : DCNL DCSP DCSP DCSP return 1 DCNL DCSP DCSP if depends ( ( b , a ) ) : DCNL DCSP DCSP DCSP return ( -1 ) DCNL DCSP DCSP return 0 DCNL DCSP return dependence
DCSP if ( linktype = = 1 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP pkt = dpkt.ethernet.Ethernet ( raw ) DCNL DCSP DCSP DCSP return pkt.data DCNL DCSP DCSP except dpkt.NeedData : DCNL DCSP DCSP DCSP pass DCNL DCSP elif ( linktype = = 101 ) : DCNL DCSP DCSP return dpkt.ip.IP ( raw ) DCNL DCSP else : DCNL DCSP DCSP raise CuckooProcessingError ( &apos; unknown DCSP PCAP DCSP linktype &apos; )
DCSP precondition ( ( numsamples &gt; 0 ) , &apos; numsamples DCSP is DCSP required DCSP to DCSP be DCSP positive . &apos; , numsamples ) DCNL DCSP precondition ( ( iterspersample &gt; 0 ) , &apos; iterspersample DCSP is DCSP required DCSP to DCSP be DCSP positive . &apos; , iterspersample ) DCNL DCSP resiters = ( &#91; None &#93; * numsamples ) DCNL DCSP resmemusage = ( &#91; None &#93; * numsamples ) DCNL DCSP totaliters = 0 DCNL DCSP for i in range ( numsamples ) : DCNL DCSP DCSP for j in range ( iterspersample ) : DCNL DCSP DCSP DCSP f ( * args , * * kwargs ) DCNL DCSP DCSP totaliters = ( totaliters + iterspersample ) DCNL DCSP DCSP resiters &#91; i &#93; = totaliters DCNL DCSP DCSP gc.collect ( ) DCNL DCSP DCSP resmemusage &#91; i &#93; = get _ mem _ used _ res ( ) DCNL DCSP avex = ( float ( reduce ( operator . _ _ add _ _ , resiters ) ) / len ( resiters ) ) DCNL DCSP avey = ( float ( reduce ( operator . _ _ add _ _ , resmemusage ) ) / len ( resmemusage ) ) DCNL DCSP sxy = reduce ( operator . _ _ add _ _ , map ( ( lambda a , avex = avex , avey = avey : ( ( a &#91; 0 &#93; - avex ) * ( a &#91; 1 &#93; - avey ) ) ) , zip ( resiters , resmemusage ) ) ) DCNL DCSP sxx = reduce ( operator . _ _ add _ _ , map ( ( lambda a , avex = avex : ( ( a - avex ) * * 2 ) ) , resiters ) ) DCNL DCSP if ( sxx = = 0 ) : DCNL DCSP DCSP return None DCNL DCSP return ( sxy / sxx )
DCSP if ( time _ rule is not None ) : DCNL DCSP DCSP from pandas.tseries.frequencies import get _ offset DCNL DCSP DCSP offset = get _ offset ( time _ rule ) DCNL DCSP start = to _ datetime ( start ) DCNL DCSP end = to _ datetime ( end ) DCNL DCSP if ( start and ( not offset.onOffset ( start ) ) ) : DCNL DCSP DCSP start = offset.rollforward ( start ) DCNL DCSP elif ( end and ( not offset.onOffset ( end ) ) ) : DCNL DCSP DCSP end = offset.rollback ( end ) DCNL DCSP if ( ( periods is None ) and ( end &lt; start ) ) : DCNL DCSP DCSP end = None DCNL DCSP DCSP periods = 0 DCNL DCSP if ( end is None ) : DCNL DCSP DCSP end = ( start + ( ( periods - 1 ) * offset ) ) DCNL DCSP if ( start is None ) : DCNL DCSP DCSP start = ( end - ( ( periods - 1 ) * offset ) ) DCNL DCSP cur = start DCNL DCSP if ( offset.n &gt; = 0 ) : DCNL DCSP DCSP while ( cur &lt; = end ) : DCNL DCSP DCSP DCSP ( yield cur ) DCNL DCSP DCSP DCSP next _ date = offset.apply ( cur ) DCNL DCSP DCSP DCSP if ( next _ date &lt; = cur ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; Offset DCSP % s DCSP did DCSP not DCSP increment DCSP date &apos; % offset ) ) DCNL DCSP DCSP DCSP cur = next _ date DCNL DCSP else : DCNL DCSP DCSP while ( cur &gt; = end ) : DCNL DCSP DCSP DCSP ( yield cur ) DCNL DCSP DCSP DCSP next _ date = offset.apply ( cur ) DCNL DCSP DCSP DCSP if ( next _ date &gt; = cur ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; Offset DCSP % s DCSP did DCSP not DCSP decrement DCSP date &apos; % offset ) ) DCNL DCSP DCSP DCSP cur = next _ date
DCSP data = { } DCNL DCSP if ( extra _ data is not None ) : DCNL DCSP DCSP data.update ( extra _ data ) DCNL DCSP if ( record is None ) : DCNL DCSP DCSP if ( extra _ data is None ) : DCNL DCSP DCSP DCSP response.set _ status ( 404 ) DCNL DCSP DCSP response.out.write ( render ( &apos; details.html &apos; , data ) ) DCNL DCSP DCSP return DCNL DCSP data.update ( get _ details _ data ( record , file _ url ) ) DCNL DCSP response.out.write ( render ( &apos; details.html &apos; , data ) )
DCSP try : DCNL DCSP DCSP return ( proc.create _ time ( ) if PSUTIL2 else proc.create _ time ) DCNL DCSP except ( psutil.NoSuchProcess , psutil.AccessDenied ) : DCNL DCSP DCSP return None
DCSP packages = process ( &#91; &apos; pm &apos; , &apos; list &apos; , &apos; packages &apos; &#93; ) .recvall ( ) DCNL DCSP return &#91; line.split ( &apos; package : &apos; , 1 ) &#91; ( -1 ) &#93; for line in packages.splitlines ( ) &#93;
DCSP if image _ meta : DCNL DCSP DCSP key = ( ( &apos; hw _ &apos; + device _ type ) + &apos; _ bus &apos; ) DCNL DCSP DCSP disk _ bus = image _ meta.get ( &apos; properties &apos; , { } ) .get ( key ) DCNL DCSP DCSP if ( disk _ bus is not None ) : DCNL DCSP DCSP DCSP if ( not is _ disk _ bus _ valid _ for _ virt ( virt _ type , disk _ bus ) ) : DCNL DCSP DCSP DCSP DCSP raise exception.UnsupportedHardware ( model = disk _ bus , virt = virt _ type ) DCNL DCSP DCSP DCSP return disk _ bus DCNL DCSP if ( virt _ type = = &apos; uml &apos; ) : DCNL DCSP DCSP if ( device _ type = = &apos; disk &apos; ) : DCNL DCSP DCSP DCSP return &apos; uml &apos; DCNL DCSP elif ( virt _ type = = &apos; lxc &apos; ) : DCNL DCSP DCSP return &apos; lxc &apos; DCNL DCSP elif ( virt _ type = = &apos; xen &apos; ) : DCNL DCSP DCSP if ( device _ type = = &apos; cdrom &apos; ) : DCNL DCSP DCSP DCSP return &apos; ide &apos; DCNL DCSP DCSP elif ( device _ type = = &apos; disk &apos; ) : DCNL DCSP DCSP DCSP return &apos; xen &apos; DCNL DCSP elif ( virt _ type in ( &apos; qemu &apos; , &apos; kvm &apos; ) ) : DCNL DCSP DCSP if ( device _ type = = &apos; cdrom &apos; ) : DCNL DCSP DCSP DCSP return &apos; ide &apos; DCNL DCSP DCSP elif ( device _ type = = &apos; disk &apos; ) : DCNL DCSP DCSP DCSP return &apos; virtio &apos; DCNL DCSP return None
DCSP if proxy : DCNL DCSP DCSP return { &apos; version &apos; : _ get _ grain ( proxy , &apos; os _ version &apos; ) }
DCSP vif _ ref = _ virtual _ interface _ query ( context ) .filter _ by ( uuid = vif _ uuid ) .first ( ) DCNL DCSP return vif _ ref
DCSP if ( not isinstance ( coro , types.GeneratorType ) ) : DCNL DCSP DCSP raise ValueError ( ( u &apos; % s DCSP is DCSP not DCSP a DCSP coroutine &apos; % coro ) ) DCNL DCSP return SpawnEvent ( coro )
DCSP ok = True DCNL DCSP try : DCNL DCSP DCSP unicode ( &apos; hey &apos; , &apos; raw _ unicode-escape &apos; ) DCNL DCSP except LookupError : DCNL DCSP DCSP ok = False DCNL DCSP Assert ( ok , &apos; dashes DCSP and DCSP underscores DCSP should DCSP be DCSP interchangable &apos; )
DCSP kimplements = getattr ( obj , &apos; _ _ implements _ _ &apos; , ( ) ) DCNL DCSP if ( not isinstance ( kimplements , ( list , tuple ) ) ) : DCNL DCSP DCSP kimplements = ( kimplements , ) DCNL DCSP for implementedinterface in kimplements : DCNL DCSP DCSP if issubclass ( implementedinterface , interface ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP runner = Runner ( join _ path ( &apos; ru &apos; , &apos; success &apos; , &apos; outlines.feature &apos; ) , verbosity = 3 , no _ color = True ) DCNL DCSP runner.run ( ) DCNL DCSP assert _ stdout _ lines ( u &apos; \ n \ u0424 \ u0443 \ u043d \ u043a \ u0446 \ u0438 \ u043e \ u043d \ u0430 \ u043b : DCSP \ u041f \ u0440 \ u043e \ u0432 \ u0435 \ u0440 \ u0438 \ u0442 \ u044c DCSP \ u0432 \ u044b \ u0432 \ u043e \ u0434 DCSP \ u0441 \ u0442 \ u0440 \ u0443 \ u043a \ u0442 \ u0443 \ u0440 \ u043d \ u043e \ u0433 \ u043e DCSP \ u0441 \ u0446 \ u0435 \ u043d \ u0430 \ u0440 \ u0438 \ u044f DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines.feature : 3 \ n DCSP DCSP \ u041a \ u0430 \ u043a DCSP \ u043f \ u0440 \ u043e \ u0433 \ u0440 \ u0430 \ u043c \ u043c \ u0438 \ u0441 \ u0442 DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines.feature : 4 \ n DCSP DCSP \ u0414 \ u043b \ u044f DCSP \ u0442 \ u043e \ u0433 \ u043e DCSP \ u0447 \ u043e \ u0431 \ u044b DCSP lettuce DCSP \ u0431 \ u044b \ u043b DCSP \ u043d \ u0430 \ u0434 \ u0435 \ u0436 \ u043d \ u044b \ u043c DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines.feature : 5 \ n DCSP DCSP \ u042f DCSP \ u0445 \ u043e \ u0447 \ u0443 , DCSP \ u0447 \ u0442 \ u043e DCSP \ u0431 \ u044b DCSP \ u0441 \ u0446 \ u0435 \ u043d \ u0430 \ u0440 \ u0438 \ u0438 DCSP \ u0441 \ u043e DCSP \ u0441 \ u0442 \ u0440 \ u0443 \ u043a \ u0442 \ u0443 \ u0440 \ u043e \ u0439 DCSP \ u0440 \ u0430 \ u0431 \ u043e \ u0442 \ u0430 \ u043b \ u0438 DCSP \ u043d \ u0430 DCSP \ u0440 \ u0443 \ u0441 \ u0441 \ u043a \ u043e \ u043c DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines.feature : 6 \ n \ n DCSP DCSP \ u0421 \ u0442 \ u0440 \ u0443 \ u043a \ u0442 \ u0443 \ u0440 \ u0430 DCSP \ u0441 \ u0446 \ u0435 \ u043d \ u0430 \ u0440 \ u0438 \ u044f : DCSP \ u0417 \ u0430 \ u043f \ u043e \ u043b \ u043d \ u0438 \ u0442 \ u044c DCSP \ u0444 \ u043e \ u0440 \ u043c \ u0443 DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines.feature : 8 \ n DCSP DCSP DCSP DCSP \ u041f \ u0443 \ u0441 \ u043a \ u0430 \ u0439 DCSP \ u044f DCSP \ u043e \ u0442 \ u043a \ u0440 \ u044b \ u0432 \ u0430 \ u044e DCSP \ u0432 DCSP \ u0431 \ u0440 \ u0430 \ u0443 \ u0437 \ u0435 \ u0440 \ u0435 DCSP DCSP &quot; http : / / sona-studio.com / contacts / &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 12 \ n DCSP DCSP DCSP DCSP \ u041a \ u043e \ u0433 \ u0434 \ u0430 DCSP \ u044f DCSP \ u0437 \ u0430 \ u043f \ u043e \ u043b \ u043d \ u044f \ u044e DCSP \ u0432 DCSP \ u043f \ u043e \ u043b \ u0435 DCSP &quot; \ u0418 \ u043c \ u044f &quot; DCSP &quot; &lt; \ u0438 \ u043c \ u044f &gt; &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 16 \ n DCSP DCSP DCSP DCSP \ u0418 DCSP \ u044f DCSP \ u0437 \ u0430 \ u043f \ u043e \ u043b \ u043d \ u044f \ u044e DCSP \ u0432 DCSP \ u043f \ u043e \ u043b \ u0435 DCSP &quot; Email &quot; DCSP &quot; &lt; email &gt; &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 24 \ n DCSP DCSP DCSP DCSP \ u0418 DCSP \ u044f DCSP \ u0437 \ u0430 \ u043f \ u043e \ u043b \ u043d \ u044f \ u044e DCSP \ u0432 DCSP \ u043f \ u043e \ u043b \ u0435 DCSP &quot; \ u0421 \ u043e \ u043e \ u0431 \ u0449 \ u0435 \ u043d \ u0438 \ u0435 &quot; DCSP &quot; &lt; \ u0441 \ u043e \ u043e \ u0431 \ u0449 \ u0435 \ u043d \ u0438 \ u0435 &gt; &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 32 \ n DCSP DCSP DCSP DCSP \ u0418 DCSP \ u044f DCSP \ u043d \ u0430 \ u0436 \ u0438 \ u043c \ u0430 \ u044e DCSP &quot; \ u041e \ u0442 \ u043f \ u0440 \ u0430 \ u0432 \ u0438 \ u0442 \ u044c &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 40 \ n DCSP DCSP DCSP DCSP \ u0422 \ u043e \ u0433 \ u0434 \ u0430 DCSP \ u044f DCSP \ u043f \ u043e \ u043b \ u0443 \ u0447 \ u0430 \ u044e DCSP \ u0441 \ u043e \ u043e \ u0431 \ u0449 \ u0435 \ u043d \ u0438 \ u0435 DCSP &quot; \ u0421 \ u043f \ u0430 \ u0441 \ u0438 \ u0431 \ u043e DCSP \ u0437 \ u0430 DCSP \ u0432 \ u0430 \ u0448 \ u0435 DCSP \ u0441 \ u043e \ u043e \ u0431 \ u0449 \ u0435 \ u043d \ u0438 \ u0435 &quot; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP # DCSP tests / functional / language _ specific _ features / ru / success / outlines _ steps.py : 43 \ n \ n DCSP DCSP \ u041f \ u0440 \ u0438 \ u043c \ u0435 \ u0440 \ u044b : \ n DCSP DCSP DCSP DCSP &#124; DCSP \ u0438 \ u043c \ u044f DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &#124; DCSP email DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &#124; DCSP \ u0441 \ u043e \ u043e \ u0431 \ u0449 \ u0435 \ u043d \ u0438 \ u0435 DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &#124; \ n DCSP DCSP DCSP DCSP &#124; DCSP \ u0412 \ u0438 \ u0442 \ u0430 \ u043b \ u0438 \ u0439 DCSP \ u0418 \ u0433 \ u043e \ u0440 \ u0435 \ u0432 \ u0438 \ u0447 DCSP &#124; DCSP john @ gmail.org DCSP &#124; DCSP \ u0415 \ u0441 \ u0442 \ u044c DCSP \ u0438 \ u043d \ u0442 \ u0435 \ u0440 \ u0435 \ u0441 \ u043d \ u044b \ u0439 DCSP \ u043f \ u0440 \ u043e \ u0435 \ u043a \ u0442 , DCSP \ u043d \ u0443 \ u0436 \ u043d \ u043e DCSP \ u043e \ u0431 \ u0441 \ u0443 \ u0434 \ u0438 \ u0442 \ u044c DCSP &#124; \ n DCSP DCSP DCSP DCSP &#124; DCSP \ u041c \ u0430 \ u0440 \ u0438 \ u043d \ u0430 DCSP \ u0411 \ u0430 \ u043d \ u0440 \ u0430 \ u0443 \ u043b DCSP DCSP DCSP &#124; DCSP mary @ email.com DCSP &#124; DCSP \ u041c \ u043d \ u0435 DCSP \ u043d \ u0440 \ u0430 \ u0432 \ u044f \ u0442 \ u0441 \ u044f DCSP \ u0432 \ u0430 \ u0448 \ u0438 DCSP \ u0434 \ u0438 \ u0437 \ u0430 \ u0439 \ u043d \ u044b , DCSP \ u0445 \ u043e \ u0447 \ u0443 DCSP \ u0441 \ u0430 \ u0439 \ u0442 DCSP DCSP DCSP &#124; \ n \ n1 DCSP feature DCSP ( 1 DCSP passed ) \ n2 DCSP scenarios DCSP ( 2 DCSP passed ) \ n12 DCSP steps DCSP ( 12 DCSP passed ) \ n &apos; )
DCSP X = np.random.random ( ( 10 , 5 ) ) DCNL DCSP X &#91; ( 1 , 2 ) &#93; = np.nan DCNL DCSP df = pandas.DataFrame ( X ) DCNL DCSP ( vals , cnames , rnames ) = data.interpret _ data ( df ) DCNL DCSP np.testing.assert _ equal ( rnames.tolist ( ) , &#91; 0 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 &#93; )
DCSP from gluon.rewrite import url _ out DCNL DCSP if ( args in ( None , &#91; &#93; ) ) : DCNL DCSP DCSP args = &#91; &#93; DCNL DCSP vars = ( vars or { } ) DCNL DCSP application = None DCNL DCSP controller = None DCNL DCSP function = None DCNL DCSP if ( not isinstance ( args , ( list , tuple ) ) ) : DCNL DCSP DCSP args = &#91; args &#93; DCNL DCSP if ( not r ) : DCNL DCSP DCSP if ( a and ( not c ) and ( not f ) ) : DCNL DCSP DCSP DCSP ( f , a , c ) = ( a , c , f ) DCNL DCSP DCSP elif ( a and c and ( not f ) ) : DCNL DCSP DCSP DCSP ( c , f , a ) = ( a , c , f ) DCNL DCSP DCSP from gluon.globals import current DCNL DCSP DCSP if hasattr ( current , &apos; request &apos; ) : DCNL DCSP DCSP DCSP r = current.request DCNL DCSP if r : DCNL DCSP DCSP application = r.application DCNL DCSP DCSP controller = r.controller DCNL DCSP DCSP function = r.function DCNL DCSP DCSP env = r.env DCNL DCSP DCSP if ( ( extension is None ) and ( r.extension ! = &apos; html &apos; ) ) : DCNL DCSP DCSP DCSP extension = r.extension DCNL DCSP if a : DCNL DCSP DCSP application = a DCNL DCSP if c : DCNL DCSP DCSP controller = c DCNL DCSP if f : DCNL DCSP DCSP if ( not isinstance ( f , str ) ) : DCNL DCSP DCSP DCSP if hasattr ( f , &apos; _ _ name _ _ &apos; ) : DCNL DCSP DCSP DCSP DCSP function = f . _ _ name _ _ DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise SyntaxError ( &apos; when DCSP calling DCSP URL , DCSP function DCSP or DCSP function DCSP name DCSP required &apos; ) DCNL DCSP DCSP elif ( &apos; / &apos; in f ) : DCNL DCSP DCSP DCSP if f.startswith ( &apos; / &apos; ) : DCNL DCSP DCSP DCSP DCSP f = f &#91; 1 : &#93; DCNL DCSP DCSP DCSP items = f.split ( &apos; / &apos; ) DCNL DCSP DCSP DCSP function = f = items &#91; 0 &#93; DCNL DCSP DCSP DCSP args = ( items &#91; 1 : &#93; + args ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP function = f DCNL DCSP DCSP if ( controller = = &apos; static &apos; ) : DCNL DCSP DCSP DCSP extension = None DCNL DCSP DCSP DCSP from gluon.globals import current DCNL DCSP DCSP DCSP if hasattr ( current , &apos; response &apos; ) : DCNL DCSP DCSP DCSP DCSP response = current.response DCNL DCSP DCSP DCSP DCSP if ( response.static _ version and response.static _ version _ urls ) : DCNL DCSP DCSP DCSP DCSP DCSP args = ( &#91; function &#93; + args ) DCNL DCSP DCSP DCSP DCSP DCSP function = ( &apos; _ &apos; + str ( response.static _ version ) ) DCNL DCSP DCSP if ( &apos; .&apos; in function ) : DCNL DCSP DCSP DCSP ( function , extension ) = function.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP function2 = ( &apos; % s . % s &apos; % ( function , ( extension or &apos; html &apos; ) ) ) DCNL DCSP if ( not ( application and controller and function ) ) : DCNL DCSP DCSP raise SyntaxError ( ( &apos; not DCSP enough DCSP information DCSP to DCSP build DCSP the DCSP url DCSP ( % s DCSP % s DCSP % s ) &apos; % ( application , controller , function ) ) ) DCNL DCSP if args : DCNL DCSP DCSP if url _ encode : DCNL DCSP DCSP DCSP if encode _ embedded _ slash : DCNL DCSP DCSP DCSP DCSP other = ( &apos; / &apos; + &apos; / &apos; .join ( &#91; urllib _ quote ( str ( x ) , &apos; &apos; ) for x in args &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP other = ( args and urllib _ quote ( ( &apos; / &apos; + &apos; / &apos; .join ( &#91; str ( x ) for x in args &#93; ) ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP other = ( args and ( &apos; / &apos; + &apos; / &apos; .join ( &#91; str ( x ) for x in args &#93; ) ) ) DCNL DCSP else : DCNL DCSP DCSP other = &apos; &apos; DCNL DCSP if other.endswith ( &apos; / &apos; ) : DCNL DCSP DCSP other + = &apos; / &apos; DCNL DCSP list _ vars = &#91; &#93; DCNL DCSP for ( key , vals ) in sorted ( vars.items ( ) ) : DCNL DCSP DCSP if ( key = = &apos; _ signature &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not isinstance ( vals , ( list , tuple ) ) ) : DCNL DCSP DCSP DCSP vals = &#91; vals &#93; DCNL DCSP DCSP for val in vals : DCNL DCSP DCSP DCSP list _ vars.append ( ( key , val ) ) DCNL DCSP if user _ signature : DCNL DCSP DCSP from gluon.globals import current DCNL DCSP DCSP if current.session.auth : DCNL DCSP DCSP DCSP hmac _ key = current.session.auth.hmac _ key DCNL DCSP if hmac _ key : DCNL DCSP DCSP h _ args = ( &apos; / % s / % s / % s % s &apos; % ( application , controller , function2 , other ) ) DCNL DCSP DCSP if ( hash _ vars is True ) : DCNL DCSP DCSP DCSP h _ vars = list _ vars DCNL DCSP DCSP elif ( hash _ vars is False ) : DCNL DCSP DCSP DCSP h _ vars = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( hash _ vars and ( not isinstance ( hash _ vars , ( list , tuple ) ) ) ) : DCNL DCSP DCSP DCSP DCSP hash _ vars = &#91; hash _ vars &#93; DCNL DCSP DCSP DCSP h _ vars = &#91; ( k , v ) for ( k , v ) in list _ vars if ( k in hash _ vars ) &#93; DCNL DCSP DCSP message = ( ( h _ args + &apos; ? &apos; ) + urlencode ( sorted ( h _ vars ) ) ) DCNL DCSP DCSP sig = simple _ hash ( message , ( hmac _ key or &apos; &apos; ) , ( salt or &apos; &apos; ) , digest _ alg = &apos; sha1 &apos; ) DCNL DCSP DCSP list _ vars.append ( ( &apos; _ signature &apos; , sig ) ) DCNL DCSP if list _ vars : DCNL DCSP DCSP if url _ encode : DCNL DCSP DCSP DCSP other + = ( &apos; ? % s &apos; % urlencode ( list _ vars ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP other + = ( &apos; ? % s &apos; % &apos; &amp; &apos; .join ( &#91; ( &apos; % s = % s &apos; % var &#91; : 2 &#93; ) for var in list _ vars &#93; ) ) DCNL DCSP if anchor : DCNL DCSP DCSP if url _ encode : DCNL DCSP DCSP DCSP other + = ( &apos; # &apos; + urllib _ quote ( str ( anchor ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP other + = ( &apos; # &apos; + str ( anchor ) ) DCNL DCSP if extension : DCNL DCSP DCSP function + = ( &apos; .&apos; + extension ) DCNL DCSP if regex _ crlf.search ( join ( &#91; application , controller , function , other &#93; ) ) : DCNL DCSP DCSP raise SyntaxError ( &apos; CRLF DCSP Injection DCSP Detected &apos; ) DCNL DCSP url = url _ out ( r , env , application , controller , function , args , other , scheme , host , port , language = language ) DCNL DCSP return url
DCSP return nav _ link ( text , named _ route = named _ route , * * kwargs )
DCSP path = ( &apos; / % s / % s / % s &apos; % ( account , container , obj ) ) DCNL DCSP with Timeout ( conn _ timeout ) : DCNL DCSP DCSP conn = http _ connect ( node &#91; &apos; ip &apos; &#93; , node &#91; &apos; port &apos; &#93; , node &#91; &apos; device &apos; &#93; , part , &apos; GET &apos; , path , headers = headers ) DCNL DCSP with Timeout ( response _ timeout ) : DCNL DCSP DCSP resp = conn.getresponse ( ) DCNL DCSP if ( not is _ success ( resp.status ) ) : DCNL DCSP DCSP resp.read ( ) DCNL DCSP DCSP raise ClientException ( ( &apos; Object DCSP server DCSP % s : % s DCSP direct DCSP GET DCSP % s DCSP gave DCSP status DCSP % s &apos; % ( node &#91; &apos; ip &apos; &#93; , node &#91; &apos; port &apos; &#93; , repr ( ( &apos; / % s / % s % s &apos; % ( node &#91; &apos; device &apos; &#93; , part , path ) ) ) , resp.status ) ) , http _ host = node &#91; &apos; ip &apos; &#93; , http _ port = node &#91; &apos; port &apos; &#93; , http _ device = node &#91; &apos; device &apos; &#93; , http _ status = resp.status , http _ reason = resp.reason ) DCNL DCSP if resp _ chunk _ size : DCNL DCSP DCSP def _ object _ body ( ) : DCNL DCSP DCSP DCSP buf = resp.read ( resp _ chunk _ size ) DCNL DCSP DCSP DCSP while buf : DCNL DCSP DCSP DCSP DCSP ( yield buf ) DCNL DCSP DCSP DCSP DCSP buf = resp.read ( resp _ chunk _ size ) DCNL DCSP DCSP object _ body = _ object _ body ( ) DCNL DCSP else : DCNL DCSP DCSP object _ body = resp.read ( ) DCNL DCSP resp _ headers = { } DCNL DCSP for ( header , value ) in resp.getheaders ( ) : DCNL DCSP DCSP resp _ headers &#91; header.lower ( ) &#93; = value DCNL DCSP return ( resp _ headers , object _ body )
DCSP i = Dummy ( &apos; i &apos; ) DCNL DCSP s = list ( zip ( reversed ( DE.T ) , reversed ( &#91; f ( DE.x ) for f in DE.Tfuncs &#93; ) ) ) DCNL DCSP return sum ( ( RootSum ( a &#91; 0 &#93; .as _ poly ( z ) , Lambda ( i , ( i * log ( a &#91; 1 &#93; .as _ expr ( ) ) .subs ( { z : i } ) .subs ( s ) ) ) ) for a in H ) )
DCSP try : DCNL DCSP DCSP return win32security.ConvertSidToStringSid ( principal ) DCNL DCSP except TypeError : DCNL DCSP DCSP principal = get _ sid ( principal ) DCNL DCSP try : DCNL DCSP DCSP return win32security.ConvertSidToStringSid ( principal ) DCNL DCSP except pywintypes.error : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Invalid DCSP principal DCSP { 0 } &apos; .format ( principal ) )
DCSP with override _ provides ( &apos; service _ provider _ admin _ form &apos; , &#91; &apos; shuup.testing.service _ forms.PseudoPaymentProcessorForm &apos; , &apos; shuup.admin.modules.service _ providers.forms : CustomCarrierForm &apos; , &apos; shuup.admin.modules.service _ providers.forms : CustomPaymentProcessorForm &apos; &#93; ) : DCNL DCSP DCSP request = apply _ all _ middleware ( request , user = user ) DCNL DCSP DCSP response = view ( request , pk = ( object.pk if object else None ) ) DCNL DCSP DCSP if hasattr ( response , &apos; render &apos; ) : DCNL DCSP DCSP DCSP response.render ( ) DCNL DCSP DCSP assert ( response.status _ code in &#91; 200 , 302 &#93; ) DCNL DCSP DCSP return BeautifulSoup ( response.content )
DCSP if ( not all ( &#91; old , new &#93; ) ) : DCNL DCSP DCSP return VERSIONING _ RATIO DCNL DCSP return ( levenshtein _ distance ( old , new ) / ( len ( old ) / 100.0 ) )
DCSP if ( self.get _ current _ user _ token ( ) is None ) : DCNL DCSP DCSP raise web.HTTPError ( 403 )
DCSP x = 1.0 DCNL DCSP y = 1 DCNL DCSP z = 123456789123456789 DCNL DCSP s = &apos; hello DCSP world &apos; DCNL DCSP t = ( 1.0 , &apos; asdf &apos; ) DCNL DCSP print sorted ( locals ( ) .items ( ) ) DCNL DCSP print sorted ( vars ( ) .items ( ) )
DCSP params = dict ( params.items ( ) ) DCNL DCSP extra _ fields = configuration _ helpers.get _ value ( &apos; REGISTRATION _ EXTRA _ FIELDS &apos; , getattr ( settings , &apos; REGISTRATION _ EXTRA _ FIELDS &apos; , { } ) ) DCNL DCSP should _ link _ with _ social _ auth = ( third _ party _ auth.is _ enabled ( ) and ( &apos; provider &apos; in params ) ) DCNL DCSP if ( should _ link _ with _ social _ auth or ( third _ party _ auth.is _ enabled ( ) and pipeline.running ( request ) ) ) : DCNL DCSP DCSP params &#91; &apos; password &apos; &#93; = pipeline.make _ random _ password ( ) DCNL DCSP extra _ fields &#91; &apos; data _ sharing _ consent &apos; &#93; = data _ sharing _ consent _ requirement _ at _ login ( request ) DCNL DCSP do _ external _ auth = ( &apos; ExternalAuthMap &apos; in request.session ) DCNL DCSP if do _ external _ auth : DCNL DCSP DCSP eamap = request.session &#91; &apos; ExternalAuthMap &apos; &#93; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP validate _ email ( eamap.external _ email ) DCNL DCSP DCSP DCSP params &#91; &apos; email &apos; &#93; = eamap.external _ email DCNL DCSP DCSP except ValidationError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP if ( eamap.external _ name.strip ( ) ! = &apos; &apos; ) : DCNL DCSP DCSP DCSP params &#91; &apos; name &apos; &#93; = eamap.external _ name DCNL DCSP DCSP params &#91; &apos; password &apos; &#93; = eamap.internal _ password DCNL DCSP DCSP log.debug ( u &apos;In DCSP create _ account DCSP with DCSP external _ auth : DCSP user DCSP = DCSP % s , DCSP email = % s &apos; , params &#91; &apos; name &apos; &#93; , params &#91; &apos; email &apos; &#93; ) DCNL DCSP extended _ profile _ fields = configuration _ helpers.get _ value ( &apos; extended _ profile _ fields &apos; , &#91; &#93; ) DCNL DCSP enforce _ password _ policy = ( settings.FEATURES.get ( &apos; ENFORCE _ PASSWORD _ POLICY &apos; , False ) and ( not do _ external _ auth ) ) DCNL DCSP registration _ fields = getattr ( settings , &apos; REGISTRATION _ EXTRA _ FIELDS &apos; , { } ) DCNL DCSP tos _ required = ( ( ( registration _ fields.get ( &apos; terms _ of _ service &apos; ) ! = &apos; hidden &apos; ) or ( registration _ fields.get ( &apos; honor _ code &apos; ) ! = &apos; hidden &apos; ) ) and ( ( not settings.FEATURES.get ( &apos; AUTH _ USE _ SHIB &apos; ) ) or ( not settings.FEATURES.get ( &apos; SHIB _ DISABLE _ TOS &apos; ) ) or ( not do _ external _ auth ) or ( not eamap.external _ domain.startswith ( openedx.core.djangoapps.external _ auth.views.SHIBBOLETH _ DOMAIN _ PREFIX ) ) ) ) DCNL DCSP form = AccountCreationForm ( data = params , extra _ fields = extra _ fields , extended _ profile _ fields = extended _ profile _ fields , enforce _ username _ neq _ password = True , enforce _ password _ policy = enforce _ password _ policy , tos _ required = tos _ required ) DCNL DCSP custom _ form = get _ registration _ extension _ form ( data = params ) DCNL DCSP with transaction.atomic ( ) : DCNL DCSP DCSP ( user , profile , registration ) = _ do _ create _ account ( form , custom _ form ) DCNL DCSP DCSP if should _ link _ with _ social _ auth : DCNL DCSP DCSP DCSP backend _ name = params &#91; &apos; provider &apos; &#93; DCNL DCSP DCSP DCSP request.social _ strategy = social _ utils.load _ strategy ( request ) DCNL DCSP DCSP DCSP redirect _ uri = reverse ( &apos; social : complete &apos; , args = ( backend _ name , ) ) DCNL DCSP DCSP DCSP request.backend = social _ utils.load _ backend ( request.social _ strategy , backend _ name , redirect _ uri ) DCNL DCSP DCSP DCSP social _ access _ token = params.get ( &apos; access _ token &apos; ) DCNL DCSP DCSP DCSP if ( not social _ access _ token ) : DCNL DCSP DCSP DCSP DCSP raise ValidationError ( { &apos; access _ token &apos; : &#91; _ ( &apos; An DCSP access _ token DCSP is DCSP required DCSP when DCSP passing DCSP value DCSP ( { } ) DCSP for DCSP provider . &apos; ) .format ( params &#91; &apos; provider &apos; &#93; ) &#93; } ) DCNL DCSP DCSP DCSP request.session &#91; pipeline.AUTH _ ENTRY _ KEY &#93; = pipeline.AUTH _ ENTRY _ REGISTER _ API DCNL DCSP DCSP DCSP pipeline _ user = None DCNL DCSP DCSP DCSP error _ message = &apos; &apos; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP pipeline _ user = request.backend.do _ auth ( social _ access _ token , user = user ) DCNL DCSP DCSP DCSP except AuthAlreadyAssociated : DCNL DCSP DCSP DCSP DCSP error _ message = _ ( &apos; The DCSP provided DCSP access _ token DCSP is DCSP already DCSP associated DCSP with DCSP another DCSP user . &apos; ) DCNL DCSP DCSP DCSP except ( HTTPError , AuthException ) : DCNL DCSP DCSP DCSP DCSP error _ message = _ ( &apos; The DCSP provided DCSP access _ token DCSP is DCSP not DCSP valid . &apos; ) DCNL DCSP DCSP DCSP if ( ( not pipeline _ user ) or ( not isinstance ( pipeline _ user , User ) ) ) : DCNL DCSP DCSP DCSP DCSP request.social _ strategy.clean _ partial _ pipeline ( ) DCNL DCSP DCSP DCSP DCSP raise ValidationError ( { &apos; access _ token &apos; : &#91; error _ message &#93; } ) DCNL DCSP preferences _ api.set _ user _ preference ( user , LANGUAGE _ KEY , get _ language ( ) ) DCNL DCSP if settings.FEATURES.get ( &apos; ENABLE _ DISCUSSION _ EMAIL _ DIGEST &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP enable _ notifications ( user ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP log.exception ( &apos; Enable DCSP discussion DCSP notifications DCSP failed DCSP for DCSP user DCSP { id } . &apos; .format ( id = user.id ) ) DCNL DCSP dog _ stats _ api.increment ( &apos; common.student.account _ created &apos; ) DCNL DCSP third _ party _ provider = None DCNL DCSP running _ pipeline = None DCNL DCSP if ( third _ party _ auth.is _ enabled ( ) and pipeline.running ( request ) ) : DCNL DCSP DCSP running _ pipeline = pipeline.get ( request ) DCNL DCSP DCSP third _ party _ provider = provider.Registry.get _ from _ pipeline ( running _ pipeline ) DCNL DCSP DCSP running _ pipeline &#91; &apos; kwargs &apos; &#93; &#91; &apos; data _ sharing _ consent &apos; &#93; = form.cleaned _ data.get ( &apos; data _ sharing _ consent &apos; , None ) DCNL DCSP if ( hasattr ( settings , &apos; LMS _ SEGMENT _ KEY &apos; ) and settings.LMS _ SEGMENT _ KEY ) : DCNL DCSP DCSP tracking _ context = tracker.get _ tracker ( ) .resolve _ context ( ) DCNL DCSP DCSP identity _ args = &#91; user.id , { &apos; email &apos; : user.email , &apos; username &apos; : user.username , &apos; name &apos; : profile.name , &apos; age &apos; : ( profile.age or ( -1 ) ) , &apos; yearOfBirth &apos; : ( profile.year _ of _ birth or datetime.datetime.now ( UTC ) .year ) , &apos; education &apos; : profile.level _ of _ education _ display , &apos; address &apos; : profile.mailing _ address , &apos; gender &apos; : profile.gender _ display , &apos; country &apos; : unicode ( profile.country ) } &#93; DCNL DCSP DCSP if hasattr ( settings , &apos; MAILCHIMP _ NEW _ USER _ LIST _ ID &apos; ) : DCNL DCSP DCSP DCSP identity _ args.append ( { &apos; MailChimp &apos; : { &apos; listId &apos; : settings.MAILCHIMP _ NEW _ USER _ LIST _ ID } } ) DCNL DCSP DCSP analytics.identify ( * identity _ args ) DCNL DCSP DCSP analytics.track ( user.id , &apos; edx.bi.user.account.registered &apos; , { &apos; category &apos; : &apos; conversion &apos; , &apos; label &apos; : params.get ( &apos; course _ id &apos; ) , &apos; provider &apos; : ( third _ party _ provider.name if third _ party _ provider else None ) } , context = { &apos; ip &apos; : tracking _ context.get ( &apos; ip &apos; ) , &apos; Google DCSP Analytics &apos; : { &apos; clientId &apos; : tracking _ context.get ( &apos; client _ id &apos; ) } } ) DCNL DCSP REGISTER _ USER.send ( sender = None , user = user , profile = profile ) DCNL DCSP create _ comments _ service _ user ( user ) DCNL DCSP send _ email = ( ( not settings.FEATURES.get ( &apos; SKIP _ EMAIL _ VALIDATION &apos; , None ) ) and ( not settings.FEATURES.get ( &apos; AUTOMATIC _ AUTH _ FOR _ TESTING &apos; ) ) and ( not ( do _ external _ auth and settings.FEATURES.get ( &apos; BYPASS _ ACTIVATION _ EMAIL _ FOR _ EXTAUTH &apos; ) ) ) and ( not ( third _ party _ provider and third _ party _ provider.skip _ email _ verification and ( user.email = = running _ pipeline &#91; &apos; kwargs &apos; &#93; .get ( &apos; details &apos; , { } ) .get ( &apos; email &apos; ) ) ) ) ) DCNL DCSP if send _ email : DCNL DCSP DCSP dest _ addr = user.email DCNL DCSP DCSP context = { &apos; name &apos; : profile.name , &apos; key &apos; : registration.activation _ key } DCNL DCSP DCSP subject = render _ to _ string ( &apos; emails / activation _ email _ subject.txt &apos; , context ) DCNL DCSP DCSP subject = &apos; &apos;.join ( subject.splitlines ( ) ) DCNL DCSP DCSP message = render _ to _ string ( &apos; emails / activation _ email.txt &apos; , context ) DCNL DCSP DCSP from _ address = configuration _ helpers.get _ value ( &apos; email _ from _ address &apos; , settings.DEFAULT _ FROM _ EMAIL ) DCNL DCSP DCSP if settings.FEATURES.get ( &apos; REROUTE _ ACTIVATION _ EMAIL &apos; ) : DCNL DCSP DCSP DCSP dest _ addr = settings.FEATURES &#91; &apos; REROUTE _ ACTIVATION _ EMAIL &apos; &#93; DCNL DCSP DCSP DCSP message = ( ( ( ( &apos; Activation DCSP for DCSP % s DCSP ( % s ) : DCSP % s \ n &apos; % ( user , user.email , profile.name ) ) + ( &apos; -&apos; * 80 ) ) + &apos; \ n \ n &apos; ) + message ) DCNL DCSP DCSP send _ activation _ email.delay ( subject , message , from _ address , dest _ addr ) DCNL DCSP else : DCNL DCSP DCSP registration.activate ( ) DCNL DCSP DCSP _ enroll _ user _ in _ pending _ courses ( user ) DCNL DCSP new _ user = authenticate ( username = user.username , password = params &#91; &apos; password &apos; &#93; ) DCNL DCSP login ( request , new _ user ) DCNL DCSP request.session.set _ expiry ( 0 ) DCNL DCSP try : DCNL DCSP DCSP record _ registration _ attributions ( request , new _ user ) DCNL DCSP except Exception : DCNL DCSP DCSP log.exception ( &apos; Error DCSP while DCSP attributing DCSP cookies DCSP to DCSP user DCSP registration . &apos; ) DCNL DCSP if ( new _ user is not None ) : DCNL DCSP DCSP AUDIT _ LOG.info ( u &apos;Login DCSP success DCSP on DCSP new DCSP account DCSP creation DCSP - DCSP { 0 } &apos; .format ( new _ user.username ) ) DCNL DCSP if do _ external _ auth : DCNL DCSP DCSP eamap.user = new _ user DCNL DCSP DCSP eamap.dtsignup = datetime.datetime.now ( UTC ) DCNL DCSP DCSP eamap.save ( ) DCNL DCSP DCSP AUDIT _ LOG.info ( u &apos;User DCSP registered DCSP with DCSP external _ auth DCSP % s &apos; , new _ user.username ) DCNL DCSP DCSP AUDIT _ LOG.info ( u &apos;Updated DCSP ExternalAuthMap DCSP for DCSP % s DCSP to DCSP be DCSP % s &apos; , new _ user.username , eamap ) DCNL DCSP DCSP if settings.FEATURES.get ( &apos; BYPASS _ ACTIVATION _ EMAIL _ FOR _ EXTAUTH &apos; ) : DCNL DCSP DCSP DCSP log.info ( &apos; bypassing DCSP activation DCSP email &apos; ) DCNL DCSP DCSP DCSP new _ user.is _ active = True DCNL DCSP DCSP DCSP new _ user.save ( ) DCNL DCSP DCSP DCSP AUDIT _ LOG.info ( u &apos;Login DCSP activated DCSP on DCSP extauth DCSP account DCSP - DCSP { 0 } DCSP ( { 1 } ) &apos; .format ( new _ user.username , new _ user.email ) ) DCNL DCSP return new _ user
DCSP def _ composed ( * args ) : DCNL DCSP DCSP for fn in functions : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP args = fn ( * args ) DCNL DCSP DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP DCSP args = fn ( args ) DCNL DCSP DCSP return args DCNL DCSP return _ composed
DCSP asset _ id = request.GET.get ( &apos; id &apos; , &apos; &apos; ) DCNL DCSP asset = get _ object ( Asset , id = asset _ id ) DCNL DCSP name = request.user.username DCNL DCSP if ( not asset ) : DCNL DCSP DCSP return HttpResponseRedirect ( ( reverse ( &apos; asset _ detail &apos; ) + ( &apos; ? id = % s &apos; % asset _ id ) ) ) DCNL DCSP else : DCNL DCSP DCSP asset _ ansible _ update ( &#91; asset &#93; , name ) DCNL DCSP return HttpResponseRedirect ( ( reverse ( &apos; asset _ detail &apos; ) + ( &apos; ? id = % s &apos; % asset _ id ) ) )
DCSP x = func.args &#91; 0 &#93; DCNL DCSP f = func.func DCNL DCSP u = Dummy ( &apos; u &apos; ) DCNL DCSP u1 = Dummy ( &apos; u1 &apos; ) DCNL DCSP r = match DCNL DCSP C1 = get _ numbered _ constants ( eq , num = 1 ) DCNL DCSP xarg = match.get ( &apos; xarg &apos; , 0 ) DCNL DCSP yarg = match.get ( &apos; yarg &apos; , 0 ) DCNL DCSP int = Integral ( ( ( - r &#91; r &#91; &apos; e &apos; &#93; &#93; ) / ( r &#91; r &#91; &apos; d &apos; &#93; &#93; + ( u1 * r &#91; r &#91; &apos; e &apos; &#93; &#93; ) ) ) .subs ( { x : 1 , r &#91; &apos; y &apos; &#93; : u1 } ) , ( u1 , None , ( f ( x ) / x ) ) ) DCNL DCSP sol = logcombine ( Eq ( log ( x ) , ( int + log ( C1 ) ) ) , force = True ) DCNL DCSP sol = sol.subs ( f ( x ) , u ) .subs ( ( ( u , ( u - yarg ) ) , ( x , ( x - xarg ) ) , ( u , f ( x ) ) ) ) DCNL DCSP return sol
DCSP return { &apos; result &apos; : ( &apos; inclusion _ two _ params DCSP - DCSP Expected DCSP result : DCSP % s , DCSP % s &apos; % ( one , two ) ) }
DCSP try : DCNL DCSP DCSP app _ name = get _ commands ( ) &#91; name &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise CommandError ( ( &apos; Unknown DCSP command : DCSP % r &apos; % name ) ) DCNL DCSP if isinstance ( app _ name , BaseCommand ) : DCNL DCSP DCSP klass = app _ name DCNL DCSP else : DCNL DCSP DCSP klass = load _ command _ class ( app _ name , name ) DCNL DCSP defaults = { } DCNL DCSP for opt in klass.option _ list : DCNL DCSP DCSP if ( opt.default is NO _ DEFAULT ) : DCNL DCSP DCSP DCSP defaults &#91; opt.dest &#93; = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP defaults &#91; opt.dest &#93; = opt.default DCNL DCSP defaults.update ( options ) DCNL DCSP return klass.execute ( * args , * * defaults )
DCSP milestone = milestones _ api.add _ milestone ( { &apos; name &apos; : _ ( &apos; Gating DCSP milestone DCSP for DCSP { usage _ key } &apos; ) .format ( usage _ key = unicode ( prereq _ content _ key ) ) , &apos; namespace &apos; : &apos; { usage _ key } { qualifier } &apos; .format ( usage _ key = prereq _ content _ key , qualifier = GATING _ NAMESPACE _ QUALIFIER ) , &apos; description &apos; : _ ( &apos; System DCSP defined DCSP milestone &apos; ) } , propagate = False ) DCNL DCSP milestones _ api.add _ course _ content _ milestone ( course _ key , prereq _ content _ key , &apos; fulfills &apos; , milestone )
DCSP compute _ api _ class _ name = _ get _ compute _ api _ class _ name ( ) DCNL DCSP compute _ api _ class = importutils.import _ class ( compute _ api _ class _ name ) DCNL DCSP class _ name = ( compute _ api _ class . _ _ module _ _ + &apos; .HostAPI &apos; ) DCNL DCSP return importutils.import _ object ( class _ name , * args , * * kwargs )
DCSP ( _ , extension ) = os.path.splitext ( script _ path ) DCNL DCSP contents = io.open ( script _ path , &apos; r &apos; , encoding = &apos; utf-8 &apos; ) .read ( ) DCNL DCSP with tempfile.NamedTemporaryFile ( delete = False , mode = &apos; wb &apos; , suffix = extension ) as temp : DCNL DCSP DCSP env = StrictEnvironment ( context = context , keep _ trailing _ newline = True ) DCNL DCSP DCSP template = env.from _ string ( contents ) DCNL DCSP DCSP output = template.render ( * * context ) DCNL DCSP DCSP temp.write ( output.encode ( &apos; utf-8 &apos; ) ) DCNL DCSP run _ script ( temp.name , cwd )
DCSP return &#91; address for address in addresses if is _ valid _ ip _ address ( address = address , family = socket.AF _ INET ) &#93;
DCSP return tf.square ( x )
DCSP pass
DCSP global livestreamer DCNL DCSP livestreamer = Livestreamer ( )
DCSP if ( not HAS _ BOTO ) : DCNL DCSP DCSP return ( False , &apos; The DCSP module DCSP boto _ cfs DCSP could DCSP not DCSP be DCSP loaded : DCSP boto DCSP libraries DCSP not DCSP found &apos; ) DCNL DCSP return True
DCSP app = inliner.document.settings.env.app DCNL DCSP tag = app.env.config &#91; &apos; version &apos; &#93; DCNL DCSP if ( &apos; -&apos; in tag ) : DCNL DCSP DCSP tag = &apos; master &apos; DCNL DCSP url = ( &apos; % s / tree / % s / % s &apos; % ( BOKEH _ GH , tag , text ) ) DCNL DCSP _ try _ url ( app , url , &apos; tree &apos; ) DCNL DCSP options = ( options or { } ) DCNL DCSP set _ classes ( options ) DCNL DCSP node = nodes.reference ( rawtext , text , refuri = url , * * options ) DCNL DCSP return ( &#91; node &#93; , &#91; &#93; )
DCSP sims = index &#91; query &#93; DCNL DCSP sims = sorted ( enumerate ( sims ) , key = ( lambda item : ( - item &#91; 1 &#93; ) ) ) DCNL DCSP result = &#91; &#93; DCNL DCSP for ( topid , topcosine ) in sims &#91; : n &#93; : DCNL DCSP DCSP result.append ( ( topid , topcosine , texts &#91; topid &#93; ) ) DCNL DCSP return result
DCSP nodelist = parser.parse ( ( &apos; endcache &apos; , ) ) DCNL DCSP parser.delete _ first _ token ( ) DCNL DCSP tokens = token.split _ contents ( ) DCNL DCSP if ( len ( tokens ) &lt; 3 ) : DCNL DCSP DCSP raise TemplateSyntaxError ( ( &quot; &apos; % r &apos; DCSP tag DCSP requires DCSP at DCSP least DCSP 2 DCSP arguments . &quot; % tokens &#91; 0 &#93; ) ) DCNL DCSP if ( ( len ( tokens ) &gt; 3 ) and tokens &#91; ( -1 ) &#93; .startswith ( &apos; using = &apos; ) ) : DCNL DCSP DCSP cache _ name = parser.compile _ filter ( tokens &#91; ( -1 ) &#93; &#91; len ( &apos; using = &apos; ) : &#93; ) DCNL DCSP DCSP tokens = tokens &#91; : ( -1 ) &#93; DCNL DCSP else : DCNL DCSP DCSP cache _ name = None DCNL DCSP return CacheNode ( nodelist , parser.compile _ filter ( tokens &#91; 1 &#93; ) , tokens &#91; 2 &#93; , &#91; parser.compile _ filter ( t ) for t in tokens &#91; 3 : &#93; &#93; , cache _ name )
DCSP data = { } DCNL DCSP if code : DCNL DCSP DCSP data &#91; ATTR _ CODE &#93; = code DCNL DCSP if entity _ id : DCNL DCSP DCSP data &#91; ATTR _ ENTITY _ ID &#93; = entity _ id DCNL DCSP hass.services.call ( DOMAIN , SERVICE _ UNLOCK , data )
DCSP rtl _ osversioninfoexw = RtlOSVersionInfoExw ( ) DCNL DCSP try : DCNL DCSP DCSP RtlGetVersion ( rtl _ osversioninfoexw ) DCNL DCSP except exceptions.WindowsError : DCNL DCSP DCSP return &apos; unknown &apos; DCNL DCSP return ( &apos; % d . % d . % d &apos; % ( rtl _ osversioninfoexw.dwMajorVersion , rtl _ osversioninfoexw.dwMinorVersion , rtl _ osversioninfoexw.dwBuildNumber ) )
DCSP if isinstance ( blob , BlobInfo ) : DCNL DCSP DCSP blob = blob.key ( ) DCNL DCSP rpc = blobstore.create _ rpc ( * * options ) DCNL DCSP rpc = blobstore.fetch _ data _ async ( blob , start _ index , end _ index , rpc = rpc ) DCNL DCSP result = ( yield rpc ) DCNL DCSP raise tasklets.Return ( result )
DCSP ( freqs , _ , Pxy ) = _ spectral _ helper ( x , y , fs , window , nperseg , noverlap , nfft , detrend , return _ onesided , scaling , axis , mode = &apos; psd &apos; ) DCNL DCSP if ( ( len ( Pxy.shape ) &gt; = 2 ) and ( Pxy.size &gt; 0 ) ) : DCNL DCSP DCSP if ( Pxy.shape &#91; ( -1 ) &#93; &gt; 1 ) : DCNL DCSP DCSP DCSP Pxy = Pxy.mean ( axis = ( -1 ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP Pxy = np.reshape ( Pxy , Pxy.shape &#91; : ( -1 ) &#93; ) DCNL DCSP return ( freqs , Pxy )
DCSP ( returncode , stdout , stderr ) = execute _ command ( command , cwd = cwd , shell = shell , env = env , stdin = stdin , stderr = stderr , preexec _ fn = preexec _ fn , use _ texpath = use _ texpath , show _ window = show _ window ) DCNL DCSP if returncode : DCNL DCSP DCSP e = CalledProcessError ( returncode , command ) DCNL DCSP DCSP e.output = stdout DCNL DCSP DCSP e.stderr = stderr DCNL DCSP DCSP raise e DCNL DCSP return stdout
DCSP from pylint.pyreverse.main import Run DCNL DCSP Run ( sys.argv &#91; 1 : &#93; )
DCSP w = _ current _ window _ for _ event ( event ) DCNL DCSP b = event.cli.current _ buffer DCNL DCSP if ( w and w.render _ info ) : DCNL DCSP DCSP line _ index = max ( 0 , min ( w.render _ info.first _ visible _ line ( ) , ( b.document.cursor _ position _ row - 1 ) ) ) DCNL DCSP DCSP b.cursor _ position = b.document.translate _ row _ col _ to _ index ( line _ index , 0 ) DCNL DCSP DCSP b.cursor _ position + = b.document.get _ start _ of _ line _ position ( after _ whitespace = True ) DCNL DCSP DCSP w.vertical _ scroll = 0
DCSP args = text.split ( ) DCNL DCSP repo = ( args &#91; 0 &#93; if ( args &#91; 0 &#93; not in shortcuts ) else shortcuts &#91; args &#91; 0 &#93; &#93; ) DCNL DCSP issue = ( args &#91; 1 &#93; if ( len ( args ) &gt; 1 ) else None ) DCNL DCSP if issue : DCNL DCSP DCSP r = requests.get ( &apos; https : / / api.github.com / repos / { } / issues / { } &apos; .format ( repo , issue ) ) DCNL DCSP DCSP j = r.json ( ) DCNL DCSP DCSP url = web.try _ shorten ( j &#91; &apos; html _ url &apos; &#93; , service = &apos; git.io &apos; ) DCNL DCSP DCSP number = j &#91; &apos; number &apos; &#93; DCNL DCSP DCSP title = j &#91; &apos; title &apos; &#93; DCNL DCSP DCSP summary = formatting.truncate ( j &#91; &apos; body &apos; &#93; .split ( &apos; \ n &apos; ) &#91; 0 &#93; , 25 ) DCNL DCSP DCSP if ( j &#91; &apos; state &apos; &#93; = = &apos; open &apos; ) : DCNL DCSP DCSP DCSP state = &apos; \ x033 \ x02Opened \ x02 \ x0f DCSP by DCSP { } &apos; .format ( j &#91; &apos; user &apos; &#93; &#91; &apos; login &apos; &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP state = &apos; \ x034 \ x02Closed \ x02 \ x0f DCSP by DCSP { } &apos; .format ( j &#91; &apos; closed _ by &apos; &#93; &#91; &apos; login &apos; &#93; ) DCNL DCSP DCSP return &apos; Issue DCSP # { } DCSP ( { } ) : DCSP { } DCSP &#124; DCSP { } : DCSP { } &apos; .format ( number , state , url , title , summary ) DCNL DCSP else : DCNL DCSP DCSP r = requests.get ( &apos; https : / / api.github.com / repos / { } / issues &apos; .format ( repo ) ) DCNL DCSP DCSP j = r.json ( ) DCNL DCSP DCSP count = len ( j ) DCNL DCSP DCSP if ( count is 0 ) : DCNL DCSP DCSP DCSP return &apos; Repository DCSP has DCSP no DCSP open DCSP issues . &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; Repository DCSP has DCSP { } DCSP open DCSP issues . &apos; .format ( count )
DCSP return skipUnless ( ( settings.ROOT _ URLCONF = = &apos; lms.urls &apos; ) , &apos; Test DCSP only DCSP valid DCSP in DCSP LMS &apos; ) ( func )
DCSP indexedLoop = indexedGrid &#91; 0 &#93; &#91; : &#93; DCNL DCSP for row in indexedGrid &#91; 1 : ( -1 ) &#93; : DCNL DCSP DCSP indexedLoop.append ( row &#91; ( -1 ) &#93; ) DCNL DCSP indexedLoop + = indexedGrid &#91; ( -1 ) &#93; &#91; : : ( -1 ) &#93; DCNL DCSP for row in indexedGrid &#91; ( len ( indexedGrid ) - 2 ) : 0 : ( -1 ) &#93; : DCNL DCSP DCSP indexedLoop.append ( row &#91; 0 &#93; ) DCNL DCSP return indexedLoop
DCSP err _ msg = None DCNL DCSP if settings.FEATURES.get ( &apos; ENFORCE _ PASSWORD _ POLICY &apos; , False ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP validate _ password _ strength ( password ) DCNL DCSP DCSP except ValidationError as err : DCNL DCSP DCSP DCSP err _ msg = ( _ ( &apos; Password : DCSP &apos; ) + &apos; ; DCSP &apos; .join ( err.messages ) ) DCNL DCSP if ( not PasswordHistory.is _ allowable _ password _ reuse ( user , password ) ) : DCNL DCSP DCSP if user.is _ staff : DCNL DCSP DCSP DCSP num _ distinct = settings.ADVANCED _ SECURITY _ CONFIG &#91; &apos; MIN _ DIFFERENT _ STAFF _ PASSWORDS _ BEFORE _ REUSE &apos; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP num _ distinct = settings.ADVANCED _ SECURITY _ CONFIG &#91; &apos; MIN _ DIFFERENT _ STUDENT _ PASSWORDS _ BEFORE _ REUSE &apos; &#93; DCNL DCSP DCSP err _ msg = ungettext ( &apos; You DCSP are DCSP re-using DCSP a DCSP password DCSP that DCSP you DCSP have DCSP used DCSP recently . DCSP You DCSP must DCSP have DCSP { num } DCSP distinct DCSP password DCSP before DCSP reusing DCSP a DCSP previous DCSP password . &apos; , &apos; You DCSP are DCSP re-using DCSP a DCSP password DCSP that DCSP you DCSP have DCSP used DCSP recently . DCSP You DCSP must DCSP have DCSP { num } DCSP distinct DCSP passwords DCSP before DCSP reusing DCSP a DCSP previous DCSP password . &apos; , num _ distinct ) .format ( num = num _ distinct ) DCNL DCSP if PasswordHistory.is _ password _ reset _ too _ soon ( user ) : DCNL DCSP DCSP num _ days = settings.ADVANCED _ SECURITY _ CONFIG &#91; &apos; MIN _ TIME _ IN _ DAYS _ BETWEEN _ ALLOWED _ RESETS &apos; &#93; DCNL DCSP DCSP err _ msg = ungettext ( &apos; You DCSP are DCSP resetting DCSP passwords DCSP too DCSP frequently . DCSP Due DCSP to DCSP security DCSP policies , DCSP { num } DCSP day DCSP must DCSP elapse DCSP between DCSP password DCSP resets . &apos; , &apos; You DCSP are DCSP resetting DCSP passwords DCSP too DCSP frequently . DCSP Due DCSP to DCSP security DCSP policies , DCSP { num } DCSP days DCSP must DCSP elapse DCSP between DCSP password DCSP resets . &apos; , num _ days ) .format ( num = num _ days ) DCNL DCSP is _ password _ valid = ( err _ msg is None ) DCNL DCSP return ( is _ password _ valid , err _ msg )
DCSP return ( is _ success ( status _ int ) or is _ redirection ( status _ int ) or ( status _ int = = HTTP _ NOT _ FOUND ) or ( status _ int = = HTTP _ PRECONDITION _ FAILED ) or ( status _ int = = HTTP _ REQUESTED _ RANGE _ NOT _ SATISFIABLE ) )
DCSP attr = getattr ( obj , &apos; _ _ numba _ _ &apos; , None ) DCNL DCSP if attr : DCNL DCSP DCSP return getattr ( obj , attr ) DCNL DCSP return obj
DCSP import slacker DCNL DCSP try : DCNL DCSP DCSP return SlackNotificationService ( config &#91; CONF _ CHANNEL &#93; , config &#91; CONF _ API _ KEY &#93; , config.get ( CONF _ USERNAME , None ) , config.get ( CONF _ ICON , None ) ) DCNL DCSP except slacker.Error : DCNL DCSP DCSP _ LOGGER.exception ( &apos; Slack DCSP authentication DCSP failed &apos; ) DCNL DCSP DCSP return None
DCSP try : DCNL DCSP DCSP result = f ( * args , * * kw ) DCNL DCSP except : DCNL DCSP DCSP return fail ( failure.Failure ( captureVars = Deferred.debug ) ) DCNL DCSP if isinstance ( result , Deferred ) : DCNL DCSP DCSP return result DCNL DCSP elif isinstance ( result , failure.Failure ) : DCNL DCSP DCSP return fail ( result ) DCNL DCSP else : DCNL DCSP DCSP return succeed ( result )
DCSP metaFilePath = archive.getSkeinforgePluginsPath ( &apos; meta.py &apos; ) DCNL DCSP settings.addPluginsParentToMenu ( skeinforge _ meta.getPluginsDirectoryPath ( ) , menu , metaFilePath , skeinforge _ meta.getPluginFileNames ( ) )
DCSP @ functools.wraps ( test ) DCNL DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP msg = &apos; { name } DCSP only DCSP runs DCSP on DCSP Python2.6.x DCSP or DCSP older &apos; .format ( name = test . _ _ name _ _ ) DCNL DCSP DCSP if ( sys.version _ info &gt; = ( 2 , 7 ) ) : DCNL DCSP DCSP DCSP raise SkipTest ( msg ) DCNL DCSP DCSP return test ( * args , * * kwargs ) DCNL DCSP return wrapper
DCSP return LazyLoader ( _ module _ dirs ( opts , &apos; grains &apos; , &apos; grain &apos; , ext _ type _ dirs = &apos; grains _ dirs &apos; ) , opts , tag = &apos; grains &apos; )
DCSP response = _ client _ wrapper ( &apos; connect _ container _ to _ network &apos; , container , network _ id ) DCNL DCSP _ clear _ context ( ) DCNL DCSP return response
DCSP if ( key in listTable ) : DCNL DCSP DCSP listTable &#91; key &#93; + = elementList DCNL DCSP else : DCNL DCSP DCSP listTable &#91; key &#93; = elementList
DCSP x = &#91; 8 , 8 , 8 , 10 , 10 , 10 , 12 , 12 , 12 , 14 , 14 &#93; DCNL DCSP y = &#91; 21 , 23.5 , 23 , 24 , 21 , 25 , 21.5 , 22 , 19 , 23.5 , 25 &#93; DCNL DCSP y _ true = &#91; 22.22222 , 22.22222 , 22.22222 , 22.22222 , 22.22222 , 22.22222 , 22.22222 , 22.22222 , 22.22222 , 24.25 , 24.25 &#93; DCNL DCSP ir = IsotonicRegression ( ) DCNL DCSP ir.fit ( x , y ) DCNL DCSP assert _ array _ almost _ equal ( ir.transform ( x ) , y _ true , 4 ) DCNL DCSP assert _ array _ almost _ equal ( ir.fit _ transform ( x , y ) , y _ true , 4 )
DCSP return render ( request , &apos; ecosystem / publish _ badges.html &apos; , { &apos; page &apos; : &apos; badges &apos; , &apos; category &apos; : &apos; publish &apos; } )
DCSP arg _ dict = ProcessArguments ( arg _ dict ) DCNL DCSP SetupLogging ( arg _ dict ) DCNL DCSP return _ PerformBulkload ( arg _ dict , oauth2 _ parameters )
DCSP return ( &apos; boto _ kms &apos; if ( &apos; boto _ kms.describe _ key &apos; in _ _ salt _ _ ) else False )
DCSP ( best _ fitness , best _ fit _ q ) = ( ( -1 ) , 0 ) DCNL DCSP ( target _ type , target _ subtype , target _ params ) = parse _ media _ range ( mime _ type ) DCNL DCSP for ( type , subtype , params ) in parsed _ ranges : DCNL DCSP DCSP if ( ( ( type = = target _ type ) or ( type = = &apos; * &apos; ) or ( target _ type = = &apos; * &apos; ) ) and ( ( subtype = = target _ subtype ) or ( subtype = = &apos; * &apos; ) or ( target _ subtype = = &apos; * &apos; ) ) ) : DCNL DCSP DCSP DCSP fitness = 0 DCNL DCSP DCSP DCSP if ( type = = target _ type ) : DCNL DCSP DCSP DCSP DCSP fitness + = 100 DCNL DCSP DCSP DCSP if ( subtype = = target _ subtype ) : DCNL DCSP DCSP DCSP DCSP fitness + = 10 DCNL DCSP DCSP DCSP for key in target _ params : DCNL DCSP DCSP DCSP DCSP if ( ( key ! = &apos; q &apos; ) and ( key in params ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( params &#91; key &#93; = = target _ params &#91; key &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP fitness + = 1 DCNL DCSP DCSP DCSP if ( fitness &gt; best _ fitness ) : DCNL DCSP DCSP DCSP DCSP best _ fitness = fitness DCNL DCSP DCSP DCSP DCSP best _ fit _ q = params &#91; &apos; q &apos; &#93; DCNL DCSP return ( best _ fitness , float ( best _ fit _ q ) )
DCSP if ( not isinstance ( s , ( binary _ type , text _ type ) ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; % r DCSP is DCSP neither DCSP bytes DCSP nor DCSP unicode &apos; % s ) ) DCNL DCSP if PY3 : DCNL DCSP DCSP if isinstance ( s , binary _ type ) : DCNL DCSP DCSP DCSP return s.decode ( &apos; utf-8 &apos; ) DCNL DCSP elif isinstance ( s , text _ type ) : DCNL DCSP DCSP return s.encode ( &apos; utf-8 &apos; ) DCNL DCSP return s
DCSP ratio = 1.0 DCNL DCSP cc = ClusterCentroids ( ratio = ratio , random _ state = RND _ SEED ) DCNL DCSP assert _ equal ( cc.ratio , ratio )
DCSP version _ parts = &#91; int ( p ) for p in version.split ( &apos; .&apos; ) &#93; DCNL DCSP assert ( len ( version _ parts ) = = 3 ) , &apos; invalid DCSP version DCSP number &apos; DCNL DCSP minor = &apos; { } . { } &apos; .format ( * version _ parts ) DCNL DCSP major = &apos; { } &apos; .format ( * version _ parts ) DCNL DCSP for ( filename , locations ) in VERSION _ LOCS : DCNL DCSP DCSP out _ lines = &#91; &#93; DCNL DCSP DCSP with open ( filename ) as f : DCNL DCSP DCSP DCSP found = False DCNL DCSP DCSP DCSP for line in f : DCNL DCSP DCSP DCSP DCSP for ( pattern , template ) in locations : DCNL DCSP DCSP DCSP DCSP DCSP match = re.match ( pattern , line ) DCNL DCSP DCSP DCSP DCSP DCSP if match : DCNL DCSP DCSP DCSP DCSP DCSP DCSP old _ version = match.group ( 1 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP old _ parts = &#91; int ( p ) for p in old _ version.split ( &apos; .&apos; ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP assert ( version _ parts &gt; old _ parts ) , &apos; version DCSP must DCSP be DCSP newer DCSP than DCSP { } &apos; .format ( old _ version ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP out _ lines.append ( ( template.format ( version = version , major = major , minor = minor ) + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP found = True DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP out _ lines.append ( line ) DCNL DCSP DCSP DCSP if ( not found ) : DCNL DCSP DCSP DCSP DCSP print &apos; No DCSP pattern DCSP found DCSP in DCSP { } &apos; .format ( filename ) DCNL DCSP DCSP with open ( filename , &apos; w &apos; ) as f : DCNL DCSP DCSP DCSP f.write ( &apos; &apos;.join ( out _ lines ) ) DCNL DCSP header _ line = &apos; { } DCSP ( in DCSP development ) &apos; .format ( version ) DCNL DCSP header = ( ( ( ( &apos; \ n \ n &apos; + header _ line ) + &apos; \ n &apos; ) + ( &apos; -&apos; * len ( header _ line ) ) ) + &apos; \ n \ n &apos; ) DCNL DCSP header + = &apos; Changelog DCSP goes DCSP here ! \ n &apos; DCNL DCSP with open ( CHANGELOG ) as f : DCNL DCSP DCSP contents = f.read ( ) DCNL DCSP location = contents.find ( &apos; \ n \ n &apos; ) DCNL DCSP contents = ( ( contents &#91; : location &#93; + header ) + contents &#91; location : &#93; ) DCNL DCSP with open ( CHANGELOG , &apos; w &apos; ) as f : DCNL DCSP DCSP f.write ( contents )
DCSP retVal = None DCNL DCSP filePath = None DCNL DCSP _ = os.path.dirname ( _ _ file _ _ ) DCNL DCSP while True : DCNL DCSP DCSP filePath = os.path.join ( _ , &apos; .git &apos; , &apos; HEAD &apos; ) DCNL DCSP DCSP if os.path.exists ( filePath ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP filePath = None DCNL DCSP DCSP DCSP if ( _ = = os.path.dirname ( _ ) ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP _ = os.path.dirname ( _ ) DCNL DCSP while True : DCNL DCSP DCSP if ( filePath and os.path.isfile ( filePath ) ) : DCNL DCSP DCSP DCSP with open ( filePath , &apos; r &apos; ) as f : DCNL DCSP DCSP DCSP DCSP content = f.read ( ) DCNL DCSP DCSP DCSP DCSP filePath = None DCNL DCSP DCSP DCSP DCSP if content.startswith ( &apos; ref : DCSP &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP filePath = os.path.join ( _ , &apos; .git &apos; , content.replace ( &apos; ref : DCSP &apos; , &apos; &apos; ) ) .strip ( ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP match = re.match ( &apos; ( ? i ) &#91; 0-9a-f &#93; { 32 } &apos; , content ) DCNL DCSP DCSP DCSP DCSP DCSP retVal = ( match.group ( 0 ) if match else None ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break DCNL DCSP if ( not retVal ) : DCNL DCSP DCSP process = subprocess.Popen ( &apos; git DCSP rev-parse DCSP --verify DCSP HEAD &apos; , shell = True , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP DCSP ( stdout , _ ) = process.communicate ( ) DCNL DCSP DCSP match = re.search ( &apos; ( ? i ) &#91; 0-9a-f &#93; { 32 } &apos; , ( stdout or &apos; &apos; ) ) DCNL DCSP DCSP retVal = ( match.group ( 0 ) if match else None ) DCNL DCSP return ( retVal &#91; : 7 &#93; if retVal else None )
DCSP ncr = NeighbourhoodCleaningRule ( random _ state = RND _ SEED ) DCNL DCSP ( X _ resampled , y _ resampled ) = ncr.fit _ sample ( X , Y ) DCNL DCSP X _ gt = np.array ( &#91; &#91; ( -1.20809175 ) , ( -1.49917302 ) &#93; , &#91; ( -0.60497017 ) , ( -0.66630228 ) &#93; , &#91; ( -0.91735824 ) , 0.93110278 &#93; , &#91; ( -0.20413357 ) , 0.64628718 &#93; , &#91; 0.35967591 , 2.61186964 &#93; , &#91; ( -1.55581933 ) , 1.09609604 &#93; , &#91; 1.55157493 , ( -1.6981518 ) &#93; &#93; ) DCNL DCSP y _ gt = np.array ( &#91; 0 , 0 , 1 , 1 , 2 , 1 , 2 &#93; ) DCNL DCSP assert _ array _ equal ( X _ resampled , X _ gt ) DCNL DCSP assert _ array _ equal ( y _ resampled , y _ gt )
DCSP ret = { } DCNL DCSP cmd = &#91; &apos; dpkg &apos; , &apos; --get-selections &apos; &#93; DCNL DCSP cmd.append ( ( pattern if pattern else &apos; * &apos; ) ) DCNL DCSP stdout = _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( cmd , output _ loglevel = &apos; trace &apos; , python _ shell = False ) DCNL DCSP ret = _ parse _ selections ( stdout ) DCNL DCSP if state : DCNL DCSP DCSP return { state : ret.get ( state , &#91; &#93; ) } DCNL DCSP return ret
DCSP modifiable = { &apos; CacheSubnetGroupDescription &apos; : &apos; CacheSubnetGroupDescription &apos; , &apos; SubnetIds &apos; : &apos; SubnetIds &apos; } DCNL DCSP need _ update = { } DCNL DCSP for ( m , o ) in modifiable.items ( ) : DCNL DCSP DCSP if ( m in desired ) : DCNL DCSP DCSP DCSP if ( not o ) : DCNL DCSP DCSP DCSP DCSP need _ update &#91; m &#93; = desired &#91; m &#93; DCNL DCSP DCSP DCSP elif ( m in current ) : DCNL DCSP DCSP DCSP DCSP if ( current &#91; m &#93; ! = desired &#91; m &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP need _ update &#91; m &#93; = desired &#91; m &#93; DCNL DCSP return need _ update
DCSP cache _ db _ con = db.DBConnection ( &apos; cache.db &apos; ) DCNL DCSP cache _ db _ con.action ( &apos; DELETE DCSP FROM DCSP scene _ names DCSP WHERE DCSP indexer _ id DCSP = DCSP ? DCSP OR DCSP indexer _ id DCSP = DCSP ? &apos; , ( indexerid , 0 ) ) DCNL DCSP toRemove = &#91; key for ( key , value ) in nameCache.iteritems ( ) if ( value in ( 0 , indexerid ) ) &#93; DCNL DCSP for key in toRemove : DCNL DCSP DCSP del nameCache &#91; key &#93;
DCSP return ( ( srv = = constants.STAGING _ URI ) or ( &apos; staging &apos; in srv ) )
DCSP if ( i &gt; = len ( mylist ) ) : DCNL DCSP DCSP return default DCNL DCSP else : DCNL DCSP DCSP return mylist &#91; i &#93;
DCSP return ( &apos; &quot; % s &quot; &apos; % value )
DCSP fillOfSurroundings = &#91; &#93; DCNL DCSP for surroundingLoop in surroundingLoops : DCNL DCSP DCSP fillOfSurroundings + = surroundingLoop.getFillLoops ( ) DCNL DCSP return fillOfSurroundings
DCSP if ( _ func is not None ) : DCNL DCSP DCSP return decorate ( _ func , caller ) DCNL DCSP if inspect.isclass ( caller ) : DCNL DCSP DCSP name = caller . _ _ name _ _ .lower ( ) DCNL DCSP DCSP doc = ( &apos; decorator ( % s ) DCSP converts DCSP functions / generators DCSP into DCSP factories DCSP of DCSP % s DCSP objects &apos; % ( caller . _ _ name _ _ , caller . _ _ name _ _ ) ) DCNL DCSP elif inspect.isfunction ( caller ) : DCNL DCSP DCSP if ( caller . _ _ name _ _ = = &apos; &lt; lambda &gt; &apos; ) : DCNL DCSP DCSP DCSP name = &apos; _ lambda _ &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP name = caller . _ _ name _ _ DCNL DCSP DCSP doc = caller . _ _ doc _ _ DCNL DCSP else : DCNL DCSP DCSP name = caller . _ _ class _ _ . _ _ name _ _ .lower ( ) DCNL DCSP DCSP doc = caller . _ _ call _ _ . _ _ doc _ _ DCNL DCSP evaldict = dict ( _ call _ = caller , _ decorate _ = decorate ) DCNL DCSP return FunctionMaker.create ( ( &apos; % s ( func ) &apos; % name ) , &apos; return DCSP _ decorate _ ( func , DCSP _ call _ ) &apos; , evaldict , doc = doc , module = caller . _ _ module _ _ , _ _ wrapped _ _ = caller )
DCSP exploration = get _ exploration _ by _ id ( exploration _ id ) DCNL DCSP exp _ summary = compute _ summary _ of _ exploration ( exploration , contributor _ id _ to _ add ) DCNL DCSP save _ exploration _ summary ( exp _ summary )
DCSP res = ( &apos; ( % s ) - &apos; % fuzzable _ request.get _ method ( ) .upper ( ) ) DCNL DCSP res + = clean _ url ( fuzzable _ request.get _ uri ( ) , dc _ handler = dc _ handler ) DCNL DCSP raw _ data = fuzzable _ request.get _ raw _ data ( ) DCNL DCSP if raw _ data : DCNL DCSP DCSP res + = ( &apos; ! &apos; + dc _ handler ( raw _ data ) ) DCNL DCSP return res
DCSP logging.info ( &apos; deprecated : DCSP DCSP microphone.switchOff ( ) DCSP is DCSP no DCSP longer DCSP needed . &apos; )
DCSP return absolute _ uri ( get _ asset _ url ( module , path ) )
DCSP namespace = namespace _ api.get ( context , namespace _ name , session ) DCNL DCSP resource _ type _ name = values &#91; &apos; name &apos; &#93; DCNL DCSP metadef _ utils.drop _ protected _ attrs ( models.MetadefNamespaceResourceType , values ) DCNL DCSP try : DCNL DCSP DCSP resource _ type = resource _ type _ api.get ( context , resource _ type _ name , session ) DCNL DCSP except exc.NotFound : DCNL DCSP DCSP resource _ type = None DCNL DCSP DCSP LOG.debug ( &apos; Creating DCSP resource-type DCSP % s &apos; , resource _ type _ name ) DCNL DCSP if ( resource _ type is None ) : DCNL DCSP DCSP resource _ type _ dict = { &apos; name &apos; : resource _ type _ name , &apos; protected &apos; : False } DCNL DCSP DCSP resource _ type = resource _ type _ api.create ( context , resource _ type _ dict , session ) DCNL DCSP ns _ resource _ type _ dict = _ to _ db _ dict ( namespace &#91; &apos; id &apos; &#93; , resource _ type &#91; &apos; id &apos; &#93; , values ) DCNL DCSP new _ rec = _ create _ association ( context , namespace _ name , resource _ type _ name , ns _ resource _ type _ dict , session ) DCNL DCSP return _ to _ model _ dict ( resource _ type _ name , new _ rec )
DCSP return LabelArray ( array.astype ( initial _ dtype ) , missing _ value = initial _ dtype.type ( missing _ value ) )
DCSP try : DCNL DCSP DCSP v = get _ scalar _ constant _ value ( var ) DCNL DCSP DCSP return ( v = = val ) DCNL DCSP except NotScalarConstantError : DCNL DCSP DCSP return False
DCSP thin _ path = os.path.join ( OPTIONS.saltdir , THIN _ ARCHIVE ) DCNL DCSP if os.path.isfile ( thin _ path ) : DCNL DCSP DCSP if ( OPTIONS.checksum ! = get _ hash ( thin _ path , OPTIONS.hashfunc ) ) : DCNL DCSP DCSP DCSP need _ deployment ( ) DCNL DCSP DCSP unpack _ thin ( thin _ path ) DCNL DCSP else : DCNL DCSP DCSP scpstat = subprocess.Popen ( &#91; &apos; / bin / sh &apos; , &apos; -c &apos; , &apos; command DCSP -v DCSP scp &apos; &#93; ) .wait ( ) DCNL DCSP DCSP if ( scpstat ! = 0 ) : DCNL DCSP DCSP DCSP sys.exit ( EX _ SCP _ NOT _ FOUND ) DCNL DCSP DCSP if ( not os.path.exists ( OPTIONS.saltdir ) ) : DCNL DCSP DCSP DCSP need _ deployment ( ) DCNL DCSP DCSP if ( not os.path.isdir ( OPTIONS.saltdir ) ) : DCNL DCSP DCSP DCSP sys.stderr.write ( &apos; ERROR : DCSP salt DCSP path DCSP &quot; { 0 } &quot; DCSP exists DCSP but DCSP is DCSP not DCSP a DCSP directory \ n &apos; .format ( OPTIONS.saltdir ) ) DCNL DCSP DCSP DCSP sys.exit ( EX _ CANTCREAT ) DCNL DCSP DCSP version _ path = os.path.join ( OPTIONS.saltdir , &apos; version &apos; ) DCNL DCSP DCSP if ( ( not os.path.exists ( version _ path ) ) or ( not os.path.isfile ( version _ path ) ) ) : DCNL DCSP DCSP DCSP sys.stderr.write ( &apos; WARNING : DCSP Unable DCSP to DCSP locate DCSP current DCSP thin DCSP DCSP version : DCSP { 0 } . \ n &apos; .format ( version _ path ) ) DCNL DCSP DCSP DCSP need _ deployment ( ) DCNL DCSP DCSP with open ( version _ path , &apos; r &apos; ) as vpo : DCNL DCSP DCSP DCSP cur _ version = vpo.readline ( ) .strip ( ) DCNL DCSP DCSP if ( cur _ version ! = OPTIONS.version ) : DCNL DCSP DCSP DCSP sys.stderr.write ( &apos; WARNING : DCSP current DCSP thin DCSP version DCSP { 0 } DCSP is DCSP not DCSP up-to-date DCSP with DCSP { 1 } . \ n &apos; .format ( cur _ version , OPTIONS.version ) ) DCNL DCSP DCSP DCSP need _ deployment ( ) DCNL DCSP salt _ call _ path = os.path.join ( OPTIONS.saltdir , &apos; salt-call &apos; ) DCNL DCSP if ( not os.path.isfile ( salt _ call _ path ) ) : DCNL DCSP DCSP sys.stderr.write ( &apos; ERROR : DCSP thin DCSP is DCSP missing DCSP &quot; { 0 } &quot; \ n &apos; .format ( salt _ call _ path ) ) DCNL DCSP DCSP need _ deployment ( ) DCNL DCSP with open ( os.path.join ( OPTIONS.saltdir , &apos; minion &apos; ) , &apos; w &apos; ) as config : DCNL DCSP DCSP config.write ( ( OPTIONS.config + &apos; \ n &apos; ) ) DCNL DCSP if OPTIONS.ext _ mods : DCNL DCSP DCSP ext _ path = os.path.join ( OPTIONS.saltdir , EXT _ ARCHIVE ) DCNL DCSP DCSP if os.path.exists ( ext _ path ) : DCNL DCSP DCSP DCSP unpack _ ext ( ext _ path ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP version _ path = os.path.join ( OPTIONS.saltdir , &apos; ext _ version &apos; ) DCNL DCSP DCSP DCSP if ( ( not os.path.exists ( version _ path ) ) or ( not os.path.isfile ( version _ path ) ) ) : DCNL DCSP DCSP DCSP DCSP need _ ext ( ) DCNL DCSP DCSP DCSP with open ( version _ path , &apos; r &apos; ) as vpo : DCNL DCSP DCSP DCSP DCSP cur _ version = vpo.readline ( ) .strip ( ) DCNL DCSP DCSP DCSP if ( cur _ version ! = OPTIONS.ext _ mods ) : DCNL DCSP DCSP DCSP DCSP need _ ext ( ) DCNL DCSP if ( len ( ARGS ) = = 1 ) : DCNL DCSP DCSP argv _ prepared = ARGS &#91; 0 &#93; .split ( ) DCNL DCSP else : DCNL DCSP DCSP argv _ prepared = ARGS DCNL DCSP salt _ argv = ( &#91; sys.executable , salt _ call _ path , &apos; --retcode-passthrough &apos; , &apos; --local &apos; , &apos; --metadata &apos; , &apos; --out &apos; , &apos; json &apos; , &apos; -l &apos; , &apos; quiet &apos; , &apos; -c &apos; , OPTIONS.saltdir , &apos; -- &apos; &#93; + argv _ prepared ) DCNL DCSP sys.stderr.write ( &apos; SALT _ ARGV : DCSP { 0 } \ n &apos; .format ( salt _ argv ) ) DCNL DCSP sys.stdout.write ( ( OPTIONS.delimiter + &apos; \ n &apos; ) ) DCNL DCSP sys.stdout.flush ( ) DCNL DCSP if ( not OPTIONS.tty ) : DCNL DCSP DCSP sys.stderr.write ( ( OPTIONS.delimiter + &apos; \ n &apos; ) ) DCNL DCSP DCSP sys.stderr.flush ( ) DCNL DCSP if ( OPTIONS.cmd _ umask is not None ) : DCNL DCSP DCSP old _ umask = os.umask ( OPTIONS.cmd _ umask ) DCNL DCSP if OPTIONS.tty : DCNL DCSP DCSP ( stdout , _ ) = subprocess.Popen ( salt _ argv , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) .communicate ( ) DCNL DCSP DCSP sys.stdout.write ( stdout ) DCNL DCSP DCSP sys.stdout.flush ( ) DCNL DCSP DCSP if OPTIONS.wipe : DCNL DCSP DCSP DCSP shutil.rmtree ( OPTIONS.saltdir ) DCNL DCSP elif OPTIONS.wipe : DCNL DCSP DCSP subprocess.call ( salt _ argv ) DCNL DCSP DCSP shutil.rmtree ( OPTIONS.saltdir ) DCNL DCSP else : DCNL DCSP DCSP subprocess.call ( salt _ argv ) DCNL DCSP if ( OPTIONS.cmd _ umask is not None ) : DCNL DCSP DCSP os.umask ( old _ umask )
DCSP canvas = FigureCanvasQTAgg ( figure ) DCNL DCSP return FigureManagerQT ( canvas , num )
DCSP return ndi.morphology.generate _ binary _ structure ( ndim , 1 )
DCSP config _ stub.data = { &apos; colors &apos; : { &apos; keyhint.fg &apos; : &apos; white &apos; , &apos; keyhint.fg.suffix &apos; : &apos; yellow &apos; , &apos; keyhint.bg &apos; : &apos; black &apos; } , &apos; fonts &apos; : { &apos; keyhint &apos; : &apos; Comic DCSP Sans &apos; } , &apos; ui &apos; : { &apos; keyhint-blacklist &apos; : &apos; &apos; , &apos; status-position &apos; : &apos; bottom &apos; } } DCNL DCSP keyhint = KeyHintView ( 0 , None ) DCNL DCSP qtbot.add _ widget ( keyhint ) DCNL DCSP assert ( keyhint.text ( ) = = &apos; &apos; ) DCNL DCSP return keyhint
DCSP fmt = &apos; ! lh32s &apos; DCNL DCSP size = struct.calcsize ( fmt ) DCNL DCSP with StringIO ( binary _ tuples ) as f : DCNL DCSP DCSP return &#91; ( datetime.datetime.fromtimestamp ( ts ) , binascii.hexlify ( tok ) ) for ( ts , toklen , tok ) in ( struct.unpack ( fmt , tup ) for tup in iter ( ( lambda : f.read ( size ) ) , &apos; &apos; ) ) &#93;
DCSP task _ history = worker . _ add _ task _ history DCNL DCSP pending _ tasks = { task for ( task , status , ext ) in task _ history if ( status = = &apos; PENDING &apos; ) } DCNL DCSP set _ tasks = { } DCNL DCSP set _ tasks &#91; &apos; completed &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( ( status = = &apos; DONE &apos; ) and ( task in pending _ tasks ) ) } DCNL DCSP set _ tasks &#91; &apos; already _ done &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( ( status = = &apos; DONE &apos; ) and ( task not in pending _ tasks ) and ( task not in set _ tasks &#91; &apos; completed &apos; &#93; ) ) } DCNL DCSP set _ tasks &#91; &apos; ever _ failed &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( status = = &apos; FAILED &apos; ) } DCNL DCSP set _ tasks &#91; &apos; failed &apos; &#93; = ( set _ tasks &#91; &apos; ever _ failed &apos; &#93; - set _ tasks &#91; &apos; completed &apos; &#93; ) DCNL DCSP set _ tasks &#91; &apos; scheduling _ error &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( status = = &apos; UNKNOWN &apos; ) } DCNL DCSP set _ tasks &#91; &apos; still _ pending _ ext &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( ( status = = &apos; PENDING &apos; ) and ( task not in set _ tasks &#91; &apos; ever _ failed &apos; &#93; ) and ( task not in set _ tasks &#91; &apos; completed &apos; &#93; ) and ( not ext ) ) } DCNL DCSP set _ tasks &#91; &apos; still _ pending _ not _ ext &apos; &#93; = { task for ( task , status , ext ) in task _ history if ( ( status = = &apos; PENDING &apos; ) and ( task not in set _ tasks &#91; &apos; ever _ failed &apos; &#93; ) and ( task not in set _ tasks &#91; &apos; completed &apos; &#93; ) and ext ) } DCNL DCSP set _ tasks &#91; &apos; run _ by _ other _ worker &apos; &#93; = set ( ) DCNL DCSP set _ tasks &#91; &apos; upstream _ failure &apos; &#93; = set ( ) DCNL DCSP set _ tasks &#91; &apos; upstream _ missing _ dependency &apos; &#93; = set ( ) DCNL DCSP set _ tasks &#91; &apos; upstream _ run _ by _ other _ worker &apos; &#93; = set ( ) DCNL DCSP set _ tasks &#91; &apos; upstream _ scheduling _ error &apos; &#93; = set ( ) DCNL DCSP set _ tasks &#91; &apos; not _ run &apos; &#93; = set ( ) DCNL DCSP return set _ tasks
DCSP excs = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP os.chmod ( dirname , ( ( stat.S _ IWRITE &#124; stat.S _ IEXEC ) &#124; stat.S _ IREAD ) ) DCNL DCSP DCSP for f in os.listdir ( dirname ) : DCNL DCSP DCSP DCSP fullname = os.path.join ( dirname , f ) DCNL DCSP DCSP DCSP if os.path.isdir ( fullname ) : DCNL DCSP DCSP DCSP DCSP rm _ dir ( fullname ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP remove ( fullname ) DCNL DCSP DCSP os.rmdir ( dirname ) DCNL DCSP except EnvironmentError as le : DCNL DCSP DCSP if ( ( ( le.args &#91; 0 &#93; ! = 2 ) and ( le.args &#91; 0 &#93; ! = 3 ) ) or ( le.args &#91; 0 &#93; ! = errno.ENOENT ) ) : DCNL DCSP DCSP DCSP excs.append ( le ) DCNL DCSP except Exception as le : DCNL DCSP DCSP excs.append ( le ) DCNL DCSP if os.path.exists ( dirname ) : DCNL DCSP DCSP if ( len ( excs ) = = 1 ) : DCNL DCSP DCSP DCSP raise excs &#91; 0 &#93; DCNL DCSP DCSP if ( len ( excs ) = = 0 ) : DCNL DCSP DCSP DCSP raise OSError , &apos; Failed DCSP to DCSP remove DCSP dir DCSP for DCSP unknown DCSP reason . &apos; DCNL DCSP DCSP raise OSError , excs
DCSP assert ( ( batch _ size % num _ skips ) = = 0 ) DCNL DCSP assert ( num _ skips &lt; = ( 2 * skip _ window ) ) DCNL DCSP batch = np.ndarray ( shape = batch _ size , dtype = np.int32 ) DCNL DCSP labels = np.ndarray ( shape = ( batch _ size , 1 ) , dtype = np.int32 ) DCNL DCSP span = ( ( 2 * skip _ window ) + 1 ) DCNL DCSP buffer = collections.deque ( maxlen = span ) DCNL DCSP for _ in range ( span ) : DCNL DCSP DCSP buffer.append ( data &#91; data _ index &#93; ) DCNL DCSP DCSP data _ index = ( ( data _ index + 1 ) % len ( data ) ) DCNL DCSP for i in range ( ( batch _ size / / num _ skips ) ) : DCNL DCSP DCSP target = skip _ window DCNL DCSP DCSP targets _ to _ avoid = &#91; skip _ window &#93; DCNL DCSP DCSP for j in range ( num _ skips ) : DCNL DCSP DCSP DCSP while ( target in targets _ to _ avoid ) : DCNL DCSP DCSP DCSP DCSP target = random.randint ( 0 , ( span - 1 ) ) DCNL DCSP DCSP DCSP targets _ to _ avoid.append ( target ) DCNL DCSP DCSP DCSP batch &#91; ( ( i * num _ skips ) + j ) &#93; = buffer &#91; skip _ window &#93; DCNL DCSP DCSP DCSP labels &#91; ( ( ( i * num _ skips ) + j ) , 0 ) &#93; = buffer &#91; target &#93; DCNL DCSP DCSP buffer.append ( data &#91; data _ index &#93; ) DCNL DCSP DCSP data _ index = ( ( data _ index + 1 ) % len ( data ) ) DCNL DCSP return ( batch , labels , data _ index )
DCSP from .singleton import S DCNL DCSP from .basic import Basic DCNL DCSP from .sympify import sympify , SympifyError DCNL DCSP from .compatibility import iterable DCNL DCSP if isinstance ( item , Basic ) : DCNL DCSP DCSP return item.sort _ key ( order = order ) DCNL DCSP if iterable ( item , exclude = string _ types ) : DCNL DCSP DCSP if isinstance ( item , dict ) : DCNL DCSP DCSP DCSP args = item.items ( ) DCNL DCSP DCSP DCSP unordered = True DCNL DCSP DCSP elif isinstance ( item , set ) : DCNL DCSP DCSP DCSP args = item DCNL DCSP DCSP DCSP unordered = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP args = list ( item ) DCNL DCSP DCSP DCSP unordered = False DCNL DCSP DCSP args = &#91; default _ sort _ key ( arg , order = order ) for arg in args &#93; DCNL DCSP DCSP if unordered : DCNL DCSP DCSP DCSP args = sorted ( args ) DCNL DCSP DCSP ( cls _ index , args ) = ( 10 , ( len ( args ) , tuple ( args ) ) ) DCNL DCSP else : DCNL DCSP DCSP if ( not isinstance ( item , string _ types ) ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP item = sympify ( item ) DCNL DCSP DCSP DCSP except SympifyError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if isinstance ( item , Basic ) : DCNL DCSP DCSP DCSP DCSP DCSP return default _ sort _ key ( item ) DCNL DCSP DCSP ( cls _ index , args ) = ( 0 , ( 1 , ( str ( item ) , ) ) ) DCNL DCSP return ( ( cls _ index , 0 , item . _ _ class _ _ . _ _ name _ _ ) , args , S.One.sort _ key ( ) , S.One )
DCSP IMPL.aggregate _ metadata _ add ( context , aggregate _ id , metadata , set _ delete )
DCSP pattern = &apos; ( \ \ &quot; . * ? \ \ &quot; &#124; \ \ \ &apos; . * ? \ \ \ &apos; ) &#124; ( / \ \ * . * ? \ \ * / &#124; / / &#91; ^ \ \ r \ \ n &#93; * \ \ n ) &apos; DCNL DCSP regex = re.compile ( pattern , ( re.MULTILINE &#124; re.DOTALL ) ) DCNL DCSP def do _ replace ( match ) : DCNL DCSP DCSP if ( match.group ( 2 ) is not None ) : DCNL DCSP DCSP DCSP return &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return match.group ( 1 ) DCNL DCSP return regex.sub ( do _ replace , code )
DCSP if ( derivation = = None ) : DCNL DCSP DCSP derivation = PegDerivation ( elementNode ) DCNL DCSP positives = &#91; &#93; DCNL DCSP radiusArealized = complex ( derivation.radiusArealized , derivation.radiusArealized ) DCNL DCSP addPegOutput ( derivation.bevel , derivation.endZ , positives , radiusArealized , derivation.sides , derivation.start , derivation.topOverBottom ) DCNL DCSP return extrude.getGeometryOutputByNegativesPositives ( elementNode , &#91; &#93; , positives )
DCSP if ( &apos; env &apos; in kwargs ) : DCNL DCSP DCSP salt.utils.warn _ until ( &apos; Oxygen &apos; , &quot; Parameter DCSP &apos; env &apos; DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list . DCSP DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP &apos; saltenv &apos; DCSP as DCSP of DCSP Salt DCSP 2016.11.0 . DCSP DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen . &quot; ) DCNL DCSP DCSP kwargs.pop ( &apos; env &apos; ) DCNL DCSP name = os.path.expanduser ( name ) DCNL DCSP default _ serializer _ opts = { &apos; yaml.serialize &apos; : { &apos; default _ flow _ style &apos; : False } , &apos; json.serialize &apos; : { &apos; indent &apos; : 2 , &apos; separators &apos; : ( &apos; , &apos; , &apos; : DCSP &apos; ) , &apos; sort _ keys &apos; : True } } DCNL DCSP ret = { &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; , &apos; name &apos; : name , &apos; result &apos; : True } DCNL DCSP if ( not name ) : DCNL DCSP DCSP return _ error ( ret , &apos; Must DCSP provide DCSP name DCSP to DCSP file.serialize &apos; ) DCNL DCSP if ( not create ) : DCNL DCSP DCSP if ( not os.path.isfile ( name ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; File DCSP { 0 } DCSP is DCSP not DCSP present DCSP and DCSP is DCSP not DCSP set DCSP for DCSP creation &apos; .format ( name ) DCNL DCSP DCSP DCSP return ret DCNL DCSP formatter = kwargs.pop ( &apos; formatter &apos; , &apos; yaml &apos; ) .lower ( ) DCNL DCSP if ( len ( &#91; x for x in ( dataset , dataset _ pillar ) if x &#93; ) &gt; 1 ) : DCNL DCSP DCSP return _ error ( ret , &quot; Only DCSP one DCSP of DCSP &apos; dataset &apos; DCSP and DCSP &apos; dataset _ pillar &apos; DCSP is DCSP permitted &quot; ) DCNL DCSP if dataset _ pillar : DCNL DCSP DCSP dataset = _ _ salt _ _ &#91; &apos; pillar.get &apos; &#93; ( dataset _ pillar ) DCNL DCSP if ( dataset is None ) : DCNL DCSP DCSP return _ error ( ret , &quot; Neither DCSP &apos; dataset &apos; DCSP nor DCSP &apos; dataset _ pillar &apos; DCSP was DCSP defined &quot; ) DCNL DCSP if salt.utils.is _ windows ( ) : DCNL DCSP DCSP if ( group is not None ) : DCNL DCSP DCSP DCSP log.warning ( &apos; The DCSP group DCSP argument DCSP for DCSP { 0 } DCSP has DCSP been DCSP ignored DCSP as DCSP this DCSP is DCSP a DCSP Windows DCSP system . &apos; .format ( name ) ) DCNL DCSP DCSP group = user DCNL DCSP serializer _ name = &apos; { 0 } .serialize &apos; .format ( formatter ) DCNL DCSP deserializer _ name = &apos; { 0 } .deserialize &apos; .format ( formatter ) DCNL DCSP if ( serializer _ name not in _ _ serializers _ _ ) : DCNL DCSP DCSP return { &apos; changes &apos; : { } , &apos; comment &apos; : &apos; { 0 } DCSP format DCSP is DCSP not DCSP supported &apos; .format ( formatter.capitalize ( ) ) , &apos; name &apos; : name , &apos; result &apos; : False } DCNL DCSP if merge _ if _ exists : DCNL DCSP DCSP if os.path.isfile ( name ) : DCNL DCSP DCSP DCSP if ( &apos; { 0 } .deserialize &apos; .format ( formatter ) not in _ _ serializers _ _ ) : DCNL DCSP DCSP DCSP DCSP return { &apos; changes &apos; : { } , &apos; comment &apos; : &apos; { 0 } DCSP format DCSP is DCSP not DCSP supported DCSP for DCSP merging &apos; .format ( formatter.capitalize ( ) ) , &apos; name &apos; : name , &apos; result &apos; : False } DCNL DCSP DCSP DCSP with salt.utils.fopen ( name , &apos; r &apos; ) as fhr : DCNL DCSP DCSP DCSP DCSP existing _ data = _ _ serializers _ _ &#91; deserializer _ name &#93; ( fhr ) DCNL DCSP DCSP DCSP if ( existing _ data is not None ) : DCNL DCSP DCSP DCSP DCSP merged _ data = salt.utils.dictupdate.merge _ recurse ( existing _ data , dataset ) DCNL DCSP DCSP DCSP DCSP if ( existing _ data = = merged _ data ) : DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; The DCSP file DCSP { 0 } DCSP is DCSP in DCSP the DCSP correct DCSP state &apos; .format ( name ) DCNL DCSP DCSP DCSP DCSP DCSP return ret DCNL DCSP DCSP DCSP DCSP dataset = merged _ data DCNL DCSP contents = _ _ serializers _ _ &#91; serializer _ name &#93; ( dataset , * * default _ serializer _ opts.get ( serializer _ name , { } ) ) DCNL DCSP contents + = &apos; \ n &apos; DCNL DCSP mode = salt.utils.normalize _ mode ( mode ) DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = _ _ salt _ _ &#91; &apos; file.check _ managed _ changes &apos; &#93; ( name = name , source = None , source _ hash = { } , source _ hash _ name = None , user = user , group = group , mode = mode , template = None , context = None , defaults = None , saltenv = _ _ env _ _ , contents = contents , skip _ verify = False , * * kwargs ) DCNL DCSP DCSP if ret &#91; &apos; changes &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Dataset DCSP will DCSP be DCSP serialized DCSP and DCSP stored DCSP into DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; The DCSP file DCSP { 0 } DCSP is DCSP in DCSP the DCSP correct DCSP state &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP return _ _ salt _ _ &#91; &apos; file.manage _ file &apos; &#93; ( name = name , sfn = &apos; &apos; , ret = ret , source = None , source _ sum = { } , user = user , group = group , mode = mode , saltenv = _ _ env _ _ , backup = backup , makedirs = makedirs , template = None , show _ changes = show _ diff , contents = contents )
DCSP pieces = &#91; &#93; DCNL DCSP if ( not isinstance ( by , ( list , tuple ) ) ) : DCNL DCSP DCSP by = &#91; by &#93; DCNL DCSP lby = left.groupby ( by , sort = False ) DCNL DCSP try : DCNL DCSP DCSP if check _ duplicates : DCNL DCSP DCSP DCSP if ( on is None ) : DCNL DCSP DCSP DCSP DCSP on = &#91; &#93; DCNL DCSP DCSP DCSP elif ( not isinstance ( on , ( list , tuple ) ) ) : DCNL DCSP DCSP DCSP DCSP on = &#91; on &#93; DCNL DCSP DCSP DCSP if right.duplicated ( ( by + on ) ) .any ( ) : DCNL DCSP DCSP DCSP DCSP right = right.drop _ duplicates ( ( by + on ) , keep = &apos; last &apos; ) DCNL DCSP DCSP rby = right.groupby ( by , sort = False ) DCNL DCSP except KeyError : DCNL DCSP DCSP rby = None DCNL DCSP for ( key , lhs ) in lby : DCNL DCSP DCSP if ( rby is None ) : DCNL DCSP DCSP DCSP rhs = right DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP rhs = right.take ( rby.indices &#91; key &#93; ) DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP lcols = lhs.columns.tolist ( ) DCNL DCSP DCSP DCSP DCSP cols = ( lcols + &#91; r for r in right.columns if ( r not in set ( lcols ) ) &#93; ) DCNL DCSP DCSP DCSP DCSP merged = lhs.reindex ( columns = cols ) DCNL DCSP DCSP DCSP DCSP merged.index = range ( len ( merged ) ) DCNL DCSP DCSP DCSP DCSP pieces.append ( merged ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP merged = _ merge _ pieces ( lhs , rhs ) DCNL DCSP DCSP for k in by : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( k in merged ) : DCNL DCSP DCSP DCSP DCSP DCSP merged &#91; k &#93; = key DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP pieces.append ( merged ) DCNL DCSP result = concat ( pieces , ignore _ index = True ) DCNL DCSP result = result.reindex ( columns = pieces &#91; 0 &#93; .columns , copy = False ) DCNL DCSP return ( result , lby )
DCSP if matplotlib.is _ interactive ( ) : DCNL DCSP DCSP figManager = Gcf.get _ active ( ) DCNL DCSP DCSP if ( figManager is not None ) : DCNL DCSP DCSP DCSP figManager.canvas.invalidate ( )
DCSP from frappe.translate import get _ full _ dict DCNL DCSP if ( not lang ) : DCNL DCSP DCSP lang = local.lang DCNL DCSP msg = as _ unicode ( msg ) .strip ( ) DCNL DCSP return ( get _ full _ dict ( local.lang ) .get ( msg ) or msg )
DCSP ( object _ type , privileges , _ privs ) = _ mod _ priv _ opts ( object _ type , privileges ) DCNL DCSP _ validate _ privileges ( object _ type , _ privs , privileges ) DCNL DCSP if ( not has _ privileges ( name , object _ name , object _ type , privileges , prepend = prepend , maintenance _ db = maintenance _ db , user = user , host = host , port = port , password = password , runas = runas ) ) : DCNL DCSP DCSP log.info ( &apos; The DCSP object : DCSP % s DCSP of DCSP type : DCSP % s DCSP does DCSP not DCSP have DCSP privileges : DCSP % s DCSP set &apos; , object _ name , object _ type , privileges ) DCNL DCSP DCSP return False DCNL DCSP _ grants = &apos; , &apos; .join ( _ privs ) DCNL DCSP if ( object _ type in &#91; &apos; table &apos; , &apos; sequence &apos; &#93; ) : DCNL DCSP DCSP on _ part = &apos; { 0 } . { 1 } &apos; .format ( prepend , object _ name ) DCNL DCSP else : DCNL DCSP DCSP on _ part = object _ name DCNL DCSP if ( object _ type = = &apos; group &apos; ) : DCNL DCSP DCSP query = &apos; REVOKE DCSP { 0 } DCSP FROM DCSP { 1 } &apos; .format ( object _ name , name ) DCNL DCSP else : DCNL DCSP DCSP query = &apos; REVOKE DCSP { 0 } DCSP ON DCSP { 1 } DCSP { 2 } DCSP FROM DCSP { 3 } &apos; .format ( _ grants , object _ type.upper ( ) , on _ part , name ) DCNL DCSP ret = _ psql _ prepare _ and _ run ( &#91; &apos; -c &apos; , query &#93; , user = user , host = host , port = port , maintenance _ db = maintenance _ db , password = password , runas = runas ) DCNL DCSP return ( ret &#91; &apos; retcode &apos; &#93; = = 0 )
DCSP try : DCNL DCSP DCSP km = dist.km DCNL DCSP except AttributeError : DCNL DCSP DCSP raise SpatialError ( ( u &quot; &apos; % s &apos; DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP &apos; Distance &apos; DCSP object . &quot; % dist ) ) DCNL DCSP return dist
DCSP currpos = fileobj.tell ( ) DCNL DCSP fileobj.seek ( 0 , 2 ) DCNL DCSP total _ size = fileobj.tell ( ) DCNL DCSP fileobj.seek ( currpos ) DCNL DCSP return total _ size
DCSP import getopt DCNL DCSP class BadUsage : DCNL DCSP DCSP pass DCNL DCSP if ( &apos; &apos; not in sys.path ) : DCNL DCSP DCSP scriptdir = os.path.dirname ( sys.argv &#91; 0 &#93; ) DCNL DCSP DCSP if ( scriptdir in sys.path ) : DCNL DCSP DCSP DCSP sys.path.remove ( scriptdir ) DCNL DCSP DCSP sys.path.insert ( 0 , &apos; .&apos; ) DCNL DCSP try : DCNL DCSP DCSP ( opts , args ) = getopt.getopt ( sys.argv &#91; 1 : &#93; , &apos; gk : p : w &apos; ) DCNL DCSP DCSP writing = 0 DCNL DCSP DCSP for ( opt , val ) in opts : DCNL DCSP DCSP DCSP if ( opt = = &apos; -g &apos; ) : DCNL DCSP DCSP DCSP DCSP gui ( ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP if ( opt = = &apos; -k &apos; ) : DCNL DCSP DCSP DCSP DCSP apropos ( val ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP if ( opt = = &apos; -p &apos; ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP port = int ( val ) DCNL DCSP DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP DCSP raise BadUsage DCNL DCSP DCSP DCSP DCSP def ready ( server ) : DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; pydoc DCSP server DCSP ready DCSP at DCSP % s &apos; % server.url ) DCNL DCSP DCSP DCSP DCSP def stopped ( ) : DCNL DCSP DCSP DCSP DCSP DCSP print &apos; pydoc DCSP server DCSP stopped &apos; DCNL DCSP DCSP DCSP DCSP serve ( port , ready , stopped ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP if ( opt = = &apos; -w &apos; ) : DCNL DCSP DCSP DCSP DCSP writing = 1 DCNL DCSP DCSP if ( not args ) : DCNL DCSP DCSP DCSP raise BadUsage DCNL DCSP DCSP for arg in args : DCNL DCSP DCSP DCSP if ( ispath ( arg ) and ( not os.path.exists ( arg ) ) ) : DCNL DCSP DCSP DCSP DCSP print ( &apos; file DCSP % r DCSP does DCSP not DCSP exist &apos; % arg ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( ispath ( arg ) and os.path.isfile ( arg ) ) : DCNL DCSP DCSP DCSP DCSP DCSP arg = importfile ( arg ) DCNL DCSP DCSP DCSP DCSP if writing : DCNL DCSP DCSP DCSP DCSP DCSP if ( ispath ( arg ) and os.path.isdir ( arg ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP writedocs ( arg ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP writedoc ( arg ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP help.help ( arg ) DCNL DCSP DCSP DCSP except ErrorDuringImport as value : DCNL DCSP DCSP DCSP DCSP print value DCNL DCSP except ( getopt.error , BadUsage ) : DCNL DCSP DCSP cmd = os.path.basename ( sys.argv &#91; 0 &#93; ) DCNL DCSP DCSP print ( &quot; pydoc DCSP - DCSP the DCSP Python DCSP documentation DCSP tool \ n \ n % s DCSP &lt; name &gt; DCSP ... \ n DCSP DCSP DCSP DCSP Show DCSP text DCSP documentation DCSP on DCSP something . DCSP DCSP &lt; name &gt; DCSP may DCSP be DCSP the DCSP name DCSP of DCSP a \ n DCSP DCSP DCSP DCSP Python DCSP keyword , DCSP topic , DCSP function , DCSP module , DCSP or DCSP package , DCSP or DCSP a DCSP dotted \ n DCSP DCSP DCSP DCSP reference DCSP to DCSP a DCSP class DCSP or DCSP function DCSP within DCSP a DCSP module DCSP or DCSP module DCSP in DCSP a \ n DCSP DCSP DCSP DCSP package . DCSP DCSP If DCSP &lt; name &gt; DCSP contains DCSP a DCSP &apos; % s &apos; , DCSP it DCSP is DCSP used DCSP as DCSP the DCSP path DCSP to DCSP a \ n DCSP DCSP DCSP DCSP Python DCSP source DCSP file DCSP to DCSP document . DCSP If DCSP name DCSP is DCSP &apos; keywords &apos; , DCSP &apos; topics &apos; , \ n DCSP DCSP DCSP DCSP or DCSP &apos; modules &apos; , DCSP a DCSP listing DCSP of DCSP these DCSP things DCSP is DCSP displayed . \ n \ n % s DCSP -k DCSP &lt; keyword &gt; \ n DCSP DCSP DCSP DCSP Search DCSP for DCSP a DCSP keyword DCSP in DCSP the DCSP synopsis DCSP lines DCSP of DCSP all DCSP available DCSP modules . \ n \ n % s DCSP -p DCSP &lt; port &gt; \ n DCSP DCSP DCSP DCSP Start DCSP an DCSP HTTP DCSP server DCSP on DCSP the DCSP given DCSP port DCSP on DCSP the DCSP local DCSP machine . DCSP DCSP Port \ n DCSP DCSP DCSP DCSP number DCSP 0 DCSP can DCSP be DCSP used DCSP to DCSP get DCSP an DCSP arbitrary DCSP unused DCSP port . \ n \ n % s DCSP -g \ n DCSP DCSP DCSP DCSP Pop DCSP up DCSP a DCSP graphical DCSP interface DCSP for DCSP finding DCSP and DCSP serving DCSP documentation . \ n \ n % s DCSP -w DCSP &lt; name &gt; DCSP ... \ n DCSP DCSP DCSP DCSP Write DCSP out DCSP the DCSP HTML DCSP documentation DCSP for DCSP a DCSP module DCSP to DCSP a DCSP file DCSP in DCSP the DCSP current \ n DCSP DCSP DCSP DCSP directory . DCSP DCSP If DCSP &lt; name &gt; DCSP contains DCSP a DCSP &apos; % s &apos; , DCSP it DCSP is DCSP treated DCSP as DCSP a DCSP filename ; DCSP if \ n DCSP DCSP DCSP DCSP it DCSP names DCSP a DCSP directory , DCSP documentation DCSP is DCSP written DCSP for DCSP all DCSP the DCSP contents . \ n &quot; % ( cmd , os.sep , cmd , cmd , cmd , cmd , os.sep ) )
DCSP for path in os.listdir ( style _ dir ) : DCNL DCSP DCSP filename = os.path.basename ( path ) DCNL DCSP DCSP if is _ style _ file ( filename ) : DCNL DCSP DCSP DCSP match = STYLE _ FILE _ PATTERN.match ( filename ) DCNL DCSP DCSP DCSP path = os.path.abspath ( os.path.join ( style _ dir , path ) ) DCNL DCSP DCSP DCSP ( yield ( path , match.groups ( ) &#91; 0 &#93; ) )
DCSP if ( context is None ) : DCNL DCSP DCSP context = EvalJs ( ) DCNL DCSP if ( not isinstance ( context , EvalJs ) ) : DCNL DCSP DCSP raise TypeError ( &apos; context DCSP must DCSP be DCSP the DCSP instance DCSP of DCSP EvalJs &apos; ) DCNL DCSP eval _ value = context.eval ( get _ file _ contents ( path _ or _ file ) ) DCNL DCSP return ( eval _ value , context )
DCSP try : DCNL DCSP DCSP if cond : DCNL DCSP DCSP DCSP a = &#91; &#93; DCNL DCSP DCSP raise ValueError DCNL DCSP except ValueError : DCNL DCSP DCSP return a
DCSP return ( is _ trunk _ bridge ( port _ name ) or ( port _ name &#91; : 2 &#93; in ( tman.TrunkParentPort.DEV _ PREFIX , tman.SubPort.DEV _ PREFIX ) ) )
DCSP def newFunc ( * args , * * kwargs ) : DCNL DCSP DCSP warnings.warn ( ( &apos; Call DCSP to DCSP deprecated DCSP function DCSP % s . &apos; % name ) , category = DeprecationWarning ) DCNL DCSP DCSP return func ( * args , * * kwargs ) DCNL DCSP newFunc . _ _ name _ _ = func . _ _ name _ _ DCNL DCSP newFunc . _ _ doc _ _ = func . _ _ doc _ _ DCNL DCSP newFunc . _ _ dict _ _ .update ( func . _ _ dict _ _ ) DCNL DCSP return newFunc
DCSP return call _ talib _ with _ ohlc ( barDs , count , talib.CDLADVANCEBLOCK )
DCSP if ( radon _ image.ndim ! = 2 ) : DCNL DCSP DCSP raise ValueError ( &apos; The DCSP input DCSP image DCSP must DCSP be DCSP 2-D &apos; ) DCNL DCSP if ( theta is None ) : DCNL DCSP DCSP ( m , n ) = radon _ image.shape DCNL DCSP DCSP theta = np.linspace ( 0 , 180 , n , endpoint = False ) DCNL DCSP else : DCNL DCSP DCSP theta = np.asarray ( theta ) DCNL DCSP if ( len ( theta ) ! = radon _ image.shape &#91; 1 &#93; ) : DCNL DCSP DCSP raise ValueError ( &apos; The DCSP given DCSP ``theta`` DCSP does DCSP not DCSP match DCSP the DCSP number DCSP of DCSP projections DCSP in DCSP ``radon _ image`` . &apos; ) DCNL DCSP interpolation _ types = ( &apos; linear &apos; , &apos; nearest &apos; , &apos; cubic &apos; ) DCNL DCSP if ( interpolation not in interpolation _ types ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP interpolation : DCSP % s &apos; % interpolation ) ) DCNL DCSP if ( not output _ size ) : DCNL DCSP DCSP if circle : DCNL DCSP DCSP DCSP output _ size = radon _ image.shape &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP output _ size = int ( np.floor ( np.sqrt ( ( ( radon _ image.shape &#91; 0 &#93; * * 2 ) / 2.0 ) ) ) ) DCNL DCSP if ( circle is None ) : DCNL DCSP DCSP warn ( &apos; The DCSP default DCSP of DCSP `circle` DCSP in DCSP `skimage.transform.iradon` DCSP will DCSP change DCSP to DCSP `True` DCSP in DCSP version DCSP 0.15 . &apos; ) DCNL DCSP DCSP circle = False DCNL DCSP if circle : DCNL DCSP DCSP radon _ image = _ sinogram _ circle _ to _ square ( radon _ image ) DCNL DCSP th = ( ( np.pi / 180.0 ) * theta ) DCNL DCSP projection _ size _ padded = max ( 64 , int ( ( 2 * * np.ceil ( np.log2 ( ( 2 * radon _ image.shape &#91; 0 &#93; ) ) ) ) ) ) DCNL DCSP pad _ width = ( ( 0 , ( projection _ size _ padded - radon _ image.shape &#91; 0 &#93; ) ) , ( 0 , 0 ) ) DCNL DCSP img = np.pad ( radon _ image , pad _ width , mode = &apos; constant &apos; , constant _ values = 0 ) DCNL DCSP f = fftfreq ( projection _ size _ padded ) .reshape ( ( -1 ) , 1 ) DCNL DCSP omega = ( ( 2 * np.pi ) * f ) DCNL DCSP fourier _ filter = ( 2 * np.abs ( f ) ) DCNL DCSP if ( filter = = &apos; ramp &apos; ) : DCNL DCSP DCSP pass DCNL DCSP elif ( filter = = &apos; shepp-logan &apos; ) : DCNL DCSP DCSP fourier _ filter &#91; 1 : &#93; = ( ( fourier _ filter &#91; 1 : &#93; * np.sin ( omega &#91; 1 : &#93; ) ) / omega &#91; 1 : &#93; ) DCNL DCSP elif ( filter = = &apos; cosine &apos; ) : DCNL DCSP DCSP fourier _ filter * = np.cos ( omega ) DCNL DCSP elif ( filter = = &apos; hamming &apos; ) : DCNL DCSP DCSP fourier _ filter * = ( 0.54 + ( 0.46 * np.cos ( ( omega / 2 ) ) ) ) DCNL DCSP elif ( filter = = &apos; hann &apos; ) : DCNL DCSP DCSP fourier _ filter * = ( ( 1 + np.cos ( ( omega / 2 ) ) ) / 2 ) DCNL DCSP elif ( filter is None ) : DCNL DCSP DCSP fourier _ filter &#91; : &#93; = 1 DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP filter : DCSP % s &apos; % filter ) ) DCNL DCSP projection = ( fft ( img , axis = 0 ) * fourier _ filter ) DCNL DCSP radon _ filtered = np.real ( ifft ( projection , axis = 0 ) ) DCNL DCSP radon _ filtered = radon _ filtered &#91; : radon _ image.shape &#91; 0 &#93; , : &#93; DCNL DCSP reconstructed = np.zeros ( ( output _ size , output _ size ) ) DCNL DCSP mid _ index = ( radon _ image.shape &#91; 0 &#93; / / 2 ) DCNL DCSP &#91; X , Y &#93; = np.mgrid &#91; 0 : output _ size , 0 : output _ size &#93; DCNL DCSP xpr = ( X - ( int ( output _ size ) / / 2 ) ) DCNL DCSP ypr = ( Y - ( int ( output _ size ) / / 2 ) ) DCNL DCSP for i in range ( len ( theta ) ) : DCNL DCSP DCSP t = ( ( ypr * np.cos ( th &#91; i &#93; ) ) - ( xpr * np.sin ( th &#91; i &#93; ) ) ) DCNL DCSP DCSP x = ( np.arange ( radon _ filtered.shape &#91; 0 &#93; ) - mid _ index ) DCNL DCSP DCSP if ( interpolation = = &apos; linear &apos; ) : DCNL DCSP DCSP DCSP backprojected = np.interp ( t , x , radon _ filtered &#91; : , i &#93; , left = 0 , right = 0 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP interpolant = interp1d ( x , radon _ filtered &#91; : , i &#93; , kind = interpolation , bounds _ error = False , fill _ value = 0 ) DCNL DCSP DCSP DCSP backprojected = interpolant ( t ) DCNL DCSP DCSP reconstructed + = backprojected DCNL DCSP if circle : DCNL DCSP DCSP radius = ( output _ size / / 2 ) DCNL DCSP DCSP reconstruction _ circle = ( ( ( xpr * * 2 ) + ( ypr * * 2 ) ) &lt; = ( radius * * 2 ) ) DCNL DCSP DCSP reconstructed &#91; ( ~ reconstruction _ circle ) &#93; = 0.0 DCNL DCSP return ( ( reconstructed * np.pi ) / ( 2 * len ( th ) ) )
DCSP return spatio _ temporal _ dist _ connectivity ( src , 1 , dist )
DCSP options = ( { } , None , { &apos; event _ data &apos; : { } } , { &apos; event &apos; : &apos; state _ changed &apos; , &apos; event _ data &apos; : 1 } ) DCNL DCSP for value in options : DCNL DCSP DCSP with pytest.raises ( vol.MultipleInvalid ) : DCNL DCSP DCSP DCSP cv.EVENT _ SCHEMA ( value ) DCNL DCSP options = ( { &apos; event &apos; : &apos; state _ changed &apos; } , { &apos; event &apos; : &apos; state _ changed &apos; , &apos; event _ data &apos; : { &apos; hello &apos; : &apos; world &apos; } } ) DCNL DCSP for value in options : DCNL DCSP DCSP cv.EVENT _ SCHEMA ( value )
DCSP if has _ module ( u &apos;DNS &apos; ) : DCNL DCSP DCSP return ( True , None ) DCNL DCSP else : DCNL DCSP DCSP return ( False , _ ( u &apos;PyDNS , DCSP which DCSP is DCSP required DCSP to DCSP find DCSP the DCSP domain DCSP controller , DCSP is DCSP not DCSP installed . &apos; ) )
DCSP return _ compile ( pattern , flags , kwargs ) .findall ( string , pos , endpos , overlapped , concurrent )
DCSP endtime = salt.utils.jid.jid _ to _ time ( salt.utils.jid.gen _ jid ( ) ) DCNL DCSP if any ( ( ( key not in load ) for key in ( &apos; return &apos; , &apos; jid &apos; , &apos; id &apos; ) ) ) : DCNL DCSP DCSP return False DCNL DCSP if ( not salt.utils.verify.valid _ id ( opts , load &#91; &apos; id &apos; &#93; ) ) : DCNL DCSP DCSP return False DCNL DCSP if ( mminion is None ) : DCNL DCSP DCSP mminion = salt.minion.MasterMinion ( opts , states = False , rend = False ) DCNL DCSP job _ cache = opts &#91; &apos; master _ job _ cache &apos; &#93; DCNL DCSP if ( load &#91; &apos; jid &apos; &#93; = = &apos; req &apos; ) : DCNL DCSP DCSP load &#91; &apos; arg &apos; &#93; = load.get ( &apos; arg &apos; , load.get ( &apos; fun _ args &apos; , &#91; &#93; ) ) DCNL DCSP DCSP load &#91; &apos; tgt _ type &apos; &#93; = &apos; glob &apos; DCNL DCSP DCSP load &#91; &apos; tgt &apos; &#93; = load &#91; &apos; id &apos; &#93; DCNL DCSP DCSP prep _ fstr = &apos; { 0 } .prep _ jid &apos; .format ( opts &#91; &apos; master _ job _ cache &apos; &#93; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP load &#91; &apos; jid &apos; &#93; = mminion.returners &#91; prep _ fstr &#93; ( nocache = load.get ( &apos; nocache &apos; , False ) ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP emsg = &quot; Returner DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP support DCSP function DCSP prep _ jid &quot; .format ( job _ cache ) DCNL DCSP DCSP DCSP log.error ( emsg ) DCNL DCSP DCSP DCSP raise KeyError ( emsg ) DCNL DCSP DCSP saveload _ fstr = &apos; { 0 } .save _ load &apos; .format ( job _ cache ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP mminion.returners &#91; saveload _ fstr &#93; ( load &#91; &apos; jid &apos; &#93; , load ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP emsg = &quot; Returner DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP support DCSP function DCSP save _ load &quot; .format ( job _ cache ) DCNL DCSP DCSP DCSP log.error ( emsg ) DCNL DCSP DCSP DCSP raise KeyError ( emsg ) DCNL DCSP elif salt.utils.jid.is _ jid ( load &#91; &apos; jid &apos; &#93; ) : DCNL DCSP DCSP jidstore _ fstr = &apos; { 0 } .prep _ jid &apos; .format ( job _ cache ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP mminion.returners &#91; jidstore _ fstr &#93; ( False , passed _ jid = load &#91; &apos; jid &apos; &#93; ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP emsg = &quot; Returner DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP support DCSP function DCSP prep _ jid &quot; .format ( job _ cache ) DCNL DCSP DCSP DCSP log.error ( emsg ) DCNL DCSP DCSP DCSP raise KeyError ( emsg ) DCNL DCSP if event : DCNL DCSP DCSP log.info ( &apos; Got DCSP return DCSP from DCSP { id } DCSP for DCSP job DCSP { jid } &apos; .format ( * * load ) ) DCNL DCSP DCSP event.fire _ event ( load , salt.utils.event.tagify ( &#91; load &#91; &apos; jid &apos; &#93; , &apos; ret &apos; , load &#91; &apos; id &apos; &#93; &#93; , &apos; job &apos; ) ) DCNL DCSP DCSP event.fire _ ret _ load ( load ) DCNL DCSP if ( ( not opts &#91; &apos; job _ cache &apos; &#93; ) or opts.get ( &apos; ext _ job _ cache &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP if ( load.get ( &apos; jid &apos; ) = = &apos; nocache &apos; ) : DCNL DCSP DCSP log.debug ( &apos; Ignoring DCSP job DCSP return DCSP with DCSP jid DCSP for DCSP caching DCSP { jid } DCSP from DCSP { id } &apos; .format ( * * load ) ) DCNL DCSP DCSP return DCNL DCSP savefstr = &apos; { 0 } .save _ load &apos; .format ( job _ cache ) DCNL DCSP getfstr = &apos; { 0 } .get _ load &apos; .format ( job _ cache ) DCNL DCSP fstr = &apos; { 0 } .returner &apos; .format ( job _ cache ) DCNL DCSP if ( ( &apos; fun &apos; not in load ) and load.get ( &apos; return &apos; , { } ) ) : DCNL DCSP DCSP ret _ = load.get ( &apos; return &apos; , { } ) DCNL DCSP DCSP if ( &apos; fun &apos; in ret _ ) : DCNL DCSP DCSP DCSP load.update ( { &apos; fun &apos; : ret _ &#91; &apos; fun &apos; &#93; } ) DCNL DCSP DCSP if ( &apos; user &apos; in ret _ ) : DCNL DCSP DCSP DCSP load.update ( { &apos; user &apos; : ret _ &#91; &apos; user &apos; &#93; } ) DCNL DCSP try : DCNL DCSP DCSP if ( ( &apos; jid &apos; in load ) and ( &apos; get _ load &apos; in mminion.returners ) and ( not mminion.returners &#91; getfstr &#93; ( load.get ( &apos; jid &apos; , &apos; &apos; ) ) ) ) : DCNL DCSP DCSP DCSP mminion.returners &#91; savefstr &#93; ( load &#91; &apos; jid &apos; &#93; , load ) DCNL DCSP DCSP mminion.returners &#91; fstr &#93; ( load ) DCNL DCSP DCSP updateetfstr = &apos; { 0 } .update _ endtime &apos; .format ( job _ cache ) DCNL DCSP DCSP if ( opts.get ( &apos; job _ cache _ store _ endtime &apos; ) and ( updateetfstr in mminion.returners ) ) : DCNL DCSP DCSP DCSP mminion.returners &#91; updateetfstr &#93; ( load &#91; &apos; jid &apos; &#93; , endtime ) DCNL DCSP except KeyError : DCNL DCSP DCSP emsg = &quot; Returner DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP support DCSP function DCSP returner &quot; .format ( job _ cache ) DCNL DCSP DCSP log.error ( emsg ) DCNL DCSP DCSP raise KeyError ( emsg )
DCSP ( ( key , value ) , ) = input _ dict.items ( ) DCNL DCSP must _ return = False DCNL DCSP if ( output is None ) : DCNL DCSP DCSP output = StringIO ( ) DCNL DCSP DCSP must _ return = True DCNL DCSP content _ handler = XMLGenerator ( output , encoding ) DCNL DCSP if full _ document : DCNL DCSP DCSP content _ handler.startDocument ( ) DCNL DCSP _ emit ( key , value , content _ handler , * * kwargs ) DCNL DCSP if full _ document : DCNL DCSP DCSP content _ handler.endDocument ( ) DCNL DCSP if must _ return : DCNL DCSP DCSP value = output.getvalue ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP value = value.decode ( encoding ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP return value
DCSP if reconnect : DCNL DCSP DCSP disconnect ( alias ) DCNL DCSP if ( alias in _ connections ) : DCNL DCSP DCSP return _ connections &#91; alias &#93; DCNL DCSP if ( alias not in _ connection _ settings ) : DCNL DCSP DCSP if ( alias = = DEFAULT _ CONNECTION _ NAME ) : DCNL DCSP DCSP DCSP msg = &apos; You DCSP have DCSP not DCSP defined DCSP a DCSP default DCSP connection &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP msg = ( &apos; Connection DCSP with DCSP alias DCSP &quot; % s &quot; DCSP has DCSP not DCSP been DCSP defined &apos; % alias ) DCNL DCSP DCSP raise MongoEngineConnectionError ( msg ) DCNL DCSP def _ clean _ settings ( settings _ dict ) : DCNL DCSP DCSP irrelevant _ fields = set ( &#91; &apos; name &apos; , &apos; username &apos; , &apos; password &apos; , &apos; authentication _ source &apos; , &apos; authentication _ mechanism &apos; &#93; ) DCNL DCSP DCSP return { k : v for ( k , v ) in settings _ dict.items ( ) if ( k not in irrelevant _ fields ) } DCNL DCSP conn _ settings = _ clean _ settings ( _ connection _ settings &#91; alias &#93; .copy ( ) ) DCNL DCSP is _ mock = conn _ settings.pop ( &apos; is _ mock &apos; , False ) DCNL DCSP if is _ mock : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP import mongomock DCNL DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP raise RuntimeError ( &apos; You DCSP need DCSP mongomock DCSP installed DCSP to DCSP mock DCSP MongoEngine . &apos; ) DCNL DCSP DCSP connection _ class = mongomock.MongoClient DCNL DCSP else : DCNL DCSP DCSP connection _ class = MongoClient DCNL DCSP DCSP if ( ( &apos; replicaSet &apos; in conn _ settings ) and ( not IS _ PYMONGO _ 3 ) ) : DCNL DCSP DCSP DCSP connection _ class = MongoReplicaSetClient DCNL DCSP DCSP DCSP conn _ settings &#91; &apos; hosts _ or _ uri &apos; &#93; = conn _ settings.pop ( &apos; host &apos; , None ) DCNL DCSP DCSP DCSP if isinstance ( conn _ settings &#91; &apos; hosts _ or _ uri &apos; &#93; , list ) : DCNL DCSP DCSP DCSP DCSP conn _ settings &#91; &apos; hosts _ or _ uri &apos; &#93; = &apos; , &apos; .join ( conn _ settings &#91; &apos; hosts _ or _ uri &apos; &#93; ) DCNL DCSP DCSP DCSP conn _ settings.pop ( &apos; port &apos; , None ) DCNL DCSP existing _ connection = None DCNL DCSP connection _ settings _ iterator = ( ( db _ alias , settings.copy ( ) ) for ( db _ alias , settings ) in _ connection _ settings.items ( ) ) DCNL DCSP for ( db _ alias , connection _ settings ) in connection _ settings _ iterator : DCNL DCSP DCSP connection _ settings = _ clean _ settings ( connection _ settings ) DCNL DCSP DCSP if ( ( conn _ settings = = connection _ settings ) and _ connections.get ( db _ alias ) ) : DCNL DCSP DCSP DCSP existing _ connection = _ connections &#91; db _ alias &#93; DCNL DCSP DCSP DCSP break DCNL DCSP if existing _ connection : DCNL DCSP DCSP _ connections &#91; alias &#93; = existing _ connection DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ connections &#91; alias &#93; = connection _ class ( * * conn _ settings ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP raise MongoEngineConnectionError ( ( &apos; Cannot DCSP connect DCSP to DCSP database DCSP % s DCSP : \ n % s &apos; % ( alias , e ) ) ) DCNL DCSP return _ connections &#91; alias &#93;
DCSP if isinstance ( index , ( int , long ) ) : DCNL DCSP DCSP i = 0 DCNL DCSP DCSP ind = index DCNL DCSP DCSP lens = list ( lengths ) DCNL DCSP DCSP while ( ind &gt; = lens &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP i + = 1 DCNL DCSP DCSP DCSP ind - = lens.pop ( 0 ) DCNL DCSP DCSP return { i : ind } DCNL DCSP assert isinstance ( index , slice ) DCNL DCSP if ( index = = colon ) : DCNL DCSP DCSP return { k : colon for k in range ( len ( lengths ) ) } DCNL DCSP step = ( index.step or 1 ) DCNL DCSP if ( step &gt; 0 ) : DCNL DCSP DCSP start = ( index.start or 0 ) DCNL DCSP DCSP stop = ( index.stop if ( index.stop is not None ) else dim _ shape ) DCNL DCSP else : DCNL DCSP DCSP start = ( index.start or ( dim _ shape - 1 ) ) DCNL DCSP DCSP start = ( ( dim _ shape - 1 ) if ( start &gt; = dim _ shape ) else start ) DCNL DCSP DCSP stop = ( ( - ( dim _ shape + 1 ) ) if ( index.stop is None ) else index.stop ) DCNL DCSP if ( start &lt; 0 ) : DCNL DCSP DCSP start + = dim _ shape DCNL DCSP if ( stop &lt; 0 ) : DCNL DCSP DCSP stop + = dim _ shape DCNL DCSP d = dict ( ) DCNL DCSP if ( step &gt; 0 ) : DCNL DCSP DCSP for ( i , length ) in enumerate ( lengths ) : DCNL DCSP DCSP DCSP if ( ( start &lt; length ) and ( stop &gt; 0 ) ) : DCNL DCSP DCSP DCSP DCSP d &#91; i &#93; = slice ( start , min ( stop , length ) , step ) DCNL DCSP DCSP DCSP DCSP start = ( ( start - length ) % step ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP start = ( start - length ) DCNL DCSP DCSP DCSP stop - = length DCNL DCSP else : DCNL DCSP DCSP rstart = start DCNL DCSP DCSP chunk _ boundaries = list ( accumulate ( add , lengths ) ) DCNL DCSP DCSP for ( i , chunk _ stop ) in reversed ( list ( enumerate ( chunk _ boundaries ) ) ) : DCNL DCSP DCSP DCSP if ( i = = 0 ) : DCNL DCSP DCSP DCSP DCSP chunk _ start = 0 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP chunk _ start = chunk _ boundaries &#91; ( i - 1 ) &#93; DCNL DCSP DCSP DCSP if ( ( chunk _ start &lt; = rstart &lt; chunk _ stop ) and ( rstart &gt; stop ) ) : DCNL DCSP DCSP DCSP DCSP d &#91; i &#93; = slice ( ( rstart - chunk _ stop ) , max ( ( ( chunk _ start - chunk _ stop ) - 1 ) , ( stop - chunk _ stop ) ) , step ) DCNL DCSP DCSP DCSP DCSP offset = ( ( rstart - ( chunk _ start - 1 ) ) % step ) DCNL DCSP DCSP DCSP DCSP rstart = ( ( chunk _ start + offset ) - 1 ) DCNL DCSP for ( k , v ) in d.items ( ) : DCNL DCSP DCSP if ( v = = slice ( 0 , lengths &#91; k &#93; , 1 ) ) : DCNL DCSP DCSP DCSP d &#91; k &#93; = slice ( None , None , None ) DCNL DCSP if ( not d ) : DCNL DCSP DCSP d &#91; 0 &#93; = slice ( 0 , 0 , 1 ) DCNL DCSP return d
DCSP ignore = ( ignore or &#91; &#93; ) DCNL DCSP def prefix _ match ( path , prefix ) : DCNL DCSP DCSP if ( path = = prefix ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP prefix = ( prefix.rstrip ( os.path.sep ) + os.path.sep ) DCNL DCSP DCSP return path.startswith ( prefix ) DCNL DCSP start _ keys = set ( &#91; k for k in start.keys ( ) if ( not any ( &#91; prefix _ match ( k , i ) for i in ignore &#93; ) ) &#93; ) DCNL DCSP end _ keys = set ( &#91; k for k in end.keys ( ) if ( not any ( &#91; prefix _ match ( k , i ) for i in ignore &#93; ) ) &#93; ) DCNL DCSP deleted = dict ( &#91; ( k , start &#91; k &#93; ) for k in start _ keys.difference ( end _ keys ) &#93; ) DCNL DCSP created = dict ( &#91; ( k , end &#91; k &#93; ) for k in end _ keys.difference ( start _ keys ) &#93; ) DCNL DCSP updated = { } DCNL DCSP for k in start _ keys.intersection ( end _ keys ) : DCNL DCSP DCSP if ( start &#91; k &#93; .size ! = end &#91; k &#93; .size ) : DCNL DCSP DCSP DCSP updated &#91; k &#93; = end &#91; k &#93; DCNL DCSP return dict ( deleted = deleted , created = created , updated = updated )
DCSP if ( ( not check.name ) and ( not service _ id ) ) : DCNL DCSP DCSP module.fail _ json ( msg = &apos; a DCSP check DCSP name DCSP is DCSP required DCSP for DCSP a DCSP node DCSP level DCSP check , DCSP one DCSP not DCSP attached DCSP to DCSP a DCSP service &apos; ) DCNL DCSP consul _ api = get _ consul _ api ( module ) DCNL DCSP check.register ( consul _ api ) DCNL DCSP module.exit _ json ( changed = True , check _ id = check.check _ id , check _ name = check.name , script = check.script , interval = check.interval , ttl = check.ttl , http = check.http , timeout = check.timeout , service _ id = check.service _ id )
DCSP rval = &#91; &#93; DCNL DCSP async _ datasets = &#91; &#93; DCNL DCSP if ( params.get ( &apos; async _ datasets &apos; , None ) not in &#91; &apos; None &apos; , &apos; &apos; , None &#93; ) : DCNL DCSP DCSP async _ datasets = params &#91; &apos; async _ datasets &apos; &#93; .split ( &apos; , &apos; ) DCNL DCSP current _ user _ roles = trans.get _ current _ user _ roles ( ) DCNL DCSP for id in async _ datasets : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = trans.sa _ session.query ( data _ obj ) .get ( int ( id ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP log.exception ( ( &apos; Unable DCSP to DCSP load DCSP precreated DCSP dataset DCSP ( % s ) DCSP sent DCSP in DCSP upload DCSP form &apos; % id ) ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( data _ obj is trans.app.model.HistoryDatasetAssociation ) : DCNL DCSP DCSP DCSP if ( ( trans.user is None ) and ( trans.galaxy _ session.current _ history ! = data.history ) ) : DCNL DCSP DCSP DCSP DCSP log.error ( ( &quot; Got DCSP a DCSP precreated DCSP dataset DCSP ( % s ) DCSP but DCSP it DCSP does DCSP not DCSP belong DCSP to DCSP anonymous DCSP user &apos;s DCSP current DCSP session DCSP ( % s ) &quot; % ( data.id , trans.galaxy _ session.id ) ) ) DCNL DCSP DCSP DCSP elif ( data.history.user ! = trans.user ) : DCNL DCSP DCSP DCSP DCSP log.error ( ( &apos; Got DCSP a DCSP precreated DCSP dataset DCSP ( % s ) DCSP but DCSP it DCSP does DCSP not DCSP belong DCSP to DCSP current DCSP user DCSP ( % s ) &apos; % ( data.id , trans.user.id ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP rval.append ( data ) DCNL DCSP DCSP elif ( data _ obj is trans.app.model.LibraryDatasetDatasetAssociation ) : DCNL DCSP DCSP DCSP if ( ( controller = = &apos; library &apos; ) and ( not trans.app.security _ agent.can _ add _ library _ item ( current _ user _ roles , data.library _ dataset.folder ) ) ) : DCNL DCSP DCSP DCSP DCSP log.error ( ( &apos; Got DCSP a DCSP precreated DCSP dataset DCSP ( % s ) DCSP but DCSP this DCSP user DCSP ( % s ) DCSP is DCSP not DCSP allowed DCSP to DCSP write DCSP to DCSP it &apos; % ( data.id , trans.user.id ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP rval.append ( data ) DCNL DCSP return rval
DCSP if isinstance ( value , web.HTTPError ) : DCNL DCSP DCSP return ( value.status _ code , value.log _ message ) DCNL DCSP elif isinstance ( value , InvalidRequestError ) : DCNL DCSP DCSP return ( 400 , value.args &#91; 0 &#93; ) DCNL DCSP elif isinstance ( value , HttpForbiddenError ) : DCNL DCSP DCSP return ( 403 , value.args &#91; 0 &#93; ) DCNL DCSP elif isinstance ( value , NotFoundError ) : DCNL DCSP DCSP return ( 404 , value.args &#91; 0 &#93; ) DCNL DCSP elif isinstance ( value , ServiceUnavailableError ) : DCNL DCSP DCSP return ( 503 , value.args &#91; 0 &#93; ) DCNL DCSP else : DCNL DCSP DCSP return ( 500 , str ( value ) )
DCSP new = set ( ) DCNL DCSP for d in definitions : DCNL DCSP DCSP imp _ or _ stmt = d.get _ definition ( ) DCNL DCSP DCSP if isinstance ( imp _ or _ stmt , tree.Import ) : DCNL DCSP DCSP DCSP s = imports.ImportWrapper ( evaluator , d ) DCNL DCSP DCSP DCSP new &#124; = set ( s.follow ( is _ goto = True ) ) DCNL DCSP return ( set ( definitions ) &#124; new )
DCSP with io.open ( codefile , u &apos;w &apos; ) as code _ filehandle : DCNL DCSP DCSP code _ filehandle.write ( ( u &apos; # include &lt; stdio.h &gt; DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; stdlib.h &gt; DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; tuple &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; utility &gt; DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; limits &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; functional &gt; DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; string &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; map &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; iostream &gt; DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; vector &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; algorithm &gt; DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ n # include &lt; memory &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP / / DCSP by DCSP md-split \ nusing DCSP namespace DCSP std ; DCSP DCSP DCSP / / DCSP by DCSP md-split \ n / / DCSP % s DCSP : DCSP % s \ n &apos; % ( sourcefile , start _ linenum ) ) ) DCNL DCSP DCSP for codeline in linebuffer : DCNL DCSP DCSP DCSP code _ filehandle.write ( codeline )
DCSP tokens = lex ( s , name = name ) DCNL DCSP result = &#91; &#93; DCNL DCSP while tokens : DCNL DCSP DCSP ( next , tokens ) = parse _ expr ( tokens , name ) DCNL DCSP DCSP result.append ( next ) DCNL DCSP return result
DCSP try : DCNL DCSP DCSP return plist &#91; &apos; Label &apos; &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP return &apos; False&apos;
DCSP sign = ( 1 if greater _ is _ better else ( -1 ) ) DCNL DCSP if ( needs _ proba and needs _ threshold ) : DCNL DCSP DCSP raise ValueError ( &apos; Set DCSP either DCSP needs _ proba DCSP or DCSP needs _ threshold DCSP to DCSP True , DCSP but DCSP not DCSP both . &apos; ) DCNL DCSP if needs _ proba : DCNL DCSP DCSP cls = _ ProbaScorer DCNL DCSP elif needs _ threshold : DCNL DCSP DCSP cls = _ ThresholdScorer DCNL DCSP else : DCNL DCSP DCSP cls = _ PredictScorer DCNL DCSP return cls ( score _ func , sign , kwargs )
DCSP retty = seqty.dtype DCNL DCSP getitem _ impl = context.get _ function ( &apos; getitem &apos; , signature ( retty , seqty , types.intp ) ) DCNL DCSP def wrap ( builder , args ) : DCNL DCSP DCSP ret = getitem _ impl ( builder , args ) DCNL DCSP DCSP if context.enable _ nrt : DCNL DCSP DCSP DCSP context.nrt.decref ( builder , retty , ret ) DCNL DCSP DCSP return ret DCNL DCSP return wrap
DCSP return &#91; EntityAnnotation.from _ pb ( annotation ) for annotation in annotations &#93;
DCSP return Response ( &apos; route &apos; )
DCSP out = &#91; &#93; DCNL DCSP if ( not str ) : DCNL DCSP DCSP return out DCNL DCSP current = &apos; &apos; DCNL DCSP openQuotes = &apos; &quot; \ &apos; &lt; ( { &apos; DCNL DCSP closeQuotes = &apos; &quot; \ &apos; &gt; ) } &apos; DCNL DCSP matchingQuote = &apos; &apos; DCNL DCSP insideQuotes = False DCNL DCSP nextIsLiteral = False DCNL DCSP for char in str : DCNL DCSP DCSP if nextIsLiteral : DCNL DCSP DCSP DCSP current + = char DCNL DCSP DCSP DCSP nextIsLiteral = False DCNL DCSP DCSP elif insideQuotes : DCNL DCSP DCSP DCSP if ( char = = &apos; \ \ &apos; ) : DCNL DCSP DCSP DCSP DCSP nextIsLiteral = True DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP current + = char DCNL DCSP DCSP DCSP DCSP if ( char = = matchingQuote ) : DCNL DCSP DCSP DCSP DCSP DCSP insideQuotes = False DCNL DCSP DCSP elif ( char = = &apos; , &apos; ) : DCNL DCSP DCSP DCSP out.append ( current.strip ( ) ) DCNL DCSP DCSP DCSP current = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP current + = char DCNL DCSP DCSP DCSP quoteIndex = openQuotes.find ( char ) DCNL DCSP DCSP DCSP if ( quoteIndex &gt; ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP matchingQuote = closeQuotes &#91; quoteIndex &#93; DCNL DCSP DCSP DCSP DCSP insideQuotes = True DCNL DCSP out.append ( current.strip ( ) ) DCNL DCSP return out
DCSP styles = dict ( ) DCNL DCSP for ( path , name ) in iter _ style _ files ( style _ dir ) : DCNL DCSP DCSP with warnings.catch _ warnings ( record = True ) as warns : DCNL DCSP DCSP DCSP styles &#91; name &#93; = rc _ params _ from _ file ( path , use _ default _ template = False ) DCNL DCSP DCSP for w in warns : DCNL DCSP DCSP DCSP message = ( u &apos;In DCSP % s : DCSP % s &apos; % ( path , w.message ) ) DCNL DCSP DCSP DCSP warnings.warn ( message ) DCNL DCSP return styles
DCSP numberOfBezierPoints = int ( math.ceil ( ( 0.5 * evaluate.getSidesMinimumThreeBasedOnPrecision ( abs ( ( end - begin ) ) , xmlElement ) ) ) ) DCNL DCSP return evaluate.getEvaluatedIntDefault ( numberOfBezierPoints , &apos; sides &apos; , xmlElement )
DCSP template = env.get _ template ( &apos; index.html &apos; ) DCNL DCSP return template.render ( providers = ASSEMBLED _ CONFIG , oauth2 _ providers = OAUTH2 _ PROVIDERS , oauth1 _ providers = OAUTH1 _ PROVIDERS , openid _ providers = OPENID _ PROVIDERS , framework _ name = framework _ name )
DCSP str = re.sub ( &apos; --- &apos; , &apos; &amp; # 8211 ; &apos; , str ) DCNL DCSP str = re.sub ( &apos; -- &apos; , &apos; &amp; # 8212 ; &apos; , str ) DCNL DCSP return str
DCSP if ( args.iv is not None ) : DCNL DCSP DCSP print &apos; WARNING : DCSP --iv DCSP argument DCSP is DCSP for DCSP TESTING DCSP PURPOSES DCSP ONLY &apos; DCNL DCSP DCSP iv = args.iv.read ( 128 ) DCNL DCSP else : DCNL DCSP DCSP iv = os.urandom ( 128 ) DCNL DCSP plaintext _ image = args.image.read ( ) DCNL DCSP if ( ( len ( plaintext _ image ) % 128 ) ! = 0 ) : DCNL DCSP DCSP plaintext _ image + = ( &apos; \ xff &apos; * ( 128 - ( len ( plaintext _ image ) % 128 ) ) ) DCNL DCSP plaintext = ( iv + plaintext _ image ) DCNL DCSP key = args.keyfile.read ( ) DCNL DCSP if ( len ( key ) ! = 32 ) : DCNL DCSP DCSP raise esptool.FatalError ( ( &apos; Key DCSP file DCSP contains DCSP wrong DCSP length DCSP ( % d DCSP bytes ) , DCSP 32 DCSP expected . &apos; % len ( key ) ) ) DCNL DCSP aes = pyaes.AESModeOfOperationECB ( key ) DCNL DCSP digest = hashlib.sha512 ( ) DCNL DCSP for block in get _ chunks ( plaintext , 16 ) : DCNL DCSP DCSP block = block &#91; : : ( -1 ) &#93; DCNL DCSP DCSP cipher _ block = aes.encrypt ( block ) DCNL DCSP DCSP cipher _ block = cipher _ block &#91; : : ( -1 ) &#93; DCNL DCSP DCSP for block in get _ chunks ( cipher _ block , 4 ) : DCNL DCSP DCSP DCSP digest.update ( block &#91; : : ( -1 ) &#93; ) DCNL DCSP if ( args.output is None ) : DCNL DCSP DCSP args.output = ( os.path.splitext ( args.image.name ) &#91; 0 &#93; + &apos; -digest-0x0000.bin &apos; ) DCNL DCSP with open ( args.output , &apos; wb &apos; ) as f : DCNL DCSP DCSP f.write ( iv ) DCNL DCSP DCSP digest = digest.digest ( ) DCNL DCSP DCSP for word in get _ chunks ( digest , 4 ) : DCNL DCSP DCSP DCSP f.write ( word &#91; : : ( -1 ) &#93; ) DCNL DCSP DCSP f.write ( ( &apos; \ xff &apos; * ( 4096 - f.tell ( ) ) ) ) DCNL DCSP DCSP f.write ( plaintext _ image ) DCNL DCSP print ( &apos; digest + image DCSP written DCSP to DCSP % s &apos; % args.output )
DCSP return { key : dictionary &#91; key &#93; for key in OPTIONAL _ PARAMETERS if ( key in dictionary ) }
DCSP django.setup ( ) DCNL DCSP switch1 = NetworkSwitch.objects.get ( device _ name = &apos; pynet-sw1 &apos; ) DCNL DCSP switch2 = NetworkSwitch.objects.get ( device _ name = &apos; pynet-sw2 &apos; ) DCNL DCSP switch3 = NetworkSwitch.objects.get ( device _ name = &apos; pynet-sw3 &apos; ) DCNL DCSP switch4 = NetworkSwitch.objects.get ( device _ name = &apos; pynet-sw4 &apos; ) DCNL DCSP print &apos; Creating DCSP Switch1 DCSP port DCSP objects &apos; DCNL DCSP std _ ports = &#91; ( &apos; Ethernet1 &apos; , 1 ) , ( &apos; Ethernet2 &apos; , 100 ) , ( &apos; Ethernet3 &apos; , 200 ) , ( &apos; Ethernet7 &apos; , 200 ) &#93; DCNL DCSP for ( switchport , vlan ) in std _ ports : DCNL DCSP DCSP create _ access _ port ( switch1 , switchport , vlan ) DCNL DCSP create _ trunk _ port ( switch1 , &apos; Ethernet4 &apos; ) DCNL DCSP create _ lag _ port ( switch1 , &apos; Ethernet5 &apos; , lag _ mode = &apos; active &apos; , lag _ group = 1 ) DCNL DCSP create _ lag _ port ( switch1 , &apos; Ethernet6 &apos; , lag _ mode = &apos; active &apos; , lag _ group = 1 ) DCNL DCSP create _ trunk _ port ( switch1 , &apos; Port-channel1 &apos; ) DCNL DCSP print &apos; Creating DCSP Switch2 DCSP port DCSP objects &apos; DCNL DCSP std _ ports = &#91; ( &apos; Ethernet1 &apos; , 1 ) , ( &apos; Ethernet2 &apos; , 100 ) , ( &apos; Ethernet3 &apos; , 100 ) , ( &apos; Ethernet4 &apos; , 200 ) , ( &apos; Ethernet5 &apos; , 300 ) &#93; DCNL DCSP for ( switchport , vlan ) in std _ ports : DCNL DCSP DCSP create _ access _ port ( switch2 , switchport , vlan ) DCNL DCSP create _ trunk _ port ( switch2 , &apos; Ethernet6 &apos; , native _ vlan = 300 , allowed _ vlans = &apos; 100,200,300 &apos; ) DCNL DCSP create _ trunk _ port ( switch2 , &apos; Ethernet7 &apos; , native _ vlan = 300 , allowed _ vlans = &apos; 100,200,300 &apos; ) DCNL DCSP print &apos; Creating DCSP Switch3 DCSP port DCSP objects &apos; DCNL DCSP std _ ports = &#91; ( &apos; Ethernet1 &apos; , 1 ) , ( &apos; Ethernet2 &apos; , 100 ) , ( &apos; Ethernet3 &apos; , 100 ) , ( &apos; Ethernet4 &apos; , 100 ) , ( &apos; Ethernet5 &apos; , 100 ) , ( &apos; Ethernet6 &apos; , 200 ) , ( &apos; Ethernet7 &apos; , 200 ) &#93; DCNL DCSP for ( switchport , vlan ) in std _ ports : DCNL DCSP DCSP create _ access _ port ( switch3 , switchport , vlan ) DCNL DCSP print &apos; Creating DCSP Switch4 DCSP port DCSP objects &apos; DCNL DCSP std _ ports = &#91; ( &apos; Ethernet1 &apos; , 1 ) , ( &apos; Ethernet2 &apos; , 100 ) , ( &apos; Ethernet3 &apos; , 100 ) , ( &apos; Ethernet4 &apos; , 100 ) , ( &apos; Ethernet5 &apos; , 100 ) &#93; DCNL DCSP for ( switchport , vlan ) in std _ ports : DCNL DCSP DCSP create _ access _ port ( switch4 , switchport , vlan ) DCNL DCSP create _ trunk _ port ( switch4 , &apos; Ethernet6 &apos; , native _ vlan = 300 , allowed _ vlans = &apos; 100,200,300 &apos; ) DCNL DCSP create _ trunk _ port ( switch4 , &apos; Ethernet7 &apos; , native _ vlan = 300 , allowed _ vlans = &apos; 100,200,300 &apos; )
DCSP if ( cols is not None ) : DCNL DCSP DCSP cols _ title = copy ( cols ) DCNL DCSP DCSP if ( not isinstance ( cols _ title , list ) ) : DCNL DCSP DCSP DCSP cols _ title = &#91; cols _ title &#93; DCNL DCSP DCSP return str ( &apos; , DCSP &apos; .join ( cols _ title ) .title ( ) ) .title ( ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP success = False DCNL DCSP err _ msg = &apos; &apos; DCNL DCSP params = { &apos; StreamName &apos; : stream _ name } DCNL DCSP try : DCNL DCSP DCSP if ( not check _ mode ) : DCNL DCSP DCSP DCSP if ( action = = &apos; increase &apos; ) : DCNL DCSP DCSP DCSP DCSP params &#91; &apos; RetentionPeriodHours &apos; &#93; = retention _ period DCNL DCSP DCSP DCSP DCSP client.increase _ stream _ retention _ period ( * * params ) DCNL DCSP DCSP DCSP DCSP success = True DCNL DCSP DCSP DCSP DCSP err _ msg = &apos; Retention DCSP Period DCSP increased DCSP successfully DCSP to DCSP { 0 } &apos; .format ( retention _ period ) DCNL DCSP DCSP DCSP elif ( action = = &apos; decrease &apos; ) : DCNL DCSP DCSP DCSP DCSP params &#91; &apos; RetentionPeriodHours &apos; &#93; = retention _ period DCNL DCSP DCSP DCSP DCSP client.decrease _ stream _ retention _ period ( * * params ) DCNL DCSP DCSP DCSP DCSP success = True DCNL DCSP DCSP DCSP DCSP err _ msg = &apos; Retention DCSP Period DCSP decreased DCSP successfully DCSP to DCSP { 0 } &apos; .format ( retention _ period ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP err _ msg = &apos; Invalid DCSP action DCSP { 0 } &apos; .format ( action ) DCNL DCSP DCSP elif ( action = = &apos; increase &apos; ) : DCNL DCSP DCSP DCSP success = True DCNL DCSP DCSP elif ( action = = &apos; decrease &apos; ) : DCNL DCSP DCSP DCSP success = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP err _ msg = &apos; Invalid DCSP action DCSP { 0 } &apos; .format ( action ) DCNL DCSP except botocore.exceptions.ClientError as e : DCNL DCSP DCSP err _ msg = str ( e ) DCNL DCSP return ( success , err _ msg )
DCSP s = &apos; javascript : document.vulnerable &apos; DCNL DCSP eq _ ( s , linkify ( s ) )
DCSP signature = base64.encodestring ( hmac.new ( Config.Config ( ) .secret _ key , deunicodise ( string _ to _ sign ) , sha1 ) .digest ( ) ) .strip ( ) DCNL DCSP return signature
DCSP loop = &#91; beginComplex , complex ( endComplex.real , beginComplex.imag ) , endComplex &#93; DCNL DCSP loop.append ( complex ( beginComplex.real , endComplex.imag ) ) DCNL DCSP return loop
DCSP query = Q ( ) DCNL DCSP events = Object.filter _ by _ request ( request , Event.objects.filter ( query ) ) DCNL DCSP icalstream = &apos; BEGIN : VCALENDAR \ nVERSION : 2.0 \ nCALSCALE : GREGORIAN \ nMETHOD : PUBLISH \ nPRODID : - / / PYVOBJECT / / NONSGML DCSP Version DCSP 1 / / EN \ n &apos; DCNL DCSP vevent = &apos; &apos; DCNL DCSP for event in events : DCNL DCSP DCSP vevent + = &apos; BEGIN : VEVENT \ n &apos; DCNL DCSP DCSP if event.start : DCNL DCSP DCSP DCSP vevent + = ( &apos; DTSTART ; VALUE = DATE : % s \ n &apos; % str ( datetime.strptime ( str ( event.start ) &#91; 0 : 10 &#93; , &apos; % Y- % m- % d &apos; ) ) &#91; 0 : 10 &#93; .replace ( &apos; -&apos; , &apos; &apos; ) ) DCNL DCSP DCSP vevent + = ( &apos; DTEND ; VALUE = DATE : % s \ n &apos; % str ( datetime.strptime ( str ( event.end ) &#91; 0 : 10 &#93; , &apos; % Y- % m- % d &apos; ) ) &#91; 0 : 10 &#93; .replace ( &apos; -&apos; , &apos; &apos; ) ) DCNL DCSP DCSP if ( not event.details ) : DCNL DCSP DCSP DCSP vevent + = ( &apos; SUMMARY : % s \ n &apos; % strip _ tags ( event.name ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP vevent + = ( &apos; SUMMARY : % s \ n &apos; % strip _ tags ( event.details ) ) DCNL DCSP DCSP vevent + = ( &apos; UID : % s \ n &apos; % event.name ) DCNL DCSP DCSP vevent + = &apos; END : VEVENT \ n &apos; DCNL DCSP icalstream + = vevent DCNL DCSP icalstream + = &apos; X-WR-CALDESC : Tree.io DCSP Calendar \ nX-WR-CALNAME : Tree.io \ nX-WR-TIMEZONE : London / UK \ nEND : VCALENDAR \ n &apos; DCNL DCSP response = HttpResponse ( icalstream , content _ type = &apos; text / calendar &apos; ) DCNL DCSP response &#91; &apos; Filename &apos; &#93; = &apos; events.ics &apos; DCNL DCSP response &#91; &apos; Content-Disposition &apos; &#93; = &apos; attachment ; DCSP filename = events.ics &apos; DCNL DCSP return response
DCSP table = &apos; \ n # DCSP comment DCSP ( with DCSP blank DCSP line DCSP above ) \ n &#124; DCSP DCSP Col1 DCSP DCSP &#124; DCSP DCSP Col2 DCSP DCSP DCSP &#124; DCSP DCSP Col3 DCSP &#124; \ n &#124; DCSP DCSP 1.2 DCSP DCSP DCSP &#124; DCSP &quot; hello &quot; DCSP &#124; DCSP DCSP DCSP DCSP DCSP 3 DCSP &#124; \ n &#124; DCSP DCSP 2.4 DCSP DCSP DCSP &#124; \ &apos; s DCSP worlds &#124; DCSP DCSP DCSP DCSP DCSP 7 DCSP &#124; \ n &apos; DCNL DCSP reader = ascii.get _ reader ( Reader = ascii.FixedWidth , names = ( &apos; name1 &apos; , &apos; name2 &apos; , &apos; name3 &apos; ) , include _ names = ( &apos; name1 &apos; , &apos; name3 &apos; ) ) DCNL DCSP dat = reader.read ( table ) DCNL DCSP assert _ equal ( dat.colnames , &#91; &apos; name1 &apos; , &apos; name3 &apos; &#93; ) DCNL DCSP assert _ almost _ equal ( dat &#91; 1 &#93; &#91; 0 &#93; , 2.4 ) DCNL DCSP assert _ equal ( dat &#91; 0 &#93; &#91; 1 &#93; , 3 )
DCSP f = open ( fname ) DCNL DCSP dtb = f.read ( ) DCNL DCSP f.close ( ) DCNL DCSP return dtb
DCSP if ( not ipython _ available ) : DCNL DCSP DCSP raise ImportError ( &apos; Only DCSP works DCSP inside DCSP an DCSP IPython DCSP Notebook &apos; ) DCNL DCSP if ( rd _ kwargs is None ) : DCNL DCSP DCSP rd _ kwargs = { } DCNL DCSP if ( fps is not None ) : DCNL DCSP DCSP rd _ kwargs &#91; &apos; fps &apos; &#93; = fps DCNL DCSP if ( t is not None ) : DCNL DCSP DCSP clip = clip.to _ ImageClip ( t ) DCNL DCSP return HTML2 ( html _ embed ( clip , filetype = filetype , maxduration = maxduration , center = center , rd _ kwargs = rd _ kwargs , * * html _ kwargs ) )
DCSP if ( ( not return _ distances ) and ( not return _ indices ) ) : DCNL DCSP DCSP msg = &apos; at DCSP least DCSP one DCSP of DCSP distances / indices DCSP must DCSP be DCSP specified &apos; DCNL DCSP DCSP raise RuntimeError ( msg ) DCNL DCSP tmp1 = ( numpy.asarray ( input ) ! = 0 ) DCNL DCSP struct = generate _ binary _ structure ( tmp1.ndim , tmp1.ndim ) DCNL DCSP tmp2 = binary _ dilation ( tmp1 , struct ) DCNL DCSP tmp2 = numpy.logical _ xor ( tmp1 , tmp2 ) DCNL DCSP tmp1 = ( tmp1.astype ( numpy.int8 ) - tmp2.astype ( numpy.int8 ) ) DCNL DCSP metric = metric.lower ( ) DCNL DCSP if ( metric = = &apos; euclidean &apos; ) : DCNL DCSP DCSP metric = 1 DCNL DCSP elif ( metric in &#91; &apos; taxicab &apos; , &apos; cityblock &apos; , &apos; manhattan &apos; &#93; ) : DCNL DCSP DCSP metric = 2 DCNL DCSP elif ( metric = = &apos; chessboard &apos; ) : DCNL DCSP DCSP metric = 3 DCNL DCSP else : DCNL DCSP DCSP raise RuntimeError ( &apos; distance DCSP metric DCSP not DCSP supported &apos; ) DCNL DCSP if ( sampling is not None ) : DCNL DCSP DCSP sampling = _ ni _ support . _ normalize _ sequence ( sampling , tmp1.ndim ) DCNL DCSP DCSP sampling = numpy.asarray ( sampling , dtype = numpy.float64 ) DCNL DCSP DCSP if ( not sampling.flags.contiguous ) : DCNL DCSP DCSP DCSP sampling = sampling.copy ( ) DCNL DCSP if return _ indices : DCNL DCSP DCSP ft = numpy.zeros ( tmp1.shape , dtype = numpy.int32 ) DCNL DCSP else : DCNL DCSP DCSP ft = None DCNL DCSP if return _ distances : DCNL DCSP DCSP if ( distances is None ) : DCNL DCSP DCSP DCSP if ( metric = = 1 ) : DCNL DCSP DCSP DCSP DCSP dt = numpy.zeros ( tmp1.shape , dtype = numpy.float64 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP dt = numpy.zeros ( tmp1.shape , dtype = numpy.uint32 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( distances.shape ! = tmp1.shape ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; distances DCSP array DCSP has DCSP wrong DCSP shape &apos; ) DCNL DCSP DCSP DCSP if ( metric = = 1 ) : DCNL DCSP DCSP DCSP DCSP if ( distances.dtype.type ! = numpy.float64 ) : DCNL DCSP DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; distances DCSP array DCSP must DCSP be DCSP float64 &apos; ) DCNL DCSP DCSP DCSP elif ( distances.dtype.type ! = numpy.uint32 ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; distances DCSP array DCSP must DCSP be DCSP uint32 &apos; ) DCNL DCSP DCSP DCSP dt = distances DCNL DCSP else : DCNL DCSP DCSP dt = None DCNL DCSP _ nd _ image.distance _ transform _ bf ( tmp1 , metric , sampling , dt , ft ) DCNL DCSP if return _ indices : DCNL DCSP DCSP if isinstance ( indices , numpy.ndarray ) : DCNL DCSP DCSP DCSP if ( indices.dtype.type ! = numpy.int32 ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; indices DCSP must DCSP of DCSP int32 DCSP type &apos; ) DCNL DCSP DCSP DCSP if ( indices.shape ! = ( ( tmp1.ndim , ) + tmp1.shape ) ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; indices DCSP has DCSP wrong DCSP shape &apos; ) DCNL DCSP DCSP DCSP tmp2 = indices DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP tmp2 = numpy.indices ( tmp1.shape , dtype = numpy.int32 ) DCNL DCSP DCSP ft = numpy.ravel ( ft ) DCNL DCSP DCSP for ii in range ( tmp2.shape &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP rtmp = numpy.ravel ( tmp2 &#91; ii , ... &#93; ) &#91; ft &#93; DCNL DCSP DCSP DCSP rtmp.shape = tmp1.shape DCNL DCSP DCSP DCSP tmp2 &#91; ii , ... &#93; = rtmp DCNL DCSP DCSP ft = tmp2 DCNL DCSP result = &#91; &#93; DCNL DCSP if ( return _ distances and ( not isinstance ( distances , numpy.ndarray ) ) ) : DCNL DCSP DCSP result.append ( dt ) DCNL DCSP if ( return _ indices and ( not isinstance ( indices , numpy.ndarray ) ) ) : DCNL DCSP DCSP result.append ( ft ) DCNL DCSP if ( len ( result ) = = 2 ) : DCNL DCSP DCSP return tuple ( result ) DCNL DCSP elif ( len ( result ) = = 1 ) : DCNL DCSP DCSP return result &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP return None
DCSP if os.system ( &apos; cd DCSP build / latex ; DCSP scp DCSP pandas.pdf DCSP { 0 } @ pandas.pydata.org : / usr / share / nginx / pandas / pandas-docs / dev / &apos; .format ( user ) ) : DCNL DCSP DCSP raise SystemExit ( &apos; PDF DCSP upload DCSP to DCSP Pydata DCSP Dev DCSP failed &apos; )
DCSP loader = _ guess _ loader ( names &#91; ( -1 ) &#93; , OpenSSL.crypto.FILETYPE _ PEM , OpenSSL.crypto.FILETYPE _ ASN1 ) DCNL DCSP return OpenSSL.crypto.load _ certificate _ request ( loader , load _ vector ( * names ) )
DCSP return interface _ decorator ( &apos; auto _ openstack _ logging &apos; , interface , _ openstack _ logged _ method , original )
DCSP antispam = AntispamForm ( request.POST ) DCNL DCSP if ( not antispam.is _ valid ( ) ) : DCNL DCSP DCSP return HttpResponseRedirect ( next _ unit _ url ) DCNL DCSP translation.check _ sync ( ) DCNL DCSP form = TranslationForm ( translation , None , request.POST ) DCNL DCSP if ( not form.is _ valid ( ) ) : DCNL DCSP DCSP return DCNL DCSP unit = form.cleaned _ data &#91; u &apos;unit &apos; &#93; DCNL DCSP go _ next = True DCNL DCSP if ( u &apos;suggest &apos; in request.POST ) : DCNL DCSP DCSP go _ next = perform _ suggestion ( unit , form , request ) DCNL DCSP elif ( not can _ translate ( request.user , unit.translation ) ) : DCNL DCSP DCSP messages.error ( request , _ ( u &quot; You DCSP don &apos;t DCSP have DCSP privileges DCSP to DCSP save DCSP translations ! &quot; ) ) DCNL DCSP elif ( not user _ locked ) : DCNL DCSP DCSP message = request.POST.get ( u &apos;commit _ message &apos; , None ) DCNL DCSP DCSP if ( ( message is not None ) and ( message ! = unit.translation.commit _ message ) ) : DCNL DCSP DCSP DCSP unit.translation.commit _ pending ( request , request.user ) DCNL DCSP DCSP DCSP unit.translation.commit _ message = message DCNL DCSP DCSP DCSP unit.translation.save ( ) DCNL DCSP DCSP go _ next = perform _ translation ( unit , form , request ) DCNL DCSP if go _ next : DCNL DCSP DCSP return HttpResponseRedirect ( next _ unit _ url ) DCNL DCSP else : DCNL DCSP DCSP return HttpResponseRedirect ( this _ unit _ url )
DCSP if ( name is None ) : DCNL DCSP DCSP msg = _ ( &apos; name DCSP cannot DCSP be DCSP None &apos; ) DCNL DCSP DCSP raise exception.InvalidGroupType ( reason = msg ) DCNL DCSP return db.group _ type _ get _ by _ name ( context , name )
DCSP url = u &apos; { } / { } / tags &apos; .format ( GITHUB _ API , project ) DCNL DCSP response = requests.get ( url ) DCNL DCSP response.raise _ for _ status ( ) DCNL DCSP versions = get _ versions ( response.json ( ) ) DCNL DCSP return sorted ( versions , reverse = True , key = operator.attrgetter ( u &apos;order &apos; ) )
DCSP if ( auth _ url or os.getenv ( &apos; OS _ AUTH _ URL &apos; ) ) : DCNL DCSP DCSP force _ strategy = &apos; keystone &apos; DCNL DCSP else : DCNL DCSP DCSP force _ strategy = None DCNL DCSP creds = { &apos; username &apos; : ( username or os.getenv ( &apos; OS _ AUTH _ USER &apos; , os.getenv ( &apos; OS _ USERNAME &apos; ) ) ) , &apos; password &apos; : ( password or os.getenv ( &apos; OS _ AUTH _ KEY &apos; , os.getenv ( &apos; OS _ PASSWORD &apos; ) ) ) , &apos; tenant &apos; : ( tenant or os.getenv ( &apos; OS _ AUTH _ TENANT &apos; , os.getenv ( &apos; OS _ TENANT _ NAME &apos; ) ) ) , &apos; auth _ url &apos; : ( auth _ url or os.getenv ( &apos; OS _ AUTH _ URL &apos; ) ) , &apos; strategy &apos; : ( force _ strategy or auth _ strategy or os.getenv ( &apos; OS _ AUTH _ STRATEGY &apos; , &apos; noauth &apos; ) ) , &apos; region &apos; : ( region or os.getenv ( &apos; OS _ REGION _ NAME &apos; ) ) } DCNL DCSP if ( ( creds &#91; &apos; strategy &apos; &#93; = = &apos; keystone &apos; ) and ( not creds &#91; &apos; auth _ url &apos; &#93; ) ) : DCNL DCSP DCSP msg = &apos; --os _ auth _ url DCSP option DCSP or DCSP OS _ AUTH _ URL DCSP environment DCSP variable DCSP required DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enabled \ n &apos; DCNL DCSP DCSP raise exception.ClientConfigurationError ( msg ) DCNL DCSP return CacheClient ( host = host , port = port , timeout = timeout , use _ ssl = use _ ssl , auth _ tok = ( auth _ token or os.getenv ( &apos; OS _ TOKEN &apos; ) ) , creds = creds , insecure = insecure )
DCSP item _ types = { } DCNL DCSP for meta _ source in META _ SOURCES.values ( ) : DCNL DCSP DCSP item _ types.update ( meta _ source.item _ types ) DCNL DCSP return item _ types
DCSP rv = &#91; &#93; DCNL DCSP any _ prefix _ is _ slash = False DCNL DCSP for opt in options : DCNL DCSP DCSP prefix = split _ opt ( opt ) &#91; 0 &#93; DCNL DCSP DCSP if ( prefix = = &apos; / &apos; ) : DCNL DCSP DCSP DCSP any _ prefix _ is _ slash = True DCNL DCSP DCSP rv.append ( ( len ( prefix ) , opt ) ) DCNL DCSP rv.sort ( key = ( lambda x : x &#91; 0 &#93; ) ) DCNL DCSP rv = &apos; , DCSP &apos; .join ( ( x &#91; 1 &#93; for x in rv ) ) DCNL DCSP return ( rv , any _ prefix _ is _ slash )
DCSP return HttpResponse ( json.dumps ( request.META ) )
DCSP if ( auth.permission.format ! = &apos; s3json &apos; ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( r.method ! = &apos; options &apos; ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3 _ rest _ controller ( )
DCSP if ( field and hasattr ( user , field ) ) : DCNL DCSP DCSP if args : DCNL DCSP DCSP DCSP v = args &#91; 0 &#93; DCNL DCSP DCSP DCSP if v : DCNL DCSP DCSP DCSP DCSP User = get _ user _ model ( ) DCNL DCSP DCSP DCSP DCSP v = v &#91; 0 : User . _ meta.get _ field ( field ) .max _ length &#93; DCNL DCSP DCSP DCSP setattr ( user , field , v ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return getattr ( user , field )
DCSP name = cfg.marker _ file ( ) DCNL DCSP if name : DCNL DCSP DCSP path = os.path.join ( folder , name ) DCNL DCSP DCSP logging.debug ( &apos; Create DCSP marker DCSP file DCSP % s &apos; , path ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP fp = open ( path , &apos; w &apos; ) DCNL DCSP DCSP DCSP fp.close ( ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP logging.info ( &apos; Cannot DCSP create DCSP marker DCSP file DCSP % s &apos; , path ) DCNL DCSP DCSP DCSP logging.info ( &apos; Traceback : DCSP &apos; , exc _ info = True ) DCNL DCSP DCSP DCSP name = None DCNL DCSP return name
DCSP _ execute ( &apos; ip &apos; , &apos; addr &apos; , &apos; add &apos; , ( str ( floating _ ip ) + &apos; / 32 &apos; ) , &apos; dev &apos; , device , run _ as _ root = True , check _ exit _ code = &#91; 0 , 2 , 254 &#93; ) DCNL DCSP if ( CONF.send _ arp _ for _ ha and ( CONF.send _ arp _ for _ ha _ count &gt; 0 ) ) : DCNL DCSP DCSP send _ arp _ for _ ip ( floating _ ip , device , CONF.send _ arp _ for _ ha _ count )
DCSP chart = Chart ( interpolate = &apos; hermite &apos; , interpolation _ parameters = { &apos; type &apos; : &apos; cardinal &apos; , &apos; c &apos; : 0.75 } ) DCNL DCSP chart = make _ data ( chart , datas ) DCNL DCSP assert chart.render ( )
DCSP if ( not frappe.db.exists ( doctype , old ) ) : DCNL DCSP DCSP return DCNL DCSP force = cint ( force ) DCNL DCSP merge = cint ( merge ) DCNL DCSP meta = frappe.get _ meta ( doctype ) DCNL DCSP old _ doc = frappe.get _ doc ( doctype , old ) DCNL DCSP out = ( old _ doc.run _ method ( u &apos;before _ rename &apos; , old , new , merge ) or { } ) DCNL DCSP new = ( ( out.get ( u &apos;new &apos; ) or new ) if isinstance ( out , dict ) else ( out or new ) ) DCNL DCSP if ( doctype ! = u &apos;DocType &apos; ) : DCNL DCSP DCSP new = validate _ rename ( doctype , new , meta , merge , force , ignore _ permissions ) DCNL DCSP if ( not merge ) : DCNL DCSP DCSP rename _ parent _ and _ child ( doctype , old , new , meta ) DCNL DCSP link _ fields = get _ link _ fields ( doctype ) DCNL DCSP update _ link _ field _ values ( link _ fields , old , new , doctype ) DCNL DCSP rename _ dynamic _ links ( doctype , old , new ) DCNL DCSP if ( doctype = = u &apos;DocType &apos; ) : DCNL DCSP DCSP rename _ doctype ( doctype , old , new , force ) DCNL DCSP update _ attachments ( doctype , old , new ) DCNL DCSP if merge : DCNL DCSP DCSP frappe.delete _ doc ( doctype , old ) DCNL DCSP new _ doc = frappe.get _ doc ( doctype , new ) DCNL DCSP new _ doc . _ local = getattr ( old _ doc , u &apos; _ local &apos; , None ) DCNL DCSP new _ doc.run _ method ( u &apos;after _ rename &apos; , old , new , merge ) DCNL DCSP rename _ versions ( doctype , old , new ) DCNL DCSP if ( not merge ) : DCNL DCSP DCSP rename _ password ( doctype , old , new ) DCNL DCSP frappe.db.sql ( u &quot; update DCSP tabDefaultValue DCSP set DCSP defvalue = % s DCSP where DCSP parenttype = &apos; User DCSP Permission &apos; \ n DCTB DCTB and DCSP defkey = % s DCSP and DCSP defvalue = % s &quot; , ( new , doctype , old ) ) DCNL DCSP frappe.clear _ cache ( ) DCNL DCSP if merge : DCNL DCSP DCSP new _ doc.add _ comment ( u &apos;Edit &apos; , _ ( u &apos;merged DCSP { 0 } DCSP into DCSP { 1 } &apos; ) .format ( frappe.bold ( old ) , frappe.bold ( new ) ) ) DCNL DCSP else : DCNL DCSP DCSP new _ doc.add _ comment ( u &apos;Edit &apos; , _ ( u &apos;renamed DCSP from DCSP { 0 } DCSP to DCSP { 1 } &apos; ) .format ( frappe.bold ( old ) , frappe.bold ( new ) ) ) DCNL DCSP return new
DCSP bigip _ session = _ build _ session ( username , password ) DCNL DCSP trans _ id = _ _ salt _ _ &#91; &apos; grains.get &apos; &#93; ( &apos; bigip _ f5 _ trans : { label } &apos; .format ( label = label ) ) DCNL DCSP if trans _ id : DCNL DCSP DCSP payload = { } DCNL DCSP DCSP payload &#91; &apos; state &apos; &#93; = &apos; VALIDATING &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP response = bigip _ session.patch ( ( BIG _ IP _ URL _ BASE.format ( host = hostname ) + &apos; / transaction / { trans _ id } &apos; .format ( trans _ id = trans _ id ) ) , data = json.dumps ( payload ) ) DCNL DCSP DCSP DCSP return _ load _ response ( response ) DCNL DCSP DCSP except requests.exceptions.ConnectionError as e : DCNL DCSP DCSP DCSP return _ load _ connection _ error ( hostname , e ) DCNL DCSP else : DCNL DCSP DCSP return &apos; Error : DCSP the DCSP label DCSP for DCSP this DCSP transaction DCSP was DCSP not DCSP defined DCSP as DCSP a DCSP grain . DCSP DCSP Begin DCSP a DCSP new DCSP transaction DCSP using DCSP the DCSP bigip.start _ transaction DCSP function&apos;
DCSP func _ name = ( prefix + cmd ) DCNL DCSP if ( func _ name in globals ( ) ) : DCNL DCSP DCSP return globals ( ) &#91; func _ name &#93; ( stdout , stderr , environ , * cmd _ args ) DCNL DCSP else : DCNL DCSP DCSP stderr.write ( error _ msg ) DCNL DCSP DCSP return ( -1 )
DCSP if ( isinstance ( node.op , T.Elemwise ) and isinstance ( node.op.scalar _ op , theano.scalar.basic.Sub ) ) : DCNL DCSP DCSP ( in1 , in2 ) = node.inputs DCNL DCSP DCSP out = node.outputs &#91; 0 &#93; DCNL DCSP DCSP if ( in1.owner and isinstance ( in1.owner.op , T.Elemwise ) and isinstance ( in1.owner.op.scalar _ op , theano.scalar.basic.Exp ) and ( T.extract _ constant ( in2 , only _ process _ constants = False ) = = 1 ) ) : DCNL DCSP DCSP DCSP in11 = in1.owner.inputs &#91; 0 &#93; DCNL DCSP DCSP DCSP new _ out = T.expm1 ( in11 ) DCNL DCSP DCSP DCSP if ( new _ out.dtype ! = out.dtype ) : DCNL DCSP DCSP DCSP DCSP new _ out = T.cast ( new _ out , dtype = out.dtype ) DCNL DCSP DCSP DCSP if ( new _ out.type ! = out.type ) : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP return &#91; new _ out &#93;
DCSP return defaulttags.firstof ( parser , token , escape = True )
DCSP conn = _ _ get _ conn ( ) DCNL DCSP cpus = conn.getInfo ( ) &#91; 2 &#93; DCNL DCSP for vm _ in list _ domains ( ) : DCNL DCSP DCSP dom = _ get _ domain ( vm _ ) DCNL DCSP DCSP if ( dom.ID ( ) &gt; 0 ) : DCNL DCSP DCSP DCSP cpus - = dom.info ( ) &#91; 3 &#93; DCNL DCSP return cpus
DCSP if ( &apos; npm DCSP install &apos; in arg ) : DCNL DCSP DCSP raise BuildFailure ( &apos; Subprocess DCSP return DCSP code : DCSP 50 &apos; ) DCNL DCSP else : DCNL DCSP DCSP return
DCSP primary = eni _ desc.get ( &apos; privateIpAddress &apos; ) DCNL DCSP if ( not primary ) : DCNL DCSP DCSP return None DCNL DCSP addresses = &#91; primary &#93; DCNL DCSP lst = eni _ desc.get ( &apos; privateIpAddressesSet &apos; , { } ) .get ( &apos; item &apos; , &#91; &#93; ) DCNL DCSP if ( not isinstance ( lst , list ) ) : DCNL DCSP DCSP return addresses DCNL DCSP for entry in lst : DCNL DCSP DCSP if ( entry.get ( &apos; primary &apos; ) = = &apos; true &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if entry.get ( &apos; privateIpAddress &apos; ) : DCNL DCSP DCSP DCSP addresses.append ( entry.get ( &apos; privateIpAddress &apos; ) ) DCNL DCSP return addresses
DCSP client = _ _ utils _ _ &#91; &apos; etcd _ util.get _ conn &apos; &#93; ( _ _ opts _ _ , profile ) DCNL DCSP return client.ls ( path )
DCSP http = transport.get _ http _ object ( timeout = GCE _ METADATA _ TIMEOUT ) DCNL DCSP try : DCNL DCSP DCSP ( response , _ ) = transport.request ( http , _ GCE _ METADATA _ URI , headers = _ GCE _ HEADERS ) DCNL DCSP DCSP return ( ( response.status = = http _ client.OK ) and ( response.get ( _ METADATA _ FLAVOR _ HEADER ) = = _ DESIRED _ METADATA _ FLAVOR ) ) DCNL DCSP except socket.error : DCNL DCSP DCSP logger.info ( &apos; Timeout DCSP attempting DCSP to DCSP reach DCSP GCE DCSP metadata DCSP service . &apos; ) DCNL DCSP DCSP return False
DCSP tpeak = 0.073 DCNL DCSP sphere = make _ sphere _ model ( head _ radius = 0.1 ) DCNL DCSP evoked = read _ evokeds ( fname _ evo , baseline = ( None , 0 ) ) &#91; 0 &#93; DCNL DCSP evoked.pick _ types ( meg = True ) DCNL DCSP t _ idx = np.argmin ( np.abs ( ( tpeak - evoked.times ) ) ) DCNL DCSP evoked _ crop = evoked.copy ( ) .crop ( tpeak , tpeak ) DCNL DCSP assert _ equal ( len ( evoked _ crop.times ) , 1 ) DCNL DCSP cov = read _ cov ( fname _ cov ) DCNL DCSP ( dip _ seq , resid ) = fit _ dipole ( evoked _ crop , cov , sphere ) DCNL DCSP assert _ true ( isinstance ( dip _ seq , Dipole ) ) DCNL DCSP assert _ equal ( len ( dip _ seq.times ) , 1 ) DCNL DCSP ( pos , ori , gof ) = ( dip _ seq.pos &#91; 0 &#93; , dip _ seq.ori &#91; 0 &#93; , dip _ seq.gof &#91; 0 &#93; ) DCNL DCSP amp = dip _ seq.amplitude &#91; 0 &#93; DCNL DCSP ( dip _ free , resid _ free ) = fit _ dipole ( evoked , cov , sphere , pos = pos ) DCNL DCSP assert _ true ( isinstance ( dip _ free , Dipole ) ) DCNL DCSP assert _ allclose ( dip _ free.times , evoked.times ) DCNL DCSP assert _ allclose ( np.tile ( pos &#91; np.newaxis &#93; , ( len ( evoked.times ) , 1 ) ) , dip _ free.pos ) DCNL DCSP assert _ allclose ( ori , dip _ free.ori &#91; t _ idx &#93; ) DCNL DCSP assert _ true ( ( np.dot ( dip _ free.ori , ori ) .mean ( ) &lt; 0.9 ) ) DCNL DCSP assert _ allclose ( gof , dip _ free.gof &#91; t _ idx &#93; ) DCNL DCSP assert _ allclose ( amp , dip _ free.amplitude &#91; t _ idx &#93; ) DCNL DCSP assert _ allclose ( resid , resid _ free &#91; : , &#91; t _ idx &#93; &#93; ) DCNL DCSP ( dip _ fixed , resid _ fixed ) = fit _ dipole ( evoked , cov , sphere , pos = pos , ori = ori ) DCNL DCSP assert _ true ( isinstance ( dip _ fixed , DipoleFixed ) ) DCNL DCSP assert _ allclose ( dip _ fixed.times , evoked.times ) DCNL DCSP assert _ allclose ( dip _ fixed.info &#91; &apos; chs &apos; &#93; &#91; 0 &#93; &#91; &apos; loc &apos; &#93; &#91; : 3 &#93; , pos ) DCNL DCSP assert _ allclose ( dip _ fixed.info &#91; &apos; chs &apos; &#93; &#91; 0 &#93; &#91; &apos; loc &apos; &#93; &#91; 3 : 6 &#93; , ori ) DCNL DCSP assert _ allclose ( dip _ fixed.data &#91; ( 1 , t _ idx ) &#93; , gof ) DCNL DCSP assert _ allclose ( resid , resid _ fixed &#91; : , &#91; t _ idx &#93; &#93; ) DCNL DCSP _ check _ roundtrip _ fixed ( dip _ fixed ) DCNL DCSP evoked _ nan = evoked.copy ( ) .crop ( 0 , 0 ) DCNL DCSP evoked _ nan.data &#91; ( 0 , 0 ) &#93; = None DCNL DCSP assert _ raises ( ValueError , fit _ dipole , evoked _ nan , cov , sphere ) DCNL DCSP assert _ raises ( ValueError , fit _ dipole , evoked , cov , sphere , ori = &#91; 1 , 0 , 0 &#93; ) DCNL DCSP assert _ raises ( ValueError , fit _ dipole , evoked , cov , sphere , pos = &#91; 0 , 0 , 0 &#93; , ori = &#91; 2 , 0 , 0 &#93; ) DCNL DCSP assert _ raises ( ValueError , fit _ dipole , evoked , cov , sphere , pos = &#91; 0.1 , 0 , 0 &#93; )
DCSP ( d , terms ) = ( dmp _ degree ( g , v ) , &#91; &#93; ) DCNL DCSP if ( not v ) : DCNL DCSP DCSP for ( i , c ) in enumerate ( g ) : DCNL DCSP DCSP DCSP if ( not c ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP terms.append ( ( ( monom + ( ( d - i ) , ) ) , c ) ) DCNL DCSP else : DCNL DCSP DCSP w = ( v - 1 ) DCNL DCSP DCSP for ( i , c ) in enumerate ( g ) : DCNL DCSP DCSP DCSP terms.extend ( _ rec _ list _ terms ( c , w , ( monom + ( ( d - i ) , ) ) ) ) DCNL DCSP return terms
DCSP conn = _ auth ( profile ) DCNL DCSP return conn.update _ quota ( tenant _ id , subnet , router , network , floatingip , port , security _ group , security _ group _ rule )
DCSP normalize = ( lambda u : ( ( u &apos; / / &apos; + u.split ( u &apos; : / / &apos; ) &#91; ( -1 ) &#93; ) if ( u &apos; : / / &apos; in u ) else u ) ) DCNL DCSP url = normalize ( request.GET &#91; u &apos;u &apos; &#93; ) DCNL DCSP host = ( u &apos; / / &apos; + request.get _ host ( ) ) DCNL DCSP static _ url = normalize ( settings.STATIC _ URL ) DCNL DCSP for prefix in ( host , static _ url , u &apos; / &apos; ) : DCNL DCSP DCSP if url.startswith ( prefix ) : DCNL DCSP DCSP DCSP url = url.replace ( prefix , u &apos; &apos; , 1 ) DCNL DCSP response = u &apos; &apos; DCNL DCSP ( content _ type , encoding ) = mimetypes.guess _ type ( url ) DCNL DCSP if ( content _ type is None ) : DCNL DCSP DCSP content _ type = u &apos;application / octet-stream &apos; DCNL DCSP path = finders.find ( url ) DCNL DCSP if path : DCNL DCSP DCSP if isinstance ( path , ( list , tuple ) ) : DCNL DCSP DCSP DCSP path = path &#91; 0 &#93; DCNL DCSP DCSP if url.endswith ( u &apos; .htm &apos; ) : DCNL DCSP DCSP DCSP static _ url = ( ( settings.STATIC _ URL + os.path.split ( url ) &#91; 0 &#93; ) + u &apos; / &apos; ) DCNL DCSP DCSP DCSP if ( not urlparse ( static _ url ) .scheme ) : DCNL DCSP DCSP DCSP DCSP static _ url = urljoin ( host , static _ url ) DCNL DCSP DCSP DCSP base _ tag = ( u &quot; &lt; base DCSP href = &apos; % s &apos; &gt; &quot; % static _ url ) DCNL DCSP DCSP DCSP with open ( path , u &apos;r &apos; ) as f : DCNL DCSP DCSP DCSP DCSP response = f.read ( ) .replace ( u &apos; &lt; head &gt; &apos; , ( u &apos; &lt; head &gt; &apos; + base _ tag ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP with open ( path , u &apos;rb &apos; ) as f : DCNL DCSP DCSP DCSP DCSP DCSP response = f.read ( ) DCNL DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP return HttpResponseNotFound ( ) DCNL DCSP return HttpResponse ( response , content _ type = content _ type )
DCSP config _ stub.data = { &apos; storage &apos; : { &apos; cache-size &apos; : 1024 } , &apos; general &apos; : { &apos; private-browsing &apos; : False } } DCNL DCSP url = &apos; http : / / qutebrowser.org &apos; DCNL DCSP disk _ cache = cache.DiskCache ( str ( tmpdir ) ) DCNL DCSP preload _ cache ( disk _ cache , url ) DCNL DCSP assert ( disk _ cache.cacheSize ( ) &gt; 0 ) DCNL DCSP assert disk _ cache.remove ( QUrl ( url ) ) DCNL DCSP assert ( disk _ cache.cacheSize ( ) = = 0 )
DCSP _ debugOut ( ( &apos; _ executeExternalCmdAndReapStdout : DCSP Starting ... \ n &lt; % s &gt; &apos; % ( args , ) ) ) DCNL DCSP p = subprocess.Popen ( args , env = os.environ , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP _ debugOut ( ( &apos; Process DCSP started DCSP for DCSP &lt; % s &gt; &apos; % ( args , ) ) ) DCNL DCSP ( stdoutData , stderrData ) = p.communicate ( ) DCNL DCSP _ debugOut ( ( ( &apos; Process DCSP completed DCSP for DCSP &lt; % s &gt; : DCSP exit DCSP status = % s , DCSP &apos; + &apos; stdoutDataType = % s , DCSP stdoutData = &lt; % s &gt; , DCSP stderrData = &lt; % s &gt; &apos; ) % ( args , p.returncode , type ( stdoutData ) , stdoutData , stderrData ) ) ) DCNL DCSP result = dict ( exitStatus = p.returncode , stdoutData = stdoutData , stderrData = stderrData ) DCNL DCSP _ debugOut ( ( &apos; _ executeExternalCmdAndReapStdout DCSP for DCSP &lt; % s &gt; : DCSP result = \ n % s &apos; % ( args , pprint.pformat ( result , indent = 4 ) ) ) ) DCNL DCSP return result
DCSP char _ list = list ( s ) DCNL DCSP char _ list.sort ( ) DCNL DCSP i = 0 DCNL DCSP n = len ( char _ list ) DCNL DCSP result = &#91; &#93; DCNL DCSP while ( i &lt; n ) : DCNL DCSP DCSP code1 = ord ( char _ list &#91; i &#93; ) DCNL DCSP DCSP code2 = ( code1 + 1 ) DCNL DCSP DCSP i + = 1 DCNL DCSP DCSP while ( ( i &lt; n ) and ( code2 &gt; = ord ( char _ list &#91; i &#93; ) ) ) : DCNL DCSP DCSP DCSP code2 + = 1 DCNL DCSP DCSP DCSP i + = 1 DCNL DCSP DCSP result.append ( code1 ) DCNL DCSP DCSP result.append ( code2 ) DCNL DCSP return result
DCSP failed = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP fp = open ( sfv _ path , &apos; r &apos; ) DCNL DCSP except : DCNL DCSP DCSP logging.info ( &apos; Cannot DCSP open DCSP SFV DCSP file DCSP % s &apos; , sfv _ path ) DCNL DCSP DCSP failed.append ( unicoder ( sfv _ path ) ) DCNL DCSP DCSP return failed DCNL DCSP root = os.path.split ( sfv _ path ) &#91; 0 &#93; DCNL DCSP for line in fp : DCNL DCSP DCSP line = line.strip ( &apos; \ n \ r DCSP &apos; ) DCNL DCSP DCSP if ( line and ( line &#91; 0 &#93; ! = &apos; ; &apos; ) ) : DCNL DCSP DCSP DCSP x = line.rfind ( &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP if ( x &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP filename = platform _ encode ( line &#91; : x &#93; .strip ( ) ) DCNL DCSP DCSP DCSP DCSP checksum = line &#91; x : &#93; .strip ( ) DCNL DCSP DCSP DCSP DCSP path = os.path.join ( root , filename ) DCNL DCSP DCSP DCSP DCSP if os.path.exists ( path ) : DCNL DCSP DCSP DCSP DCSP DCSP if crc _ check ( path , checksum ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP logging.debug ( &apos; File DCSP % s DCSP passed DCSP SFV DCSP check &apos; , path ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP logging.info ( &apos; File DCSP % s DCSP did DCSP not DCSP pass DCSP SFV DCSP check &apos; , path ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP failed.append ( unicoder ( filename ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP logging.info ( &apos; File DCSP % s DCSP missing DCSP in DCSP SFV DCSP check &apos; , path ) DCNL DCSP DCSP DCSP DCSP DCSP failed.append ( unicoder ( filename ) ) DCNL DCSP fp.close ( ) DCNL DCSP return failed
DCSP if isinstance ( client , images _ v1 _ client.ImagesClient ) : DCNL DCSP DCSP def _ show _ image _ v1 ( image _ id ) : DCNL DCSP DCSP DCSP resp = client.check _ image ( image _ id ) DCNL DCSP DCSP DCSP return common _ image.get _ image _ meta _ from _ headers ( resp ) DCNL DCSP DCSP show _ image = _ show _ image _ v1 DCNL DCSP else : DCNL DCSP DCSP show _ image = client.show _ image DCNL DCSP current _ status = &apos; An DCSP unknown DCSP status &apos; DCNL DCSP start = int ( time.time ( ) ) DCNL DCSP while ( ( int ( time.time ( ) ) - start ) &lt; client.build _ timeout ) : DCNL DCSP DCSP image = show _ image ( image _ id ) DCNL DCSP DCSP if ( &apos; image &apos; in image ) : DCNL DCSP DCSP DCSP image = image &#91; &apos; image &apos; &#93; DCNL DCSP DCSP current _ status = image &#91; &apos; status &apos; &#93; DCNL DCSP DCSP if ( current _ status = = status ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if ( current _ status.lower ( ) = = &apos; killed &apos; ) : DCNL DCSP DCSP DCSP raise exceptions.ImageKilledException ( image _ id = image _ id , status = status ) DCNL DCSP DCSP if ( current _ status.lower ( ) = = &apos; error &apos; ) : DCNL DCSP DCSP DCSP raise exceptions.AddImageException ( image _ id = image _ id ) DCNL DCSP DCSP time.sleep ( client.build _ interval ) DCNL DCSP message = ( &apos; Image DCSP % ( image _ id ) s DCSP failed DCSP to DCSP reach DCSP % ( status ) s DCSP state DCSP ( current DCSP state DCSP % ( current _ status ) s ) DCSP within DCSP the DCSP required DCSP time DCSP ( % ( timeout ) s DCSP s ) . &apos; % { &apos; image _ id &apos; : image _ id , &apos; status &apos; : status , &apos; current _ status &apos; : current _ status , &apos; timeout &apos; : client.build _ timeout } ) DCNL DCSP caller = test _ utils.find _ test _ caller ( ) DCNL DCSP if caller : DCNL DCSP DCSP message = ( &apos; ( % s ) DCSP % s &apos; % ( caller , message ) ) DCNL DCSP raise lib _ exc.TimeoutException ( message )
DCSP return &apos; { name } _ { size } . { file _ extension } &apos; .format ( name = name , size = size , file _ extension = file _ extension )
DCSP if ( _ _ grains _ _ &#91; &apos; kernel &apos; &#93; ! = &apos; OpenBSD &apos; ) : DCNL DCSP DCSP return False DCNL DCSP userinfo = _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( &#91; &apos; userinfo &apos; , name &#93; , python _ shell = False ) DCNL DCSP for line in userinfo.splitlines ( ) : DCNL DCSP DCSP if line.startswith ( &apos; class &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ret = line.split ( None , 1 ) &#91; 1 &#93; DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP except ( ValueError , IndexError ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP else : DCNL DCSP DCSP ret = &apos; &apos; DCNL DCSP return ret
DCSP result _ path _ filename = list ( ) DCNL DCSP result _ path _ filename.extend ( &#91; os.path.join ( dirpath , filename ) for ( dirpath , dirnames , filenames ) in os.walk ( search _ directory ) for filename in filenames if ( os.path.splitext ( filename ) &#91; 1 &#93; = = ( &apos; .&apos; + specific _ file ) ) &#93; ) DCNL DCSP return result _ path _ filename
DCSP return { &apos; title &apos; : &apos; home &apos; , &apos; href &apos; : &apos; / &apos; }
DCSP numpy.testing.assert _ array _ less ( cupy.asnumpy ( x ) , cupy.asnumpy ( y ) , err _ msg = err _ msg , verbose = verbose )
DCSP if ( not os.path.exists ( session _ file ) ) : DCNL DCSP DCSP return DCNL DCSP with open ( session _ file ) as handle : DCNL DCSP DCSP data = json.load ( handle ) DCNL DCSP for ( mx _ id , token ) in data.items ( ) : DCNL DCSP DCSP AUTH _ TOKENS &#91; mx _ id &#93; = token
DCSP global _ cache _ tz DCNL DCSP _ cache _ tz = pytz.timezone ( get _ localzone _ name ( ) )
DCSP evoked = read _ evokeds ( evoked _ fname , condition = &apos; Left DCSP Auditory &apos; ) DCNL DCSP evoked.info &#91; &apos; bads &apos; &#93; = &#91; &apos; MEG DCSP 2443 &apos; , &apos; EEG DCSP 053 &apos; &#93; DCNL DCSP surf = get _ head _ surf ( &apos; sample &apos; , subjects _ dir = subjects _ dir ) DCNL DCSP assert _ raises ( ValueError , _ make _ surface _ mapping , evoked.info , surf , &apos; eeg &apos; ) DCNL DCSP evoked.pick _ types ( meg = False , eeg = True ) DCNL DCSP fmd = make _ field _ map ( evoked , trans _ fname , subject = &apos; sample &apos; , subjects _ dir = subjects _ dir ) DCNL DCSP assert _ raises ( RuntimeError , make _ field _ map , evoked , None , subject = &apos; sample &apos; , subjects _ dir = subjects _ dir ) DCNL DCSP fmd = make _ field _ map ( evoked , trans _ fname , subject = &apos; sample &apos; , subjects _ dir = subjects _ dir ) DCNL DCSP assert _ true ( ( len ( fmd ) = = 1 ) ) DCNL DCSP assert _ array _ equal ( fmd &#91; 0 &#93; &#91; &apos; data &apos; &#93; .shape , ( 642 , 59 ) ) DCNL DCSP assert _ true ( len ( fmd &#91; 0 &#93; &#91; &apos; ch _ names &apos; &#93; ) , 59 )
DCSP options = get _ options ( ) DCNL DCSP options.resource = options.resource &#91; 0 &#93; DCNL DCSP before _ str = _ _ determine _ before _ str ( options ) DCNL DCSP resource _ basename = options.resource &#91; ( options.resource.rfind ( &apos; .&apos; ) + 1 ) : &#93; DCNL DCSP resource _ id _ key = ( resource _ basename &#91; : ( -1 ) &#93; if ( resource _ basename &#91; ( -1 ) &#93; = = &apos; s &apos; ) else resource _ basename ) DCNL DCSP delete _ kwargs = _ _ determine _ delete _ kwargs ( options ) DCNL DCSP list _ kwargs = _ _ determine _ list _ kwargs ( options ) DCNL DCSP resource _ obj = make _ resource _ object ( options.resource , options.credentials ) DCNL DCSP num _ errors = 0 DCNL DCSP if options.aggregated : DCNL DCSP DCSP elems = collect _ aggregated ( resource _ obj , resource _ basename , list _ kwargs , name _ filter = re.compile ( options.name ) , before _ str = before _ str ) DCNL DCSP DCSP for ( keyvalue , resource _ instance ) in elems : DCNL DCSP DCSP DCSP ( key , value ) = keyvalue.split ( &apos; / &apos; ) DCNL DCSP DCSP DCSP delete _ kwargs &#91; key &#91; : ( -1 ) &#93; &#93; = value DCNL DCSP DCSP DCSP delete _ kwargs &#91; resource _ id _ key &#93; = resource _ instance &#91; &apos; name &apos; &#93; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP delete ( resource _ obj , resource _ instance , delete _ kwargs , options.dry _ run ) DCNL DCSP DCSP DCSP except IOError as error : DCNL DCSP DCSP DCSP DCSP sys.stderr.write ( ( str ( error ) + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP DCSP num _ errors + = 1 DCNL DCSP else : DCNL DCSP DCSP elems = collect ( resource _ obj , list _ kwargs , name _ filter = re.compile ( options.name ) , before _ str = before _ str ) DCNL DCSP DCSP for resource _ instance in elems : DCNL DCSP DCSP DCSP delete _ kwargs &#91; resource _ id _ key &#93; = resource _ instance &#91; &apos; name &apos; &#93; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP delete ( resource _ obj , resource _ instance , delete _ kwargs , options.dry _ run ) DCNL DCSP DCSP DCSP except IOError as error : DCNL DCSP DCSP DCSP DCSP sys.stderr.write ( ( str ( error ) + &apos; \ n &apos; ) ) DCNL DCSP DCSP DCSP DCSP num _ errors + = 1 DCNL DCSP return ( 0 if ( num _ errors = = 0 ) else ( -1 ) )
DCSP table = FIELDSET ( ) DCNL DCSP for ( id , label , controls , help ) in fields : DCNL DCSP DCSP _ help = DIV ( help , _ class = &apos; w2p _ fc &apos; ) DCNL DCSP DCSP _ controls = DIV ( controls , _ class = &apos; w2p _ fw &apos; ) DCNL DCSP DCSP _ label = DIV ( label , _ class = &apos; w2p _ fl &apos; ) DCNL DCSP DCSP table.append ( DIV ( _ label , _ controls , _ help , _ id = id ) ) DCNL DCSP return table
DCSP with open ( &apos; .. / show _ version.txt &apos; ) as show _ ver _ file : DCNL DCSP DCSP show _ ver = show _ ver _ file.read ( ) DCNL DCSP print obtain _ uptime ( show _ ver )
DCSP ( min _ len , max _ len ) = _ is _ num _ param ( ( &apos; min &apos; , &apos; max &apos; ) , ( min , max ) ) DCNL DCSP if isinstance ( value , string _ type ) : DCNL DCSP DCSP raise VdtTypeError ( value ) DCNL DCSP try : DCNL DCSP DCSP num _ members = len ( value ) DCNL DCSP except TypeError : DCNL DCSP DCSP raise VdtTypeError ( value ) DCNL DCSP if ( ( min _ len is not None ) and ( num _ members &lt; min _ len ) ) : DCNL DCSP DCSP raise VdtValueTooShortError ( value ) DCNL DCSP if ( ( max _ len is not None ) and ( num _ members &gt; max _ len ) ) : DCNL DCSP DCSP raise VdtValueTooLongError ( value ) DCNL DCSP return list ( value )
DCSP t1 = Time ( ( -100000.123456 ) , format = &apos; jd &apos; , scale = &apos; tt &apos; ) DCNL DCSP assert ( np.round ( t1.jd1 ) = = t1.jd1 ) DCNL DCSP t1 _ tai = t1.tai DCNL DCSP assert ( np.round ( t1 _ tai.jd1 ) = = t1 _ tai.jd1 )
DCSP return ( &apos; splunk _ search &apos; if ( &apos; splunk _ search.get &apos; in _ _ salt _ _ ) else False )
DCSP def wrapper ( self , * arg , * * kw ) : DCNL DCSP DCSP defaults = { } DCNL DCSP DCSP if arg : DCNL DCSP DCSP DCSP view = arg &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP view = kw.get ( &apos; view &apos; ) DCNL DCSP DCSP view = self.maybe _ dotted ( view ) DCNL DCSP DCSP if inspect.isclass ( view ) : DCNL DCSP DCSP DCSP defaults = getattr ( view , &apos; _ _ view _ defaults _ _ &apos; , { } ) .copy ( ) DCNL DCSP DCSP if ( &apos; _ backframes &apos; not in kw ) : DCNL DCSP DCSP DCSP kw &#91; &apos; _ backframes &apos; &#93; = 1 DCNL DCSP DCSP defaults.update ( kw ) DCNL DCSP DCSP return wrapped ( self , * arg , * * defaults ) DCNL DCSP return functools.wraps ( wrapped ) ( wrapper )
DCSP L = list ( tup ) DCNL DCSP L &#91; loc &#93; = val DCNL DCSP return tuple ( L )
DCSP try : DCNL DCSP DCSP ts = email.utils.parsedate _ tz ( ims ) DCNL DCSP DCSP return ( ( time.mktime ( ( ts &#91; : 8 &#93; + ( 0 , ) ) ) - ( ts &#91; 9 &#93; or 0 ) ) - time.timezone ) DCNL DCSP except ( TypeError , ValueError , IndexError , OverflowError ) : DCNL DCSP DCSP return None
DCSP vnames = ( &apos; PendingFileRenameOperations &apos; , &apos; PendingFileRenameOperations2 &apos; ) DCNL DCSP key = &apos; SYSTEM \ \ CurrentControlSet \ \ Control \ \ Session DCSP Manager &apos; DCNL DCSP for vname in vnames : DCNL DCSP DCSP reg _ ret = _ _ salt _ _ &#91; &apos; reg.read _ value &apos; &#93; ( &apos; HKLM &apos; , key , vname ) DCNL DCSP DCSP if reg _ ret &#91; &apos; success &apos; &#93; : DCNL DCSP DCSP DCSP log.debug ( &apos; Found DCSP key : DCSP % s &apos; , key ) DCNL DCSP DCSP DCSP if ( reg _ ret &#91; &apos; vdata &apos; &#93; and ( reg _ ret &#91; &apos; vdata &apos; &#93; ! = &apos; ( value DCSP not DCSP set ) &apos; ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP log.debug ( &apos; Unable DCSP to DCSP access DCSP key : DCSP % s &apos; , key ) DCNL DCSP return False
DCSP root = container.parse _ xhtml ( raw ) DCNL DCSP return serialize ( root , u &apos;text / html &apos; )
DCSP Xmu = ( X - mux ) DCNL DCSP Ymu = ( Y - muy ) DCNL DCSP rho = ( sigmaxy / ( sigmax * sigmay ) ) DCNL DCSP z = ( ( ( ( Xmu * * 2 ) / ( sigmax * * 2 ) ) + ( ( Ymu * * 2 ) / ( sigmay * * 2 ) ) ) - ( ( ( ( 2 * rho ) * Xmu ) * Ymu ) / ( sigmax * sigmay ) ) ) DCNL DCSP denom = ( ( ( ( 2 * np.pi ) * sigmax ) * sigmay ) * np.sqrt ( ( 1 - ( rho * * 2 ) ) ) ) DCNL DCSP return ( np.exp ( ( ( - z ) / ( 2 * ( 1 - ( rho * * 2 ) ) ) ) ) / denom )
DCSP ( header _ title , path1 , path2 ) = ( u &apos; \ u7f16 \ u8f91IDC &apos; , u &apos; \ u8d44 \ u4ea7 \ u7ba1 \ u7406 &apos; , u &apos; \ u7f16 \ u8f91IDC &apos; ) DCNL DCSP idc _ id = request.GET.get ( &apos; id &apos; , &apos; &apos; ) DCNL DCSP idc = get _ object ( IDC , id = idc _ id ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP idc _ form = IdcForm ( request.POST , instance = idc ) DCNL DCSP DCSP if idc _ form.is _ valid ( ) : DCNL DCSP DCSP DCSP idc _ form.save ( ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; idc _ list &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP idc _ form = IdcForm ( instance = idc ) DCNL DCSP DCSP return my _ render ( &apos; jasset / idc _ edit.html &apos; , locals ( ) , request )
DCSP if is _ regex : DCNL DCSP DCSP if isinstance ( pattern , str ) : DCNL DCSP DCSP DCSP return re.compile ( pattern ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return pattern DCNL DCSP if pattern : DCNL DCSP DCSP pattern _ re = glob _ to _ re ( pattern ) DCNL DCSP else : DCNL DCSP DCSP pattern _ re = &apos; &apos; DCNL DCSP if ( prefix is not None ) : DCNL DCSP DCSP empty _ pattern = glob _ to _ re ( &apos; &apos; ) DCNL DCSP DCSP prefix _ re = glob _ to _ re ( prefix ) &#91; : ( - len ( empty _ pattern ) ) &#93; DCNL DCSP DCSP sep = os.sep DCNL DCSP DCSP if ( os.sep = = &apos; \ \ &apos; ) : DCNL DCSP DCSP DCSP sep = &apos; \ \ \ \ &apos; DCNL DCSP DCSP pattern _ re = ( &apos; ^ &apos; + sep.join ( ( prefix _ re , ( &apos; . * &apos; + pattern _ re ) ) ) ) DCNL DCSP elif anchor : DCNL DCSP DCSP pattern _ re = ( &apos; ^ &apos; + pattern _ re ) DCNL DCSP return re.compile ( pattern _ re )
DCSP ( map _ data , map _ header , map _ comments ) = parse _ mapping _ file ( mapping _ f ) DCNL DCSP valid _ states = parse _ metadata _ state _ descriptions ( valid _ states _ str ) DCNL DCSP sample _ ids = get _ sample _ ids ( map _ data , map _ header , valid _ states ) DCNL DCSP if ( len ( sample _ ids ) &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; All DCSP samples DCSP have DCSP been DCSP filtered DCSP out DCSP for DCSP the DCSP criteria DCSP described DCSP in DCSP the DCSP valid DCSP states &apos; ) DCNL DCSP return sample _ ids
DCSP if isinstance ( s , unicode ) : DCNL DCSP DCSP for ( char , repl ) in URL _ CHARACTERS.items ( ) : DCNL DCSP DCSP DCSP s = s.replace ( char , repl ) DCNL DCSP DCSP s = s.encode ( &apos; utf8 &apos; , &apos; ignore &apos; ) DCNL DCSP return urllib.quote ( s )
DCSP def splitter ( x ) : DCNL DCSP DCSP if ( not x ) : DCNL DCSP DCSP DCSP return x DCNL DCSP DCSP x = x.strip ( ) DCNL DCSP DCSP if ( not x ) : DCNL DCSP DCSP DCSP return x DCNL DCSP DCSP if ( lstrip is not None ) : DCNL DCSP DCSP DCSP x = x.lstrip ( lstrip ) .lstrip ( ) DCNL DCSP DCSP lx = x.split ( sep ) DCNL DCSP DCSP lx &#91; : &#93; = filter ( None , &#91; j.strip ( ) for j in lx &#93; ) DCNL DCSP DCSP if comments : DCNL DCSP DCSP DCSP lx &#91; : &#93; = &#91; j.replace ( origNotesSep , newNotesSep , 1 ) for j in lx &#93; DCNL DCSP DCSP if strip : DCNL DCSP DCSP DCSP lx &#91; : &#93; = &#91; j.strip ( strip ) for j in lx &#93; DCNL DCSP DCSP return lx DCNL DCSP return splitter
DCSP ( raw , events , picks ) = _ get _ data ( ) DCNL DCSP epochs = Epochs ( raw , events , event _ id , tmin , tmax , picks = picks , preload = True , baseline = None , verbose = False ) DCNL DCSP X = epochs . _ data DCNL DCSP y = epochs.events &#91; : , ( -1 ) &#93; DCNL DCSP xdt = _ XdawnTransformer ( ) DCNL DCSP xdt.fit ( X , y ) DCNL DCSP assert _ raises ( ValueError , xdt.fit , X , y &#91; 1 : &#93; ) DCNL DCSP assert _ raises ( ValueError , xdt.fit , &apos; foo &apos; ) DCNL DCSP signal _ cov = compute _ raw _ covariance ( raw , picks = picks ) DCNL DCSP xdt = _ XdawnTransformer ( signal _ cov = signal _ cov ) DCNL DCSP xdt.fit ( X , y ) DCNL DCSP signal _ cov = np.eye ( len ( picks ) ) DCNL DCSP xdt = _ XdawnTransformer ( signal _ cov = signal _ cov ) DCNL DCSP xdt.fit ( X , y ) DCNL DCSP signal _ cov = np.eye ( ( len ( picks ) - 1 ) ) DCNL DCSP xdt = _ XdawnTransformer ( signal _ cov = signal _ cov ) DCNL DCSP assert _ raises ( ValueError , xdt.fit , X , y ) DCNL DCSP signal _ cov = 42 DCNL DCSP xdt = _ XdawnTransformer ( signal _ cov = signal _ cov ) DCNL DCSP assert _ raises ( ValueError , xdt.fit , X , y ) DCNL DCSP xdt = _ XdawnTransformer ( ) DCNL DCSP xdt.fit ( X ) DCNL DCSP xd = Xdawn ( correct _ overlap = False ) DCNL DCSP xd.fit ( epochs ) DCNL DCSP xdt = _ XdawnTransformer ( ) DCNL DCSP xdt.fit ( X , y ) DCNL DCSP assert _ array _ almost _ equal ( xd.filters _ &#91; &apos; cond2 &apos; &#93; &#91; : , : 2 &#93; , xdt.filters _ .reshape ( 2 , 2 , 8 ) &#91; 0 &#93; .T ) DCNL DCSP xdt.transform ( X &#91; 1 : , ... &#93; ) DCNL DCSP xdt.transform ( X &#91; : , : , 1 : &#93; ) DCNL DCSP assert _ raises ( ValueError , xdt.transform , X &#91; : , 1 : , : &#93; ) DCNL DCSP Xt = xdt.transform ( X ) DCNL DCSP assert _ raises ( ValueError , xdt.transform , 42 ) DCNL DCSP Xinv = xdt.inverse _ transform ( Xt ) DCNL DCSP assert _ equal ( Xinv.shape , X.shape ) DCNL DCSP xdt.inverse _ transform ( Xt &#91; 1 : , ... &#93; ) DCNL DCSP xdt.inverse _ transform ( Xt &#91; : , : , 1 : &#93; ) DCNL DCSP assert _ raises ( ValueError , xdt.inverse _ transform , Xt &#91; : , 1 : , : &#93; ) DCNL DCSP assert _ raises ( ValueError , xdt.inverse _ transform , 42 )
DCSP index = typ.fields.index ( attr ) DCNL DCSP res = builder.extract _ value ( value , index ) DCNL DCSP return impl _ ret _ borrowed ( context , builder , typ &#91; index &#93; , res )
DCSP if ( ( max _ &lt; = 0 ) or ( min _ &lt; = 0 ) ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP min _ order = int ( floor ( log10 ( min _ ) ) ) DCNL DCSP max _ order = int ( ceil ( log10 ( max _ ) ) ) DCNL DCSP positions = &#91; &#93; DCNL DCSP amplitude = ( max _ order - min _ order ) DCNL DCSP if ( amplitude &lt; = 1 ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP detail = 10.0 DCNL DCSP while ( ( amplitude * detail ) &lt; ( min _ scale * 5 ) ) : DCNL DCSP DCSP detail * = 2 DCNL DCSP while ( ( amplitude * detail ) &gt; ( max _ scale * 3 ) ) : DCNL DCSP DCSP detail / = 2 DCNL DCSP for order in range ( min _ order , ( max _ order + 1 ) ) : DCNL DCSP DCSP for i in range ( int ( detail ) ) : DCNL DCSP DCSP DCSP tick = ( ( ( ( 10 * i ) / detail ) or 1 ) * ( 10 * * order ) ) DCNL DCSP DCSP DCSP tick = round _ to _ scale ( tick , tick ) DCNL DCSP DCSP DCSP if ( ( min _ &lt; = tick &lt; = max _ ) and ( tick not in positions ) ) : DCNL DCSP DCSP DCSP DCSP positions.append ( tick ) DCNL DCSP return positions
DCSP evaluate.setAttributesByArguments ( &#91; &apos; sides &apos; , &apos; radius &apos; &#93; , arguments , elementNode ) DCNL DCSP return getGeometryOutput ( None , elementNode )
DCSP mg.show ( lenmavlist )
DCSP return osp.isfile ( osp.join ( get _ module _ path ( &apos; spyder &apos; ) , osp.pardir ) )
DCSP name = _ make _ profile _ image _ name ( username ) DCNL DCSP return { size : _ get _ profile _ image _ filename ( name , size ) for size in _ PROFILE _ IMAGE _ SIZES }
DCSP def _ operation _ complete ( result ) : DCNL DCSP DCSP return result DCNL DCSP retry = RetryResult ( _ operation _ complete , max _ tries = max _ attempts ) DCNL DCSP return retry ( operation.poll ) ( )
DCSP try : DCNL DCSP DCSP code = int ( code ) DCNL DCSP except ValueError : DCNL DCSP DCSP pass DCNL DCSP raise SystemExit , code
DCSP return isinstance ( value , list )
DCSP if ( seed is not None ) : DCNL DCSP DCSP _ = getCurrentThreadData ( ) .random DCNL DCSP DCSP _ .seed ( seed ) DCNL DCSP DCSP randint = _ .randint DCNL DCSP else : DCNL DCSP DCSP randint = random.randint DCNL DCSP return int ( randint ( start , stop ) )
DCSP chunksize = 4096 DCNL DCSP fsize = os.path.getsize ( filename ) DCNL DCSP if ( ( not size ) or ( size &gt; fsize ) ) : DCNL DCSP DCSP size = fsize DCNL DCSP f = open ( filename , &apos; rb &apos; ) DCNL DCSP try : DCNL DCSP DCSP hash = utils.hash ( method ) DCNL DCSP except ValueError : DCNL DCSP DCSP logging.error ( ( &apos; Unknown DCSP hash DCSP type DCSP % s , DCSP returning DCSP None &apos; % method ) ) DCNL DCSP while ( size &gt; 0 ) : DCNL DCSP DCSP if ( chunksize &gt; size ) : DCNL DCSP DCSP DCSP chunksize = size DCNL DCSP DCSP data = f.read ( chunksize ) DCNL DCSP DCSP if ( len ( data ) = = 0 ) : DCNL DCSP DCSP DCSP logging.debug ( ( &apos; Nothing DCSP left DCSP to DCSP read DCSP but DCSP size = % d &apos; % size ) ) DCNL DCSP DCSP DCSP break DCNL DCSP DCSP hash.update ( data ) DCNL DCSP DCSP size - = len ( data ) DCNL DCSP f.close ( ) DCNL DCSP return hash.hexdigest ( )
DCSP header = &#91; &apos; Feature DCSP ID &apos; , &apos; Test DCSP stat . &apos; , &apos; pval &apos; , &apos; pval _ fdr &apos; , &apos; pval _ bon &apos; , md _ key &#93; DCNL DCSP num _ lines = len ( test _ stats ) DCNL DCSP lines = &#91; &apos; DCTB &apos; .join ( header ) &#93; DCNL DCSP for i in range ( num _ lines ) : DCNL DCSP DCSP tmp = &#91; bt.ids ( axis = &apos; observation &apos; ) &#91; i &#93; , test _ stats &#91; i &#93; , pvals &#91; i &#93; , fdr _ pvals &#91; i &#93; , bon _ pvals &#91; i &#93; &#93; DCNL DCSP DCSP lines.append ( &apos; DCTB &apos; .join ( map ( str , tmp ) ) ) DCNL DCSP nls = _ add _ metadata ( bt , md _ key , lines ) DCNL DCSP return nls
DCSP if unixtime : DCNL DCSP DCSP return str ( datetime.datetime.fromtimestamp ( ( unixtime / 1000 ) ) .strftime ( &apos; % x DCSP % X DCSP % Z &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP return &apos; &apos;
DCSP keys = ( &apos; username &apos; , &apos; realm &apos; , &apos; nonce &apos; , &apos; cnonce &apos; ) DCNL DCSP params _ copy = { } DCNL DCSP for key in keys : DCNL DCSP DCSP params _ copy &#91; key &#93; = params &#91; key &#93; DCNL DCSP params _ copy &#91; &apos; algorithm &apos; &#93; = MD5 _ SESS DCNL DCSP return _ A1 ( params _ copy , password )
DCSP try : DCNL DCSP DCSP from bs4 import BeautifulSoup DCNL DCSP except ImportError : DCNL DCSP DCSP error = u &apos;Missing DCSP dependency DCSP &quot; BeautifulSoup4 &quot; DCSP and DCSP &quot; lxml &quot; DCSP required DCSP to DCSP import DCSP WordPress DCSP XML DCSP files . &apos; DCNL DCSP DCSP sys.exit ( error ) DCNL DCSP with open ( xml , encoding = u &apos;utf-8 &apos; ) as infile : DCNL DCSP DCSP xmlfile = infile.read ( ) DCNL DCSP soup = BeautifulSoup ( xmlfile , u &apos;xml &apos; ) DCNL DCSP items = soup.rss.channel.findAll ( u &apos;item &apos; ) DCNL DCSP return items
DCSP def SetListener ( self , listener ) : DCNL DCSP DCSP if ( listener is None ) : DCNL DCSP DCSP DCSP self . _ listener = message _ listener _ mod.NullMessageListener ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP self . _ listener = listener DCNL DCSP cls . _ SetListener = SetListener
DCSP out = _ lib.eglQueryString ( display , name ) DCNL DCSP if ( not out ) : DCNL DCSP DCSP raise RuntimeError ( ( &apos; Could DCSP not DCSP query DCSP % s &apos; % name ) ) DCNL DCSP return out
DCSP if ( isinstance ( node.op , SparseBlockOuter ) and any ( ( _ owner _ isinstance ( inp , HostFromGpu ) for inp in node.inputs ) ) ) : DCNL DCSP DCSP inputs = _ clear _ host _ from _ gpu ( node.inputs ) DCNL DCSP DCSP return &#91; host _ from _ gpu ( GpuSparseBlockOuter ( ) ( * inputs ) ) &#93; DCNL DCSP elif ( isinstance ( node.op , GpuFromHost ) and _ owner _ isinstance ( node.inputs &#91; 0 &#93; , SparseBlockOuter ) ) : DCNL DCSP DCSP meta _ node = node.inputs &#91; 0 &#93; .owner DCNL DCSP DCSP inputs = _ clear _ host _ from _ gpu ( meta _ node.inputs ) DCNL DCSP DCSP return &#91; GpuSparseBlockOuter ( ) ( * inputs ) &#93;
DCSP try : DCNL DCSP DCSP mod = import _ module ( taglib _ module ) DCNL DCSP except ImportError as e : DCNL DCSP DCSP if is _ library _ missing ( taglib _ module ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise InvalidTemplateLibrary ( ( &apos; ImportError DCSP raised DCSP loading DCSP % s : DCSP % s &apos; % ( taglib _ module , e ) ) ) DCNL DCSP try : DCNL DCSP DCSP return mod.register DCNL DCSP except AttributeError : DCNL DCSP DCSP raise InvalidTemplateLibrary ( ( &quot; Template DCSP library DCSP % s DCSP does DCSP not DCSP have DCSP a DCSP variable DCSP named DCSP &apos; register &apos; &quot; % taglib _ module ) )
DCSP expr = ( lambda obj : ( ( obj.token _ type = = TOKEN _ BLOCK ) and ( len ( obj.split _ contents ( ) ) &gt; 0 ) and ( obj.split _ contents ( ) &#91; 0 &#93; = = &apos; autopaginate &apos; ) ) ) DCNL DCSP multiple _ paginations = ( len ( filter ( expr , parser.tokens ) ) &gt; 0 ) DCNL DCSP split = token.split _ contents ( ) DCNL DCSP as _ index = None DCNL DCSP context _ var = None DCNL DCSP for ( i , bit ) in enumerate ( split ) : DCNL DCSP DCSP if ( bit = = &apos; as &apos; ) : DCNL DCSP DCSP DCSP as _ index = i DCNL DCSP DCSP DCSP break DCNL DCSP if ( as _ index is not None ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP context _ var = split &#91; ( as _ index + 1 ) &#93; DCNL DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP raise template.TemplateSyntaxError ( ( ( &apos; Context DCSP variable DCSP assignment DCSP &apos; + &apos; must DCSP take DCSP the DCSP form DCSP of DCSP { % % DCSP % r DCSP object.example _ set.all DCSP ... DCSP as DCSP &apos; ) + ( &apos; context _ var _ name DCSP % % } &apos; % split &#91; 0 &#93; ) ) ) DCNL DCSP DCSP del split &#91; as _ index : ( as _ index + 2 ) &#93; DCNL DCSP if ( len ( split ) = = 2 ) : DCNL DCSP DCSP return AutoPaginateNode ( split &#91; 1 &#93; , multiple _ paginations = multiple _ paginations ) DCNL DCSP elif ( len ( split ) = = 3 ) : DCNL DCSP DCSP return AutoPaginateNode ( split &#91; 1 &#93; , paginate _ by = split &#91; 2 &#93; , context _ var = context _ var , multiple _ paginations = multiple _ paginations ) DCNL DCSP elif ( len ( split ) = = 4 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP orphans = int ( split &#91; 3 &#93; ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise template.TemplateSyntaxError ( ( u &apos;Got DCSP % s , DCSP but DCSP expected DCSP integer . &apos; % split &#91; 3 &#93; ) ) DCNL DCSP DCSP return AutoPaginateNode ( split &#91; 1 &#93; , paginate _ by = split &#91; 2 &#93; , orphans = orphans , context _ var = context _ var , multiple _ paginations = multiple _ paginations ) DCNL DCSP else : DCNL DCSP DCSP raise template.TemplateSyntaxError ( ( &apos; % r DCSP tag DCSP takes DCSP one DCSP required DCSP &apos; + ( &apos; argument DCSP and DCSP one DCSP optional DCSP argument &apos; % split &#91; 0 &#93; ) ) )
DCSP encoder = codecs.getencoder ( &apos; unicode _ escape &apos; ) DCNL DCSP return encoder ( text ) &#91; 0 &#93; .decode ( )
DCSP if ( validator _ type = = &apos; error &apos; ) : DCNL DCSP DCSP from .errors import codes DCNL DCSP DCSP from .errors import EXT DCNL DCSP elif ( validator _ type = = &apos; warning &apos; ) : DCNL DCSP DCSP from .warnings import codes DCNL DCSP DCSP from .warnings import EXT DCNL DCSP else : DCNL DCSP DCSP pass DCNL DCSP def decorator ( func ) : DCNL DCSP DCSP def wrapper ( * args , * * kw ) : DCNL DCSP DCSP DCSP extra = func ( * args , * * kw ) DCNL DCSP DCSP DCSP if ( extra is None ) : DCNL DCSP DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP DCSP if isinstance ( code _ or _ name , string _ types ) : DCNL DCSP DCSP DCSP DCSP code = EXT DCNL DCSP DCSP DCSP DCSP name = ( ( codes &#91; code &#93; &#91; 0 &#93; + &apos; : &apos; ) + code _ or _ name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP code = code _ or _ name DCNL DCSP DCSP DCSP DCSP name = codes &#91; code &#93; &#91; 0 &#93; DCNL DCSP DCSP DCSP text = codes &#91; code &#93; &#91; 1 &#93; DCNL DCSP DCSP DCSP return &#91; ( code , name , text , extra ) &#93; DCNL DCSP DCSP wrapper.validator _ type = validator _ type DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP if ( t &lt; 0.0 ) : DCNL DCSP DCSP return a DCNL DCSP if ( t &gt; 1.0 ) : DCNL DCSP DCSP return b DCNL DCSP return ( a + ( ( b - a ) * t ) )
DCSP conf = global _ conf.copy ( ) DCNL DCSP conf.update ( local _ conf ) DCNL DCSP def auth _ filter ( app ) : DCNL DCSP DCSP return KeystoneAuth ( app , conf ) DCNL DCSP return auth _ filter
DCSP from _ _ main _ _ import _ _ dict _ _ as namespace DCNL DCSP shell = namespace.get ( &apos; _ _ ipythonshell _ _ &apos; ) DCNL DCSP if ( ( shell is not None ) and hasattr ( shell , &apos; user _ ns &apos; ) ) : DCNL DCSP DCSP return shell.user _ ns DCNL DCSP else : DCNL DCSP DCSP return namespace DCNL DCSP return namespace
DCSP if ( ( len ( individual ) &lt; 3 ) or ( individual.height &lt; = 1 ) ) : DCNL DCSP DCSP return ( individual , ) DCNL DCSP iprims = &#91; &#93; DCNL DCSP for ( i , node ) in enumerate ( individual &#91; 1 : &#93; , 1 ) : DCNL DCSP DCSP if ( isinstance ( node , Primitive ) and ( node.ret in node.args ) ) : DCNL DCSP DCSP DCSP iprims.append ( ( i , node ) ) DCNL DCSP if ( len ( iprims ) ! = 0 ) : DCNL DCSP DCSP ( index , prim ) = random.choice ( iprims ) DCNL DCSP DCSP arg _ idx = random.choice ( &#91; i for ( i , type _ ) in enumerate ( prim.args ) if ( type _ = = prim.ret ) &#93; ) DCNL DCSP DCSP rindex = ( index + 1 ) DCNL DCSP DCSP for _ in range ( ( arg _ idx + 1 ) ) : DCNL DCSP DCSP DCSP rslice = individual.searchSubtree ( rindex ) DCNL DCSP DCSP DCSP subtree = individual &#91; rslice &#93; DCNL DCSP DCSP DCSP rindex + = len ( subtree ) DCNL DCSP DCSP slice _ = individual.searchSubtree ( index ) DCNL DCSP DCSP individual &#91; slice _ &#93; = subtree DCNL DCSP return ( individual , )
DCSP if ( extra _ context is not _ sentinel ) : DCNL DCSP DCSP warnings.warn ( &apos; The DCSP unused DCSP `extra _ context` DCSP parameter DCSP to DCSP `logout _ then _ login` DCSP is DCSP deprecated . &apos; , RemovedInDjango21Warning ) DCNL DCSP if ( not login _ url ) : DCNL DCSP DCSP login _ url = settings.LOGIN _ URL DCNL DCSP login _ url = resolve _ url ( login _ url ) DCNL DCSP return LogoutView.as _ view ( next _ page = login _ url ) ( request )
DCSP result = { } DCNL DCSP pk _ value = primary _ key _ value ( instance ) DCNL DCSP self _ link = url _ for ( model , pk _ value , relation , relationship = True ) DCNL DCSP related _ link = url _ for ( model , pk _ value , relation ) DCNL DCSP result &#91; &apos; links &apos; &#93; = { &apos; self &apos; : self _ link } DCNL DCSP try : DCNL DCSP DCSP related _ model = get _ related _ model ( model , relation ) DCNL DCSP DCSP url _ for ( related _ model ) DCNL DCSP except ValueError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP result &#91; &apos; links &apos; &#93; &#91; &apos; related &apos; &#93; = related _ link DCNL DCSP related _ value = getattr ( instance , relation ) DCNL DCSP if is _ like _ list ( instance , relation ) : DCNL DCSP DCSP result &#91; &apos; data &apos; &#93; = list ( map ( simple _ relationship _ dump , related _ value ) ) DCNL DCSP elif ( related _ value is not None ) : DCNL DCSP DCSP result &#91; &apos; data &apos; &#93; = simple _ relationship _ dump ( related _ value ) DCNL DCSP else : DCNL DCSP DCSP result &#91; &apos; data &apos; &#93; = None DCNL DCSP return result
DCSP try : DCNL DCSP DCSP username = params.get ( &apos; username &apos; ) DCNL DCSP DCSP user = User.objects.get ( username = username ) DCNL DCSP except User.DoesNotExist : DCNL DCSP DCSP msg = _ ( &apos; User DCSP { username } DCSP does DCSP not DCSP exist &apos; ) .format ( username = username ) DCNL DCSP DCSP return ( None , HttpResponseBadRequest ( msg ) ) DCNL DCSP try : DCNL DCSP DCSP course _ key = CourseKey.from _ string ( params.get ( &apos; course _ key &apos; ) ) DCNL DCSP except InvalidKeyError : DCNL DCSP DCSP msg = _ ( &apos; { course _ key } DCSP is DCSP not DCSP a DCSP valid DCSP course DCSP key &apos; ) .format ( course _ key = params.get ( &apos; course _ key &apos; ) ) DCNL DCSP DCSP return ( None , HttpResponseBadRequest ( msg ) ) DCNL DCSP return ( { &apos; user &apos; : user , &apos; course _ key &apos; : course _ key } , None )
DCSP import numpy as np DCNL DCSP if ( nodelist is None ) : DCNL DCSP DCSP nodelist = list ( G ) DCNL DCSP nodeset = set ( nodelist ) DCNL DCSP if ( len ( nodelist ) ! = len ( nodeset ) ) : DCNL DCSP DCSP msg = &apos; Ambiguous DCSP ordering : DCSP `nodelist` DCSP contained DCSP duplicates . &apos; DCNL DCSP DCSP raise nx.NetworkXError ( msg ) DCNL DCSP nlen = len ( nodelist ) DCNL DCSP undirected = ( not G.is _ directed ( ) ) DCNL DCSP index = dict ( zip ( nodelist , range ( nlen ) ) ) DCNL DCSP if G.is _ multigraph ( ) : DCNL DCSP DCSP M = np.full ( ( nlen , nlen ) , np.nan , order = order ) DCNL DCSP DCSP operator = { sum : np.nansum , min : np.nanmin , max : np.nanmax } DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP op = operator &#91; multigraph _ weight &#93; DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP raise ValueError ( &apos; multigraph _ weight DCSP must DCSP be DCSP sum , DCSP min , DCSP or DCSP max &apos; ) DCNL DCSP DCSP for ( u , v , attrs ) in G.edges ( data = True ) : DCNL DCSP DCSP DCSP if ( ( u in nodeset ) and ( v in nodeset ) ) : DCNL DCSP DCSP DCSP DCSP ( i , j ) = ( index &#91; u &#93; , index &#91; v &#93; ) DCNL DCSP DCSP DCSP DCSP e _ weight = attrs.get ( weight , 1 ) DCNL DCSP DCSP DCSP DCSP M &#91; ( i , j ) &#93; = op ( &#91; e _ weight , M &#91; ( i , j ) &#93; &#93; ) DCNL DCSP DCSP DCSP DCSP if undirected : DCNL DCSP DCSP DCSP DCSP DCSP M &#91; ( j , i ) &#93; = M &#91; ( i , j ) &#93; DCNL DCSP else : DCNL DCSP DCSP M = np.full ( ( nlen , nlen ) , np.nan , order = order ) DCNL DCSP DCSP for ( u , nbrdict ) in G.adjacency ( ) : DCNL DCSP DCSP DCSP for ( v , d ) in nbrdict.items ( ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP M &#91; ( index &#91; u &#93; , index &#91; v &#93; ) &#93; = d.get ( weight , 1 ) DCNL DCSP DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP M &#91; np.isnan ( M ) &#93; = nonedge DCNL DCSP M = np.asmatrix ( M , dtype = dtype ) DCNL DCSP return M
DCSP if ( dtype is None ) : DCNL DCSP DCSP dtype = a.dtype DCNL DCSP return zeros ( a.shape , dtype = dtype )
DCSP logging.info ( &apos; Cleaning DCSP Zone &apos; ) DCNL DCSP Zone.objects.all ( ) .delete ( ) DCNL DCSP logging.info ( &apos; Cleaning DCSP Facility &apos; ) DCNL DCSP Facility.objects.all ( ) .delete ( ) DCNL DCSP logging.info ( &apos; Cleaning DCSP Device &apos; ) DCNL DCSP Device.objects.all ( ) .delete ( )
DCSP if isinstance ( s , binary _ type ) : DCNL DCSP DCSP return s.decode ( encoding , errors ) DCNL DCSP return s
DCSP if ( extra _ context is None ) : DCNL DCSP DCSP extra _ context = { } DCNL DCSP if ( login _ required and ( not request.user.is _ authenticated ( ) ) ) : DCNL DCSP DCSP return redirect _ to _ login ( request.path ) DCNL DCSP obj = lookup _ object ( model , object _ id , slug , slug _ field ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP obj.delete ( ) DCNL DCSP DCSP msg = ( ugettext ( &apos; The DCSP % ( verbose _ name ) s DCSP was DCSP deleted . &apos; ) % { &apos; verbose _ name &apos; : model . _ meta.verbose _ name } ) DCNL DCSP DCSP messages.success ( request , msg , fail _ silently = True ) DCNL DCSP DCSP return HttpResponseRedirect ( post _ delete _ redirect ) DCNL DCSP else : DCNL DCSP DCSP if ( not template _ name ) : DCNL DCSP DCSP DCSP template _ name = ( &apos; % s / % s _ confirm _ delete.html &apos; % ( model . _ meta.app _ label , model . _ meta.object _ name.lower ( ) ) ) DCNL DCSP DCSP t = template _ loader.get _ template ( template _ name ) DCNL DCSP DCSP c = RequestContext ( request , { template _ object _ name : obj } , context _ processors ) DCNL DCSP DCSP apply _ extra _ context ( extra _ context , c ) DCNL DCSP DCSP response = HttpResponse ( t.render ( c ) ) DCNL DCSP DCSP populate _ xheaders ( request , response , model , getattr ( obj , obj . _ meta.pk.attname ) ) DCNL DCSP DCSP return response
DCSP TOPIC _ NAME = ( &apos; subscription _ check _ iam _ permissions- % d &apos; % ( _ millis ( ) , ) ) DCNL DCSP SUB _ NAME = ( &apos; subscription _ check _ iam _ permissions-defaults- % d &apos; % ( _ millis ( ) , ) ) DCNL DCSP topic = client.topic ( TOPIC _ NAME ) DCNL DCSP topic.create ( ) DCNL DCSP to _ delete.append ( topic ) DCNL DCSP subscription = topic.subscription ( SUB _ NAME ) DCNL DCSP subscription.create ( ) DCNL DCSP to _ delete.append ( subscription ) DCNL DCSP from google.cloud.pubsub.iam import OWNER _ ROLE , EDITOR _ ROLE , VIEWER _ ROLE DCNL DCSP TO _ CHECK = &#91; OWNER _ ROLE , EDITOR _ ROLE , VIEWER _ ROLE &#93; DCNL DCSP ALLOWED = subscription.check _ iam _ permissions ( TO _ CHECK ) DCNL DCSP assert ( set ( ALLOWED ) = = set ( TO _ CHECK ) )
DCSP def _ clientfactory ( url , * args , * * kwargs ) : DCNL DCSP DCSP url = to _ unicode ( url ) DCNL DCSP DCSP timeout = kwargs.pop ( &apos; timeout &apos; , 0 ) DCNL DCSP DCSP f = client.ScrapyHTTPClientFactory ( Request ( url , * args , * * kwargs ) , timeout = timeout ) DCNL DCSP DCSP f.deferred.addCallback ( ( response _ transform or ( lambda r : r.body ) ) ) DCNL DCSP DCSP return f DCNL DCSP from twisted.web.client import _ makeGetterFactory DCNL DCSP return _ makeGetterFactory ( to _ bytes ( url ) , _ clientfactory , contextFactory = contextFactory , * args , * * kwargs ) .deferred
DCSP data = { ATTR _ ENTITY _ ID : entity _ id , ATTR _ VALUE : value } DCNL DCSP hass.services.call ( DOMAIN , SERVICE _ SET _ VAR _ VALUE , data )
DCSP ret = &#91; &#93; DCNL DCSP interfaces = &#91; &#93; DCNL DCSP expanded _ config = { } DCNL DCSP global LAST _ STATS DCNL DCSP coalesce = False DCNL DCSP _ stats = _ copy _ interfaces _ info ( IP.by _ name ) DCNL DCSP if ( not LAST _ STATS ) : DCNL DCSP DCSP LAST _ STATS = _ stats DCNL DCSP if ( ( &apos; coalesce &apos; in config ) and config &#91; &apos; coalesce &apos; &#93; ) : DCNL DCSP DCSP coalesce = True DCNL DCSP DCSP changes = { } DCNL DCSP for item in config : DCNL DCSP DCSP if ( item = = &apos; coalesce &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( item in _ stats ) : DCNL DCSP DCSP DCSP interfaces.append ( item ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP interface _ regexp = item.replace ( &apos; * &apos; , &apos; &#91; 0-9 &#93; + &apos; ) DCNL DCSP DCSP DCSP for interface in _ stats : DCNL DCSP DCSP DCSP DCSP match = re.search ( interface _ regexp , interface ) DCNL DCSP DCSP DCSP DCSP if match : DCNL DCSP DCSP DCSP DCSP DCSP interfaces.append ( match.group ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP expanded _ config &#91; match.group ( ) &#93; = config &#91; item &#93; DCNL DCSP if expanded _ config : DCNL DCSP DCSP config.update ( expanded _ config ) DCNL DCSP for interface in interfaces : DCNL DCSP DCSP _ send _ event = False DCNL DCSP DCSP _ diff _ stats = ( _ stats &#91; interface &#93; - LAST _ STATS &#91; interface &#93; ) DCNL DCSP DCSP _ ret _ diff = { } DCNL DCSP DCSP if _ diff _ stats : DCNL DCSP DCSP DCSP _ diff _ stats _ dict = { } DCNL DCSP DCSP DCSP LAST _ STATS &#91; interface &#93; = _ stats &#91; interface &#93; DCNL DCSP DCSP DCSP for item in _ diff _ stats : DCNL DCSP DCSP DCSP DCSP _ diff _ stats _ dict.update ( item ) DCNL DCSP DCSP DCSP for attr in config &#91; interface &#93; : DCNL DCSP DCSP DCSP DCSP if ( attr in _ diff _ stats _ dict ) : DCNL DCSP DCSP DCSP DCSP DCSP config _ value = None DCNL DCSP DCSP DCSP DCSP DCSP if ( config &#91; interface &#93; &#91; attr &#93; and ( &apos; onvalue &apos; in config &#91; interface &#93; &#91; attr &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP config _ value = config &#91; interface &#93; &#91; attr &#93; &#91; &apos; onvalue &apos; &#93; DCNL DCSP DCSP DCSP DCSP DCSP new _ value = ast.literal _ eval ( _ diff _ stats _ dict &#91; attr &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( not config _ value ) or ( config _ value = = new _ value ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP _ send _ event = True DCNL DCSP DCSP DCSP DCSP DCSP DCSP _ ret _ diff &#91; attr &#93; = new _ value DCNL DCSP DCSP DCSP if _ send _ event : DCNL DCSP DCSP DCSP DCSP if coalesce : DCNL DCSP DCSP DCSP DCSP DCSP changes &#91; interface &#93; = _ ret _ diff DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP ret.append ( { &apos; tag &apos; : interface , &apos; interface &apos; : interface , &apos; change &apos; : _ ret _ diff } ) DCNL DCSP if ( coalesce and changes ) : DCNL DCSP DCSP grains _ info = salt.loader.grains ( _ _ opts _ _ , True ) DCNL DCSP DCSP _ _ grains _ _ .update ( grains _ info ) DCNL DCSP DCSP ret.append ( { &apos; tag &apos; : &apos; result &apos; , &apos; changes &apos; : changes } ) DCNL DCSP return ret
DCSP from pybrain.tools.plotting.colormaps import ColorMap DCNL DCSP import pylab DCNL DCSP n = 50 DCNL DCSP ps = &#91; ( 10 , 0.1 ) , ( 10 , ) , ( 50 , ) , ( 50 , 0.5 ) &#93; DCNL DCSP ms = &#91; &#93; DCNL DCSP for p in ps : DCNL DCSP DCSP if ( len ( p ) &gt; 1 ) : DCNL DCSP DCSP DCSP m = generateIBP ( n , p &#91; 0 &#93; , p &#91; 1 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP m = generateIBP ( n , p &#91; 0 &#93; ) DCNL DCSP DCSP ms.append ( leftordered ( m ) ) DCNL DCSP for m in ms : DCNL DCSP DCSP ColorMap ( m , pixelspervalue = 3 ) DCNL DCSP pylab.show ( )
DCSP self = { } DCNL DCSP epoch = 0 DCNL DCSP counter = 0 DCNL DCSP out _ labels = &#91; &apos; g _ loss &apos; , &apos; d _ loss &apos; , &apos; d _ loss _ fake &apos; , &apos; d _ loss _ legit &apos; , &apos; time &apos; &#93; DCNL DCSP callback _ metrics = ( out _ labels + &#91; ( &apos; val _ &apos; + n ) for n in out _ labels &#93; ) DCNL DCSP history = cbks.History ( ) DCNL DCSP callbacks = ( ( &#91; cbks.BaseLogger ( ) &#93; + callbacks ) + &#91; history &#93; ) DCNL DCSP if verbose : DCNL DCSP DCSP callbacks + = &#91; cbks.ProgbarLogger ( ) &#93; DCNL DCSP callbacks = cbks.CallbackList ( callbacks ) DCNL DCSP callbacks . _ set _ params ( { &apos; nb _ epoch &apos; : nb _ epoch , &apos; nb _ sample &apos; : samples _ per _ epoch , &apos; verbose &apos; : verbose , &apos; metrics &apos; : callback _ metrics } ) DCNL DCSP callbacks.on _ train _ begin ( ) DCNL DCSP while ( epoch &lt; nb _ epoch ) : DCNL DCSP DCSP callbacks.on _ epoch _ begin ( epoch ) DCNL DCSP DCSP samples _ seen = 0 DCNL DCSP DCSP batch _ index = 0 DCNL DCSP DCSP while ( samples _ seen &lt; samples _ per _ epoch ) : DCNL DCSP DCSP DCSP ( z , x ) = next ( generator ) DCNL DCSP DCSP DCSP batch _ logs = { } DCNL DCSP DCSP DCSP if ( type ( x ) is list ) : DCNL DCSP DCSP DCSP DCSP batch _ size = len ( x &#91; 0 &#93; ) DCNL DCSP DCSP DCSP elif ( type ( x ) is dict ) : DCNL DCSP DCSP DCSP DCSP batch _ size = len ( list ( x.values ( ) ) &#91; 0 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP batch _ size = len ( x ) DCNL DCSP DCSP DCSP batch _ logs &#91; &apos; batch &apos; &#93; = batch _ index DCNL DCSP DCSP DCSP batch _ logs &#91; &apos; size &apos; &#93; = batch _ size DCNL DCSP DCSP DCSP callbacks.on _ batch _ begin ( batch _ index , batch _ logs ) DCNL DCSP DCSP DCSP t1 = time.time ( ) DCNL DCSP DCSP DCSP d _ losses = d _ train ( x , z , counter ) DCNL DCSP DCSP DCSP ( z , x ) = next ( generator ) DCNL DCSP DCSP DCSP ( g _ loss , samples , xs ) = g _ train ( x , z , counter ) DCNL DCSP DCSP DCSP outs = ( ( ( g _ loss , ) + d _ losses ) + ( ( time.time ( ) - t1 ) , ) ) DCNL DCSP DCSP DCSP counter + = 1 DCNL DCSP DCSP DCSP if ( ( batch _ index % 100 ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP join _ image = np.zeros _ like ( np.concatenate ( &#91; samples &#91; : 64 &#93; , xs &#91; : 64 &#93; &#93; , axis = 0 ) ) DCNL DCSP DCSP DCSP DCSP for ( j , ( i1 , i2 ) ) in enumerate ( zip ( samples &#91; : 64 &#93; , xs &#91; : 64 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP join _ image &#91; ( j * 2 ) &#93; = i1 DCNL DCSP DCSP DCSP DCSP DCSP join _ image &#91; ( ( j * 2 ) + 1 ) &#93; = i2 DCNL DCSP DCSP DCSP DCSP save _ images ( join _ image , &#91; ( 8 * 2 ) , 8 &#93; , ( &apos; . / outputs / samples _ % s / train _ % s _ % s.png &apos; % ( name , epoch , batch _ index ) ) ) DCNL DCSP DCSP DCSP DCSP ( samples , xs ) = sampler ( z , x ) DCNL DCSP DCSP DCSP DCSP join _ image = np.zeros _ like ( np.concatenate ( &#91; samples &#91; : 64 &#93; , xs &#91; : 64 &#93; &#93; , axis = 0 ) ) DCNL DCSP DCSP DCSP DCSP for ( j , ( i1 , i2 ) ) in enumerate ( zip ( samples &#91; : 64 &#93; , xs &#91; : 64 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP join _ image &#91; ( j * 2 ) &#93; = i1 DCNL DCSP DCSP DCSP DCSP DCSP join _ image &#91; ( ( j * 2 ) + 1 ) &#93; = i2 DCNL DCSP DCSP DCSP DCSP save _ images ( join _ image , &#91; ( 8 * 2 ) , 8 &#93; , ( &apos; . / outputs / samples _ % s / test _ % s _ % s.png &apos; % ( name , epoch , batch _ index ) ) ) DCNL DCSP DCSP DCSP for ( l , o ) in zip ( out _ labels , outs ) : DCNL DCSP DCSP DCSP DCSP batch _ logs &#91; l &#93; = o DCNL DCSP DCSP DCSP callbacks.on _ batch _ end ( batch _ index , batch _ logs ) DCNL DCSP DCSP DCSP epoch _ logs = { } DCNL DCSP DCSP DCSP batch _ index + = 1 DCNL DCSP DCSP DCSP samples _ seen + = batch _ size DCNL DCSP DCSP if ( saver is not None ) : DCNL DCSP DCSP DCSP saver ( epoch ) DCNL DCSP DCSP callbacks.on _ epoch _ end ( epoch , epoch _ logs ) DCNL DCSP DCSP epoch + = 1 DCNL DCSP callbacks.on _ train _ end ( )
DCSP ( topic _ tree , exercises , assessment _ items , contents ) = retrieve _ API _ data ( channel = channel ) DCNL DCSP exercise _ lookup = dict ( ( ( exercise &#91; &apos; id &apos; &#93; , exercise ) for exercise in exercises ) ) DCNL DCSP content _ lookup = dict ( ( ( content &#91; &apos; id &apos; &#93; , content ) for content in contents ) ) DCNL DCSP def recurse _ nodes ( node , path = &apos; &apos; ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Internal DCSP function DCSP for DCSP recursing DCSP over DCSP the DCSP topic DCSP tree , DCSP marking DCSP relevant DCSP metadata , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP and DCSP removing DCSP undesired DCSP attributes DCSP and DCSP children . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP kind = node &#91; &apos; kind &apos; &#93; DCNL DCSP DCSP node = whitewash _ node _ data ( node , path ) DCNL DCSP DCSP if ( kind ! = &apos; Topic &apos; ) : DCNL DCSP DCSP DCSP if ( kind in channel _ data &#91; &apos; denormed _ attribute _ list &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP for key in node.keys ( ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( key not in channel _ data &#91; &apos; denormed _ attribute _ list &apos; &#93; &#91; kind &#93; ) or ( not node.get ( key , &apos; &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP del node &#91; key &#93; DCNL DCSP DCSP if ( &apos; child _ data &apos; in node ) : DCNL DCSP DCSP DCSP children _ to _ delete = &#91; &#93; DCNL DCSP DCSP DCSP child _ kinds = set ( ) DCNL DCSP DCSP DCSP for ( i , child ) in enumerate ( node.get ( &apos; children &apos; , &#91; &#93; ) ) : DCNL DCSP DCSP DCSP DCSP child _ kind = child.get ( &apos; kind &apos; ) DCNL DCSP DCSP DCSP DCSP if ( ( child _ kind = = &apos; Video &apos; ) or ( child _ kind = = &apos; Exercise &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP for i in reversed ( children _ to _ delete ) : DCNL DCSP DCSP DCSP DCSP del node &#91; &apos; children &apos; &#93; &#91; i &#93; DCNL DCSP DCSP for child _ datum in node.get ( &apos; child _ data &apos; , &#91; &#93; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP child _ id = str ( child _ datum &#91; &apos; id &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP child _ kind = child _ datum &#91; &apos; kind &apos; &#93; DCNL DCSP DCSP DCSP DCSP slug _ key = channel _ data &#91; &apos; slug _ key &apos; &#93; &#91; child _ kind &#93; DCNL DCSP DCSP DCSP DCSP if ( child _ kind = = &apos; Exercise &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP child _ denormed _ data = exercise _ lookup &#91; child _ id &#93; DCNL DCSP DCSP DCSP DCSP DCSP slug = ( exercise _ lookup &#91; child _ id &#93; &#91; slug _ key &#93; if ( exercise _ lookup &#91; child _ id &#93; &#91; slug _ key &#93; ! = &apos; root &apos; ) else &apos; khan &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP slug = slugify ( unicode ( slug ) ) DCNL DCSP DCSP DCSP DCSP DCSP exercise _ lookup &#91; child _ id &#93; &#91; &apos; path &apos; &#93; = ( ( node &#91; &apos; path &apos; &#93; + slug ) + &apos; / &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( child _ kind = = &apos; Video &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP child _ denormed _ data = content _ lookup &#91; child _ id &#93; DCNL DCSP DCSP DCSP DCSP DCSP slug = ( content _ lookup &#91; child _ id &#93; &#91; slug _ key &#93; if ( content _ lookup &#91; child _ id &#93; &#91; slug _ key &#93; ! = &apos; root &apos; ) else &apos; khan &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP slug = slugify ( unicode ( slug ) ) DCNL DCSP DCSP DCSP DCSP DCSP content _ lookup &#91; child _ id &#93; &#91; &apos; path &apos; &#93; = ( ( node &#91; &apos; path &apos; &#93; + slug ) + &apos; / &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP child _ denormed _ data = None DCNL DCSP DCSP DCSP DCSP if child _ denormed _ data : DCNL DCSP DCSP DCSP DCSP DCSP node &#91; &apos; children &apos; &#93; .append ( copy.deepcopy ( dict ( child _ denormed _ data ) ) ) DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP logging.warn ( ( &apos; % ( kind ) s DCSP % ( id ) s DCSP does DCSP not DCSP exist DCSP in DCSP lookup DCSP table &apos; % child _ datum ) ) DCNL DCSP DCSP children _ to _ delete = &#91; &#93; DCNL DCSP DCSP child _ kinds = set ( ) DCNL DCSP DCSP for ( i , child ) in enumerate ( node.get ( &apos; children &apos; , &#91; &#93; ) ) : DCNL DCSP DCSP DCSP child _ kind = child.get ( &apos; kind &apos; ) DCNL DCSP DCSP DCSP if ( child _ kind in channel _ data &#91; &apos; kind _ blacklist &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( child &#91; channel _ data &#91; &apos; slug _ key &apos; &#93; &#91; child _ kind &#93; &#93; in channel _ data &#91; &apos; slug _ blacklist &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( not child.get ( &apos; live &apos; , True ) ) : DCNL DCSP DCSP DCSP DCSP logging.debug ( ( &apos; Removing DCSP non-live DCSP child : DCSP % s &apos; % child &#91; channel _ data &#91; &apos; slug _ key &apos; &#93; &#91; child _ kind &#93; &#93; ) ) DCNL DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif child.get ( &apos; hide &apos; , False ) : DCNL DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP DCSP logging.debug ( ( &apos; Removing DCSP hidden DCSP child : DCSP % s &apos; % child &#91; channel _ data &#91; &apos; slug _ key &apos; &#93; &#91; child _ kind &#93; &#93; ) ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( ( child _ kind = = &apos; Video &apos; ) and ( set ( &#91; &apos; mp4 &apos; , &apos; png &apos; &#93; ) - set ( child.get ( &apos; download _ urls &apos; , { } ) .keys ( ) ) ) ) : DCNL DCSP DCSP DCSP DCSP logging.warn ( ( &apos; No DCSP download DCSP link DCSP for DCSP video : DCSP % s \ n &apos; % child.get ( &apos; youtube _ id &apos; , child.get ( &apos; id &apos; , &apos; &apos; ) ) ) ) DCNL DCSP DCSP DCSP DCSP if channel _ data.get ( &apos; require _ download _ link &apos; , False ) : DCNL DCSP DCSP DCSP DCSP DCSP children _ to _ delete.append ( i ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP child _ kinds = child _ kinds.union ( set ( &#91; child _ kind &#93; ) ) DCNL DCSP DCSP DCSP child _ kinds = child _ kinds.union ( recurse _ nodes ( child , path = node &#91; &apos; path &apos; &#93; ) ) DCNL DCSP DCSP for i in reversed ( children _ to _ delete ) : DCNL DCSP DCSP DCSP del node &#91; &apos; children &apos; &#93; &#91; i &#93; DCNL DCSP DCSP if ( kind = = &apos; Topic &apos; ) : DCNL DCSP DCSP DCSP node &#91; &apos; contains &apos; &#93; = list ( child _ kinds ) DCNL DCSP DCSP return child _ kinds DCNL DCSP recurse _ nodes ( topic _ tree ) DCNL DCSP dedupe _ paths ( topic _ tree ) DCNL DCSP def recurse _ nodes _ to _ remove _ childless _ nodes ( node ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Remove DCSP dead-end DCSP topics . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP children _ to _ delete = &#91; &#93; DCNL DCSP DCSP for ( ci , child ) in enumerate ( node.get ( &apos; children &apos; , &#91; &#93; ) ) : DCNL DCSP DCSP DCSP if ( child &#91; &apos; kind &apos; &#93; ! = &apos; Topic &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP recurse _ nodes _ to _ remove _ childless _ nodes ( child ) DCNL DCSP DCSP DCSP if ( not child.get ( &apos; children &apos; ) ) : DCNL DCSP DCSP DCSP DCSP children _ to _ delete.append ( ci ) DCNL DCSP DCSP DCSP DCSP logging.warn ( ( &apos; Removing DCSP childless DCSP topic : DCSP % s &apos; % child &#91; &apos; slug &apos; &#93; ) ) DCNL DCSP DCSP for ci in reversed ( children _ to _ delete ) : DCNL DCSP DCSP DCSP del node &#91; &apos; children &apos; &#93; &#91; ci &#93; DCNL DCSP recurse _ nodes _ to _ remove _ childless _ nodes ( topic _ tree ) DCNL DCSP return ( topic _ tree , exercises , assessment _ items , contents )
DCSP p &#91; 0 &#93; = ( &apos; LET &apos; , p &#91; 2 &#93; , p &#91; 4 &#93; )
DCSP spec _ tgt = os.path.basename ( spec ) DCNL DCSP dest = os.path.join ( tree _ base , spec _ tgt ) DCNL DCSP return _ _ salt _ _ &#91; &apos; cp.get _ url &apos; &#93; ( spec , dest , saltenv = saltenv )
DCSP if ( not g ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP comp = &#91; g &#91; 0 &#93; &#93; DCNL DCSP for a in g &#91; 1 : &#93; : DCNL DCSP DCSP comp = gf _ mul ( comp , h , p , K ) DCNL DCSP DCSP comp = gf _ add _ ground ( comp , a , p , K ) DCNL DCSP DCSP comp = gf _ rem ( comp , f , p , K ) DCNL DCSP return comp
DCSP if queryset.exists ( ) : DCNL DCSP DCSP primary _ key = 0 DCNL DCSP DCSP last _ pk = queryset.order _ by ( &apos; -pk &apos; ) &#91; 0 &#93; .pk DCNL DCSP DCSP queryset = queryset.order _ by ( &apos; pk &apos; ) DCNL DCSP DCSP while ( primary _ key &lt; last _ pk ) : DCNL DCSP DCSP DCSP for row in queryset.filter ( pk _ _ gt = primary _ key ) &#91; : chunksize &#93; : DCNL DCSP DCSP DCSP DCSP primary _ key = row.pk DCNL DCSP DCSP DCSP DCSP ( yield row ) DCNL DCSP DCSP DCSP gc.collect ( )
DCSP t = Twitter ( auth = authen ( ) ) DCNL DCSP t.statuses.update ( status = g &#91; &apos; stuff &apos; &#93; )
DCSP def wrapped ( * args , * * kwargs ) : DCNL DCSP DCSP kwargs &#91; &apos; return _ response &apos; &#93; = False DCNL DCSP DCSP kwargs &#91; &apos; prefetch &apos; &#93; = True DCNL DCSP DCSP config = kwargs.get ( &apos; config &apos; , { } ) DCNL DCSP DCSP config.update ( safe _ mode = True ) DCNL DCSP DCSP kwargs &#91; &apos; config &apos; &#93; = config DCNL DCSP DCSP return f ( * args , * * kwargs ) DCNL DCSP return wrapped
DCSP from patsy.desc import INTERCEPT DCNL DCSP if ( INTERCEPT in terms ) : DCNL DCSP DCSP terms.remove ( INTERCEPT ) DCNL DCSP return terms
DCSP if isinstance ( value , unicode ) : DCNL DCSP DCSP value = value.encode ( &apos; utf-8 &apos; ) DCNL DCSP if ( len ( value ) &gt; max _ len ) : DCNL DCSP DCSP raise datastore _ errors.BadValueError ( ( &apos; Property DCSP % s DCSP is DCSP % d DCSP bytes DCSP long ; DCSP it DCSP must DCSP be DCSP % d DCSP or DCSP less . DCSP Consider DCSP Text DCSP instead , DCSP which DCSP can DCSP store DCSP strings DCSP of DCSP any DCSP length . &apos; % ( name , len ( value ) , max _ len ) ) )
DCSP def gen ( next , data = { } , cnt = &#91; 0 &#93; ) : DCNL DCSP DCSP dpop = data.pop DCNL DCSP DCSP for i in itertools.count ( ) : DCNL DCSP DCSP DCSP if ( i = = cnt &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP item = data &#91; i &#93; = next ( ) DCNL DCSP DCSP DCSP DCSP cnt &#91; 0 &#93; + = 1 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP item = dpop ( i ) DCNL DCSP DCSP DCSP ( yield item ) DCNL DCSP next = iter ( iterable ) .next DCNL DCSP return ( gen ( next ) , gen ( next ) )
DCSP try : DCNL DCSP DCSP if ( tool _ shed _ url.find ( &apos; : / / &apos; ) &gt; 0 ) : DCNL DCSP DCSP DCSP return tool _ shed _ url.split ( &apos; : / / &apos; ) &#91; 0 &#93; .lower ( ) DCNL DCSP except Exception as e : DCNL DCSP DCSP if ( tool _ shed _ url is not None ) : DCNL DCSP DCSP DCSP log.exception ( &apos; Handled DCSP exception DCSP getting DCSP the DCSP protocol DCSP from DCSP Tool DCSP Shed DCSP URL DCSP % s : \ n % s &apos; , str ( tool _ shed _ url ) , e ) DCNL DCSP DCSP return &apos; http&apos;
DCSP def newfn ( * args ) : DCNL DCSP DCSP &apos; Generated DCSP function . DCSP Closure-ish . &apos; DCNL DCSP DCSP if ( len ( args ) = = 1 ) : DCNL DCSP DCSP DCSP return fn ( * args ) DCNL DCSP DCSP args = &apos; DCSP &apos; .join ( map ( str , args ) ) DCNL DCSP DCSP return fn ( args ) DCNL DCSP setattr ( newfn , &apos; _ _ name _ _ &apos; , fn . _ _ name _ _ ) DCNL DCSP setattr ( newfn , &apos; _ _ doc _ _ &apos; , fn . _ _ doc _ _ ) DCNL DCSP return newfn
DCSP response = None DCNL DCSP if settings.FEATURES.get ( &apos; AUTH _ USE _ CERTIFICATES _ IMMEDIATE _ SIGNUP &apos; ) : DCNL DCSP DCSP response = openedx.core.djangoapps.external _ auth.views.redirect _ with _ get ( &apos; root &apos; , request.GET ) DCNL DCSP return response
DCSP try : DCNL DCSP DCSP renewal _ candidate = storage.RenewableCert ( full _ path , config ) DCNL DCSP except ( errors.CertStorageError , IOError ) as exc : DCNL DCSP DCSP logger.warning ( exc ) DCNL DCSP DCSP logger.warning ( &apos; Renewal DCSP configuration DCSP file DCSP % s DCSP is DCSP broken . DCSP Skipping . &apos; , full _ path ) DCNL DCSP DCSP logger.debug ( &apos; Traceback DCSP was : \ n % s &apos; , traceback.format _ exc ( ) ) DCNL DCSP DCSP return None DCNL DCSP if ( &apos; renewalparams &apos; not in renewal _ candidate.configuration ) : DCNL DCSP DCSP logger.warning ( &apos; Renewal DCSP configuration DCSP file DCSP % s DCSP lacks DCSP renewalparams . DCSP Skipping . &apos; , full _ path ) DCNL DCSP DCSP return None DCNL DCSP renewalparams = renewal _ candidate.configuration &#91; &apos; renewalparams &apos; &#93; DCNL DCSP if ( &apos; authenticator &apos; not in renewalparams ) : DCNL DCSP DCSP logger.warning ( &apos; Renewal DCSP configuration DCSP file DCSP % s DCSP does DCSP not DCSP specify DCSP an DCSP authenticator . DCSP Skipping . &apos; , full _ path ) DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP restore _ required _ config _ elements ( config , renewalparams ) DCNL DCSP DCSP _ restore _ plugin _ configs ( config , renewalparams ) DCNL DCSP except ( ValueError , errors.Error ) as error : DCNL DCSP DCSP logger.warning ( &apos; An DCSP error DCSP occurred DCSP while DCSP parsing DCSP % s . DCSP The DCSP error DCSP was DCSP % s . DCSP Skipping DCSP the DCSP file . &apos; , full _ path , error.message ) DCNL DCSP DCSP logger.debug ( &apos; Traceback DCSP was : \ n % s &apos; , traceback.format _ exc ( ) ) DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP config.domains = &#91; util.enforce _ domain _ sanity ( d ) for d in renewal _ candidate.names ( ) &#93; DCNL DCSP except errors.ConfigurationError as error : DCNL DCSP DCSP logger.warning ( &apos; Renewal DCSP configuration DCSP file DCSP % s DCSP references DCSP a DCSP cert DCSP that DCSP contains DCSP an DCSP invalid DCSP domain DCSP name . DCSP The DCSP problem DCSP was : DCSP % s . DCSP Skipping . &apos; , full _ path , error ) DCNL DCSP DCSP return None DCNL DCSP return renewal _ candidate
DCSP return json.dumps ( acl _ dict , ensure _ ascii = True , separators = ( &apos; , &apos; , &apos; : &apos; ) , sort _ keys = True )
DCSP assert virtualenv.virtualenv _ version , &apos; Should DCSP have DCSP version&apos;
DCSP mark _ done ( client , args.task _ id ) DCNL DCSP print &apos; Task DCSP { } DCSP marked DCSP done . &apos; .format ( args.task _ id )
DCSP model = context &#91; &apos; model &apos; &#93; DCNL DCSP schema = ( context.get ( &apos; schema &apos; ) or schema _ .default _ update _ relationship _ schema ( ) ) DCNL DCSP ( id , id2 , rel ) = _ get _ or _ bust ( data _ dict , &#91; &apos; subject &apos; , &apos; object &apos; , &apos; type &apos; &#93; ) DCNL DCSP pkg1 = model.Package.get ( id ) DCNL DCSP pkg2 = model.Package.get ( id2 ) DCNL DCSP if ( not pkg1 ) : DCNL DCSP DCSP raise NotFound ( ( &apos; Subject DCSP package DCSP % r DCSP was DCSP not DCSP found . &apos; % id ) ) DCNL DCSP if ( not pkg2 ) : DCNL DCSP DCSP return NotFound ( ( &apos; Object DCSP package DCSP % r DCSP was DCSP not DCSP found . &apos; % id2 ) ) DCNL DCSP ( data , errors ) = _ validate ( data _ dict , schema , context ) DCNL DCSP if errors : DCNL DCSP DCSP model.Session.rollback ( ) DCNL DCSP DCSP raise ValidationError ( errors ) DCNL DCSP _ check _ access ( &apos; package _ relationship _ update &apos; , context , data _ dict ) DCNL DCSP existing _ rels = pkg1.get _ relationships _ with ( pkg2 , rel ) DCNL DCSP if ( not existing _ rels ) : DCNL DCSP DCSP raise NotFound ( &apos; This DCSP relationship DCSP between DCSP the DCSP packages DCSP was DCSP not DCSP found . &apos; ) DCNL DCSP entity = existing _ rels &#91; 0 &#93; DCNL DCSP comment = data _ dict.get ( &apos; comment &apos; , u &apos; &apos; ) DCNL DCSP context &#91; &apos; relationship &apos; &#93; = entity DCNL DCSP return _ update _ package _ relationship ( entity , comment , context )
DCSP if ( direction not in ( DOWNLOAD , UPLOAD ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP direction DCSP argument DCSP { ! r } . DCSP Must DCSP be DCSP one DCSP of DCSP ``runner.DOWNLOAD`` DCSP or DCSP ``runner.UPLOAD``. &apos; .format ( direction ) ) DCNL DCSP remote _ host _ path = ( ( ( ( username + &apos; @ &apos; ) + host ) + &apos; : &apos; ) + remote _ path.path ) DCNL DCSP scp _ command = ( &#91; &apos; scp &apos; , &apos; -r &apos; , &apos; -P &apos; , bytes ( port ) &#93; + SSH _ OPTIONS ) DCNL DCSP if ( identity _ file is not None ) : DCNL DCSP DCSP scp _ command + = &#91; &apos; -i &apos; , identity _ file.path &#93; DCNL DCSP if ( direction is DOWNLOAD ) : DCNL DCSP DCSP scp _ command + = &#91; remote _ host _ path , local _ path.path &#93; DCNL DCSP else : DCNL DCSP DCSP scp _ command + = &#91; local _ path.path , remote _ host _ path &#93; DCNL DCSP action = SCP _ ACTION ( username = username , host = host , remote _ path = remote _ path , local _ path = local _ path , port = port , identity _ file = identity _ file ) DCNL DCSP failed _ reason = &#91; &#93; DCNL DCSP def handle _ stdout ( line ) : DCNL DCSP DCSP SCP _ OUTPUT _ MESSAGE ( line = line ) .write ( action = action ) DCNL DCSP def handle _ stderr ( line ) : DCNL DCSP DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Notice DCSP scp &apos;s DCSP particular DCSP way DCSP of DCSP describing DCSP the DCSP file-not-found DCSP condition \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP and DCSP turn DCSP it DCSP into DCSP a DCSP more DCSP easily DCSP recognized DCSP form . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; DCNL DCSP DCSP if ( &apos; No DCSP such DCSP file DCSP or DCSP directory &apos; in line ) : DCNL DCSP DCSP DCSP failed _ reason.append ( RemoteFileNotFound ( remote _ path ) ) DCNL DCSP DCSP if ( &apos; lost DCSP connection &apos; in line ) : DCNL DCSP DCSP DCSP failed _ reason.append ( SCPConnectionError ( ) ) DCNL DCSP DCSP SCP _ ERROR _ MESSAGE ( line = line ) .write ( action = action ) DCNL DCSP def scp _ failed ( reason ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Check DCSP for DCSP a DCSP known DCSP error DCSP with DCSP the DCSP scp DCSP attempt DCSP and DCSP turn DCSP the DCSP normal \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP failure DCSP into DCSP a DCSP more DCSP meaningful DCSP one . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP reason.trap ( ProcessTerminated ) DCNL DCSP DCSP if failed _ reason : DCNL DCSP DCSP DCSP return Failure ( failed _ reason &#91; ( -1 ) &#93; ) DCNL DCSP DCSP return reason DCNL DCSP with action.context ( ) : DCNL DCSP DCSP context = DeferredContext ( run ( reactor , scp _ command , handle _ stdout = handle _ stdout , handle _ stderr = handle _ stderr ) ) DCNL DCSP DCSP context.addErrback ( scp _ failed ) DCNL DCSP DCSP return context.addActionFinish ( )
DCSP assert ( len ( rbm _ list ) &gt; 1 ) DCNL DCSP for ( this _ rbm , above _ rbm ) in zip ( rbm _ list &#91; : ( -1 ) &#93; , rbm _ list &#91; 1 : &#93; ) : DCNL DCSP DCSP hidden _ layer = this _ rbm.hidden _ layers &#91; 0 &#93; DCNL DCSP DCSP visible _ layer = above _ rbm.visible _ layer DCNL DCSP DCSP new _ biases = ( 0.5 * ( hidden _ layer.get _ biases ( ) + visible _ layer.get _ biases ( ) ) ) DCNL DCSP DCSP hidden _ layer.set _ biases ( new _ biases ) DCNL DCSP visible _ layer = rbm _ list &#91; 0 &#93; .visible _ layer DCNL DCSP visible _ layer.dbm = None DCNL DCSP hidden _ layers = &#91; &#93; DCNL DCSP for rbm in rbm _ list : DCNL DCSP DCSP if ( rbm = = rbm _ list &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP DCSP if targets : DCNL DCSP DCSP DCSP DCSP assert ( len ( rbm.hidden _ layers ) = = 2 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( len ( rbm.hidden _ layers ) = = 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP assert ( len ( rbm.hidden _ layers ) = = 1 ) DCNL DCSP DCSP hidden _ layers = ( hidden _ layers + rbm.hidden _ layers ) DCNL DCSP for hidden _ layer in hidden _ layers : DCNL DCSP DCSP hidden _ layer.dbm = None DCNL DCSP first _ hidden _ layer = hidden _ layers &#91; ( -1 ) &#93; DCNL DCSP if targets : DCNL DCSP DCSP last _ hidden _ layer = hidden _ layers &#91; ( -2 ) &#93; DCNL DCSP else : DCNL DCSP DCSP last _ hidden _ layer = hidden _ layers &#91; ( -1 ) &#93; DCNL DCSP first _ hidden _ layer.set _ weights ( ( 0.5 * first _ hidden _ layer.get _ weights ( ) ) ) DCNL DCSP last _ hidden _ layer.set _ weights ( ( 0.5 * last _ hidden _ layer.get _ weights ( ) ) ) DCNL DCSP return DBM ( batch _ size , visible _ layer , hidden _ layers , niter , inference _ procedure )
DCSP def required _ label _ tag ( self , contents = None , attrs = None ) : DCNL DCSP DCSP &apos; Required DCSP label DCSP tag &apos; DCNL DCSP DCSP contents = ( contents or escape ( self.label ) ) DCNL DCSP DCSP if self.field.required : DCNL DCSP DCSP DCSP if ( not self.label.endswith ( &apos; DCSP * &apos; ) ) : DCNL DCSP DCSP DCSP DCSP self.label + = &apos; DCSP * &apos; DCNL DCSP DCSP DCSP DCSP contents + = &apos; DCSP * &apos; DCNL DCSP DCSP DCSP attrs = { &apos; class &apos; : &apos; required &apos; } DCNL DCSP DCSP return original _ function ( self , contents , attrs ) DCNL DCSP return required _ label _ tag
DCSP class ScriptTests ( TestCase , ) : DCNL DCSP DCSP @ skipUnless ( which ( executable ) , ( executable + &apos; DCSP not DCSP installed &apos; ) ) DCNL DCSP DCSP def test _ version ( self ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP The DCSP script DCSP is DCSP a DCSP command DCSP available DCSP on DCSP the DCSP system DCSP path . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP result = run _ process ( ( &#91; executable &#93; + &#91; &apos; --version &apos; &#93; ) ) DCNL DCSP DCSP DCSP self.assertEqual ( result.output , ( &apos; % s \ n &apos; % ( _ _ version _ _ , ) ) ) DCNL DCSP DCSP @ skipUnless ( which ( executable ) , ( executable + &apos; DCSP not DCSP installed &apos; ) ) DCNL DCSP DCSP def test _ identification ( self ) : DCNL DCSP DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP The DCSP script DCSP identifies DCSP itself DCSP as DCSP what DCSP it DCSP is . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP DCSP result = run _ process ( ( &#91; executable &#93; + &#91; &apos; --help &apos; &#93; ) ) DCNL DCSP DCSP DCSP self.assertIn ( executable , result.output ) DCNL DCSP return ScriptTests
DCSP if ( &apos; nova / tests / &apos; in filename ) : DCNL DCSP DCSP res = import _ translation _ for _ log _ or _ exception.match ( logical _ line ) DCNL DCSP DCSP if res : DCNL DCSP DCSP DCSP ( yield ( 0 , &quot; N337 DCSP Don &apos;t DCSP import DCSP translation DCSP in DCSP tests &quot; ) )
DCSP return WebDriverWait ( context.browser , wait _ time ) .until ( EC.element _ to _ be _ clickable ( by ) )
DCSP return &#91; models.Issue ( subject = line , * * additional _ fields ) for line in text.split _ in _ lines ( bulk _ data ) &#93;
DCSP try : DCNL DCSP DCSP return KWARG _ REGEX.match ( string _ ) .groups ( ) DCNL DCSP except AttributeError : DCNL DCSP DCSP return ( None , None )
DCSP groups = groups.split ( u &apos; , &apos; ) DCNL DCSP shortGroupList = &#91; &#93; DCNL DCSP if sickrage.srCore.ADBA _ CONNECTION : DCNL DCSP DCSP for groupName in groups : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP group = sickrage.srCore.ADBA _ CONNECTION.group ( gname = groupName ) DCNL DCSP DCSP DCSP except AniDBCommandTimeoutError : DCNL DCSP DCSP DCSP DCSP sickrage.srCore.srLogger.debug ( u &apos;Timeout DCSP while DCSP loading DCSP group DCSP from DCSP AniDB . DCSP Trying DCSP next DCSP group &apos; ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP sickrage.srCore.srLogger.debug ( u &apos;Failed DCSP while DCSP loading DCSP group DCSP from DCSP AniDB . DCSP Trying DCSP next DCSP group &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP for line in group.datalines : DCNL DCSP DCSP DCSP DCSP DCSP if line &#91; u &apos;shortname &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP DCSP shortGroupList.append ( line &#91; u &apos;shortname &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP elif ( groupName not in shortGroupList ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP shortGroupList.append ( groupName ) DCNL DCSP else : DCNL DCSP DCSP shortGroupList = groups DCNL DCSP return shortGroupList
DCSP mo = InternalDate.match ( resp ) DCNL DCSP if ( not mo ) : DCNL DCSP DCSP return None DCNL DCSP mon = Mon2num &#91; mo.group ( &apos; mon &apos; ) &#93; DCNL DCSP zonen = mo.group ( &apos; zonen &apos; ) DCNL DCSP day = int ( mo.group ( &apos; day &apos; ) ) DCNL DCSP year = int ( mo.group ( &apos; year &apos; ) ) DCNL DCSP hour = int ( mo.group ( &apos; hour &apos; ) ) DCNL DCSP min = int ( mo.group ( &apos; min &apos; ) ) DCNL DCSP sec = int ( mo.group ( &apos; sec &apos; ) ) DCNL DCSP zoneh = int ( mo.group ( &apos; zoneh &apos; ) ) DCNL DCSP zonem = int ( mo.group ( &apos; zonem &apos; ) ) DCNL DCSP zone = ( ( ( zoneh * 60 ) + zonem ) * 60 ) DCNL DCSP if ( zonen = = &apos; -&apos; ) : DCNL DCSP DCSP zone = ( - zone ) DCNL DCSP tt = ( year , mon , day , hour , min , sec , ( -1 ) , ( -1 ) , ( -1 ) ) DCNL DCSP utc = time.mktime ( tt ) DCNL DCSP lt = time.localtime ( utc ) DCNL DCSP if ( time.daylight and lt &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP zone = ( zone + time.altzone ) DCNL DCSP else : DCNL DCSP DCSP zone = ( zone + time.timezone ) DCNL DCSP return time.localtime ( ( utc - zone ) )
DCSP clk = 48000000 DCNL DCSP clk _ div = 16 DCNL DCSP frac _ code = &#91; 0 , 3 , 2 , 4 , 1 , 5 , 6 , 7 &#93; DCNL DCSP actual _ baud = 0 DCNL DCSP if ( baudrate &gt; = ( clk / clk _ div ) ) : DCNL DCSP DCSP encoded _ divisor = 0 DCNL DCSP DCSP actual _ baud = ( clk / / clk _ div ) DCNL DCSP elif ( baudrate &gt; = ( clk / ( clk _ div + ( clk _ div / 2 ) ) ) ) : DCNL DCSP DCSP encoded _ divisor = 1 DCNL DCSP DCSP actual _ baud = ( clk / / ( clk _ div + ( clk _ div / / 2 ) ) ) DCNL DCSP elif ( baudrate &gt; = ( clk / ( 2 * clk _ div ) ) ) : DCNL DCSP DCSP encoded _ divisor = 2 DCNL DCSP DCSP actual _ baud = ( clk / / ( 2 * clk _ div ) ) DCNL DCSP else : DCNL DCSP DCSP divisor = ( ( ( clk * 16 ) / / clk _ div ) / / baudrate ) DCNL DCSP DCSP best _ divisor = ( ( divisor + 1 ) / / 2 ) DCNL DCSP DCSP if ( best _ divisor &gt; 131072 ) : DCNL DCSP DCSP DCSP best _ divisor = 131071 DCNL DCSP DCSP actual _ baud = ( ( ( clk * 16 ) / / clk _ div ) / / best _ divisor ) DCNL DCSP DCSP actual _ baud = ( ( actual _ baud + 1 ) / / 2 ) DCNL DCSP DCSP encoded _ divisor = ( ( best _ divisor &gt; &gt; 3 ) + ( frac _ code &#91; ( best _ divisor &amp; 7 ) &#93; &lt; &lt; 14 ) ) DCNL DCSP value = ( encoded _ divisor &amp; 65535 ) DCNL DCSP index = ( encoded _ divisor &gt; &gt; 16 ) DCNL DCSP return ( actual _ baud , value , index )
DCSP output = s3 _ rest _ controller ( ) DCNL DCSP return output
DCSP if ( term in lookup _ dict ) : DCNL DCSP DCSP return ( lookup _ dict , term ) DCNL DCSP dict _ cursor = lookup _ dict DCNL DCSP subkeys = term.split ( &apos; .&apos; ) DCNL DCSP subkey = &apos; &apos; DCNL DCSP while ( len ( subkeys ) &gt; 0 ) : DCNL DCSP DCSP subkey + = subkeys.pop ( 0 ) DCNL DCSP DCSP if ( subkey in dict _ cursor ) : DCNL DCSP DCSP DCSP if ( len ( subkeys ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP dict _ cursor = dict _ cursor &#91; subkey &#93; DCNL DCSP DCSP DCSP subkey = &apos; &apos; DCNL DCSP DCSP elif ( len ( subkeys ) = = 0 ) : DCNL DCSP DCSP DCSP dict _ cursor = None DCNL DCSP DCSP DCSP subkey = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP subkey + = &apos; .&apos; DCNL DCSP return ( dict _ cursor , subkey )
DCSP failed = set _ ip _ nonlocal _ bind ( value = 0 , namespace = namespace , log _ fail _ as _ error = False ) DCNL DCSP if failed : DCNL DCSP DCSP LOG.warning ( _ LW ( &apos; % s DCSP will DCSP not DCSP be DCSP set DCSP to DCSP 0 DCSP in DCSP the DCSP root DCSP namespace DCSP in DCSP order DCSP to DCSP not DCSP break DCSP DVR , DCSP which DCSP requires DCSP this DCSP value DCSP be DCSP set DCSP to DCSP 1 . DCSP This DCSP may DCSP introduce DCSP a DCSP race DCSP between DCSP moving DCSP a DCSP floating DCSP IP DCSP to DCSP a DCSP different DCSP network DCSP node , DCSP and DCSP the DCSP peer DCSP side DCSP getting DCSP a DCSP populated DCSP ARP DCSP cache DCSP for DCSP a DCSP given DCSP floating DCSP IP DCSP address . &apos; ) , IP _ NONLOCAL _ BIND )
DCSP ct . _ write _ head ( ) DCNL DCSP df = _ parsing _ dayprice _ json ( 1 ) DCNL DCSP if ( df is not None ) : DCNL DCSP DCSP for i in range ( 2 , ct.PAGE _ NUM &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP newdf = _ parsing _ dayprice _ json ( i ) DCNL DCSP DCSP DCSP df = df.append ( newdf , ignore _ index = True ) DCNL DCSP return df
DCSP if ( not salt.utils.validate.net.mac ( bdaddr ) ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Invalid DCSP BD DCSP address DCSP passed DCSP to DCSP bluetooth.block &apos; ) DCNL DCSP cmd = &apos; hciconfig DCSP { 0 } DCSP block &apos; .format ( bdaddr ) DCNL DCSP _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd ) .splitlines ( )
DCSP ( cc _ comment , context ) = _ get _ comment _ and _ context ( request , comment _ id ) DCNL DCSP if can _ delete ( cc _ comment , context ) : DCNL DCSP DCSP cc _ comment.delete ( ) DCNL DCSP DCSP comment _ deleted.send ( sender = None , user = request.user , post = cc _ comment ) DCNL DCSP else : DCNL DCSP DCSP raise PermissionDenied
DCSP path = e &#91; &apos; PATH _ INFO &apos; &#93; DCNL DCSP host = e.get ( &apos; HTTP _ HOST &apos; , e.get ( &apos; SERVER _ NAME &apos; , &apos; localhost &apos; ) ) .lower ( ) DCNL DCSP i = host.find ( &apos; : &apos; ) DCNL DCSP if ( i &gt; 0 ) : DCNL DCSP DCSP host = host &#91; : i &#93; DCNL DCSP key = ( &apos; % s : % s : / / % s : % s DCSP % s &apos; % ( e.get ( &apos; REMOTE _ ADDR &apos; , &apos; localhost &apos; ) , e.get ( &apos; wsgi.url _ scheme &apos; , &apos; http &apos; ) .lower ( ) , host , e.get ( &apos; REQUEST _ METHOD &apos; , &apos; get &apos; ) .lower ( ) , path ) ) DCNL DCSP for ( regex , value , custom _ env ) in regexes : DCNL DCSP DCSP if regex.match ( key ) : DCNL DCSP DCSP DCSP e.update ( custom _ env ) DCNL DCSP DCSP DCSP rewritten = regex.sub ( value , key ) DCNL DCSP DCSP DCSP log _ rewrite ( ( &apos; % s : DCSP &#91; % s &#93; DCSP &#91; % s &#93; DCSP - &gt; DCSP % s &apos; % ( tag , key , value , rewritten ) ) ) DCNL DCSP DCSP DCSP return rewritten DCNL DCSP log _ rewrite ( ( &apos; % s : DCSP &#91; % s &#93; DCSP - &gt; DCSP % s DCSP ( not DCSP rewritten ) &apos; % ( tag , key , default ) ) ) DCNL DCSP return default
DCSP sorted _ sample _ ids _ set = set ( sorted _ sample _ ids ) DCNL DCSP if ( set ( otu _ table.ids ( ) ) - sorted _ sample _ ids _ set ) : DCNL DCSP DCSP raise KeyError ( ( &apos; Sample DCSP IDs DCSP present DCSP in DCSP OTU DCSP table DCSP but DCSP not DCSP sorted DCSP sample DCSP id DCSP list : DCSP &apos; + &apos; DCSP &apos; .join ( list ( ( set ( otu _ table.ids ( ) ) - set ( sorted _ sample _ ids ) ) ) ) ) ) DCNL DCSP if ( len ( sorted _ sample _ ids _ set ) ! = len ( sorted _ sample _ ids ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Duplicate DCSP sample DCSP IDs DCSP are DCSP present DCSP in DCSP sorted DCSP sample DCSP id DCSP list . &apos; ) DCNL DCSP safe _ sorted _ sample _ ids = &#91; &#93; DCNL DCSP for k in sorted _ sample _ ids : DCNL DCSP DCSP if otu _ table.exists ( k ) : DCNL DCSP DCSP DCSP safe _ sorted _ sample _ ids.append ( k ) DCNL DCSP sorted _ table = otu _ table.sort _ order ( safe _ sorted _ sample _ ids ) DCNL DCSP return sorted _ table
DCSP try : DCNL DCSP DCSP value = int ( value ) DCNL DCSP except ( TypeError , ValueError ) : DCNL DCSP DCSP return value DCNL DCSP t = ( &apos; th &apos; , &apos; st &apos; , &apos; nd &apos; , &apos; rd &apos; , &apos; th &apos; , &apos; th &apos; , &apos; th &apos; , &apos; th &apos; , &apos; th &apos; , &apos; th &apos; ) DCNL DCSP if ( ( value % 100 ) in ( 11 , 12 , 13 ) ) : DCNL DCSP DCSP return ( u &apos; % d % s &apos; % ( value , t &#91; 0 &#93; ) ) DCNL DCSP return ( u &apos; % d % s &apos; % ( value , t &#91; ( value % 10 ) &#93; ) )
DCSP log.info ( &apos; Attempting DCSP to DCSP delete DCSP instance DCSP % s &apos; , name ) DCNL DCSP if ( not vb _ machine _ exists ( name ) ) : DCNL DCSP DCSP return &quot; { 0 } DCSP doesn &apos;t DCSP exist DCSP and DCSP can &apos;t DCSP be DCSP deleted &quot; .format ( name ) DCNL DCSP cloud.fire _ event ( &apos; event &apos; , &apos; destroying DCSP instance &apos; , &apos; salt / cloud / { 0 } / destroying &apos; .format ( name ) , args = { &apos; name &apos; : name } , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; ) DCNL DCSP vb _ destroy _ machine ( name ) DCNL DCSP cloud.fire _ event ( &apos; event &apos; , &apos; destroyed DCSP instance &apos; , &apos; salt / cloud / { 0 } / destroyed &apos; .format ( name ) , args = { &apos; name &apos; : name } , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; )
DCSP ( get _ images _ table , ) = from _ migration _ import ( &apos; 008 _ add _ image _ members _ table &apos; , &#91; &apos; get _ images _ table &apos; &#93; ) DCNL DCSP images = get _ images _ table ( meta ) DCNL DCSP return images
DCSP vertices = &#91; &#93; DCNL DCSP codes = &#91; &#93; DCNL DCSP for p in paths : DCNL DCSP DCSP p = make _ path _ regular ( p ) DCNL DCSP DCSP vertices.append ( p.vertices ) DCNL DCSP DCSP codes.append ( p.codes ) DCNL DCSP _ path = Path ( np.concatenate ( vertices ) , np.concatenate ( codes ) ) DCNL DCSP return _ path
DCSP ( credentials , default _ project _ id ) = google.auth.default ( scopes = &#91; &apos; https : / / www.googleapis.com / auth / bigquery &apos; &#93; ) DCNL DCSP session = google.auth.transport.requests.AuthorizedSession ( credentials ) DCNL DCSP if ( project _ id is None ) : DCNL DCSP DCSP project _ id = default _ project _ id DCNL DCSP url _ format = &apos; https : / / www.googleapis.com / bigquery / v2 / projects / { project _ id } / datasets / { dataset _ id } / tables / { table _ id } &apos; DCNL DCSP response = session.patch ( url _ format.format ( project _ id = project _ id , dataset _ id = dataset _ id , table _ id = table _ id ) , params = { &apos; fields &apos; : &apos; labels &apos; } , json = { &apos; labels &apos; : { label _ key : label _ value } } ) DCNL DCSP response.raise _ for _ status ( ) DCNL DCSP labels = response.json ( ) &#91; &apos; labels &apos; &#93; DCNL DCSP print &apos; Updated DCSP label DCSP &quot; { } &quot; DCSP with DCSP value DCSP &quot; { } &quot; &apos; .format ( label _ key , labels &#91; label _ key &#93; )
DCSP I = I &#91; 35 : 195 &#93; DCNL DCSP I = I &#91; : : 2 , : : 2 , 0 &#93; DCNL DCSP I &#91; ( I = = 144 ) &#93; = 0 DCNL DCSP I &#91; ( I = = 109 ) &#93; = 0 DCNL DCSP I &#91; ( I ! = 0 ) &#93; = 1 DCNL DCSP return I.astype ( np.float ) .ravel ( )
DCSP objs = None DCNL DCSP if ( src and dest ) : DCNL DCSP DCSP module.fail _ json ( msg = &apos; Error : DCSP ambiguous DCSP instructions ; DCSP files DCSP to DCSP set DCSP meta DCSP have DCSP been DCSP specified DCSP on DCSP both DCSP src DCSP and DCSP dest DCSP args &apos; ) DCNL DCSP elif dest : DCNL DCSP DCSP objs = dest DCNL DCSP else : DCNL DCSP DCSP objs = src DCNL DCSP objs = objs.split ( &apos; , &apos; ) DCNL DCSP objs = map ( str.strip , objs ) DCNL DCSP c = _ get _ container ( module , cf , container ) DCNL DCSP results = &#91; &#93; DCNL DCSP for obj in objs : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP result = c.get _ object ( obj ) .set _ metadata ( meta , clear = clear _ meta ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP module.fail _ json ( msg = e.message ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP results.append ( result ) DCNL DCSP EXIT _ DICT &#91; &apos; container &apos; &#93; = c.name DCNL DCSP EXIT _ DICT &#91; &apos; success &apos; &#93; = True DCNL DCSP if results : DCNL DCSP DCSP EXIT _ DICT &#91; &apos; changed &apos; &#93; = True DCNL DCSP DCSP EXIT _ DICT &#91; &apos; num _ changed &apos; &#93; = True DCNL DCSP module.exit _ json ( * * EXIT _ DICT )
DCSP if ( seq in challenge _ acks ) : DCNL DCSP DCSP challenge = challenge _ acks &#91; seq &#93; DCNL DCSP else : DCNL DCSP DCSP challenge = &apos; CHALLENGE DCSP NOT DCSP FOUND &apos; DCNL DCSP if ( len ( msg3 ) &gt; 43 ) : DCNL DCSP DCSP ( lmlen , lmmax , lmoff , ntlen , ntmax , ntoff , domlen , dommax , domoff , userlen , usermax , useroff ) = struct.unpack ( &apos; 12xhhihhihhihhi &apos; , msg3 &#91; : 44 &#93; ) DCNL DCSP DCSP lmhash = binascii.b2a _ hex ( msg3 &#91; lmoff : ( lmoff + lmlen ) &#93; ) DCNL DCSP DCSP nthash = binascii.b2a _ hex ( msg3 &#91; ntoff : ( ntoff + ntlen ) &#93; ) DCNL DCSP DCSP domain = msg3 &#91; domoff : ( domoff + domlen ) &#93; .replace ( &apos; \ x00 &apos; , &apos; &apos; ) DCNL DCSP DCSP user = msg3 &#91; useroff : ( useroff + userlen ) &#93; .replace ( &apos; \ x00 &apos; , &apos; &apos; ) DCNL DCSP DCSP if ( ntlen = = 24 ) : DCNL DCSP DCSP DCSP msg = ( &apos; % s DCSP % s &apos; % ( &apos; NETNTLMv1 : &apos; , ( ( ( ( ( ( ( ( user + &apos; : : &apos; ) + domain ) + &apos; : &apos; ) + lmhash ) + &apos; : &apos; ) + nthash ) + &apos; : &apos; ) + challenge ) ) ) DCNL DCSP DCSP DCSP return msg DCNL DCSP DCSP elif ( ntlen &gt; 60 ) : DCNL DCSP DCSP DCSP msg = ( &apos; % s DCSP % s &apos; % ( &apos; NETNTLMv2 : &apos; , ( ( ( ( ( ( ( ( user + &apos; : : &apos; ) + domain ) + &apos; : &apos; ) + challenge ) + &apos; : &apos; ) + nthash &#91; : 32 &#93; ) + &apos; : &apos; ) + nthash &#91; 32 : &#93; ) ) ) DCNL DCSP DCSP DCSP return msg
DCSP dsk = { &apos; a &apos; : 1 , &apos; b &apos; : ( f , &apos; a &apos; ) , &apos; c &apos; : ( f , &apos; b &apos; ) , &apos; x &apos; : 1 , &apos; y &apos; : ( f , &apos; x &apos; ) } DCNL DCSP o = order ( dsk ) DCNL DCSP assert ( o = = { &apos; c &apos; : 0 , &apos; b &apos; : 1 , &apos; a &apos; : 2 , &apos; y &apos; : 3 , &apos; x &apos; : 4 } )
DCSP w - = np.dot ( np.dot ( w , W &#91; : j &#93; .T ) , W &#91; : j &#93; ) DCNL DCSP return w
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : None , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP try : DCNL DCSP DCSP installed _ pkgs = _ _ salt _ _ &#91; &apos; npm.list &apos; &#93; ( dir = dir ) DCNL DCSP except ( CommandExecutionError , CommandNotFoundError ) as err : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Error DCSP uninstalling DCSP &apos; { 0 } &apos; : DCSP { 1 } &quot; .format ( name , err ) DCNL DCSP DCSP return ret DCNL DCSP if ( name not in installed _ pkgs ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Package DCSP &apos; { 0 } &apos; DCSP is DCSP not DCSP installed &quot; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Package DCSP &apos; { 0 } &apos; DCSP is DCSP set DCSP to DCSP be DCSP removed &quot; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ salt _ _ &#91; &apos; npm.uninstall &apos; &#93; ( pkg = name , dir = dir , runas = user ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; name &#93; = &apos; Removed &apos; DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Package DCSP &apos; { 0 } &apos; DCSP was DCSP successfully DCSP removed &quot; .format ( name ) DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Error DCSP removing DCSP package DCSP &apos; { 0 } &apos; &quot; .format ( name ) DCNL DCSP return ret
DCSP message _ set = KafkaProtocol . _ encode _ message _ set ( &#91; create _ message ( payload , pl _ key ) for ( payload , pl _ key ) in payloads &#93; ) DCNL DCSP gzipped = gzip _ encode ( message _ set , compresslevel = compresslevel ) DCNL DCSP codec = ( ATTRIBUTE _ CODEC _ MASK &amp; CODEC _ GZIP ) DCNL DCSP return kafka.structs.Message ( 0 , ( 0 &#124; codec ) , key , gzipped )
DCSP _ unpublish _ activity ( committer _ id , exploration _ id , feconf.ACTIVITY _ TYPE _ EXPLORATION )
DCSP env = os.environ.copy ( ) DCNL DCSP if ( exec _ env is not None ) : DCNL DCSP DCSP for ( env _ name , env _ val ) in exec _ env.items ( ) : DCNL DCSP DCSP DCSP if callable ( env _ val ) : DCNL DCSP DCSP DCSP DCSP env &#91; env _ name &#93; = env _ val ( env.get ( env _ name ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP env &#91; env _ name &#93; = env _ val DCNL DCSP pid = os.fork ( ) DCNL DCSP if ( pid = = 0 ) : DCNL DCSP DCSP if logfile : DCNL DCSP DCSP DCSP fds = &#91; 1 , 2 &#93; DCNL DCSP DCSP DCSP with open ( logfile , &apos; r + b &apos; ) as fptr : DCNL DCSP DCSP DCSP DCSP for desc in fds : DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP os.dup2 ( fptr.fileno ( ) , desc ) DCNL DCSP DCSP DCSP DCSP DCSP except OSError : DCNL DCSP DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP if ( pass _ fds and hasattr ( os , &apos; set _ inheritable &apos; ) ) : DCNL DCSP DCSP DCSP for fd in pass _ fds : DCNL DCSP DCSP DCSP DCSP os.set _ inheritable ( fd , True ) DCNL DCSP DCSP args = shlex.split ( cmd ) DCNL DCSP DCSP os.execvpe ( args &#91; 0 &#93; , args , env ) DCNL DCSP else : DCNL DCSP DCSP return pid
DCSP class SlugChangingArticleForm ( forms.ModelForm , ) : DCNL DCSP DCSP &apos; Custom DCSP form DCSP class DCSP to DCSP overwrite DCSP the DCSP slug . &apos; DCNL DCSP DCSP class Meta : DCNL DCSP DCSP DCSP model = Article DCNL DCSP DCSP def save ( self , * args , * * kwargs ) : DCNL DCSP DCSP DCSP self.instance.slug = &apos; some-other-slug &apos; DCNL DCSP DCSP DCSP return super ( SlugChangingArticleForm , self ) .save ( * args , * * kwargs ) DCNL DCSP from django.views.generic.create _ update import create _ object DCNL DCSP return create _ object ( request , post _ save _ redirect = &apos; / create _ update / view / article / % ( slug ) s / &apos; , form _ class = SlugChangingArticleForm )
DCSP minimum = complex ( 999999999.0 , 999999999.0 ) DCNL DCSP for path in paths : DCNL DCSP DCSP minimum = getMinimum ( minimum , getMinimumByPathComplex ( path ) ) DCNL DCSP return minimum
DCSP with bz2.BZ2File ( loc ) as file _ : DCNL DCSP DCSP for ( i , line ) in enumerate ( file _ ) : DCNL DCSP DCSP DCSP ( yield ujson.loads ( line ) &#91; u &apos;body &apos; &#93; )
DCSP ( rc , out , err ) = module.run _ command ( ( &apos; % s DCSP -p DCSP -v &apos; % PKGIN _ PATH ) ) DCNL DCSP if ( rc = = 0 ) : DCNL DCSP DCSP pflag = &apos; -p &apos; DCNL DCSP DCSP splitchar = &apos; ; &apos; DCNL DCSP else : DCNL DCSP DCSP pflag = &apos; &apos; DCNL DCSP DCSP splitchar = &apos; DCSP &apos; DCNL DCSP ( rc , out , err ) = module.run _ command ( ( &apos; % s DCSP % s DCSP search DCSP &quot; ^ % s $ &quot; &apos; % ( PKGIN _ PATH , pflag , name ) ) ) DCNL DCSP if ( rc = = 0 ) : DCNL DCSP DCSP packages = out.split ( &apos; \ n &apos; ) DCNL DCSP DCSP for package in packages : DCNL DCSP DCSP DCSP ( pkgname _ with _ version , raw _ state ) = package.split ( splitchar ) &#91; 0 : 2 &#93; DCNL DCSP DCSP DCSP pkg _ search _ obj = re.search ( &apos; ^ ( . * ? ) \ \ - &#91; 0-9 &#93; &#91; 0-9 . &#93; * ( nb &#91; 0-9 &#93; + ) * &apos; , pkgname _ with _ version , re.M ) DCNL DCSP DCSP DCSP if ( not pkg _ search _ obj ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP pkgname _ without _ version = pkg _ search _ obj.group ( 1 ) DCNL DCSP DCSP DCSP if ( name ! = pkgname _ without _ version ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( raw _ state = = &apos; &lt; &apos; ) : DCNL DCSP DCSP DCSP DCSP return &apos; outdated &apos; DCNL DCSP DCSP DCSP elif ( ( raw _ state = = &apos; = &apos; ) or ( raw _ state = = &apos; &gt; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP return &apos; present &apos; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP return False
DCSP while ( node is not None ) : DCNL DCSP DCSP if ( ( node.type = = syms.suite ) and ( len ( node.children ) &gt; 2 ) ) : DCNL DCSP DCSP DCSP indent = node.children &#91; 1 &#93; DCNL DCSP DCSP DCSP if ( indent.type = = token.INDENT ) : DCNL DCSP DCSP DCSP DCSP return indent.value DCNL DCSP DCSP node = node.parent DCNL DCSP return u &apos; &apos;
DCSP return _ expect _ warnings ( sa _ exc.SAWarning , messages , * * kw )
DCSP if ( not response.has _ header ( &apos; Cache-Control &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP cc = dict ( &#91; _ to _ tuple ( el ) for el in cc _ delim _ re.split ( response &#91; &apos; Cache-Control &apos; &#93; ) &#93; ) DCNL DCSP if ( &apos; max-age &apos; in cc ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return int ( cc &#91; &apos; max-age &apos; &#93; ) DCNL DCSP DCSP except ( ValueError , TypeError ) : DCNL DCSP DCSP DCSP pass
DCSP return XBlockConfiguration.objects.current _ set ( ) .filter ( enabled = False )
DCSP token = token.split _ contents ( ) DCNL DCSP form = token.pop ( 1 ) DCNL DCSP helper = None DCNL DCSP template _ pack = ( &quot; &apos; % s &apos; &quot; % get _ template _ pack ( ) ) DCNL DCSP try : DCNL DCSP DCSP helper = token.pop ( 1 ) DCNL DCSP except IndexError : DCNL DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP template _ pack = token.pop ( 1 ) DCNL DCSP except IndexError : DCNL DCSP DCSP pass DCNL DCSP if ( ( helper is not None ) and isinstance ( helper , string _ types ) and ( ( &quot; &apos; &quot; in helper ) or ( &apos; &quot; &apos; in helper ) ) ) : DCNL DCSP DCSP template _ pack = helper DCNL DCSP DCSP helper = None DCNL DCSP if ( template _ pack is not None ) : DCNL DCSP DCSP template _ pack = template _ pack &#91; 1 : ( -1 ) &#93; DCNL DCSP DCSP ALLOWED _ TEMPLATE _ PACKS = getattr ( settings , &apos; CRISPY _ ALLOWED _ TEMPLATE _ PACKS &apos; , ( &apos; bootstrap &apos; , &apos; uni _ form &apos; , &apos; bootstrap3 &apos; , &apos; bootstrap4 &apos; ) ) DCNL DCSP DCSP if ( template _ pack not in ALLOWED _ TEMPLATE _ PACKS ) : DCNL DCSP DCSP DCSP raise template.TemplateSyntaxError ( ( &quot; crispy DCSP tag &apos;s DCSP template _ pack DCSP argument DCSP should DCSP be DCSP in DCSP % s &quot; % str ( ALLOWED _ TEMPLATE _ PACKS ) ) ) DCNL DCSP return CrispyFormNode ( form , helper , template _ pack = template _ pack )
DCSP t.lexer.lineno + = t.value.count ( &apos; \ n &apos; ) DCNL DCSP return t
DCSP map = dict ( ) DCNL DCSP for entry in entry _ list : DCNL DCSP DCSP handler = entry.handler DCNL DCSP DCSP method _ str = ( ( handler.im _ self . _ _ name _ _ + &apos; .&apos; ) + handler.im _ func . _ _ name _ _ ) DCNL DCSP DCSP map &#91; method _ str &#93; = entry DCNL DCSP return map
DCSP env = builtins . _ _ xonsh _ env _ _ DCNL DCSP vd = env.get _ docs ( name ) DCNL DCSP if ( not vd.configurable ) : DCNL DCSP DCSP return DCNL DCSP default = vd.default DCNL DCSP if ( &apos; \ n &apos; in default ) : DCNL DCSP DCSP default = ( &apos; \ n &apos; + _ wrap _ paragraphs ( default , width = 69 ) ) DCNL DCSP curr = env.get ( name ) DCNL DCSP if ( is _ string ( curr ) and is _ template _ string ( curr ) ) : DCNL DCSP DCSP curr = curr.replace ( &apos; { &apos; , &apos; { { &apos; ) .replace ( &apos; } &apos; , &apos; } } &apos; ) DCNL DCSP curr = pprint.pformat ( curr , width = 69 ) DCNL DCSP if ( &apos; \ n &apos; in curr ) : DCNL DCSP DCSP curr = ( &apos; \ n &apos; + curr ) DCNL DCSP msg = ENVVAR _ MESSAGE.format ( name = name , default = default , current = curr , docstr = _ wrap _ paragraphs ( vd.docstr , width = 69 ) ) DCNL DCSP mnode = wiz.Message ( message = msg ) DCNL DCSP ens = env.get _ ensurer ( name ) DCNL DCSP path = ( &apos; / env / &apos; + name ) DCNL DCSP pnode = wiz.StoreNonEmpty ( ENVVAR _ PROMPT , converter = ens.convert , show _ conversion = True , path = path , retry = True , store _ raw = vd.store _ as _ str ) DCNL DCSP return ( mnode , pnode )
DCSP def float _ or _ nan ( v ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return float ( v ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP return nan DCNL DCSP entries = line.split ( &apos; DCTB &apos; ) DCNL DCSP return ( entries &#91; 0 &#93; , map ( float _ or _ nan , entries &#91; 1 : &#93; ) )
DCSP ( rows , cols ) = shape DCNL DCSP if ( not isinstance ( key , tuple ) ) : DCNL DCSP DCSP if ( rows = = 1 ) : DCNL DCSP DCSP DCSP key = ( slice ( 0 , 1 , None ) , key ) DCNL DCSP DCSP elif ( cols = = 1 ) : DCNL DCSP DCSP DCSP key = ( key , slice ( 0 , 1 , None ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise IndexError ( &apos; Invalid DCSP index / slice . &apos; ) DCNL DCSP key = ( format _ slice ( slc , dim ) for ( slc , dim ) in zip ( key , shape ) ) DCNL DCSP return tuple ( key )
DCSP if frappe.flags.in _ import : DCNL DCSP DCSP return DCNL DCSP if record _ list : DCNL DCSP DCSP for record in record _ list : DCNL DCSP DCSP DCSP write _ document _ file ( frappe.get _ doc ( record &#91; 0 &#93; , record &#91; 1 &#93; ) , record _ module , create _ init = create _ init )
DCSP args = dict ( &#91; ( key , association _ response _ values &#91; key &#93; ) for key in keys &#93; ) DCNL DCSP return Message.fromOpenIDArgs ( args )
DCSP s = u ( &apos; def DCSP x ( ) : \ n DCSP . &apos; ) DCNL DCSP m = ParserWithRecovery ( load _ grammar ( ) , s ) .module DCNL DCSP func = m.children &#91; 0 &#93; DCNL DCSP assert ( func.type = = &apos; funcdef &apos; ) DCNL DCSP assert ( func.end _ pos = = ( 3 , 0 ) ) DCNL DCSP assert ( m.end _ pos = = ( 2 , 2 ) )
DCSP func.argtypes = &#91; GEOM _ PTR &#93; DCNL DCSP func.restype = c _ int DCNL DCSP if zero : DCNL DCSP DCSP func.errcheck = check _ zero DCNL DCSP else : DCNL DCSP DCSP func.errcheck = check _ minus _ one DCNL DCSP return func
DCSP ( name , value ) = header DCNL DCSP if isinstance ( value , bytes ) : DCNL DCSP DCSP pat = _ CLEAN _ HEADER _ REGEX _ BYTE DCNL DCSP else : DCNL DCSP DCSP pat = _ CLEAN _ HEADER _ REGEX _ STR DCNL DCSP try : DCNL DCSP DCSP if ( not pat.match ( value ) ) : DCNL DCSP DCSP DCSP raise InvalidHeader ( ( &apos; Invalid DCSP return DCSP character DCSP or DCSP leading DCSP space DCSP in DCSP header : DCSP % s &apos; % name ) ) DCNL DCSP except TypeError : DCNL DCSP DCSP raise InvalidHeader ( ( &apos; Header DCSP value DCSP % s DCSP must DCSP be DCSP of DCSP type DCSP str DCSP or DCSP bytes , DCSP not DCSP % s &apos; % ( value , type ( value ) ) ) )
DCSP ring _ w = numpy.sum ( rings ) DCNL DCSP inner _ h = ( img.shape &#91; 1 &#93; - ( 2 * ring _ w ) ) DCNL DCSP inner _ w = ( img.shape &#91; 2 &#93; - ( 2 * ring _ w ) ) DCNL DCSP end _ idx = ( start _ idx + ( inner _ h * inner _ w ) ) DCNL DCSP inner _ img = dense _ input &#91; : , start _ idx : end _ idx &#93; .reshape ( ( -1 ) , inner _ h , inner _ w ) DCNL DCSP img &#91; : , ring _ w : ( ring _ w + inner _ h ) , ring _ w : ( ring _ w + inner _ w ) &#93; = inner _ img DCNL DCSP idx = 0 DCNL DCSP start _ idx = end _ idx DCNL DCSP for rd in rings : DCNL DCSP DCSP start _ idx = restore _ ring ( img , idx , rd , dense _ input , start _ idx ) DCNL DCSP DCSP idx + = rd DCNL DCSP return start _ idx
DCSP attrs = { &apos; database &apos; : &apos; database &apos; , &apos; timeout &apos; : &apos; timeout &apos; } DCNL DCSP _ options = salt.returners.get _ returner _ options ( _ _ virtualname _ _ , ret , attrs , _ _ salt _ _ = _ _ salt _ _ , _ _ opts _ _ = _ _ opts _ _ ) DCNL DCSP return _ options
DCSP deserializer = rpc.RPCJSONDeserializer ( ) DCNL DCSP serializer = rpc.RPCJSONSerializer ( ) DCNL DCSP return wsgi.Resource ( Controller ( ) , deserializer , serializer )
DCSP field _ re = re.compile ( &apos; _ _ { } _ _ \ \ s + = \ \ s + ( . * ) &apos; .format ( re.escape ( name ) ) ) DCNL DCSP path = os.path.join ( BASEDIR , &apos; qutebrowser &apos; , &apos; _ _ init _ _ .py &apos; ) DCNL DCSP line = field _ re.search ( read _ file ( path ) ) .group ( 1 ) DCNL DCSP value = ast.literal _ eval ( line ) DCNL DCSP return value
DCSP assert re.search ( expected , result ) , ( &apos; % s % r DCSP not DCSP found DCSP in DCSP % r &apos; % ( _ fmt _ msg ( msg ) , expected , result ) )
DCSP point _ count = 1000 DCNL DCSP x _ index = np.random.random ( point _ count ) DCNL DCSP y _ index = np.random.random ( point _ count ) DCNL DCSP color _ list = np.random.random ( point _ count ) DCNL DCSP scale _ list = ( np.random.random ( point _ count ) * 100 ) DCNL DCSP plt.scatter ( x _ index , y _ index , s = scale _ list , c = color _ list , marker = &apos; o &apos; ) DCNL DCSP plt.show ( ) DCNL DCSP return
DCSP uuid = util.wsgi _ path _ item ( req.environ , &apos; uuid &apos; ) DCNL DCSP context = req.environ &#91; &apos; placement.context &apos; &#93; DCNL DCSP resource _ provider = objects.ResourceProvider.get _ by _ uuid ( context , uuid ) DCNL DCSP req.response.body = encodeutils.to _ utf8 ( jsonutils.dumps ( _ serialize _ provider ( req.environ , resource _ provider ) ) ) DCNL DCSP req.response.content _ type = &apos; application / json &apos; DCNL DCSP return req.response
DCSP try : DCNL DCSP DCSP age _ in _ days = int ( age _ in _ days ) DCNL DCSP except ValueError : DCNL DCSP DCSP msg = ( _ ( &apos; Invalid DCSP value DCSP for DCSP age , DCSP % ( age ) s &apos; ) % { &apos; age &apos; : age _ in _ days } ) DCNL DCSP DCSP LOG.exception ( msg ) DCNL DCSP DCSP raise exception.InvalidParameterValue ( msg ) DCNL DCSP engine = get _ engine ( ) DCNL DCSP session = get _ session ( ) DCNL DCSP metadata = MetaData ( ) DCNL DCSP metadata.reflect ( engine ) DCNL DCSP for table in reversed ( metadata.sorted _ tables ) : DCNL DCSP DCSP if ( &apos; deleted &apos; not in table.columns.keys ( ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP LOG.info ( _ LI ( &apos; Purging DCSP deleted DCSP rows DCSP older DCSP than DCSP age = % ( age ) d DCSP days DCSP from DCSP table = % ( table ) s &apos; ) , { &apos; age &apos; : age _ in _ days , &apos; table &apos; : table } ) DCNL DCSP DCSP deleted _ age = ( timeutils.utcnow ( ) - dt.timedelta ( days = age _ in _ days ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with session.begin ( ) : DCNL DCSP DCSP DCSP DCSP if ( six.text _ type ( table ) = = &apos; quality _ of _ service _ specs &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP session.query ( models.QualityOfServiceSpecs ) .filter ( and _ ( models.QualityOfServiceSpecs.specs _ id.isnot ( None ) , ( models.QualityOfServiceSpecs.deleted = = 1 ) , ( models.QualityOfServiceSpecs.deleted _ at &lt; deleted _ age ) ) ) .delete ( ) DCNL DCSP DCSP DCSP DCSP result = session.execute ( table.delete ( ) .where ( ( table.c.deleted _ at &lt; deleted _ age ) ) ) DCNL DCSP DCSP except db _ exc.DBReferenceError as ex : DCNL DCSP DCSP DCSP LOG.error ( _ LE ( &apos; DBError DCSP detected DCSP when DCSP purging DCSP from DCSP % ( tablename ) s : DCSP % ( error ) s . &apos; ) , { &apos; tablename &apos; : table , &apos; error &apos; : six.text _ type ( ex ) } ) DCNL DCSP DCSP DCSP raise DCNL DCSP DCSP rows _ purged = result.rowcount DCNL DCSP DCSP if ( rows _ purged ! = 0 ) : DCNL DCSP DCSP DCSP LOG.info ( _ LI ( &apos; Deleted DCSP % ( row ) d DCSP rows DCSP from DCSP table = % ( table ) s &apos; ) , { &apos; row &apos; : rows _ purged , &apos; table &apos; : table } )
DCSP try : DCNL DCSP DCSP mod = _ _ import _ _ ( module _ name , fromlist = members ) DCNL DCSP except ImportError : DCNL DCSP DCSP return False DCNL DCSP for member in members : DCNL DCSP DCSP if ( not hasattr ( mod , member ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP realignflow = pe.Workflow ( name = name ) DCNL DCSP inputnode = pe.Node ( interface = util.IdentityInterface ( fields = &#91; u &apos;func &apos; &#93; ) , name = u &apos;inputspec &apos; ) DCNL DCSP outputnode = pe.Node ( interface = util.IdentityInterface ( fields = &#91; u &apos;realigned _ file &apos; &#93; ) , name = u &apos;outputspec &apos; ) DCNL DCSP realigner = pe.Node ( fsl.MCFLIRT ( save _ mats = True , stats _ imgs = True ) , name = u &apos;realigner &apos; ) DCNL DCSP splitter = pe.Node ( fsl.Split ( dimension = u &apos;t &apos; ) , name = u &apos;splitter &apos; ) DCNL DCSP warper = pe.MapNode ( fsl.ApplyWarp ( interp = u &apos;spline &apos; ) , iterfield = &#91; u &apos;in _ file &apos; , u &apos;premat &apos; &#93; , name = u &apos;warper &apos; ) DCNL DCSP joiner = pe.Node ( fsl.Merge ( dimension = u &apos;t &apos; ) , name = u &apos;joiner &apos; ) DCNL DCSP realignflow.connect ( inputnode , u &apos;func &apos; , realigner , u &apos;in _ file &apos; ) DCNL DCSP realignflow.connect ( inputnode , ( u &apos;func &apos; , select _ volume , u &apos;middle &apos; ) , realigner , u &apos;ref _ vol &apos; ) DCNL DCSP realignflow.connect ( realigner , u &apos;out _ file &apos; , splitter , u &apos;in _ file &apos; ) DCNL DCSP realignflow.connect ( realigner , u &apos;mat _ file &apos; , warper , u &apos;premat &apos; ) DCNL DCSP realignflow.connect ( realigner , u &apos;variance _ img &apos; , warper , u &apos;ref _ file &apos; ) DCNL DCSP realignflow.connect ( splitter , u &apos;out _ files &apos; , warper , u &apos;in _ file &apos; ) DCNL DCSP realignflow.connect ( warper , u &apos;out _ file &apos; , joiner , u &apos;in _ files &apos; ) DCNL DCSP realignflow.connect ( joiner , u &apos;merged _ file &apos; , outputnode , u &apos;realigned _ file &apos; ) DCNL DCSP return realignflow
DCSP return dmp _ div ( f , g , u , K ) &#91; 1 &#93;
DCSP if ( context.location ! = &apos; &apos; ) : DCNL DCSP DCSP return context.location DCNL DCSP context.location = None DCNL DCSP if getattr ( request , &apos; via _ cdn &apos; , False ) : DCNL DCSP DCSP g.stats.simple _ event ( &apos; geoip.cdn _ request &apos; ) DCNL DCSP DCSP cdn _ geoinfo = g.cdn _ provider.get _ client _ location ( request.environ ) DCNL DCSP DCSP if cdn _ geoinfo : DCNL DCSP DCSP DCSP context.location = cdn _ geoinfo DCNL DCSP elif getattr ( request , &apos; ip &apos; , None ) : DCNL DCSP DCSP g.stats.simple _ event ( &apos; geoip.non _ cdn _ request &apos; ) DCNL DCSP DCSP timer = g.stats.get _ timer ( &apos; providers.geoip.location _ by _ ips &apos; ) DCNL DCSP DCSP timer.start ( ) DCNL DCSP DCSP location = location _ by _ ips ( request.ip ) DCNL DCSP DCSP if location : DCNL DCSP DCSP DCSP context.location = location.get ( &apos; country _ code &apos; , None ) DCNL DCSP DCSP timer.stop ( ) DCNL DCSP return context.location
DCSP return IMPL.service _ get _ all _ by _ host ( context , host )
DCSP return parse.quote ( domain.replace ( &apos; .&apos; , &apos; % 2E &apos; ) )
DCSP cache _ key = ( u &apos; % s . % s . % s . &apos; % ( settings.CACHE _ MIDDLEWARE _ KEY _ PREFIX , current _ site _ id ( ) , ( device _ from _ request ( request ) or u &apos;default &apos; ) ) ) DCNL DCSP return _ i18n _ cache _ key _ suffix ( request , cache _ key )
DCSP assert _ nD ( data , 2 , &apos; data &apos; ) DCNL DCSP if ( predefined _ filter is None ) : DCNL DCSP DCSP predefined _ filter = LPIFilter2D ( impulse _ response , * * filter _ params ) DCNL DCSP return predefined _ filter ( data )
DCSP extern _ key = tobytes ( extern _ key ) DCNL DCSP if ( passphrase is not None ) : DCNL DCSP DCSP passphrase = tobytes ( passphrase ) DCNL DCSP if extern _ key.startswith ( b ( &apos; ----- &apos; ) ) : DCNL DCSP DCSP ( der , marker , enc _ flag ) = PEM.decode ( tostr ( extern _ key ) , passphrase ) DCNL DCSP DCSP if enc _ flag : DCNL DCSP DCSP DCSP passphrase = None DCNL DCSP DCSP return _ import _ keyDER ( der , passphrase ) DCNL DCSP if extern _ key.startswith ( b ( &apos; ssh-rsa DCSP &apos; ) ) : DCNL DCSP DCSP keystring = binascii.a2b _ base64 ( extern _ key.split ( b ( &apos; DCSP &apos; ) ) &#91; 1 &#93; ) DCNL DCSP DCSP keyparts = &#91; &#93; DCNL DCSP DCSP while ( len ( keystring ) &gt; 4 ) : DCNL DCSP DCSP DCSP l = struct.unpack ( &apos; &gt; I &apos; , keystring &#91; : 4 &#93; ) &#91; 0 &#93; DCNL DCSP DCSP DCSP keyparts.append ( keystring &#91; 4 : ( 4 + l ) &#93; ) DCNL DCSP DCSP DCSP keystring = keystring &#91; ( 4 + l ) : &#93; DCNL DCSP DCSP e = Integer.from _ bytes ( keyparts &#91; 1 &#93; ) DCNL DCSP DCSP n = Integer.from _ bytes ( keyparts &#91; 2 &#93; ) DCNL DCSP DCSP return construct ( &#91; n , e &#93; ) DCNL DCSP if ( bord ( extern _ key &#91; 0 &#93; ) = = 48 ) : DCNL DCSP DCSP return _ import _ keyDER ( extern _ key , passphrase ) DCNL DCSP raise ValueError ( &apos; RSA DCSP key DCSP format DCSP is DCSP not DCSP supported &apos; )
DCSP if ( ( not meta.has ( &apos; width &apos; ) ) or ( not meta.has ( &apos; height &apos; ) ) or ( not meta.has ( &apos; bits _ per _ pixel &apos; ) ) ) : DCNL DCSP DCSP return DCNL DCSP if ( not compr _ size ) : DCNL DCSP DCSP return DCNL DCSP orig _ size = ( ( meta.get ( &apos; width &apos; ) * meta.get ( &apos; height &apos; ) ) * meta.get ( &apos; bits _ per _ pixel &apos; ) ) DCNL DCSP meta.compr _ rate = ( float ( orig _ size ) / compr _ size )
DCSP if ( not checkout.child ( &apos; .svn &apos; ) .exists ( ) ) : DCNL DCSP DCSP raise NotWorkingDirectory ( ( &apos; % s DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP an DCSP SVN DCSP working DCSP directory . &apos; % ( checkout.path , ) ) ) DCNL DCSP if runCommand ( &#91; &apos; svn &apos; , &apos; st &apos; , checkout.path &#93; ) .strip ( ) : DCNL DCSP DCSP raise UncleanWorkingDirectory ( ( &apos; There DCSP are DCSP local DCSP modifications DCSP to DCSP the DCSP SVN DCSP checkout DCSP in DCSP % s . &apos; % ( checkout.path , ) ) ) DCNL DCSP workPath = FilePath ( mkdtemp ( ) ) DCNL DCSP export = workPath.child ( &apos; export &apos; ) DCNL DCSP runCommand ( &#91; &apos; svn &apos; , &apos; export &apos; , checkout.path , export.path &#93; ) DCNL DCSP twistedPath = export.child ( &apos; twisted &apos; ) DCNL DCSP version = Project ( twistedPath ) .getVersion ( ) DCNL DCSP versionString = version.base ( ) DCNL DCSP apiBaseURL = ( &apos; http : / / twistedmatrix.com / documents / % s / api / % % s.html &apos; % versionString ) DCNL DCSP if ( not destination.exists ( ) ) : DCNL DCSP DCSP destination.createDirectory ( ) DCNL DCSP db = DistributionBuilder ( export , destination , apiBaseURL = apiBaseURL ) DCNL DCSP db.buildCore ( versionString ) DCNL DCSP for subproject in twisted _ subprojects : DCNL DCSP DCSP if twistedPath.child ( subproject ) .exists ( ) : DCNL DCSP DCSP DCSP db.buildSubProject ( subproject , versionString ) DCNL DCSP db.buildTwisted ( versionString ) DCNL DCSP workPath.remove ( )
DCSP return SpSum ( axis , sparse _ grad ) ( x )
DCSP gui _ proxy = GUIProxy ( rpchandler , gui _ adap _ oid ) DCNL DCSP idb = Debugger.Idb ( gui _ proxy ) DCNL DCSP idb _ adap = IdbAdapter ( idb ) DCNL DCSP rpchandler.register ( idb _ adap _ oid , idb _ adap ) DCNL DCSP return idb _ adap _ oid
DCSP import optparse DCNL DCSP import textwrap DCNL DCSP usage = &apos; python DCSP web2py.py &apos; DCNL DCSP description = &quot; DCSP DCSP DCSP DCSP web2py DCSP Web DCSP Framework DCSP startup DCSP script . \ n DCSP DCSP DCSP DCSP ATTENTION : DCSP unless DCSP a DCSP password DCSP is DCSP specified DCSP ( -a DCSP &apos; passwd &apos; ) DCSP web2py DCSP will \ n DCSP DCSP DCSP DCSP attempt DCSP to DCSP run DCSP a DCSP GUI . DCSP In DCSP this DCSP case DCSP command DCSP line DCSP options DCSP are DCSP ignored . &quot; DCNL DCSP description = textwrap.dedent ( description ) DCNL DCSP parser = optparse.OptionParser ( usage , None , optparse.Option , ProgramVersion ) DCNL DCSP parser.description = description DCNL DCSP msg = &quot; IP DCSP address DCSP of DCSP the DCSP server DCSP ( e.g. , DCSP 127.0.0.1 DCSP or DCSP : : 1 ) ; DCSP Note : DCSP This DCSP value DCSP is DCSP ignored DCSP when DCSP using DCSP the DCSP &apos; interfaces &apos; DCSP option . &quot; DCNL DCSP parser.add _ option ( &apos; -i &apos; , &apos; --ip &apos; , default = &apos; 127.0.0.1 &apos; , dest = &apos; ip &apos; , help = msg ) DCNL DCSP parser.add _ option ( &apos; -p &apos; , &apos; --port &apos; , default = &apos; 8000 &apos; , dest = &apos; port &apos; , type = &apos; int &apos; , help = &apos; port DCSP of DCSP server DCSP ( 8000 ) &apos; ) DCNL DCSP parser.add _ option ( &apos; -G &apos; , &apos; --GAE &apos; , default = None , dest = &apos; gae &apos; , help = &quot; &apos; -G DCSP configure &apos; DCSP will DCSP create DCSP app.yaml DCSP and DCSP gaehandler.py &quot; ) DCNL DCSP msg = &apos; password DCSP to DCSP be DCSP used DCSP for DCSP administration DCSP ( use DCSP -a DCSP &quot; &lt; recycle &gt; &quot; DCSP to DCSP reuse DCSP the DCSP last DCSP password ) ) &apos; DCNL DCSP parser.add _ option ( &apos; -a &apos; , &apos; --password &apos; , default = &apos; &lt; ask &gt; &apos; , dest = &apos; password &apos; , help = msg ) DCNL DCSP parser.add _ option ( &apos; -c &apos; , &apos; --ssl _ certificate &apos; , default = &apos; &apos; , dest = &apos; ssl _ certificate &apos; , help = &apos; file DCSP that DCSP contains DCSP ssl DCSP certificate &apos; ) DCNL DCSP parser.add _ option ( &apos; -k &apos; , &apos; --ssl _ private _ key &apos; , default = &apos; &apos; , dest = &apos; ssl _ private _ key &apos; , help = &apos; file DCSP that DCSP contains DCSP ssl DCSP private DCSP key &apos; ) DCNL DCSP msg = &apos; Use DCSP this DCSP file DCSP containing DCSP the DCSP CA DCSP certificate DCSP to DCSP validate DCSP X509 DCSP certificates DCSP from DCSP clients &apos; DCNL DCSP parser.add _ option ( &apos; --ca-cert &apos; , action = &apos; store &apos; , dest = &apos; ssl _ ca _ certificate &apos; , default = None , help = msg ) DCNL DCSP parser.add _ option ( &apos; -d &apos; , &apos; --pid _ filename &apos; , default = &apos; httpserver.pid &apos; , dest = &apos; pid _ filename &apos; , help = &apos; file DCSP to DCSP store DCSP the DCSP pid DCSP of DCSP the DCSP server &apos; ) DCNL DCSP parser.add _ option ( &apos; -l &apos; , &apos; --log _ filename &apos; , default = &apos; httpserver.log &apos; , dest = &apos; log _ filename &apos; , help = &apos; file DCSP to DCSP log DCSP connections &apos; ) DCNL DCSP parser.add _ option ( &apos; -n &apos; , &apos; --numthreads &apos; , default = None , type = &apos; int &apos; , dest = &apos; numthreads &apos; , help = &apos; number DCSP of DCSP threads DCSP ( deprecated ) &apos; ) DCNL DCSP parser.add _ option ( &apos; --minthreads &apos; , default = None , type = &apos; int &apos; , dest = &apos; minthreads &apos; , help = &apos; minimum DCSP number DCSP of DCSP server DCSP threads &apos; ) DCNL DCSP parser.add _ option ( &apos; --maxthreads &apos; , default = None , type = &apos; int &apos; , dest = &apos; maxthreads &apos; , help = &apos; maximum DCSP number DCSP of DCSP server DCSP threads &apos; ) DCNL DCSP parser.add _ option ( &apos; -s &apos; , &apos; --server _ name &apos; , default = socket.gethostname ( ) , dest = &apos; server _ name &apos; , help = &apos; server DCSP name DCSP for DCSP the DCSP web DCSP server &apos; ) DCNL DCSP msg = &apos; max DCSP number DCSP of DCSP queued DCSP requests DCSP when DCSP server DCSP unavailable &apos; DCNL DCSP parser.add _ option ( &apos; -q &apos; , &apos; --request _ queue _ size &apos; , default = &apos; 5&apos; , type = &apos; int &apos; , dest = &apos; request _ queue _ size &apos; , help = msg ) DCNL DCSP parser.add _ option ( &apos; -o &apos; , &apos; --timeout &apos; , default = &apos; 10 &apos; , type = &apos; int &apos; , dest = &apos; timeout &apos; , help = &apos; timeout DCSP for DCSP individual DCSP request DCSP ( 10 DCSP seconds ) &apos; ) DCNL DCSP parser.add _ option ( &apos; -z &apos; , &apos; --shutdown _ timeout &apos; , default = &apos; 5&apos; , type = &apos; int &apos; , dest = &apos; shutdown _ timeout &apos; , help = &apos; timeout DCSP on DCSP shutdown DCSP of DCSP server DCSP ( 5 DCSP seconds ) &apos; ) DCNL DCSP parser.add _ option ( &apos; --socket-timeout &apos; , default = 5 , type = &apos; int &apos; , dest = &apos; socket _ timeout &apos; , help = &apos; timeout DCSP for DCSP socket DCSP ( 5 DCSP second ) &apos; ) DCNL DCSP parser.add _ option ( &apos; -f &apos; , &apos; --folder &apos; , default = os.getcwd ( ) , dest = &apos; folder &apos; , help = &apos; folder DCSP from DCSP which DCSP to DCSP run DCSP web2py &apos; ) DCNL DCSP parser.add _ option ( &apos; -v &apos; , &apos; --verbose &apos; , action = &apos; store _ true &apos; , dest = &apos; verbose &apos; , default = False , help = &apos; increase DCSP --test DCSP verbosity &apos; ) DCNL DCSP parser.add _ option ( &apos; -Q &apos; , &apos; --quiet &apos; , action = &apos; store _ true &apos; , dest = &apos; quiet &apos; , default = False , help = &apos; disable DCSP all DCSP output &apos; ) DCNL DCSP parser.add _ option ( &apos; -e &apos; , &apos; --errors _ to _ console &apos; , action = &apos; store _ true &apos; , dest = &apos; print _ errors &apos; , default = False , help = &apos; log DCSP all DCSP errors DCSP to DCSP console &apos; ) DCNL DCSP msg = &apos; set DCSP debug DCSP output DCSP level DCSP ( 0-100 , DCSP 0 DCSP means DCSP all , DCSP 100 DCSP means DCSP none ; DCSP default DCSP is DCSP 30 ) &apos; DCNL DCSP parser.add _ option ( &apos; -D &apos; , &apos; --debug &apos; , dest = &apos; debuglevel &apos; , default = 30 , type = &apos; int &apos; , help = msg ) DCNL DCSP msg = &apos; run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP IPython DCSP ( if DCSP installed ) DCSP with DCSP specified DCSP appname DCSP ( if DCSP app DCSP does DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP created ) . DCSP APPNAME DCSP like DCSP a / c / f DCSP ( c , f DCSP optional ) &apos; DCNL DCSP parser.add _ option ( &apos; -S &apos; , &apos; --shell &apos; , dest = &apos; shell &apos; , metavar = &apos; APPNAME &apos; , help = msg ) DCNL DCSP msg = &apos; run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP bpython DCSP ( if DCSP installed ) DCSP with DCSP specified DCSP appname DCSP ( if DCSP app DCSP does DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP created ) . \ nUse DCSP combined DCSP with DCSP --shell &apos; DCNL DCSP parser.add _ option ( &apos; -B &apos; , &apos; --bpython &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; bpython &apos; , help = msg ) DCNL DCSP msg = &apos; only DCSP use DCSP plain DCSP python DCSP shell ; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option &apos; DCNL DCSP parser.add _ option ( &apos; -P &apos; , &apos; --plain &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; plain &apos; , help = msg ) DCNL DCSP msg = &apos; auto DCSP import DCSP model DCSP files ; DCSP default DCSP is DCSP False ; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option &apos; DCNL DCSP parser.add _ option ( &apos; -M &apos; , &apos; --import _ models &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; import _ models &apos; , help = msg ) DCNL DCSP msg = &apos; run DCSP PYTHON _ FILE DCSP in DCSP web2py DCSP environment ; DCSP should DCSP be DCSP used DCSP with DCSP --shell DCSP option &apos; DCNL DCSP parser.add _ option ( &apos; -R &apos; , &apos; --run &apos; , dest = &apos; run &apos; , metavar = &apos; PYTHON _ FILE &apos; , default = &apos; &apos; , help = msg ) DCNL DCSP msg = &apos; run DCSP scheduled DCSP tasks DCSP for DCSP the DCSP specified DCSP apps : DCSP expects DCSP a DCSP list DCSP of DCSP app DCSP names DCSP as DCSP -K DCSP app1 , app2 , app3 DCSP or DCSP a DCSP list DCSP of DCSP app : groups DCSP as DCSP -K DCSP app1 : group1 : group2 , app2 : group1 DCSP to DCSP override DCSP specific DCSP group _ names . DCSP ( only DCSP strings , DCSP no DCSP spaces DCSP allowed . DCSP Requires DCSP a DCSP scheduler DCSP defined DCSP in DCSP the DCSP models &apos; DCNL DCSP parser.add _ option ( &apos; -K &apos; , &apos; --scheduler &apos; , dest = &apos; scheduler &apos; , default = None , help = msg ) DCNL DCSP msg = &apos; run DCSP schedulers DCSP alongside DCSP webserver , DCSP needs DCSP -K DCSP app1 DCSP and DCSP -a DCSP too &apos; DCNL DCSP parser.add _ option ( &apos; -X &apos; , &apos; --with-scheduler &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; with _ scheduler &apos; , help = msg ) DCNL DCSP msg = &apos; run DCSP doctests DCSP in DCSP web2py DCSP environment ; DCSP TEST _ PATH DCSP like DCSP a / c / f DCSP ( c , f DCSP optional ) &apos; DCNL DCSP parser.add _ option ( &apos; -T &apos; , &apos; --test &apos; , dest = &apos; test &apos; , metavar = &apos; TEST _ PATH &apos; , default = None , help = msg ) DCNL DCSP msg = &apos; trigger DCSP a DCSP cron DCSP run DCSP manually ; DCSP usually DCSP invoked DCSP from DCSP a DCSP system DCSP crontab &apos; DCNL DCSP parser.add _ option ( &apos; -C &apos; , &apos; --cron &apos; , action = &apos; store _ true &apos; , dest = &apos; extcron &apos; , default = False , help = msg ) DCNL DCSP msg = &apos; triggers DCSP the DCSP use DCSP of DCSP softcron &apos; DCNL DCSP parser.add _ option ( &apos; --softcron &apos; , action = &apos; store _ true &apos; , dest = &apos; softcron &apos; , default = False , help = msg ) DCNL DCSP parser.add _ option ( &apos; -Y &apos; , &apos; --run-cron &apos; , action = &apos; store _ true &apos; , dest = &apos; runcron &apos; , default = False , help = &apos; start DCSP the DCSP background DCSP cron DCSP process &apos; ) DCNL DCSP parser.add _ option ( &apos; -J &apos; , &apos; --cronjob &apos; , action = &apos; store _ true &apos; , dest = &apos; cronjob &apos; , default = False , help = &apos; identify DCSP cron-initiated DCSP command &apos; ) DCNL DCSP parser.add _ option ( &apos; -L &apos; , &apos; --config &apos; , dest = &apos; config &apos; , default = &apos; &apos; , help = &apos; config DCSP file &apos; ) DCNL DCSP parser.add _ option ( &apos; -F &apos; , &apos; --profiler &apos; , dest = &apos; profiler _ dir &apos; , default = None , help = &apos; profiler DCSP dir &apos; ) DCNL DCSP parser.add _ option ( &apos; -t &apos; , &apos; --taskbar &apos; , action = &apos; store _ true &apos; , dest = &apos; taskbar &apos; , default = False , help = &apos; use DCSP web2py DCSP gui DCSP and DCSP run DCSP in DCSP taskbar DCSP ( system DCSP tray ) &apos; ) DCNL DCSP parser.add _ option ( &apos; &apos; , &apos; --nogui &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; nogui &apos; , help = &apos; text-only , DCSP no DCSP GUI &apos; ) DCNL DCSP msg = &apos; should DCSP be DCSP followed DCSP by DCSP a DCSP list DCSP of DCSP arguments DCSP to DCSP be DCSP passed DCSP to DCSP script , DCSP to DCSP be DCSP used DCSP with DCSP -S , DCSP -A DCSP must DCSP be DCSP the DCSP last DCSP option &apos; DCNL DCSP parser.add _ option ( &apos; -A &apos; , &apos; --args &apos; , action = &apos; store &apos; , dest = &apos; args &apos; , default = None , help = msg ) DCNL DCSP parser.add _ option ( &apos; --no-banner &apos; , action = &apos; store _ true &apos; , default = False , dest = &apos; nobanner &apos; , help = &apos; Do DCSP not DCSP print DCSP header DCSP banner &apos; ) DCNL DCSP msg = &apos; listen DCSP on DCSP multiple DCSP addresses : DCSP &quot; ip1 : port1 : key1 : cert1 : ca _ cert1 ; ip2 : port2 : key2 : cert2 : ca _ cert2 ; ... &quot; DCSP ( : key : cert : ca _ cert DCSP optional ; DCSP no DCSP spaces ; DCSP IPv6 DCSP addresses DCSP must DCSP be DCSP in DCSP square DCSP &#91; &#93; DCSP brackets ) &apos; DCNL DCSP parser.add _ option ( &apos; --interfaces &apos; , action = &apos; store &apos; , dest = &apos; interfaces &apos; , default = None , help = msg ) DCNL DCSP msg = &apos; runs DCSP web2py DCSP tests &apos; DCNL DCSP parser.add _ option ( &apos; --run _ system _ tests &apos; , action = &apos; store _ true &apos; , dest = &apos; run _ system _ tests &apos; , default = False , help = msg ) DCNL DCSP msg = &apos; adds DCSP coverage DCSP reporting DCSP ( needs DCSP --run _ system _ tests ) , DCSP python DCSP 2.7 DCSP and DCSP the DCSP coverage DCSP module DCSP installed . DCSP You DCSP can DCSP alter DCSP the DCSP default DCSP path DCSP setting DCSP the DCSP environmental DCSP var DCSP &quot; COVERAGE _ PROCESS _ START &quot; . DCSP By DCSP default DCSP it DCSP takes DCSP gluon / tests / coverage.ini &apos; DCNL DCSP parser.add _ option ( &apos; --with _ coverage &apos; , action = &apos; store _ true &apos; , dest = &apos; with _ coverage &apos; , default = False , help = msg ) DCNL DCSP if ( &apos; -A &apos; in sys.argv ) : DCNL DCSP DCSP k = sys.argv.index ( &apos; -A &apos; ) DCNL DCSP elif ( &apos; --args &apos; in sys.argv ) : DCNL DCSP DCSP k = sys.argv.index ( &apos; --args &apos; ) DCNL DCSP else : DCNL DCSP DCSP k = len ( sys.argv ) DCNL DCSP ( sys.argv , other _ args ) = ( sys.argv &#91; : k &#93; , sys.argv &#91; ( k + 1 ) : &#93; ) DCNL DCSP ( options , args ) = parser.parse _ args ( ) DCNL DCSP options.args = ( &#91; options.run &#93; + other _ args ) DCNL DCSP copy _ options = copy.deepcopy ( options ) DCNL DCSP copy _ options.password = &apos; * * * * * * &apos; DCNL DCSP global _ settings.cmd _ options = copy _ options DCNL DCSP global _ settings.cmd _ args = args DCNL DCSP if options.gae : DCNL DCSP DCSP if ( not os.path.exists ( &apos; app.yaml &apos; ) ) : DCNL DCSP DCSP DCSP name = raw _ input ( &apos; Your DCSP GAE DCSP app DCSP name : DCSP &apos; ) DCNL DCSP DCSP DCSP content = open ( os.path.join ( &apos; examples &apos; , &apos; app.example.yaml &apos; ) , &apos; rb &apos; ) .read ( ) DCNL DCSP DCSP DCSP open ( &apos; app.yaml &apos; , &apos; wb &apos; ) .write ( content.replace ( &apos; yourappname &apos; , name ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP print ( &apos; app.yaml DCSP alreday DCSP exists DCSP in DCSP the DCSP web2py DCSP folder &apos; ) DCNL DCSP DCSP if ( not os.path.exists ( &apos; gaehandler.py &apos; ) ) : DCNL DCSP DCSP DCSP content = open ( os.path.join ( &apos; handlers &apos; , &apos; gaehandler.py &apos; ) , &apos; rb &apos; ) .read ( ) DCNL DCSP DCSP DCSP open ( &apos; gaehandler.py &apos; , &apos; wb &apos; ) .write ( content ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP print ( &apos; gaehandler.py DCSP alreday DCSP exists DCSP in DCSP the DCSP web2py DCSP folder &apos; ) DCNL DCSP DCSP sys.exit ( 0 ) DCNL DCSP try : DCNL DCSP DCSP options.ips = list ( set ( &#91; addrinfo &#91; 4 &#93; &#91; 0 &#93; for addrinfo in getipaddrinfo ( socket.getfqdn ( ) ) if ( not is _ loopback _ ip _ address ( addrinfo = addrinfo ) ) &#93; ) ) DCNL DCSP except socket.gaierror : DCNL DCSP DCSP options.ips = &#91; &#93; DCNL DCSP if options.run _ system _ tests : DCNL DCSP DCSP run _ system _ tests ( options ) DCNL DCSP if options.quiet : DCNL DCSP DCSP capture = StringIO ( ) DCNL DCSP DCSP sys.stdout = capture DCNL DCSP DCSP logger.setLevel ( ( logging.CRITICAL + 1 ) ) DCNL DCSP else : DCNL DCSP DCSP logger.setLevel ( options.debuglevel ) DCNL DCSP if ( options.config &#91; ( -3 ) : &#93; = = &apos; .py &apos; ) : DCNL DCSP DCSP options.config = options.config &#91; : ( -3 ) &#93; DCNL DCSP if options.cronjob : DCNL DCSP DCSP global _ settings.cronjob = True DCNL DCSP DCSP options.plain = True DCNL DCSP DCSP options.nobanner = True DCNL DCSP DCSP options.nogui = True DCNL DCSP options.folder = os.path.abspath ( options.folder ) DCNL DCSP if isinstance ( options.interfaces , str ) : DCNL DCSP DCSP interfaces = options.interfaces.split ( &apos; ; &apos; ) DCNL DCSP DCSP options.interfaces = &#91; &#93; DCNL DCSP DCSP for interface in interfaces : DCNL DCSP DCSP DCSP if interface.startswith ( &apos; &#91; &apos; ) : DCNL DCSP DCSP DCSP DCSP ( ip , if _ remainder ) = interface.split ( &apos; &#93; &apos; , 1 ) DCNL DCSP DCSP DCSP DCSP ip = ip &#91; 1 : &#93; DCNL DCSP DCSP DCSP DCSP if _ remainder = if _ remainder &#91; 1 : &#93; .split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP DCSP if _ remainder &#91; 0 &#93; = int ( if _ remainder &#91; 0 &#93; ) DCNL DCSP DCSP DCSP DCSP options.interfaces.append ( tuple ( ( &#91; ip &#93; + if _ remainder ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP interface = interface.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP DCSP interface &#91; 1 &#93; = int ( interface &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP options.interfaces.append ( tuple ( interface ) ) DCNL DCSP scheduler = &#91; &#93; DCNL DCSP options.scheduler _ groups = None DCNL DCSP if isinstance ( options.scheduler , str ) : DCNL DCSP DCSP if ( &apos; : &apos; in options.scheduler ) : DCNL DCSP DCSP DCSP for opt in options.scheduler.split ( &apos; , &apos; ) : DCNL DCSP DCSP DCSP DCSP scheduler.append ( opt.split ( &apos; : &apos; ) ) DCNL DCSP DCSP DCSP options.scheduler = &apos; , &apos; .join ( &#91; app &#91; 0 &#93; for app in scheduler &#93; ) DCNL DCSP DCSP DCSP options.scheduler _ groups = scheduler DCNL DCSP if ( ( options.numthreads is not None ) and ( options.minthreads is None ) ) : DCNL DCSP DCSP options.minthreads = options.numthreads DCNL DCSP create _ welcome _ w2p ( ) DCNL DCSP if ( not options.cronjob ) : DCNL DCSP DCSP if ( not os.path.exists ( &apos; applications / _ _ init _ _ .py &apos; ) ) : DCNL DCSP DCSP DCSP write _ file ( &apos; applications / _ _ init _ _ .py &apos; , &apos; &apos; ) DCNL DCSP return ( options , args )
DCSP if ( pattern is None ) : DCNL DCSP DCSP pattern = sickbeard.NAMING _ PATTERN DCNL DCSP logger.log ( ( ( u &apos;Checking DCSP whether DCSP the DCSP pattern DCSP &apos; + pattern ) + u &apos; DCSP is DCSP valid DCSP for DCSP an DCSP air-by-date DCSP episode &apos; ) , logger.DEBUG ) DCNL DCSP valid = validate _ name ( pattern , abd = True ) DCNL DCSP return valid
DCSP view _ link = frappe.utils.cint ( frappe.db.get _ value ( u &apos;Print DCSP Settings &apos; , u &apos;Print DCSP Settings &apos; , u &apos;attach _ view _ link &apos; ) ) DCNL DCSP if ( print _ format and view _ link ) : DCNL DCSP DCSP doc.content + = get _ attach _ link ( doc , print _ format ) DCNL DCSP set _ incoming _ outgoing _ accounts ( doc ) DCNL DCSP if ( not doc.sender ) : DCNL DCSP DCSP doc.sender = doc.outgoing _ email _ account.email _ id DCNL DCSP if ( not doc.sender _ full _ name ) : DCNL DCSP DCSP doc.sender _ full _ name = ( doc.outgoing _ email _ account.name or _ ( u &apos;Notification &apos; ) ) DCNL DCSP if doc.sender : DCNL DCSP DCSP doc.sender = formataddr ( &#91; doc.sender _ full _ name , doc.sender &#93; ) DCNL DCSP doc.attachments = &#91; &#93; DCNL DCSP if ( print _ html or print _ format ) : DCNL DCSP DCSP doc.attachments.append ( frappe.attach _ print ( doc.reference _ doctype , doc.reference _ name , print _ format = print _ format , html = print _ html ) ) DCNL DCSP if attachments : DCNL DCSP DCSP if isinstance ( attachments , basestring ) : DCNL DCSP DCSP DCSP attachments = json.loads ( attachments ) DCNL DCSP DCSP for a in attachments : DCNL DCSP DCSP DCSP if isinstance ( a , basestring ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP file = get _ file ( a ) DCNL DCSP DCSP DCSP DCSP DCSP doc.attachments.append ( { u &apos;fname &apos; : file &#91; 0 &#93; , u &apos;fcontent &apos; : file &#91; 1 &#93; } ) DCNL DCSP DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP DCSP frappe.throw ( _ ( u &apos;Unable DCSP to DCSP find DCSP attachment DCSP { 0 } &apos; ) .format ( a ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP doc.attachments.append ( a )
DCSP request = context.get ( u &apos;request &apos; ) DCNL DCSP siteconfig = SiteConfiguration.objects.get ( site = Site.objects.get _ current ( ) ) DCNL DCSP widget _ states = siteconfig.get ( u &apos;widget _ settings &apos; ) DCNL DCSP if widget _ states : DCNL DCSP DCSP widget.collapsed = ( widget _ states.get ( widget.name , u &apos; 0 &apos; ) ! = u &apos; 0 &apos; ) DCNL DCSP else : DCNL DCSP DCSP widget.collapsed = False DCNL DCSP return widget.render ( request )
DCSP if undirected : DCNL DCSP DCSP if ( distance is not None ) : DCNL DCSP DCSP DCSP ( sp , _ ) = nx.single _ source _ dijkstra ( G.to _ undirected ( ) , n , cutoff = radius , weight = distance ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sp = dict ( nx.single _ source _ shortest _ path _ length ( G.to _ undirected ( ) , n , cutoff = radius ) ) DCNL DCSP elif ( distance is not None ) : DCNL DCSP DCSP ( sp , _ ) = nx.single _ source _ dijkstra ( G , n , cutoff = radius , weight = distance ) DCNL DCSP else : DCNL DCSP DCSP sp = dict ( nx.single _ source _ shortest _ path _ length ( G , n , cutoff = radius ) ) DCNL DCSP H = G.subgraph ( sp ) .copy ( ) DCNL DCSP if ( not center ) : DCNL DCSP DCSP H.remove _ node ( n ) DCNL DCSP return H
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : False , &apos; comment &apos; : &apos; &apos; } DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP return _ test _ output ( ret , &apos; delete &apos; , params = { &apos; hostname &apos; : hostname , &apos; username &apos; : username , &apos; password &apos; : password , &apos; name &apos; : name , &apos; members &apos; : member } ) DCNL DCSP existing = _ _ salt _ _ &#91; &apos; bigip.list _ pool &apos; &#93; ( hostname , username , password , name ) DCNL DCSP if ( existing &#91; &apos; code &apos; &#93; = = 200 ) : DCNL DCSP DCSP current _ members = existing &#91; &apos; content &apos; &#93; &#91; &apos; membersReference &apos; &#93; &#91; &apos; items &apos; &#93; DCNL DCSP DCSP exists = False DCNL DCSP DCSP for current _ member in current _ members : DCNL DCSP DCSP DCSP if ( current _ member &#91; &apos; name &apos; &#93; = = member ) : DCNL DCSP DCSP DCSP DCSP exists = True DCNL DCSP DCSP DCSP DCSP existing _ member = current _ member DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if exists : DCNL DCSP DCSP DCSP deleted = _ _ salt _ _ &#91; &apos; bigip.delete _ pool _ member &apos; &#93; ( hostname , username , password , name , member ) DCNL DCSP DCSP DCSP if ( deleted &#91; &apos; code &apos; &#93; = = 200 ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Pool DCSP Member : DCSP { member } DCSP was DCSP successfully DCSP deleted . &apos; .format ( member = member ) DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; old &apos; &#93; = existing _ member DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = { } DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; This DCSP pool DCSP member DCSP already DCSP does DCSP not DCSP exist . DCSP No DCSP changes DCSP made . &apos; DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; old &apos; &#93; = { } DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = { } DCNL DCSP else : DCNL DCSP DCSP ret = _ load _ result ( existing , ret ) DCNL DCSP return ret
DCSP return ( dirname , glob ( os.path.join ( dirname , entry ) ) )
DCSP if callable ( using ) : DCNL DCSP DCSP return CommitOnSuccessManager ( DEFAULT _ DB _ ALIAS , read _ committed ) ( using ) DCNL DCSP else : DCNL DCSP DCSP return CommitOnSuccessManager ( using , read _ committed )
DCSP if transform : DCNL DCSP DCSP if ( transform is np.log ) : DCNL DCSP DCSP DCSP x1 = transform ( x1 ) DCNL DCSP DCSP DCSP x2 = transform ( x2 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP xx = transform ( np.concatenate ( ( x1 , x2 ) , 0 ) ) DCNL DCSP DCSP DCSP x1 = xx &#91; : len ( x1 ) &#93; DCNL DCSP DCSP DCSP x2 = xx &#91; len ( x1 ) : &#93; DCNL DCSP DCSP low = transform ( low ) DCNL DCSP DCSP upp = transform ( upp ) DCNL DCSP dd = DescrStatsW ( ( x1 - x2 ) , weights = weights , ddof = 0 ) DCNL DCSP ( t1 , pv1 , df1 ) = dd.ttest _ mean ( low , alternative = &apos; larger &apos; ) DCNL DCSP ( t2 , pv2 , df2 ) = dd.ttest _ mean ( upp , alternative = &apos; smaller &apos; ) DCNL DCSP return ( np.maximum ( pv1 , pv2 ) , ( t1 , pv1 , df1 ) , ( t2 , pv2 , df2 ) )
DCSP if callable ( formstyle ) : DCNL DCSP DCSP row = formstyle ( row _ id , label , widget , comment ) DCNL DCSP DCSP if isinstance ( row , ( tuple , list ) ) : DCNL DCSP DCSP DCSP for subrow in row : DCNL DCSP DCSP DCSP DCSP form &#91; 0 &#93; .insert ( position , subrow ) DCNL DCSP DCSP DCSP DCSP if ( position &gt; = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP position + = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP form &#91; 0 &#93; .insert ( position , row ) DCNL DCSP else : DCNL DCSP DCSP addrow ( form , label , widget , comment , formstyle , row _ id , position = position ) DCNL DCSP return
DCSP params = { &apos; expected &apos; : expected , &apos; result &apos; : result } DCNL DCSP aka = ( &apos; \ n \ n--------------------------------- DCSP aka DCSP ----------------------------------------- \ n \ nExpected : \ n % ( expected ) r \ n \ nGot : \ n % ( result ) r \ n &apos; % params ) DCNL DCSP default _ msg = ( &apos; \ nExpected : \ n % ( expected ) s \ n \ nGot : \ n % ( result ) s \ n &apos; % params ) DCNL DCSP if ( ( repr ( result ) ! = str ( result ) ) or ( repr ( expected ) ! = str ( expected ) ) ) : DCNL DCSP DCSP default _ msg + = aka DCNL DCSP assert ( result = = expected ) , ( msg or default _ msg )
DCSP pdef = base _ param ( registry , xml _ parent , data , False , &apos; eu.markov.jenkins.plugin.mvnmeta.MavenMetadataParameterDefinition &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; repoBaseUrl &apos; ) .text = data.get ( &apos; repository-base-url &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; groupId &apos; ) .text = data.get ( &apos; artifact-group-id &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; artifactId &apos; ) .text = data.get ( &apos; artifact-id &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; packaging &apos; ) .text = data.get ( &apos; packaging &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; defaultValue &apos; ) .text = data.get ( &apos; default-value &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; versionFilter &apos; ) .text = data.get ( &apos; versions-filter &apos; , &apos; &apos; ) DCNL DCSP sort _ order = data.get ( &apos; sorting-order &apos; , &apos; descending &apos; ) .lower ( ) DCNL DCSP sort _ dict = { &apos; descending &apos; : &apos; DESC &apos; , &apos; ascending &apos; : &apos; ASC &apos; } DCNL DCSP if ( sort _ order not in sort _ dict ) : DCNL DCSP DCSP raise InvalidAttributeError ( sort _ order , sort _ order , sort _ dict.keys ( ) ) DCNL DCSP XML.SubElement ( pdef , &apos; sortOrder &apos; ) .text = sort _ dict &#91; sort _ order &#93; DCNL DCSP XML.SubElement ( pdef , &apos; maxVersions &apos; ) .text = str ( data.get ( &apos; maximum-versions-to-display &apos; , 10 ) ) DCNL DCSP XML.SubElement ( pdef , &apos; username &apos; ) .text = data.get ( &apos; repository-username &apos; , &apos; &apos; ) DCNL DCSP XML.SubElement ( pdef , &apos; password &apos; ) .text = data.get ( &apos; repository-password &apos; , &apos; &apos; )
DCSP if ( not is _ partition ( G , communities ) ) : DCNL DCSP DCSP raise NotAPartition ( G , communities ) DCNL DCSP multigraph = G.is _ multigraph ( ) DCNL DCSP directed = G.is _ directed ( ) DCNL DCSP m = G.size ( weight = weight ) DCNL DCSP if directed : DCNL DCSP DCSP out _ degree = dict ( G.out _ degree ( weight = weight ) ) DCNL DCSP DCSP in _ degree = dict ( G.in _ degree ( weight = weight ) ) DCNL DCSP DCSP norm = ( 1 / m ) DCNL DCSP else : DCNL DCSP DCSP out _ degree = dict ( G.degree ( weight = weight ) ) DCNL DCSP DCSP in _ degree = out _ degree DCNL DCSP DCSP norm = ( 1 / ( 2 * m ) ) DCNL DCSP def val ( u , v ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if multigraph : DCNL DCSP DCSP DCSP DCSP w = sum ( ( d.get ( weight , 1 ) for ( k , d ) in G &#91; u &#93; &#91; v &#93; .items ( ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP w = G &#91; u &#93; &#91; v &#93; .get ( weight , 1 ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP w = 0 DCNL DCSP DCSP if ( ( u = = v ) and ( not directed ) ) : DCNL DCSP DCSP DCSP w * = 2 DCNL DCSP DCSP return ( w - ( ( in _ degree &#91; u &#93; * out _ degree &#91; v &#93; ) * norm ) ) DCNL DCSP Q = sum ( ( val ( u , v ) for c in communities for ( u , v ) in product ( c , repeat = 2 ) ) ) DCNL DCSP return ( Q * norm )
DCSP try : DCNL DCSP DCSP dot = path.rindex ( &apos; .&apos; ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise ValueError ( ( &quot; Error DCSP loading DCSP object DCSP &apos; % s &apos; : DCSP not DCSP a DCSP full DCSP path &quot; % path ) ) DCNL DCSP ( module , name ) = ( path &#91; : dot &#93; , path &#91; ( dot + 1 ) : &#93; ) DCNL DCSP mod = import _ module ( module ) DCNL DCSP try : DCNL DCSP DCSP obj = getattr ( mod , name ) DCNL DCSP except AttributeError : DCNL DCSP DCSP raise NameError ( ( &quot; Module DCSP &apos; % s &apos; DCSP doesn &apos;t DCSP define DCSP any DCSP object DCSP named DCSP &apos; % s &apos; &quot; % ( module , name ) ) ) DCNL DCSP return obj
DCSP hsrc = win32api.LoadLibraryEx ( filename , 0 , LOAD _ LIBRARY _ AS _ DATAFILE ) DCNL DCSP res = _ GetResources ( hsrc , types , names , languages ) DCNL DCSP win32api.FreeLibrary ( hsrc ) DCNL DCSP return res
DCSP def prep ( r ) : DCNL DCSP DCSP if r.component : DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; translate &apos; ) : DCNL DCSP DCSP DCSP DCSP table = s3db.survey _ translate DCNL DCSP DCSP DCSP DCSP if ( r.component _ id = = None ) : DCNL DCSP DCSP DCSP DCSP DCSP table.file.readable = False DCNL DCSP DCSP DCSP DCSP DCSP table.file.writable = False DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP table.language.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.code.writable = False DCNL DCSP DCSP DCSP DCSP s3db.configure ( &apos; survey _ translate &apos; , deletable = False ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP table = r.table DCNL DCSP DCSP DCSP s3 _ action _ buttons ( r ) DCNL DCSP DCSP DCSP rows = db ( ( table.status = = 1 ) ) .select ( table.id ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP s3.actions &#91; 1 &#93; &#91; &apos; restrict &apos; &#93; .extend ( ( str ( row.id ) for row in rows ) ) DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP s3.actions &#91; 1 &#93; &#91; &apos; restrict &apos; &#93; = &#91; str ( row.id ) for row in rows &#93; DCNL DCSP DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP s3.dataTableStyleAlert = &#91; str ( row.id ) for row in rows &#93; DCNL DCSP DCSP DCSP rows = db ( ( table.status = = 3 ) ) .select ( table.id ) DCNL DCSP DCSP DCSP s3.dataTableStyleDisabled = &#91; str ( row.id ) for row in rows &#93; DCNL DCSP DCSP DCSP s3.dataTableStyleWarning = &#91; str ( row.id ) for row in rows &#93; DCNL DCSP DCSP DCSP rows = db ( ( table.status = = 4 ) ) .select ( table.id ) DCNL DCSP DCSP DCSP s3.dataTableStyleWarning.extend ( ( str ( row.id ) for row in rows ) ) DCNL DCSP DCSP DCSP s3db.configure ( &apos; survey _ template &apos; , orderby = &apos; survey _ template.status &apos; , create _ next = URL ( c = &apos; survey &apos; , f = &apos; template &apos; ) , update _ next = URL ( c = &apos; survey &apos; , f = &apos; template &apos; ) ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if r.component : DCNL DCSP DCSP DCSP template _ id = r.id DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; translate &apos; ) : DCNL DCSP DCSP DCSP DCSP s3 _ action _ buttons ( r ) DCNL DCSP DCSP DCSP DCSP s3.actions.extend ( &#91; dict ( label = str ( T ( &apos; Download &apos; ) ) , _ class = &apos; action-btn &apos; , url = r.url ( method = &apos; translate _ download &apos; , component = &apos; translate &apos; , component _ id = &apos; &#91; id &#93; &apos; , representation = &apos; xls &apos; ) ) , dict ( label = str ( T ( &apos; Upload &apos; ) ) , _ class = &apos; action-btn &apos; , url = URL ( c = module , f = &apos; template &apos; , args = &#91; template _ id , &apos; translate &apos; , &apos; &#91; id &#93; &apos; &#93; ) ) &#93; ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if request.ajax : DCNL DCSP DCSP post = request.post _ vars DCNL DCSP DCSP action = post.get ( &apos; action &apos; ) DCNL DCSP DCSP template _ id = post.get ( &apos; parent _ id &apos; ) DCNL DCSP DCSP section _ id = post.get ( &apos; section _ id &apos; ) DCNL DCSP DCSP section _ text = post.get ( &apos; section _ text &apos; ) DCNL DCSP DCSP if ( ( action = = &apos; section &apos; ) and ( template _ id ! = None ) ) : DCNL DCSP DCSP DCSP id = db.survey _ section.insert ( name = section _ text , template _ id = template _ id , cloned _ section _ id = section _ id ) DCNL DCSP DCSP DCSP if ( id is None ) : DCNL DCSP DCSP DCSP DCSP print &apos; Failed DCSP to DCSP insert DCSP record &apos; DCNL DCSP DCSP DCSP return DCNL DCSP s3db.configure ( &apos; survey _ template &apos; , listadd = False ) DCNL DCSP output = s3 _ rest _ controller ( rheader = s3db.survey _ template _ rheader ) DCNL DCSP return output
DCSP ret = _ sync ( &apos; output &apos; , saltenv ) DCNL DCSP if refresh : DCNL DCSP DCSP refresh _ modules ( ) DCNL DCSP return ret
DCSP con = _ conn ( queue ) DCNL DCSP with con : DCNL DCSP DCSP cur = con.cursor ( ) DCNL DCSP DCSP cmd = &apos; SELECT DCSP name DCSP FROM DCSP { 0 } &apos; .format ( queue ) DCNL DCSP DCSP log.debug ( &apos; SQL DCSP Query : DCSP { 0 } &apos; .format ( cmd ) ) DCNL DCSP DCSP cur.execute ( cmd ) DCNL DCSP DCSP contents = cur.fetchall ( ) DCNL DCSP return contents
DCSP assert _ raises ( BundleError , bundle _ to _ joblist , Bundle ( Bundle ( &apos; s1 &apos; , output = &apos; foo &apos; ) , Bundle ( &apos; s2 &apos; , output = &apos; foo &apos; ) ) )
DCSP closeness = { } DCNL DCSP path _ length = nx.single _ source _ shortest _ path _ length DCNL DCSP top = set ( nodes ) DCNL DCSP bottom = ( set ( G ) - top ) DCNL DCSP n = float ( len ( top ) ) DCNL DCSP m = float ( len ( bottom ) ) DCNL DCSP for node in top : DCNL DCSP DCSP sp = dict ( path _ length ( G , node ) ) DCNL DCSP DCSP totsp = sum ( sp.values ( ) ) DCNL DCSP DCSP if ( ( totsp &gt; 0.0 ) and ( len ( G ) &gt; 1 ) ) : DCNL DCSP DCSP DCSP closeness &#91; node &#93; = ( ( m + ( 2 * ( n - 1 ) ) ) / totsp ) DCNL DCSP DCSP DCSP if normalized : DCNL DCSP DCSP DCSP DCSP s = ( ( len ( sp ) - 1.0 ) / ( len ( G ) - 1 ) ) DCNL DCSP DCSP DCSP DCSP closeness &#91; node &#93; * = s DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP closeness &#91; n &#93; = 0.0 DCNL DCSP for node in bottom : DCNL DCSP DCSP sp = dict ( path _ length ( G , node ) ) DCNL DCSP DCSP totsp = sum ( sp.values ( ) ) DCNL DCSP DCSP if ( ( totsp &gt; 0.0 ) and ( len ( G ) &gt; 1 ) ) : DCNL DCSP DCSP DCSP closeness &#91; node &#93; = ( ( n + ( 2 * ( m - 1 ) ) ) / totsp ) DCNL DCSP DCSP DCSP if normalized : DCNL DCSP DCSP DCSP DCSP s = ( ( len ( sp ) - 1.0 ) / ( len ( G ) - 1 ) ) DCNL DCSP DCSP DCSP DCSP closeness &#91; node &#93; * = s DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP closeness &#91; n &#93; = 0.0 DCNL DCSP return closeness
DCSP if ( sys.version _ info &#91; 0 &#93; = = 2 ) : DCNL DCSP DCSP return DCNL DCSP chart = Chart ( ) DCNL DCSP chart.add ( u ( &apos; S \ xc3 \ xa9rie1 &apos; ) , &#91; { &apos; value &apos; : 1 , &apos; xlink &apos; : &apos; http : / / 1 / &apos; , &apos; label &apos; : eval ( &quot; &apos; { \ \ } \ xc3 \ x82 \ xc2 \ xb0 \ xc4 \ xb3 \ xc3 \ xa6 \ xc3 \ xb0 \ xc2 \ xa9 &amp; \ xc3 \ x97 &amp; &lt; \ xe2 \ x80 \ x94 \ xc3 \ x97 \ xe2 \ x82 \ xac \ xc2 \ xbf _ \ xe2 \ x80 \ xa6 \ \ { _ \ xe2 \ x80 \ xa6 &apos; &quot; ) } , { &apos; value &apos; : 2 , &apos; xlink &apos; : { &apos; href &apos; : &apos; http : / / 6.example.com / &apos; } , &apos; label &apos; : eval ( &quot; &apos; \ xc3 \ xa6 \ xc3 \ x82 \ xc2 \ xb0 \ xe2 \ x82 \ xac \ xe2 \ x89 \ xa0 &#124; \ xe2 \ x82 \ xac \ xc3 \ xa6 \ xc3 \ x82 \ xc2 \ xb0 \ xe2 \ x82 \ xac \ xc9 \ x99 \ xc3 \ xa6 &apos; &quot; ) } , { &apos; value &apos; : 3 , &apos; label &apos; : eval ( &quot; b &apos;unicode DCSP &lt; 3 &apos; &quot; ) } &#93; ) DCNL DCSP if ( not chart . _ dual ) : DCNL DCSP DCSP chart.x _ labels = eval ( &quot; &#91; &apos; &amp; \ xc5 \ x93 &apos; , DCSP &apos; \ xc2 \ xbf ? &apos; , DCSP &apos; \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 \ xe2 \ x80 \ xa0 &apos; , DCSP &apos; unicode DCSP &lt; 3 &apos; &#93; &quot; ) DCNL DCSP chart.render _ pyquery ( )
DCSP x0 = np.asarray ( x0 ) .flatten ( ) DCNL DCSP xk = x0 DCNL DCSP k = 0 DCNL DCSP if line _ search : DCNL DCSP DCSP old _ fval = func ( x0 , * args ) DCNL DCSP DCSP old _ old _ fval = None DCNL DCSP while ( k &lt; maxiter ) : DCNL DCSP DCSP ( fgrad , fhess _ p ) = grad _ hess ( xk , * args ) DCNL DCSP DCSP absgrad = np.abs ( fgrad ) DCNL DCSP DCSP if ( np.max ( absgrad ) &lt; tol ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP maggrad = np.sum ( absgrad ) DCNL DCSP DCSP eta = min ( &#91; 0.5 , np.sqrt ( maggrad ) &#93; ) DCNL DCSP DCSP termcond = ( eta * maggrad ) DCNL DCSP DCSP xsupi = _ cg ( fhess _ p , fgrad , maxiter = maxinner , tol = termcond ) DCNL DCSP DCSP alphak = 1.0 DCNL DCSP DCSP if line _ search : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( alphak , fc , gc , old _ fval , old _ old _ fval , gfkp1 ) = _ line _ search _ wolfe12 ( func , grad , xk , xsupi , fgrad , old _ fval , old _ old _ fval , args = args ) DCNL DCSP DCSP DCSP except _ LineSearchError : DCNL DCSP DCSP DCSP DCSP warnings.warn ( &apos; Line DCSP Search DCSP failed &apos; ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP xk = ( xk + ( alphak * xsupi ) ) DCNL DCSP DCSP k + = 1 DCNL DCSP if ( warn and ( k &gt; = maxiter ) ) : DCNL DCSP DCSP warnings.warn ( &apos; newton-cg DCSP failed DCSP to DCSP converge . DCSP Increase DCSP the DCSP number DCSP of DCSP iterations . &apos; , ConvergenceWarning ) DCNL DCSP return ( xk , k )
DCSP try : DCNL DCSP DCSP if ( A. _ class _ priority &gt; B. _ class _ priority ) : DCNL DCSP DCSP DCSP return A. _ _ class _ _ DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return B. _ _ class _ _ DCNL DCSP except Exception : DCNL DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP import numpy DCNL DCSP DCSP if isinstance ( A , numpy.ndarray ) : DCNL DCSP DCSP DCSP return B. _ _ class _ _ DCNL DCSP DCSP if isinstance ( B , numpy.ndarray ) : DCNL DCSP DCSP DCSP return A. _ _ class _ _ DCNL DCSP except Exception : DCNL DCSP DCSP pass DCNL DCSP raise TypeError ( ( &apos; Incompatible DCSP classes DCSP % s , DCSP % s &apos; % ( A. _ _ class _ _ , B. _ _ class _ _ ) ) )
DCSP new _ blocks = &#91; &#93; DCNL DCSP for ( i , names , array ) in tuples : DCNL DCSP DCSP array = _ maybe _ to _ sparse ( array ) DCNL DCSP DCSP block = make _ block ( array , klass = SparseBlock , fastpath = True , placement = &#91; i &#93; ) DCNL DCSP DCSP new _ blocks.append ( block ) DCNL DCSP return new _ blocks
DCSP for i in xrange ( 0 , len ( l ) , n ) : DCNL DCSP DCSP ( yield l &#91; i : ( i + n ) &#93; )
DCSP loader = Loader ( stream ) DCNL DCSP while loader.check _ node ( ) : DCNL DCSP DCSP ( yield loader.get _ node ( ) )
DCSP return s3db.req _ send _ commit ( )
DCSP if ( randfunc is None ) : DCNL DCSP DCSP _ import _ Random ( ) DCNL DCSP DCSP randfunc = Random.new ( ) .read DCNL DCSP S = randfunc ( ( N &gt; &gt; 3 ) ) DCNL DCSP odd _ bits = ( N % 8 ) DCNL DCSP if ( odd _ bits ! = 0 ) : DCNL DCSP DCSP char = ( ord ( randfunc ( 1 ) ) &gt; &gt; ( 8 - odd _ bits ) ) DCNL DCSP DCSP S = ( bchr ( char ) + S ) DCNL DCSP value = bytes _ to _ long ( S ) DCNL DCSP return value
DCSP _ inventory.retrieve _ inventories _ size ( ) DCNL DCSP return _ inventory.item _ inventory _ size
DCSP config _ stub.data = { &apos; general &apos; : { &apos; private-browsing &apos; : True } } DCNL DCSP private _ hist = history.WebHistory ( hist _ dir = str ( tmpdir ) , hist _ name = &apos; history &apos; ) DCNL DCSP with qtbot.assertNotEmitted ( private _ hist.add _ completion _ item ) : DCNL DCSP DCSP with qtbot.assertNotEmitted ( private _ hist.item _ added ) : DCNL DCSP DCSP DCSP private _ hist.add _ url ( QUrl ( &apos; http : / / www.example.com / &apos; ) ) DCNL DCSP assert ( not private _ hist . _ temp _ history ) DCNL DCSP with qtbot.assertNotEmitted ( private _ hist.add _ completion _ item ) : DCNL DCSP DCSP with qtbot.assertNotEmitted ( private _ hist.item _ added ) : DCNL DCSP DCSP DCSP with qtbot.waitSignals ( &#91; private _ hist.async _ read _ done &#93; , order = &apos; strict &apos; ) : DCNL DCSP DCSP DCSP DCSP list ( private _ hist.async _ read ( ) ) DCNL DCSP with qtbot.assertNotEmitted ( private _ hist.add _ completion _ item ) : DCNL DCSP DCSP with qtbot.assertNotEmitted ( private _ hist.item _ added ) : DCNL DCSP DCSP DCSP private _ hist.add _ url ( QUrl ( &apos; http : / / www.example.com / &apos; ) ) DCNL DCSP assert ( not private _ hist . _ temp _ history ) DCNL DCSP assert ( not private _ hist . _ new _ history ) DCNL DCSP assert ( not private _ hist.history _ dict )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : False , &apos; comment &apos; : &apos; Failed DCSP to DCSP update . &apos; } DCNL DCSP try : DCNL DCSP DCSP packages = _ _ salt _ _ &#91; &apos; pip.list _ upgrades &apos; &#93; ( bin _ env = bin _ env , user = user , cwd = cwd ) DCNL DCSP except Exception as e : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = str ( e ) DCNL DCSP DCSP return ret DCNL DCSP if ( not packages ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; System DCSP is DCSP already DCSP up-to-date . &apos; DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP return ret DCNL DCSP elif _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; System DCSP update DCSP will DCSP be DCSP performed &apos; DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP return ret DCNL DCSP updated = _ _ salt _ _ &#91; &apos; pip.upgrade &apos; &#93; ( bin _ env = bin _ env , user = user , cwd = cwd , use _ vt = use _ vt ) DCNL DCSP if ( updated.get ( &apos; result &apos; ) is False ) : DCNL DCSP DCSP ret.update ( updated ) DCNL DCSP elif updated : DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = updated DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Upgrade DCSP successful . &apos; DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Upgrade DCSP failed . &apos; DCNL DCSP return ret
DCSP try : DCNL DCSP DCSP if ( type ( obj ) in &#91; int , float &#93; ) : DCNL DCSP DCSP DCSP return str ( obj ) DCNL DCSP DCSP elif isinstance ( obj , dict ) : DCNL DCSP DCSP DCSP if ( len ( obj ) &gt; 5 ) : DCNL DCSP DCSP DCSP DCSP return ( &apos; &lt; dict DCSP { % s , ... } &gt; &apos; % &apos; , &apos; .join ( list ( obj.keys ( ) ) &#91; : 5 &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return ( &apos; &lt; dict DCSP { % s } &gt; &apos; % &apos; , &apos; .join ( list ( obj.keys ( ) ) ) ) DCNL DCSP DCSP elif isinstance ( obj , str ) : DCNL DCSP DCSP DCSP if ( len ( obj ) &gt; 50 ) : DCNL DCSP DCSP DCSP DCSP return ( &apos; &quot; % s ... &quot; &apos; % obj &#91; : 50 &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return obj &#91; : &#93; DCNL DCSP DCSP elif isinstance ( obj , ndarray ) : DCNL DCSP DCSP DCSP return ( &apos; &lt; ndarray DCSP % s DCSP % s &gt; &apos; % ( str ( obj.dtype ) , str ( obj.shape ) ) ) DCNL DCSP DCSP elif hasattr ( obj , &apos; _ _ len _ _ &apos; ) : DCNL DCSP DCSP DCSP if ( len ( obj ) &gt; 5 ) : DCNL DCSP DCSP DCSP DCSP return ( &apos; &lt; % s DCSP &#91; % s , ... &#93; &gt; &apos; % ( type ( obj ) . _ _ name _ _ , &apos; , &apos; .join ( &#91; type ( o ) . _ _ name _ _ for o in obj &#91; : 5 &#93; &#93; ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return ( &apos; &lt; % s DCSP &#91; % s &#93; &gt; &apos; % ( type ( obj ) . _ _ name _ _ , &apos; , &apos; .join ( &#91; type ( o ) . _ _ name _ _ for o in obj &#93; ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( &apos; &lt; % s DCSP % s &gt; &apos; % ( type ( obj ) . _ _ name _ _ , obj . _ _ class _ _ . _ _ name _ _ ) ) DCNL DCSP except : DCNL DCSP DCSP return str ( type ( obj ) )
DCSP suffices = &#91; &apos; B &apos; , &apos; KB &apos; , &apos; MB &apos; , &apos; GB &apos; , &apos; TB &apos; , &apos; PB &apos; , &apos; EB &apos; , &apos; ZB &apos; , &apos; YB &apos; , &apos; HB &apos; &#93; DCNL DCSP for suffix in suffices : DCNL DCSP DCSP if ( size &lt; 1024 ) : DCNL DCSP DCSP DCSP return ( &apos; % 3.1f DCSP % s &apos; % ( size , suffix ) ) DCNL DCSP DCSP size / = 1024.0 DCNL DCSP return &apos; big&apos;
DCSP if ( value = = &apos; &lt; empty &gt; &apos; ) : DCNL DCSP DCSP value = &apos; &apos; DCNL DCSP value = value.replace ( &apos; ( port ) &apos; , str ( httpbin.port ) ) DCNL DCSP quteproc.set _ setting ( sect , opt , value )
DCSP logging.debug ( &apos; metric _ cleanup &apos; ) DCNL DCSP pass
DCSP try : DCNL DCSP DCSP return ( ( u &apos; % &apos; + six.text _ type ( arg ) ) % value ) DCNL DCSP except ( ValueError , TypeError ) : DCNL DCSP DCSP return u &apos; &apos;
DCSP def set _ version ( ) : DCNL DCSP DCSP p _ out = output _ subprocess _ Popen ( &#91; nvcc _ path , &apos; --version &apos; &#93; ) DCNL DCSP DCSP ver _ line = decode ( p _ out &#91; 0 &#93; ) .strip ( ) .split ( &apos; \ n &apos; ) &#91; ( -1 ) &#93; DCNL DCSP DCSP ( build , version ) = ver _ line.split ( &apos; , &apos; ) &#91; 1 &#93; .strip ( ) .split ( ) DCNL DCSP DCSP assert ( build = = &apos; release &apos; ) DCNL DCSP DCSP global nvcc _ version DCNL DCSP DCSP nvcc _ version = version DCNL DCSP try : DCNL DCSP DCSP set _ version ( ) DCNL DCSP DCSP return True DCNL DCSP except Exception : DCNL DCSP DCSP p = os.path.join ( config.cuda.root , &apos; bin &apos; , &apos; nvcc &apos; ) DCNL DCSP DCSP if os.path.exists ( p ) : DCNL DCSP DCSP DCSP global nvcc _ path DCNL DCSP DCSP DCSP nvcc _ path = p DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP set _ version ( ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return False
DCSP cmd = &apos; volume DCSP quota DCSP { 0 } &apos; .format ( name ) DCNL DCSP cmd + = &apos; DCSP list &apos; DCNL DCSP root = _ gluster _ xml ( cmd ) DCNL DCSP if ( not _ gluster _ ok ( root ) ) : DCNL DCSP DCSP return None DCNL DCSP ret = { } DCNL DCSP for limit in _ iter ( root , &apos; limit &apos; ) : DCNL DCSP DCSP path = limit.find ( &apos; path &apos; ) .text DCNL DCSP DCSP ret &#91; path &#93; = _ etree _ to _ dict ( limit ) DCNL DCSP return ret
DCSP global _ CACHE _ SLUG DCNL DCSP if ( not _ CACHE _ SLUG ) : DCNL DCSP DCSP _ CACHE _ SLUG = &apos; &apos; DCNL DCSP DCSP if ( feconf.IS _ MINIFIED or ( not feconf.DEV _ MODE ) ) : DCNL DCSP DCSP DCSP yaml _ file _ content = dict _ from _ yaml ( get _ file _ contents ( &apos; cache _ slug.yaml &apos; ) ) DCNL DCSP DCSP DCSP _ CACHE _ SLUG = yaml _ file _ content &#91; &apos; cache _ slug &apos; &#93; DCNL DCSP return _ CACHE _ SLUG
DCSP mt = r.getstate ( ) &#91; 1 &#93; DCNL DCSP ( ints , index ) = ( mt &#91; : ( -1 ) &#93; , mt &#91; ( -1 ) &#93; ) DCNL DCSP _ helperlib.rnd _ set _ state ( ptr , ( index , list ( ints ) ) ) DCNL DCSP return ( ints , index )
DCSP try : DCNL DCSP DCSP xreply = json.loads ( xreply ) DCNL DCSP except ValueError as err : DCNL DCSP DCSP log.error ( err ) DCNL DCSP DCSP return ( 1 , &apos; unexpected DCSP reply DCSP from DCSP server &apos; ) DCNL DCSP return _ code = xreply &#91; &apos; return _ code &apos; &#93; DCNL DCSP content = xreply &#91; &apos; content &apos; &#93; DCNL DCSP return ( return _ code , content )
DCSP return context.core.playback.next ( ) .get ( )
DCSP info = { &apos; name &apos; : driver.class _ name , &apos; version &apos; : driver.version , &apos; fqn &apos; : driver.class _ fqn , &apos; description &apos; : driver.desc , &apos; ci _ wiki _ name &apos; : driver.ci _ wiki _ name } DCNL DCSP return info
DCSP chars = ( ( upperAlpha + lowerAlpha ) + numerals ) DCNL DCSP return rand _ base ( length , bad , set ( chars ) )
DCSP raise ValueError ( &apos; Foo ! &apos; )
DCSP if ( sys.platform = = &apos; win32 &apos; ) : DCNL DCSP DCSP origramps = numpy.empty ( ( 3 , 256 ) , dtype = numpy.uint16 ) DCNL DCSP DCSP success = windll.gdi32.GetDeviceGammaRamp ( ( 4294967295 &amp; pygletWindow . _ dc ) , origramps.ctypes ) DCNL DCSP DCSP if ( not success ) : DCNL DCSP DCSP DCSP raise AssertionError , &apos; GetDeviceGammaRamp DCSP failed &apos; DCNL DCSP DCSP origramps = ( origramps / 65535.0 ) DCNL DCSP if ( sys.platform = = &apos; darwin &apos; ) : DCNL DCSP DCSP origramps = numpy.empty ( ( 3 , 256 ) , dtype = numpy.float32 ) DCNL DCSP DCSP n = numpy.empty ( &#91; 1 &#93; , dtype = numpy.int ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ screenID = pygletWindow . _ screen.id DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP _ screenID = pygletWindow . _ screen . _ cg _ display _ id DCNL DCSP DCSP error = carbon.CGGetDisplayTransferByTable ( _ screenID , 256 , origramps &#91; 0 , : &#93; .ctypes , origramps &#91; 1 , : &#93; .ctypes , origramps &#91; 2 , : &#93; .ctypes , n.ctypes ) DCNL DCSP DCSP if error : DCNL DCSP DCSP DCSP raise AssertionError , &apos; CGSetDisplayTransferByTable DCSP failed &apos; DCNL DCSP if sys.platform.startswith ( &apos; linux &apos; ) : DCNL DCSP DCSP origramps = numpy.empty ( ( 3 , 256 ) , dtype = numpy.uint16 ) DCNL DCSP DCSP success = xf86vm.XF86VidModeGetGammaRamp ( pygletWindow . _ x _ display , pygletWindow . _ x _ screen _ id , 256 , origramps &#91; 0 , : &#93; .ctypes , origramps &#91; 1 , : &#93; .ctypes , origramps &#91; 2 , : &#93; .ctypes ) DCNL DCSP DCSP if ( not success ) : DCNL DCSP DCSP DCSP raise AssertionError , &apos; XF86VidModeGetGammaRamp DCSP failed &apos; DCNL DCSP DCSP origramps = ( origramps / 65535.0 ) DCNL DCSP return origramps
DCSP def implementer ( context , builder , sig , args ) : DCNL DCSP DCSP ( val , ) = args DCNL DCSP DCSP input _ type = sig.args &#91; 0 &#93; DCNL DCSP DCSP fpval = context.cast ( builder , val , input _ type , types.float64 ) DCNL DCSP DCSP inner _ sig = signature ( types.float64 , types.float64 ) DCNL DCSP DCSP res = wrapped _ impl ( context , builder , inner _ sig , ( fpval , ) ) DCNL DCSP DCSP return context.cast ( builder , res , types.float64 , sig.return _ type ) DCNL DCSP return implementer
DCSP token = oauth.OAuthToken.from _ string ( http _ body ) DCNL DCSP oauth _ token = OAuthToken ( key = token.key , secret = token.secret ) DCNL DCSP return oauth _ token
DCSP x = x &#91; : d &#93; DCNL DCSP return np.asarray ( &#91; np.diff ( x , ( d - i ) ) &#91; 0 &#93; for i in range ( d , 0 , ( -1 ) ) &#93; )
DCSP if pieces &#91; &apos; closest-tag &apos; &#93; : DCNL DCSP DCSP rendered = pieces &#91; &apos; closest-tag &apos; &#93; DCNL DCSP DCSP if pieces &#91; &apos; distance &apos; &#93; : DCNL DCSP DCSP DCSP rendered + = ( &apos; - % d-g % s &apos; % ( pieces &#91; &apos; distance &apos; &#93; , pieces &#91; &apos; short &apos; &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP rendered = pieces &#91; &apos; short &apos; &#93; DCNL DCSP if pieces &#91; &apos; dirty &apos; &#93; : DCNL DCSP DCSP rendered + = &apos; -dirty &apos; DCNL DCSP return rendered
DCSP g = ( lambda x : sum ( &#91; ( ( a - 0.5 ) * * 2 ) for a in x &#93; ) ) DCNL DCSP gval = g ( ind &#91; ( n _ objs - 1 ) : &#93; ) DCNL DCSP theta = ( lambda x : ( ( pi / ( 4.0 * ( 1 + gval ) ) ) * ( 1 + ( ( 2 * gval ) * x ) ) ) ) DCNL DCSP fit = &#91; ( ( ( 1 + gval ) * cos ( ( ( pi / 2.0 ) * ind &#91; 0 &#93; ) ) ) * reduce ( ( lambda x , y : ( x * y ) ) , &#91; cos ( theta ( a ) ) for a in ind &#91; 1 : &#93; &#93; ) ) &#93; DCNL DCSP for m in reversed ( range ( 1 , n _ objs ) ) : DCNL DCSP DCSP if ( m = = 1 ) : DCNL DCSP DCSP DCSP fit.append ( ( ( 1 + gval ) * sin ( ( ( pi / 2.0 ) * ind &#91; 0 &#93; ) ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fit.append ( ( ( ( ( 1 + gval ) * cos ( ( ( pi / 2.0 ) * ind &#91; 0 &#93; ) ) ) * reduce ( ( lambda x , y : ( x * y ) ) , &#91; cos ( theta ( a ) ) for a in ind &#91; 1 : ( m - 1 ) &#93; &#93; , 1 ) ) * sin ( theta ( ind &#91; ( m - 1 ) &#93; ) ) ) ) DCNL DCSP return fit
DCSP try : DCNL DCSP DCSP return getattr ( obj , attr , default ) DCNL DCSP except Exception : DCNL DCSP DCSP return default
DCSP mode = f.mode DCNL DCSP if isinstance ( f , gzip.GzipFile ) : DCNL DCSP DCSP if ( mode = = gzip.READ ) : DCNL DCSP DCSP DCSP return &apos; rb &apos; DCNL DCSP DCSP elif ( mode = = gzip.WRITE ) : DCNL DCSP DCSP DCSP return &apos; wb &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP if ( &apos; + &apos; in mode ) : DCNL DCSP DCSP mode = mode.replace ( &apos; + &apos; , &apos; &apos; ) DCNL DCSP DCSP mode + = &apos; + &apos; DCNL DCSP return mode
DCSP from sympy.functions.combinatorial.factorials import binomial DCNL DCSP from sympy.core.mul import prod DCNL DCSP if isinstance ( n , SYMPY _ INTS ) : DCNL DCSP DCSP if ( k is None ) : DCNL DCSP DCSP DCSP if ( not replacement ) : DCNL DCSP DCSP DCSP DCSP return ( 2 * * n ) DCNL DCSP DCSP DCSP return sum ( ( nC ( n , i , replacement ) for i in range ( ( n + 1 ) ) ) ) DCNL DCSP DCSP if ( k &lt; 0 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; k DCSP cannot DCSP be DCSP negative &apos; ) DCNL DCSP DCSP if replacement : DCNL DCSP DCSP DCSP return binomial ( ( ( n + k ) - 1 ) , k ) DCNL DCSP DCSP return binomial ( n , k ) DCNL DCSP if isinstance ( n , _ MultisetHistogram ) : DCNL DCSP DCSP N = n &#91; _ N &#93; DCNL DCSP DCSP if ( k is None ) : DCNL DCSP DCSP DCSP if ( not replacement ) : DCNL DCSP DCSP DCSP DCSP return prod ( ( ( m + 1 ) for m in n &#91; _ M &#93; ) ) DCNL DCSP DCSP DCSP return sum ( ( nC ( n , i , replacement ) for i in range ( ( N + 1 ) ) ) ) DCNL DCSP DCSP elif replacement : DCNL DCSP DCSP DCSP return nC ( n &#91; _ ITEMS &#93; , k , replacement ) DCNL DCSP DCSP elif ( k in ( 1 , ( N - 1 ) ) ) : DCNL DCSP DCSP DCSP return n &#91; _ ITEMS &#93; DCNL DCSP DCSP elif ( k in ( 0 , N ) ) : DCNL DCSP DCSP DCSP return 1 DCNL DCSP DCSP return _ AOP _ product ( tuple ( n &#91; _ M &#93; ) ) &#91; k &#93; DCNL DCSP else : DCNL DCSP DCSP return nC ( _ multiset _ histogram ( n ) , k , replacement )
DCSP d1 = des ( expandDesKey ( K &#91; 0 : 7 &#93; ) ) DCNL DCSP d2 = des ( expandDesKey ( K &#91; 7 : 14 &#93; ) ) DCNL DCSP d3 = des ( expandDesKey ( ( K &#91; 14 : 16 &#93; + ( &apos; \ x00 &apos; * 5 ) ) ) ) DCNL DCSP return ( ( d1.encrypt ( D ) + d2.encrypt ( D ) ) + d3.encrypt ( D ) )
DCSP for y in range ( count ) : DCNL DCSP DCSP value * = 2 DCNL DCSP DCSP if ( value &gt; 18446744073709551615L ) : DCNL DCSP DCSP DCSP value - = 18446744073709551616L DCNL DCSP DCSP DCSP value + = 1 DCNL DCSP return value
DCSP none _ fill = ( lambda x : ( None if ( x = = &apos; &apos; ) else x ) ) DCNL DCSP if ( index _ col is None ) : DCNL DCSP DCSP return ( none _ fill ( row &#91; 0 &#93; ) , row &#91; 1 : &#93; ) DCNL DCSP else : DCNL DCSP DCSP i = ( index _ col if ( not is _ list _ like ( index _ col ) ) else max ( index _ col ) ) DCNL DCSP DCSP return ( none _ fill ( row &#91; i &#93; ) , ( ( row &#91; : i &#93; + &#91; &apos; &apos; &#93; ) + row &#91; ( i + 1 ) : &#93; ) )
DCSP util.dbg ( &apos; starting DCSP remux &apos; ) DCNL DCSP temp _ file = ( ( filename + &apos; .&apos; ) + str ( random.randint ( 10000 , 99999 ) ) ) DCNL DCSP os.rename ( filename , temp _ file ) DCNL DCSP meta = extract _ metadata ( title ) DCNL DCSP metadata = &#91; ( &apos; title = % s &apos; % meta &#91; &apos; title &apos; &#93; ) &#93; DCNL DCSP if meta &#91; &apos; artist &apos; &#93; : DCNL DCSP DCSP metadata = &#91; ( &apos; title = % s &apos; % meta &#91; &apos; title &apos; &#93; ) , &apos; -metadata &apos; , ( &apos; artist = % s &apos; % meta &#91; &apos; artist &apos; &#93; ) &#93; DCNL DCSP cmd = &#91; g.muxapp , &apos; -y &apos; , &apos; -i &apos; , temp _ file , &apos; -acodec &apos; , &apos; copy &apos; , &apos; -metadata &apos; &#93; DCNL DCSP cmd + = ( metadata + &#91; &apos; -vn &apos; , filename &#93; ) DCNL DCSP util.dbg ( cmd ) DCNL DCSP try : DCNL DCSP DCSP with open ( os.devnull , &apos; w &apos; ) as devnull : DCNL DCSP DCSP DCSP subprocess.call ( cmd , stdout = devnull , stderr = subprocess.STDOUT ) DCNL DCSP except OSError : DCNL DCSP DCSP util.dbg ( &apos; Failed DCSP to DCSP remux DCSP audio DCSP using DCSP % s &apos; , g.muxapp ) DCNL DCSP DCSP os.rename ( temp _ file , filename ) DCNL DCSP else : DCNL DCSP DCSP os.unlink ( temp _ file ) DCNL DCSP DCSP util.dbg ( ( &apos; remuxed DCSP audio DCSP file DCSP using DCSP % s &apos; % g.muxapp ) )
DCSP time _ points = get _ time _ points ( interval ) DCNL DCSP q = Session.query ( cls ) .filter ( cls.date.in _ ( time _ points ) ) DCNL DCSP if hasattr ( cls , &apos; interval &apos; ) : DCNL DCSP DCSP q = q.filter ( ( cls.interval = = interval ) ) DCNL DCSP q = q.order _ by ( desc ( cls.date ) ) DCNL DCSP return ( time _ points , q )
DCSP responsesCorrectPerCycle = np.ones ( nCorrect , dtype = np.int ) DCNL DCSP responsesIncorrectPerCycle = np.zeros ( nIncorrect , dtype = np.int ) DCNL DCSP responses = np.tile ( np.r _ &#91; ( responsesCorrectPerCycle , responsesIncorrectPerCycle ) &#93; , cycles ) .tolist ( ) DCNL DCSP if ( length is not None ) : DCNL DCSP DCSP return responses &#91; : length &#93; DCNL DCSP else : DCNL DCSP DCSP return responses
DCSP epoch = int ( ( time.mktime ( t.timetuple ( ) ) * 1000 ) ) DCNL DCSP return epoch
DCSP for ( name , inset ) in referenced _ images.iteritems ( ) : DCNL DCSP DCSP if ( inset is None ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP img _ path = os.path.join ( IOS _ IMAGES _ DIR , ImageName2X ( name ) ) DCNL DCSP DCSP assert os.access ( img _ path , os.R _ OK ) , ( &apos; 2x DCSP version DCSP of DCSP % s DCSP is DCSP not DCSP readable &apos; % name ) DCNL DCSP DCSP nine _ path = os.path.join ( ANDROID _ IMAGES _ DIR , ImageName9Patch ( name ) ) DCNL DCSP DCSP generate _ 9patch = True DCNL DCSP DCSP if os.access ( nine _ path , os.R _ OK ) : DCNL DCSP DCSP DCSP generate _ 9patch = False DCNL DCSP DCSP DCSP android _ inset = GetInsetFrom9Patch ( nine _ path ) DCNL DCSP DCSP DCSP if ( inset = = android _ inset ) : DCNL DCSP DCSP DCSP DCSP if options.options.v : DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; % s : DCSP OK DCSP % r &apos; % ( name , inset ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP print ( &apos; % s : DCSP 9-patch DCSP with DCSP different DCSP inset : &apos; % name ) DCNL DCSP DCSP DCSP DCSP print ( &apos; DCSP DCSP iOS DCSP 2x : DCSP DCSP DCSP size : DCSP % r , DCSP inset : DCSP % r &apos; % ( Image.open ( img _ path ) .size , inset ) ) DCNL DCSP DCSP DCSP DCSP print ( &apos; DCSP DCSP android : DCSP DCSP size : DCSP % r , DCSP inset : DCSP % r &apos; % ( Image.open ( nine _ path ) .size , android _ inset ) ) DCNL DCSP DCSP DCSP DCSP Generate9PatchFromInset ( img _ path , inset , nine _ path , True ) DCNL DCSP DCSP DCSP DCSP if ( name in options.options.regenerate ) : DCNL DCSP DCSP DCSP DCSP DCSP print &apos; DCSP DCSP Regenerating DCSP 9 DCSP patch ... &apos; DCNL DCSP DCSP DCSP DCSP DCSP generate _ 9patch = True DCNL DCSP DCSP if generate _ 9patch : DCNL DCSP DCSP DCSP print ( &apos; % s : DCSP generating DCSP 9-patch DCSP with DCSP inset DCSP % r &apos; % ( name , inset ) ) DCNL DCSP DCSP DCSP print ( &apos; DCSP DCSP iOS DCSP 2x : DCSP DCSP DCSP size : DCSP % r , DCSP inset : DCSP % r &apos; % ( Image.open ( img _ path ) .size , inset ) ) DCNL DCSP DCSP DCSP Generate9PatchFromInset ( img _ path , inset , nine _ path , False )
DCSP return _ client ( ) .is _ cached ( path , saltenv )
DCSP print &apos; &apos; DCNL DCSP print &apos; &apos; DCNL DCSP print ( &apos; Statistics DCSP are DCSP being DCSP generated DCSP for DCSP the DCSP file DCSP &apos; + archive.getSummarizedFileName ( fileName ) ) DCNL DCSP if ( repository = = None ) : DCNL DCSP DCSP repository = settings.getReadRepository ( StatisticRepository ( ) ) DCNL DCSP skein = StatisticSkein ( ) DCNL DCSP statisticGcode = skein.getCraftedGcode ( gcodeText , repository ) DCNL DCSP if repository.printStatistics.value : DCNL DCSP DCSP print statisticGcode DCNL DCSP if repository.saveStatistics.value : DCNL DCSP DCSP archive.writeFileMessageEnd ( &apos; .txt &apos; , fileName , statisticGcode , &apos; The DCSP statistics DCSP file DCSP is DCSP saved DCSP as DCSP &apos; )
DCSP if rs _ is _ puiseux ( p , x ) : DCNL DCSP DCSP return rs _ puiseux ( rs _ LambertW , p , x , prec ) DCNL DCSP R = p.ring DCNL DCSP p1 = R ( 0 ) DCNL DCSP if _ has _ constant _ term ( p , x ) : DCNL DCSP DCSP raise NotImplementedError ( &apos; Polynomial DCSP must DCSP not DCSP have DCSP constant DCSP term DCSP in DCSP the DCSP series DCSP variables &apos; ) DCNL DCSP if ( x in R.gens ) : DCNL DCSP DCSP for precx in _ giant _ steps ( prec ) : DCNL DCSP DCSP DCSP e = rs _ exp ( p1 , x , precx ) DCNL DCSP DCSP DCSP p2 = ( rs _ mul ( e , p1 , x , precx ) - p ) DCNL DCSP DCSP DCSP p3 = rs _ mul ( e , ( p1 + 1 ) , x , precx ) DCNL DCSP DCSP DCSP p3 = rs _ series _ inversion ( p3 , x , precx ) DCNL DCSP DCSP DCSP tmp = rs _ mul ( p2 , p3 , x , precx ) DCNL DCSP DCSP DCSP p1 - = tmp DCNL DCSP DCSP return p1 DCNL DCSP else : DCNL DCSP DCSP raise NotImplementedError
DCSP while data : DCNL DCSP DCSP n = os.write ( fd , data ) DCNL DCSP DCSP data = data &#91; n : &#93;
DCSP factory = GoogleCheckerFactory ( words ) DCNL DCSP reactor.connectTCP ( &apos; www.google.com &apos; , 80 , factory ) DCNL DCSP return factory.deferred
DCSP try : DCNL DCSP DCSP symbols = &#91; &#93; DCNL DCSP DCSP symbols.extend ( greek _ unicode.values ( ) ) DCNL DCSP DCSP symbols + = atoms _ table.values ( ) DCNL DCSP DCSP for s in symbols : DCNL DCSP DCSP DCSP if ( s is None ) : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP encoding = getattr ( sys.stdout , &apos; encoding &apos; , None ) DCNL DCSP DCSP DCSP if ( encoding is None ) : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP s.encode ( encoding ) DCNL DCSP except UnicodeEncodeError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP pretty _ use _ unicode ( True )
DCSP visitors = { } DCNL DCSP request = _ build _ request ( ) DCNL DCSP date = start _ date DCNL DCSP while ( date &lt; = end _ date ) : DCNL DCSP DCSP date _ str = str ( date ) DCNL DCSP DCSP visitors &#91; str ( date ) &#93; = int ( request.get ( ids = ( &apos; ga : &apos; + profile _ id ) , start _ date = date _ str , end _ date = date _ str , metrics = &apos; ga : visitors &apos; ) .execute ( ) &#91; &apos; rows &apos; &#93; &#91; 0 &#93; &#91; 0 &#93; ) DCNL DCSP DCSP date + = timedelta ( days = 1 ) DCNL DCSP return visitors
DCSP if ( not driver.initialized ) : DCNL DCSP DCSP driver _ name = driver . _ _ class _ _ . _ _ name _ _ DCNL DCSP DCSP LOG.error ( _ LE ( &apos; Volume DCSP driver DCSP % s DCSP not DCSP initialized &apos; ) , driver _ name ) DCNL DCSP DCSP raise exception.DriverNotInitialized ( ) DCNL DCSP else : DCNL DCSP DCSP log _ unsupported _ driver _ warning ( driver )
DCSP if ( not os.path.exists ( source ) ) : DCNL DCSP DCSP return DCNL DCSP if ( os.path.exists ( destination ) and os.path.isdir ( destination ) ) : DCNL DCSP DCSP destination = os.path.join ( destination , os.path.basename ( source ) ) DCNL DCSP if ( source.lower ( ) .endswith ( &apos; _ t &apos; ) and context ) : DCNL DCSP DCSP if ( renderer is None ) : DCNL DCSP DCSP DCSP from sphinx.util.template import SphinxRenderer DCNL DCSP DCSP DCSP renderer = SphinxRenderer ( ) DCNL DCSP DCSP with codecs.open ( source , &apos; r &apos; , encoding = &apos; utf-8 &apos; ) as fsrc : DCNL DCSP DCSP DCSP if destination.lower ( ) .endswith ( &apos; _ t &apos; ) : DCNL DCSP DCSP DCSP DCSP destination = destination &#91; : ( -2 ) &#93; DCNL DCSP DCSP DCSP with codecs.open ( destination , &apos; w &apos; , encoding = &apos; utf-8 &apos; ) as fdst : DCNL DCSP DCSP DCSP DCSP fdst.write ( renderer.render _ string ( fsrc.read ( ) , context ) ) DCNL DCSP else : DCNL DCSP DCSP copyfile ( source , destination )
DCSP with pytest.raises ( InvalidConfiguration ) as excinfo : DCNL DCSP DCSP config.get _ config ( &apos; tests / test-config / invalid-config.yaml &apos; ) DCNL DCSP expected _ error _ msg = &apos; Unable DCSP to DCSP parse DCSP YAML DCSP file DCSP tests / test-config / invalid-config.yaml. DCSP Error : DCSP &apos; DCNL DCSP assert ( expected _ error _ msg in str ( excinfo.value ) )
DCSP pass
DCSP for key in kwargs : DCNL DCSP DCSP if ( key not in PLOT _ OPTIONS ) : DCNL DCSP DCSP DCSP raise exceptions.PlotlyError ( &apos; { } DCSP is DCSP not DCSP a DCSP valid DCSP config DCSP or DCSP plot DCSP option DCSP key &apos; .format ( key ) ) DCNL DCSP DCSP if ( not isinstance ( kwargs &#91; key &#93; , PLOT _ OPTIONS &#91; key &#93; ) ) : DCNL DCSP DCSP DCSP raise exceptions.PlotlyError ( &quot; { } DCSP must DCSP be DCSP of DCSP type DCSP &apos; { } &apos; &quot; .format ( key , PLOT _ OPTIONS &#91; key &#93; ) ) DCNL DCSP DCSP if ( ( key = = &apos; sharing &apos; ) and ( not ( kwargs &#91; key &#93; in SHARING _ OPTIONS ) ) ) : DCNL DCSP DCSP DCSP raise exceptions.PlotlyError ( &quot; &apos; { 0 } &apos; DCSP must DCSP be DCSP of DCSP either DCSP &apos; { 1 } &apos; , DCSP &apos; { 2 } &apos; DCSP or DCSP &apos; { 3 } &apos; &quot; .format ( key , * SHARING _ OPTIONS ) ) DCNL DCSP _ session &#91; &apos; plot _ options &apos; &#93; .update ( kwargs )
DCSP pass
DCSP ret = &#91; &#93; DCNL DCSP cmd = &#91; &apos; docker &apos; , &apos; history &apos; , &apos; -q &apos; , name &#93; DCNL DCSP for line in reversed ( _ _ salt _ _ &#91; &apos; cmd.run _ stdout &apos; &#93; ( cmd , python _ shell = False ) .splitlines ( ) ) : DCNL DCSP DCSP ret.append ( line ) DCNL DCSP if ( not ret ) : DCNL DCSP DCSP raise CommandExecutionError ( &quot; Image DCSP &apos; { 0 } &apos; DCSP not DCSP found &quot; .format ( name ) ) DCNL DCSP return ret
DCSP try : DCNL DCSP DCSP proc = subprocess.Popen ( &#91; &apos; python2 &apos; , checkpyver . _ _ file _ _ , &apos; --no-err-windows &apos; &#93; , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP DCSP ( stdout , stderr ) = proc.communicate ( ) DCNL DCSP except FileNotFoundError : DCNL DCSP DCSP pytest.skip ( &apos; python2 DCSP not DCSP found &apos; ) DCNL DCSP assert ( not stdout ) DCNL DCSP stderr = stderr.decode ( &apos; utf-8 &apos; ) DCNL DCSP assert re.match ( TEXT , stderr ) , stderr DCNL DCSP assert ( proc.returncode = = 1 )
DCSP ret = { } DCNL DCSP default = kwargs.get ( &apos; default &apos; , &apos; &apos; ) DCNL DCSP delimiter = kwargs.get ( &apos; delimiter &apos; , DEFAULT _ TARGET _ DELIM ) DCNL DCSP try : DCNL DCSP DCSP for arg in args : DCNL DCSP DCSP DCSP ret &#91; arg &#93; = salt.utils.traverse _ dict _ and _ list ( _ _ grains _ _ , arg , default , delimiter ) DCNL DCSP except KeyError : DCNL DCSP DCSP pass DCNL DCSP if salt.utils.is _ true ( kwargs.get ( &apos; sanitize &apos; ) ) : DCNL DCSP DCSP for ( arg , func ) in six.iteritems ( _ SANITIZERS ) : DCNL DCSP DCSP DCSP if ( arg in ret ) : DCNL DCSP DCSP DCSP DCSP ret &#91; arg &#93; = func ( ret &#91; arg &#93; ) DCNL DCSP return ret
DCSP for plugin in find _ plugins ( ) : DCNL DCSP DCSP for candidate in plugin.candidates ( items , artist , album , va _ likely ) : DCNL DCSP DCSP DCSP ( yield candidate )
DCSP names &#91; p &#91; 1 &#93; &#93; = p &#91; 3 &#93;
DCSP service _ instance = salt.utils.vmware.get _ service _ instance ( host = host , username = username , password = password , protocol = protocol , port = port ) DCNL DCSP host _ names = _ check _ hosts ( service _ instance , host , host _ names ) DCNL DCSP valid _ services = &#91; &apos; DCUI &apos; , &apos; TSM &apos; , &apos; SSH &apos; , &apos; ssh &apos; , &apos; lbtd &apos; , &apos; lsassd &apos; , &apos; lwiod &apos; , &apos; netlogond &apos; , &apos; ntpd &apos; , &apos; sfcbd-watchdog &apos; , &apos; snmpd &apos; , &apos; vprobed &apos; , &apos; vpxa &apos; , &apos; xorg &apos; &#93; DCNL DCSP ret = { } DCNL DCSP if ( ( service _ name = = &apos; SSH &apos; ) or ( service _ name = = &apos; ssh &apos; ) ) : DCNL DCSP DCSP temp _ service _ name = &apos; TSM-SSH &apos; DCNL DCSP else : DCNL DCSP DCSP temp _ service _ name = service _ name DCNL DCSP for host _ name in host _ names : DCNL DCSP DCSP if ( service _ name not in valid _ services ) : DCNL DCSP DCSP DCSP ret.update ( { host _ name : { &apos; Error &apos; : &apos; { 0 } DCSP is DCSP not DCSP a DCSP valid DCSP service DCSP name . &apos; .format ( service _ name ) } } ) DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP host _ ref = _ get _ host _ ref ( service _ instance , host , host _ name = host _ name ) DCNL DCSP DCSP service _ manager = _ get _ service _ manager ( host _ ref ) DCNL DCSP DCSP log.debug ( &quot; Restarting DCSP the DCSP &apos; { 0 } &apos; DCSP service DCSP on DCSP { 1 } . &quot; .format ( service _ name , host _ name ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP service _ manager.RestartService ( id = temp _ service _ name ) DCNL DCSP DCSP except vim.fault.HostConfigFault as err : DCNL DCSP DCSP DCSP msg = &quot; &apos; vsphere.service _ restart &apos; DCSP failed DCSP for DCSP host DCSP { 0 } : DCSP { 1 } &quot; .format ( host _ name , err ) DCNL DCSP DCSP DCSP log.debug ( msg ) DCNL DCSP DCSP DCSP ret.update ( { host _ name : { &apos; Error &apos; : msg } } ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP except vim.fault.RestrictedVersion as err : DCNL DCSP DCSP DCSP log.debug ( err ) DCNL DCSP DCSP DCSP ret.update ( { host _ name : { &apos; Error &apos; : err } } ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ret.update ( { host _ name : { &apos; Service DCSP Restarted &apos; : True } } ) DCNL DCSP return ret
DCSP return _ file _ lists ( load , &apos; empty _ dirs &apos; )
DCSP patterns = &#91; &#93; DCNL DCSP days _ only _ pattern = &apos; ( ? P &lt; days &gt; \ \ d + ) \ \ s + day ( s ) ? &apos; DCNL DCSP patterns.append ( days _ only _ pattern ) DCNL DCSP hms _ only _ pattern = &apos; ( ? P &lt; hours &gt; \ \ d ? \ \ d ) : ( ? P &lt; minutes &gt; \ \ d \ \ d ) : ( ? P &lt; seconds &gt; \ \ d \ \ d ) &apos; DCNL DCSP patterns.append ( hms _ only _ pattern ) DCNL DCSP ms _ only _ pattern = &apos; . ( ? P &lt; milliseconds &gt; \ \ d \ \ d \ \ d ) ( ? P &lt; microseconds &gt; \ \ d \ \ d \ \ d ) &apos; DCNL DCSP patterns.append ( ms _ only _ pattern ) DCNL DCSP hms _ and _ ms _ pattern = ( hms _ only _ pattern + ms _ only _ pattern ) DCNL DCSP patterns.append ( hms _ and _ ms _ pattern ) DCNL DCSP days _ and _ hms _ pattern = &apos; { 0 } , \ \ s + { 1 } &apos; .format ( days _ only _ pattern , hms _ only _ pattern ) DCNL DCSP patterns.append ( days _ and _ hms _ pattern ) DCNL DCSP days _ and _ hms _ and _ ms _ pattern = ( days _ and _ hms _ pattern + ms _ only _ pattern ) DCNL DCSP patterns.append ( days _ and _ hms _ and _ ms _ pattern ) DCNL DCSP for pattern in patterns : DCNL DCSP DCSP match = re.match ( &apos; ^ { 0 } $ &apos; .format ( pattern ) , s ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP break DCNL DCSP if ( not match ) : DCNL DCSP DCSP raise logic.ValidationError ( &apos; Not DCSP a DCSP valid DCSP time : DCSP { 0 } &apos; .format ( s ) ) DCNL DCSP gd = match.groupdict ( ) DCNL DCSP days = int ( gd.get ( &apos; days &apos; , &apos; 0&apos; ) ) DCNL DCSP hours = int ( gd.get ( &apos; hours &apos; , &apos; 0&apos; ) ) DCNL DCSP minutes = int ( gd.get ( &apos; minutes &apos; , &apos; 0&apos; ) ) DCNL DCSP seconds = int ( gd.get ( &apos; seconds &apos; , &apos; 0&apos; ) ) DCNL DCSP milliseconds = int ( gd.get ( &apos; milliseconds &apos; , &apos; 0&apos; ) ) DCNL DCSP microseconds = int ( gd.get ( &apos; microseconds &apos; , &apos; 0&apos; ) ) DCNL DCSP delta = datetime.timedelta ( days = days , hours = hours , minutes = minutes , seconds = seconds , milliseconds = milliseconds , microseconds = microseconds ) DCNL DCSP return delta
DCSP user = None DCNL DCSP graph = ( facebook _ graph or get _ facebook _ graph ( request , access _ token ) ) DCNL DCSP converter = get _ instance _ for ( &apos; user _ conversion &apos; , graph ) DCNL DCSP assert converter.is _ authenticated ( ) DCNL DCSP facebook _ data = converter.facebook _ profile _ data ( ) DCNL DCSP force _ registration = ( request.POST.get ( &apos; force _ registration &apos; ) or request.GET.get ( &apos; force _ registration &apos; ) or request.POST.get ( &apos; force _ registration _ hard &apos; ) or request.GET.get ( &apos; force _ registration _ hard &apos; ) ) DCNL DCSP logger.debug ( &apos; force DCSP registration DCSP is DCSP set DCSP to DCSP % s &apos; , force _ registration ) DCNL DCSP if ( connect _ facebook and request.user.is _ authenticated ( ) and ( not force _ registration ) ) : DCNL DCSP DCSP action = CONNECT _ ACTIONS.CONNECT DCNL DCSP DCSP user = _ connect _ user ( request , converter , overwrite = True ) DCNL DCSP else : DCNL DCSP DCSP email = facebook _ data.get ( &apos; email &apos; , False ) DCNL DCSP DCSP email _ verified = facebook _ data.get ( &apos; verified &apos; , False ) DCNL DCSP DCSP kwargs = { } DCNL DCSP DCSP if ( email and email _ verified ) : DCNL DCSP DCSP DCSP kwargs = { &apos; facebook _ email &apos; : email } DCNL DCSP DCSP auth _ user = authenticate ( facebook _ id = facebook _ data &#91; &apos; id &apos; &#93; , * * kwargs ) DCNL DCSP DCSP if ( auth _ user and ( not force _ registration ) ) : DCNL DCSP DCSP DCSP action = CONNECT _ ACTIONS.LOGIN DCNL DCSP DCSP DCSP update = getattr ( auth _ user , &apos; fb _ update _ required &apos; , False ) DCNL DCSP DCSP DCSP profile = try _ get _ profile ( auth _ user ) DCNL DCSP DCSP DCSP current _ facebook _ id = get _ user _ attribute ( auth _ user , profile , &apos; facebook _ id &apos; ) DCNL DCSP DCSP DCSP if ( not current _ facebook _ id ) : DCNL DCSP DCSP DCSP DCSP update = True DCNL DCSP DCSP DCSP user = _ login _ user ( request , converter , auth _ user , update = update ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP action = CONNECT _ ACTIONS.REGISTER DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP user = _ register _ user ( request , converter , remove _ old _ connections = force _ registration ) DCNL DCSP DCSP DCSP except facebook _ exceptions.AlreadyRegistered as e : DCNL DCSP DCSP DCSP DCSP logger.info ( &apos; parallel DCSP register DCSP encountered , DCSP slower DCSP thread DCSP is DCSP doing DCSP a DCSP login &apos; ) DCNL DCSP DCSP DCSP DCSP auth _ user = authenticate ( facebook _ id = facebook _ data &#91; &apos; id &apos; &#93; , * * kwargs ) DCNL DCSP DCSP DCSP DCSP if ( not auth _ user ) : DCNL DCSP DCSP DCSP DCSP DCSP raise e DCNL DCSP DCSP DCSP DCSP action = CONNECT _ ACTIONS.LOGIN DCNL DCSP DCSP DCSP DCSP user = _ login _ user ( request , converter , auth _ user , update = False ) DCNL DCSP _ update _ likes _ and _ friends ( request , user , converter ) DCNL DCSP _ update _ access _ token ( user , graph ) DCNL DCSP logger.info ( &apos; connect DCSP finished DCSP with DCSP action DCSP % s &apos; , action ) DCNL DCSP return ( action , user )
DCSP import mock DCNL DCSP import sys DCNL DCSP if ( fake _ module is None ) : DCNL DCSP DCSP fake _ module = mock.MagicMock ( ) DCNL DCSP if fake _ module : DCNL DCSP DCSP sys.modules &#91; module &#93; = fake _ module
DCSP res1a = OLS ( endog , exog _ others ) .fit ( ) DCNL DCSP res1b = OLS ( exog _ i , exog _ others ) .fit ( ) DCNL DCSP res1c = OLS ( res1a.resid , res1b.resid ) .fit ( ) DCNL DCSP return ( res1c , ( res1a , res1b ) )
DCSP for ( name , rc _ dict ) in six.iteritems ( new _ dict ) : DCNL DCSP DCSP if ( name in main _ dict ) : DCNL DCSP DCSP DCSP main _ dict &#91; name &#93; .update ( rc _ dict ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP main _ dict &#91; name &#93; = rc _ dict DCNL DCSP return main _ dict
DCSP try : DCNL DCSP DCSP return ( float ( value ) if ( &apos; .&apos; in value ) else int ( value ) ) DCNL DCSP except ValueError : DCNL DCSP DCSP return value
DCSP return LtiConsumer ( consumer _ name = &apos; Consumer DCSP Name &apos; , consumer _ key = &apos; Consumer DCSP Key &apos; , consumer _ secret = &apos; Consumer DCSP Secret &apos; )
DCSP rc ( &apos; font &apos; , size = &apos; 8&apos; ) DCNL DCSP rc ( &apos; axes &apos; , linewidth = 0.5 , edgecolor = label _ color ) DCNL DCSP rc ( &apos; axes &apos; , labelsize = 8 ) DCNL DCSP rc ( &apos; xtick &apos; , labelsize = 8 ) DCNL DCSP rc ( &apos; ytick &apos; , labelsize = 8 ) DCNL DCSP ( fig , ax ) = plt.subplots ( figsize = ( x _ len , y _ len ) ) DCNL DCSP mtitle = props.get ( &apos; title &apos; , &apos; Groups &apos; ) DCNL DCSP x _ label = props.get ( &apos; xlabel &apos; , &apos; X &apos; ) DCNL DCSP y _ label = props.get ( &apos; ylabel &apos; , &apos; Y &apos; ) DCNL DCSP ax.set _ title ( ( &apos; % s &apos; % mtitle ) , fontsize = &apos; 10 &apos; , color = label _ color ) DCNL DCSP ax.set _ xlabel ( x _ label , fontsize = &apos; 8&apos; , color = label _ color ) DCNL DCSP ax.set _ ylabel ( y _ label , fontsize = &apos; 8&apos; , color = label _ color ) DCNL DCSP sorted _ keys = sorted ( xy _ coords.keys ( ) ) DCNL DCSP for s _ label in sorted _ keys : DCNL DCSP DCSP s _ data = xy _ coords &#91; s _ label &#93; DCNL DCSP DCSP c = s _ data &#91; 3 &#93; DCNL DCSP DCSP m = s _ data &#91; 2 &#93; DCNL DCSP DCSP ax.plot ( s _ data &#91; 0 &#93; , s _ data &#91; 1 &#93; , c = c , marker = m , label = s _ label , linewidth = 0.1 , ms = 5 , alpha = 1.0 ) DCNL DCSP fp = FontProperties ( ) DCNL DCSP fp.set _ size ( &apos; 8&apos; ) DCNL DCSP ax.legend ( prop = fp , loc = 0 ) DCNL DCSP img _ name = &apos; scree _ plot.png &apos; DCNL DCSP fig.savefig ( os.path.join ( dir _ path , img _ name ) , dpi = 80 , facecolor = background _ color ) DCNL DCSP eps _ link = &apos; &apos; DCNL DCSP if generate _ eps : DCNL DCSP DCSP eps _ img _ name = str ( &apos; scree _ plot.eps &apos; ) DCNL DCSP DCSP fig.savefig ( os.path.join ( dir _ path , eps _ img _ name ) , format = &apos; eps &apos; ) DCNL DCSP DCSP ( out , err , retcode ) = qiime _ system _ call ( ( &apos; gzip DCSP -f DCSP &apos; + os.path.join ( dir _ path , eps _ img _ name ) ) ) DCNL DCSP DCSP eps _ link = ( DOWNLOAD _ LINK % ( ( os.path.join ( data _ file _ link , eps _ img _ name ) + &apos; .gz &apos; ) , &apos; Download DCSP Figure &apos; ) ) DCNL DCSP return ( os.path.join ( data _ file _ link , img _ name ) , eps _ link )
DCSP if ( pid = = 0 ) : DCNL DCSP DCSP return True DCNL DCSP try : DCNL DCSP DCSP os.kill ( pid , 0 ) DCNL DCSP except OSError as err : DCNL DCSP DCSP if ( err.errno = = errno.ESRCH ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP elif ( err.errno = = errno.EPERM ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise err DCNL DCSP else : DCNL DCSP DCSP return True
DCSP session = db.get _ session ( ) DCNL DCSP try : DCNL DCSP DCSP creds = session.query ( l2network _ models.Credential ) .filter _ by ( tenant _ id = tenant _ id ) .all ( ) DCNL DCSP DCSP return creds DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP return &#91; &#93;
DCSP def decorator ( func ) : DCNL DCSP DCSP @ functools.wraps ( func ) DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP return _ value = return _ on _ exception DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return _ value = func ( * args , * * kwargs ) DCNL DCSP DCSP DCSP except excepts as err : DCNL DCSP DCSP DCSP DCSP logger.warn ( err.strerror ) DCNL DCSP DCSP DCSP DCSP warnings.warn ( err.strerror , warning ) DCNL DCSP DCSP DCSP return return _ value DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP command = config &#91; CONF _ COMMAND &#93; DCNL DCSP return CommandLineNotificationService ( command )
DCSP if caseless : DCNL DCSP DCSP isequal = ( lambda a , b : ( a.upper ( ) = = b.upper ( ) ) ) DCNL DCSP DCSP masks = ( lambda a , b : b.upper ( ) .startswith ( a.upper ( ) ) ) DCNL DCSP DCSP parseElementClass = CaselessLiteral DCNL DCSP else : DCNL DCSP DCSP isequal = ( lambda a , b : ( a = = b ) ) DCNL DCSP DCSP masks = ( lambda a , b : b.startswith ( a ) ) DCNL DCSP DCSP parseElementClass = Literal DCNL DCSP symbols = &#91; &#93; DCNL DCSP if isinstance ( strs , basestring ) : DCNL DCSP DCSP symbols = strs.split ( ) DCNL DCSP elif isinstance ( strs , collections.Sequence ) : DCNL DCSP DCSP symbols = list ( strs &#91; : &#93; ) DCNL DCSP elif isinstance ( strs , _ generatorType ) : DCNL DCSP DCSP symbols = list ( strs ) DCNL DCSP else : DCNL DCSP DCSP warnings.warn ( &apos; Invalid DCSP argument DCSP to DCSP oneOf , DCSP expected DCSP string DCSP or DCSP list &apos; , SyntaxWarning , stacklevel = 2 ) DCNL DCSP if ( not symbols ) : DCNL DCSP DCSP return NoMatch ( ) DCNL DCSP i = 0 DCNL DCSP while ( i &lt; ( len ( symbols ) - 1 ) ) : DCNL DCSP DCSP cur = symbols &#91; i &#93; DCNL DCSP DCSP for ( j , other ) in enumerate ( symbols &#91; ( i + 1 ) : &#93; ) : DCNL DCSP DCSP DCSP if isequal ( other , cur ) : DCNL DCSP DCSP DCSP DCSP del symbols &#91; ( ( i + j ) + 1 ) &#93; DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP elif masks ( cur , other ) : DCNL DCSP DCSP DCSP DCSP del symbols &#91; ( ( i + j ) + 1 ) &#93; DCNL DCSP DCSP DCSP DCSP symbols.insert ( i , other ) DCNL DCSP DCSP DCSP DCSP cur = other DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP i + = 1 DCNL DCSP if ( ( not caseless ) and useRegex ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( len ( symbols ) = = len ( &apos; &apos;.join ( symbols ) ) ) : DCNL DCSP DCSP DCSP DCSP return Regex ( ( &apos; &#91; % s &#93; &apos; % &apos; &apos;.join ( ( _ escapeRegexRangeChars ( sym ) for sym in symbols ) ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return Regex ( &apos; &#124; &apos; .join ( ( re.escape ( sym ) for sym in symbols ) ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP warnings.warn ( &apos; Exception DCSP creating DCSP Regex DCSP for DCSP oneOf , DCSP building DCSP MatchFirst &apos; , SyntaxWarning , stacklevel = 2 ) DCNL DCSP return MatchFirst ( &#91; parseElementClass ( sym ) for sym in symbols &#93; )
DCSP path = path.replace ( &apos; / \ \ &apos; , &apos; \ \ &apos; ) DCNL DCSP path = path.replace ( &apos; / &apos; , &apos; \ \ &apos; ) DCNL DCSP m = re.match ( &apos; \ \ \ \ ( &#91; a-zA-Z &#93; ) : ( . * ) $ &apos; , path ) DCNL DCSP if m : DCNL DCSP DCSP path = ( &apos; % s : \ \ % s &apos; % ( m.group ( 1 ) , m.group ( 2 ) .lstrip ( &apos; \ \ &apos; ) ) ) DCNL DCSP return path
DCSP def constResult ( * args , * * kwargs ) : DCNL DCSP DCSP return result DCNL DCSP return constResult
DCSP if ( num _ cpus &gt; 1 ) : DCNL DCSP DCSP denoise _ seqs ( sff _ fps , fasta _ fp , tmp _ outdir , primer = primer , cluster = True , num _ cpus = num _ cpus , verbose = verbose , titanium = titanium ) DCNL DCSP else : DCNL DCSP DCSP denoise _ seqs ( sff _ fps , fasta _ fp , tmp _ outdir , primer = primer , verbose = verbose , titanium = titanium ) DCNL DCSP centroids = parse _ fasta ( open ( ( tmp _ outdir + &apos; / centroids.fasta &apos; ) ) ) DCNL DCSP singletons = parse _ fasta ( open ( ( tmp _ outdir + &apos; / singletons.fasta &apos; ) ) ) DCNL DCSP seqs = chain ( centroids , singletons ) DCNL DCSP mapping = { } DCNL DCSP cluster _ mapping = open ( ( tmp _ outdir + &apos; / denoiser _ mapping.txt &apos; ) ) DCNL DCSP for ( i , cluster ) in enumerate ( cluster _ mapping ) : DCNL DCSP DCSP ( cluster , members ) = cluster.split ( &apos; : &apos; ) DCNL DCSP DCSP members = members.split ( ) DCNL DCSP DCSP clust = &#91; cluster &#93; DCNL DCSP DCSP clust.extend ( members ) DCNL DCSP DCSP mapping &#91; i &#93; = clust DCNL DCSP return ( seqs , mapping )
DCSP url = &apos; / api / v1 / events &apos; DCNL DCSP if args : DCNL DCSP DCSP url + = ( &apos; / &apos; + &apos; / &apos; .join ( map ( str , args ) ) ) DCNL DCSP return url
DCSP if ( deletechars is None ) : DCNL DCSP DCSP f = ( lambda x : x.translate ( table ) ) DCNL DCSP else : DCNL DCSP DCSP from pandas import compat DCNL DCSP DCSP if compat.PY3 : DCNL DCSP DCSP DCSP raise ValueError ( &apos; deletechars DCSP is DCSP not DCSP a DCSP valid DCSP argument DCSP for DCSP str.translate DCSP in DCSP python DCSP 3 . DCSP You DCSP should DCSP simply DCSP specify DCSP character DCSP deletions DCSP in DCSP the DCSP table DCSP argument &apos; ) DCNL DCSP DCSP f = ( lambda x : x.translate ( table , deletechars ) ) DCNL DCSP return _ na _ map ( f , arr )
DCSP ( s , t ) = I DCNL DCSP ( a , c ) = ( field.numer ( s ) , field.denom ( s ) ) DCNL DCSP ( b , d ) = ( field.numer ( t ) , field.denom ( t ) ) DCNL DCSP return ( a , b , c , d )
DCSP migrate _ cohort _ settings ( course ) DCNL DCSP query _ set = CourseUserGroup.objects.filter ( course _ id = course.location.course _ key , group _ type = CourseUserGroup.COHORT ) DCNL DCSP query _ set = ( query _ set.filter ( cohort _ _ assignment _ type = assignment _ type ) if assignment _ type else query _ set ) DCNL DCSP return list ( query _ set )
DCSP one _ equal = False DCNL DCSP for expected in alternatives : DCNL DCSP DCSP if np.all ( ( output = = expected ) ) : DCNL DCSP DCSP DCSP one _ equal = True DCNL DCSP DCSP DCSP break DCNL DCSP assert _ ( one _ equal )
DCSP output = URLSCHEMA.sub ( ( lambda m : ( &apos; &lt; a DCSP href = &quot; % s &quot; DCSP target = &quot; _ blank &quot; &gt; % s &lt; / a &gt; &apos; % ( m.group ( 0 ) , m.group ( 0 ) ) ) ) , text ) DCNL DCSP return output
DCSP use _ kwargs = dict ( stderr = None , stdout = sp.PIPE ) DCNL DCSP use _ kwargs.update ( kwargs ) DCNL DCSP p = sp.Popen ( command , * * use _ kwargs ) DCNL DCSP output = p.communicate ( ) &#91; 0 &#93; DCNL DCSP output = ( &apos; &apos; if ( output is None ) else output ) DCNL DCSP output = ( output.decode ( &apos; utf-8 &apos; ) if isinstance ( output , bytes ) else output ) DCNL DCSP if ( p.returncode ! = 0 ) : DCNL DCSP DCSP print output DCNL DCSP DCSP err _ fun = sp.CalledProcessError. _ _ init _ _ DCNL DCSP DCSP if ( &apos; output &apos; in inspect.getargspec ( err _ fun ) .args ) : DCNL DCSP DCSP DCSP raise sp.CalledProcessError ( p.returncode , command , output ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise sp.CalledProcessError ( p.returncode , command ) DCNL DCSP return output
DCSP matches = _ ls _ logs ( fs , log _ dir _ stream , _ match _ emr _ step _ stderr _ path , step _ id = step _ id ) DCNL DCSP return sorted ( matches , key = _ match _ sort _ key , reverse = True )
DCSP return ( &apos; % s % d &apos; % ( colname ( colx ) , ( rowx + 1 ) ) )
DCSP d = _ translate _ conductor _ summary _ view ( context , vol , image _ id ) DCNL DCSP return d
DCSP try : DCNL DCSP DCSP proc = subprocess.Popen ( &#91; &apos; which &apos; , &apos; xmlsec1 &apos; &#93; , stdout = subprocess.PIPE ) DCNL DCSP DCSP return proc.stdout.read ( ) .strip ( ) DCNL DCSP except subprocess.CalledProcessError : DCNL DCSP DCSP return &apos; / usr / local / bin / xmlsec1&apos;
DCSP if ( f.registration _ required and ( not request.user.is _ authenticated ( ) ) ) : DCNL DCSP DCSP from django.contrib.auth.views import redirect _ to _ login DCNL DCSP DCSP return redirect _ to _ login ( request.path ) DCNL DCSP if f.template _ name : DCNL DCSP DCSP t = loader.select _ template ( ( f.template _ name , DEFAULT _ TEMPLATE ) ) DCNL DCSP else : DCNL DCSP DCSP t = loader.get _ template ( DEFAULT _ TEMPLATE ) DCNL DCSP f.title = mark _ safe ( f.title ) DCNL DCSP f.content = mark _ safe ( f.content ) DCNL DCSP c = RequestContext ( request , { &apos; flatpage &apos; : f } ) DCNL DCSP response = HttpResponse ( t.render ( c ) ) DCNL DCSP populate _ xheaders ( request , response , FlatPage , f.id ) DCNL DCSP return response
DCSP if ( not salt.utils.exactly _ one ( ( subnet _ id , subnet _ name ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; One DCSP ( but DCSP not DCSP both ) DCSP of DCSP subnet _ id DCSP or DCSP subnet _ name DCSP must DCSP be DCSP provided . &apos; ) DCNL DCSP if subnet _ name : DCNL DCSP DCSP resource = _ _ salt _ _ &#91; &apos; boto _ vpc.get _ resource _ id &apos; &#93; ( &apos; subnet &apos; , subnet _ name , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP if ( &apos; id &apos; not in resource ) : DCNL DCSP DCSP DCSP log.warning ( &quot; Couldn &apos;t DCSP resolve DCSP subnet DCSP name DCSP { 0 } . &quot; ) .format ( subnet _ name ) DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP subnet _ id = resource &#91; &apos; id &apos; &#93; DCNL DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP r = { } DCNL DCSP result = _ get _ network _ interface ( conn , name ) DCNL DCSP if ( &apos; result &apos; in result ) : DCNL DCSP DCSP r &#91; &apos; error &apos; &#93; = { &apos; message &apos; : &apos; An DCSP ENI DCSP with DCSP this DCSP Name DCSP tag DCSP already DCSP exists . &apos; } DCNL DCSP DCSP return r DCNL DCSP vpc _ id = _ _ salt _ _ &#91; &apos; boto _ vpc.get _ subnet _ association &apos; &#93; ( &#91; subnet _ id &#93; , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP vpc _ id = vpc _ id.get ( &apos; vpc _ id &apos; ) DCNL DCSP if ( not vpc _ id ) : DCNL DCSP DCSP msg = &apos; subnet _ id DCSP { 0 } DCSP does DCSP not DCSP map DCSP to DCSP a DCSP valid DCSP vpc DCSP id . &apos; .format ( subnet _ id ) DCNL DCSP DCSP r &#91; &apos; error &apos; &#93; = { &apos; message &apos; : msg } DCNL DCSP DCSP return r DCNL DCSP _ groups = _ _ salt _ _ &#91; &apos; boto _ secgroup.convert _ to _ group _ ids &apos; &#93; ( groups , vpc _ id = vpc _ id , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP try : DCNL DCSP DCSP eni = conn.create _ network _ interface ( subnet _ id , private _ ip _ address = private _ ip _ address , description = description , groups = _ groups ) DCNL DCSP DCSP eni.add _ tag ( &apos; Name &apos; , name ) DCNL DCSP except boto.exception.EC2ResponseError as e : DCNL DCSP DCSP r &#91; &apos; error &apos; &#93; = _ _ utils _ _ &#91; &apos; boto.get _ error &apos; &#93; ( e ) DCNL DCSP DCSP return r DCNL DCSP r &#91; &apos; result &apos; &#93; = _ describe _ network _ interface ( eni ) DCNL DCSP return r
DCSP return IMPL.network _ disassociate ( context , network _ id , disassociate _ host , disassociate _ project )
DCSP x = 1 DCNL DCSP for ( y , z ) in zip ( F , E ) : DCNL DCSP DCSP x * = ( y * * z ) DCNL DCSP return x
DCSP rpc = create _ rpc ( deadline ) DCNL DCSP make _ get _ public _ certificates _ call ( rpc ) DCNL DCSP rpc.wait ( ) DCNL DCSP return rpc.get _ result ( )
DCSP if ( password is not None ) : DCNL DCSP DCSP password = str ( password ) DCNL DCSP if ( encrypted and password and ( not password.startswith ( &apos; md5 &apos; ) ) ) : DCNL DCSP DCSP password = &apos; md5 { 0 } &apos; .format ( hashlib.md5 ( salt.utils.to _ bytes ( &apos; { 0 } { 1 } &apos; .format ( password , role ) ) ) .hexdigest ( ) ) DCNL DCSP return password
DCSP url = u &apos;https : / / api.github.com / repos / edx / edx-platform / pulls / { num } &apos; .format ( num = num ) DCNL DCSP ( username , token ) = get _ github _ creds ( ) DCNL DCSP headers = { u &apos;Authorization &apos; : u &apos;token DCSP { } &apos; .format ( token ) , u &apos;User-Agent &apos; : u &apos;edx-release &apos; } DCNL DCSP response = requests.get ( url , headers = headers ) DCNL DCSP result = response.json ( ) DCNL DCSP if ( not response.ok ) : DCNL DCSP DCSP raise requests.exceptions.RequestException ( result &#91; u &apos;message &apos; &#93; ) DCNL DCSP return result
DCSP for start in settings.IGNORABLE _ 404 _ STARTS : DCNL DCSP DCSP if uri.startswith ( start ) : DCNL DCSP DCSP DCSP return True DCNL DCSP for end in settings.IGNORABLE _ 404 _ ENDS : DCNL DCSP DCSP if uri.endswith ( end ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP try : DCNL DCSP DCSP allow _ CTRL _ C ( ) DCNL DCSP DCSP app = QtCore.QCoreApplication.instance ( ) DCNL DCSP DCSP if ( not app ) : DCNL DCSP DCSP DCSP return 0 DCNL DCSP DCSP app.processEvents ( QtCore.QEventLoop.AllEvents , 300 ) DCNL DCSP DCSP if ( not stdin _ ready ( ) ) : DCNL DCSP DCSP DCSP timer = QtCore.QTimer ( ) DCNL DCSP DCSP DCSP event _ loop = QtCore.QEventLoop ( ) DCNL DCSP DCSP DCSP timer.timeout.connect ( event _ loop.quit ) DCNL DCSP DCSP DCSP while ( not stdin _ ready ( ) ) : DCNL DCSP DCSP DCSP DCSP timer.start ( 50 ) DCNL DCSP DCSP DCSP DCSP event _ loop.exec _ ( ) DCNL DCSP DCSP DCSP DCSP timer.stop ( ) DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP print &apos; \ nKeyboardInterrupt DCSP - DCSP Press DCSP Enter DCSP for DCSP new DCSP prompt &apos; DCNL DCSP except : DCNL DCSP DCSP ignore _ CTRL _ C ( ) DCNL DCSP DCSP from traceback import print _ exc DCNL DCSP DCSP print _ exc ( ) DCNL DCSP DCSP print &apos; Got DCSP exception DCSP from DCSP inputhook , DCSP unregistering . &apos; DCNL DCSP DCSP clear _ inputhook ( ) DCNL DCSP finally : DCNL DCSP DCSP allow _ CTRL _ C ( ) DCNL DCSP return 0
DCSP if isinstance ( s , string _ t ) : DCNL DCSP DCSP return s.split ( u &apos; , &apos; ) DCNL DCSP return s
DCSP root _ logger = logging.getLogger ( ) DCNL DCSP old _ level = root _ logger.getEffectiveLevel ( ) DCNL DCSP old _ id = getattr ( local _ context , u &apos;session _ id &apos; , None ) DCNL DCSP local _ context.session _ id = ( old _ id or uuid.uuid4 ( ) ) DCNL DCSP old _ output = getattr ( local _ context , u &apos;output &apos; , None ) DCNL DCSP old _ loglevel = getattr ( local _ context , u &apos;loglevel &apos; , None ) DCNL DCSP streamhandler = logging.StreamHandler ( stream ) DCNL DCSP streamhandler.setFormatter ( FlexGetFormatter ( ) ) DCNL DCSP streamhandler.addFilter ( SessionFilter ( local _ context.session _ id ) ) DCNL DCSP if ( loglevel is not None ) : DCNL DCSP DCSP loglevel = get _ level _ no ( loglevel ) DCNL DCSP DCSP streamhandler.setLevel ( loglevel ) DCNL DCSP DCSP if ( not root _ logger.isEnabledFor ( loglevel ) ) : DCNL DCSP DCSP DCSP root _ logger.setLevel ( loglevel ) DCNL DCSP local _ context.output = stream DCNL DCSP local _ context.loglevel = loglevel DCNL DCSP root _ logger.addHandler ( streamhandler ) DCNL DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP root _ logger.removeHandler ( streamhandler ) DCNL DCSP DCSP root _ logger.setLevel ( old _ level ) DCNL DCSP DCSP local _ context.session _ id = old _ id DCNL DCSP DCSP local _ context.output = old _ output DCNL DCSP DCSP local _ context.loglevel = old _ loglevel
DCSP logger = pyalgotrade.logger.getLogger ( &apos; yahoofinance &apos; ) DCNL DCSP ret = yahoofeed.Feed ( frequency , timezone ) DCNL DCSP if ( not os.path.exists ( storage ) ) : DCNL DCSP DCSP logger.info ( ( &apos; Creating DCSP % s DCSP directory &apos; % storage ) ) DCNL DCSP DCSP os.mkdir ( storage ) DCNL DCSP for year in range ( fromYear , ( toYear + 1 ) ) : DCNL DCSP DCSP for instrument in instruments : DCNL DCSP DCSP DCSP fileName = os.path.join ( storage , ( &apos; % s- % d-yahoofinance.csv &apos; % ( instrument , year ) ) ) DCNL DCSP DCSP DCSP if ( not os.path.exists ( fileName ) ) : DCNL DCSP DCSP DCSP DCSP logger.info ( ( &apos; Downloading DCSP % s DCSP % d DCSP to DCSP % s &apos; % ( instrument , year , fileName ) ) ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP if ( frequency = = bar.Frequency.DAY ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP download _ daily _ bars ( instrument , year , fileName ) DCNL DCSP DCSP DCSP DCSP DCSP elif ( frequency = = bar.Frequency.WEEK ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP download _ weekly _ bars ( instrument , year , fileName ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise Exception ( &apos; Invalid DCSP frequency &apos; ) DCNL DCSP DCSP DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP DCSP DCSP if skipErrors : DCNL DCSP DCSP DCSP DCSP DCSP DCSP logger.error ( str ( e ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise e DCNL DCSP DCSP DCSP ret.addBarsFromCSV ( instrument , fileName ) DCNL DCSP return ret
DCSP return &apos; , DCSP &apos; .join ( DOC _ PATHS.keys ( ) )
DCSP which = ( &apos; pulls &apos; if pulls else &apos; issues &apos; ) DCNL DCSP if isinstance ( period , timedelta ) : DCNL DCSP DCSP since = round _ hour ( ( datetime.utcnow ( ) - period ) ) DCNL DCSP else : DCNL DCSP DCSP since = period DCNL DCSP url = ( &apos; https : / / api.github.com / repos / % s / % s ? state = closed &amp; sort = updated &amp; since = % s &amp; per _ page = % i &apos; % ( project , which , since.strftime ( ISO8601 ) , PER _ PAGE ) ) DCNL DCSP allclosed = get _ paged _ request ( url , headers = make _ auth _ header ( ) ) DCNL DCSP filtered = &#91; i for i in allclosed if ( _ parse _ datetime ( i &#91; &apos; closed _ at &apos; &#93; ) &gt; since ) &#93; DCNL DCSP if pulls : DCNL DCSP DCSP filtered = &#91; i for i in filtered if ( _ parse _ datetime ( i &#91; &apos; merged _ at &apos; &#93; ) &gt; since ) &#93; DCNL DCSP DCSP filtered = &#91; i for i in filtered if ( i &#91; &apos; base &apos; &#93; &#91; &apos; ref &apos; &#93; = = &apos; master &apos; ) &#93; DCNL DCSP else : DCNL DCSP DCSP filtered = &#91; i for i in filtered if ( not is _ pull _ request ( i ) ) &#93; DCNL DCSP return filtered
DCSP with all _ warnings ( ) as w : DCNL DCSP DCSP ( yield w ) DCNL DCSP DCSP remaining = &#91; m for m in matching if ( &apos; \ \ A \ \ Z &apos; not in m.split ( &apos; &#124; &apos; ) ) &#93; DCNL DCSP DCSP for warn in w : DCNL DCSP DCSP DCSP found = False DCNL DCSP DCSP DCSP for match in matching : DCNL DCSP DCSP DCSP DCSP if ( re.search ( match , str ( warn.message ) ) is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP found = True DCNL DCSP DCSP DCSP DCSP DCSP if ( match in remaining ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP remaining.remove ( match ) DCNL DCSP DCSP DCSP if ( not found ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; Unexpected DCSP warning : DCSP % s &apos; % str ( warn.message ) ) ) DCNL DCSP DCSP if ( len ( remaining ) &gt; 0 ) : DCNL DCSP DCSP DCSP msg = ( &apos; No DCSP warning DCSP raised DCSP matching : \ n % s &apos; % &apos; \ n &apos; .join ( remaining ) ) DCNL DCSP DCSP DCSP raise ValueError ( msg )
DCSP if add _ deprecation _ to _ docstring : DCNL DCSP DCSP header = ( &apos; .. DCSP deprecated : : DCSP % s DCSP ( pending ) DCSP % s &apos; % ( version , ( message or &apos; &apos; ) ) ) DCNL DCSP else : DCNL DCSP DCSP header = None DCNL DCSP if ( message is None ) : DCNL DCSP DCSP message = &apos; Call DCSP to DCSP deprecated DCSP function DCSP % ( func ) s &apos; DCNL DCSP def decorate ( fn ) : DCNL DCSP DCSP return _ decorate _ with _ warning ( fn , exc.SAPendingDeprecationWarning , ( message % dict ( func = fn . _ _ name _ _ ) ) , header ) DCNL DCSP return decorate
DCSP def capture ( function ) : DCNL DCSP DCSP @ functools.wraps ( function ) DCNL DCSP DCSP def captured _ function ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return function ( * args , * * kwargs ) DCNL DCSP DCSP DCSP except Exception as exc : DCNL DCSP DCSP DCSP DCSP async _ result.set _ exception ( exc ) DCNL DCSP DCSP return captured _ function DCNL DCSP return capture
DCSP name = getattr ( obj , &apos; name &apos; , None ) DCNL DCSP if ( name and isinstance ( name , builtin _ str ) and ( name &#91; 0 &#93; ! = &apos; &lt; &apos; ) and ( name &#91; ( -1 ) &#93; ! = &apos; &gt; &apos; ) ) : DCNL DCSP DCSP return os.path.basename ( name )
DCSP kwargs = { &apos; name &apos; : name } DCNL DCSP result = util.callm ( ( &apos; % s / % s &apos; % ( &apos; catalog &apos; , &apos; profile &apos; ) ) , kwargs ) DCNL DCSP return Catalog ( * * util.fix ( result &#91; &apos; response &apos; &#93; &#91; &apos; catalog &apos; &#93; ) )
DCSP start = timer ( ) DCNL DCSP sess.run ( reset ) DCNL DCSP for _ in xrange ( num _ unrolls ) : DCNL DCSP DCSP cost = sess.run ( ( &#91; cost _ op &#93; + ops ) ) &#91; 0 &#93; DCNL DCSP return ( ( timer ( ) - start ) , cost )
DCSP try : DCNL DCSP DCSP patchOperations = &#91; &#93; DCNL DCSP DCSP for api in apis : DCNL DCSP DCSP DCSP patchOperations.append ( { &apos; op &apos; : op , &apos; path &apos; : &apos; / apiStages &apos; , &apos; value &apos; : &apos; { 0 } : { 1 } &apos; .format ( api &#91; &apos; apiId &apos; &#93; , api &#91; &apos; stage &apos; &#93; ) } ) DCNL DCSP DCSP res = None DCNL DCSP DCSP if patchOperations : DCNL DCSP DCSP DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP DCSP res = conn.update _ usage _ plan ( usagePlanId = plan _ id , patchOperations = patchOperations ) DCNL DCSP DCSP return { &apos; success &apos; : True , &apos; result &apos; : res } DCNL DCSP except ClientError as e : DCNL DCSP DCSP return { &apos; error &apos; : salt.utils.boto3.get _ error ( e ) } DCNL DCSP except Exception as e : DCNL DCSP DCSP return { &apos; error &apos; : e }
DCSP for field in resource _ media _ fields ( document , resource ) : DCNL DCSP DCSP if ( original and ( field in original ) ) : DCNL DCSP DCSP DCSP if isinstance ( original &#91; field &#93; , list ) : DCNL DCSP DCSP DCSP DCSP for file _ id in original &#91; field &#93; : DCNL DCSP DCSP DCSP DCSP DCSP app.media.delete ( file _ id , resource ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP app.media.delete ( original &#91; field &#93; , resource ) DCNL DCSP DCSP if document &#91; field &#93; : DCNL DCSP DCSP DCSP if isinstance ( document &#91; field &#93; , list ) : DCNL DCSP DCSP DCSP DCSP id _ lst = &#91; &#93; DCNL DCSP DCSP DCSP DCSP for stor _ obj in document &#91; field &#93; : DCNL DCSP DCSP DCSP DCSP DCSP id _ lst.append ( app.media.put ( stor _ obj , filename = stor _ obj.filename , content _ type = stor _ obj.mimetype , resource = resource ) ) DCNL DCSP DCSP DCSP DCSP document &#91; field &#93; = id _ lst DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP document &#91; field &#93; = app.media.put ( document &#91; field &#93; , filename = document &#91; field &#93; .filename , content _ type = document &#91; field &#93; .mimetype , resource = resource )
DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Searching DCSP for DCSP hosts &apos; } , &apos; progress &apos; ) DCNL DCSP data = query ( host , quiet = True ) DCNL DCSP for node in data : DCNL DCSP DCSP if ( &apos; vm _ info &apos; in data &#91; node &#93; ) : DCNL DCSP DCSP DCSP if ( name in data &#91; node &#93; &#91; &apos; vm _ info &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Virtual DCSP machine DCSP { 0 } DCSP is DCSP already DCSP deployed &apos; .format ( name ) } , &apos; progress &apos; ) DCNL DCSP DCSP DCSP DCSP return &apos; fail &apos; DCNL DCSP if ( host is None ) : DCNL DCSP DCSP host = _ determine _ host ( data ) DCNL DCSP if ( ( host not in data ) or ( not host ) ) : DCNL DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Host DCSP { 0 } DCSP was DCSP not DCSP found &apos; .format ( host ) } , &apos; progress &apos; ) DCNL DCSP DCSP return &apos; fail &apos; DCNL DCSP pub _ key = None DCNL DCSP priv _ key = None DCNL DCSP if seed : DCNL DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Minion DCSP will DCSP be DCSP preseeded &apos; } , &apos; progress &apos; ) DCNL DCSP DCSP ( priv _ key , pub _ key ) = salt.utils.cloud.gen _ keys ( ) DCNL DCSP DCSP accepted _ key = os.path.join ( _ _ opts _ _ &#91; &apos; pki _ dir &apos; &#93; , &apos; minions &apos; , name ) DCNL DCSP DCSP with salt.utils.fopen ( accepted _ key , &apos; w &apos; ) as fp _ : DCNL DCSP DCSP DCSP fp _ .write ( pub _ key ) DCNL DCSP client = salt.client.get _ local _ client ( _ _ opts _ _ &#91; &apos; conf _ file &apos; &#93; ) DCNL DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Creating DCSP VM DCSP { 0 } DCSP on DCSP host DCSP { 1 } &apos; .format ( name , host ) } , &apos; progress &apos; ) DCNL DCSP try : DCNL DCSP DCSP cmd _ ret = client.cmd _ iter ( host , &apos; virt.init &apos; , &#91; name , cpu , mem , image , nic , hypervisor , start , disk , saltenv , seed , install , pub _ key , priv _ key , enable _ vnc &#93; , timeout = 600 ) DCNL DCSP except SaltClientError as client _ error : DCNL DCSP DCSP print ( client _ error ) DCNL DCSP ret = next ( cmd _ ret ) DCNL DCSP if ( not ret ) : DCNL DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; VM DCSP { 0 } DCSP was DCSP not DCSP initialized . &apos; .format ( name ) } , &apos; progress &apos; ) DCNL DCSP DCSP return &apos; fail &apos; DCNL DCSP for minion _ id in ret : DCNL DCSP DCSP if ( ret &#91; minion _ id &#93; &#91; &apos; ret &apos; &#93; is False ) : DCNL DCSP DCSP DCSP print ( &apos; VM DCSP { 0 } DCSP initialization DCSP failed . DCSP Returned DCSP error : DCSP { 1 } &apos; .format ( name , ret &#91; minion _ id &#93; &#91; &apos; ret &apos; &#93; ) ) DCNL DCSP DCSP DCSP return &apos; fail &apos; DCNL DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; VM DCSP { 0 } DCSP initialized DCSP on DCSP host DCSP { 1 } &apos; .format ( name , host ) } , &apos; progress &apos; ) DCNL DCSP return &apos; good&apos;
DCSP if list : DCNL DCSP DCSP assert ( len ( list ) = = 1 ) , list DCNL DCSP DCSP return list &#91; 0 &#93; DCNL DCSP return default
DCSP url = nzo.nzo _ info.get ( &apos; failure &apos; ) DCNL DCSP if ( url and cfg.new _ nzb _ on _ failure ( ) ) : DCNL DCSP DCSP sabnzbd.add _ url ( url , nzo.pp , nzo.script , nzo.cat , nzo.priority )
DCSP if ( not target ) : DCNL DCSP DCSP target = mat DCNL DCSP if exact : DCNL DCSP DCSP err _ code = _ cudamat.apply _ log _ 1 _ plus _ exp _ exact ( mat.p _ mat , target.p _ mat ) DCNL DCSP else : DCNL DCSP DCSP err _ code = _ cudamat.apply _ log _ 1 _ plus _ exp ( mat.p _ mat , target.p _ mat ) DCNL DCSP if err _ code : DCNL DCSP DCSP raise generate _ exception ( err _ code ) DCNL DCSP return target
DCSP @ app.task ( name = u &apos;celery.backend _ cleanup &apos; , shared = False , lazy = False ) DCNL DCSP def backend _ cleanup ( ) : DCNL DCSP DCSP app.backend.cleanup ( ) DCNL DCSP return backend _ cleanup
DCSP maps = read _ morph _ map ( subject _ to , subject _ from , subjects _ dir ) DCNL DCSP stc _ morph = stc.copy ( ) DCNL DCSP stc _ morph.subject = subject _ to DCNL DCSP cnt = 0 DCNL DCSP for ( k , hemi ) in enumerate ( &#91; &apos; lh &apos; , &apos; rh &apos; &#93; ) : DCNL DCSP DCSP if ( stc.vertices &#91; k &#93; .size &gt; 0 ) : DCNL DCSP DCSP DCSP map _ hemi = maps &#91; k &#93; DCNL DCSP DCSP DCSP vertno _ k = _ sparse _ argmax _ nnz _ row ( map _ hemi &#91; stc.vertices &#91; k &#93; &#93; ) DCNL DCSP DCSP DCSP order = np.argsort ( vertno _ k ) DCNL DCSP DCSP DCSP n _ active _ hemi = len ( vertno _ k ) DCNL DCSP DCSP DCSP data _ hemi = stc _ morph . _ data &#91; cnt : ( cnt + n _ active _ hemi ) &#93; DCNL DCSP DCSP DCSP stc _ morph . _ data &#91; cnt : ( cnt + n _ active _ hemi ) &#93; = data _ hemi &#91; order &#93; DCNL DCSP DCSP DCSP stc _ morph.vertices &#91; k &#93; = vertno _ k &#91; order &#93; DCNL DCSP DCSP DCSP cnt + = n _ active _ hemi DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP stc _ morph.vertices &#91; k &#93; = np.array ( &#91; &#93; , int ) DCNL DCSP return stc _ morph
DCSP return getJoinedPath ( getFabmetheusPath ( &apos; documentation &apos; ) , subName )
DCSP cursor = schema _ editor.connection.cursor ( ) DCNL DCSP if ( not hasattr ( cursor.db , u &apos;mysql _ version &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP db _ name = cursor.db.get _ connection _ params ( ) &#91; u &apos;db &apos; &#93; DCNL DCSP table _ name = apps.get _ model ( u &apos;accounts.User &apos; ) . _ meta.local _ many _ to _ many &#91; 0 &#93; .m2m _ db _ table ( ) DCNL DCSP cursor.execute ( ( u &quot; SELECT DCSP COLUMN _ NAME DCSP FROM DCSP INFORMATION _ SCHEMA.COLUMNS DCSP WHERE DCSP TABLE _ SCHEMA DCSP = DCSP &apos; % s &apos; DCSP DCSP DCSP AND DCSP TABLE _ NAME DCSP = DCSP &apos; % s &apos; DCSP DCSP DCSP AND DCSP COLUMN _ NAME DCSP = DCSP &apos; pootleprofile _ id &apos; ; &quot; % ( db _ name , table _ name ) ) ) DCNL DCSP if ( not cursor.fetchone ( ) ) : DCNL DCSP DCSP return DCNL DCSP cursor.execute ( ( u &quot; SELECT DCSP CONSTRAINT _ NAME DCSP DCSP DCSP FROM DCSP INFORMATION _ SCHEMA.KEY _ COLUMN _ USAGE DCSP DCSP DCSP WHERE DCSP TABLE _ SCHEMA DCSP = DCSP &apos; % s &apos; DCSP DCSP DCSP DCSP DCSP AND DCSP TABLE _ NAME DCSP = DCSP &apos; % s &apos; DCSP DCSP DCSP DCSP DCSP AND DCSP COLUMN _ NAME DCSP = DCSP &apos; pootleprofile _ id &apos; &quot; % ( db _ name , table _ name ) ) ) DCNL DCSP uniq = None DCNL DCSP fk = None DCNL DCSP default = False DCNL DCSP for constraint in cursor.fetchall ( ) : DCNL DCSP DCSP if constraint &#91; 0 &#93; .endswith ( u &apos;uniq &apos; ) : DCNL DCSP DCSP DCSP uniq = constraint &#91; 0 &#93; DCNL DCSP DCSP elif constraint &#91; 0 &#93; .startswith ( u &apos;pootleprofile _ id _ refs &apos; ) : DCNL DCSP DCSP DCSP fk = constraint &#91; 0 &#93; DCNL DCSP DCSP elif ( constraint &#91; 0 &#93; = = u &apos;pootleprofile _ id &apos; ) : DCNL DCSP DCSP DCSP default = True DCNL DCSP if uniq : DCNL DCSP DCSP cursor.execute ( ( u &apos;ALTER DCSP TABLE DCSP % s DCSP DCSP DCSP DROP DCSP KEY DCSP % s &apos; % ( table _ name , uniq ) ) ) DCNL DCSP if fk : DCNL DCSP DCSP cursor.execute ( ( u &apos;ALTER DCSP TABLE DCSP % s DCSP DCSP DCSP DROP DCSP FOREIGN DCSP KEY DCSP % s &apos; % ( table _ name , fk ) ) ) DCNL DCSP if default : DCNL DCSP DCSP cursor.execute ( ( u &apos;DROP DCSP INDEX DCSP pootleprofile _ id DCSP DCSP DCSP ON DCSP % s ; &apos; % table _ name ) ) DCNL DCSP cursor.execute ( ( u &apos;ALTER DCSP TABLE DCSP % s DCSP DCSP DCSP DROP DCSP COLUMN DCSP pootleprofile _ id &apos; % table _ name ) )
DCSP &#91; curr _ metrics , last _ metrics &#93; = get _ metrics ( ) DCNL DCSP metric _ name _ list = name.split ( &apos; _ &apos; ) &#91; 1 : &#93; DCNL DCSP metric _ name = &apos; _ &apos; .join ( metric _ name _ list ) DCNL DCSP try : DCNL DCSP DCSP delta = ( ( float ( curr _ metrics &#91; &apos; data &apos; &#93; &#91; metric _ name &#93; ) - float ( last _ metrics &#91; &apos; data &apos; &#93; &#91; metric _ name &#93; ) ) / ( curr _ metrics &#91; &apos; time &apos; &#93; - last _ metrics &#91; &apos; time &apos; &#93; ) ) DCNL DCSP DCSP if ( delta &lt; 0 ) : DCNL DCSP DCSP DCSP if Debug : DCNL DCSP DCSP DCSP DCSP print ( name + &apos; DCSP is DCSP less DCSP 0 . DCSP Setting DCSP value DCSP to DCSP 0 . &apos; ) DCNL DCSP DCSP DCSP delta = 0 DCNL DCSP except KeyError : DCNL DCSP DCSP if Debug : DCNL DCSP DCSP DCSP print ( ( &apos; Key DCSP &apos; + name ) + &quot; DCSP can &apos;t DCSP be DCSP found . &quot; ) DCNL DCSP DCSP delta = 0.0 DCNL DCSP return delta
DCSP for desc in _ description.splitlines ( ) : DCNL DCSP DCSP print desc
DCSP mgr.set _ lang _ info ( lang , silvercity _ lexer = HTML5Lexer ( ) , buf _ class = HTML5Buffer , langintel _ class = HTML5LangIntel , cile _ driver _ class = HTML5CILEDriver , is _ cpln _ lang = True )
DCSP pattern = &apos; ( \ \ &quot; . * ? \ \ &quot; &#124; \ \ \ &apos; . * ? \ \ \ &apos; ) &#124; ( &lt; # . * ? # &gt; &#124; # &#91; ^ \ \ r \ \ n &#93; * $ ) &apos; DCNL DCSP regex = re.compile ( pattern , ( re.MULTILINE &#124; re.DOTALL ) ) DCNL DCSP def _ replacer ( match ) : DCNL DCSP DCSP if ( match.group ( 2 ) is not None ) : DCNL DCSP DCSP DCSP return &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return match.group ( 1 ) DCNL DCSP return regex.sub ( _ replacer , string )
DCSP result = script.pip ( &apos; install &apos; , data.root , expect _ error = True ) DCNL DCSP assert ( not result.files _ created ) DCNL DCSP assert ( &quot; is DCSP not DCSP installable . DCSP File DCSP &apos; setup.py &apos; DCSP not DCSP found . &quot; in result.stderr )
DCSP env = inliner.document.settings.env DCNL DCSP r = env.get _ domain ( &apos; py &apos; ) .role ( &apos; obj &apos; ) ( &apos; obj &apos; , rawtext , etext , lineno , inliner , options , content ) DCNL DCSP pnode = r &#91; 0 &#93; &#91; 0 &#93; DCNL DCSP prefixes = get _ import _ prefixes _ from _ env ( env ) DCNL DCSP try : DCNL DCSP DCSP ( name , obj , parent ) = import _ by _ name ( pnode &#91; &apos; reftarget &apos; &#93; , prefixes ) DCNL DCSP except ImportError : DCNL DCSP DCSP content = pnode &#91; 0 &#93; DCNL DCSP DCSP r &#91; 0 &#93; &#91; 0 &#93; = nodes.emphasis ( rawtext , content &#91; 0 &#93; .astext ( ) , classes = content &#91; &apos; classes &apos; &#93; ) DCNL DCSP return r
DCSP if six.PY3 : DCNL DCSP DCSP os.makedirs ( newdir , mode = mode , exist _ ok = True ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP os.makedirs ( newdir , mode = mode ) DCNL DCSP DCSP except OSError as exception : DCNL DCSP DCSP DCSP if ( exception.errno ! = errno.EEXIST ) : DCNL DCSP DCSP DCSP DCSP raise
DCSP return a.repeat ( repeats , axis )
DCSP for op in all _ unary ( prec , exp _ range , itr ) : DCNL DCSP DCSP fmt1 = rand _ format ( chr ( random.randrange ( 0 , 128 ) ) , &apos; EeGgn &apos; ) DCNL DCSP DCSP fmt2 = rand _ locale ( ) DCNL DCSP DCSP for fmt in ( fmt1 , fmt2 ) : DCNL DCSP DCSP DCSP fmtop = ( op &#91; 0 &#93; , fmt ) DCNL DCSP DCSP DCSP t = TestSet ( method , fmtop ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( not convert ( t , convstr = False ) ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP callfuncs ( t ) DCNL DCSP DCSP DCSP DCSP verify ( t , stat ) DCNL DCSP DCSP DCSP except VerifyError as err : DCNL DCSP DCSP DCSP DCSP log ( err ) DCNL DCSP for op in all _ unary ( prec , 9999 , itr ) : DCNL DCSP DCSP fmt1 = rand _ format ( chr ( random.randrange ( 0 , 128 ) ) , &apos; Ff % &apos; ) DCNL DCSP DCSP fmt2 = rand _ locale ( ) DCNL DCSP DCSP for fmt in ( fmt1 , fmt2 ) : DCNL DCSP DCSP DCSP fmtop = ( op &#91; 0 &#93; , fmt ) DCNL DCSP DCSP DCSP t = TestSet ( method , fmtop ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( not convert ( t , convstr = False ) ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP callfuncs ( t ) DCNL DCSP DCSP DCSP DCSP verify ( t , stat ) DCNL DCSP DCSP DCSP except VerifyError as err : DCNL DCSP DCSP DCSP DCSP log ( err )
DCSP encodedStream = &apos; &apos; DCNL DCSP return ( ( -1 ) , &apos; RunLengthEncode DCSP not DCSP supported DCSP yet &apos; )
DCSP split = set ( re.findall ( &apos; \ \ w + &apos; , keyword ) ) DCNL DCSP return split
DCSP validate _ user _ access _ to _ subscribers ( requesting _ user , stream ) DCNL DCSP subscriptions = Subscription.objects.filter ( recipient _ _ type = Recipient.STREAM , recipient _ _ type _ id = stream.id , user _ profile _ _ is _ active = True , active = True ) DCNL DCSP return subscriptions
DCSP import hikvision.api DCNL DCSP from hikvision.error import HikvisionError , MissingParamError DCNL DCSP host = config.get ( CONF _ HOST ) DCNL DCSP port = config.get ( CONF _ PORT ) DCNL DCSP name = config.get ( CONF _ NAME ) DCNL DCSP username = config.get ( CONF _ USERNAME ) DCNL DCSP password = config.get ( CONF _ PASSWORD ) DCNL DCSP try : DCNL DCSP DCSP hikvision _ cam = hikvision.api.CreateDevice ( host , port = port , username = username , password = password , is _ https = False ) DCNL DCSP except MissingParamError as param _ err : DCNL DCSP DCSP _ LOGGING.error ( &apos; Missing DCSP required DCSP param : DCSP % s &apos; , param _ err ) DCNL DCSP DCSP return False DCNL DCSP except HikvisionError as conn _ err : DCNL DCSP DCSP _ LOGGING.error ( &apos; Unable DCSP to DCSP connect : DCSP % s &apos; , conn _ err ) DCNL DCSP DCSP return False DCNL DCSP add _ devices ( &#91; HikvisionMotionSwitch ( name , hikvision _ cam ) &#93; )
DCSP locator = xblock.location DCNL DCSP parent _ location = modulestore ( ) .get _ parent _ location ( locator ) DCNL DCSP if ( parent _ location is None ) : DCNL DCSP DCSP return None DCNL DCSP return modulestore ( ) .get _ item ( parent _ location )
DCSP return getCraftedTextFromText ( archive.getTextIfEmpty ( fileName , text ) , repository )
DCSP LOG.debug ( _ ( &apos; Making DCSP synchronous DCSP call DCSP on DCSP % s DCSP ... &apos; ) , topic ) DCNL DCSP msg _ id = uuid.uuid4 ( ) .hex DCNL DCSP msg.update ( { &apos; _ msg _ id &apos; : msg _ id } ) DCNL DCSP LOG.debug ( ( _ ( &apos; MSG _ ID DCSP is DCSP % s &apos; ) % msg _ id ) ) DCNL DCSP _ add _ unique _ id ( msg ) DCNL DCSP pack _ context ( msg , context ) DCNL DCSP with _ reply _ proxy _ create _ sem : DCNL DCSP DCSP if ( not connection _ pool.reply _ proxy ) : DCNL DCSP DCSP DCSP connection _ pool.reply _ proxy = ReplyProxy ( conf , connection _ pool ) DCNL DCSP msg.update ( { &apos; _ reply _ q &apos; : connection _ pool.reply _ proxy.get _ reply _ q ( ) } ) DCNL DCSP wait _ msg = MulticallProxyWaiter ( conf , msg _ id , timeout , connection _ pool ) DCNL DCSP with ConnectionContext ( conf , connection _ pool ) as conn : DCNL DCSP DCSP conn.topic _ send ( topic , rpc _ common.serialize _ msg ( msg ) , timeout ) DCNL DCSP return wait _ msg
DCSP package = data.packages.join ( &apos; requires _ source-1.0-py2.py3-none-any.whl &apos; ) DCNL DCSP result = script.pip ( &apos; install &apos; , &apos; --no-index &apos; , &apos; --find-links &apos; , data.find _ links , package ) DCNL DCSP result.assert _ installed ( &apos; source &apos; , editable = False )
DCSP secgroup = _ get _ secgroup ( cs , args.secgroup ) DCNL DCSP cs.security _ groups.delete ( secgroup ) DCNL DCSP _ print _ secgroups ( &#91; secgroup &#93; )
DCSP filepath = private _ storage.save ( filepath , attachment ) DCNL DCSP return filepath.split ( &apos; / &apos; ) &#91; ( -1 ) &#93;
DCSP env1x = { } DCNL DCSP url _ encoding = environ &#91; ntou ( &apos; wsgi.url _ encoding &apos; ) &#93; DCNL DCSP for ( k , v ) in list ( environ.items ( ) ) : DCNL DCSP DCSP if ( k in &#91; ntou ( &apos; PATH _ INFO &apos; ) , ntou ( &apos; SCRIPT _ NAME &apos; ) , ntou ( &apos; QUERY _ STRING &apos; ) &#93; ) : DCNL DCSP DCSP DCSP v = v.encode ( url _ encoding ) DCNL DCSP DCSP elif isinstance ( v , six.text _ type ) : DCNL DCSP DCSP DCSP v = v.encode ( &apos; ISO-8859-1 &apos; ) DCNL DCSP DCSP env1x &#91; k.encode ( &apos; ISO-8859-1 &apos; ) &#93; = v DCNL DCSP return env1x
DCSP try : DCNL DCSP DCSP if ( not ek ( os.path.exists , targetDir ) ) : DCNL DCSP DCSP DCSP ek ( os.mkdir , targetDir ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP def path _ leaf ( path ) : DCNL DCSP DCSP DCSP DCSP ( head , tail ) = ek ( os.path.split , path ) DCNL DCSP DCSP DCSP DCSP return ( tail or ek ( os.path.basename , head ) ) DCNL DCSP DCSP DCSP bakFilename = u &apos; { 0 } - { 1 } &apos; .format ( path _ leaf ( targetDir ) , datetime.datetime.now ( ) .strftime ( u &apos; % Y % m % d _ % H % M % S &apos; ) ) DCNL DCSP DCSP DCSP shutil.move ( targetDir , ek ( os.path.join , ek ( os.path.dirname , targetDir ) , bakFilename ) ) DCNL DCSP DCSP zip _ file = zipfile.ZipFile ( archive , u &apos;r &apos; , allowZip64 = True ) DCNL DCSP DCSP for member in zip _ file.namelist ( ) : DCNL DCSP DCSP DCSP zip _ file.extract ( member , targetDir ) DCNL DCSP DCSP zip _ file.close ( ) DCNL DCSP DCSP return True DCNL DCSP except Exception as error : DCNL DCSP DCSP logger.log ( u &apos;Zip DCSP extraction DCSP error : DCSP { 0 } &apos; .format ( error ) , logger.ERROR ) DCNL DCSP DCSP shutil.rmtree ( targetDir ) DCNL DCSP DCSP return False
