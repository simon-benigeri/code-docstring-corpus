DCSP if cint ( frappe.db.get _ single _ value ( u &apos;System DCSP Settings &apos; , u &apos;setup _ complete &apos; ) ) : DCNL DCSP DCSP return DCNL DCSP args = process _ args ( args ) DCNL DCSP try : DCNL DCSP DCSP if ( args.language and ( args.language ! = u &apos;english &apos; ) ) : DCNL DCSP DCSP DCSP set _ default _ language ( get _ language _ code ( args.lang ) ) DCNL DCSP DCSP frappe.clear _ cache ( ) DCNL DCSP DCSP update _ system _ settings ( args ) DCNL DCSP DCSP update _ user _ name ( args ) DCNL DCSP DCSP for method in frappe.get _ hooks ( u &apos;setup _ wizard _ complete &apos; ) : DCNL DCSP DCSP DCSP frappe.get _ attr ( method ) ( args ) DCNL DCSP DCSP disable _ future _ access ( ) DCNL DCSP DCSP frappe.db.commit ( ) DCNL DCSP DCSP frappe.clear _ cache ( ) DCNL DCSP except : DCNL DCSP DCSP frappe.db.rollback ( ) DCNL DCSP DCSP if args : DCNL DCSP DCSP DCSP traceback = frappe.get _ traceback ( ) DCNL DCSP DCSP DCSP for hook in frappe.get _ hooks ( u &apos;setup _ wizard _ exception &apos; ) : DCNL DCSP DCSP DCSP DCSP frappe.get _ attr ( hook ) ( traceback , args ) DCNL DCSP DCSP raise DCNL DCSP else : DCNL DCSP DCSP for hook in frappe.get _ hooks ( u &apos;setup _ wizard _ success &apos; ) : DCNL DCSP DCSP DCSP frappe.get _ attr ( hook ) ( args )
DCSP module = AnsibleModule ( argument _ spec = ClcGroup . _ define _ module _ argument _ spec ( ) , supports _ check _ mode = True ) DCNL DCSP clc _ group = ClcGroup ( module ) DCNL DCSP clc _ group.process _ request ( )
DCSP try : DCNL DCSP DCSP fields = os.path.split ( filename ) DCNL DCSP DCSP if fields : DCNL DCSP DCSP DCSP if ( fields &#91; ( -1 ) &#93; .startswith ( &apos; dataset _ &apos; ) and fields &#91; ( -1 ) &#93; .endswith ( &apos; .dat &apos; ) ) : DCNL DCSP DCSP DCSP DCSP return Dataset.get ( int ( fields &#91; ( -1 ) &#93; &#91; len ( &apos; dataset _ &apos; ) : ( - len ( &apos; .dat &apos; ) ) &#93; ) ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP return None
DCSP result = &#91; &#93; DCNL DCSP for node in maybe _ xrefs : DCNL DCSP DCSP if isinstance ( node , addnodes.pending _ xref ) : DCNL DCSP DCSP DCSP result.extend ( resolve _ pending _ xref ( app , fromdocname , node.deepcopy ( ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result.append ( node ) DCNL DCSP return result
DCSP ( is _ travis , non _ pr ) = check _ environment ( ) DCNL DCSP if ( not is _ travis ) : DCNL DCSP DCSP return DCNL DCSP if ( not non _ pr ) : DCNL DCSP DCSP print ( &apos; Running DCSP in DCSP Travis DCSP during DCSP non-merge DCSP to DCSP master , DCSP doing DCSP nothing . &apos; ) DCNL DCSP DCSP sys.exit ( 0 ) DCNL DCSP decrypt _ keyfile ( )
DCSP result = script.pip ( &apos; download &apos; , expect _ error = True ) DCNL DCSP assert ( &apos; You DCSP must DCSP give DCSP at DCSP least DCSP one DCSP requirement DCSP to DCSP download &apos; in result.stderr ) DCNL DCSP assert ( result.returncode = = ERROR )
DCSP with open ( &apos; .. / show _ version.txt &apos; ) as show _ ver _ file : DCNL DCSP DCSP show _ ver = show _ ver _ file.read ( ) DCNL DCSP print obtain _ os _ version ( show _ ver )
DCSP stdout.write ( msg.encode ( &apos; utf-8 &apos; ) )
DCSP api _ key = bot.config.get ( &apos; api _ keys &apos; , { } ) .get ( &apos; bing _ azure &apos; ) DCNL DCSP show _ nsfw = text.endswith ( &apos; DCSP nsfw &apos; ) DCNL DCSP if show _ nsfw : DCNL DCSP DCSP text = text &#91; : ( -5 ) &#93; .strip ( ) .lower ( ) DCNL DCSP rating = ( NSFW _ FILTER if show _ nsfw else DEFAULT _ FILTER ) DCNL DCSP if ( not api _ key ) : DCNL DCSP DCSP return &apos; Error : DCSP No DCSP Bing DCSP Azure DCSP API DCSP details . &apos; DCNL DCSP params = { &apos; Sources &apos; : bingify ( &apos; image &apos; ) , &apos; Query &apos; : bingify ( text ) , &apos; Adult &apos; : bingify ( rating ) , &apos; $ format &apos; : &apos; json &apos; } DCNL DCSP request = requests.get ( API _ URL , params = params , auth = ( api _ key , api _ key ) ) DCNL DCSP j = request.json ( ) &#91; &apos; d &apos; &#93; &#91; &apos; results &apos; &#93; &#91; 0 &#93; DCNL DCSP if ( not j &#91; &apos; Image &apos; &#93; ) : DCNL DCSP DCSP return &apos; No DCSP results . &apos; DCNL DCSP result = random.choice ( j &#91; &apos; Image &apos; &#93; &#91; : 10 &#93; ) DCNL DCSP tags = &#91; &#93; DCNL DCSP tags.append ( &apos; { } x { } px &apos; .format ( result &#91; &apos; Width &apos; &#93; , result &#91; &apos; Height &apos; &#93; ) ) DCNL DCSP tags.append ( result &#91; &apos; ContentType &apos; &#93; ) DCNL DCSP tags.append ( filesize.size ( int ( result &#91; &apos; FileSize &apos; &#93; ) , system = filesize.alternative ) ) DCNL DCSP if ( &apos; explicit &apos; in result &#91; &apos; Thumbnail &apos; &#93; &#91; &apos; MediaUrl &apos; &#93; ) : DCNL DCSP DCSP tags.append ( &apos; NSFW &apos; ) DCNL DCSP tag _ text = &apos; , DCSP &apos; .join ( tags ) DCNL DCSP return &apos; { } DCSP ( { } ) &apos; .format ( unescape ( result &#91; &apos; MediaUrl &apos; &#93; ) , tag _ text )
DCSP if ( not issubclass ( optionable _ type , Optionable ) ) : DCNL DCSP DCSP raise TypeError ( u &apos;The DCSP given DCSP `optionable _ type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Optionable` : DCSP { } &apos; .format ( optionable _ type ) ) DCNL DCSP option _ values = { } DCNL DCSP registration _ function = _ options _ registration _ function ( option _ values ) DCNL DCSP optionable _ type.register _ options ( registration _ function ) DCNL DCSP option _ values.update ( * * options ) DCNL DCSP return create _ option _ values ( option _ values )
DCSP q = ( ( 2 * endog ) - 1 ) DCNL DCSP X = exog DCNL DCSP return np.add.reduce ( stats.norm.logcdf ( ( q * np.dot ( X , params ) ) ) )
DCSP filename = get _ pkg _ data _ filename ( u &apos;data / sip2.fits &apos; ) DCNL DCSP with catch _ warnings ( wcs.wcs.FITSFixedWarning ) as caught _ warnings : DCNL DCSP DCSP ww = wcs.WCS ( filename ) DCNL DCSP DCSP assert ( len ( caught _ warnings ) = = 1 ) DCNL DCSP n = 3 DCNL DCSP pixels = ( np.arange ( n ) * np.ones ( ( 2 , n ) ) ) .T DCNL DCSP result = ww.wcs _ pix2world ( pixels , 0 , ra _ dec _ order = True ) DCNL DCSP ww.wcs _ pix2world ( pixels &#91; ... , 0 &#93; , pixels &#91; ... , 1 &#93; , 0 , ra _ dec _ order = True ) DCNL DCSP close _ enough = 1e-08 DCNL DCSP answer = np.array ( &#91; &#91; 0.00024976 , 0.00023018 &#93; , &#91; 0.00023043 , ( -0.00024997 ) &#93; &#93; ) DCNL DCSP assert np.all ( ( np.abs ( ( ww.wcs.pc - answer ) ) &lt; close _ enough ) ) DCNL DCSP answer = np.array ( &#91; &#91; 202.39265216 , 47.17756518 &#93; , &#91; 202.39335826 , 47.17754619 &#93; , &#91; 202.39406436 , 47.1775272 &#93; &#93; ) DCNL DCSP assert np.all ( ( np.abs ( ( result - answer ) ) &lt; close _ enough ) )
DCSP ( fig , ax ) = utils.create _ mpl _ ax ( ax ) DCNL DCSP infl = results.get _ influence ( ) DCNL DCSP if criterion.lower ( ) .startswith ( &apos; coo &apos; ) : DCNL DCSP DCSP psize = infl.cooks _ distance &#91; 0 &#93; DCNL DCSP elif criterion.lower ( ) .startswith ( &apos; dff &apos; ) : DCNL DCSP DCSP psize = np.abs ( infl.dffits &#91; 0 &#93; ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Criterion DCSP % s DCSP not DCSP understood &apos; % criterion ) ) DCNL DCSP old _ range = np.ptp ( psize ) DCNL DCSP new _ range = ( ( size * * 2 ) - ( 8 * * 2 ) ) DCNL DCSP psize = ( ( ( ( psize - psize.min ( ) ) * new _ range ) / old _ range ) + ( 8 * * 2 ) ) DCNL DCSP leverage = infl.hat _ matrix _ diag DCNL DCSP if external : DCNL DCSP DCSP resids = infl.resid _ studentized _ external DCNL DCSP else : DCNL DCSP DCSP resids = infl.resid _ studentized _ internal DCNL DCSP from scipy import stats DCNL DCSP cutoff = stats.t.ppf ( ( 1.0 - ( alpha / 2 ) ) , results.df _ resid ) DCNL DCSP large _ resid = ( np.abs ( resids ) &gt; cutoff ) DCNL DCSP large _ leverage = ( leverage &gt; _ high _ leverage ( results ) ) DCNL DCSP large _ points = np.logical _ or ( large _ resid , large _ leverage ) DCNL DCSP ax.scatter ( leverage , resids , s = psize , alpha = plot _ alpha ) DCNL DCSP labels = results.model.data.row _ labels DCNL DCSP if ( labels is None ) : DCNL DCSP DCSP labels = lrange ( len ( resids ) ) DCNL DCSP ax = utils.annotate _ axes ( np.where ( large _ points ) &#91; 0 &#93; , labels , lzip ( leverage , resids ) , lzip ( ( - ( ( psize / 2 ) * * 0.5 ) ) , ( ( psize / 2 ) * * 0.5 ) ) , &apos; x-large &apos; , ax ) DCNL DCSP font = { &apos; fontsize &apos; : 16 , &apos; color &apos; : &apos; black &apos; } DCNL DCSP ax.set _ ylabel ( &apos; Studentized DCSP Residuals &apos; , * * font ) DCNL DCSP ax.set _ xlabel ( &apos; H DCSP Leverage &apos; , * * font ) DCNL DCSP ax.set _ title ( &apos; Influence DCSP Plot &apos; , * * font ) DCNL DCSP return fig
DCSP nf = NetlogFile ( name ) DCNL DCSP nf.sock.sendall ( data ) DCNL DCSP nf.close ( )
DCSP root = get _ or _ create _ root ( ) DCNL DCSP return redirect ( &apos; wiki : get &apos; , path = root.path )
DCSP return IMPL.block _ device _ mapping _ update _ or _ create ( context , values )
DCSP flavors = novaclient ( request ) .flavors.list ( is _ public = is _ public ) DCNL DCSP if get _ extras : DCNL DCSP DCSP for flavor in flavors : DCNL DCSP DCSP DCSP flavor.extras = flavor _ get _ extras ( request , flavor.id , True , flavor ) DCNL DCSP return flavors
DCSP if ( u &apos;charset &apos; in format ) : DCNL DCSP DCSP return format DCNL DCSP if ( format in ( u &apos;application / json &apos; , u &apos;text / javascript &apos; ) ) : DCNL DCSP DCSP return format DCNL DCSP return ( u &apos; % s ; DCSP charset = % s &apos; % ( format , encoding ) )
DCSP random _ index = randint ( 0 , ( TopicCategory.objects.all ( ) .count ( ) - 1 ) ) DCNL DCSP tc = TopicCategory.objects.all ( ) &#91; random _ index &#93; DCNL DCSP resource.category = tc DCNL DCSP resource.save ( )
DCSP NOT _ PRESENT = object ( ) DCNL DCSP old _ values = { } DCNL DCSP for ( attr , new _ value ) in kwargs.items ( ) : DCNL DCSP DCSP old _ values &#91; attr &#93; = getattr ( obj , attr , NOT _ PRESENT ) DCNL DCSP DCSP setattr ( obj , attr , new _ value ) DCNL DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP for ( attr , old _ value ) in old _ values.items ( ) : DCNL DCSP DCSP DCSP if ( old _ value is NOT _ PRESENT ) : DCNL DCSP DCSP DCSP DCSP del obj &#91; attr &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP setattr ( obj , attr , old _ value )
DCSP modules = set ( &#91; &apos; textannotation &apos; , &apos; imageannotation &apos; , &apos; videoannotation &apos; &#93; ) DCNL DCSP return bool ( modules.intersection ( course.advanced _ modules ) )
DCSP for ( label , seq ) in parse _ fasta ( file _ lines ) : DCNL DCSP DCSP if ( id _ from _ fasta _ label _ line ( label ) in ids ) : DCNL DCSP DCSP DCSP ( yield ( label , seq ) )
DCSP inse = tf.reduce _ sum ( ( output * target ) ) DCNL DCSP l = tf.reduce _ sum ( ( output * output ) ) DCNL DCSP r = tf.reduce _ sum ( ( target * target ) ) DCNL DCSP dice = ( ( 2 * inse ) / ( l + r ) ) DCNL DCSP if ( epsilon = = 0 ) : DCNL DCSP DCSP return dice DCNL DCSP else : DCNL DCSP DCSP return tf.clip _ by _ value ( dice , 0 , ( 1.0 - epsilon ) )
DCSP if callable ( getattr ( self.connection.features , &apos; confirm &apos; , None ) ) : DCNL DCSP DCSP self.connection.features.confirm ( ) DCNL DCSP elif hasattr ( self , &apos; _ rollback _ works &apos; ) : DCNL DCSP DCSP can _ rollback = self . _ rollback _ works ( ) DCNL DCSP DCSP self.connection.settings _ dict &#91; &apos; SUPPORTS _ TRANSACTIONS &apos; &#93; = can _ rollback DCNL DCSP return self . _ get _ test _ db _ name ( )
DCSP missionlist = readmission ( aFileName ) DCNL DCSP print ( &apos; \ nUpload DCSP mission DCSP from DCSP a DCSP file : DCSP % s &apos; % import _ mission _ filename ) DCNL DCSP print &apos; DCSP Clear DCSP mission &apos; DCNL DCSP cmds = vehicle.commands DCNL DCSP cmds.clear ( ) DCNL DCSP for command in missionlist : DCNL DCSP DCSP cmds.add ( command ) DCNL DCSP print &apos; DCSP Upload DCSP mission &apos; DCNL DCSP vehicle.commands.upload ( )
DCSP if ( math _ expr.strip ( ) = = &apos; &apos; ) : DCNL DCSP DCSP return float ( &apos; nan &apos; ) DCNL DCSP math _ interpreter = ParseAugmenter ( math _ expr , case _ sensitive ) DCNL DCSP math _ interpreter.parse _ algebra ( ) DCNL DCSP ( all _ variables , all _ functions ) = add _ defaults ( variables , functions , case _ sensitive ) DCNL DCSP math _ interpreter.check _ variables ( all _ variables , all _ functions ) DCNL DCSP if case _ sensitive : DCNL DCSP DCSP casify = ( lambda x : x ) DCNL DCSP else : DCNL DCSP DCSP casify = ( lambda x : x.lower ( ) ) DCNL DCSP evaluate _ actions = { &apos; number &apos; : eval _ number , &apos; variable &apos; : ( lambda x : all _ variables &#91; casify ( x &#91; 0 &#93; ) &#93; ) , &apos; function &apos; : ( lambda x : all _ functions &#91; casify ( x &#91; 0 &#93; ) &#93; ( x &#91; 1 &#93; ) ) , &apos; atom &apos; : eval _ atom , &apos; power &apos; : eval _ power , &apos; parallel &apos; : eval _ parallel , &apos; product &apos; : eval _ product , &apos; sum &apos; : eval _ sum } DCNL DCSP return math _ interpreter.reduce _ tree ( evaluate _ actions )
DCSP if ( not data ) : DCNL DCSP DCSP raise ValueError ( &apos; No DCSP data DCSP available DCSP for DCSP pie DCSP chart . &apos; ) DCNL DCSP all _ fracs = &#91; &#93; DCNL DCSP all _ labels = &#91; &#93; DCNL DCSP colors = &#91; &#93; DCNL DCSP for ( color _ ix , ( c _ label , c _ frac ) ) in enumerate ( data ) : DCNL DCSP DCSP if ( c _ label = = others _ key ) : DCNL DCSP DCSP DCSP colors.append ( others _ color ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP colors.append ( data _ colors &#91; pref _ colors &#91; c _ label &#93; &#93; .toHex ( ) ) DCNL DCSP DCSP all _ fracs.append ( c _ frac ) DCNL DCSP DCSP if should _ capitalize : DCNL DCSP DCSP DCSP capital = ( &apos; % s DCSP ( % .2f % % ) &apos; % ( c _ label.capitalize ( ) , ( c _ frac * 100.0 ) ) ) DCNL DCSP DCSP DCSP all _ labels.append ( capital ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP all _ labels.append ( ( &apos; % s DCSP ( % .2f % % ) &apos; % ( c _ label , ( c _ frac * 100.0 ) ) ) ) DCNL DCSP rc ( &apos; font &apos; , size = &apos; 10 &apos; ) DCNL DCSP rc ( &apos; text &apos; , color = label _ color ) DCNL DCSP rc ( &apos; patch &apos; , linewidth = 0.1 ) DCNL DCSP rc ( &apos; axes &apos; , linewidth = 0.5 , edgecolor = label _ color ) DCNL DCSP rc ( &apos; text &apos; , usetex = False ) DCNL DCSP fig = figure ( randrange ( 10000 ) , figsize = ( plot _ width , plot _ height ) ) DCNL DCSP fp = FontProperties ( ) DCNL DCSP fp.set _ size ( &apos; 8&apos; ) DCNL DCSP if ( len ( data ) &gt; 30 ) : DCNL DCSP DCSP loc = 4 DCNL DCSP else : DCNL DCSP DCSP loc = 5 DCNL DCSP mtitle = &apos; Pie DCSP Chart &apos; DCNL DCSP if ( &apos; title &apos; in props ) : DCNL DCSP DCSP mtitle = props &#91; &apos; title &apos; &#93; DCNL DCSP axis ( &apos; off &apos; ) DCNL DCSP title ( mtitle , fontsize = &apos; 10 &apos; , color = label _ color ) DCNL DCSP ax = axes ( &#91; 0.0 , 0.0 , 0.5 , 1 &#93; ) DCNL DCSP p1 = pie ( all _ fracs , shadow = False , colors = colors ) DCNL DCSP if ( file _ prefix is None ) : DCNL DCSP DCSP img _ name = make _ img _ name ( file _ ext = &apos; .png &apos; ) DCNL DCSP else : DCNL DCSP DCSP img _ name = file _ prefix DCNL DCSP img _ abs = os.path.join ( dir _ path , &apos; charts &apos; , img _ name ) DCNL DCSP savefig ( img _ abs , dpi = dpi , facecolor = background _ color ) DCNL DCSP eps _ link = &apos; &apos; DCNL DCSP eps _ abs = &apos; &apos; DCNL DCSP if ( file _ prefix is None ) : DCNL DCSP DCSP eps _ img _ name = make _ img _ name ( file _ ext = ( &apos; . % s &apos; % generate _ image _ type ) ) DCNL DCSP else : DCNL DCSP DCSP eps _ img _ name = ( file _ prefix + ( &apos; . % s &apos; % generate _ image _ type ) ) DCNL DCSP savefig ( os.path.join ( dir _ path , &apos; charts &apos; , eps _ img _ name ) , facecolor = background _ color ) DCNL DCSP if ( generate _ image _ type = = &apos; eps &apos; ) : DCNL DCSP DCSP strip _ eps _ font ( os.path.join ( dir _ path , &apos; charts &apos; , eps _ img _ name ) ) DCNL DCSP eps _ abs = os.path.join ( dir _ path , &apos; charts &apos; , eps _ img _ name ) DCNL DCSP eps _ link = ( PDF _ LINK % ( os.path.join ( &apos; charts &apos; , eps _ img _ name ) , ( &apos; View DCSP Figure DCSP ( . % s ) &apos; % generate _ image _ type ) ) ) DCNL DCSP close ( fig ) DCNL DCSP clf ( ) DCNL DCSP updated _ taxa = &#91; &#93; DCNL DCSP updated _ colors = &#91; &#93; DCNL DCSP for i in data : DCNL DCSP DCSP if ( i &#91; 0 &#93; ! = others _ key ) : DCNL DCSP DCSP DCSP updated _ taxa.append ( i &#91; 0 &#93; .replace ( &apos; &quot; &apos; , &apos; &apos; ) ) DCNL DCSP DCSP DCSP updated _ colors.append ( data _ colors &#91; pref _ colors &#91; i &#91; 0 &#93; &#93; &#93; .toHex ( ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP updated _ taxa.append ( others _ key ) DCNL DCSP DCSP DCSP updated _ colors.append ( others _ color ) DCNL DCSP if include _ html _ legend : DCNL DCSP DCSP legend _ fname _ png = make _ legend ( updated _ taxa , updated _ colors , plot _ width , plot _ height , label _ color , background _ color , img _ abs , &apos; png &apos; , 80 ) DCNL DCSP DCSP legend _ fpath _ png = os.path.join ( &apos; charts &apos; , legend _ fname _ png ) DCNL DCSP legend _ fname = make _ legend ( updated _ taxa , updated _ colors , plot _ width , plot _ height , label _ color , background _ color , img _ abs , generate _ image _ type , dpi ) DCNL DCSP legend _ fpath = os.path.join ( &apos; charts &apos; , legend _ fname ) DCNL DCSP legend _ link = ( LEGEND _ LINK % ( legend _ fpath , ( &apos; View DCSP Legend DCSP ( . % s ) &apos; % generate _ image _ type ) ) ) DCNL DCSP points _ id = &apos; &apos; DCNL DCSP xmap _ html = &apos; &apos; DCNL DCSP if ( not include _ html _ legend ) : DCNL DCSP DCSP IMG _ TEXT = ( IMG _ SRC _ minus _ legend % ( os.path.join ( &apos; charts &apos; , img _ name ) , points _ id ) ) DCNL DCSP else : DCNL DCSP DCSP IMG _ TEXT = ( IMG _ SRC _ 2 % ( os.path.join ( &apos; charts &apos; , img _ name ) , points _ id , legend _ fpath _ png ) ) DCNL DCSP return ( eps _ link , legend _ link , IMG _ TEXT , xmap _ html )
DCSP try : DCNL DCSP DCSP return ismount _ raw ( path ) DCNL DCSP except OSError : DCNL DCSP DCSP return False
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ vlm _ get _ media _ instance _ title &apos; , None ) or _ Cfunction ( &apos; libvlc _ vlm _ get _ media _ instance _ title &apos; , ( ( 1 , ) , ( 1 , ) , ( 1 , ) ) , None , ctypes.c _ int , Instance , ctypes.c _ char _ p , ctypes.c _ int ) ) DCNL DCSP return f ( p _ instance , psz _ name , i _ instance )
DCSP if ( len ( s ) &lt; 1 ) : DCNL DCSP DCSP return Raw ( s ) DCNL DCSP ietype = ord ( s &#91; 0 &#93; ) DCNL DCSP cls = ietypecls.get ( ietype , Raw ) DCNL DCSP if ( ( cls = = Raw ) and ( ( ietype &amp; 128 ) = = 128 ) ) : DCNL DCSP DCSP cls = IE _ NotImplementedTLV DCNL DCSP return cls ( s )
DCSP results = &#91; &#93; DCNL DCSP for path in combine _ lists ( * path _ seqs ) : DCNL DCSP DCSP expanded = expand _ path ( path ) DCNL DCSP DCSP paths = ( sorted ( glob.glob ( expanded ) ) or &#91; expanded &#93; ) DCNL DCSP DCSP results.extend ( paths ) DCNL DCSP return results
DCSP atoi = ( lambda addr : struct.unpack ( &apos; ! I &apos; , socket.inet _ aton ( addr ) ) &#91; 0 &#93; ) DCNL DCSP itoa = ( lambda addr : socket.inet _ ntoa ( struct.pack ( &apos; ! I &apos; , addr ) ) ) DCNL DCSP ( address , netmask ) = network.split ( &apos; / &apos; ) DCNL DCSP netmask _ i = ( ( 4294967295 &lt; &lt; ( 32 - atoi ( netmask ) ) ) &amp; 4294967295 ) DCNL DCSP return itoa ( ( ( atoi ( address ) &amp; netmask _ i ) + 1 ) )
DCSP assert ( name in &#91; &apos; harry &apos; , &apos; terry &apos; , &apos; ule &apos; &#93; ) DCNL DCSP common = os.path.join ( preprocess ( &apos; $ { PYLEARN2 _ DATA _ PATH } &apos; ) , &apos; UTLC &apos; , &apos; sparse &apos; , ( name + &apos; _ &apos; ) ) DCNL DCSP ( trname , vname , tename ) = &#91; ( ( common + subset ) + &apos; .npy &apos; ) for subset in &#91; &apos; train &apos; , &apos; valid &apos; , &apos; test &apos; &#93; &#93; DCNL DCSP train = load _ sparse ( trname ) DCNL DCSP valid = load _ sparse ( vname ) DCNL DCSP test = load _ sparse ( tename ) DCNL DCSP if randomize _ valid : DCNL DCSP DCSP rng = make _ np _ rng ( None , &#91; 1 , 2 , 3 , 4 &#93; , which _ method = &apos; permutation &apos; ) DCNL DCSP DCSP perm = rng.permutation ( valid.shape &#91; 0 &#93; ) DCNL DCSP DCSP valid = valid &#91; perm &#93; DCNL DCSP if randomize _ test : DCNL DCSP DCSP rng = make _ np _ rng ( None , &#91; 1 , 2 , 3 , 4 &#93; , which _ method = &apos; permutation &apos; ) DCNL DCSP DCSP perm = rng.permutation ( test.shape &#91; 0 &#93; ) DCNL DCSP DCSP test = test &#91; perm &#93; DCNL DCSP if normalize : DCNL DCSP DCSP if ( name = = &apos; ule &apos; ) : DCNL DCSP DCSP DCSP train = ( train.astype ( theano.config.floatX ) / 255 ) DCNL DCSP DCSP DCSP valid = ( valid.astype ( theano.config.floatX ) / 255 ) DCNL DCSP DCSP DCSP test = ( test.astype ( theano.config.floatX ) / 255 ) DCNL DCSP DCSP elif ( name = = &apos; harry &apos; ) : DCNL DCSP DCSP DCSP train = train.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP valid = valid.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP test = test.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP std = 0.6933604603392579 DCNL DCSP DCSP DCSP train = ( train / std ) DCNL DCSP DCSP DCSP valid = ( valid / std ) DCNL DCSP DCSP DCSP test = ( test / std ) DCNL DCSP DCSP elif ( name = = &apos; terry &apos; ) : DCNL DCSP DCSP DCSP train = train.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP valid = valid.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP test = test.astype ( theano.config.floatX ) DCNL DCSP DCSP DCSP train = ( train / 300 ) DCNL DCSP DCSP DCSP valid = ( valid / 300 ) DCNL DCSP DCSP DCSP test = ( test / 300 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise Exception ( &quot; This DCSP dataset DCSP don &apos;t DCSP have DCSP its DCSP normalization DCSP defined &quot; ) DCNL DCSP if transfer : DCNL DCSP DCSP fname = os.path.join ( preprocess ( &apos; $ { PYLEARN2 _ DATA _ PATH } &apos; ) , &apos; UTLC &apos; , &apos; filetensor &apos; , ( name + &apos; _ transfer.ft &apos; ) ) DCNL DCSP DCSP transfer = load _ filetensor ( fname ) DCNL DCSP DCSP return ( train , valid , test , transfer ) DCNL DCSP else : DCNL DCSP DCSP return ( train , valid , test )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ video _ get _ spu _ description &apos; , None ) or _ Cfunction ( &apos; libvlc _ video _ get _ spu _ description &apos; , ( ( 1 , ) , ) , None , ctypes.POINTER ( TrackDescription ) , MediaPlayer ) ) DCNL DCSP return f ( p _ mi )
DCSP arr = np.asarray ( data , dtype = np.float32 ) DCNL DCSP out = cuda.device _ array ( 1 , dtype = np.float32 ) DCNL DCSP gpu _ single _ block _ sum &#91; ( 1 , gpu _ block _ sum _ max _ blockdim ) &#93; ( arr , out ) DCNL DCSP return out.copy _ to _ host ( ) &#91; 0 &#93;
DCSP assert hug.validate.contains _ one _ of ( &apos; no &apos; , &apos; way &apos; ) ( TEST _ SCHEMA ) DCNL DCSP assert ( not hug.validate.contains _ one _ of ( &apos; last &apos; , &apos; place &apos; ) ( TEST _ SCHEMA ) )
DCSP if ( len ( nestedRings ) &gt; 0 ) : DCNL DCSP DCSP oldOrderedLocation.z = nestedRings &#91; 0 &#93; .z DCNL DCSP closestDistance = 9.876543219876543e + 17 DCNL DCSP closestNestedRing = None DCNL DCSP for remainingNestedRing in nestedRings : DCNL DCSP DCSP distance = getClosestDistanceIndexToLine ( oldOrderedLocation.dropAxis ( ) , remainingNestedRing.boundary ) .distance DCNL DCSP DCSP if ( distance &lt; closestDistance ) : DCNL DCSP DCSP DCSP closestDistance = distance DCNL DCSP DCSP DCSP closestNestedRing = remainingNestedRing DCNL DCSP nestedRings.remove ( closestNestedRing ) DCNL DCSP closestNestedRing.addToThreads ( extrusionHalfWidth , oldOrderedLocation , skein , threadSequence ) DCNL DCSP return closestNestedRing
DCSP requires = IS _ ONE _ OF ( current.db , &apos; org _ organisation.id &apos; , org _ OrganisationRepresent ( ) , realms = realms , updateable = updateable , orderby = &apos; org _ organisation.name &apos; , sort = True ) DCNL DCSP if ( not required ) : DCNL DCSP DCSP requires = IS _ EMPTY _ OR ( requires ) DCNL DCSP return requires
DCSP return &apos; emoncms { } _ { } _ { } _ { } _ { } &apos; .format ( sensorid , feedtag , feedname , feedid , feeduserid )
DCSP return _ _ execute _ cmd ( &apos; setniccfg DCSP -s DCSP { 0 } DCSP { 1 } DCSP { 2 } &apos; .format ( ip , netmask , gateway ) )
DCSP with smart _ open ( fname , &apos; wb &apos; ) as fout : DCNL DCSP DCSP _ pickle.dump ( obj , fout , protocol = protocol )
DCSP return ( None , changed _ file )
DCSP entries1 = _ tree _ entries ( path , tree1 ) DCNL DCSP entries2 = _ tree _ entries ( path , tree2 ) DCNL DCSP i1 = i2 = 0 DCNL DCSP len1 = len ( entries1 ) DCNL DCSP len2 = len ( entries2 ) DCNL DCSP result = &#91; &#93; DCNL DCSP while ( ( i1 &lt; len1 ) and ( i2 &lt; len2 ) ) : DCNL DCSP DCSP entry1 = entries1 &#91; i1 &#93; DCNL DCSP DCSP entry2 = entries2 &#91; i2 &#93; DCNL DCSP DCSP if ( entry1.path &lt; entry2.path ) : DCNL DCSP DCSP DCSP result.append ( ( entry1 , _ NULL _ ENTRY ) ) DCNL DCSP DCSP DCSP i1 + = 1 DCNL DCSP DCSP elif ( entry1.path &gt; entry2.path ) : DCNL DCSP DCSP DCSP result.append ( ( _ NULL _ ENTRY , entry2 ) ) DCNL DCSP DCSP DCSP i2 + = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result.append ( ( entry1 , entry2 ) ) DCNL DCSP DCSP DCSP i1 + = 1 DCNL DCSP DCSP DCSP i2 + = 1 DCNL DCSP for i in range ( i1 , len1 ) : DCNL DCSP DCSP result.append ( ( entries1 &#91; i &#93; , _ NULL _ ENTRY ) ) DCNL DCSP for i in range ( i2 , len2 ) : DCNL DCSP DCSP result.append ( ( _ NULL _ ENTRY , entries2 &#91; i &#93; ) ) DCNL DCSP return result
DCSP req _ vars = form.request _ vars DCNL DCSP position = req _ vars.get ( &apos; position &apos; , &apos; &apos; ) DCNL DCSP reason = req _ vars.get ( &apos; reason &apos; , &apos; &apos; ) DCNL DCSP db = current.db DCNL DCSP table = db.auth _ user DCNL DCSP db ( ( table.id = = form.vars.id ) ) .update ( comments = ( &apos; % s DCSP &#124; DCSP % s &apos; % ( position , reason ) ) )
DCSP if ( not a ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP else : DCNL DCSP DCSP return &#91; ( ( a * b ) % p ) for b in f &#93;
DCSP review _ request _ id _ to _ commits _ map = defaultdict ( list ) DCNL DCSP branch _ name = payload.get ( u &apos;repository _ path &apos; ) DCNL DCSP if ( not branch _ name ) : DCNL DCSP DCSP return review _ request _ id _ to _ commits _ map DCNL DCSP revisions = payload.get ( u &apos;revisions &apos; , &#91; &#93; ) DCNL DCSP for revision in revisions : DCNL DCSP DCSP revision _ id = revision.get ( u &apos;revision &apos; ) DCNL DCSP DCSP if ( len ( revision _ id ) &gt; 7 ) : DCNL DCSP DCSP DCSP revision _ id = revision _ id &#91; : 7 &#93; DCNL DCSP DCSP commit _ message = revision.get ( u &apos;message &apos; ) DCNL DCSP DCSP review _ request _ id = get _ review _ request _ id ( commit _ message , server _ url ) DCNL DCSP DCSP review _ request _ id _ to _ commits _ map &#91; review _ request _ id &#93; .append ( ( u &apos; % s DCSP ( % s ) &apos; % ( branch _ name , revision _ id ) ) ) DCNL DCSP return review _ request _ id _ to _ commits _ map
DCSP try : DCNL DCSP DCSP codecs.lookup ( argument ) DCNL DCSP except LookupError : DCNL DCSP DCSP raise ValueError ( ( &apos; unknown DCSP encoding : DCSP &quot; % s &quot; &apos; % argument ) ) DCNL DCSP return argument
DCSP for ( k , v ) in opts.items ( ) : DCNL DCSP DCSP setConfigOption ( k , v )
DCSP subKeys = itemName.split ( &apos; : &apos; ) DCNL DCSP subResults = results DCNL DCSP for subKey in subKeys : DCNL DCSP DCSP subResults = subResults &#91; subKey &#93; DCNL DCSP return subResults
DCSP inner _ text = &#91; &#93; DCNL DCSP for child in node.childNodes : DCNL DCSP DCSP if ( ( child.nodeType = = child.TEXT _ NODE ) or ( child.nodeType = = child.CDATA _ SECTION _ NODE ) ) : DCNL DCSP DCSP DCSP inner _ text.append ( child.data ) DCNL DCSP DCSP elif ( child.nodeType = = child.ELEMENT _ NODE ) : DCNL DCSP DCSP DCSP inner _ text.extend ( getInnerText ( child ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP pass DCNL DCSP return &apos; &apos;.join ( inner _ text )
DCSP if ( not name ) : DCNL DCSP DCSP return namespace ( namespace _ ) DCNL DCSP name = canonicalize _ name ( name ) DCNL DCSP if ( name &#91; 0 &#93; = = SEP ) : DCNL DCSP DCSP resolved _ name = name DCNL DCSP elif is _ private ( name ) : DCNL DCSP DCSP resolved _ name = canonicalize _ name ( ( ( namespace _ + SEP ) + name &#91; 1 : &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP resolved _ name = ( namespace ( namespace _ ) + name ) DCNL DCSP if ( remappings and ( resolved _ name in remappings ) ) : DCNL DCSP DCSP return remappings &#91; resolved _ name &#93; DCNL DCSP else : DCNL DCSP DCSP return resolved _ name
DCSP qt _ start = u &apos; &lt; ! -- : &apos; DCNL DCSP qt _ end = u &apos; -- &gt; &apos; DCNL DCSP qt _ end _ with _ lang _ len = 5 DCNL DCSP qt _ chunks = text.split ( qt _ start ) DCNL DCSP content _ by _ lang = { } DCNL DCSP common _ txt _ list = &#91; &#93; DCNL DCSP for c in qt _ chunks : DCNL DCSP DCSP if ( not c.strip ( ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if c.startswith ( qt _ end ) : DCNL DCSP DCSP DCSP lang = u &apos; &apos; DCNL DCSP DCSP DCSP c = c.lstrip ( qt _ end ) DCNL DCSP DCSP DCSP if ( not c ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP elif c &#91; 2 : &#93; .startswith ( qt _ end ) : DCNL DCSP DCSP DCSP lang = c &#91; : 2 &#93; DCNL DCSP DCSP DCSP c = c &#91; qt _ end _ with _ lang _ len : &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP lang = u &apos; &apos; DCNL DCSP DCSP if ( not lang ) : DCNL DCSP DCSP DCSP common _ txt _ list.append ( c ) DCNL DCSP DCSP DCSP for l in content _ by _ lang.keys ( ) : DCNL DCSP DCSP DCSP DCSP content _ by _ lang &#91; l &#93; .append ( c ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP content _ by _ lang &#91; lang &#93; = ( content _ by _ lang.get ( lang , common _ txt _ list ) + &#91; c &#93; ) DCNL DCSP if ( common _ txt _ list and ( not content _ by _ lang ) ) : DCNL DCSP DCSP content _ by _ lang &#91; u &apos; &apos; &#93; = common _ txt _ list DCNL DCSP for l in content _ by _ lang.keys ( ) : DCNL DCSP DCSP content _ by _ lang &#91; l &#93; = u &apos; DCSP &apos; .join ( content _ by _ lang &#91; l &#93; ) DCNL DCSP return content _ by _ lang
DCSP def getter ( value ) : DCNL DCSP DCSP if ET.iselement ( value ) : DCNL DCSP DCSP DCSP value = value.attrib DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if _ is _ re _ match ( value ) : DCNL DCSP DCSP DCSP DCSP return value.group ( item ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return value &#91; item &#93; DCNL DCSP DCSP except ( KeyError , IndexError ) : DCNL DCSP DCSP DCSP return default DCNL DCSP DCSP except ( TypeError , AttributeError ) as err : DCNL DCSP DCSP DCSP raise ValueError ( err ) DCNL DCSP return transform ( getter )
DCSP txt = txt.replace ( &apos; \ r \ n &apos; , &apos; \ n &apos; ) DCNL DCSP txt = txt.replace ( &apos; \ r &apos; , &apos; \ n &apos; ) DCNL DCSP txt _ line _ count = len ( re.findall ( &apos; ( ? mu ) ^ \ \ s * . + $ &apos; , txt ) ) DCNL DCSP docanalysis = DocAnalysis ( &apos; txt &apos; , txt ) DCNL DCSP hardbreaks = docanalysis.line _ histogram ( 0.55 ) DCNL DCSP if hardbreaks : DCNL DCSP DCSP tab _ line _ count = len ( re.findall ( &apos; ( ? mu ) ^ ( DCTB &#124; \ \ s { 2 , } ) . + $ &apos; , txt ) ) DCNL DCSP DCSP print _ percent = ( tab _ line _ count / float ( txt _ line _ count ) ) DCNL DCSP DCSP empty _ line _ count = len ( re.findall ( &apos; ( ? mu ) ^ \ \ s * $ &apos; , txt ) ) DCNL DCSP DCSP block _ percent = ( empty _ line _ count / float ( txt _ line _ count ) ) DCNL DCSP DCSP if ( print _ percent &gt; = block _ percent ) : DCNL DCSP DCSP DCSP if ( 0.15 &lt; = print _ percent &lt; = 0.75 ) : DCNL DCSP DCSP DCSP DCSP return &apos; print &apos; DCNL DCSP DCSP elif ( 0.15 &lt; = block _ percent &lt; = 0.75 ) : DCNL DCSP DCSP DCSP return &apos; block &apos; DCNL DCSP DCSP return &apos; unformatted &apos; DCNL DCSP return &apos; single&apos;
DCSP idcount = 0 DCNL DCSP if ( extension and ( not extension.startswith ( &apos; .&apos; ) ) ) : DCNL DCSP DCSP extension = ( &apos; . % s &apos; % extension ) DCNL DCSP fname = ( base _ name + extension ) DCNL DCSP while os.path.exists ( fname ) : DCNL DCSP DCSP fname = ( &apos; % s- % d % s &apos; % ( base _ name , idcount , extension ) ) DCNL DCSP DCSP idcount + = 1 DCNL DCSP return fname
DCSP so _ far = set ( ) DCNL DCSP def no _ dups ( x ) : DCNL DCSP DCSP k = key ( x ) DCNL DCSP DCSP if ( k in so _ far ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP so _ far.add ( k ) DCNL DCSP DCSP DCSP return True DCNL DCSP return IteratorFilter ( iterator , no _ dups )
DCSP if ( not is _ list _ like ( n ) ) : DCNL DCSP DCSP n = np.array ( ( &#91; n &#93; * len ( m ) ) ) DCNL DCSP elif ( isinstance ( n , np.ndarray ) and ( n.ndim = = 0 ) ) : DCNL DCSP DCSP n = np.repeat ( np.array ( n , ndmin = 1 ) , len ( m ) ) DCNL DCSP try : DCNL DCSP DCSP nn = n &#91; m &#93; DCNL DCSP DCSP if ( not _ is _ na _ compat ( v , nn &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP raise ValueError DCNL DCSP DCSP nn _ at = nn.astype ( v.dtype ) DCNL DCSP DCSP if ( not is _ numeric _ v _ string _ like ( nn , nn _ at ) ) : DCNL DCSP DCSP DCSP comp = ( nn = = nn _ at ) DCNL DCSP DCSP DCSP if ( is _ list _ like ( comp ) and comp.all ( ) ) : DCNL DCSP DCSP DCSP DCSP nv = v.copy ( ) DCNL DCSP DCSP DCSP DCSP nv &#91; m &#93; = nn _ at DCNL DCSP DCSP DCSP DCSP return nv DCNL DCSP except ( ValueError , IndexError , TypeError ) : DCNL DCSP DCSP pass DCNL DCSP ( dtype , _ ) = _ maybe _ promote ( n.dtype ) DCNL DCSP if ( is _ extension _ type ( v.dtype ) and is _ object _ dtype ( dtype ) ) : DCNL DCSP DCSP nv = v.get _ values ( dtype ) DCNL DCSP else : DCNL DCSP DCSP nv = v.astype ( dtype ) DCNL DCSP try : DCNL DCSP DCSP nv &#91; m &#93; = n &#91; m &#93; DCNL DCSP except ValueError : DCNL DCSP DCSP ( idx , ) = np.where ( np.squeeze ( m ) ) DCNL DCSP DCSP for ( mask _ index , new _ val ) in zip ( idx , n &#91; m &#93; ) : DCNL DCSP DCSP DCSP nv &#91; mask _ index &#93; = new _ val DCNL DCSP return nv
DCSP filter _ func = ( filter _ func or ( lambda _ _ : True ) ) DCNL DCSP stack = deque ( &#91; start _ node &#93; ) DCNL DCSP yield _ results = { } DCNL DCSP while stack : DCNL DCSP DCSP current _ node = stack.pop ( ) DCNL DCSP DCSP if ( get _ parents and ( current _ node ! = start _ node ) ) : DCNL DCSP DCSP DCSP parents = get _ parents ( current _ node ) DCNL DCSP DCSP DCSP if ( not all ( ( ( parent in yield _ results ) for parent in parents ) ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( ( not yield _ descendants _ of _ unyielded ) and ( not any ( ( yield _ results &#91; parent &#93; for parent in parents ) ) ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP if ( current _ node not in yield _ results ) : DCNL DCSP DCSP DCSP if get _ parents : DCNL DCSP DCSP DCSP DCSP unvisited _ children = list ( get _ children ( current _ node ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP unvisited _ children = list ( ( child for child in get _ children ( current _ node ) if ( child not in yield _ results ) ) ) DCNL DCSP DCSP DCSP unvisited _ children.reverse ( ) DCNL DCSP DCSP DCSP stack.extend ( unvisited _ children ) DCNL DCSP DCSP DCSP should _ yield _ node = filter _ func ( current _ node ) DCNL DCSP DCSP DCSP if should _ yield _ node : DCNL DCSP DCSP DCSP DCSP ( yield current _ node ) DCNL DCSP DCSP DCSP yield _ results &#91; current _ node &#93; = should _ yield _ node
DCSP end = evaluate.getVector3FromElementNode ( elementNode ) DCNL DCSP previousElementNode = elementNode.getPreviousElementNode ( ) DCNL DCSP if ( previousElementNode = = None ) : DCNL DCSP DCSP print &apos; Warning , DCSP can DCSP not DCSP get DCSP previousElementNode DCSP in DCSP getQuadraticPath DCSP in DCSP quadratic DCSP for : &apos; DCNL DCSP DCSP print elementNode DCNL DCSP DCSP return &#91; end &#93; DCNL DCSP begin = elementNode.getPreviousVertex ( Vector3 ( ) ) DCNL DCSP controlPoint = evaluate.getVector3ByPrefix ( None , elementNode , &apos; controlPoint &apos; ) DCNL DCSP if ( controlPoint = = None ) : DCNL DCSP DCSP oldControlPoint = evaluate.getVector3ByPrefixes ( previousElementNode , &#91; &apos; controlPoint &apos; , &apos; controlPoint1 &apos; &#93; , None ) DCNL DCSP DCSP if ( oldControlPoint = = None ) : DCNL DCSP DCSP DCSP oldControlPoint = end DCNL DCSP DCSP controlPoint = ( ( begin + begin ) - oldControlPoint ) DCNL DCSP DCSP evaluate.addVector3ToElementNode ( elementNode , &apos; controlPoint &apos; , controlPoint ) DCNL DCSP return svg _ reader.getQuadraticPoints ( begin , controlPoint , end , lineation.getNumberOfBezierPoints ( begin , elementNode , end ) )
DCSP if ( isinstance ( node.op , tensor.Elemwise ) and isinstance ( node.op.scalar _ op , scalar.basic.Log ) and ( len ( node.inputs ) = = 1 ) and ( node.inputs &#91; 0 &#93; .owner is not None ) and isinstance ( node.inputs &#91; 0 &#93; .owner.op , Softmax ) ) : DCNL DCSP DCSP inVars = node.inputs &#91; 0 &#93; .owner.inputs &#91; 0 &#93; DCNL DCSP DCSP new _ op = LogSoftmax ( ) DCNL DCSP DCSP ret = new _ op ( inVars ) DCNL DCSP DCSP ret.tag.values _ eq _ approx = values _ eq _ approx _ remove _ inf DCNL DCSP DCSP copy _ stack _ trace ( &#91; node.inputs &#91; 0 &#93; , node.outputs &#91; 0 &#93; &#93; , ret ) DCNL DCSP DCSP return &#91; ret &#93;
DCSP freqs = numpy.array ( &#91; ( ( ( f + 1 ) * fs ) / ( 2 * nfft ) ) for f in range ( nfft ) &#93; ) DCNL DCSP Cp = 27.5 DCNL DCSP nChroma = numpy.round ( ( 12.0 * numpy.log2 ( ( freqs / Cp ) ) ) ) .astype ( int ) DCNL DCSP nFreqsPerChroma = numpy.zeros ( ( nChroma.shape &#91; 0 &#93; , ) ) DCNL DCSP uChroma = numpy.unique ( nChroma ) DCNL DCSP for u in uChroma : DCNL DCSP DCSP idx = numpy.nonzero ( ( nChroma = = u ) ) DCNL DCSP DCSP nFreqsPerChroma &#91; idx &#93; = idx &#91; 0 &#93; .shape DCNL DCSP return ( nChroma , nFreqsPerChroma )
DCSP def _ set _ nxm _ headers _ dec ( self ) : DCNL DCSP DCSP self.nxm _ headers = nxm _ headers DCNL DCSP DCSP return self DCNL DCSP return _ set _ nxm _ headers _ dec
DCSP return get _ i18n ( ) .gettext ( string , * * variables )
DCSP diff = ( X - x _ old ) DCNL DCSP diff _ norm = np.sqrt ( np.sum ( ( diff * * 2 ) , axis = 1 ) ) DCNL DCSP mask = ( diff _ norm &gt; = _ EPSILON ) DCNL DCSP is _ x _ old _ in _ X = int ( ( mask.sum ( ) &lt; X.shape &#91; 0 &#93; ) ) DCNL DCSP diff = diff &#91; mask &#93; DCNL DCSP diff _ norm = diff _ norm &#91; mask &#93; &#91; : , np.newaxis &#93; DCNL DCSP quotient _ norm = linalg.norm ( np.sum ( ( diff / diff _ norm ) , axis = 0 ) ) DCNL DCSP if ( quotient _ norm &gt; _ EPSILON ) : DCNL DCSP DCSP new _ direction = ( np.sum ( ( X &#91; mask , : &#93; / diff _ norm ) , axis = 0 ) / np.sum ( ( 1 / diff _ norm ) , axis = 0 ) ) DCNL DCSP else : DCNL DCSP DCSP new _ direction = 1.0 DCNL DCSP DCSP quotient _ norm = 1.0 DCNL DCSP return ( ( max ( 0.0 , ( 1.0 - ( is _ x _ old _ in _ X / quotient _ norm ) ) ) * new _ direction ) + ( min ( 1.0 , ( is _ x _ old _ in _ X / quotient _ norm ) ) * x _ old ) )
DCSP if ( not hasattr ( req , &apos; best _ match _ language &apos; ) ) : DCNL DCSP DCSP return e DCNL DCSP locale = req.best _ match _ language ( ) DCNL DCSP if isinstance ( e , webob.exc.HTTPError ) : DCNL DCSP DCSP e.explanation = i18n.translate ( e.explanation , locale ) DCNL DCSP DCSP e.detail = i18n.translate ( e.detail , locale ) DCNL DCSP DCSP if getattr ( e , &apos; body _ template &apos; , None ) : DCNL DCSP DCSP DCSP e.body _ template = i18n.translate ( e.body _ template , locale ) DCNL DCSP return e
DCSP return uuid.uuid4 ( ) .hex
DCSP return time.time ( )
DCSP would _ be _ changed = &#91; &#93; DCNL DCSP for package in packages : DCNL DCSP DCSP ( installed , updated ) = query _ package ( module , xbps _ path , package ) DCNL DCSP DCSP if ( ( ( state in &#91; &apos; present &apos; , &apos; latest &apos; &#93; ) and ( not installed ) ) or ( ( state = = &apos; absent &apos; ) and installed ) or ( ( state = = &apos; latest &apos; ) and ( not updated ) ) ) : DCNL DCSP DCSP DCSP would _ be _ changed.append ( package ) DCNL DCSP if would _ be _ changed : DCNL DCSP DCSP if ( state = = &apos; absent &apos; ) : DCNL DCSP DCSP DCSP state = &apos; removed &apos; DCNL DCSP DCSP module.exit _ json ( changed = True , msg = ( &apos; % s DCSP package ( s ) DCSP would DCSP be DCSP % s &apos; % ( len ( would _ be _ changed ) , state ) ) , packages = would _ be _ changed ) DCNL DCSP else : DCNL DCSP DCSP module.exit _ json ( changed = False , msg = ( &apos; package ( s ) DCSP already DCSP % s &apos; % state ) , packages = &#91; &#93; )
DCSP for d in frappe.get _ all ( u &apos;Daily DCSP Work DCSP Summary &apos; , dict ( status = u &apos;Open &apos; ) ) : DCNL DCSP DCSP daily _ work _ summary = frappe.get _ doc ( u &apos;Daily DCSP Work DCSP Summary &apos; , d.name ) DCNL DCSP DCSP daily _ work _ summary.send _ summary ( )
DCSP if ( provider in drivers ) : DCNL DCSP DCSP raise AttributeError ( ( &apos; Provider DCSP % s DCSP already DCSP registered &apos; % provider ) ) DCNL DCSP drivers &#91; provider &#93; = ( module , klass ) DCNL DCSP try : DCNL DCSP DCSP driver = get _ driver ( drivers , provider ) DCNL DCSP except ( ImportError , AttributeError ) : DCNL DCSP DCSP exp = sys.exc _ info ( ) &#91; 1 &#93; DCNL DCSP DCSP drivers.pop ( provider ) DCNL DCSP DCSP raise exp DCNL DCSP return driver
DCSP return str ( tablename )
DCSP splitLine = line.split ( ) DCNL DCSP return Vector3 ( float ( splitLine &#91; 1 &#93; ) , float ( splitLine &#91; 2 &#93; ) , float ( splitLine &#91; 3 &#93; ) )
DCSP flags = &#91; &#93; DCNL DCSP TCP _ FIN = 1 DCNL DCSP TCP _ SYN = 2 DCNL DCSP TCP _ RST = 4 DCNL DCSP TCP _ PSH = 8 DCNL DCSP TCP _ ACK = 16 DCNL DCSP TCP _ URG = 32 DCNL DCSP TCP _ ECE = 64 DCNL DCSP TCP _ CWK = 128 DCNL DCSP if ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ FIN ) : DCNL DCSP DCSP flags.append ( &apos; FIN &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ SYN ) : DCNL DCSP DCSP flags.append ( &apos; SYN &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ RST ) : DCNL DCSP DCSP flags.append ( &apos; RST &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ PSH ) : DCNL DCSP DCSP flags.append ( &apos; PSH &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ ACK ) : DCNL DCSP DCSP flags.append ( &apos; ACK &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ URG ) : DCNL DCSP DCSP flags.append ( &apos; URG &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ ECE ) : DCNL DCSP DCSP flags.append ( &apos; ECE &apos; ) DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; flags &apos; &#93; &amp; TCP _ CWK ) : DCNL DCSP DCSP flags.append ( &apos; CWK &apos; ) DCNL DCSP else : DCNL DCSP DCSP print ( &apos; UNKNOWN DCSP PACKET &apos; ) DCNL DCSP if ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; d _ port &apos; &#93; = = 4505 ) : DCNL DCSP DCSP if ( ( &apos; SYN &apos; in flags ) and ( len ( flags ) = = 1 ) ) : DCNL DCSP DCSP DCSP return 10 DCNL DCSP DCSP elif ( &apos; FIN &apos; in flags ) : DCNL DCSP DCSP DCSP return 12 DCNL DCSP elif ( packet &#91; &apos; tcp &apos; &#93; &#91; &apos; d _ port &apos; &#93; = = 4506 ) : DCNL DCSP DCSP if ( ( &apos; SYN &apos; in flags ) and ( len ( flags ) = = 1 ) ) : DCNL DCSP DCSP DCSP return 100 DCNL DCSP DCSP elif ( &apos; FIN &apos; in flags ) : DCNL DCSP DCSP DCSP return 120 DCNL DCSP else : DCNL DCSP DCSP return None
DCSP keys = &#91; &#93; DCNL DCSP for i in request &#91; &apos; item &apos; &#93; : DCNL DCSP DCSP if ( &apos; MemcacheSetRequest _ Item &apos; in i ) : DCNL DCSP DCSP DCSP key = i &#91; &apos; MemcacheSetRequest _ Item &apos; &#93; &#91; &apos; key &apos; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP key = i &#91; &apos; Item &apos; &#93; &#91; &apos; key &apos; &#93; DCNL DCSP DCSP keys.append ( truncate ( key ) ) DCNL DCSP return &apos; \ n &apos; .join ( keys )
DCSP if isinstance ( tck , BSpline ) : DCNL DCSP DCSP return tck.antiderivative ( n ) DCNL DCSP else : DCNL DCSP DCSP return _ impl.splantider ( tck , n )
DCSP if tag : DCNL DCSP DCSP return tag ( context , objects ) DCNL DCSP request = context &#91; &apos; request &apos; &#93; DCNL DCSP response _ format = &apos; html &apos; DCNL DCSP if ( &apos; response _ format &apos; in context ) : DCNL DCSP DCSP response _ format = context &#91; &apos; response _ format &apos; &#93; DCNL DCSP return Markup ( render _ to _ string ( &apos; core / tags / generic _ list &apos; , { &apos; objects &apos; : objects , &apos; skip _ group &apos; : skip _ group } , context _ instance = RequestContext ( request ) , response _ format = response _ format ) )
DCSP if pf _ interface : DCNL DCSP DCSP return ( &apos; / sys / bus / pci / devices / % s / physfn / net &apos; % pci _ addr ) DCNL DCSP return ( &apos; / sys / bus / pci / devices / % s / net &apos; % pci _ addr )
DCSP t = desc.type DCNL DCSP if unpacker _ coercions.has _ key ( t ) : DCNL DCSP DCSP desc = desc.AECoerceDesc ( unpacker _ coercions &#91; t &#93; ) DCNL DCSP DCSP t = desc.type DCNL DCSP if ( t = = typeAEList ) : DCNL DCSP DCSP l = &#91; &#93; DCNL DCSP DCSP for i in range ( desc.AECountItems ( ) ) : DCNL DCSP DCSP DCSP ( keyword , item ) = desc.AEGetNthDesc ( ( i + 1 ) , &apos; * * * * &apos; ) DCNL DCSP DCSP DCSP l.append ( unpack ( item , formodulename ) ) DCNL DCSP DCSP return l DCNL DCSP if ( t = = typeAERecord ) : DCNL DCSP DCSP d = { } DCNL DCSP DCSP for i in range ( desc.AECountItems ( ) ) : DCNL DCSP DCSP DCSP ( keyword , item ) = desc.AEGetNthDesc ( ( i + 1 ) , &apos; * * * * &apos; ) DCNL DCSP DCSP DCSP d &#91; keyword &#93; = unpack ( item , formodulename ) DCNL DCSP DCSP return d DCNL DCSP if ( t = = typeAEText ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP return mkaetext ( unpack ( record , formodulename ) ) DCNL DCSP if ( t = = typeAlias ) : DCNL DCSP DCSP return Carbon.File.Alias ( rawdata = desc.data ) DCNL DCSP if ( t = = typeBoolean ) : DCNL DCSP DCSP return struct.unpack ( &apos; b &apos; , desc.data ) &#91; 0 &#93; DCNL DCSP if ( t = = typeChar ) : DCNL DCSP DCSP return desc.data DCNL DCSP if ( t = = typeUnicodeText ) : DCNL DCSP DCSP return unicode ( desc.data , &apos; utf16 &apos; ) DCNL DCSP if ( t = = typeEnumeration ) : DCNL DCSP DCSP return mkenum ( desc.data ) DCNL DCSP if ( t = = typeFalse ) : DCNL DCSP DCSP return 0 DCNL DCSP if ( t = = typeFloat ) : DCNL DCSP DCSP data = desc.data DCNL DCSP DCSP return struct.unpack ( &apos; d &apos; , data ) &#91; 0 &#93; DCNL DCSP if ( t = = typeFSS ) : DCNL DCSP DCSP return Carbon.File.FSSpec ( rawdata = desc.data ) DCNL DCSP if ( t = = typeFSRef ) : DCNL DCSP DCSP return Carbon.File.FSRef ( rawdata = desc.data ) DCNL DCSP if ( t = = typeInsertionLoc ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP return mkinsertionloc ( unpack ( record , formodulename ) ) DCNL DCSP if ( t = = typeIntlText ) : DCNL DCSP DCSP ( script , language ) = struct.unpack ( &apos; hh &apos; , desc.data &#91; : 4 &#93; ) DCNL DCSP DCSP return aetypes.IntlText ( script , language , desc.data &#91; 4 : &#93; ) DCNL DCSP if ( t = = typeIntlWritingCode ) : DCNL DCSP DCSP ( script , language ) = struct.unpack ( &apos; hh &apos; , desc.data ) DCNL DCSP DCSP return aetypes.IntlWritingCode ( script , language ) DCNL DCSP if ( t = = typeKeyword ) : DCNL DCSP DCSP return mkkeyword ( desc.data ) DCNL DCSP if ( t = = typeLongInteger ) : DCNL DCSP DCSP return struct.unpack ( &apos; l &apos; , desc.data ) &#91; 0 &#93; DCNL DCSP if ( t = = typeLongDateTime ) : DCNL DCSP DCSP ( a , b ) = struct.unpack ( &apos; lL &apos; , desc.data ) DCNL DCSP DCSP return ( ( long ( a ) &lt; &lt; 32 ) + b ) DCNL DCSP if ( t = = typeNull ) : DCNL DCSP DCSP return None DCNL DCSP if ( t = = typeMagnitude ) : DCNL DCSP DCSP v = struct.unpack ( &apos; l &apos; , desc.data ) DCNL DCSP DCSP if ( v &lt; 0 ) : DCNL DCSP DCSP DCSP v = ( 4294967296L + v ) DCNL DCSP DCSP return v DCNL DCSP if ( t = = typeObjectSpecifier ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP if formodulename : DCNL DCSP DCSP DCSP return mkobjectfrommodule ( unpack ( record , formodulename ) , formodulename ) DCNL DCSP DCSP return mkobject ( unpack ( record , formodulename ) ) DCNL DCSP if ( t = = typeQDPoint ) : DCNL DCSP DCSP ( v , h ) = struct.unpack ( &apos; hh &apos; , desc.data ) DCNL DCSP DCSP return aetypes.QDPoint ( v , h ) DCNL DCSP if ( t = = typeQDRectangle ) : DCNL DCSP DCSP ( v0 , h0 , v1 , h1 ) = struct.unpack ( &apos; hhhh &apos; , desc.data ) DCNL DCSP DCSP return aetypes.QDRectangle ( v0 , h0 , v1 , h1 ) DCNL DCSP if ( t = = typeRGBColor ) : DCNL DCSP DCSP ( r , g , b ) = struct.unpack ( &apos; hhh &apos; , desc.data ) DCNL DCSP DCSP return aetypes.RGBColor ( r , g , b ) DCNL DCSP if ( t = = typeShortFloat ) : DCNL DCSP DCSP return struct.unpack ( &apos; f &apos; , desc.data ) &#91; 0 &#93; DCNL DCSP if ( t = = typeShortInteger ) : DCNL DCSP DCSP return struct.unpack ( &apos; h &apos; , desc.data ) &#91; 0 &#93; DCNL DCSP if ( t = = typeTargetID ) : DCNL DCSP DCSP return mktargetid ( desc.data ) DCNL DCSP if ( t = = typeTrue ) : DCNL DCSP DCSP return 1 DCNL DCSP if ( t = = typeType ) : DCNL DCSP DCSP return mktype ( desc.data , formodulename ) DCNL DCSP if ( t = = &apos; rang &apos; ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP return mkrange ( unpack ( record , formodulename ) ) DCNL DCSP if ( t = = &apos; cmpd &apos; ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP return mkcomparison ( unpack ( record , formodulename ) ) DCNL DCSP if ( t = = &apos; logi &apos; ) : DCNL DCSP DCSP record = desc.AECoerceDesc ( &apos; reco &apos; ) DCNL DCSP DCSP return mklogical ( unpack ( record , formodulename ) ) DCNL DCSP return mkunknown ( desc.type , desc.data )
DCSP return &#91; transl &#91; l &#93; for l in labels &#93;
DCSP mask = &apos; , &apos; .join ( mask ) DCNL DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; } DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP status = _ check _ cron ( user , path , mask , cmd ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP if ( status = = &apos; absent &apos; ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Incron DCSP { 0 } DCSP is DCSP absent &apos; .format ( name ) DCNL DCSP DCSP elif ( ( status = = &apos; present &apos; ) or ( status = = &apos; update &apos; ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Incron DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP removed &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP data = _ _ salt _ _ &#91; &apos; incron.rm _ job &apos; &#93; ( user = user , path = path , mask = mask , cmd = cmd ) DCNL DCSP if ( data = = &apos; absent &apos; ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Incron DCSP { 0 } DCSP already DCSP absent &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP if ( data = = &apos; removed &apos; ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Incron DCSP { 0 } DCSP removed DCSP from DCSP { 1 } &apos; s DCSP crontab &quot; .format ( name , user ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { user : name } DCNL DCSP DCSP return ret DCNL DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Incron DCSP { 0 } DCSP for DCSP user DCSP { 1 } DCSP failed DCSP to DCSP commit DCSP with DCSP error DCSP { 2 } &apos; .format ( name , user , data ) DCNL DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP return ret
DCSP return _ list _ users ( )
DCSP import inspect DCNL DCSP if isinstance ( frame , six.string _ types ) : DCNL DCSP DCSP frame _ names = frame _ transform _ graph.get _ names ( ) DCNL DCSP DCSP if ( frame not in frame _ names ) : DCNL DCSP DCSP DCSP raise ValueError ( u &apos;Coordinate DCSP frame DCSP { 0 } DCSP not DCSP in DCSP allowed DCSP values DCSP { 1 } &apos; .format ( frame , sorted ( frame _ names ) ) ) DCNL DCSP DCSP frame _ cls = frame _ transform _ graph.lookup _ name ( frame ) DCNL DCSP elif ( inspect.isclass ( frame ) and issubclass ( frame , BaseCoordinateFrame ) ) : DCNL DCSP DCSP frame _ cls = frame DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( u &apos;Coordinate DCSP frame DCSP must DCSP be DCSP a DCSP frame DCSP name DCSP or DCSP frame DCSP class &apos; ) DCNL DCSP return frame _ cls
DCSP while u : DCNL DCSP DCSP f = dmp _ TC ( f , K ) DCNL DCSP DCSP u - = 1 DCNL DCSP return dup _ TC ( f , K )
DCSP cur _ chromosome = BasicChromosome.Chromosome ( chr _ name ) DCNL DCSP num _ segments = random.randrange ( num _ possible _ segments ) DCNL DCSP for seg in range ( num _ segments ) : DCNL DCSP DCSP if ( seg = = 0 ) : DCNL DCSP DCSP DCSP cur _ segment = BasicChromosome.TelomereSegment ( ) DCNL DCSP DCSP elif ( seg = = ( num _ segments - 1 ) ) : DCNL DCSP DCSP DCSP cur _ segment = BasicChromosome.TelomereSegment ( 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cur _ segment = BasicChromosome.ChromosomeSegment ( ) DCNL DCSP DCSP color _ chance = random.random ( ) DCNL DCSP DCSP if ( color _ chance &lt; = color _ prob ) : DCNL DCSP DCSP DCSP fill _ color = random.choice ( color _ choices ) DCNL DCSP DCSP DCSP cur _ segment.fill _ color = fill _ color DCNL DCSP DCSP id _ chance = random.random ( ) DCNL DCSP DCSP if ( id _ chance &lt; = id _ prob ) : DCNL DCSP DCSP DCSP id = get _ random _ id ( ) DCNL DCSP DCSP DCSP cur _ segment.label = id DCNL DCSP DCSP cur _ chromosome.add ( cur _ segment ) DCNL DCSP return ( cur _ chromosome , num _ segments )
DCSP imdb = datasets.pascal _ voc ( split , year ) DCNL DCSP imdb.roidb _ handler = imdb.selective _ search _ IJCV _ roidb DCNL DCSP imdb.config &#91; &apos; top _ k &apos; &#93; = top _ k DCNL DCSP return imdb
DCSP if opts &#91; &apos; file _ ignore _ regex &apos; &#93; : DCNL DCSP DCSP for regex in opts &#91; &apos; file _ ignore _ regex &apos; &#93; : DCNL DCSP DCSP DCSP if re.search ( regex , fname ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; File DCSP matching DCSP file _ ignore _ regex . DCSP Skipping : DCSP { 0 } &apos; .format ( fname ) ) DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP if opts &#91; &apos; file _ ignore _ glob &apos; &#93; : DCNL DCSP DCSP for glob in opts &#91; &apos; file _ ignore _ glob &apos; &#93; : DCNL DCSP DCSP DCSP if fnmatch.fnmatch ( fname , glob ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; File DCSP matching DCSP file _ ignore _ glob . DCSP Skipping : DCSP { 0 } &apos; .format ( fname ) ) DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP return False
DCSP msg = u &apos; { 0 } DCSP Assuming DCSP UT1-UTC = 0 DCSP for DCSP coordinate DCSP transformations . &apos; DCNL DCSP warnings.warn ( msg.format ( ierserr.args &#91; 0 &#93; ) , AstropyWarning )
DCSP axis = _ normalize _ axis ( axis , ndim ( x ) ) DCNL DCSP if ( x.dtype.base _ dtype = = tf.bool ) : DCNL DCSP DCSP x = tf.cast ( x , floatx ( ) ) DCNL DCSP return tf.reduce _ mean ( x , reduction _ indices = axis , keep _ dims = keepdims )
DCSP src _ from = _ ensure _ src ( src _ from ) DCNL DCSP subject _ from = _ ensure _ src _ subject ( src _ from , subject _ from ) DCNL DCSP subjects _ dir = get _ subjects _ dir ( subjects _ dir , raise _ error = True ) DCNL DCSP src _ out = list ( ) DCNL DCSP for fro in src _ from : DCNL DCSP DCSP ( hemi , idx , id _ ) = _ get _ hemi ( fro ) DCNL DCSP DCSP to = op.join ( subjects _ dir , subject _ to , &apos; surf &apos; , ( &apos; % s . % s &apos; % ( hemi , surf ) ) ) DCNL DCSP DCSP logger.info ( ( &apos; Reading DCSP destination DCSP surface DCSP % s &apos; % ( to , ) ) ) DCNL DCSP DCSP to = read _ surface ( to , return _ dict = True , verbose = False ) &#91; ( -1 ) &#93; DCNL DCSP DCSP complete _ surface _ info ( to , copy = False ) DCNL DCSP DCSP best = _ get _ vertex _ map _ nn ( fro , subject _ from , subject _ to , hemi , subjects _ dir , to &#91; &apos; neighbor _ tri &apos; &#93; ) DCNL DCSP DCSP for key in ( &apos; neighbor _ tri &apos; , &apos; tri _ area &apos; , &apos; tri _ cent &apos; , &apos; tri _ nn &apos; , &apos; use _ tris &apos; ) : DCNL DCSP DCSP DCSP del to &#91; key &#93; DCNL DCSP DCSP to &#91; &apos; vertno &apos; &#93; = np.sort ( best &#91; fro &#91; &apos; vertno &apos; &#93; &#93; ) DCNL DCSP DCSP to &#91; &apos; inuse &apos; &#93; = np.zeros ( len ( to &#91; &apos; rr &apos; &#93; ) , int ) DCNL DCSP DCSP to &#91; &apos; inuse &apos; &#93; &#91; to &#91; &apos; vertno &apos; &#93; &#93; = True DCNL DCSP DCSP to &#91; &apos; use _ tris &apos; &#93; = best &#91; fro &#91; &apos; use _ tris &apos; &#93; &#93; DCNL DCSP DCSP to.update ( nuse = len ( to &#91; &apos; vertno &apos; &#93; ) , nuse _ tri = len ( to &#91; &apos; use _ tris &apos; &#93; ) , nearest = None , nearest _ dist = None , patch _ inds = None , pinfo = None , dist = None , id = id _ , dist _ limit = None , type = &apos; surf &apos; , coord _ frame = FIFF.FIFFV _ COORD _ MRI , subject _ his _ id = subject _ to , rr = ( to &#91; &apos; rr &apos; &#93; / 1000.0 ) ) DCNL DCSP DCSP src _ out.append ( to ) DCNL DCSP DCSP logger.info ( &apos; &#91; done &#93; \ n &apos; ) DCNL DCSP info = dict ( working _ dir = os.getcwd ( ) , command _ line = _ get _ call _ line ( in _ verbose = True ) ) DCNL DCSP return SourceSpaces ( src _ out , info = info )
DCSP encoding = kwds.get ( &apos; encoding &apos; , None ) DCNL DCSP if ( encoding is not None ) : DCNL DCSP DCSP encoding = re.sub ( &apos; _ &apos; , &apos; -&apos; , encoding ) .lower ( ) DCNL DCSP DCSP kwds &#91; &apos; encoding &apos; &#93; = encoding DCNL DCSP compression = kwds.get ( &apos; compression &apos; ) DCNL DCSP compression = _ infer _ compression ( filepath _ or _ buffer , compression ) DCNL DCSP ( filepath _ or _ buffer , _ , compression ) = get _ filepath _ or _ buffer ( filepath _ or _ buffer , encoding , compression ) DCNL DCSP kwds &#91; &apos; compression &apos; &#93; = compression DCNL DCSP if ( kwds.get ( &apos; date _ parser &apos; , None ) is not None ) : DCNL DCSP DCSP if isinstance ( kwds &#91; &apos; parse _ dates &apos; &#93; , bool ) : DCNL DCSP DCSP DCSP kwds &#91; &apos; parse _ dates &apos; &#93; = True DCNL DCSP iterator = kwds.get ( &apos; iterator &apos; , False ) DCNL DCSP chunksize = kwds.get ( &apos; chunksize &apos; , None ) DCNL DCSP nrows = _ validate _ nrows ( kwds.pop ( &apos; nrows &apos; , None ) ) DCNL DCSP parser = TextFileReader ( filepath _ or _ buffer , * * kwds ) DCNL DCSP if ( ( nrows is not None ) and ( chunksize is not None ) ) : DCNL DCSP DCSP raise NotImplementedError ( &quot; &apos; nrows &apos; DCSP and DCSP &apos; chunksize &apos; DCSP cannot DCSP be DCSP used DCSP together DCSP yet . &quot; ) DCNL DCSP elif ( nrows is not None ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = parser.read ( nrows ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP parser.close ( ) DCNL DCSP DCSP return data DCNL DCSP elif ( chunksize or iterator ) : DCNL DCSP DCSP return parser DCNL DCSP try : DCNL DCSP DCSP data = parser.read ( ) DCNL DCSP finally : DCNL DCSP DCSP parser.close ( ) DCNL DCSP return data
DCSP ( tags , noserver ) = read _ etag _ file ( options ) DCNL DCSP if ( noserver and ( not options.noserver ) ) : DCNL DCSP DCSP options.noserver = noserver DCNL DCSP m = re.match ( &apos; ( ? : W / ) ? &quot; ? ( . * ) &quot; ? $ &apos; , options.etag ) DCNL DCSP if m : DCNL DCSP DCSP options.etag = m.group ( 1 ) DCNL DCSP etag = options.etag DCNL DCSP if ( etag in tags ) : DCNL DCSP DCSP print ( &apos; Found DCSP etag DCSP &#91; % s &#93; DCSP for DCSP version DCSP % s &apos; % ( etag , tags &#91; etag &#93; &#91; 0 &#93; &#91; &apos; version &apos; &#93; ) ) DCNL DCSP DCSP return tags &#91; etag &#93; DCNL DCSP short = etag &#91; etag.index ( &apos; -&apos; ) : &#93; DCNL DCSP for t in tags : DCNL DCSP DCSP if ( t.find ( short ) ! = ( -1 ) ) : DCNL DCSP DCSP DCSP print ( &apos; Partial DCSP ETag DCSP match : DCSP &#91; % s &#93; , &#91; % s &#93; DCSP for DCSP version DCSP % s &apos; % ( etag , t , tags &#91; t &#93; &#91; 0 &#93; &#91; &apos; version &apos; &#93; ) ) DCNL DCSP DCSP DCSP return tags &#91; t &#93; DCNL DCSP return None
DCSP if ( get _ configured _ provider ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP if ( get _ dependencies ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP for ( provider , details ) in six.iteritems ( _ _ opts _ _ &#91; &apos; providers &apos; &#93; ) : DCNL DCSP DCSP if ( &apos; dimensiondata &apos; not in details ) : DCNL DCSP DCSP DCSP continue DCNL DCSP return _ _ virtualname _ _
DCSP R = p.ring DCNL DCSP n = R.gens.index ( x ) DCNL DCSP p1 = R.zero DCNL DCSP mn = ( &#91; 0 &#93; * R.ngens ) DCNL DCSP mn &#91; n &#93; = 1 DCNL DCSP mn = tuple ( mn ) DCNL DCSP for expv in p : DCNL DCSP DCSP if expv &#91; n &#93; : DCNL DCSP DCSP DCSP e = monomial _ ldiv ( expv , mn ) DCNL DCSP DCSP DCSP p1 &#91; e &#93; = ( p &#91; expv &#93; * expv &#91; n &#93; ) DCNL DCSP return p1
DCSP if ( pkg in _ bootstrapped ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP m = rospack.get _ manifest ( pkg ) DCNL DCSP if m.is _ catkin : DCNL DCSP DCSP _ bootstrapped.append ( pkg ) DCNL DCSP DCSP return &#91; &#93; DCNL DCSP packages = get _ depends ( pkg , rospack ) DCNL DCSP packages.append ( pkg ) DCNL DCSP paths = &#91; &#93; DCNL DCSP try : DCNL DCSP DCSP for p in packages : DCNL DCSP DCSP DCSP m = rospack.get _ manifest ( p ) DCNL DCSP DCSP DCSP d = rospack.get _ path ( p ) DCNL DCSP DCSP DCSP _ append _ package _ paths ( m , paths , d ) DCNL DCSP DCSP DCSP _ bootstrapped.append ( p ) DCNL DCSP except : DCNL DCSP DCSP if ( pkg in _ bootstrapped ) : DCNL DCSP DCSP DCSP _ bootstrapped.remove ( pkg ) DCNL DCSP DCSP raise DCNL DCSP return paths
DCSP ( procs , pipes ) = launch _ tails ( follow _ paths , lastlines _ dirpath ) DCNL DCSP while pipes : DCNL DCSP DCSP ( lines , bad _ pipes ) = poll _ tail _ pipes ( pipes , lastlines _ dirpath , waitsecs ) DCNL DCSP DCSP for bad in bad _ pipes : DCNL DCSP DCSP DCSP pipes.pop ( bad ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP outstream.writelines ( ( &#91; &apos; \ n &apos; &#93; + lines ) ) DCNL DCSP DCSP DCSP outstream.flush ( ) DCNL DCSP DCSP except ( IOError , OSError ) as e : DCNL DCSP DCSP DCSP break DCNL DCSP snuff ( procs.values ( ) )
DCSP if ( not isinstance ( data , list ) ) : DCNL DCSP DCSP raise errors.AnsibleFilterError ( &apos; &#124; failed DCSP expects DCSP to DCSP filter DCSP on DCSP a DCSP list &apos; ) DCNL DCSP if ( not isinstance ( keys , list ) ) : DCNL DCSP DCSP raise errors.AnsibleFilterError ( &apos; &#124; failed DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list &apos; ) DCNL DCSP retval = &#91; oo _ select _ keys ( item , keys ) for item in data &#93; DCNL DCSP return oo _ flatten ( retval )
DCSP user = urllib.unquote ( user ) DCNL DCSP sys.stderr.write ( ( ( ( ( &apos; checking DCSP permissions DCSP for DCSP user DCSP &apos; + user ) + &apos; DCSP on DCSP api DCSP &apos; ) + api _ name ) + &apos; \ n &apos; ) ) DCNL DCSP secret _ file = open ( &apos; / etc / appscale / secret.key &apos; , &apos; r &apos; ) DCNL DCSP secret = secret _ file.read ( ) DCNL DCSP secret = secret &#91; 0 : ( -1 ) &#93; DCNL DCSP secret _ file.close ( ) DCNL DCSP uaserver _ file = open ( &apos; / etc / appscale / hypersoap &apos; , &apos; r &apos; ) DCNL DCSP uaserver = uaserver _ file.read ( ) DCNL DCSP uaserver _ file.close ( ) DCNL DCSP server = SOAPpy.SOAPProxy ( ( ( &apos; https : / / &apos; + uaserver ) + &apos; : 4343 &apos; ) ) DCNL DCSP capabilities = server.get _ capabilities ( user , secret ) DCNL DCSP if ( not isinstance ( capabilities , str ) ) : DCNL DCSP DCSP return False DCNL DCSP capabilities = capabilities.split ( &apos; : &apos; ) DCNL DCSP sys.stderr.write ( ( ( ( ( &apos; user DCSP &apos; + user ) + &apos; DCSP has DCSP the DCSP following DCSP capabilities : DCSP &apos; ) + str ( capabilities ) ) + &apos; \ n &apos; ) ) DCNL DCSP if ( api _ name in capabilities ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP if any ( &#91; getattr ( c.op , &apos; check _ input &apos; , config.check _ input ) for ( c , _ ) in r.clients if ( not isinstance ( c , string _ types ) ) &#93; ) : DCNL DCSP DCSP if any ( &#91; getattr ( c.op , &apos; check _ broadcast &apos; , True ) for ( c , _ ) in r.clients if ( not isinstance ( c , string _ types ) ) &#93; ) : DCNL DCSP DCSP DCSP c _ extract = r.type.c _ extract ( name , sub , True ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP c _ extract = r.type.c _ extract ( name , sub , True , check _ broadcast = False ) DCNL DCSP DCSP DCSP except TypeError as e : DCNL DCSP DCSP DCSP DCSP c _ extract = r.type.c _ extract ( name , sub , True ) DCNL DCSP else : DCNL DCSP DCSP c _ extract = r.type.c _ extract ( name , sub , False ) DCNL DCSP pre = ( &apos; \ n DCSP DCSP DCSP DCSP py _ % ( name ) s DCSP = DCSP PyList _ GET _ ITEM ( storage _ % ( name ) s , DCSP 0 ) ; \ n DCSP DCSP DCSP DCSP { Py _ XINCREF ( py _ % ( name ) s ) ; } \ n DCSP DCSP DCSP DCSP &apos; % locals ( ) ) DCNL DCSP return ( pre + c _ extract )
DCSP return &apos; DCSP &apos; .join ( map ( _ stringify , value ) )
DCSP ctx = zmq.Context.instance ( ) DCNL DCSP s = ctx.socket ( zmq.PUSH ) DCNL DCSP s.connect ( url ) DCNL DCSP print ( ( &apos; Producing DCSP % s &apos; % ident ) ) DCNL DCSP for i in range ( MSGS ) : DCNL DCSP DCSP s.send ( ( u &apos; % s : DCSP % i &apos; % ( ident , time.time ( ) ) ) .encode ( &apos; utf8 &apos; ) ) DCNL DCSP DCSP time.sleep ( 1 ) DCNL DCSP print ( ( &apos; Producer DCSP % s DCSP done &apos; % ident ) ) DCNL DCSP s.close ( )
DCSP closestIndex = getClosestDistanceIndexToLine ( location , loop ) .index DCNL DCSP loop = getAroundLoop ( closestIndex , closestIndex , loop ) DCNL DCSP closestPoint = getClosestPointOnSegment ( loop &#91; 0 &#93; , loop &#91; 1 &#93; , location ) DCNL DCSP if ( ( abs ( ( closestPoint - loop &#91; 0 &#93; ) ) &gt; extrusionHalfWidth ) and ( abs ( ( closestPoint - loop &#91; 1 &#93; ) ) &gt; extrusionHalfWidth ) ) : DCNL DCSP DCSP loop = ( ( &#91; closestPoint &#93; + loop &#91; 1 : &#93; ) + &#91; loop &#91; 0 &#93; &#93; ) DCNL DCSP elif ( abs ( ( closestPoint - loop &#91; 0 &#93; ) ) &gt; abs ( ( closestPoint - loop &#91; 1 &#93; ) ) ) : DCNL DCSP DCSP loop = ( loop &#91; 1 : &#93; + &#91; loop &#91; 0 &#93; &#93; ) DCNL DCSP return loop
DCSP if is _ plotting : DCNL DCSP DCSP v = &apos; Plotting &apos; DCNL DCSP else : DCNL DCSP DCSP v = &apos; Registering DCSP plot DCSP modes &apos; DCNL DCSP if is _ independent : DCNL DCSP DCSP ( n , s ) = ( PlotMode . _ i _ var _ max , &apos; independent &apos; ) DCNL DCSP else : DCNL DCSP DCSP ( n , s ) = ( PlotMode . _ d _ var _ max , &apos; dependent &apos; ) DCNL DCSP return ( &apos; % s DCSP with DCSP more DCSP than DCSP % i DCSP % s DCSP variables DCSP is DCSP not DCSP supported . &apos; % ( v , n , s ) )
DCSP if ( len ( xs ) ! = len ( ys ) ) : DCNL DCSP DCSP raise ValueError ( &apos; xs DCSP and DCSP ys DCSP should DCSP be DCSP the DCSP same DCSP length . &apos; ) DCNL DCSP classes = set ( ys ) DCNL DCSP if ( classes ! = set ( &#91; 0 , 1 &#93; ) ) : DCNL DCSP DCSP raise ValueError ( &quot; Classes DCSP should DCSP be DCSP 0 &apos;s DCSP and DCSP 1 &apos;s &quot; ) DCNL DCSP if ( typecode is None ) : DCNL DCSP DCSP typecode = &apos; d &apos; DCNL DCSP ( N , ndims ) = ( len ( xs ) , ( len ( xs &#91; 0 &#93; ) + 1 ) ) DCNL DCSP if ( ( N = = 0 ) or ( ndims = = 1 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; No DCSP observations DCSP or DCSP observation DCSP of DCSP 0 DCSP dimension . &apos; ) DCNL DCSP X = numpy.ones ( ( N , ndims ) , typecode ) DCNL DCSP X &#91; : , 1 : &#93; = xs DCNL DCSP Xt = numpy.transpose ( X ) DCNL DCSP y = numpy.asarray ( ys , typecode ) DCNL DCSP beta = numpy.zeros ( ndims , typecode ) DCNL DCSP MAX _ ITERATIONS = 500 DCNL DCSP CONVERGE _ THRESHOLD = 0.01 DCNL DCSP stepsize = 1.0 DCNL DCSP i = 0 DCNL DCSP old _ beta = old _ llik = None DCNL DCSP while ( i &lt; MAX _ ITERATIONS ) : DCNL DCSP DCSP ebetaX = numpy.exp ( numpy.dot ( beta , Xt ) ) DCNL DCSP DCSP p = ( ebetaX / ( 1 + ebetaX ) ) DCNL DCSP DCSP logp = ( ( y * numpy.log ( p ) ) + ( ( 1 - y ) * numpy.log ( ( 1 - p ) ) ) ) DCNL DCSP DCSP llik = sum ( logp ) DCNL DCSP DCSP if ( update _ fn is not None ) : DCNL DCSP DCSP DCSP update _ fn ( iter , llik ) DCNL DCSP DCSP if ( old _ llik is not None ) : DCNL DCSP DCSP DCSP if ( llik &lt; old _ llik ) : DCNL DCSP DCSP DCSP DCSP stepsize / = 2.0 DCNL DCSP DCSP DCSP DCSP beta = old _ beta DCNL DCSP DCSP DCSP if ( numpy.fabs ( ( llik - old _ llik ) ) &lt; = CONVERGE _ THRESHOLD ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP ( old _ llik , old _ beta ) = ( llik , beta ) DCNL DCSP DCSP i + = 1 DCNL DCSP DCSP W = ( numpy.identity ( N ) * p ) DCNL DCSP DCSP Xtyp = numpy.dot ( Xt , ( y - p ) ) DCNL DCSP DCSP XtWX = numpy.dot ( numpy.dot ( Xt , W ) , X ) DCNL DCSP DCSP delta = numpy.linalg.solve ( XtWX , Xtyp ) DCNL DCSP DCSP if ( numpy.fabs ( ( stepsize - 1.0 ) ) &gt; 0.001 ) : DCNL DCSP DCSP DCSP delta * = stepsize DCNL DCSP DCSP beta + = delta DCNL DCSP else : DCNL DCSP DCSP raise RuntimeError ( &quot; Didn &apos;t DCSP converge . &quot; ) DCNL DCSP lr = LogisticRegression ( ) DCNL DCSP lr.beta = &#91; float ( x ) for x in beta &#93; DCNL DCSP return lr
DCSP response = _ client _ wrapper ( &apos; create _ volume &apos; , name , driver = driver , driver _ opts = driver _ opts ) DCNL DCSP _ clear _ context ( ) DCNL DCSP return response
DCSP linter.register _ reporter ( HTMLReporter )
DCSP ( i , j ) = np.mgrid &#91; ( -5 ) : 6 , ( -5 ) : 6 &#93; DCNL DCSP image = ( j &gt; = 0 ) .astype ( float ) DCNL DCSP result = filters.scharr _ v ( image ) DCNL DCSP j &#91; ( np.abs ( i ) = = 5 ) &#93; = 10000 DCNL DCSP assert np.all ( ( result &#91; ( j = = 0 ) &#93; = = 1 ) ) DCNL DCSP assert np.all ( ( result &#91; ( np.abs ( j ) &gt; 1 ) &#93; = = 0 ) )
DCSP try : DCNL DCSP DCSP source = open ( filename ) .readlines ( ) DCNL DCSP DCSP lower _ bound = max ( 0 , ( lineno - context _ lines ) ) DCNL DCSP DCSP upper _ bound = ( lineno + context _ lines ) DCNL DCSP DCSP pre _ context = &#91; line.strip ( &apos; \ n &apos; ) for line in source &#91; lower _ bound : lineno &#93; &#93; DCNL DCSP DCSP context _ line = source &#91; lineno &#93; .strip ( &apos; \ n &apos; ) DCNL DCSP DCSP post _ context = &#91; line.strip ( &apos; \ n &apos; ) for line in source &#91; ( lineno + 1 ) : upper _ bound &#93; &#93; DCNL DCSP DCSP return ( lower _ bound , pre _ context , context _ line , post _ context ) DCNL DCSP except ( OSError , IOError ) : DCNL DCSP DCSP return ( None , &#91; &#93; , None , &#91; &#93; )
DCSP parser = OptionParser ( usage = u &apos; % prog DCSP name DCSP &#91; options &#93; &apos; , version = ( u &apos;Review DCSP Board DCSP &apos; + get _ version _ string ( ) ) ) DCNL DCSP parser.add _ option ( u &apos; --class-name &apos; , dest = u &apos;class _ name &apos; , default = None , help = u &apos;class DCSP name DCSP of DCSP extension DCSP ( capitalized DCSP no DCSP spaces ) &apos; ) DCNL DCSP parser.add _ option ( u &apos; --package-name &apos; , dest = u &apos;package _ name &apos; , default = None , help = u &apos;package DCSP name DCSP of DCSP extension DCSP ( lower DCSP case DCSP with DCSP underscores ) &apos; ) DCNL DCSP parser.add _ option ( u &apos; --description &apos; , dest = u &apos;description &apos; , default = None , help = u &apos;description DCSP of DCSP extension &apos; ) DCNL DCSP parser.add _ option ( u &apos; --author &apos; , dest = u &apos;author &apos; , default = None , help = u &apos;author DCSP of DCSP the DCSP extension &apos; ) DCNL DCSP parser.add _ option ( u &apos; --is-configurable &apos; , dest = u &apos;is _ configurable &apos; , action = u &apos;store _ true &apos; , default = False , help = u &apos;whether DCSP this DCSP extension DCSP is DCSP configurable &apos; ) DCNL DCSP ( globals ( ) &#91; u &apos;options &apos; &#93; , args ) = parser.parse _ args ( ) DCNL DCSP if ( len ( args ) ! = 1 ) : DCNL DCSP DCSP print ( u &apos;Error : DCSP incorrect DCSP number DCSP of DCSP arguments &apos; ) DCNL DCSP DCSP parser.print _ help ( ) DCNL DCSP DCSP exit ( ( -1 ) ) DCNL DCSP options.extension _ name = args &#91; 0 &#93; DCNL DCSP autofill _ unprovided _ options ( )
DCSP version _ re = re.compile ( &apos; ^ LATEST _ LIBXML2 _ IS _ ( . * ) $ &apos; ) DCNL DCSP filename = &apos; libxml2- % s.tar.gz &apos; DCNL DCSP return download _ library ( dest _ dir , LIBXML2 _ LOCATION , &apos; libxml2 &apos; , version _ re , filename , version = version )
DCSP if ( push _ notification _ enabled ( ) and update.get ( &apos; push _ notification _ selected &apos; ) ) : DCNL DCSP DCSP course = modulestore ( ) .get _ course ( course _ key ) DCNL DCSP DCSP if course : DCNL DCSP DCSP DCSP push _ course _ update _ task.delay ( unicode ( course _ key ) , course.clean _ id ( padding _ char = &apos; _ &apos; ) , course.display _ name )
DCSP paths _ dict = dict ( paths ) DCNL DCSP def os _ walk ( top , topdown = True ) : DCNL DCSP DCSP ( dirs , nondirs ) = paths _ dict &#91; top &#93; DCNL DCSP DCSP ( yield ( top , dirs , nondirs ) ) DCNL DCSP DCSP for name in dirs : DCNL DCSP DCSP DCSP new _ path = &apos; / &apos; .join ( &#91; top , name &#93; ) DCNL DCSP DCSP DCSP for x in os _ walk ( new _ path , topdown ) : DCNL DCSP DCSP DCSP DCSP ( yield x ) DCNL DCSP return os _ walk
DCSP output = &#91; &apos; &apos; &#93; DCNL DCSP widget _ lines = _ get _ widgets ( ) DCNL DCSP widget _ lines = &#91; ( &apos; DCSP DCSP DCSP DCSP &apos; + e ) for e in widget _ lines &#93; DCNL DCSP widget _ lines.insert ( 0 , &apos; Qt DCSP widgets DCSP - DCSP { } DCSP objects : &apos; .format ( len ( widget _ lines ) ) ) DCNL DCSP output + = widget _ lines DCNL DCSP if ( start _ obj is None ) : DCNL DCSP DCSP start _ obj = QApplication.instance ( ) DCNL DCSP pyqt _ lines = &#91; &#93; DCNL DCSP _ get _ pyqt _ objects ( pyqt _ lines , start _ obj ) DCNL DCSP pyqt _ lines = &#91; ( &apos; DCSP DCSP DCSP DCSP &apos; + e ) for e in pyqt _ lines &#93; DCNL DCSP pyqt _ lines.insert ( 0 , &apos; Qt DCSP objects DCSP - DCSP { } DCSP objects : &apos; .format ( len ( pyqt _ lines ) ) ) DCNL DCSP output + = &#91; &apos; &apos; &#93; DCNL DCSP output + = pyqt _ lines DCNL DCSP output + = objreg.dump _ objects ( ) DCNL DCSP return &apos; \ n &apos; .join ( output )
DCSP if ( &apos; display _ name &apos; in param _ dict ) : DCNL DCSP DCSP param _ dict &#91; &apos; course _ name &apos; &#93; = param _ dict &#91; &apos; display _ name &apos; &#93; DCNL DCSP param _ dict &#91; &apos; site _ name &apos; &#93; = configuration _ helpers.get _ value ( &apos; SITE _ NAME &apos; , param _ dict &#91; &apos; site _ name &apos; &#93; ) DCNL DCSP subject = None DCNL DCSP message = None DCNL DCSP message _ type = param _ dict &#91; &apos; message &apos; &#93; DCNL DCSP email _ template _ dict = { &apos; allowed _ enroll &apos; : ( &apos; emails / enroll _ email _ allowedsubject.txt &apos; , &apos; emails / enroll _ email _ allowedmessage.txt &apos; ) , &apos; enrolled _ enroll &apos; : ( &apos; emails / enroll _ email _ enrolledsubject.txt &apos; , &apos; emails / enroll _ email _ enrolledmessage.txt &apos; ) , &apos; allowed _ unenroll &apos; : ( &apos; emails / unenroll _ email _ subject.txt &apos; , &apos; emails / unenroll _ email _ allowedmessage.txt &apos; ) , &apos; enrolled _ unenroll &apos; : ( &apos; emails / unenroll _ email _ subject.txt &apos; , &apos; emails / unenroll _ email _ enrolledmessage.txt &apos; ) , &apos; add _ beta _ tester &apos; : ( &apos; emails / add _ beta _ tester _ email _ subject.txt &apos; , &apos; emails / add _ beta _ tester _ email _ message.txt &apos; ) , &apos; remove _ beta _ tester &apos; : ( &apos; emails / remove _ beta _ tester _ email _ subject.txt &apos; , &apos; emails / remove _ beta _ tester _ email _ message.txt &apos; ) , &apos; account _ creation _ and _ enrollment &apos; : ( &apos; emails / enroll _ email _ enrolledsubject.txt &apos; , &apos; emails / account _ creation _ and _ enroll _ emailMessage.txt &apos; ) } DCNL DCSP ( subject _ template , message _ template ) = email _ template _ dict.get ( message _ type , ( None , None ) ) DCNL DCSP if ( ( subject _ template is not None ) and ( message _ template is not None ) ) : DCNL DCSP DCSP ( subject , message ) = render _ message _ to _ string ( subject _ template , message _ template , param _ dict , language = language ) DCNL DCSP if ( subject and message ) : DCNL DCSP DCSP message = message.strip ( ) DCNL DCSP DCSP subject = &apos; &apos;.join ( subject.splitlines ( ) ) DCNL DCSP DCSP from _ address = configuration _ helpers.get _ value ( &apos; email _ from _ address &apos; , settings.DEFAULT _ FROM _ EMAIL ) DCNL DCSP DCSP send _ mail ( subject , message , from _ address , &#91; student &#93; , fail _ silently = False )
DCSP return os.path.join ( autodir , &apos; results &apos; , &apos; default &apos; , &apos; debug &apos; , &apos; client.DEBUG &apos; )
DCSP return check _ call ( cmd , shell = True )
DCSP attr = exc.kwargs.get ( &apos; attr &apos; ) DCNL DCSP state = exc.kwargs.get ( &apos; state &apos; ) DCNL DCSP if ( ( attr is not None ) and ( state is not None ) ) : DCNL DCSP DCSP msg = ( _ ( &quot; Cannot DCSP &apos; % ( action ) s &apos; DCSP instance DCSP % ( server _ id ) s DCSP while DCSP it DCSP is DCSP in DCSP % ( attr ) s DCSP % ( state ) s &quot; ) % { &apos; action &apos; : action , &apos; attr &apos; : attr , &apos; state &apos; : state , &apos; server _ id &apos; : server _ id } ) DCNL DCSP else : DCNL DCSP DCSP msg = ( _ ( &quot; Instance DCSP % ( server _ id ) s DCSP is DCSP in DCSP an DCSP invalid DCSP state DCSP for DCSP &apos; % ( action ) s &apos; &quot; ) % { &apos; action &apos; : action , &apos; server _ id &apos; : server _ id } ) DCNL DCSP raise webob.exc.HTTPConflict ( explanation = msg )
DCSP if ( start &lt; end ) : DCNL DCSP DCSP p = choosePivot ( start , end ) DCNL DCSP DCSP ( a &#91; start &#93; , a &#91; p &#93; ) = ( a &#91; p &#93; , a &#91; start &#93; ) DCNL DCSP DCSP j = partition ( a , start , end ) DCNL DCSP DCSP if ( j = = i ) : DCNL DCSP DCSP DCSP return a &#91; i &#93; DCNL DCSP DCSP if ( j &lt; i ) : DCNL DCSP DCSP DCSP return random _ selection ( a , ( j + 1 ) , end , i ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return random _ selection ( a , start , ( j - 1 ) , i ) DCNL DCSP else : DCNL DCSP DCSP return a &#91; start &#93;
DCSP parser = OptionParser ( ) DCNL DCSP parser.add _ option ( &apos; -d &apos; , &apos; --days &apos; , dest = &apos; days &apos; , action = &apos; store &apos; , type = &apos; int &apos; , help = &apos; number DCSP of DCSP days DCSP ( 14 ) &apos; , default = 14 ) DCNL DCSP parser.add _ option ( &apos; -i &apos; , &apos; --info _ only &apos; , action = &apos; store _ true &apos; , dest = &apos; info _ only &apos; , help = &apos; info DCSP about DCSP the DCSP requested DCSP action &apos; , default = False ) DCNL DCSP parser.add _ option ( &apos; -v &apos; , &apos; --verbose &apos; , action = &apos; store _ true &apos; , dest = &apos; verbose &apos; , help = &apos; verbose DCSP mode , DCSP print DCSP the DCSP name DCSP of DCSP each DCSP repository &apos; , default = False ) DCNL DCSP ( options , args ) = parser.parse _ args ( ) DCNL DCSP try : DCNL DCSP DCSP ini _ file = args &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP sys.exit ( ( &apos; Usage : DCSP python DCSP % s DCSP &lt; tool DCSP shed DCSP .ini DCSP file &gt; DCSP &#91; options &#93; &apos; % sys.argv &#91; 0 &#93; ) ) DCNL DCSP config _ parser = ConfigParser.ConfigParser ( { &apos; here &apos; : os.getcwd ( ) } ) DCNL DCSP config _ parser.read ( ini _ file ) DCNL DCSP config _ dict = { } DCNL DCSP for ( key , value ) in config _ parser.items ( &apos; app : main &apos; ) : DCNL DCSP DCSP config _ dict &#91; key &#93; = value DCNL DCSP config = tool _ shed _ config.Configuration ( * * config _ dict ) DCNL DCSP app = DeprecateRepositoriesApplication ( config ) DCNL DCSP cutoff _ time = ( datetime.utcnow ( ) - timedelta ( days = options.days ) ) DCNL DCSP now = strftime ( &apos; % Y- % m- % d DCSP % H : % M : % S &apos; ) DCNL DCSP print &apos; \ n # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # &apos; DCNL DCSP print ( &apos; # DCSP % s DCSP - DCSP Handling DCSP stuff DCSP older DCSP than DCSP % i DCSP days &apos; % ( now , options.days ) ) DCNL DCSP if options.info _ only : DCNL DCSP DCSP print &apos; # DCSP Displaying DCSP info DCSP only DCSP ( DCSP --info _ only DCSP ) &apos; DCNL DCSP deprecate _ repositories ( app , cutoff _ time , days = options.days , info _ only = options.info _ only , verbose = options.verbose )
DCSP if ( not isinstance ( package , string _ types ) ) : DCNL DCSP DCSP raise ValueError DCNL DCSP ( pkg _ base , pkg _ dir ) = get _ package _ paths ( package ) DCNL DCSP if subdir : DCNL DCSP DCSP pkg _ dir = os.path.join ( pkg _ dir , subdir ) DCNL DCSP datas = &#91; &#93; DCNL DCSP for ( dirpath , dirnames , files ) in os.walk ( pkg _ dir ) : DCNL DCSP DCSP for f in files : DCNL DCSP DCSP DCSP extension = os.path.splitext ( f ) &#91; 1 &#93; DCNL DCSP DCSP DCSP if ( include _ py _ files or ( extension not in PY _ IGNORE _ EXTENSIONS ) ) : DCNL DCSP DCSP DCSP DCSP source = os.path.join ( dirpath , f ) DCNL DCSP DCSP DCSP DCSP dest = remove _ prefix ( dirpath , ( os.path.dirname ( pkg _ base ) + os.sep ) ) DCNL DCSP DCSP DCSP DCSP datas.append ( ( source , dest ) ) DCNL DCSP return datas
DCSP salt = _ make _ salt ( ) DCNL DCSP return _ encrypt ( salt , plaintext , g.tracking _ secret )
DCSP referrers = &#91; &#93; DCNL DCSP groups = &#91; &#93; DCNL DCSP if acl _ string : DCNL DCSP DCSP for value in acl _ string.split ( &apos; , &apos; ) : DCNL DCSP DCSP DCSP if value.startswith ( &apos; .r : &apos; ) : DCNL DCSP DCSP DCSP DCSP referrers.append ( value &#91; len ( &apos; .r : &apos; ) : &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP groups.append ( value ) DCNL DCSP return ( referrers , groups )
DCSP proc = popen _ sp ( * args , * * kwargs ) DCNL DCSP if proc.stdin : DCNL DCSP DCSP proc.stdin = pipebuf.NonBlockBufferedWriter ( proc.stdin ) DCNL DCSP if proc.stdout : DCNL DCSP DCSP proc.stdout = pipebuf.NonBlockBufferedReader ( proc.stdout ) DCNL DCSP if proc.stderr : DCNL DCSP DCSP proc.stderr = pipebuf.NonBlockBufferedReader ( proc.stderr ) DCNL DCSP return proc
DCSP if ( not f ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP n = ( len ( f ) - 1 ) DCNL DCSP ( h , Q ) = ( &#91; f &#91; 0 &#93; &#93; , &#91; &#91; K.one &#93; &#93; ) DCNL DCSP for i in range ( 0 , n ) : DCNL DCSP DCSP Q.append ( dup _ mul ( Q &#91; ( -1 ) &#93; , q , K ) ) DCNL DCSP for ( c , q ) in zip ( f &#91; 1 : &#93; , Q &#91; 1 : &#93; ) : DCNL DCSP DCSP h = dup _ mul ( h , p , K ) DCNL DCSP DCSP q = dup _ mul _ ground ( q , c , K ) DCNL DCSP DCSP h = dup _ add ( h , q , K ) DCNL DCSP return h
DCSP _ _ connect ( ) DCNL DCSP collection = mongodb &#91; collection.collection _ type ( ) &#93; DCNL DCSP data = collection.find _ one ( { &apos; name &apos; : item.name } ) DCNL DCSP if data : DCNL DCSP DCSP collection.update ( { &apos; name &apos; : item.name } , item.to _ dict ( ) ) DCNL DCSP else : DCNL DCSP DCSP collection.insert ( item.to _ dict ( ) )
DCSP return Serato ( c _ instance )
DCSP if ( request.function ! = &apos; fema &apos; ) : DCNL DCSP DCSP s3.filter = ( FS ( &apos; req _ id $ is _ template &apos; ) = = False ) DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( r.interactive or ( r.representation = = &apos; aadata &apos; ) ) : DCNL DCSP DCSP DCSP list _ fields = s3db.get _ config ( &apos; req _ req _ item &apos; , &apos; list _ fields &apos; ) DCNL DCSP DCSP DCSP list _ fields.insert ( 1 , &apos; req _ id $ site _ id &apos; ) DCNL DCSP DCSP DCSP levels = gis.get _ relevant _ hierarchy _ levels ( ) DCNL DCSP DCSP DCSP levels.reverse ( ) DCNL DCSP DCSP DCSP for level in levels : DCNL DCSP DCSP DCSP DCSP lfield = ( &apos; req _ id $ site _ id $ location _ id $ % s &apos; % level ) DCNL DCSP DCSP DCSP DCSP list _ fields.insert ( 1 , lfield ) DCNL DCSP DCSP DCSP s3db.configure ( &apos; req _ req _ item &apos; , insertable = False , list _ fields = list _ fields ) DCNL DCSP DCSP DCSP s3.crud _ strings &#91; &apos; req _ req _ item &apos; &#93; .title _ list = T ( &apos; Requested DCSP Items &apos; ) DCNL DCSP DCSP DCSP if ( ( r.method ! = None ) and ( r.method ! = &apos; update &apos; ) and ( r.method ! = &apos; read &apos; ) ) : DCNL DCSP DCSP DCSP DCSP s3db.req _ hide _ quantities ( r.table ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3 _ rest _ controller ( &apos; req &apos; , &apos; req _ item &apos; ) DCNL DCSP if settings.get _ req _ prompt _ match ( ) : DCNL DCSP DCSP req _ item _ inv _ item _ btn = dict ( url = URL ( c = &apos; req &apos; , f = &apos; req _ item _ inv _ item &apos; , args = &#91; &apos; &#91; id &#93; &apos; &#93; ) , _ class = &apos; action-btn &apos; , label = str ( T ( &apos; Request DCSP from DCSP Facility &apos; ) ) ) DCNL DCSP DCSP if s3.actions : DCNL DCSP DCSP DCSP s3.actions.append ( req _ item _ inv _ item _ btn ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP s3.actions = &#91; req _ item _ inv _ item _ btn &#93; DCNL DCSP return output
DCSP if ( not hostname ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Missing DCSP hostname DCSP parameter &apos; ) DCNL DCSP if ( not service ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Missing DCSP service DCSP parameter &apos; ) DCNL DCSP target = &apos; service &apos; DCNL DCSP numeric = kwargs.get ( &apos; numeric &apos; ) DCNL DCSP data = _ status _ query ( target , hostname , service = service , enumerate = numeric ) DCNL DCSP ret = { &apos; result &apos; : data &#91; &apos; result &apos; &#93; } DCNL DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; status &apos; &#93; = data.get ( &apos; json _ data &apos; , { } ) .get ( &apos; data &apos; , { } ) .get ( target , { } ) .get ( &apos; status &apos; , ( ( ( not numeric ) and &apos; Unknown &apos; ) or 2 ) ) DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; error &apos; &#93; = data &#91; &apos; error &apos; &#93; DCNL DCSP return ret
DCSP print problem.get _ html ( )
DCSP return request.current _ route _ url ( * elements , * * kw )
DCSP import re DCNL DCSP newCode = code DCNL DCSP newCode = remove _ comments ( newCode ) DCNL DCSP if ( &apos; function DCSP Invoke-ReflectivePEInjection &apos; in newCode ) : DCNL DCSP DCSP newCode = newCode.replace ( &quot; $ TypeBuilder.DefineLiteral ( &apos; IMAGE _ DLL _ CHARACTERISTICS _ DYNAMIC _ BASE &apos; , DCSP &#91; UInt16 &#93; DCSP 0x0040 ) DCSP &#124; DCSP Out-Null &quot; , &quot; $ TypeBuilder.DefineLiteral ( &apos; IMAGE _ DLL _ CHARACTERIS &apos; + &apos; TICS _ DYNAMIC _ BASE &apos; , DCSP &#91; UInt16 &#93; DCSP 0x0040 ) DCSP &#124; DCSP Out-Null &quot; ) DCNL DCSP return newCode
DCSP buf = &#91; &#93; DCNL DCSP for line in ir.splitlines ( ) : DCNL DCSP DCSP if re _ metadata _ def.match ( line ) : DCNL DCSP DCSP DCSP if ( None is re _ metadata _ correct _ usage.search ( line ) ) : DCNL DCSP DCSP DCSP DCSP line = line.replace ( &apos; ! { &apos; , &apos; metadata DCSP ! { &apos; ) DCNL DCSP DCSP DCSP DCSP line = line.replace ( &apos; ! &quot; &apos; , &apos; metadata DCSP ! &quot; &apos; ) DCNL DCSP DCSP DCSP DCSP def sub _ metadata ( m ) : DCNL DCSP DCSP DCSP DCSP DCSP return &apos; metadata DCSP { 0 } &apos; .format ( m.group ( 0 ) ) DCNL DCSP DCSP DCSP DCSP line = re _ metadata _ ref.sub ( sub _ metadata , line ) DCNL DCSP DCSP DCSP DCSP line = line.lstrip ( &apos; metadata DCSP &apos; ) DCNL DCSP DCSP buf.append ( line ) DCNL DCSP return &apos; \ n &apos; .join ( buf )
DCSP return ArrowFactory ( type )
DCSP def mbsize ( x ) : DCNL DCSP DCSP &apos; DCSP Return DCSP size DCSP in DCSP MB . DCSP &apos; DCNL DCSP DCSP return str ( int ( ( x / ( 1024 * * 2 ) ) ) ) DCNL DCSP p = util.get _ pafy ( song ) DCNL DCSP dldata = &#91; &#93; DCNL DCSP text = &apos; DCSP &#91; Fetching DCSP stream DCSP info &#93; DCSP &gt; &apos; DCNL DCSP streamlist = &#91; x for x in p.allstreams &#93; DCNL DCSP if ( mediatype = = &apos; audio &apos; ) : DCNL DCSP DCSP streamlist = &#91; x for x in p.audiostreams &#93; DCNL DCSP l = len ( streamlist ) DCNL DCSP for ( n , stream ) in enumerate ( streamlist ) : DCNL DCSP DCSP sys.stdout.write ( ( ( ( ( text + ( &apos; -&apos; * n ) ) + &apos; &gt; &apos; ) + ( &apos; DCSP &apos; * ( ( l - n ) - 1 ) ) ) + &apos; &lt; \ r &apos; ) ) DCNL DCSP DCSP sys.stdout.flush ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP size = mbsize ( stream.get _ filesize ( ) ) DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP util.dbg ( ( ( c.r + &apos; ---Error DCSP getting DCSP stream DCSP size &apos; ) + c.w ) ) DCNL DCSP DCSP DCSP size = 0 DCNL DCSP DCSP item = { &apos; mediatype &apos; : stream.mediatype , &apos; size &apos; : size , &apos; ext &apos; : stream.extension , &apos; quality &apos; : stream.quality , &apos; notes &apos; : stream.notes , &apos; url &apos; : stream.url } DCNL DCSP DCSP dldata.append ( item ) DCNL DCSP screen.writestatus ( &apos; &apos; ) DCNL DCSP return ( dldata , p )
DCSP ( algorithm _ name , digestmod ) = get _ algorithm ( algorithm ) DCNL DCSP if first : DCNL DCSP DCSP ctx = hmac.new ( secret , digestmod = digestmod ) DCNL DCSP DCSP ml = len ( request _ mac ) DCNL DCSP DCSP if ( ml &gt; 0 ) : DCNL DCSP DCSP DCSP ctx.update ( struct.pack ( &apos; ! H &apos; , ml ) ) DCNL DCSP DCSP DCSP ctx.update ( request _ mac ) DCNL DCSP id = struct.pack ( &apos; ! H &apos; , original _ id ) DCNL DCSP ctx.update ( id ) DCNL DCSP ctx.update ( wire &#91; 2 : &#93; ) DCNL DCSP if first : DCNL DCSP DCSP ctx.update ( keyname.to _ digestable ( ) ) DCNL DCSP DCSP ctx.update ( struct.pack ( &apos; ! H &apos; , dns.rdataclass.ANY ) ) DCNL DCSP DCSP ctx.update ( struct.pack ( &apos; ! I &apos; , 0 ) ) DCNL DCSP long _ time = ( time + 0L ) DCNL DCSP upper _ time = ( ( long _ time &gt; &gt; 32 ) &amp; 65535L ) DCNL DCSP lower _ time = ( long _ time &amp; 4294967295L ) DCNL DCSP time _ mac = struct.pack ( &apos; ! HIH &apos; , upper _ time , lower _ time , fudge ) DCNL DCSP pre _ mac = ( algorithm _ name + time _ mac ) DCNL DCSP ol = len ( other _ data ) DCNL DCSP if ( ol &gt; 65535 ) : DCNL DCSP DCSP raise ValueError ( &apos; TSIG DCSP Other DCSP Data DCSP is DCSP &gt; DCSP 65535 DCSP bytes &apos; ) DCNL DCSP post _ mac = ( struct.pack ( &apos; ! HH &apos; , error , ol ) + other _ data ) DCNL DCSP if first : DCNL DCSP DCSP ctx.update ( pre _ mac ) DCNL DCSP DCSP ctx.update ( post _ mac ) DCNL DCSP else : DCNL DCSP DCSP ctx.update ( time _ mac ) DCNL DCSP mac = ctx.digest ( ) DCNL DCSP mpack = struct.pack ( &apos; ! H &apos; , len ( mac ) ) DCNL DCSP tsig _ rdata = ( ( ( ( pre _ mac + mpack ) + mac ) + id ) + post _ mac ) DCNL DCSP if multi : DCNL DCSP DCSP ctx = hmac.new ( secret , digestmod = digestmod ) DCNL DCSP DCSP ml = len ( mac ) DCNL DCSP DCSP ctx.update ( struct.pack ( &apos; ! H &apos; , ml ) ) DCNL DCSP DCSP ctx.update ( mac ) DCNL DCSP else : DCNL DCSP DCSP ctx = None DCNL DCSP return ( tsig _ rdata , mac , ctx )
DCSP document = { &apos; errors &apos; : errors , &apos; jsonapi &apos; : { &apos; version &apos; : JSONAPI _ VERSION } } DCNL DCSP return ( jsonpify ( document ) , status )
DCSP if ( ( j &lt; 0 ) or ( j &gt; u ) ) : DCNL DCSP DCSP raise IndexError ( ( &apos; 0 DCSP &lt; = DCSP j DCSP &lt; = DCSP u DCSP expected , DCSP got DCSP % s &apos; % ( u , j ) ) ) DCNL DCSP return _ rec _ integrate _ in ( f , m , u , 0 , j , K )
DCSP threads = threading.enumerate ( ) DCNL DCSP output _ file = ( PROFILING _ OUTPUT _ FMT % get _ filename _ fmt ( ) ) DCNL DCSP data = { } DCNL DCSP for ( thread , frame ) in sys . _ current _ frames ( ) .items ( ) : DCNL DCSP DCSP trace = traceback.format _ stack ( frame ) DCNL DCSP DCSP data &#91; ( &apos; % x &apos; % thread ) &#93; = { &apos; traceback &apos; : trace , &apos; name &apos; : get _ thread _ name ( threads , thread ) } DCNL DCSP json.dump ( data , file ( output _ file , &apos; w &apos; ) , indent = 4 )
DCSP db = get _ db ( ctx , rd , library _ id ) DCNL DCSP with db.safe _ read _ lock : DCNL DCSP DCSP id _ is _ uuid = rd.query.get ( u &apos;id _ is _ uuid &apos; , u &apos;false &apos; ) DCNL DCSP DCSP ids = rd.query.get ( u &apos;ids &apos; ) DCNL DCSP DCSP if ( ( ids is None ) or ( ids = = u &apos;all &apos; ) ) : DCNL DCSP DCSP DCSP ids = db.all _ book _ ids ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ids = ids.split ( u &apos; , &apos; ) DCNL DCSP DCSP DCSP if ( id _ is _ uuid = = u &apos;true &apos; ) : DCNL DCSP DCSP DCSP DCSP ids = { db.lookup _ by _ uuid ( x ) for x in ids } DCNL DCSP DCSP DCSP DCSP ids.discard ( None ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP ids = { int ( x ) for x in ids } DCNL DCSP DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP DCSP raise HTTPNotFound ( u &apos;ids DCSP must DCSP a DCSP comma DCSP separated DCSP list DCSP of DCSP integers &apos; ) DCNL DCSP DCSP last _ modified = None DCNL DCSP DCSP category _ urls = ( rd.query.get ( u &apos;category _ urls &apos; , u &apos;true &apos; ) .lower ( ) = = u &apos;true &apos; ) DCNL DCSP DCSP device _ compatible = ( rd.query.get ( u &apos;device _ compatible &apos; , u &apos;false &apos; ) .lower ( ) = = u &apos;true &apos; ) DCNL DCSP DCSP device _ for _ template = rd.query.get ( u &apos;device _ for _ template &apos; , None ) DCNL DCSP DCSP ans = { } DCNL DCSP DCSP restricted _ to = ctx.allowed _ book _ ids ( rd , db ) DCNL DCSP DCSP for book _ id in ids : DCNL DCSP DCSP DCSP if ( book _ id not in restricted _ to ) : DCNL DCSP DCSP DCSP DCSP ans &#91; book _ id &#93; = None DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP ( data , lm ) = book _ to _ json ( ctx , rd , db , book _ id , get _ category _ urls = category _ urls , device _ compatible = device _ compatible , device _ for _ template = device _ for _ template ) DCNL DCSP DCSP DCSP last _ modified = ( lm if ( last _ modified is None ) else max ( lm , last _ modified ) ) DCNL DCSP DCSP DCSP ans &#91; book _ id &#93; = data DCNL DCSP if ( last _ modified is not None ) : DCNL DCSP DCSP rd.outheaders &#91; u &apos;Last-Modified &apos; &#93; = http _ date ( timestampfromdt ( last _ modified ) ) DCNL DCSP return ans
DCSP if ( network _ info is None ) : DCNL DCSP DCSP return None DCNL DCSP if hasattr ( network _ info , &apos; legacy &apos; ) : DCNL DCSP DCSP network _ info = network _ info.legacy ( ) DCNL DCSP nets = &#91; &#93; DCNL DCSP ifc _ num = ( -1 ) DCNL DCSP have _ injected _ networks = False DCNL DCSP for ( network _ ref , mapping ) in network _ info : DCNL DCSP DCSP ifc _ num + = 1 DCNL DCSP DCSP if ( not network _ ref &#91; &apos; injected &apos; &#93; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP have _ injected _ networks = True DCNL DCSP DCSP address = mapping &#91; &apos; ips &apos; &#93; &#91; 0 &#93; &#91; &apos; ip &apos; &#93; DCNL DCSP DCSP netmask = mapping &#91; &apos; ips &apos; &#93; &#91; 0 &#93; &#91; &apos; netmask &apos; &#93; DCNL DCSP DCSP address _ v6 = None DCNL DCSP DCSP gateway _ v6 = None DCNL DCSP DCSP netmask _ v6 = None DCNL DCSP DCSP if use _ ipv6 : DCNL DCSP DCSP DCSP address _ v6 = mapping &#91; &apos; ip6s &apos; &#93; &#91; 0 &#93; &#91; &apos; ip &apos; &#93; DCNL DCSP DCSP DCSP netmask _ v6 = mapping &#91; &apos; ip6s &apos; &#93; &#91; 0 &#93; &#91; &apos; netmask &apos; &#93; DCNL DCSP DCSP DCSP gateway _ v6 = mapping &#91; &apos; gateway _ v6 &apos; &#93; DCNL DCSP DCSP net _ info = { &apos; name &apos; : ( &apos; eth % d &apos; % ifc _ num ) , &apos; address &apos; : address , &apos; netmask &apos; : netmask , &apos; gateway &apos; : mapping &#91; &apos; gateway &apos; &#93; , &apos; broadcast &apos; : mapping &#91; &apos; broadcast &apos; &#93; , &apos; dns &apos; : &apos; DCSP &apos; .join ( mapping &#91; &apos; dns &apos; &#93; ) , &apos; address _ v6 &apos; : address _ v6 , &apos; gateway _ v6 &apos; : gateway _ v6 , &apos; netmask _ v6 &apos; : netmask _ v6 } DCNL DCSP DCSP nets.append ( net _ info ) DCNL DCSP if ( have _ injected _ networks is False ) : DCNL DCSP DCSP return None DCNL DCSP if ( not template ) : DCNL DCSP DCSP return None DCNL DCSP _ late _ load _ cheetah ( ) DCNL DCSP ifc _ template = open ( template ) .read ( ) DCNL DCSP return str ( Template ( ifc _ template , searchList = &#91; { &apos; interfaces &apos; : nets , &apos; use _ ipv6 &apos; : use _ ipv6 } &#93; ) )
DCSP standarddir.init ( None ) DCNL DCSP ( yield ) DCNL DCSP standarddir.init ( None )
DCSP if full : DCNL DCSP DCSP return ( _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( &apos; / bin / pkg DCSP refresh DCSP --full &apos; ) = = 0 ) DCNL DCSP else : DCNL DCSP DCSP return ( _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( &apos; / bin / pkg DCSP refresh &apos; ) = = 0 )
DCSP if ( settings.USE _ TZ and ( value is not None ) and timezone.is _ naive ( value ) ) : DCNL DCSP DCSP current _ timezone = timezone.get _ current _ timezone ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return timezone.make _ aware ( value , current _ timezone ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP raise ValidationError ( ( _ ( u &quot; % ( datetime ) s DCSP couldn &apos;t DCSP be DCSP interpreted DCSP in DCSP time DCSP zone DCSP % ( current _ timezone ) s ; DCSP it DCSP may DCSP be DCSP ambiguous DCSP or DCSP it DCSP may DCSP not DCSP exist . &quot; ) % { u &apos;datetime &apos; : value , u &apos;current _ timezone &apos; : current _ timezone } ) ) DCNL DCSP return value
DCSP CONFIG.AddOption ( type _ info.Bool ( name = name , default = default , description = help ) )
DCSP if osp.isfile ( LANG _ FILE ) : DCNL DCSP DCSP with open ( LANG _ FILE , &apos; r &apos; ) as f : DCNL DCSP DCSP DCSP lang = f.read ( ) DCNL DCSP else : DCNL DCSP DCSP lang = get _ interface _ language ( ) DCNL DCSP DCSP save _ lang _ conf ( lang ) DCNL DCSP if ( lang.strip ( &apos; \ n &apos; ) in DISABLED _ LANGUAGES ) : DCNL DCSP DCSP lang = DEFAULT _ LANGUAGE DCNL DCSP DCSP save _ lang _ conf ( lang ) DCNL DCSP return lang
DCSP def nameCollision ( * args , * * kwargs ) : DCNL DCSP DCSP return fn ( * args , * * kwargs ) DCNL DCSP return nameCollision
DCSP if ( &apos; env &apos; in kwargs ) : DCNL DCSP DCSP salt.utils.warn _ until ( &apos; Oxygen &apos; , &quot; Parameter DCSP &apos; env &apos; DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list . DCSP DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP &apos; saltenv &apos; DCSP as DCSP of DCSP Salt DCSP 2016.11.0 . DCSP DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen . &quot; ) DCNL DCSP DCSP kwargs.pop ( &apos; env &apos; ) DCNL DCSP path = os.path.normpath ( path ) DCNL DCSP fnd = { &apos; path &apos; : &apos; &apos; , &apos; rel &apos; : &apos; &apos; } DCNL DCSP if os.path.isabs ( path ) : DCNL DCSP DCSP return fnd DCNL DCSP if ( saltenv not in _ _ opts _ _ &#91; &apos; file _ roots &apos; &#93; ) : DCNL DCSP DCSP return fnd DCNL DCSP def _ add _ file _ stat ( fnd ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Stat DCSP the DCSP file DCSP and , DCSP assuming DCSP no DCSP errors DCSP were DCSP found , DCSP convert DCSP the DCSP stat \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP result DCSP to DCSP a DCSP list DCSP of DCSP values DCSP and DCSP add DCSP to DCSP the DCSP return DCSP dict . \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Converting DCSP the DCSP stat DCSP result DCSP to DCSP a DCSP list , DCSP the DCSP elements DCSP of DCSP the DCSP list \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP correspond DCSP to DCSP the DCSP following DCSP stat _ result DCSP params : \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 0 DCSP = &gt; DCSP st _ mode = 33188 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 1 DCSP = &gt; DCSP st _ ino = 10227377 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 2 DCSP = &gt; DCSP st _ dev = 65026 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 3 DCSP = &gt; DCSP st _ nlink = 1 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 4 DCSP = &gt; DCSP st _ uid = 1000 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 5 DCSP = &gt; DCSP st _ gid = 1000 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 6 DCSP = &gt; DCSP st _ size = 1056233 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 7 DCSP = &gt; DCSP st _ atime = 1468284229 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 8 DCSP = &gt; DCSP st _ mtime = 1456338235 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP 9 DCSP = &gt; DCSP st _ ctime = 1456338235 \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP fnd &#91; &apos; stat &apos; &#93; = list ( os.stat ( fnd &#91; &apos; path &apos; &#93; ) ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP return fnd DCNL DCSP if ( &apos; index &apos; in kwargs ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP root = _ _ opts _ _ &#91; &apos; file _ roots &apos; &#93; &#91; saltenv &#93; &#91; int ( kwargs &#91; &apos; index &apos; &#93; ) &#93; DCNL DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP return fnd DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP return fnd DCNL DCSP DCSP full = os.path.join ( root , path ) DCNL DCSP DCSP if ( os.path.isfile ( full ) and ( not salt.fileserver.is _ file _ ignored ( _ _ opts _ _ , full ) ) ) : DCNL DCSP DCSP DCSP fnd &#91; &apos; path &apos; &#93; = full DCNL DCSP DCSP DCSP fnd &#91; &apos; rel &apos; &#93; = path DCNL DCSP DCSP DCSP return _ add _ file _ stat ( fnd ) DCNL DCSP DCSP return fnd DCNL DCSP for root in _ _ opts _ _ &#91; &apos; file _ roots &apos; &#93; &#91; saltenv &#93; : DCNL DCSP DCSP full = os.path.join ( root , path ) DCNL DCSP DCSP if ( os.path.isfile ( full ) and ( not salt.fileserver.is _ file _ ignored ( _ _ opts _ _ , full ) ) ) : DCNL DCSP DCSP DCSP fnd &#91; &apos; path &apos; &#93; = full DCNL DCSP DCSP DCSP fnd &#91; &apos; rel &apos; &#93; = path DCNL DCSP DCSP DCSP return _ add _ file _ stat ( fnd ) DCNL DCSP return fnd
DCSP filepath = os.path.dirname ( os.path.abspath ( _ _ file _ _ ) ) DCNL DCSP data = pd.read _ csv ( os.path.join ( ( filepath + &apos; / china _ smoking.csv &apos; ) ) , index _ col = &apos; Location &apos; ) DCNL DCSP return utils.Dataset ( data = data , title = &apos; Smoking DCSP and DCSP lung DCSP cancer DCSP in DCSP Chinese DCSP regions &apos; )
DCSP for item in seq : DCNL DCSP DCSP if scalarp ( item ) : DCNL DCSP DCSP DCSP ( yield item ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for subitem in flatten ( item , scalarp ) : DCNL DCSP DCSP DCSP DCSP ( yield subitem )
DCSP normalizedSegment = ( pointEnd - pointBegin ) DCNL DCSP normalizedSegmentLength = abs ( normalizedSegment ) DCNL DCSP if ( normalizedSegmentLength &gt; 0.0 ) : DCNL DCSP DCSP normalizedSegment / = normalizedSegmentLength DCNL DCSP DCSP segmentYMirror = complex ( normalizedSegment.real , ( - normalizedSegment.imag ) ) DCNL DCSP DCSP pointBeginRotated = ( segmentYMirror * pointBegin ) DCNL DCSP DCSP pointEndRotated = ( segmentYMirror * pointEnd ) DCNL DCSP DCSP if isLoopListIntersectingInsideXSegment ( loops , pointBeginRotated.real , pointEndRotated.real , segmentYMirror , pointBeginRotated.imag ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP if ( not diffs ) : DCNL DCSP DCSP return &apos; No DCSP differences &apos; DCNL DCSP diffs = diffs.items ( ) DCNL DCSP diffs.sort ( ) DCNL DCSP s = &#91; &#93; DCNL DCSP last = &apos; &apos; DCNL DCSP for ( path , desc ) in diffs : DCNL DCSP DCSP t = _ space _ prefix ( last , path , indent = 4 , include _ sep = False ) DCNL DCSP DCSP if colorize : DCNL DCSP DCSP DCSP t = color _ line ( t , 11 ) DCNL DCSP DCSP last = path DCNL DCSP DCSP if ( len ( desc.splitlines ( ) ) &gt; 1 ) : DCNL DCSP DCSP DCSP cur _ indent = len ( re.search ( &apos; ^ &#91; DCSP &#93; * &apos; , t ) .group ( 0 ) ) DCNL DCSP DCSP DCSP desc = indent ( ( cur _ indent + 2 ) , desc ) DCNL DCSP DCSP DCSP if colorize : DCNL DCSP DCSP DCSP DCSP t + = &apos; \ n &apos; DCNL DCSP DCSP DCSP DCSP for line in desc.splitlines ( ) : DCNL DCSP DCSP DCSP DCSP DCSP if line.strip ( ) .startswith ( &apos; + &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP line = color _ line ( line , 10 ) DCNL DCSP DCSP DCSP DCSP DCSP elif line.strip ( ) .startswith ( &apos; -&apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP line = color _ line ( line , 9 ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP line = color _ line ( line , 14 ) DCNL DCSP DCSP DCSP DCSP DCSP t + = ( line + &apos; \ n &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP t + = ( &apos; \ n &apos; + desc ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP t + = ( &apos; DCSP &apos; + desc ) DCNL DCSP DCSP s.append ( t ) DCNL DCSP s.append ( ( &apos; Files DCSP with DCSP differences : DCSP % s &apos; % len ( diffs ) ) ) DCNL DCSP return &apos; \ n &apos; .join ( s )
DCSP tax = get _ object _ or _ 404 ( Tax , pk = tax _ id ) DCNL DCSP if ( ( not request.user.profile.has _ permission ( tax , mode = &apos; r &apos; ) ) and ( not request.user.profile.is _ admin ( &apos; treeio _ finance &apos; ) ) ) : DCNL DCSP DCSP return user _ denied ( request , &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Tax &quot; , response _ format ) DCNL DCSP return render _ to _ response ( &apos; finance / tax _ view &apos; , { &apos; tax &apos; : tax } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP before = time.time ( ) DCNL DCSP res = func ( ) DCNL DCSP return ( ( time.time ( ) - before ) , res )
DCSP if ( not obs _ date ) : DCNL DCSP DCSP return strptime ( http _ date , &apos; % a , DCSP % d DCSP % b DCSP % Y DCSP % H : % M : % S DCSP % Z &apos; ) DCNL DCSP time _ formats = ( &apos; % a , DCSP % d DCSP % b DCSP % Y DCSP % H : % M : % S DCSP % Z &apos; , &apos; % a , DCSP % d- % b- % Y DCSP % H : % M : % S DCSP % Z &apos; , &apos; % A , DCSP % d- % b- % y DCSP % H : % M : % S DCSP % Z &apos; , &apos; % a DCSP % b DCSP % d DCSP % H : % M : % S DCSP % Y &apos; ) DCNL DCSP for time _ format in time _ formats : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return strptime ( http _ date , time _ format ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP continue DCNL DCSP raise ValueError ( ( &apos; time DCSP data DCSP % r DCSP does DCSP not DCSP match DCSP known DCSP formats &apos; % http _ date ) )
DCSP import myusps DCNL DCSP try : DCNL DCSP DCSP cookie = hass.config.path ( COOKIE ) DCNL DCSP DCSP session = myusps.get _ session ( config.get ( CONF _ USERNAME ) , config.get ( CONF _ PASSWORD ) , cookie _ path = cookie ) DCNL DCSP except myusps.USPSError : DCNL DCSP DCSP _ LOGGER.exception ( &apos; Could DCSP not DCSP connect DCSP to DCSP My DCSP USPS &apos; ) DCNL DCSP DCSP return False DCNL DCSP add _ devices ( &#91; USPSSensor ( session , config.get ( CONF _ UPDATE _ INTERVAL ) ) &#93; )
DCSP validate _ start _ action ( action ) DCNL DCSP if is _ systemd _ distribution ( distribution ) : DCNL DCSP DCSP return sequence ( &#91; run _ from _ args ( &#91; &apos; systemctl &apos; , &apos; enable &apos; , &apos; flocker-control &apos; &#93; ) , run _ from _ args ( &#91; &apos; systemctl &apos; , action.lower ( ) , &apos; flocker-control &apos; &#93; ) &#93; ) DCNL DCSP elif is _ ubuntu ( distribution ) : DCNL DCSP DCSP return sequence ( &#91; put ( path = &apos; / etc / init / flocker-control.override &apos; , content = dedent ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP start DCSP on DCSP runlevel DCSP &#91; 2345 &#93; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP stop DCSP on DCSP runlevel DCSP &#91; 016 &#93; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; ) ) , run ( &quot; echo DCSP &apos; flocker-control-api DCTB 4523 / tcp DCTB DCTB DCTB # DCSP Flocker DCSP Control DCSP API DCSP port &apos; DCSP &gt; &gt; DCSP / etc / services &quot; ) , run ( &quot; echo DCSP &apos; flocker-control-agent DCTB 4524 / tcp DCTB DCTB DCTB # DCSP Flocker DCSP Control DCSP Agent DCSP port &apos; DCSP &gt; &gt; DCSP / etc / services &quot; ) , run _ from _ args ( &#91; &apos; service &apos; , &apos; flocker-control &apos; , action.lower ( ) &#93; ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP raise DistributionNotSupported ( distribution = distribution )
DCSP client = SoftLayer.Client ( username = config.get _ cloud _ config _ value ( &apos; user &apos; , get _ configured _ provider ( ) , _ _ opts _ _ , search _ global = False ) , api _ key = config.get _ cloud _ config _ value ( &apos; apikey &apos; , get _ configured _ provider ( ) , _ _ opts _ _ , search _ global = False ) ) DCNL DCSP return client &#91; service &#93;
DCSP N = s.shape &#91; axis &#93; DCNL DCSP S = np.fft.fft ( s , n = ( ( 2 * N ) - 1 ) , axis = axis ) DCNL DCSP sxx = np.fft.ifft ( ( S * S.conjugate ( ) ) , axis = axis ) .real &#91; : N &#93; DCNL DCSP return ( sxx / N )
DCSP def can _ load ( ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Can DCSP this DCSP user DCSP load DCSP this DCSP course ? \ n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP NOTE : DCSP this DCSP is DCSP not DCSP checking DCSP whether DCSP user DCSP is DCSP actually DCSP enrolled DCSP in DCSP the DCSP course . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP response = ( _ visible _ to _ nonstaff _ users ( courselike ) and _ can _ access _ descriptor _ with _ start _ date ( user , courselike , courselike.id ) ) DCNL DCSP DCSP return ( ACCESS _ GRANTED if ( response or _ has _ staff _ access _ to _ descriptor ( user , courselike , courselike.id ) ) else response ) DCNL DCSP def can _ enroll ( ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP whether DCSP the DCSP user DCSP can DCSP enroll DCSP in DCSP the DCSP course . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP return _ can _ enroll _ courselike ( user , courselike ) DCNL DCSP def see _ exists ( ) : DCNL DCSP DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Can DCSP see DCSP if DCSP can DCSP enroll , DCSP but DCSP also DCSP if DCSP can DCSP load DCSP it : DCSP if DCSP user DCSP enrolled DCSP in DCSP a DCSP course DCSP and DCSP now \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP it &apos;s DCSP past DCSP the DCSP enrollment DCSP period , DCSP they DCSP should DCSP still DCSP see DCSP it . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; DCNL DCSP DCSP return ( ACCESS _ GRANTED if ( can _ load ( ) or can _ enroll ( ) ) else ACCESS _ DENIED ) DCNL DCSP def can _ see _ in _ catalog ( ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Implements DCSP the DCSP &quot; can DCSP see DCSP course DCSP in DCSP catalog &quot; DCSP logic DCSP if DCSP a DCSP course DCSP should DCSP be DCSP visible DCSP in DCSP the DCSP main DCSP course DCSP catalog \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog _ visibility DCSP property DCSP on DCSP the DCSP course DCSP descriptor \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP return ( _ has _ catalog _ visibility ( courselike , CATALOG _ VISIBILITY _ CATALOG _ AND _ ABOUT ) or _ has _ staff _ access _ to _ descriptor ( user , courselike , courselike.id ) ) DCNL DCSP def can _ see _ about _ page ( ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Implements DCSP the DCSP &quot; can DCSP see DCSP course DCSP about DCSP page &quot; DCSP logic DCSP if DCSP a DCSP course DCSP about DCSP page DCSP should DCSP be DCSP visible \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog _ visibility DCSP property DCSP on DCSP the DCSP course DCSP descriptor \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP return ( _ has _ catalog _ visibility ( courselike , CATALOG _ VISIBILITY _ CATALOG _ AND _ ABOUT ) or _ has _ catalog _ visibility ( courselike , CATALOG _ VISIBILITY _ ABOUT ) or _ has _ staff _ access _ to _ descriptor ( user , courselike , courselike.id ) ) DCNL DCSP checkers = { &apos; load &apos; : can _ load , &apos; view _ courseware _ with _ prerequisites &apos; : ( lambda : _ can _ view _ courseware _ with _ prerequisites ( user , courselike ) ) , &apos; load _ mobile &apos; : ( lambda : ( can _ load ( ) and _ can _ load _ course _ on _ mobile ( user , courselike ) ) ) , &apos; enroll &apos; : can _ enroll , &apos; see _ exists &apos; : see _ exists , &apos; staff &apos; : ( lambda : _ has _ staff _ access _ to _ descriptor ( user , courselike , courselike.id ) ) , &apos; instructor &apos; : ( lambda : _ has _ instructor _ access _ to _ descriptor ( user , courselike , courselike.id ) ) , &apos; see _ in _ catalog &apos; : can _ see _ in _ catalog , &apos; see _ about _ page &apos; : can _ see _ about _ page } DCNL DCSP return _ dispatch ( checkers , action , user , courselike )
DCSP sequences _ out = &#91; &#91; &#93; for _ in range ( len ( sequences ) ) &#93; DCNL DCSP for i in range ( len ( sequences ) ) : DCNL DCSP DCSP if remove _ last : DCNL DCSP DCSP DCSP sequences _ out &#91; i &#93; = ( &#91; start _ id &#93; + sequences &#91; i &#93; &#91; : ( -1 ) &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sequences _ out &#91; i &#93; = ( &#91; start _ id &#93; + sequences &#91; i &#93; ) DCNL DCSP return sequences _ out
DCSP cnn = CondensedNearestNeighbour ( random _ state = RND _ SEED ) DCNL DCSP assert _ raises ( RuntimeError , cnn.sample , X , Y )
DCSP f = int _ or _ true _ div ( ( as _ scalar ( x ) .type in discrete _ types ) , ( as _ scalar ( y ) .type in discrete _ types ) ) DCNL DCSP return f ( x , y )
DCSP uid = parse _ uid ( uid ) DCNL DCSP if ( uid ! = os.getuid ( ) ) : DCNL DCSP DCSP os.seteuid ( uid )
DCSP nitems = payload.used DCNL DCSP listobj = c.pyapi.list _ new ( nitems ) DCNL DCSP ok = cgutils.is _ not _ null ( c.builder , listobj ) DCNL DCSP with c.builder.if _ then ( ok , likely = True ) : DCNL DCSP DCSP index = cgutils.alloca _ once _ value ( c.builder , ir.Constant ( nitems.type , 0 ) ) DCNL DCSP DCSP with payload . _ iterate ( ) as loop : DCNL DCSP DCSP DCSP i = c.builder.load ( index ) DCNL DCSP DCSP DCSP item = loop.entry.key DCNL DCSP DCSP DCSP itemobj = c.box ( typ.dtype , item ) DCNL DCSP DCSP DCSP c.pyapi.list _ setitem ( listobj , i , itemobj ) DCNL DCSP DCSP DCSP i = c.builder.add ( i , ir.Constant ( i.type , 1 ) ) DCNL DCSP DCSP DCSP c.builder.store ( i , index ) DCNL DCSP return ( ok , listobj )
DCSP mtime = os.stat ( filename ) .st _ mtime DCNL DCSP ( lastupdate , result ) = cache.get ( filename , ( 0 , None ) ) DCNL DCSP if ( lastupdate &lt; mtime ) : DCNL DCSP DCSP info = inspect.getmoduleinfo ( filename ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP file = open ( filename ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if ( info and ( &apos; b &apos; in info &#91; 2 &#93; ) ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP module = imp.load _ module ( &apos; _ _ temp _ _ &apos; , file , filename , info &#91; 1 : &#93; ) DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP return None DCNL DCSP DCSP DCSP result = ( module . _ _ doc _ _ or &apos; &apos; ) .splitlines ( ) &#91; 0 &#93; DCNL DCSP DCSP DCSP del sys.modules &#91; &apos; _ _ temp _ _ &apos; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = source _ synopsis ( file ) DCNL DCSP DCSP DCSP file.close ( ) DCNL DCSP DCSP cache &#91; filename &#93; = ( mtime , result ) DCNL DCSP return result
DCSP print ( &quot; --- DCSP Cleaning DCSP Autoscale DCSP Groups DCSP matching DCSP &apos; % s &apos; &quot; % args.match _ re ) DCNL DCSP for region in pyrax.identity.services.autoscale.regions : DCNL DCSP DCSP asg = pyrax.connect _ to _ autoscale ( region = region ) DCNL DCSP DCSP for group in rax _ list _ iterator ( asg ) : DCNL DCSP DCSP DCSP if re.search ( args.match _ re , group.name ) : DCNL DCSP DCSP DCSP DCSP group.manager. _ delete = _ force _ delete _ rax _ scaling _ group ( group.manager ) DCNL DCSP DCSP DCSP DCSP prompt _ and _ delete ( group , ( &apos; Delete DCSP matching DCSP % s ? DCSP &#91; y / n &#93; : DCSP &apos; % group ) , args.assumeyes )
DCSP user _ home = os.path.expanduser ( &apos; ~ &apos; ) DCNL DCSP ( join , exists ) = ( os.path.join , os.path.exists ) DCNL DCSP if mswin : DCNL DCSP DCSP return join ( user _ home , &apos; Downloads &apos; , &apos; mps &apos; ) DCNL DCSP USER _ DIRS = join ( user _ home , &apos; .config &apos; , &apos; user-dirs.dirs &apos; ) DCNL DCSP DOWNLOAD _ HOME = join ( user _ home , &apos; Downloads &apos; ) DCNL DCSP if ( &apos; XDG _ DOWNLOAD _ DIR &apos; in os.environ ) : DCNL DCSP DCSP ddir = os.environ &#91; &apos; XDG _ DOWNLOAD _ DIR &apos; &#93; DCNL DCSP elif exists ( USER _ DIRS ) : DCNL DCSP DCSP lines = open ( USER _ DIRS ) .readlines ( ) DCNL DCSP DCSP defn = &#91; x for x in lines if x.startswith ( &apos; XDG _ DOWNLOAD _ DIR &apos; ) &#93; DCNL DCSP DCSP if ( len ( defn ) = = 1 ) : DCNL DCSP DCSP DCSP ddir = defn &#91; 0 &#93; .split ( &apos; = &apos; ) &#91; 1 &#93; .replace ( &apos; &quot; &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP ddir = ddir.replace ( &apos; $ HOME &apos; , user _ home ) .strip ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ddir = ( DOWNLOAD _ HOME if exists ( DOWNLOAD _ HOME ) else user _ home ) DCNL DCSP else : DCNL DCSP DCSP ddir = ( DOWNLOAD _ HOME if exists ( DOWNLOAD _ HOME ) else user _ home ) DCNL DCSP ddir = ddir DCNL DCSP return os.path.join ( ddir , &apos; mps &apos; )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP floating _ ip _ pool _ list DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function &apos; ) DCNL DCSP conn = get _ conn ( ) DCNL DCSP return conn.floating _ ip _ pool _ list ( )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP table = Table ( table _ name , connection = conn ) DCNL DCSP table.delete ( ) DCNL DCSP MAX _ ATTEMPTS = 30 DCNL DCSP for i in range ( MAX _ ATTEMPTS ) : DCNL DCSP DCSP if ( not exists ( table _ name , region , key , keyid , profile ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP time.sleep ( 1 ) DCNL DCSP return False
DCSP ( yield ( qualName , &#91; &#93; ) ) DCNL DCSP qualParts = qualName.split ( &apos; .&apos; ) DCNL DCSP for index in range ( 1 , len ( qualParts ) ) : DCNL DCSP DCSP ( yield ( &apos; .&apos;.join ( qualParts &#91; : ( - index ) &#93; ) , qualParts &#91; ( - index ) : &#93; ) )
DCSP form _ data = { &apos; code &apos; : &apos; foo &apos; , &apos; fullname &apos; : &apos; Foo &apos; , &apos; checkstyle &apos; : &apos; foo &apos; , &apos; nplurals &apos; : &apos; 2&apos; , &apos; specialchars &apos; : specialchars } DCNL DCSP form = LanguageForm ( form _ data ) DCNL DCSP assert form.is _ valid ( ) DCNL DCSP assert ( form.cleaned _ data &#91; &apos; specialchars &apos; &#93; .count ( count _ char ) = = 1 )
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP is _ present = _ _ salt _ _ &#91; &apos; boto _ sqs.exists &apos; &#93; ( name , region , key , keyid , profile ) DCNL DCSP if ( not is _ present ) : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP msg = &apos; AWS DCSP SQS DCSP queue DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP created . &apos; .format ( name ) DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP created = _ _ salt _ _ &#91; &apos; boto _ sqs.create &apos; &#93; ( name , region , key , keyid , profile ) DCNL DCSP DCSP if created : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; old &apos; &#93; = None DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = { &apos; queue &apos; : name } DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP { 0 } DCSP AWS DCSP queue &apos; .format ( name ) DCNL DCSP DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; { 0 } DCSP present . &apos; .format ( name ) DCNL DCSP attrs _ to _ set = { } DCNL DCSP _ attributes = _ _ salt _ _ &#91; &apos; boto _ sqs.get _ attributes &apos; &#93; ( name , region , key , keyid , profile ) DCNL DCSP if attributes : DCNL DCSP DCSP for ( attr , val ) in six.iteritems ( attributes ) : DCNL DCSP DCSP DCSP _ val = _ attributes.get ( attr , None ) DCNL DCSP DCSP DCSP if ( attr = = &apos; Policy &apos; ) : DCNL DCSP DCSP DCSP DCSP if isinstance ( _ val , six.string _ types ) : DCNL DCSP DCSP DCSP DCSP DCSP _ val = json.loads ( _ val ) DCNL DCSP DCSP DCSP DCSP if isinstance ( val , six.string _ types ) : DCNL DCSP DCSP DCSP DCSP DCSP val = json.loads ( val ) DCNL DCSP DCSP DCSP DCSP if ( _ val ! = val ) : DCNL DCSP DCSP DCSP DCSP DCSP log.debug ( &apos; Policies DCSP differ : \ n { 0 } \ n { 1 } &apos; .format ( _ val , val ) ) DCNL DCSP DCSP DCSP DCSP DCSP attrs _ to _ set &#91; attr &#93; = json.dumps ( val , sort _ keys = True ) DCNL DCSP DCSP DCSP elif ( str ( _ val ) ! = str ( val ) ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; Attributes DCSP differ : \ n { 0 } \ n { 1 } &apos; .format ( _ val , val ) ) DCNL DCSP DCSP DCSP DCSP attrs _ to _ set &#91; attr &#93; = val DCNL DCSP attr _ names = &apos; , &apos; .join ( attrs _ to _ set ) DCNL DCSP if attrs _ to _ set : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Attribute ( s ) DCSP { 0 } DCSP to DCSP be DCSP set DCSP on DCSP { 1 } . &apos; .format ( attr _ names , name ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP msg = &apos; DCSP Setting DCSP { 0 } DCSP attribute ( s ) . &apos; .format ( attr _ names ) DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = ( ret &#91; &apos; comment &apos; &#93; + msg ) DCNL DCSP DCSP if ( &apos; new &apos; in ret &#91; &apos; changes &apos; &#93; ) : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; &#91; &apos; attributes _ set &apos; &#93; = &#91; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = { &apos; attributes _ set &apos; : &#91; &#93; } DCNL DCSP DCSP for ( attr , val ) in six.iteritems ( attrs _ to _ set ) : DCNL DCSP DCSP DCSP set _ attr = _ _ salt _ _ &#91; &apos; boto _ sqs.set _ attributes &apos; &#93; ( name , { attr : val } , region , key , keyid , profile ) DCNL DCSP DCSP DCSP if ( not set _ attr ) : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP msg = &apos; Set DCSP attribute DCSP { 0 } . &apos; .format ( attr ) DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; &#91; &apos; attributes _ set &apos; &#93; .append ( attr ) DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = ( ret &#91; &apos; comment &apos; &#93; + &apos; DCSP Attributes DCSP set . &apos; ) DCNL DCSP return ret
DCSP from sympy.simplify.radsimp import split _ surds DCNL DCSP p = _ mexpand ( p ) DCNL DCSP if p.is _ Number : DCNL DCSP DCSP res = ( p , S.Zero , S.Zero ) DCNL DCSP elif p.is _ Add : DCNL DCSP DCSP pargs = sorted ( p.args , key = default _ sort _ key ) DCNL DCSP DCSP if all ( ( ( x * * 2 ) .is _ Rational for x in pargs ) ) : DCNL DCSP DCSP DCSP ( r , b , a ) = split _ surds ( p ) DCNL DCSP DCSP DCSP res = ( a , b , r ) DCNL DCSP DCSP DCSP return list ( res ) DCNL DCSP DCSP v = &#91; ( sqrt _ depth ( x ) , x , i ) for ( i , x ) in enumerate ( pargs ) &#93; DCNL DCSP DCSP nmax = max ( v , key = default _ sort _ key ) DCNL DCSP DCSP if ( nmax &#91; 0 &#93; = = 0 ) : DCNL DCSP DCSP DCSP res = &#91; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( depth , _ , i ) = nmax DCNL DCSP DCSP DCSP r = pargs.pop ( i ) DCNL DCSP DCSP DCSP v.pop ( i ) DCNL DCSP DCSP DCSP b = S.One DCNL DCSP DCSP DCSP if r.is _ Mul : DCNL DCSP DCSP DCSP DCSP bv = &#91; &#93; DCNL DCSP DCSP DCSP DCSP rv = &#91; &#93; DCNL DCSP DCSP DCSP DCSP for x in r.args : DCNL DCSP DCSP DCSP DCSP DCSP if ( sqrt _ depth ( x ) &lt; depth ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP bv.append ( x ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP rv.append ( x ) DCNL DCSP DCSP DCSP DCSP b = Mul . _ from _ args ( bv ) DCNL DCSP DCSP DCSP DCSP r = Mul . _ from _ args ( rv ) DCNL DCSP DCSP DCSP a1 = &#91; &#93; DCNL DCSP DCSP DCSP b1 = &#91; b &#93; DCNL DCSP DCSP DCSP for x in v : DCNL DCSP DCSP DCSP DCSP if ( x &#91; 0 &#93; &lt; depth ) : DCNL DCSP DCSP DCSP DCSP DCSP a1.append ( x &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP x1 = x &#91; 1 &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( x1 = = r ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP b1.append ( 1 ) DCNL DCSP DCSP DCSP DCSP DCSP elif x1.is _ Mul : DCNL DCSP DCSP DCSP DCSP DCSP DCSP x1args = list ( x1.args ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( r in x1args ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP x1args.remove ( r ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP b1.append ( Mul ( * x1args ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP a1.append ( x &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP a1.append ( x &#91; 1 &#93; ) DCNL DCSP DCSP DCSP a = Add ( * a1 ) DCNL DCSP DCSP DCSP b = Add ( * b1 ) DCNL DCSP DCSP DCSP res = ( a , b , ( r * * 2 ) ) DCNL DCSP else : DCNL DCSP DCSP ( b , r ) = p.as _ coeff _ Mul ( ) DCNL DCSP DCSP if is _ sqrt ( r ) : DCNL DCSP DCSP DCSP res = ( S.Zero , b , ( r * * 2 ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP res = &#91; &#93; DCNL DCSP return list ( res )
DCSP event = get _ object _ or _ 404 ( Event , pk = event _ id ) DCNL DCSP if ( not request.user.profile.has _ permission ( event , mode = &apos; w &apos; ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Event &quot; ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; cancel &apos; not in request.POST ) : DCNL DCSP DCSP DCSP form = EventForm ( request.user.profile , None , None , request.POST , instance = event ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP event = form.save ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; events _ event _ view &apos; , args = &#91; event.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; events &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP form = EventForm ( request.user.profile , instance = event ) DCNL DCSP return render _ to _ response ( &apos; events / event _ edit &apos; , { &apos; event &apos; : event , &apos; form &apos; : form } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP parsed _ media _ url = urlparse ( settings.MEDIA _ URL ) DCNL DCSP if request.path _ info.startswith ( parsed _ media _ url.path ) : DCNL DCSP DCSP if parsed _ media _ url.netloc : DCNL DCSP DCSP DCSP if ( request.get _ host ( ) = = parsed _ media _ url.netloc ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP subnet _ ids = &#91; &#93; DCNL DCSP subnet _ names = &#91; &#93; DCNL DCSP subnet _ cidrs = &#91; &#93; DCNL DCSP for subnet in ( identified _ subnets or &#91; &#93; ) : DCNL DCSP DCSP if re.match ( SUBNET _ RE , subnet ) : DCNL DCSP DCSP DCSP subnet _ ids.append ( subnet ) DCNL DCSP DCSP elif re.match ( CIDR _ RE , subnet ) : DCNL DCSP DCSP DCSP subnet _ cidrs.append ( subnet ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP subnet _ names.append ( subnet ) DCNL DCSP subnets _ by _ id = &#91; &#93; DCNL DCSP if subnet _ ids : DCNL DCSP DCSP subnets _ by _ id = vpc _ conn.get _ all _ subnets ( subnet _ ids , filters = { &apos; vpc _ id &apos; : vpc _ id } ) DCNL DCSP DCSP for subnet _ id in subnet _ ids : DCNL DCSP DCSP DCSP if ( not any ( ( ( s.id = = subnet _ id ) for s in subnets _ by _ id ) ) ) : DCNL DCSP DCSP DCSP DCSP raise AnsibleSubnetSearchException ( &apos; Subnet DCSP ID DCSP &quot; { 0 } &quot; DCSP does DCSP not DCSP exist &apos; .format ( subnet _ id ) ) DCNL DCSP subnets _ by _ cidr = &#91; &#93; DCNL DCSP if subnet _ cidrs : DCNL DCSP DCSP subnets _ by _ cidr = vpc _ conn.get _ all _ subnets ( filters = { &apos; vpc _ id &apos; : vpc _ id , &apos; cidr &apos; : subnet _ cidrs } ) DCNL DCSP DCSP for cidr in subnet _ cidrs : DCNL DCSP DCSP DCSP if ( not any ( ( ( s.cidr _ block = = cidr ) for s in subnets _ by _ cidr ) ) ) : DCNL DCSP DCSP DCSP DCSP raise AnsibleSubnetSearchException ( &apos; Subnet DCSP CIDR DCSP &quot; { 0 } &quot; DCSP does DCSP not DCSP exist &apos; .format ( cidr ) ) DCNL DCSP subnets _ by _ name = &#91; &#93; DCNL DCSP if subnet _ names : DCNL DCSP DCSP subnets _ by _ name = vpc _ conn.get _ all _ subnets ( filters = { &apos; vpc _ id &apos; : vpc _ id , &apos; tag : Name &apos; : subnet _ names } ) DCNL DCSP DCSP for name in subnet _ names : DCNL DCSP DCSP DCSP matching _ count = len ( &#91; 1 for s in subnets _ by _ name if ( s.tags.get ( &apos; Name &apos; ) = = name ) &#93; ) DCNL DCSP DCSP DCSP if ( matching _ count = = 0 ) : DCNL DCSP DCSP DCSP DCSP raise AnsibleSubnetSearchException ( &apos; Subnet DCSP named DCSP &quot; { 0 } &quot; DCSP does DCSP not DCSP exist &apos; .format ( name ) ) DCNL DCSP DCSP DCSP elif ( matching _ count &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP raise AnsibleSubnetSearchException ( &apos; Multiple DCSP subnets DCSP named DCSP &quot; { 0 } &quot; &apos; .format ( name ) ) DCNL DCSP return ( ( subnets _ by _ id + subnets _ by _ cidr ) + subnets _ by _ name )
DCSP data = &#91; 0 , 1 &#93; DCNL DCSP mask = np.array ( &#91; True , False &#93; ) DCNL DCSP result = sigma _ clipped _ stats ( data , mask = mask ) DCNL DCSP assert isinstance ( result &#91; 1 &#93; , float ) DCNL DCSP assert ( result = = ( 1.0 , 1.0 , 0.0 ) ) DCNL DCSP result = sigma _ clipped _ stats ( data , mask _ value = 0.0 ) DCNL DCSP assert isinstance ( result &#91; 1 &#93; , float ) DCNL DCSP assert ( result = = ( 1.0 , 1.0 , 0.0 ) ) DCNL DCSP data = &#91; 0 , 2 &#93; DCNL DCSP result = sigma _ clipped _ stats ( data ) DCNL DCSP assert isinstance ( result &#91; 1 &#93; , float ) DCNL DCSP assert ( result = = ( 1.0 , 1.0 , 1.0 ) ) DCNL DCSP _ data = np.arange ( 10 ) DCNL DCSP data = np.ma.MaskedArray ( &#91; _ data , _ data , ( 10 * _ data ) &#93; ) DCNL DCSP mean = sigma _ clip ( data , axis = 0 , sigma = 1 ) .mean ( axis = 0 ) DCNL DCSP assert _ equal ( mean , _ data ) DCNL DCSP ( mean , median , stddev ) = sigma _ clipped _ stats ( data , axis = 0 , sigma = 1 ) DCNL DCSP assert _ equal ( mean , _ data ) DCNL DCSP assert _ equal ( median , _ data ) DCNL DCSP assert _ equal ( stddev , np.zeros _ like ( _ data ) )
DCSP path = ( example _ bin _ lush _ path + &apos; ubyte _ scalar.lushbin &apos; ) DCNL DCSP result = read _ bin _ lush _ matrix ( path ) DCNL DCSP assert ( str ( result.dtype ) = = &apos; uint8 &apos; ) DCNL DCSP assert ( len ( result.shape ) = = 3 ) DCNL DCSP assert ( result.shape &#91; 0 &#93; = = 1 ) DCNL DCSP assert ( result.shape &#91; 1 &#93; = = 1 ) DCNL DCSP assert ( result.shape &#91; 1 &#93; = = 1 ) DCNL DCSP assert ( result &#91; ( 0 , 0 ) &#93; = = 12 )
DCSP return ( path if isabs ( path ) else join ( project _ data _ dir ( ) , path ) )
DCSP if ( interface in get _ interfaces ( zone , permanent ) ) : DCNL DCSP DCSP log.info ( &apos; Interface DCSP is DCSP already DCSP bound DCSP to DCSP zone . &apos; ) DCNL DCSP cmd = &apos; --zone = { 0 } DCSP --add-interface = { 1 } &apos; .format ( zone , interface ) DCNL DCSP if permanent : DCNL DCSP DCSP cmd + = &apos; DCSP --permanent &apos; DCNL DCSP return _ _ firewall _ cmd ( cmd )
DCSP is _ dylib = DYLIB _ RE.match ( filename ) DCNL DCSP if ( not is _ dylib ) : DCNL DCSP DCSP return None DCNL DCSP return is _ dylib.groupdict ( )
DCSP function = sum.function DCNL DCSP for l in sum.limits : DCNL DCSP DCSP function = function.subs ( l &#91; 0 &#93; , ( l &#91; ( -1 ) &#93; + 1 ) ) DCNL DCSP return function
DCSP mounts = utils.system _ output ( &apos; mount &apos; ) .splitlines ( ) DCNL DCSP hd _ list = &#91; &#93; DCNL DCSP hd _ regexp = re.compile ( &apos; ( &#91; hsv &#93; d &#91; a-z &#93; + 3 ) $ &apos; ) DCNL DCSP partfile = open ( _ DISKPART _ FILE ) DCNL DCSP for partline in partfile : DCNL DCSP DCSP parts = partline.strip ( ) .split ( ) DCNL DCSP DCSP if ( ( len ( parts ) ! = 4 ) or partline.startswith ( &apos; major &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP partname = parts &#91; 3 &#93; DCNL DCSP DCSP if ( not get _ all _ disks ) : DCNL DCSP DCSP DCSP if ( not partname &#91; ( -1 ) : &#93; .isdigit ( ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not fd _ mgr.use _ partition ( partname ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP tunepath = fd _ mgr.map _ drive _ name ( partname ) DCNL DCSP DCSP mstat = 0 DCNL DCSP DCSP fstype = &apos; &apos; DCNL DCSP DCSP fsopts = &apos; &apos; DCNL DCSP DCSP fsmkfs = &apos; ? &apos; DCNL DCSP DCSP chkdev = ( &apos; / dev / &apos; + partname ) DCNL DCSP DCSP mountpt = None DCNL DCSP DCSP for mln in mounts : DCNL DCSP DCSP DCSP splt = mln.split ( ) DCNL DCSP DCSP DCSP if ( splt &#91; 0 &#93; .strip ( ) = = chkdev.strip ( ) ) : DCNL DCSP DCSP DCSP DCSP mountpt = fd _ mgr.check _ mount _ point ( partname , splt &#91; 2 &#93; ) DCNL DCSP DCSP DCSP DCSP if ( not mountpt ) : DCNL DCSP DCSP DCSP DCSP DCSP mstat = ( -1 ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP fstype = splt &#91; 4 &#93; DCNL DCSP DCSP DCSP DCSP fsopts = splt &#91; 5 &#93; DCNL DCSP DCSP DCSP DCSP if ( fsopts &#91; : 3 &#93; ! = &apos; ( rw &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP mstat = ( -1 ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP mstat = 1 DCNL DCSP DCSP if ( std _ mounts _ only and ( mstat &lt; 0 ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not get _ all _ disks ) : DCNL DCSP DCSP DCSP if ( not mountpt ) : DCNL DCSP DCSP DCSP DCSP mountpt = fd _ mgr.check _ mount _ point ( partname , None ) DCNL DCSP DCSP DCSP DCSP if ( not mountpt ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP hd _ list.append ( { &apos; device &apos; : partname , &apos; mountpt &apos; : mountpt , &apos; tunable &apos; : tunepath , &apos; fs _ type &apos; : fstype , &apos; fs _ opts &apos; : fsopts , &apos; fs _ mkfs &apos; : fsmkfs , &apos; mounted &apos; : mstat } ) DCNL DCSP return hd _ list
DCSP if ( Info.version ( ) is None ) : DCNL DCSP DCSP return True DCNL DCSP return False
DCSP cli.register ( &apos; building-command-table.main &apos; , change _ name ) DCNL DCSP cli.register ( &apos; building-command-table.deploy &apos; , inject _ commands ) DCNL DCSP cli.register ( &apos; building-argument-table.deploy.get-application-revision &apos; , modify _ revision _ arguments ) DCNL DCSP cli.register ( &apos; building-argument-table.deploy.register-application-revision &apos; , modify _ revision _ arguments ) DCNL DCSP cli.register ( &apos; building-argument-table.deploy.create-deployment &apos; , modify _ revision _ arguments )
DCSP get _ random _ state ( ) .seed ( seed )
DCSP if ( not hasattr ( settings , &apos; PEP _ REPO _ PATH &apos; ) ) : DCNL DCSP DCSP raise ImproperlyConfigured ( &apos; No DCSP PEP _ REPO _ PATH DCSP in DCSP settings &apos; ) DCNL DCSP if ( not os.path.exists ( settings.PEP _ REPO _ PATH ) ) : DCNL DCSP DCSP raise ImproperlyConfigured ( &apos; PEP _ REPO _ PATH DCSP in DCSP settings DCSP does DCSP not DCSP exist &apos; )
DCSP assert isinstance ( message , text _ type ) DCNL DCSP app = create _ confirm _ application ( message ) DCNL DCSP return run _ application ( app )
DCSP for ( key , value ) in dictionary.iteritems ( ) : DCNL DCSP DCSP if ( element is value ) : DCNL DCSP DCSP DCSP return key
DCSP next _ heartbeat = int ( ( time.time ( ) + 600 ) ) DCNL DCSP while ALIVE : DCNL DCSP DCSP populate _ collectors ( options.cdir ) DCNL DCSP DCSP reload _ changed _ config _ modules ( modules , options , sender , tags ) DCNL DCSP DCSP reap _ children ( ) DCNL DCSP DCSP check _ children ( options ) DCNL DCSP DCSP spawn _ children ( ) DCNL DCSP DCSP time.sleep ( 15 ) DCNL DCSP DCSP now = int ( time.time ( ) ) DCNL DCSP DCSP if ( now &gt; = next _ heartbeat ) : DCNL DCSP DCSP DCSP LOG.info ( ( &apos; Heartbeat DCSP ( % d DCSP collectors DCSP running ) &apos; % sum ( ( 1 for col in all _ living _ collectors ( ) ) ) ) ) DCNL DCSP DCSP DCSP next _ heartbeat = ( now + 600 )
DCSP global _ task DCNL DCSP _ task.stop ( ) DCNL DCSP _ task = None
DCSP if ( x _ discrete and y _ discrete ) : DCNL DCSP DCSP return mutual _ info _ score ( x , y ) DCNL DCSP elif ( x _ discrete and ( not y _ discrete ) ) : DCNL DCSP DCSP return _ compute _ mi _ cd ( y , x , n _ neighbors ) DCNL DCSP elif ( ( not x _ discrete ) and y _ discrete ) : DCNL DCSP DCSP return _ compute _ mi _ cd ( x , y , n _ neighbors ) DCNL DCSP else : DCNL DCSP DCSP return _ compute _ mi _ cc ( x , y , n _ neighbors )
DCSP if ( surfs &#91; 0 &#93; &#91; &apos; np &apos; &#93; &gt; 10000 ) : DCNL DCSP DCSP msg = ( &apos; The DCSP bem DCSP surface DCSP has DCSP % s DCSP data DCSP points . DCSP 5120 DCSP ( ico DCSP grade = 4 ) DCSP should DCSP be DCSP enough . &apos; % surfs &#91; 0 &#93; &#91; &apos; np &apos; &#93; ) DCNL DCSP DCSP if ( len ( surfs ) = = 3 ) : DCNL DCSP DCSP DCSP msg + = &apos; DCSP Dense DCSP 3-layer DCSP bems DCSP may DCSP not DCSP save DCSP properly . &apos; DCNL DCSP DCSP warn ( msg )
DCSP return block.location.name
DCSP stor = Storage ( ) DCNL DCSP for k in ( requireds + tuple ( f.keys ( ) ) ) : DCNL DCSP DCSP v = f &#91; k &#93; DCNL DCSP DCSP if isinstance ( v , list ) : DCNL DCSP DCSP DCSP v = v &#91; ( -1 ) &#93; DCNL DCSP DCSP if hasattr ( v , &apos; value &apos; ) : DCNL DCSP DCSP DCSP v = v.value DCNL DCSP DCSP setattr ( stor , k , v ) DCNL DCSP for ( k , v ) in defaults.iteritems ( ) : DCNL DCSP DCSP result = v DCNL DCSP DCSP if hasattr ( stor , k ) : DCNL DCSP DCSP DCSP result = stor &#91; k &#93; DCNL DCSP DCSP if ( ( v = = ( ) ) and ( not isinstance ( result , tuple ) ) ) : DCNL DCSP DCSP DCSP result = ( result , ) DCNL DCSP DCSP setattr ( stor , k , result ) DCNL DCSP return stor
DCSP if ( ( not session.logged _ in ) and ( &apos; name &apos; in kwargs ) and ( &apos; password &apos; in kwargs ) ) : DCNL DCSP DCSP from evennia.commands.default.unloggedin import create _ normal _ player DCNL DCSP DCSP player = create _ normal _ player ( session , kwargs &#91; &apos; name &apos; &#93; , kwargs &#91; &apos; password &apos; &#93; ) DCNL DCSP DCSP if player : DCNL DCSP DCSP DCSP session.sessionhandler.login ( session , player )
DCSP size = g.size DCNL DCSP g = g.array _ form DCNL DCSP num _ dummies = ( size - 2 ) DCNL DCSP indices = list ( range ( num _ dummies ) ) DCNL DCSP all _ metrics _ with _ sym = all ( &#91; ( _ is not None ) for _ in sym &#93; ) DCNL DCSP num _ types = len ( sym ) DCNL DCSP dumx = dummies &#91; : &#93; DCNL DCSP dumx _ flat = &#91; &#93; DCNL DCSP for dx in dumx : DCNL DCSP DCSP dumx _ flat.extend ( dx ) DCNL DCSP b _ S = b _ S &#91; : &#93; DCNL DCSP sgensx = &#91; h . _ array _ form for h in sgens &#93; DCNL DCSP if b _ S : DCNL DCSP DCSP S _ transversals = transversal2coset ( size , b _ S , S _ transversals ) DCNL DCSP dsgsx = &#91; &#93; DCNL DCSP for i in range ( num _ types ) : DCNL DCSP DCSP dsgsx.extend ( dummy _ sgs ( dumx &#91; i &#93; , sym &#91; i &#93; , num _ dummies ) ) DCNL DCSP ginv = _ af _ invert ( g ) DCNL DCSP idn = list ( range ( size ) ) DCNL DCSP TAB = &#91; ( idn , idn , g ) &#93; DCNL DCSP for i in range ( ( size - 2 ) ) : DCNL DCSP DCSP b = i DCNL DCSP DCSP testb = ( ( b in b _ S ) and sgensx ) DCNL DCSP DCSP if testb : DCNL DCSP DCSP DCSP sgensx1 = &#91; _ af _ new ( _ ) for _ in sgensx &#93; DCNL DCSP DCSP DCSP deltab = _ orbit ( size , sgensx1 , b ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP deltab = { b } DCNL DCSP DCSP if all _ metrics _ with _ sym : DCNL DCSP DCSP DCSP md = _ min _ dummies ( dumx , sym , indices ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP md = &#91; min ( _ orbit ( size , &#91; _ af _ new ( ddx ) for ddx in dsgsx &#93; , ii ) ) for ii in range ( ( size - 2 ) ) &#93; DCNL DCSP DCSP p _ i = min ( &#91; min ( &#91; md &#91; h &#91; x &#93; &#93; for x in deltab &#93; ) for ( s , d , h ) in TAB &#93; ) DCNL DCSP DCSP dsgsx1 = &#91; _ af _ new ( _ ) for _ in dsgsx &#93; DCNL DCSP DCSP Dxtrav = ( _ orbit _ transversal ( size , dsgsx1 , p _ i , False , af = True ) if dsgsx else None ) DCNL DCSP DCSP if Dxtrav : DCNL DCSP DCSP DCSP Dxtrav = &#91; _ af _ invert ( x ) for x in Dxtrav &#93; DCNL DCSP DCSP for ii in range ( num _ types ) : DCNL DCSP DCSP DCSP if ( p _ i in dumx &#91; ii &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( sym &#91; ii &#93; is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP deltap = dumx &#91; ii &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP p _ i _ index = ( dumx &#91; ii &#93; .index ( p _ i ) % 2 ) DCNL DCSP DCSP DCSP DCSP DCSP deltap = dumx &#91; ii &#93; &#91; p _ i _ index : : 2 &#93; DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP deltap = &#91; p _ i &#93; DCNL DCSP DCSP TAB1 = &#91; &#93; DCNL DCSP DCSP nTAB = len ( TAB ) DCNL DCSP DCSP while TAB : DCNL DCSP DCSP DCSP ( s , d , h ) = TAB.pop ( ) DCNL DCSP DCSP DCSP if ( min ( &#91; md &#91; h &#91; x &#93; &#93; for x in deltab &#93; ) ! = p _ i ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP deltab1 = &#91; x for x in deltab if ( md &#91; h &#91; x &#93; &#93; = = p _ i ) &#93; DCNL DCSP DCSP DCSP dg = _ af _ rmul ( d , g ) DCNL DCSP DCSP DCSP dginv = _ af _ invert ( dg ) DCNL DCSP DCSP DCSP sdeltab = &#91; s &#91; x &#93; for x in deltab1 &#93; DCNL DCSP DCSP DCSP gdeltap = &#91; dginv &#91; x &#93; for x in deltap &#93; DCNL DCSP DCSP DCSP NEXT = &#91; x for x in sdeltab if ( x in gdeltap ) &#93; DCNL DCSP DCSP DCSP for j in NEXT : DCNL DCSP DCSP DCSP DCSP if testb : DCNL DCSP DCSP DCSP DCSP DCSP s1 = _ trace _ S ( s , j , b , S _ transversals ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not s1 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP s1 = &#91; s &#91; ix &#93; for ix in s1 &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP s1 = s DCNL DCSP DCSP DCSP DCSP if Dxtrav : DCNL DCSP DCSP DCSP DCSP DCSP d1 = _ trace _ D ( dg &#91; j &#93; , p _ i , Dxtrav ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not d1 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP if ( p _ i ! = dg &#91; j &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP d1 = idn DCNL DCSP DCSP DCSP DCSP assert ( d1 &#91; dg &#91; j &#93; &#93; = = p _ i ) DCNL DCSP DCSP DCSP DCSP d1 = &#91; d1 &#91; ix &#93; for ix in d &#93; DCNL DCSP DCSP DCSP DCSP h1 = &#91; d1 &#91; g &#91; ix &#93; &#93; for ix in s1 &#93; DCNL DCSP DCSP DCSP DCSP TAB1.append ( ( s1 , d1 , h1 ) ) DCNL DCSP DCSP TAB1.sort ( key = ( lambda x : x &#91; ( -1 ) &#93; ) ) DCNL DCSP DCSP nTAB1 = len ( TAB1 ) DCNL DCSP DCSP prev = ( &#91; 0 &#93; * size ) DCNL DCSP DCSP while TAB1 : DCNL DCSP DCSP DCSP ( s , d , h ) = TAB1.pop ( ) DCNL DCSP DCSP DCSP if ( h &#91; : ( -2 ) &#93; = = prev &#91; : ( -2 ) &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( h &#91; ( -1 ) &#93; ! = prev &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP return 0 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP TAB.append ( ( s , d , h ) ) DCNL DCSP DCSP DCSP prev = h DCNL DCSP DCSP sgensx = &#91; h for h in sgensx if ( h &#91; b &#93; = = b ) &#93; DCNL DCSP DCSP if ( b in b _ S ) : DCNL DCSP DCSP DCSP b _ S.remove ( b ) DCNL DCSP DCSP _ dumx _ remove ( dumx , dumx _ flat , p _ i ) DCNL DCSP DCSP dsgsx = &#91; &#93; DCNL DCSP DCSP for i in range ( num _ types ) : DCNL DCSP DCSP DCSP dsgsx.extend ( dummy _ sgs ( dumx &#91; i &#93; , sym &#91; i &#93; , num _ dummies ) ) DCNL DCSP return TAB &#91; 0 &#93; &#91; ( -1 ) &#93;
DCSP logger = logging.getLogger ( ) DCNL DCSP logger.setLevel ( logging.NOTSET ) DCNL DCSP for handler in logger.handlers &#91; : &#93; : DCNL DCSP DCSP logger.removeHandler ( handler ) DCNL DCSP info _ handler = NewLineStreamHandler ( SafeEncodingWriter ( status ) ) DCNL DCSP info _ handler.addFilter ( InfoFilter ( ) ) DCNL DCSP info _ handler.setLevel ( VERBOSITY _ MAP &#91; app.verbosity &#93; ) DCNL DCSP info _ handler.setFormatter ( ColorizeFormatter ( ) ) DCNL DCSP warning _ handler = WarningStreamHandler ( SafeEncodingWriter ( warning ) ) DCNL DCSP warning _ handler.addFilter ( WarningSuppressor ( app ) ) DCNL DCSP warning _ handler.addFilter ( WarningIsErrorFilter ( app ) ) DCNL DCSP warning _ handler.addFilter ( WarningLogRecordTranslator ( app ) ) DCNL DCSP warning _ handler.setLevel ( logging.WARNING ) DCNL DCSP warning _ handler.setFormatter ( ColorizeFormatter ( ) ) DCNL DCSP logger.addHandler ( info _ handler ) DCNL DCSP logger.addHandler ( warning _ handler )
DCSP version = Version.objects.get ( pk = version _ pk ) DCNL DCSP if html : DCNL DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = version.project.documentation _ type ) DCNL DCSP DCSP target = version.project.rtd _ build _ path ( version.slug ) DCNL DCSP DCSP Syncer.copy ( from _ path , target , host = hostname ) DCNL DCSP if ( &apos; sphinx &apos; in version.project.documentation _ type ) : DCNL DCSP DCSP if localmedia : DCNL DCSP DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = &apos; sphinx _ localmedia &apos; ) DCNL DCSP DCSP DCSP to _ path = version.project.get _ production _ media _ path ( type _ = &apos; htmlzip &apos; , version _ slug = version.slug , include _ file = False ) DCNL DCSP DCSP DCSP Syncer.copy ( from _ path , to _ path , host = hostname ) DCNL DCSP DCSP if search : DCNL DCSP DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = &apos; sphinx _ search &apos; ) DCNL DCSP DCSP DCSP to _ path = version.project.get _ production _ media _ path ( type _ = &apos; json &apos; , version _ slug = version.slug , include _ file = False ) DCNL DCSP DCSP DCSP Syncer.copy ( from _ path , to _ path , host = hostname ) DCNL DCSP DCSP if pdf : DCNL DCSP DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = &apos; sphinx _ pdf &apos; ) DCNL DCSP DCSP DCSP to _ path = version.project.get _ production _ media _ path ( type _ = &apos; pdf &apos; , version _ slug = version.slug , include _ file = False ) DCNL DCSP DCSP DCSP Syncer.copy ( from _ path , to _ path , host = hostname ) DCNL DCSP DCSP if epub : DCNL DCSP DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = &apos; sphinx _ epub &apos; ) DCNL DCSP DCSP DCSP to _ path = version.project.get _ production _ media _ path ( type _ = &apos; epub &apos; , version _ slug = version.slug , include _ file = False ) DCNL DCSP DCSP DCSP Syncer.copy ( from _ path , to _ path , host = hostname ) DCNL DCSP if ( &apos; mkdocs &apos; in version.project.documentation _ type ) : DCNL DCSP DCSP if search : DCNL DCSP DCSP DCSP from _ path = version.project.artifact _ path ( version = version.slug , type _ = &apos; mkdocs _ json &apos; ) DCNL DCSP DCSP DCSP to _ path = version.project.get _ production _ media _ path ( type _ = &apos; json &apos; , version _ slug = version.slug , include _ file = False ) DCNL DCSP DCSP DCSP Syncer.copy ( from _ path , to _ path , host = hostname )
DCSP password _ hash = ( md5 ( user.password ) if user.password else None ) DCNL DCSP data = &#91; str ( user.id ) , password _ hash &#93; DCNL DCSP return _ security.reset _ serializer.dumps ( data )
DCSP rgbtuple = _ namedict.get ( color ) DCNL DCSP if ( rgbtuple is None ) : DCNL DCSP DCSP if ( color &#91; 0 &#93; ! = &apos; # &apos; ) : DCNL DCSP DCSP DCSP raise BadColor ( color ) DCNL DCSP DCSP red = color &#91; 1 : 3 &#93; DCNL DCSP DCSP green = color &#91; 3 : 5 &#93; DCNL DCSP DCSP blue = color &#91; 5 : 7 &#93; DCNL DCSP DCSP rgbtuple = ( int ( red , 16 ) , int ( green , 16 ) , int ( blue , 16 ) ) DCNL DCSP DCSP _ namedict &#91; color &#93; = rgbtuple DCNL DCSP return rgbtuple
DCSP if ( not trigger.group ( 2 ) ) : DCNL DCSP DCSP return bot.reply ( u &apos;No DCSP query DCSP term . &apos; ) DCNL DCSP query = trigger.group ( 2 ) DCNL DCSP uri = u &apos;http : / / websitedev.de / temp-bin / suggest.pl ? q = &apos; DCNL DCSP answer = web.get ( ( uri + query.replace ( u &apos; + &apos; , u &apos; % 2B &apos; ) ) ) DCNL DCSP if answer : DCNL DCSP DCSP bot.say ( answer ) DCNL DCSP else : DCNL DCSP DCSP bot.reply ( u &apos;Sorry , DCSP no DCSP result . &apos; )
DCSP _ assign _ role ( committer _ id , assignee _ id , new _ role , exploration _ id , feconf.ACTIVITY _ TYPE _ EXPLORATION ) DCNL DCSP if ( new _ role in &#91; ROLE _ OWNER , ROLE _ EDITOR &#93; ) : DCNL DCSP DCSP subscription _ services.subscribe _ to _ exploration ( assignee _ id , exploration _ id )
DCSP executor = None DCNL DCSP def shutting _ down ( ) : DCNL DCSP DCSP return ( _ shutdown or ( executor is None ) or executor . _ shutdown _ thread ) DCNL DCSP def shutdown _ worker ( ) : DCNL DCSP DCSP nb _ children _ alive = sum ( ( p.is _ alive ( ) for p in processes.values ( ) ) ) DCNL DCSP DCSP for i in range ( 0 , nb _ children _ alive ) : DCNL DCSP DCSP DCSP call _ queue.put _ nowait ( None ) DCNL DCSP DCSP call _ queue.close ( ) DCNL DCSP DCSP for p in processes.values ( ) : DCNL DCSP DCSP DCSP p.join ( ) DCNL DCSP reader = result _ queue . _ reader DCNL DCSP while True : DCNL DCSP DCSP _ add _ call _ item _ to _ queue ( pending _ work _ items , work _ ids _ queue , call _ queue ) DCNL DCSP DCSP sentinels = &#91; p.sentinel for p in processes.values ( ) &#93; DCNL DCSP DCSP assert sentinels DCNL DCSP DCSP ready = wait ( ( &#91; reader &#93; + sentinels ) ) DCNL DCSP DCSP if ( reader in ready ) : DCNL DCSP DCSP DCSP result _ item = reader.recv ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP executor = executor _ reference ( ) DCNL DCSP DCSP DCSP if ( executor is not None ) : DCNL DCSP DCSP DCSP DCSP executor . _ broken = True DCNL DCSP DCSP DCSP DCSP executor . _ shutdown _ thread = True DCNL DCSP DCSP DCSP DCSP executor = None DCNL DCSP DCSP DCSP for ( work _ id , work _ item ) in pending _ work _ items.items ( ) : DCNL DCSP DCSP DCSP DCSP work _ item.future.set _ exception ( BrokenProcessPool ( &apos; A DCSP process DCSP in DCSP the DCSP process DCSP pool DCSP was DCSP terminated DCSP abruptly DCSP while DCSP the DCSP future DCSP was DCSP running DCSP or DCSP pending . &apos; ) ) DCNL DCSP DCSP DCSP DCSP del work _ item DCNL DCSP DCSP DCSP pending _ work _ items.clear ( ) DCNL DCSP DCSP DCSP for p in processes.values ( ) : DCNL DCSP DCSP DCSP DCSP p.terminate ( ) DCNL DCSP DCSP DCSP shutdown _ worker ( ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if isinstance ( result _ item , int ) : DCNL DCSP DCSP DCSP assert shutting _ down ( ) DCNL DCSP DCSP DCSP p = processes.pop ( result _ item ) DCNL DCSP DCSP DCSP p.join ( ) DCNL DCSP DCSP DCSP if ( not processes ) : DCNL DCSP DCSP DCSP DCSP shutdown _ worker ( ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP elif ( result _ item is not None ) : DCNL DCSP DCSP DCSP work _ item = pending _ work _ items.pop ( result _ item.work _ id , None ) DCNL DCSP DCSP DCSP if ( work _ item is not None ) : DCNL DCSP DCSP DCSP DCSP if result _ item.exception : DCNL DCSP DCSP DCSP DCSP DCSP work _ item.future.set _ exception ( result _ item.exception ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP work _ item.future.set _ result ( result _ item.result ) DCNL DCSP DCSP DCSP DCSP del work _ item DCNL DCSP DCSP executor = executor _ reference ( ) DCNL DCSP DCSP if shutting _ down ( ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( not pending _ work _ items ) : DCNL DCSP DCSP DCSP DCSP DCSP shutdown _ worker ( ) DCNL DCSP DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP except Full : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP executor = None
DCSP print ( s.ljust ( 20 ) , end = &apos; DCSP &apos; ) DCNL DCSP res = func ( * args , * * kwargs ) DCNL DCSP if ( correct is not None ) : DCNL DCSP DCSP assert np.allclose ( res , correct ) , ( res , correct ) DCNL DCSP print ( &apos; { : &gt; 5.0f } DCSP ms &apos; .format ( ( min ( repeat ( ( lambda : func ( * args , * * kwargs ) ) , number = 5 , repeat = 2 ) ) * 1000 ) ) ) DCNL DCSP return res
DCSP from nltk import Tree , ProbabilisticTree DCNL DCSP s = u &apos; ( S DCSP ( NP DCSP ( DT DCSP the ) DCSP ( NN DCSP cat ) ) DCSP ( VP DCSP ( VBD DCSP ate ) DCSP ( NP DCSP ( DT DCSP a ) DCSP ( NN DCSP cookie ) ) ) ) &apos; DCNL DCSP t = Tree.fromstring ( s ) DCNL DCSP print ( u &apos;Convert DCSP bracketed DCSP string DCSP into DCSP tree : &apos; ) DCNL DCSP print ( t ) DCNL DCSP print ( t . _ _ repr _ _ ( ) ) DCNL DCSP print ( u &apos;Display DCSP tree DCSP properties : &apos; ) DCNL DCSP print ( t.label ( ) ) DCNL DCSP print ( t &#91; 0 &#93; ) DCNL DCSP print ( t &#91; 1 &#93; ) DCNL DCSP print ( t.height ( ) ) DCNL DCSP print ( t.leaves ( ) ) DCNL DCSP print ( t &#91; 1 &#93; ) DCNL DCSP print ( t &#91; ( 1 , 1 ) &#93; ) DCNL DCSP print ( t &#91; ( 1 , 1 , 0 ) &#93; ) DCNL DCSP the _ cat = t &#91; 0 &#93; DCNL DCSP the _ cat.insert ( 1 , Tree.fromstring ( u &apos; ( JJ DCSP big ) &apos; ) ) DCNL DCSP print ( u &apos;Tree DCSP modification : &apos; ) DCNL DCSP print ( t ) DCNL DCSP t &#91; ( 1 , 1 , 1 ) &#93; = Tree.fromstring ( u &apos; ( NN DCSP cake ) &apos; ) DCNL DCSP print ( t ) DCNL DCSP print ( ) DCNL DCSP print ( u &apos;Collapse DCSP unary : &apos; ) DCNL DCSP t.collapse _ unary ( ) DCNL DCSP print ( t ) DCNL DCSP print ( u &apos;Chomsky DCSP normal DCSP form : &apos; ) DCNL DCSP t.chomsky _ normal _ form ( ) DCNL DCSP print ( t ) DCNL DCSP print ( ) DCNL DCSP pt = ProbabilisticTree ( u &apos;x &apos; , &#91; u &apos;y &apos; , u &apos;z &apos; &#93; , prob = 0.5 ) DCNL DCSP print ( u &apos;Probabilistic DCSP Tree : &apos; ) DCNL DCSP print ( pt ) DCNL DCSP print ( ) DCNL DCSP t = Tree.fromstring ( t.pformat ( ) ) DCNL DCSP print ( u &apos;Convert DCSP tree DCSP to DCSP bracketed DCSP string DCSP and DCSP back DCSP again : &apos; ) DCNL DCSP print ( t ) DCNL DCSP print ( ) DCNL DCSP print ( u &apos;LaTeX DCSP output : &apos; ) DCNL DCSP print ( t.pformat _ latex _ qtree ( ) ) DCNL DCSP print ( ) DCNL DCSP print ( u &apos;Production DCSP output : &apos; ) DCNL DCSP print ( t.productions ( ) ) DCNL DCSP print ( ) DCNL DCSP t.set _ label ( ( u &apos;test &apos; , 3 ) ) DCNL DCSP print ( t )
DCSP if ( node.op ! = T.mul ) : DCNL DCSP DCSP return False DCNL DCSP for ( idx , i ) in enumerate ( node.inputs ) : DCNL DCSP DCSP if ( i.owner and ( i.owner.op = = T.switch ) ) : DCNL DCSP DCSP DCSP switch = i.owner DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( get _ scalar _ constant _ value ( switch.inputs &#91; 1 &#93; , only _ process _ constants = True ) = = 0.0 ) : DCNL DCSP DCSP DCSP DCSP DCSP listmul = ( node.inputs &#91; : idx &#93; + node.inputs &#91; ( idx + 1 ) : &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP fmul = T.mul ( * ( listmul + &#91; switch.inputs &#91; 2 &#93; &#93; ) ) DCNL DCSP DCSP DCSP DCSP DCSP copy _ stack _ trace ( node.outputs , fmul ) DCNL DCSP DCSP DCSP DCSP DCSP fct = &#91; T.switch ( switch.inputs &#91; 0 &#93; , 0 , fmul ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP fct &#91; 0 &#93; .tag.values _ eq _ approx = values _ eq _ approx _ remove _ nan DCNL DCSP DCSP DCSP DCSP DCSP copy _ stack _ trace ( ( node.outputs + switch.outputs ) , fct ) DCNL DCSP DCSP DCSP DCSP DCSP return fct DCNL DCSP DCSP DCSP except NotScalarConstantError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( get _ scalar _ constant _ value ( switch.inputs &#91; 2 &#93; , only _ process _ constants = True ) = = 0.0 ) : DCNL DCSP DCSP DCSP DCSP DCSP listmul = ( node.inputs &#91; : idx &#93; + node.inputs &#91; ( idx + 1 ) : &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP fmul = T.mul ( * ( listmul + &#91; switch.inputs &#91; 1 &#93; &#93; ) ) DCNL DCSP DCSP DCSP DCSP DCSP copy _ stack _ trace ( node.outputs , fmul ) DCNL DCSP DCSP DCSP DCSP DCSP fct = &#91; T.switch ( switch.inputs &#91; 0 &#93; , fmul , 0 ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP fct &#91; 0 &#93; .tag.values _ eq _ approx = values _ eq _ approx _ remove _ nan DCNL DCSP DCSP DCSP DCSP DCSP copy _ stack _ trace ( ( node.outputs + switch.outputs ) , fct ) DCNL DCSP DCSP DCSP DCSP DCSP return fct DCNL DCSP DCSP DCSP except NotScalarConstantError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP return False
DCSP query = ( ( FS ( &apos; followup _ date &apos; ) &lt; = datetime.datetime.utcnow ( ) .date ( ) ) &amp; ( FS ( &apos; completed &apos; ) ! = True ) ) DCNL DCSP resource = current.s3db.resource ( &apos; po _ household _ followup &apos; , filter = query ) DCNL DCSP return resource.count ( )
DCSP return _ strips ( &apos; l &apos; , text , remove )
DCSP repository = getNewRepository ( ) DCNL DCSP repository.fileNameInput.value = fileName DCNL DCSP settings.startMainLoopFromWindow ( repository.execute ( ) )
DCSP real _ dst = dst DCNL DCSP if os.path.isdir ( dst ) : DCNL DCSP DCSP if _ samefile ( src , dst ) : DCNL DCSP DCSP DCSP os.rename ( src , dst ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP real _ dst = os.path.join ( dst , _ basename ( src ) ) DCNL DCSP DCSP if os.path.exists ( real _ dst ) : DCNL DCSP DCSP DCSP raise Error , ( &quot; Destination DCSP path DCSP &apos; % s &apos; DCSP already DCSP exists &quot; % real _ dst ) DCNL DCSP try : DCNL DCSP DCSP os.rename ( src , real _ dst ) DCNL DCSP except OSError : DCNL DCSP DCSP if os.path.isdir ( src ) : DCNL DCSP DCSP DCSP if _ destinsrc ( src , dst ) : DCNL DCSP DCSP DCSP DCSP raise Error , ( &quot; Cannot DCSP move DCSP a DCSP directory DCSP &apos; % s &apos; DCSP into DCSP itself DCSP &apos; % s &apos; . &quot; % ( src , dst ) ) DCNL DCSP DCSP DCSP copytree ( src , real _ dst , symlinks = True ) DCNL DCSP DCSP DCSP rmtree ( src ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP copy2 ( src , real _ dst ) DCNL DCSP DCSP DCSP os.unlink ( src )
DCSP if ( iri is None ) : DCNL DCSP DCSP return iri DCNL DCSP return quote ( force _ bytes ( iri ) , safe = &quot; / # % &#91; &#93; = : ; $ &amp; ( ) + , ! ? * @ &apos; ~ &quot; )
DCSP pypi = current _ version DCNL DCSP try : DCNL DCSP DCSP pypi = available _ on _ pypi ( prerelease ) DCNL DCSP except Exception : DCNL DCSP DCSP log.warning ( &apos; An DCSP issue DCSP occurred DCSP while DCSP checking DCSP PyPI &apos; ) DCNL DCSP best = max ( pypi , current _ version ) DCNL DCSP where = None DCNL DCSP command = None DCNL DCSP cache = cache _ file ( ) DCNL DCSP if cache : DCNL DCSP DCSP os.utime ( cache , None ) DCNL DCSP if ( best = = current _ version ) : DCNL DCSP DCSP log.info ( ( &apos; You DCSP have DCSP the DCSP latest DCSP version DCSP of DCSP Pwntools DCSP ( % s ) &apos; % best ) ) DCNL DCSP DCSP return DCNL DCSP command = &#91; &apos; pip &apos; , &apos; install &apos; , &apos; -U &apos; &#93; DCNL DCSP if ( best = = pypi ) : DCNL DCSP DCSP where = &apos; pypi &apos; DCNL DCSP DCSP pypi _ package = package _ name DCNL DCSP DCSP if best.is _ prerelease : DCNL DCSP DCSP DCSP pypi _ package + = ( &apos; = = % s &apos; % best ) DCNL DCSP DCSP command + = &#91; pypi _ package &#93; DCNL DCSP command _ str = &apos; DCSP &apos; .join ( command ) DCNL DCSP log.info ( ( ( &apos; A DCSP newer DCSP version DCSP of DCSP % s DCSP is DCSP available DCSP on DCSP % s DCSP ( % s DCSP -- &gt; DCSP % s ) . \ n &apos; % ( package _ name , where , current _ version , best ) ) + ( &apos; Update DCSP with : DCSP $ DCSP % s &apos; % command _ str ) ) ) DCNL DCSP return command
DCSP try : DCNL DCSP DCSP reg = request.registry DCNL DCSP except AttributeError : DCNL DCSP DCSP reg = get _ current _ registry ( ) DCNL DCSP url _ adapter = reg.queryMultiAdapter ( ( resource , request ) , IResourceURL ) DCNL DCSP if ( url _ adapter is None ) : DCNL DCSP DCSP url _ adapter = ResourceURL ( resource , request ) DCNL DCSP ( vpath , rpath ) = ( url _ adapter.virtual _ path , url _ adapter.physical _ path ) DCNL DCSP if ( ( rpath ! = vpath ) and rpath.endswith ( vpath ) ) : DCNL DCSP DCSP vroot _ path = rpath &#91; : ( - len ( vpath ) ) &#93; DCNL DCSP DCSP return find _ resource ( resource , vroot _ path ) DCNL DCSP try : DCNL DCSP DCSP return request.root DCNL DCSP except AttributeError : DCNL DCSP DCSP return find _ root ( resource )
DCSP ret = &apos; &apos; DCNL DCSP try : DCNL DCSP DCSP with salt.utils.fopen ( conf _ path , &apos; r &apos; ) as fp _ : DCNL DCSP DCSP DCSP for line in fp _ : DCNL DCSP DCSP DCSP DCSP ret + = line DCNL DCSP except IOError as exc : DCNL DCSP DCSP if ( exc.errno = = errno.ENOENT ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; { 0 } DCSP does DCSP not DCSP exist &apos; .format ( conf _ path ) ) DCNL DCSP DCSP elif ( exc.errno = = errno.EACCES ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; Unable DCSP to DCSP read DCSP { 0 } , DCSP access DCSP denied &apos; .format ( conf _ path ) ) DCNL DCSP DCSP elif ( exc.errno = = errno.EISDIR ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; Unable DCSP to DCSP read DCSP { 0 } , DCSP path DCSP is DCSP a DCSP directory &apos; .format ( conf _ path ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; Error DCSP { 0 } : DCSP { 1 } &apos; .format ( exc.errno , exc.strerror ) ) DCNL DCSP else : DCNL DCSP DCSP return ret
DCSP return int ( ( time.time ( ) * scale ) )
DCSP if ( not isinstance ( key , ( list , tuple ) ) ) : DCNL DCSP DCSP key = &#91; key &#93; DCNL DCSP return &#91; table.columns &#91; name &#93; for name in key &#93;
DCSP _ NO _ DEFAULT.check ( interfaceIndex ) DCNL DCSP _ NO _ DEFAULT.check ( name ) DCNL DCSP _ NO _ DEFAULT.check ( regtype ) DCNL DCSP _ NO _ DEFAULT.check ( domain ) DCNL DCSP @ _ DNSServiceResolveReply DCNL DCSP def _ callback ( sdRef , flags , interfaceIndex , errorCode , fullname , hosttarget , port , txtLen , txtRecord , context ) : DCNL DCSP DCSP if ( callBack is not None ) : DCNL DCSP DCSP DCSP port = socket.ntohs ( port ) DCNL DCSP DCSP DCSP txtRecord = _ length _ and _ void _ p _ to _ string ( txtLen , txtRecord ) DCNL DCSP DCSP DCSP callBack ( sdRef , flags , interfaceIndex , errorCode , fullname.decode ( ) , hosttarget.decode ( ) , port , txtRecord ) DCNL DCSP _ global _ lock.acquire ( ) DCNL DCSP try : DCNL DCSP DCSP sdRef = _ DNSServiceResolve ( flags , interfaceIndex , name , regtype , domain , _ callback , None ) DCNL DCSP finally : DCNL DCSP DCSP _ global _ lock.release ( ) DCNL DCSP sdRef . _ add _ callback ( _ callback ) DCNL DCSP return sdRef
DCSP import regutil , string DCNL DCSP if ( not packageName ) : DCNL DCSP DCSP raise error ( &apos; A DCSP package DCSP name DCSP must DCSP be DCSP supplied &apos; ) DCNL DCSP corePaths = regutil.GetRegisteredNamedPath ( None ) .split ( &apos; ; &apos; ) DCNL DCSP if ( not searchPaths ) : DCNL DCSP DCSP searchPaths = corePaths DCNL DCSP registryAppName = ( registryAppName or packageName ) DCNL DCSP try : DCNL DCSP DCSP ( pathLook , pathAdd ) = FindPackagePath ( packageName , knownFile , searchPaths ) DCNL DCSP DCSP if ( pathAdd is not None ) : DCNL DCSP DCSP DCSP if ( pathAdd in corePaths ) : DCNL DCSP DCSP DCSP DCSP pathAdd = &apos; &apos; DCNL DCSP DCSP DCSP regutil.RegisterNamedPath ( registryAppName , pathAdd ) DCNL DCSP DCSP return pathLook DCNL DCSP except error as details : DCNL DCSP DCSP print ( &apos; * * * DCSP The DCSP % s DCSP package DCSP could DCSP not DCSP be DCSP registered DCSP - DCSP % s &apos; % ( packageName , details ) ) DCNL DCSP DCSP print &apos; * * * DCSP Please DCSP ensure DCSP you DCSP have DCSP passed DCSP the DCSP correct DCSP paths DCSP on DCSP the DCSP command DCSP line . &apos; DCNL DCSP DCSP print &apos; * * * DCSP - DCSP For DCSP packages , DCSP you DCSP should DCSP pass DCSP a DCSP path DCSP to DCSP the DCSP packages DCSP parent DCSP directory , &apos; DCNL DCSP DCSP print &apos; * * * DCSP - DCSP and DCSP not DCSP the DCSP package DCSP directory DCSP itself ... &apos;
DCSP return _ osquery _ cmd ( table = &apos; kernel _ info &apos; , attrs = attrs , where = where )
DCSP return { &apos; geometry &apos; : geometry , &apos; atoms &apos; : atoms }
DCSP tax _ rules = TaxRule.objects.may _ match _ postal _ code ( taxing _ context.postal _ code ) .filter ( enabled = True , tax _ classes = tax _ class ) DCNL DCSP if taxing _ context.customer _ tax _ group : DCNL DCSP DCSP tax _ rules = tax _ rules.filter ( ( Q ( customer _ tax _ groups = taxing _ context.customer _ tax _ group ) &#124; Q ( customer _ tax _ groups = None ) ) ) DCNL DCSP tax _ rules = tax _ rules.order _ by ( &apos; -override _ group &apos; , &apos; priority &apos; ) DCNL DCSP return tax _ rules
DCSP values = ( 1.0 / ( 1.0 + np.arange ( ( ( 2 * n ) - 1 ) ) ) ) DCNL DCSP h = hankel ( values &#91; : n &#93; , r = values &#91; ( n - 1 ) : &#93; ) DCNL DCSP return h
DCSP return float ( sum ( iterable ) )
DCSP ( writer , outf ) = outf _ writer _ compat ( outfile , encoding , errors , gzip _ compress ) DCNL DCSP header = get _ header _ field _ list ( main _ fields , entity _ type , entity _ fields ) DCNL DCSP writer.writerow ( header ) DCNL DCSP for line in tweets _ file : DCNL DCSP DCSP tweet = json.loads ( line ) DCNL DCSP DCSP if _ is _ composed _ key ( entity _ type ) : DCNL DCSP DCSP DCSP ( key , value ) = _ get _ key _ value _ composed ( entity _ type ) DCNL DCSP DCSP DCSP object _ json = _ get _ entity _ recursive ( tweet , key ) DCNL DCSP DCSP DCSP if ( not object _ json ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP object _ fields = extract _ fields ( object _ json , main _ fields ) DCNL DCSP DCSP DCSP items = _ get _ entity _ recursive ( object _ json , value ) DCNL DCSP DCSP DCSP _ write _ to _ file ( object _ fields , items , entity _ fields , writer ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP tweet _ fields = extract _ fields ( tweet , main _ fields ) DCNL DCSP DCSP DCSP items = _ get _ entity _ recursive ( tweet , entity _ type ) DCNL DCSP DCSP DCSP _ write _ to _ file ( tweet _ fields , items , entity _ fields , writer ) DCNL DCSP outf.close ( )
DCSP return IMPL.quota _ allocated _ update ( context , project _ id , resource , allocated )
DCSP max = kwargs.pop ( &apos; max &apos; , None ) DCNL DCSP config = _ GetConfigFromKwargs ( kwargs ) DCNL DCSP if ( getattr ( config , &apos; read _ policy &apos; , None ) = = EVENTUAL _ CONSISTENCY ) : DCNL DCSP DCSP raise datastore _ errors.BadRequestError ( &apos; read _ policy DCSP is DCSP only DCSP supported DCSP on DCSP read DCSP operations . &apos; ) DCNL DCSP ( keys , _ ) = NormalizeAndTypeCheckKeys ( model _ key ) DCNL DCSP if ( len ( keys ) &gt; 1 ) : DCNL DCSP DCSP raise datastore _ errors.BadArgumentError ( &apos; Cannot DCSP allocate DCSP IDs DCSP for DCSP more DCSP than DCSP one DCSP model DCSP key DCSP at DCSP a DCSP time &apos; ) DCNL DCSP rpc = _ GetConnection ( ) .async _ allocate _ ids ( config , keys &#91; 0 &#93; , size , max ) DCNL DCSP return rpc
DCSP ( payload , symtab , radix , count ) = _ filterargs ( source ) DCNL DCSP if ( count ! = len ( symtab ) ) : DCNL DCSP DCSP raise UnpackingError ( &apos; Malformed DCSP p.a.c.k.e.r. DCSP symtab . &apos; ) DCNL DCSP try : DCNL DCSP DCSP unbase = Unbaser ( radix ) DCNL DCSP except TypeError : DCNL DCSP DCSP raise UnpackingError ( &apos; Unknown DCSP p.a.c.k.e.r. DCSP encoding . &apos; ) DCNL DCSP def lookup ( match ) : DCNL DCSP DCSP &apos; Look DCSP up DCSP symbols DCSP in DCSP the DCSP synthetic DCSP symtab . &apos; DCNL DCSP DCSP word = match.group ( 0 ) DCNL DCSP DCSP return ( symtab &#91; unbase ( word ) &#93; or word ) DCNL DCSP source = re.sub ( &apos; \ \ b \ \ w + \ \ b &apos; , lookup , payload ) DCNL DCSP return _ replacestrings ( source )
DCSP orig = msg.get _ payload ( decode = True ) DCNL DCSP encdata = _ qencode ( orig ) DCNL DCSP msg.set _ payload ( encdata ) DCNL DCSP msg &#91; &apos; Content-Transfer-Encoding &apos; &#93; = &apos; quoted-printable&apos;
DCSP def println ( value ) : DCNL DCSP DCSP u &apos;Write DCSP a DCSP new DCSP line DCSP containing DCSP `value` DCSP to DCSP `out` . &apos; DCNL DCSP DCSP out.write ( ( value + u &apos; \ n &apos; ) ) DCNL DCSP footer = read _ footer ( filename ) DCNL DCSP println ( u &apos;File DCSP Metadata : DCSP { 0 } &apos; .format ( filename ) ) DCNL DCSP println ( u &apos; DCSP DCSP Version : DCSP { 0 } &apos; .format ( footer.version ) ) DCNL DCSP println ( u &apos; DCSP DCSP Num DCSP Rows : DCSP { 0 } &apos; .format ( footer.num _ rows ) ) DCNL DCSP println ( u &apos; DCSP DCSP k / v DCSP metadata : DCSP &apos; ) DCNL DCSP if ( footer.key _ value _ metadata and ( len ( footer.key _ value _ metadata ) &gt; 0 ) ) : DCNL DCSP DCSP for item in footer.key _ value _ metadata : DCNL DCSP DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP { 0 } = { 1 } &apos; .format ( item.key , item.value ) ) DCNL DCSP else : DCNL DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP ( none ) &apos; ) DCNL DCSP println ( u &apos; DCSP DCSP schema : DCSP &apos; ) DCNL DCSP for element in footer.schema : DCNL DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP { name } DCSP ( { type } ) : DCSP length = { type _ length } , DCSP repetition = { repetition _ type } , DCSP children = { num _ children } , DCSP converted _ type = { converted _ type } &apos; .format ( name = element.name , type = ( parquet _ thrift.Type. _ VALUES _ TO _ NAMES &#91; element.type &#93; if element.type else None ) , type _ length = element.type _ length , repetition _ type = _ get _ name ( parquet _ thrift.FieldRepetitionType , element.repetition _ type ) , num _ children = element.num _ children , converted _ type = element.converted _ type ) ) DCNL DCSP if show _ row _ group _ metadata : DCNL DCSP DCSP println ( u &apos; DCSP DCSP row DCSP groups : DCSP &apos; ) DCNL DCSP DCSP for row _ group in footer.row _ groups : DCNL DCSP DCSP DCSP num _ rows = row _ group.num _ rows DCNL DCSP DCSP DCSP size _ bytes = row _ group.total _ byte _ size DCNL DCSP DCSP DCSP println ( u &apos; DCSP DCSP rows = { num _ rows } , DCSP bytes = { bytes } &apos; .format ( num _ rows = num _ rows , bytes = size _ bytes ) ) DCNL DCSP DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP chunks : &apos; ) DCNL DCSP DCSP DCSP for col _ group in row _ group.columns : DCNL DCSP DCSP DCSP DCSP cmd = col _ group.meta _ data DCNL DCSP DCSP DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP DCSP DCSP type = { type } DCSP file _ offset = { offset } DCSP compression = { codec } DCSP encodings = { encodings } DCSP path _ in _ schema = { path _ in _ schema } DCSP num _ values = { num _ values } DCSP uncompressed _ bytes = { raw _ bytes } DCSP compressed _ bytes = { compressed _ bytes } DCSP data _ page _ offset = { data _ page _ offset } DCSP dictionary _ page _ offset = { dictionary _ page _ offset } &apos; .format ( type = _ get _ name ( parquet _ thrift.Type , cmd.type ) , offset = col _ group.file _ offset , codec = _ get _ name ( parquet _ thrift.CompressionCodec , cmd.codec ) , encodings = u &apos; , &apos; .join ( &#91; _ get _ name ( parquet _ thrift.Encoding , s ) for s in cmd.encodings &#93; ) , path _ in _ schema = cmd.path _ in _ schema , num _ values = cmd.num _ values , raw _ bytes = cmd.total _ uncompressed _ size , compressed _ bytes = cmd.total _ compressed _ size , data _ page _ offset = cmd.data _ page _ offset , dictionary _ page _ offset = cmd.dictionary _ page _ offset ) ) DCNL DCSP DCSP DCSP DCSP with open ( filename , u &apos;rb &apos; ) as file _ obj : DCNL DCSP DCSP DCSP DCSP DCSP offset = _ get _ offset ( cmd ) DCNL DCSP DCSP DCSP DCSP DCSP file _ obj.seek ( offset , 0 ) DCNL DCSP DCSP DCSP DCSP DCSP values _ read = 0 DCNL DCSP DCSP DCSP DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP DCSP DCSP pages : DCSP &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP while ( values _ read &lt; num _ rows ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP page _ header = _ read _ page _ header ( file _ obj ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP file _ obj.seek ( page _ header.compressed _ page _ size , 1 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP daph = page _ header.data _ page _ header DCNL DCSP DCSP DCSP DCSP DCSP DCSP type _ = _ get _ name ( parquet _ thrift.PageType , page _ header.type ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP raw _ bytes = page _ header.uncompressed _ page _ size DCNL DCSP DCSP DCSP DCSP DCSP DCSP num _ values = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( page _ header.type = = parquet _ thrift.PageType.DATA _ PAGE ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP num _ values = daph.num _ values DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP values _ read + = num _ values DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( page _ header.type = = parquet _ thrift.PageType.DICTIONARY _ PAGE ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP DCSP DCSP DCSP encoding _ type = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP def _ level _ encoding = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP rep _ level _ encoding = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP if daph : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP encoding _ type = _ get _ name ( parquet _ thrift.Encoding , daph.encoding ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP def _ level _ encoding = _ get _ name ( parquet _ thrift.Encoding , daph.definition _ level _ encoding ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP rep _ level _ encoding = _ get _ name ( parquet _ thrift.Encoding , daph.repetition _ level _ encoding ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP println ( u &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP page DCSP header : DCSP type = { type } DCSP uncompressed _ size = { raw _ bytes } DCSP num _ values = { num _ values } DCSP encoding = { encoding } DCSP def _ level _ encoding = { def _ level _ encoding } DCSP rep _ level _ encoding = { rep _ level _ encoding } &apos; .format ( type = type _ , raw _ bytes = raw _ bytes , num _ values = num _ values , encoding = encoding _ type , def _ level _ encoding = def _ level _ encoding , rep _ level _ encoding = rep _ level _ encoding ) )
DCSP q = { } DCNL DCSP if sample _ filter.user : DCNL DCSP DCSP q &#91; &apos; user _ id &apos; &#93; = sample _ filter.user DCNL DCSP if sample _ filter.project : DCNL DCSP DCSP q &#91; &apos; project _ id &apos; &#93; = sample _ filter.project DCNL DCSP if sample _ filter.meter : DCNL DCSP DCSP q &#91; &apos; counter _ name &apos; &#93; = sample _ filter.meter DCNL DCSP elif require _ meter : DCNL DCSP DCSP raise RuntimeError ( &apos; Missing DCSP required DCSP meter DCSP specifier &apos; ) DCNL DCSP ts _ range = make _ timestamp _ range ( sample _ filter.start _ timestamp , sample _ filter.end _ timestamp , sample _ filter.start _ timestamp _ op , sample _ filter.end _ timestamp _ op ) DCNL DCSP if ts _ range : DCNL DCSP DCSP q &#91; &apos; timestamp &apos; &#93; = ts _ range DCNL DCSP if sample _ filter.resource : DCNL DCSP DCSP q &#91; &apos; resource _ id &apos; &#93; = sample _ filter.resource DCNL DCSP if sample _ filter.source : DCNL DCSP DCSP q &#91; &apos; source &apos; &#93; = sample _ filter.source DCNL DCSP if sample _ filter.message _ id : DCNL DCSP DCSP q &#91; &apos; message _ id &apos; &#93; = sample _ filter.message _ id DCNL DCSP q.update ( dict ( ( ( ( &apos; resource _ % s &apos; % k ) , v ) for ( k , v ) in six.iteritems ( improve _ keys ( sample _ filter.metaquery , metaquery = True ) ) ) ) ) DCNL DCSP return q
DCSP return _ validate _ user _ input ( InputDialog ( message , default _ value , is _ truthy ( hidden ) ) )
DCSP priv _ subnets = &#91; { &apos; subnet &apos; : &apos; 10.0.0.0 &apos; , &apos; mask &apos; : &apos; 255.0.0.0 &apos; } , { &apos; subnet &apos; : &apos; 172.16.0.0 &apos; , &apos; mask &apos; : &apos; 255.240.0.0 &apos; } , { &apos; subnet &apos; : &apos; 192.168.0.0 &apos; , &apos; mask &apos; : &apos; 255.255.0.0 &apos; } &#93; DCNL DCSP ip = struct.unpack ( &apos; I &apos; , socket.inet _ aton ( ip ) ) &#91; 0 &#93; DCNL DCSP for network in priv _ subnets : DCNL DCSP DCSP subnet = struct.unpack ( &apos; I &apos; , socket.inet _ aton ( network &#91; &apos; subnet &apos; &#93; ) ) &#91; 0 &#93; DCNL DCSP DCSP mask = struct.unpack ( &apos; I &apos; , socket.inet _ aton ( network &#91; &apos; mask &apos; &#93; ) ) &#91; 0 &#93; DCNL DCSP DCSP if ( ( ip &amp; mask ) = = ( subnet &amp; mask ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP event _ name = &apos; .&apos;.join ( &#91; &apos; edx &apos; , &apos; certificate &apos; , event _ name &#93; ) DCNL DCSP if ( course is None ) : DCNL DCSP DCSP course = modulestore ( ) .get _ course ( course _ id , depth = 0 ) DCNL DCSP context = { &apos; org _ id &apos; : course.org , &apos; course _ id &apos; : unicode ( course _ id ) } DCNL DCSP data = { &apos; user _ id &apos; : user.id , &apos; course _ id &apos; : unicode ( course _ id ) , &apos; certificate _ url &apos; : get _ certificate _ url ( user.id , course _ id ) } DCNL DCSP event _ data = ( event _ data or { } ) DCNL DCSP event _ data.update ( data ) DCNL DCSP with tracker.get _ tracker ( ) .context ( event _ name , context ) : DCNL DCSP DCSP tracker.emit ( event _ name , event _ data )
DCSP checkpoint _ dir = ( out _ fp + &apos; / checkpoints / &apos; ) DCNL DCSP if ( not exists ( checkpoint _ dir ) ) : DCNL DCSP DCSP create _ dir ( checkpoint _ dir ) DCNL DCSP out _ fp = ( checkpoint _ dir + ( &apos; / checkpoint % d.pickle &apos; % ctr ) ) DCNL DCSP out _ fh = open ( out _ fp , &apos; w &apos; ) DCNL DCSP pickle.dump ( ( current _ key , ctr , cluster _ mapping , ids , bestscores , order ) , out _ fh ) DCNL DCSP return out _ fp
DCSP LOG.debug ( _ ( &apos; get _ nexusport _ binding ( ) DCSP called &apos; ) ) DCNL DCSP session = db.get _ session ( ) DCNL DCSP try : DCNL DCSP DCSP binding = session.query ( nexus _ models _ v2.NexusPortBinding ) .filter _ by ( vlan _ id = vlan _ id ) .filter _ by ( switch _ ip = switch _ ip ) .filter _ by ( port _ id = port _ id ) .filter _ by ( instance _ id = instance _ id ) .all ( ) DCNL DCSP DCSP return binding DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP raise c _ exc.NexusPortBindingNotFound ( vlan _ id = vlan _ id )
DCSP if user _ ref : DCNL DCSP DCSP user _ ref = user _ ref.copy ( ) DCNL DCSP DCSP user _ ref.pop ( &apos; password &apos; , None ) DCNL DCSP DCSP user _ ref.pop ( &apos; tenants &apos; , None ) DCNL DCSP DCSP user _ ref.pop ( &apos; groups &apos; , None ) DCNL DCSP DCSP user _ ref.pop ( &apos; domains &apos; , None ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP user _ ref &#91; &apos; extra &apos; &#93; .pop ( &apos; password &apos; , None ) DCNL DCSP DCSP DCSP user _ ref &#91; &apos; extra &apos; &#93; .pop ( &apos; tenants &apos; , None ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP if ( &apos; password _ expires _ at &apos; not in user _ ref ) : DCNL DCSP DCSP DCSP user _ ref &#91; &apos; password _ expires _ at &apos; &#93; = None DCNL DCSP return user _ ref
DCSP warnings.warn ( &apos; `BdbQuit _ excepthook` DCSP is DCSP deprecated DCSP since DCSP version DCSP 5.1 &apos; , DeprecationWarning , stacklevel = 2 ) DCNL DCSP if ( et = = bdb.BdbQuit ) : DCNL DCSP DCSP print &apos; Exiting DCSP Debugger . &apos; DCNL DCSP elif ( excepthook is not None ) : DCNL DCSP DCSP excepthook ( et , ev , tb ) DCNL DCSP else : DCNL DCSP DCSP BdbQuit _ excepthook.excepthook _ ori ( et , ev , tb )
DCSP redirect _ value = request.REQUEST.get ( REDIRECT _ FIELD _ NAME ) DCNL DCSP if redirect _ value : DCNL DCSP DCSP redirect _ querystring = ( ( REDIRECT _ FIELD _ NAME + &apos; = &apos; ) + redirect _ value ) DCNL DCSP else : DCNL DCSP DCSP redirect _ querystring = &apos; &apos; DCNL DCSP return { &apos; REDIRECT _ FIELD _ NAME &apos; : REDIRECT _ FIELD _ NAME , &apos; REDIRECT _ FIELD _ VALUE &apos; : redirect _ value , &apos; redirect _ querystring &apos; : redirect _ querystring }
DCSP from django.db.models import get _ model DCNL DCSP try : DCNL DCSP DCSP ( app _ label , model _ name ) = settings.AUTH _ USER _ MODEL.split ( &apos; .&apos; ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise ImproperlyConfigured ( &quot; AUTH _ USER _ MODEL DCSP must DCSP be DCSP of DCSP the DCSP form DCSP &apos; app _ label.model _ name &apos; &quot; ) DCNL DCSP user _ model = get _ model ( app _ label , model _ name ) DCNL DCSP if ( user _ model is None ) : DCNL DCSP DCSP raise ImproperlyConfigured ( ( &quot; AUTH _ USER _ MODEL DCSP refers DCSP to DCSP model DCSP &apos; % s &apos; DCSP that DCSP has DCSP not DCSP been DCSP installed &quot; % settings.AUTH _ USER _ MODEL ) ) DCNL DCSP return user _ model
DCSP if meta : DCNL DCSP DCSP for name in USELESS _ META : DCNL DCSP DCSP DCSP if ( name in meta ) : DCNL DCSP DCSP DCSP DCSP del meta &#91; name &#93; DCNL DCSP return meta
DCSP assert ( rnncell _ fw . _ num _ units = = rnncell _ bw . _ num _ units ) , &apos; RNN DCSP Cells DCSP number DCSP of DCSP units DCSP must DCSP match ! &apos; DCNL DCSP sequence _ length = None DCNL DCSP if dynamic : DCNL DCSP DCSP sequence _ length = retrieve _ seq _ length _ op ( ( incoming if isinstance ( incoming , tf.Tensor ) else tf.pack ( incoming ) ) ) DCNL DCSP input _ shape = utils.get _ incoming _ shape ( incoming ) DCNL DCSP with tf.variable _ scope ( scope , name , values = &#91; incoming &#93; ) as scope : DCNL DCSP DCSP name = scope.name DCNL DCSP DCSP inference = incoming DCNL DCSP DCSP if ( type ( inference ) not in &#91; list , np.array &#93; ) : DCNL DCSP DCSP DCSP ndim = len ( input _ shape ) DCNL DCSP DCSP DCSP assert ( ndim &gt; = 3 ) , &apos; Input DCSP dim DCSP should DCSP be DCSP at DCSP least DCSP 3 . &apos; DCNL DCSP DCSP DCSP axes = ( &#91; 1 , 0 &#93; + list ( range ( 2 , ndim ) ) ) DCNL DCSP DCSP DCSP inference = tf.transpose ( inference , axes ) DCNL DCSP DCSP DCSP inference = tf.unpack ( inference ) DCNL DCSP DCSP ( outputs , states _ fw , states _ bw ) = _ brnn ( rnncell _ fw , rnncell _ bw , inference , initial _ state _ fw = initial _ state _ fw , initial _ state _ bw = initial _ state _ bw , sequence _ length = sequence _ length , dtype = tf.float32 ) DCNL DCSP DCSP c = ( ( tf.GraphKeys.LAYER _ VARIABLES + &apos; / &apos; ) + scope.name ) DCNL DCSP DCSP for v in &#91; rnncell _ fw.W , rnncell _ fw.b , rnncell _ bw.W , rnncell _ bw.b &#93; : DCNL DCSP DCSP DCSP if hasattr ( v , &apos; _ _ len _ _ &apos; ) : DCNL DCSP DCSP DCSP DCSP for var in v : DCNL DCSP DCSP DCSP DCSP DCSP tf.add _ to _ collection ( c , var ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tf.add _ to _ collection ( c , v ) DCNL DCSP DCSP tf.add _ to _ collection ( tf.GraphKeys.ACTIVATIONS , outputs &#91; ( -1 ) &#93; ) DCNL DCSP if dynamic : DCNL DCSP DCSP if return _ seq : DCNL DCSP DCSP DCSP o = outputs DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP outputs = tf.transpose ( tf.pack ( outputs ) , &#91; 1 , 0 , 2 &#93; ) DCNL DCSP DCSP DCSP o = advanced _ indexing _ op ( outputs , sequence _ length ) DCNL DCSP else : DCNL DCSP DCSP o = ( outputs if return _ seq else outputs &#91; ( -1 ) &#93; ) DCNL DCSP sfw = states _ fw DCNL DCSP sbw = states _ bw DCNL DCSP tf.add _ to _ collection ( ( ( tf.GraphKeys.LAYER _ TENSOR + &apos; / &apos; ) + name ) , o ) DCNL DCSP return ( ( o , sfw , sbw ) if return _ states else o )
DCSP scenario = Scenario.from _ string ( OUTLINED _ SCENARIO ) DCNL DCSP assert _ equals ( len ( scenario.steps ) , 4 ) DCNL DCSP expected _ sentences = &#91; &apos; Given DCSP I DCSP have DCSP entered DCSP &lt; input _ 1 &gt; DCSP into DCSP the DCSP calculator &apos; , &apos; And DCSP I DCSP have DCSP entered DCSP &lt; input _ 2 &gt; DCSP into DCSP the DCSP calculator &apos; , &apos; When DCSP I DCSP press DCSP &lt; button &gt; &apos; , &apos; Then DCSP the DCSP result DCSP should DCSP be DCSP &lt; output &gt; DCSP on DCSP the DCSP screen &apos; &#93; DCNL DCSP for ( step , expected _ sentence ) in zip ( scenario.steps , expected _ sentences ) : DCNL DCSP DCSP assert _ equals ( type ( step ) , Step ) DCNL DCSP DCSP assert _ equals ( step.sentence , expected _ sentence ) DCNL DCSP assert _ equals ( scenario.name , &apos; Add DCSP two DCSP numbers &apos; ) DCNL DCSP assert _ equals ( scenario.outlines , &#91; { &apos; input _ 1 &apos; : &apos; 20 &apos; , &apos; input _ 2 &apos; : &apos; 30 &apos; , &apos; button &apos; : &apos; add &apos; , &apos; output &apos; : &apos; 50 &apos; } , { &apos; input _ 1 &apos; : &apos; 2&apos; , &apos; input _ 2 &apos; : &apos; 5&apos; , &apos; button &apos; : &apos; add &apos; , &apos; output &apos; : &apos; 7&apos; } , { &apos; input _ 1 &apos; : &apos; 0&apos; , &apos; input _ 2 &apos; : &apos; 40 &apos; , &apos; button &apos; : &apos; add &apos; , &apos; output &apos; : &apos; 40 &apos; } &#93; )
DCSP string = string.replace ( &apos; &amp; amp ; &apos; , &apos; &amp; &apos; ) DCNL DCSP string = string.replace ( &apos; &amp; lt ; &apos; , &apos; &lt; &apos; ) DCNL DCSP string = string.replace ( &apos; &amp; gt ; &apos; , &apos; &gt; &apos; ) DCNL DCSP string = string.replace ( &apos; &amp; quot ; &apos; , &apos; &quot; &apos; ) DCNL DCSP string = string.replace ( &apos; / &apos; , SLASH ) DCNL DCSP return string
DCSP return rv ( name , ChiNoncentralDistribution , ( k , l ) )
DCSP return ( referred _ cls . _ _ name _ _ .lower ( ) + &apos; _ collection &apos; )
DCSP postag ( ruleformat = &apos; str &apos; )
DCSP return _ _ opts _ _ .get ( &apos; location &apos; , config.get _ cloud _ config _ value ( &apos; location &apos; , ( vm _ or get _ configured _ provider ( ) ) , _ _ opts _ _ , default = DEFAULT _ LOCATION , search _ global = False ) )
DCSP t = Table ( &#91; np.array ( &#91; u &apos;a &apos; , u &apos;b &apos; , u &apos;cd &apos; &#93; ) &#93; ) DCNL DCSP t.write ( str ( tmpdir.join ( &apos; test.fits &apos; ) ) , overwrite = True ) DCNL DCSP with fits.open ( str ( tmpdir.join ( &apos; test.fits &apos; ) ) ) as hdul : DCNL DCSP DCSP assert np.all ( ( hdul &#91; 1 &#93; .data &#91; &apos; col0 &apos; &#93; = = &#91; &apos; a &apos; , &apos; b &apos; , &apos; cd &apos; &#93; ) ) DCNL DCSP DCSP assert ( hdul &#91; 1 &#93; .header &#91; &apos; TFORM1 &apos; &#93; = = &apos; 2A &apos; ) DCNL DCSP t2 = Table ( &#91; np.array ( &#91; u &apos; \ u2603 &apos; &#93; ) &#93; ) DCNL DCSP with pytest.raises ( UnicodeEncodeError ) : DCNL DCSP DCSP t2.write ( str ( tmpdir.join ( &apos; test.fits &apos; ) ) , overwrite = True )
DCSP unfrozen = path.get _ home _ dir ( ) DCNL DCSP sys.frozen = True DCNL DCSP IPython . _ _ file _ _ = abspath ( join ( HOME _ TEST _ DIR , &apos; Lib / IPython / _ _ init _ _ .py &apos; ) ) DCNL DCSP home _ dir = path.get _ home _ dir ( ) DCNL DCSP nt.assert _ equal ( home _ dir , unfrozen )
DCSP if ( isinstance ( value , string _ types ) and value.endswith ( &apos; % &apos; ) ) : DCNL DCSP DCSP value _ pct = int ( value.replace ( &apos; % &apos; , &apos; &apos; ) ) DCNL DCSP DCSP return ( int ( ( ( value _ pct / 100.0 ) * num _ items ) ) or min _ value ) DCNL DCSP else : DCNL DCSP DCSP return int ( value )
DCSP next _ slice = ( max if ( kwargs.get ( &apos; order &apos; , &apos; descending &apos; ) = = &apos; descending &apos; ) else min ) DCNL DCSP iterators = &#91; PeekableIterator ( s ) for s in series &#93; DCNL DCSP widths = &#91; &#93; DCNL DCSP for w in iterators : DCNL DCSP DCSP r = w.peek ( ) DCNL DCSP DCSP if r : DCNL DCSP DCSP DCSP ( date , values ) = r DCNL DCSP DCSP DCSP widths.append ( len ( values ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP widths.append ( 0 ) DCNL DCSP while True : DCNL DCSP DCSP items = &#91; it.peek ( ) for it in iterators &#93; DCNL DCSP DCSP if ( not any ( items ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP current _ slice = next _ slice ( ( item &#91; 0 &#93; for item in items if item ) ) DCNL DCSP DCSP data = &#91; &#93; DCNL DCSP DCSP for ( i , item ) in enumerate ( items ) : DCNL DCSP DCSP DCSP if ( item and ( item &#91; 0 &#93; = = current _ slice ) ) : DCNL DCSP DCSP DCSP DCSP data.extend ( item &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP iterators &#91; i &#93; .next ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP data.extend ( ( &#91; 0 &#93; * widths &#91; i &#93; ) ) DCNL DCSP DCSP ( yield ( current _ slice , tuple ( data ) ) )
DCSP parts = html _ parts ( input _ string = input _ string , source _ path = source _ path , destination _ path = destination _ path , input _ encoding = input _ encoding , doctitle = doctitle , initial _ header _ level = initial _ header _ level ) DCNL DCSP fragment = parts &#91; &apos; html _ body &apos; &#93; DCNL DCSP if ( output _ encoding ! = &apos; unicode &apos; ) : DCNL DCSP DCSP fragment = fragment.encode ( output _ encoding ) DCNL DCSP return fragment
DCSP l1 = 400 DCNL DCSP l2 = 700 DCNL DCSP hue = np.clip ( ( ( ( ( l2 - l1 ) - ( wl - l1 ) ) * 0.8 ) / ( l2 - l1 ) ) , 0 , 0.8 ) DCNL DCSP val = 1.0 DCNL DCSP if ( wl &gt; 700 ) : DCNL DCSP DCSP val = ( 1.0 * ( ( ( 700 - wl ) / 700.0 ) + 1 ) ) DCNL DCSP elif ( wl &lt; 400 ) : DCNL DCSP DCSP val = ( ( wl * 1.0 ) / 400.0 ) DCNL DCSP color = pg.hsvColor ( hue , 1.0 , val ) DCNL DCSP pen = pg.mkPen ( color ) DCNL DCSP return pen
DCSP frags = defaultdict ( ( lambda : &#91; &#93; ) ) DCNL DCSP final = &#91; &#93; DCNL DCSP pos = 0 DCNL DCSP for p in plist : DCNL DCSP DCSP p . _ defrag _ pos = pos DCNL DCSP DCSP pos + = 1 DCNL DCSP DCSP if ( IP in p ) : DCNL DCSP DCSP DCSP ip = p &#91; IP &#93; DCNL DCSP DCSP DCSP if ( ( ip.frag ! = 0 ) or ( ip.flags &amp; 1 ) ) : DCNL DCSP DCSP DCSP DCSP ip = p &#91; IP &#93; DCNL DCSP DCSP DCSP DCSP uniq = ( ip.id , ip.src , ip.dst , ip.proto ) DCNL DCSP DCSP DCSP DCSP frags &#91; uniq &#93; .append ( p ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP final.append ( p ) DCNL DCSP defrag = &#91; &#93; DCNL DCSP missfrag = &#91; &#93; DCNL DCSP for lst in frags.itervalues ( ) : DCNL DCSP DCSP lst.sort ( key = ( lambda x : x.frag ) ) DCNL DCSP DCSP p = lst &#91; 0 &#93; DCNL DCSP DCSP lastp = lst &#91; ( -1 ) &#93; DCNL DCSP DCSP if ( ( p.frag &gt; 0 ) or ( ( lastp.flags &amp; 1 ) ! = 0 ) ) : DCNL DCSP DCSP DCSP missfrag + = lst DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP p = p.copy ( ) DCNL DCSP DCSP if ( conf.padding _ layer in p ) : DCNL DCSP DCSP DCSP del p &#91; conf.padding _ layer &#93; .underlayer.payload DCNL DCSP DCSP ip = p &#91; IP &#93; DCNL DCSP DCSP if ( ( ip.len is None ) or ( ip.ihl is None ) ) : DCNL DCSP DCSP DCSP clen = len ( ip.payload ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP clen = ( ip.len - ( ip.ihl &lt; &lt; 2 ) ) DCNL DCSP DCSP txt = conf.raw _ layer ( ) DCNL DCSP DCSP for q in lst &#91; 1 : &#93; : DCNL DCSP DCSP DCSP if ( clen ! = ( q.frag &lt; &lt; 3 ) ) : DCNL DCSP DCSP DCSP DCSP if ( clen &gt; ( q.frag &lt; &lt; 3 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP warning ( ( &apos; Fragment DCSP overlap DCSP ( % i DCSP &gt; DCSP % i ) DCSP % r DCSP &#124; &#124; DCSP % r DCSP &#124; &#124; DCSP DCSP % r &apos; % ( clen , ( q.frag &lt; &lt; 3 ) , p , txt , q ) ) ) DCNL DCSP DCSP DCSP DCSP missfrag + = lst DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if ( ( q &#91; IP &#93; .len is None ) or ( q &#91; IP &#93; .ihl is None ) ) : DCNL DCSP DCSP DCSP DCSP clen + = len ( q &#91; IP &#93; .payload ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP clen + = ( q &#91; IP &#93; .len - ( q &#91; IP &#93; .ihl &lt; &lt; 2 ) ) DCNL DCSP DCSP DCSP if ( conf.padding _ layer in q ) : DCNL DCSP DCSP DCSP DCSP del q &#91; conf.padding _ layer &#93; .underlayer.payload DCNL DCSP DCSP DCSP txt.add _ payload ( q &#91; IP &#93; .payload.copy ( ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ip.flags &amp; = ( ~ 1 ) DCNL DCSP DCSP DCSP del ip.chksum DCNL DCSP DCSP DCSP del ip.len DCNL DCSP DCSP DCSP p = ( p / txt ) DCNL DCSP DCSP DCSP p . _ defrag _ pos = max ( ( x . _ defrag _ pos for x in lst ) ) DCNL DCSP DCSP DCSP defrag.append ( p ) DCNL DCSP defrag2 = &#91; &#93; DCNL DCSP for p in defrag : DCNL DCSP DCSP q = p . _ _ class _ _ ( str ( p ) ) DCNL DCSP DCSP q . _ defrag _ pos = p . _ defrag _ pos DCNL DCSP DCSP defrag2.append ( q ) DCNL DCSP final + = defrag2 DCNL DCSP final + = missfrag DCNL DCSP final.sort ( key = ( lambda x : x . _ defrag _ pos ) ) DCNL DCSP for p in final : DCNL DCSP DCSP del p . _ defrag _ pos DCNL DCSP if hasattr ( plist , &apos; listname &apos; ) : DCNL DCSP DCSP name = ( &apos; Defragmented DCSP % s &apos; % plist.listname ) DCNL DCSP else : DCNL DCSP DCSP name = &apos; Defragmented &apos; DCNL DCSP return PacketList ( final , name = name )
DCSP if ( value is None ) : DCNL DCSP DCSP return value DCNL DCSP return validate _ positive _ integer ( option , value )
DCSP n = 0 DCNL DCSP for b in serial.iterbytes ( data ) : DCNL DCSP DCSP ( yield ( &apos; { : 02X } DCSP &apos; .format ( ord ( b ) ) , ( b.decode ( &apos; ascii &apos; ) if ( &apos; DCSP &apos; &lt; = b &lt; &apos; \ x7f &apos; ) else &apos; .&apos; ) ) ) DCNL DCSP DCSP n + = 1 DCNL DCSP DCSP if ( n = = 8 ) : DCNL DCSP DCSP DCSP ( yield ( &apos; DCSP &apos; , &apos; &apos; ) ) DCNL DCSP DCSP elif ( n &gt; = 16 ) : DCNL DCSP DCSP DCSP ( yield ( None , None ) ) DCNL DCSP DCSP DCSP n = 0 DCNL DCSP if ( n &gt; 0 ) : DCNL DCSP DCSP while ( n &lt; 16 ) : DCNL DCSP DCSP DCSP n + = 1 DCNL DCSP DCSP DCSP if ( n = = 8 ) : DCNL DCSP DCSP DCSP DCSP ( yield ( &apos; DCSP &apos; , &apos; &apos; ) ) DCNL DCSP DCSP DCSP ( yield ( &apos; DCSP DCSP DCSP &apos; , &apos; DCSP &apos; ) ) DCNL DCSP DCSP ( yield ( None , None ) )
DCSP vert _ template = Function ( &apos; \ n DCSP DCSP DCSP DCSP void DCSP main ( void ) \ n DCSP DCSP DCSP DCSP { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP gl _ Position DCSP = DCSP $ position ; \ n DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP &apos; ) DCNL DCSP transformScale = Function ( &apos; \ n DCSP DCSP DCSP DCSP vec4 DCSP transform _ scale ( vec4 DCSP pos ) \ n DCSP DCSP DCSP DCSP { \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP pos.xyz DCSP * = DCSP $ scale ; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP return DCSP pos ; \ n DCSP DCSP DCSP DCSP } \ n DCSP DCSP DCSP DCSP &apos; ) DCNL DCSP class Transform ( object , ) : DCNL DCSP DCSP def _ _ init _ _ ( self ) : DCNL DCSP DCSP DCSP self.func = Function ( transformScale ) DCNL DCSP DCSP DCSP self.func &#91; &apos; scale &apos; &#93; = &apos; uniform DCSP float &apos; DCNL DCSP DCSP def set _ scale ( self , scale ) : DCNL DCSP DCSP DCSP self.func &#91; &apos; scale &apos; &#93; .value = scale DCNL DCSP transforms = &#91; Transform ( ) , Transform ( ) , Transform ( ) &#93; DCNL DCSP code = Function ( vert _ template ) DCNL DCSP ob = Variable ( &apos; attribute DCSP vec3 DCSP a _ position &apos; ) DCNL DCSP for trans in transforms : DCNL DCSP DCSP ob = trans.func ( ob ) DCNL DCSP code &#91; &apos; position &apos; &#93; = ob DCNL DCSP print code
DCSP return pq ( e ) .text ( )
DCSP mlp = MLP ( layers = &#91; Linear ( layer _ name = &apos; h &apos; , dim = 5 , irange = 0.01 ) &#93; ) DCNL DCSP conditional = DummyConditional ( mlp = mlp , name = &apos; conditional &apos; ) DCNL DCSP vae = DummyVAE ( ) DCNL DCSP conditional.set _ vae ( vae ) DCNL DCSP testing.assert _ same _ object ( conditional.get _ vae ( ) , vae )
DCSP values = values.copy ( ) DCNL DCSP session = ( session or get _ session ( ) ) DCNL DCSP with session.begin ( ) : DCNL DCSP DCSP task _ info _ values = _ pop _ task _ info _ values ( values ) DCNL DCSP DCSP task _ ref = models.Task ( ) DCNL DCSP DCSP _ task _ update ( context , task _ ref , values , session = session ) DCNL DCSP DCSP _ task _ info _ create ( context , task _ ref.id , task _ info _ values , session = session ) DCNL DCSP return task _ get ( context , task _ ref.id , session )
DCSP evaluatedInt = getEvaluatedInt ( key , xmlElement ) DCNL DCSP if ( evaluatedInt = = None ) : DCNL DCSP DCSP return defaultInt DCNL DCSP return evaluatedInt
DCSP error _ map = { blobstore _ service _ pb.BlobstoreServiceError.INTERNAL _ ERROR : InternalError , blobstore _ service _ pb.BlobstoreServiceError.BLOB _ NOT _ FOUND : BlobNotFoundError , blobstore _ service _ pb.BlobstoreServiceError.DATA _ INDEX _ OUT _ OF _ RANGE : DataIndexOutOfRangeError , blobstore _ service _ pb.BlobstoreServiceError.BLOB _ FETCH _ SIZE _ TOO _ LARGE : BlobFetchSizeTooLargeError , blobstore _ service _ pb.BlobstoreServiceError.PERMISSION _ DENIED : PermissionDeniedError } DCNL DCSP desired _ exc = error _ map.get ( error.application _ error ) DCNL DCSP return ( desired _ exc ( error.error _ detail ) if desired _ exc else error )
DCSP from sympy.polys.domains import ZZ DCNL DCSP X1 = &#91; i for i in range ( p ) if ( gf _ eval ( f , i , p , ZZ ) = = 0 ) &#93; DCNL DCSP if ( e = = 1 ) : DCNL DCSP DCSP return X1 DCNL DCSP X = &#91; &#93; DCNL DCSP S = list ( zip ( X1 , ( &#91; 1 &#93; * len ( X1 ) ) ) ) DCNL DCSP while S : DCNL DCSP DCSP ( x , s ) = S.pop ( ) DCNL DCSP DCSP if ( s = = e ) : DCNL DCSP DCSP DCSP X.append ( x ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP s1 = ( s + 1 ) DCNL DCSP DCSP DCSP ps = ( p * * s ) DCNL DCSP DCSP DCSP S.extend ( &#91; ( ( x + ( v * ps ) ) , s1 ) for v in _ raise _ mod _ power ( x , s , p , f ) &#93; ) DCNL DCSP return sorted ( X )
DCSP if ( subnet.get _ meta ( &apos; dhcp _ server &apos; ) is not None ) : DCNL DCSP DCSP net _ info = { &apos; id &apos; : ( &apos; network % d &apos; % net _ num ) , &apos; type &apos; : ( &apos; ipv % d _ dhcp &apos; % version ) , &apos; link &apos; : link _ id , &apos; network _ id &apos; : vif &#91; &apos; network &apos; &#93; &#91; &apos; id &apos; &#93; } DCNL DCSP DCSP return net _ info DCNL DCSP ip = subnet &#91; &apos; ips &apos; &#93; &#91; 0 &#93; DCNL DCSP address = ip &#91; &apos; address &apos; &#93; DCNL DCSP if ( version = = 4 ) : DCNL DCSP DCSP netmask = model.get _ netmask ( ip , subnet ) DCNL DCSP elif ( version = = 6 ) : DCNL DCSP DCSP netmask = str ( subnet.as _ netaddr ( ) .netmask ) DCNL DCSP net _ info = { &apos; id &apos; : ( &apos; network % d &apos; % net _ num ) , &apos; type &apos; : ( &apos; ipv % d &apos; % version ) , &apos; link &apos; : link _ id , &apos; ip _ address &apos; : address , &apos; netmask &apos; : netmask , &apos; routes &apos; : _ get _ default _ route ( version , subnet ) , &apos; network _ id &apos; : vif &#91; &apos; network &apos; &#93; &#91; &apos; id &apos; &#93; } DCNL DCSP for route in subnet &#91; &apos; routes &apos; &#93; : DCNL DCSP DCSP route _ addr = netaddr.IPNetwork ( route &#91; &apos; cidr &apos; &#93; ) DCNL DCSP DCSP new _ route = { &apos; network &apos; : str ( route _ addr.network ) , &apos; netmask &apos; : str ( route _ addr.netmask ) , &apos; gateway &apos; : route &#91; &apos; gateway &apos; &#93; &#91; &apos; address &apos; &#93; } DCNL DCSP DCSP net _ info &#91; &apos; routes &apos; &#93; .append ( new _ route ) DCNL DCSP return net _ info
DCSP try : DCNL DCSP DCSP item _ id = request.args &#91; 0 &#93; DCNL DCSP except : DCNL DCSP DCSP raise HTTP ( 400 , current.xml.json _ message ( False , 400 , &apos; No DCSP value DCSP provided ! &apos; ) ) DCNL DCSP table = s3db.inv _ inv _ item DCNL DCSP ptable = db.supply _ item _ pack DCNL DCSP query = ( ( table.id = = item _ id ) &amp; ( table.item _ pack _ id = = ptable.id ) ) DCNL DCSP record = db ( query ) .select ( table.quantity , ptable.quantity , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP d = { &apos; iquantity &apos; : record.inv _ inv _ item.quantity , &apos; pquantity &apos; : record.supply _ item _ pack.quantity } DCNL DCSP output = json.dumps ( d ) DCNL DCSP response.headers &#91; &apos; Content-Type &apos; &#93; = &apos; application / json &apos; DCNL DCSP return output
DCSP module = ( module or service ) DCNL DCSP ( cxkey , region , key , keyid ) = _ get _ profile ( service , region , key , keyid , profile ) DCNL DCSP cxkey = ( cxkey + &apos; : conn3 &apos; ) DCNL DCSP if ( cxkey in _ _ context _ _ ) : DCNL DCSP DCSP return _ _ context _ _ &#91; cxkey &#93; DCNL DCSP try : DCNL DCSP DCSP session = boto3.session.Session ( aws _ access _ key _ id = keyid , aws _ secret _ access _ key = key , region _ name = region ) DCNL DCSP DCSP if ( session is None ) : DCNL DCSP DCSP DCSP raise SaltInvocationError ( &apos; Region DCSP &quot; { 0 } &quot; DCSP is DCSP not DCSP valid . &apos; .format ( region ) ) DCNL DCSP DCSP conn = session.client ( module ) DCNL DCSP DCSP if ( conn is None ) : DCNL DCSP DCSP DCSP raise SaltInvocationError ( &apos; Region DCSP &quot; { 0 } &quot; DCSP is DCSP not DCSP valid . &apos; .format ( region ) ) DCNL DCSP except boto.exception.NoAuthHandlerFound : DCNL DCSP DCSP raise SaltInvocationError ( &apos; No DCSP authentication DCSP credentials DCSP found DCSP when DCSP attempting DCSP to DCSP make DCSP boto DCSP { 0 } DCSP connection DCSP to DCSP region DCSP &quot; { 1 } &quot; . &apos; .format ( service , region ) ) DCNL DCSP _ _ context _ _ &#91; cxkey &#93; = conn DCNL DCSP return conn
DCSP tconfig = XML.SubElement ( xml _ parent , &apos; hudson.tasks.BuildTrigger &apos; ) DCNL DCSP childProjects = XML.SubElement ( tconfig , &apos; childProjects &apos; ) DCNL DCSP childProjects.text = data &#91; &apos; project &apos; &#93; DCNL DCSP tthreshold = XML.SubElement ( tconfig , &apos; threshold &apos; ) DCNL DCSP threshold = data.get ( &apos; threshold &apos; , &apos; SUCCESS &apos; ) DCNL DCSP supported _ thresholds = &#91; &apos; SUCCESS &apos; , &apos; UNSTABLE &apos; , &apos; FAILURE &apos; &#93; DCNL DCSP if ( threshold not in supported _ thresholds ) : DCNL DCSP DCSP raise JenkinsJobsException ( ( &apos; threshold DCSP must DCSP be DCSP one DCSP of DCSP % s &apos; % &apos; , DCSP &apos; .join ( supported _ thresholds ) ) ) DCNL DCSP tname = XML.SubElement ( tthreshold , &apos; name &apos; ) DCNL DCSP tname.text = hudson _ model.THRESHOLDS &#91; threshold &#93; &#91; &apos; name &apos; &#93; DCNL DCSP tordinal = XML.SubElement ( tthreshold , &apos; ordinal &apos; ) DCNL DCSP tordinal.text = hudson _ model.THRESHOLDS &#91; threshold &#93; &#91; &apos; ordinal &apos; &#93; DCNL DCSP tcolor = XML.SubElement ( tthreshold , &apos; color &apos; ) DCNL DCSP tcolor.text = hudson _ model.THRESHOLDS &#91; threshold &#93; &#91; &apos; color &apos; &#93;
DCSP pass
DCSP return _ unpack _ simple ( fid , &apos; &gt; f8 &apos; , np.float64 )
DCSP toothProfileHalfCylinder = getToothProfileHalfCylinder ( derivation , pitchRadius ) DCNL DCSP toothProfileHalfCylinder = getThicknessMultipliedPath ( toothProfileHalfCylinder , derivation.toothThicknessMultiplier ) DCNL DCSP toothProfileHalf = &#91; &#93; DCNL DCSP innerRadius = ( pitchRadius - derivation.dedendum ) DCNL DCSP for point in toothProfileHalfCylinder : DCNL DCSP DCSP if ( abs ( point ) &gt; = innerRadius ) : DCNL DCSP DCSP DCSP toothProfileHalf.append ( point ) DCNL DCSP return getToothProfileCylinderByProfile ( derivation , pitchRadius , teeth , toothProfileHalf )
DCSP if use _ debugger : DCNL DCSP DCSP from werkzeug.debug import DebuggedApplication DCNL DCSP DCSP application = DebuggedApplication ( application , use _ evalex ) DCNL DCSP if static _ files : DCNL DCSP DCSP from werkzeug.wsgi import SharedDataMiddleware DCNL DCSP DCSP application = SharedDataMiddleware ( application , static _ files ) DCNL DCSP def log _ startup ( sock ) : DCNL DCSP DCSP display _ hostname = ( ( ( hostname not in ( &apos; &apos; , &apos; * &apos; ) ) and hostname ) or &apos; localhost &apos; ) DCNL DCSP DCSP if ( &apos; : &apos; in display _ hostname ) : DCNL DCSP DCSP DCSP display _ hostname = ( &apos; &#91; % s &#93; &apos; % display _ hostname ) DCNL DCSP DCSP quit _ msg = &apos; ( Press DCSP CTRL + C DCSP to DCSP quit ) &apos; DCNL DCSP DCSP port = sock.getsockname ( ) &#91; 1 &#93; DCNL DCSP DCSP _ log ( &apos; info &apos; , &apos; DCSP * DCSP Running DCSP on DCSP % s : / / % s : % d / DCSP % s &apos; , ( ( ( ssl _ context is None ) and &apos; http &apos; ) or &apos; https &apos; ) , display _ hostname , port , quit _ msg ) DCNL DCSP def inner ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP fd = int ( os.environ &#91; &apos; WERKZEUG _ SERVER _ FD &apos; &#93; ) DCNL DCSP DCSP except ( LookupError , ValueError ) : DCNL DCSP DCSP DCSP fd = None DCNL DCSP DCSP srv = make _ server ( hostname , port , application , threaded , processes , request _ handler , passthrough _ errors , ssl _ context , fd = fd ) DCNL DCSP DCSP if ( fd is None ) : DCNL DCSP DCSP DCSP log _ startup ( srv.socket ) DCNL DCSP DCSP srv.serve _ forever ( ) DCNL DCSP if use _ reloader : DCNL DCSP DCSP if ( os.environ.get ( &apos; WERKZEUG _ RUN _ MAIN &apos; ) ! = &apos; true &apos; ) : DCNL DCSP DCSP DCSP if ( ( port = = 0 ) and ( not can _ open _ by _ fd ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Cannot DCSP bind DCSP to DCSP a DCSP random DCSP port DCSP with DCSP enabled DCSP reloader DCSP if DCSP the DCSP Python DCSP interpreter DCSP does DCSP not DCSP support DCSP socket DCSP opening DCSP by DCSP fd . &apos; ) DCNL DCSP DCSP DCSP address _ family = select _ ip _ version ( hostname , port ) DCNL DCSP DCSP DCSP s = socket.socket ( address _ family , socket.SOCK _ STREAM ) DCNL DCSP DCSP DCSP s.setsockopt ( socket.SOL _ SOCKET , socket.SO _ REUSEADDR , 1 ) DCNL DCSP DCSP DCSP s.bind ( ( hostname , port ) ) DCNL DCSP DCSP DCSP if hasattr ( s , &apos; set _ inheritable &apos; ) : DCNL DCSP DCSP DCSP DCSP s.set _ inheritable ( True ) DCNL DCSP DCSP DCSP if can _ open _ by _ fd : DCNL DCSP DCSP DCSP DCSP os.environ &#91; &apos; WERKZEUG _ SERVER _ FD &apos; &#93; = str ( s.fileno ( ) ) DCNL DCSP DCSP DCSP DCSP s.listen ( LISTEN _ QUEUE ) DCNL DCSP DCSP DCSP DCSP log _ startup ( s ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP s.close ( ) DCNL DCSP DCSP from . _ reloader import run _ with _ reloader DCNL DCSP DCSP run _ with _ reloader ( inner , extra _ files , reloader _ interval , reloader _ type ) DCNL DCSP else : DCNL DCSP DCSP inner ( )
DCSP from scipy import stats DCNL DCSP from statsmodels.sandbox.regression.predstd import wls _ prediction _ std DCNL DCSP infl = OLSInfluence ( res ) DCNL DCSP predict _ mean _ se = np.sqrt ( ( infl.hat _ matrix _ diag * res.mse _ resid ) ) DCNL DCSP tppf = stats.t.isf ( ( alpha / 2.0 ) , res.df _ resid ) DCNL DCSP predict _ mean _ ci = np.column _ stack ( &#91; ( res.fittedvalues - ( tppf * predict _ mean _ se ) ) , ( res.fittedvalues + ( tppf * predict _ mean _ se ) ) &#93; ) DCNL DCSP ( predict _ se , predict _ ci _ low , predict _ ci _ upp ) = wls _ prediction _ std ( res ) DCNL DCSP predict _ ci = np.column _ stack ( ( predict _ ci _ low , predict _ ci _ upp ) ) DCNL DCSP resid _ se = np.sqrt ( ( res.mse _ resid * ( 1 - infl.hat _ matrix _ diag ) ) ) DCNL DCSP table _ sm = np.column _ stack ( &#91; ( np.arange ( res.nobs ) + 1 ) , res.model.endog , res.fittedvalues , predict _ mean _ se , predict _ mean _ ci &#91; : , 0 &#93; , predict _ mean _ ci &#91; : , 1 &#93; , predict _ ci &#91; : , 0 &#93; , predict _ ci &#91; : , 1 &#93; , res.resid , resid _ se , infl.resid _ studentized _ internal , infl.cooks _ distance &#91; 0 &#93; &#93; ) DCNL DCSP data = table _ sm DCNL DCSP ss2 = &#91; &apos; Obs &apos; , &apos; Dep DCSP Var \ nPopulation &apos; , &apos; Predicted \ nValue &apos; , &apos; Std DCSP Error \ nMean DCSP Predict &apos; , &apos; Mean DCSP ci \ n95 % DCSP low &apos; , &apos; Mean DCSP ci \ n95 % DCSP upp &apos; , &apos; Predict DCSP ci \ n95 % DCSP low &apos; , &apos; Predict DCSP ci \ n95 % DCSP upp &apos; , &apos; Residual &apos; , &apos; Std DCSP Error \ nResidual &apos; , &apos; Student \ nResidual &apos; , &quot; Cook &apos;s \ nD &quot; &#93; DCNL DCSP colnames = ss2 DCNL DCSP from statsmodels.iolib.table import SimpleTable , default _ html _ fmt DCNL DCSP from statsmodels.iolib.tableformatting import fmt _ base DCNL DCSP from copy import deepcopy DCNL DCSP fmt = deepcopy ( fmt _ base ) DCNL DCSP fmt _ html = deepcopy ( default _ html _ fmt ) DCNL DCSP fmt &#91; &apos; data _ fmts &apos; &#93; = ( &#91; &apos; % 4d &apos; &#93; + ( &#91; &apos; % 6.3f &apos; &#93; * ( data.shape &#91; 1 &#93; - 1 ) ) ) DCNL DCSP st = SimpleTable ( data , headers = colnames , txt _ fmt = fmt , html _ fmt = fmt _ html ) DCNL DCSP return ( st , data , ss2 )
DCSP receptive _ field = np.zeros ( ( len ( layers ) , 2 ) ) DCNL DCSP conv _ mode = True DCNL DCSP first _ conv _ layer = True DCNL DCSP expon = np.ones ( ( 1 , 2 ) ) DCNL DCSP for ( i , layer ) in enumerate ( layers &#91; 1 : &#93; ) : DCNL DCSP DCSP j = ( i + 1 ) DCNL DCSP DCSP if ( not conv _ mode ) : DCNL DCSP DCSP DCSP receptive _ field &#91; j &#93; = img _ size DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if is _ conv2d ( layer ) : DCNL DCSP DCSP DCSP if ( not first _ conv _ layer ) : DCNL DCSP DCSP DCSP DCSP last _ field = receptive _ field &#91; i &#93; DCNL DCSP DCSP DCSP DCSP new _ field = ( last _ field + ( expon * ( np.array ( layer.filter _ size ) - 1 ) ) ) DCNL DCSP DCSP DCSP DCSP receptive _ field &#91; j &#93; = new _ field DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP receptive _ field &#91; j &#93; = layer.filter _ size DCNL DCSP DCSP DCSP DCSP first _ conv _ layer = False DCNL DCSP DCSP elif is _ maxpool2d ( layer ) : DCNL DCSP DCSP DCSP receptive _ field &#91; j &#93; = receptive _ field &#91; i &#93; DCNL DCSP DCSP DCSP expon * = np.array ( layer.pool _ size ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP conv _ mode = False DCNL DCSP DCSP DCSP receptive _ field &#91; j &#93; = img _ size DCNL DCSP receptive _ field &#91; 0 &#93; = img _ size DCNL DCSP return receptive _ field
DCSP global _ populated DCNL DCSP _ all _ actions.clear ( ) DCNL DCSP _ top _ level _ ids.clear ( ) DCNL DCSP _ populated = False
DCSP if abbreviate : DCNL DCSP DCSP chunks = ( ( ( ( ( 60 * 60 ) * 24 ) * 365 ) , ( lambda n : &apos; y &apos; ) ) , ( ( ( ( 60 * 60 ) * 24 ) * 30 ) , ( lambda n : &apos; m &apos; ) ) , ( ( ( ( 60 * 60 ) * 24 ) * 7 ) , ( lambda n : &apos; w &apos; ) ) , ( ( ( 60 * 60 ) * 24 ) , ( lambda n : &apos; d &apos; ) ) , ( ( 60 * 60 ) , ( lambda n : &apos; h &apos; ) ) , ( 60 , ( lambda n : &apos; m &apos; ) ) , ( 1 , ( lambda n : &apos; s &apos; ) ) ) DCNL DCSP else : DCNL DCSP DCSP chunks = ( ( ( ( ( 60 * 60 ) * 24 ) * 365 ) , ( lambda n : ungettext ( &apos; year &apos; , &apos; years &apos; , n ) ) ) , ( ( ( ( 60 * 60 ) * 24 ) * 30 ) , ( lambda n : ungettext ( &apos; month &apos; , &apos; months &apos; , n ) ) ) , ( ( ( ( 60 * 60 ) * 24 ) * 7 ) , ( lambda n : ungettext ( &apos; week &apos; , &apos; weeks &apos; , n ) ) ) , ( ( ( 60 * 60 ) * 24 ) , ( lambda n : ungettext ( &apos; day &apos; , &apos; days &apos; , n ) ) ) , ( ( 60 * 60 ) , ( lambda n : ungettext ( &apos; hour &apos; , &apos; hours &apos; , n ) ) ) , ( 60 , ( lambda n : ungettext ( &apos; minute &apos; , &apos; minutes &apos; , n ) ) ) , ( 1 , ( lambda n : ungettext ( &apos; second &apos; , &apos; seconds &apos; , n ) ) ) ) DCNL DCSP if ( not isinstance ( d , datetime.datetime ) ) : DCNL DCSP DCSP d = datetime.datetime ( d.year , d.month , d.day ) DCNL DCSP if ( now and ( not isinstance ( now , datetime.datetime ) ) ) : DCNL DCSP DCSP now = datetime.datetime ( now.year , now.month , now.day ) DCNL DCSP if ( not now ) : DCNL DCSP DCSP if d.tzinfo : DCNL DCSP DCSP DCSP now = datetime.datetime.now ( LocalTimezone ( d ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP now = datetime.datetime.now ( ) DCNL DCSP delta = ( now - ( d - datetime.timedelta ( 0 , 0 , d.microsecond ) ) ) DCNL DCSP since = ( ( ( ( delta.days * 24 ) * 60 ) * 60 ) + delta.seconds ) DCNL DCSP if ( since &lt; = 0 ) : DCNL DCSP DCSP if abbreviate : DCNL DCSP DCSP DCSP return ( u &apos; 0 &apos; + ugettext ( &apos; s &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( u &apos; 0 DCSP &apos; + ugettext ( &apos; seconds &apos; ) ) DCNL DCSP for ( i , ( seconds , name ) ) in enumerate ( chunks ) : DCNL DCSP DCSP count = ( since / / seconds ) DCNL DCSP DCSP if ( count ! = 0 ) : DCNL DCSP DCSP DCSP break DCNL DCSP if abbreviate : DCNL DCSP DCSP s = ( ugettext ( &apos; % ( number ) d % ( type ) s &apos; ) % { &apos; number &apos; : count , &apos; type &apos; : name ( count ) } ) DCNL DCSP else : DCNL DCSP DCSP s = ( ugettext ( &apos; % ( number ) d DCSP % ( type ) s &apos; ) % { &apos; number &apos; : count , &apos; type &apos; : name ( count ) } ) DCNL DCSP if ( ( i + 1 ) &lt; len ( chunks ) ) : DCNL DCSP DCSP ( seconds2 , name2 ) = chunks &#91; ( i + 1 ) &#93; DCNL DCSP DCSP count2 = ( ( since - ( seconds * count ) ) / / seconds2 ) DCNL DCSP DCSP if ( count2 ! = 0 ) : DCNL DCSP DCSP DCSP if abbreviate : DCNL DCSP DCSP DCSP DCSP s + = ( ugettext ( &apos; % ( separator ) s DCSP % ( number ) d % ( type ) s &apos; ) % { &apos; separator &apos; : separator , &apos; number &apos; : count2 , &apos; type &apos; : name2 ( count2 ) } ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP s + = ( ugettext ( &apos; % ( separator ) s DCSP % ( number ) d DCSP % ( type ) s &apos; ) % { &apos; separator &apos; : separator , &apos; number &apos; : count2 , &apos; type &apos; : name2 ( count2 ) } ) DCNL DCSP return s
DCSP funcs = { } DCNL DCSP for ( key , name ) in &#91; ( &apos; b &apos; , &apos; char &apos; ) , ( &apos; h &apos; , &apos; short &apos; ) , ( &apos; i &apos; , &apos; int &apos; ) , ( &apos; q &apos; , &apos; longlong &apos; ) &#93; : DCNL DCSP DCSP for ( echar , esuffix ) in &#91; ( &apos; &lt; &apos; , &apos; le &apos; ) , ( &apos; &gt; &apos; , &apos; be &apos; ) &#93; : DCNL DCSP DCSP DCSP esuffix = ( &apos; _ &apos; + esuffix ) DCNL DCSP DCSP DCSP for unsigned in &#91; True , False &#93; : DCNL DCSP DCSP DCSP DCSP s = struct.Struct ( ( echar + ( key.upper ( ) if unsigned else key ) ) ) DCNL DCSP DCSP DCSP DCSP get _ wrapper = ( lambda f : ( lambda * a , * * k : f ( * a , * * k ) &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP DCSP unpack = get _ wrapper ( s.unpack ) DCNL DCSP DCSP DCSP DCSP unpack _ from = get _ wrapper ( s.unpack _ from ) DCNL DCSP DCSP DCSP DCSP def get _ unpack _ from ( s ) : DCNL DCSP DCSP DCSP DCSP DCSP def unpack _ from ( data , offset = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return ( s.unpack _ from ( data , offset ) &#91; 0 &#93; , ( offset + s.size ) ) DCNL DCSP DCSP DCSP DCSP DCSP return unpack _ from DCNL DCSP DCSP DCSP DCSP unpack _ from = get _ unpack _ from ( s ) DCNL DCSP DCSP DCSP DCSP pack = s.pack DCNL DCSP DCSP DCSP DCSP prefix = ( &apos; u &apos; if unsigned else &apos; &apos; ) DCNL DCSP DCSP DCSP DCSP if ( s.size = = 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP esuffix = &apos; &apos; DCNL DCSP DCSP DCSP DCSP bits = str ( ( s.size * 8 ) ) DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; % s % s % s &apos; % ( prefix , name , esuffix ) ) &#93; = unpack DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; % sint % s % s &apos; % ( prefix , bits , esuffix ) ) &#93; = unpack DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; % s % s % s _ from &apos; % ( prefix , name , esuffix ) ) &#93; = unpack _ from DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; % sint % s % s _ from &apos; % ( prefix , bits , esuffix ) ) &#93; = unpack _ from DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; to _ % s % s % s &apos; % ( prefix , name , esuffix ) ) &#93; = pack DCNL DCSP DCSP DCSP DCSP funcs &#91; ( &apos; to _ % sint % s % s &apos; % ( prefix , bits , esuffix ) ) &#93; = pack DCNL DCSP for ( key , func ) in iteritems ( funcs ) : DCNL DCSP DCSP setattr ( cls , key , staticmethod ( func ) )
DCSP user = mapped _ properties &#91; &apos; user &apos; &#93; DCNL DCSP user _ id = user.get ( &apos; id &apos; ) DCNL DCSP user _ name = ( user.get ( &apos; name &apos; ) or request.remote _ user ) DCNL DCSP if ( not any ( &#91; user _ id , user _ name &#93; ) ) : DCNL DCSP DCSP msg = _ ( &apos; Could DCSP not DCSP map DCSP user DCSP while DCSP setting DCSP ephemeral DCSP user DCSP identity . DCSP Either DCSP mapping DCSP rules DCSP must DCSP specify DCSP user DCSP id / name DCSP or DCSP REMOTE _ USER DCSP environment DCSP variable DCSP must DCSP be DCSP set . &apos; ) DCNL DCSP DCSP raise exception.Unauthorized ( msg ) DCNL DCSP elif ( not user _ name ) : DCNL DCSP DCSP user &#91; &apos; name &apos; &#93; = user _ id DCNL DCSP elif ( not user _ id ) : DCNL DCSP DCSP user _ id = user _ name DCNL DCSP user &#91; &apos; id &apos; &#93; = parse.quote ( user _ id ) DCNL DCSP return ( user &#91; &apos; id &apos; &#93; , user &#91; &apos; name &apos; &#93; )
DCSP if ( expr _ form is not None ) : DCNL DCSP DCSP salt.utils.warn _ until ( &apos; Fluorine &apos; , &quot; the DCSP target DCSP type DCSP should DCSP be DCSP passed DCSP using DCSP the DCSP &apos; tgt _ type &apos; DCSP argument DCSP instead DCSP of DCSP &apos; expr _ form &apos; . DCSP Support DCSP for DCSP using DCSP &apos; expr _ form &apos; DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Fluorine . &quot; ) DCNL DCSP DCSP tgt _ type = expr _ form DCNL DCSP return _ talk2modjk ( name , lbn , target , &apos; worker _ disable &apos; , profile , tgt _ type )
DCSP if isinstance ( val , string _ types ) : DCNL DCSP DCSP return val DCNL DCSP elif isinstance ( val , collections.Sequence ) : DCNL DCSP DCSP return &#91; swap _ inf _ nan ( v ) for v in val &#93; DCNL DCSP elif isinstance ( val , collections.Mapping ) : DCNL DCSP DCSP return dict ( &#91; ( swap _ inf _ nan ( k ) , swap _ inf _ nan ( v ) ) for ( k , v ) in iteritems ( val ) &#93; ) DCNL DCSP elif isinstance ( val , float ) : DCNL DCSP DCSP if math.isnan ( val ) : DCNL DCSP DCSP DCSP return &apos; _ _ NaN _ _ &apos; DCNL DCSP DCSP elif ( val = = float ( &apos; inf &apos; ) ) : DCNL DCSP DCSP DCSP return &apos; _ _ Infinity _ _ &apos; DCNL DCSP DCSP elif ( val = = float ( &apos; -inf &apos; ) ) : DCNL DCSP DCSP DCSP return &apos; _ _ -Infinity _ _ &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return val DCNL DCSP else : DCNL DCSP DCSP return val
DCSP res = { &apos; completed &apos; : 0 , &apos; running &apos; : 0 , &apos; failed &apos; : 0 , &apos; killed &apos; : 0 , &apos; all &apos; : 0 } DCNL DCSP jobcounts = request.jt.get _ job _ count _ by _ user ( username ) DCNL DCSP res &#91; &apos; completed &apos; &#93; = jobcounts.nSucceeded DCNL DCSP res &#91; &apos; running &apos; &#93; = ( jobcounts.nPrep + jobcounts.nRunning ) DCNL DCSP res &#91; &apos; failed &apos; &#93; = jobcounts.nFailed DCNL DCSP res &#91; &apos; killed &apos; &#93; = jobcounts.nKilled DCNL DCSP res &#91; &apos; all &apos; &#93; = ( ( ( res &#91; &apos; completed &apos; &#93; + res &#91; &apos; running &apos; &#93; ) + res &#91; &apos; failed &apos; &#93; ) + res &#91; &apos; killed &apos; &#93; ) DCNL DCSP return res
DCSP return _ filer _ file _ from _ upload ( model = File , request = request , path = path , upload _ data = upload _ data , sha1 = sha1 )
DCSP if ( config.LAST _ UPDATED in document ) : DCNL DCSP DCSP return document &#91; config.LAST _ UPDATED &#93; .replace ( tzinfo = None ) DCNL DCSP else : DCNL DCSP DCSP return epoch ( )
DCSP test _ stubs.stub _ out _ registry _ server ( stubs ) DCNL DCSP def fake _ image _ update ( ctx , image _ id , values , purge _ props = False ) : DCNL DCSP DCSP return { &apos; properties &apos; : { } } DCNL DCSP stubs.Set ( db _ api , &apos; image _ update &apos; , fake _ image _ update )
DCSP for flag _ name in NamesOfDefinedFlags ( ) : DCNL DCSP DCSP module _ bar.RemoveOneFlag ( flag _ name , flag _ values = flag _ values ) DCNL DCSP module _ bar.RemoveFlags ( flag _ values = flag _ values )
DCSP query = _ volume _ get _ query ( context ) .filter _ by ( consistencygroup _ id = group _ id ) DCNL DCSP if filters : DCNL DCSP DCSP query = _ process _ volume _ filters ( query , filters ) DCNL DCSP DCSP if ( query is None ) : DCNL DCSP DCSP DCSP return &#91; &#93; DCNL DCSP return query.all ( )
DCSP xml _ parts = &#91; ( &apos; &lt; ? xml DCSP version = &quot; 1.0 &quot; DCSP encoding = &quot; % s &quot; ? &gt; &apos; % encoding ) &#93; DCNL DCSP if pretty : DCNL DCSP DCSP xml _ parts.append ( &apos; \ n &apos; ) DCNL DCSP _ ConstructContentList ( xml _ parts , content , pretty ) DCNL DCSP return &apos; &apos;.join ( xml _ parts )
DCSP token = settings.SURVEYGIZMO _ API _ TOKEN DCNL DCSP secret = settings.SURVEYGIZMO _ API _ TOKEN _ SECRET DCNL DCSP if ( ( token is None ) or ( secret is None ) ) : DCNL DCSP DCSP return DCNL DCSP survey _ id = SURVEYS &#91; survey &#93; &#91; &apos; exit _ survey _ id &apos; &#93; DCNL DCSP campaign _ id = SURVEYS &#91; survey &#93; &#91; &apos; exit _ survey _ campaign _ id &apos; &#93; DCNL DCSP try : DCNL DCSP DCSP requests.put ( &apos; https : / / restapi.surveygizmo.com / v2 / survey / { survey } / surveycampaign / { campaign } / contact ? semailaddress = { email } &amp; api _ token = { token } &amp; api _ token _ secret = { secret } &apos; .format ( survey = survey _ id , campaign = campaign _ id , email = email , token = token , secret = secret ) , timeout = 30 ) DCNL DCSP except requests.exceptions.Timeout : DCNL DCSP DCSP print ( &apos; Timedout DCSP adding : DCSP % s &apos; % email )
DCSP Z = np.zeros ( ( 5 , 4 ) ) DCNL DCSP for X in &#91; Z , csr _ matrix ( Z ) &#93; : DCNL DCSP DCSP lda = LatentDirichletAllocation ( max _ iter = 750 ) .fit ( X ) DCNL DCSP DCSP assert _ almost _ equal ( lda.components _ .sum ( axis = 0 ) , np.ones ( lda.components _ .shape &#91; 1 &#93; ) )
DCSP objects _ differ = None DCNL DCSP for ( k , v ) in state _ data &#91; &apos; service &apos; &#93; .items ( ) : DCNL DCSP DCSP if ( k = = &apos; escalation _ policy _ id &apos; ) : DCNL DCSP DCSP DCSP resource _ value = resource _ object &#91; &apos; escalation _ policy &apos; &#93; &#91; &apos; id &apos; &#93; DCNL DCSP DCSP elif ( k = = &apos; service _ key &apos; ) : DCNL DCSP DCSP DCSP resource _ value = resource _ object &#91; &apos; service _ key &apos; &#93; DCNL DCSP DCSP DCSP if ( &apos; @ &apos; in resource _ value ) : DCNL DCSP DCSP DCSP DCSP resource _ value = resource _ value &#91; 0 : resource _ value.find ( &apos; @ &apos; ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP resource _ value = resource _ object &#91; k &#93; DCNL DCSP DCSP if ( v ! = resource _ value ) : DCNL DCSP DCSP DCSP objects _ differ = &apos; { 0 } DCSP { 1 } DCSP { 2 } &apos; .format ( k , v , resource _ value ) DCNL DCSP DCSP DCSP break DCNL DCSP if objects _ differ : DCNL DCSP DCSP return state _ data DCNL DCSP else : DCNL DCSP DCSP return { }
DCSP _ find _ server ( cs , args.server ) .confirm _ resize ( )
DCSP if ( lin _ op.type is lo.NEG ) : DCNL DCSP DCSP result = value DCNL DCSP elif ( lin _ op.type is lo.MUL ) : DCNL DCSP DCSP coeff = mul ( lin _ op.data , { } , True ) DCNL DCSP DCSP if np.isscalar ( coeff ) : DCNL DCSP DCSP DCSP result = ( coeff * value ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = ( coeff.T * value ) DCNL DCSP elif ( lin _ op.type is lo.DIV ) : DCNL DCSP DCSP divisor = mul ( lin _ op.data , { } , True ) DCNL DCSP DCSP result = ( value / divisor ) DCNL DCSP elif ( lin _ op.type is lo.CONV ) : DCNL DCSP DCSP result = conv _ mul ( lin _ op , value , True , True ) DCNL DCSP else : DCNL DCSP DCSP result = op _ tmul ( lin _ op , value ) DCNL DCSP return result
DCSP htmlpage = add _ tagids ( htmlpage ) DCNL DCSP cleaned _ html = descriptify ( htmlpage , baseurl , proxy = proxy _ resources ) DCNL DCSP return cleaned _ html
DCSP obj = ctx . _ _ enter _ _ ( ) DCNL DCSP try : DCNL DCSP DCSP result = fn ( obj , * arg , * * kw ) DCNL DCSP DCSP ctx . _ _ exit _ _ ( None , None , None ) DCNL DCSP DCSP return result DCNL DCSP except : DCNL DCSP DCSP exc _ info = sys.exc _ info ( ) DCNL DCSP DCSP raise _ = ctx . _ _ exit _ _ ( * exc _ info ) DCNL DCSP DCSP if ( raise _ is None ) : DCNL DCSP DCSP DCSP raise DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return raise _
DCSP first _ row = tokens &#91; 0 &#93; &#91; 2 &#93; &#91; 0 &#93; DCNL DCSP nrows = ( ( 1 + tokens &#91; ( -1 ) &#93; &#91; 2 &#93; &#91; 0 &#93; ) - first _ row ) DCNL DCSP if ( noqa or ( nrows = = 1 ) ) : DCNL DCSP DCSP return DCNL DCSP indent _ next = logical _ line.endswith ( &apos; : &apos; ) DCNL DCSP row = depth = 0 DCNL DCSP valid _ hangs = ( ( 4 , ) if ( indent _ char ! = &apos; DCTB &apos; ) else ( 4 , 8 ) ) DCNL DCSP parens = ( &#91; 0 &#93; * nrows ) DCNL DCSP rel _ indent = ( &#91; 0 &#93; * nrows ) DCNL DCSP open _ rows = &#91; &#91; 0 &#93; &#93; DCNL DCSP hangs = &#91; None &#93; DCNL DCSP indent _ chances = { } DCNL DCSP last _ indent = tokens &#91; 0 &#93; &#91; 2 &#93; DCNL DCSP visual _ indent = None DCNL DCSP last _ token _ multiline = False DCNL DCSP indent = &#91; last _ indent &#91; 1 &#93; &#93; DCNL DCSP if ( verbose &gt; = 3 ) : DCNL DCSP DCSP print ( &apos; &gt; &gt; &gt; DCSP &apos; + tokens &#91; 0 &#93; &#91; 4 &#93; .rstrip ( ) ) DCNL DCSP for ( token _ type , text , start , end , line ) in tokens : DCNL DCSP DCSP newline = ( row &lt; ( start &#91; 0 &#93; - first _ row ) ) DCNL DCSP DCSP if newline : DCNL DCSP DCSP DCSP row = ( start &#91; 0 &#93; - first _ row ) DCNL DCSP DCSP DCSP newline = ( ( not last _ token _ multiline ) and ( token _ type not in NEWLINE ) ) DCNL DCSP DCSP if newline : DCNL DCSP DCSP DCSP last _ indent = start DCNL DCSP DCSP DCSP if ( verbose &gt; = 3 ) : DCNL DCSP DCSP DCSP DCSP print ( &apos; ... DCSP &apos; + line.rstrip ( ) ) DCNL DCSP DCSP DCSP rel _ indent &#91; row &#93; = ( expand _ indent ( line ) - indent _ level ) DCNL DCSP DCSP DCSP close _ bracket = ( ( token _ type = = tokenize.OP ) and ( text in &apos; &#93; } ) &apos; ) ) DCNL DCSP DCSP DCSP for open _ row in reversed ( open _ rows &#91; depth &#93; ) : DCNL DCSP DCSP DCSP DCSP hang = ( rel _ indent &#91; row &#93; - rel _ indent &#91; open _ row &#93; ) DCNL DCSP DCSP DCSP DCSP hanging _ indent = ( hang in valid _ hangs ) DCNL DCSP DCSP DCSP DCSP if hanging _ indent : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP if hangs &#91; depth &#93; : DCNL DCSP DCSP DCSP DCSP hanging _ indent = ( hang = = hangs &#91; depth &#93; ) DCNL DCSP DCSP DCSP visual _ indent = ( ( not close _ bracket ) and ( hang &gt; 0 ) and indent _ chances.get ( start &#91; 1 &#93; ) ) DCNL DCSP DCSP DCSP if ( close _ bracket and indent &#91; depth &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( start &#91; 1 &#93; ! = indent &#91; depth &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( start , &apos; E124 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP visual DCSP indentation &apos; ) ) DCNL DCSP DCSP DCSP elif ( close _ bracket and ( not hang ) ) : DCNL DCSP DCSP DCSP DCSP if hang _ closing : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( start , &apos; E133 DCSP closing DCSP bracket DCSP is DCSP missing DCSP indentation &apos; ) ) DCNL DCSP DCSP DCSP elif ( indent &#91; depth &#93; and ( start &#91; 1 &#93; &lt; indent &#91; depth &#93; ) ) : DCNL DCSP DCSP DCSP DCSP if ( visual _ indent is not True ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( start , &apos; E128 DCSP continuation DCSP line DCSP under-indented DCSP for DCSP visual DCSP indent &apos; ) ) DCNL DCSP DCSP DCSP elif ( hanging _ indent or ( indent _ next and ( rel _ indent &#91; row &#93; = = 8 ) ) ) : DCNL DCSP DCSP DCSP DCSP if ( close _ bracket and ( not hang _ closing ) ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( start , &quot; E123 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP indentation DCSP of DCSP opening DCSP bracket &apos;s DCSP line &quot; ) ) DCNL DCSP DCSP DCSP DCSP hangs &#91; depth &#93; = hang DCNL DCSP DCSP DCSP elif ( visual _ indent is True ) : DCNL DCSP DCSP DCSP DCSP indent &#91; depth &#93; = start &#91; 1 &#93; DCNL DCSP DCSP DCSP elif ( visual _ indent in ( text , str ) ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( hang &lt; = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP error = ( &apos; E122 &apos; , &apos; missing DCSP indentation DCSP or DCSP outdented &apos; ) DCNL DCSP DCSP DCSP DCSP elif indent &#91; depth &#93; : DCNL DCSP DCSP DCSP DCSP DCSP error = ( &apos; E127 &apos; , &apos; over-indented DCSP for DCSP visual DCSP indent &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( ( not close _ bracket ) and hangs &#91; depth &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP error = ( &apos; E131 &apos; , &apos; unaligned DCSP for DCSP hanging DCSP indent &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP hangs &#91; depth &#93; = hang DCNL DCSP DCSP DCSP DCSP DCSP if ( hang &gt; 4 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP error = ( &apos; E126 &apos; , &apos; over-indented DCSP for DCSP hanging DCSP indent &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP error = ( &apos; E121 &apos; , &apos; under-indented DCSP for DCSP hanging DCSP indent &apos; ) DCNL DCSP DCSP DCSP DCSP ( yield ( start , ( &apos; % s DCSP continuation DCSP line DCSP % s &apos; % error ) ) ) DCNL DCSP DCSP if ( parens &#91; row &#93; and ( token _ type not in ( tokenize.NL , tokenize.COMMENT ) ) and ( not indent &#91; depth &#93; ) ) : DCNL DCSP DCSP DCSP indent &#91; depth &#93; = start &#91; 1 &#93; DCNL DCSP DCSP DCSP indent _ chances &#91; start &#91; 1 &#93; &#93; = True DCNL DCSP DCSP DCSP if ( verbose &gt; = 4 ) : DCNL DCSP DCSP DCSP DCSP print ( &apos; bracket DCSP depth DCSP % s DCSP indent DCSP to DCSP % s &apos; % ( depth , start &#91; 1 &#93; ) ) DCNL DCSP DCSP elif ( ( token _ type in ( tokenize.STRING , tokenize.COMMENT ) ) or ( text in ( &apos; u &apos; , &apos; ur &apos; , &apos; b &apos; , &apos; br &apos; ) ) ) : DCNL DCSP DCSP DCSP indent _ chances &#91; start &#91; 1 &#93; &#93; = str DCNL DCSP DCSP elif ( ( not indent _ chances ) and ( not row ) and ( not depth ) and ( text = = &apos; if &apos; ) ) : DCNL DCSP DCSP DCSP indent _ chances &#91; ( end &#91; 1 &#93; + 1 ) &#93; = True DCNL DCSP DCSP elif ( ( text = = &apos; : &apos; ) and line &#91; end &#91; 1 &#93; : &#93; .isspace ( ) ) : DCNL DCSP DCSP DCSP open _ rows &#91; depth &#93; .append ( row ) DCNL DCSP DCSP if ( token _ type = = tokenize.OP ) : DCNL DCSP DCSP DCSP if ( text in &apos; ( &#91; { &apos; ) : DCNL DCSP DCSP DCSP DCSP depth + = 1 DCNL DCSP DCSP DCSP DCSP indent.append ( 0 ) DCNL DCSP DCSP DCSP DCSP hangs.append ( None ) DCNL DCSP DCSP DCSP DCSP if ( len ( open _ rows ) = = depth ) : DCNL DCSP DCSP DCSP DCSP DCSP open _ rows.append ( &#91; &#93; ) DCNL DCSP DCSP DCSP DCSP open _ rows &#91; depth &#93; .append ( row ) DCNL DCSP DCSP DCSP DCSP parens &#91; row &#93; + = 1 DCNL DCSP DCSP DCSP DCSP if ( verbose &gt; = 4 ) : DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; bracket DCSP depth DCSP % s DCSP seen , DCSP col DCSP % s , DCSP visual DCSP min DCSP = DCSP % s &apos; % ( depth , start &#91; 1 &#93; , indent &#91; depth &#93; ) ) DCNL DCSP DCSP DCSP elif ( ( text in &apos; ) &#93; } &apos; ) and ( depth &gt; 0 ) ) : DCNL DCSP DCSP DCSP DCSP prev _ indent = ( indent.pop ( ) or last _ indent &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP hangs.pop ( ) DCNL DCSP DCSP DCSP DCSP for d in range ( depth ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( indent &#91; d &#93; &gt; prev _ indent ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP indent &#91; d &#93; = 0 DCNL DCSP DCSP DCSP DCSP for ind in list ( indent _ chances ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ind &gt; = prev _ indent ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP del indent _ chances &#91; ind &#93; DCNL DCSP DCSP DCSP DCSP del open _ rows &#91; ( depth + 1 ) : &#93; DCNL DCSP DCSP DCSP DCSP depth - = 1 DCNL DCSP DCSP DCSP DCSP if depth : DCNL DCSP DCSP DCSP DCSP DCSP indent _ chances &#91; indent &#91; depth &#93; &#93; = True DCNL DCSP DCSP DCSP DCSP for idx in range ( row , ( -1 ) , ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if parens &#91; idx &#93; : DCNL DCSP DCSP DCSP DCSP DCSP DCSP parens &#91; idx &#93; - = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP assert ( len ( indent ) = = ( depth + 1 ) ) DCNL DCSP DCSP DCSP if ( start &#91; 1 &#93; not in indent _ chances ) : DCNL DCSP DCSP DCSP DCSP indent _ chances &#91; start &#91; 1 &#93; &#93; = text DCNL DCSP DCSP last _ token _ multiline = ( start &#91; 0 &#93; ! = end &#91; 0 &#93; ) DCNL DCSP DCSP if last _ token _ multiline : DCNL DCSP DCSP DCSP rel _ indent &#91; ( end &#91; 0 &#93; - first _ row ) &#93; = rel _ indent &#91; row &#93; DCNL DCSP if ( indent _ next and ( expand _ indent ( line ) = = ( indent _ level + 4 ) ) ) : DCNL DCSP DCSP pos = ( start &#91; 0 &#93; , ( indent &#91; 0 &#93; + 4 ) ) DCNL DCSP DCSP if visual _ indent : DCNL DCSP DCSP DCSP code = &apos; E129 DCSP visually DCSP indented DCSP line &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP code = &apos; E125 DCSP continuation DCSP line &apos; DCNL DCSP DCSP ( yield ( pos , ( &apos; % s DCSP with DCSP same DCSP indent DCSP as DCSP next DCSP logical DCSP line &apos; % code ) ) )
DCSP mock _ read _ user = mocker.patch ( &apos; cookiecutter.vcs.read _ user _ yes _ no &apos; , return _ value = True , autospec = True ) DCNL DCSP repo _ dir = tmpdir.mkdir ( &apos; repo &apos; ) DCNL DCSP vcs.prompt _ and _ delete _ repo ( str ( repo _ dir ) ) DCNL DCSP assert mock _ read _ user.called DCNL DCSP assert ( not repo _ dir.exists ( ) )
DCSP return np.modf ( x ) &#91; 1 &#93;
DCSP from dipy.denoise.nlmeans import nlmeans DCNL DCSP from scipy.ndimage.morphology import binary _ erosion DCNL DCSP from scipy import ndimage DCNL DCSP if ( out _ file is None ) : DCNL DCSP DCSP ( fname , fext ) = op.splitext ( op.basename ( in _ file ) ) DCNL DCSP DCSP if ( fext = = u &apos; .gz &apos; ) : DCNL DCSP DCSP DCSP ( fname , fext2 ) = op.splitext ( fname ) DCNL DCSP DCSP DCSP fext = ( fext2 + fext ) DCNL DCSP DCSP out _ file = op.abspath ( ( u &apos; . / % s _ denoise % s &apos; % ( fname , fext ) ) ) DCNL DCSP img = nb.load ( in _ file ) DCNL DCSP hdr = img.header DCNL DCSP data = img.get _ data ( ) DCNL DCSP aff = img.affine DCNL DCSP if ( data.ndim &lt; 4 ) : DCNL DCSP DCSP data = data &#91; ... , np.newaxis &#93; DCNL DCSP data = np.nan _ to _ num ( data ) DCNL DCSP if ( data.max ( ) &lt; 0.0001 ) : DCNL DCSP DCSP raise RuntimeError ( u &apos;There DCSP is DCSP no DCSP signal DCSP in DCSP the DCSP image &apos; ) DCNL DCSP df = 1.0 DCNL DCSP if ( data.max ( ) &lt; 1000.0 ) : DCNL DCSP DCSP df = ( 1000.0 / data.max ( ) ) DCNL DCSP DCSP data * = df DCNL DCSP b0 = data &#91; ... , 0 &#93; DCNL DCSP if ( smask is None ) : DCNL DCSP DCSP smask = np.zeros _ like ( b0 ) DCNL DCSP DCSP smask &#91; ( b0 &gt; np.percentile ( b0 , 85.0 ) ) &#93; = 1 DCNL DCSP smask = binary _ erosion ( smask.astype ( np.uint8 ) , iterations = 2 ) .astype ( np.uint8 ) DCNL DCSP if ( nmask is None ) : DCNL DCSP DCSP nmask = np.ones _ like ( b0 , dtype = np.uint8 ) DCNL DCSP DCSP bmask = settings &#91; u &apos;mask &apos; &#93; DCNL DCSP DCSP if ( bmask is None ) : DCNL DCSP DCSP DCSP bmask = np.zeros _ like ( b0 ) DCNL DCSP DCSP DCSP bmask &#91; ( b0 &gt; np.percentile ( b0 &#91; ( b0 &gt; 0 ) &#93; , 10 ) ) &#93; = 1 DCNL DCSP DCSP DCSP ( label _ im , nb _ labels ) = ndimage.label ( bmask ) DCNL DCSP DCSP DCSP sizes = ndimage.sum ( bmask , label _ im , range ( ( nb _ labels + 1 ) ) ) DCNL DCSP DCSP DCSP maxidx = np.argmax ( sizes ) DCNL DCSP DCSP DCSP bmask = np.zeros _ like ( b0 , dtype = np.uint8 ) DCNL DCSP DCSP DCSP bmask &#91; ( label _ im = = maxidx ) &#93; = 1 DCNL DCSP DCSP nmask &#91; ( bmask &gt; 0 ) &#93; = 0 DCNL DCSP else : DCNL DCSP DCSP nmask = np.squeeze ( nmask ) DCNL DCSP DCSP nmask &#91; ( nmask &gt; 0.0 ) &#93; = 1 DCNL DCSP DCSP nmask &#91; ( nmask &lt; 1 ) &#93; = 0 DCNL DCSP DCSP nmask = nmask.astype ( bool ) DCNL DCSP nmask = binary _ erosion ( nmask , iterations = 1 ) .astype ( np.uint8 ) DCNL DCSP den = np.zeros _ like ( data ) DCNL DCSP est _ snr = True DCNL DCSP if ( snr is not None ) : DCNL DCSP DCSP snr = ( &#91; snr &#93; * data.shape &#91; ( -1 ) &#93; ) DCNL DCSP DCSP est _ snr = False DCNL DCSP else : DCNL DCSP DCSP snr = &#91; &#93; DCNL DCSP for i in range ( data.shape &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP d = data &#91; ... , i &#93; DCNL DCSP DCSP if est _ snr : DCNL DCSP DCSP DCSP s = np.mean ( d &#91; ( smask &gt; 0 ) &#93; ) DCNL DCSP DCSP DCSP n = np.std ( d &#91; ( nmask &gt; 0 ) &#93; ) DCNL DCSP DCSP DCSP snr.append ( ( s / n ) ) DCNL DCSP DCSP den &#91; ... , i &#93; = nlmeans ( d , snr &#91; i &#93; , * * settings ) DCNL DCSP den = np.squeeze ( den ) DCNL DCSP den / = df DCNL DCSP nb.Nifti1Image ( den.astype ( hdr.get _ data _ dtype ( ) ) , aff , hdr ) .to _ filename ( out _ file ) DCNL DCSP return ( out _ file , snr )
DCSP cmd = &apos; --get-zones &apos; DCNL DCSP if permanent : DCNL DCSP DCSP cmd + = &apos; DCSP --permanent &apos; DCNL DCSP return _ _ firewall _ cmd ( cmd ) .split ( )
DCSP p &#91; 0 &#93; = p &#91; 1 &#93;
DCSP if ( sys.version _ info &gt; = ( 3 , 3 ) ) : DCNL DCSP DCSP import shutil DCNL DCSP DCSP shutil _ get _ terminal _ size = getattr ( shutil , &apos; get _ terminal _ size &apos; , None ) DCNL DCSP DCSP if shutil _ get _ terminal _ size : DCNL DCSP DCSP DCSP sz = shutil _ get _ terminal _ size ( ) DCNL DCSP DCSP DCSP return ( sz.columns , sz.lines ) DCNL DCSP if ( get _ winterm _ size is not None ) : DCNL DCSP DCSP return get _ winterm _ size ( ) DCNL DCSP def ioctl _ gwinsz ( fd ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP import fcntl DCNL DCSP DCSP DCSP import termios DCNL DCSP DCSP DCSP cr = struct.unpack ( &apos; hh &apos; , fcntl.ioctl ( fd , termios.TIOCGWINSZ , &apos; 1234 &apos; ) ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP return cr DCNL DCSP cr = ( ioctl _ gwinsz ( 0 ) or ioctl _ gwinsz ( 1 ) or ioctl _ gwinsz ( 2 ) ) DCNL DCSP if ( not cr ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP fd = os.open ( os.ctermid ( ) , os.O _ RDONLY ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP cr = ioctl _ gwinsz ( fd ) DCNL DCSP DCSP DCSP finally : DCNL DCSP DCSP DCSP DCSP os.close ( fd ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass DCNL DCSP if ( ( not cr ) or ( not cr &#91; 0 &#93; ) or ( not cr &#91; 1 &#93; ) ) : DCNL DCSP DCSP cr = ( os.environ.get ( &apos; LINES &apos; , 25 ) , os.environ.get ( &apos; COLUMNS &apos; , DEFAULT _ COLUMNS ) ) DCNL DCSP return ( int ( cr &#91; 1 &#93; ) , int ( cr &#91; 0 &#93; ) )
DCSP forward _ relations = OrderedDict ( ) DCNL DCSP for field in &#91; field for field in opts.fields if ( field.serialize and get _ remote _ field ( field ) ) &#93; : DCNL DCSP DCSP forward _ relations &#91; field.name &#93; = RelationInfo ( model _ field = field , related _ model = get _ related _ model ( field ) , to _ many = False , to _ field = _ get _ to _ field ( field ) , has _ through _ model = False , reverse = False ) DCNL DCSP for field in &#91; field for field in opts.many _ to _ many if field.serialize &#93; : DCNL DCSP DCSP forward _ relations &#91; field.name &#93; = RelationInfo ( model _ field = field , related _ model = get _ related _ model ( field ) , to _ many = True , to _ field = None , has _ through _ model = ( not get _ remote _ field ( field ) .through. _ meta.auto _ created ) , reverse = False ) DCNL DCSP return forward _ relations
DCSP LOG.debug ( _ ( &apos; get _ qos ( ) DCSP called &apos; ) ) DCNL DCSP session = db.get _ session ( ) DCNL DCSP try : DCNL DCSP DCSP qos = session.query ( l2network _ models.QoS ) .filter _ by ( tenant _ id = tenant _ id ) .filter _ by ( qos _ id = qos _ id ) .one ( ) DCNL DCSP DCSP return qos DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP raise c _ exc.QosNotFound ( qos _ id = qos _ id , tenant _ id = tenant _ id )
DCSP def get _ rel _ path ( base , path ) : DCNL DCSP DCSP base = base.replace ( os.path.sep , &apos; / &apos; ) DCNL DCSP DCSP path = path.replace ( os.path.sep , &apos; / &apos; ) DCNL DCSP DCSP assert path.startswith ( base ) DCNL DCSP DCSP return path &#91; len ( base ) : &#93; .lstrip ( &apos; / &apos; ) DCNL DCSP destinations = { } DCNL DCSP for ( base , suffix , dest ) in rules : DCNL DCSP DCSP prefix = os.path.join ( resources _ root , base ) DCNL DCSP DCSP for abs _ base in iglob ( prefix ) : DCNL DCSP DCSP DCSP abs _ glob = os.path.join ( abs _ base , suffix ) DCNL DCSP DCSP DCSP for abs _ path in iglob ( abs _ glob ) : DCNL DCSP DCSP DCSP DCSP resource _ file = get _ rel _ path ( resources _ root , abs _ path ) DCNL DCSP DCSP DCSP DCSP if ( dest is None ) : DCNL DCSP DCSP DCSP DCSP DCSP destinations.pop ( resource _ file , None ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP rel _ path = get _ rel _ path ( abs _ base , abs _ path ) DCNL DCSP DCSP DCSP DCSP DCSP rel _ dest = dest.replace ( os.path.sep , &apos; / &apos; ) .rstrip ( &apos; / &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP destinations &#91; resource _ file &#93; = ( ( rel _ dest + &apos; / &apos; ) + rel _ path ) DCNL DCSP return destinations
DCSP if ( not alert _ id ) : DCNL DCSP DCSP return False DCNL DCSP table = current.s3db.cap _ alert DCNL DCSP query = ( table.id = = alert _ id ) DCNL DCSP r = current.db ( query ) .select ( table.is _ template , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP return ( r and r.is _ template )
DCSP return add _ action ( widget , N _ ( u &apos;Close ... &apos; ) , widget.close , hotkeys.CLOSE , hotkeys.QUIT )
DCSP if ( not is _ memcache _ running ( ) ) : DCNL DCSP DCSP msg = colorize ( &apos; red &apos; , &apos; Memcache DCSP is DCSP not DCSP running DCSP locally . &apos; ) DCNL DCSP DCSP print msg DCNL DCSP DCSP sys.exit ( 1 )
DCSP funcobj . _ _ isabstractmethod _ _ = True DCNL DCSP return funcobj
DCSP operators = getattr ( app.data , &apos; operators &apos; , set ( ) ) DCNL DCSP allowed = ( config.DOMAIN &#91; resource &#93; &#91; &apos; allowed _ filters &apos; &#93; + list ( operators ) ) DCNL DCSP def validate _ filter ( filter ) : DCNL DCSP DCSP for ( key , value ) in filter.items ( ) : DCNL DCSP DCSP DCSP if ( ( &apos; * &apos; not in allowed ) and ( key not in allowed ) ) : DCNL DCSP DCSP DCSP DCSP return ( &quot; filter DCSP on DCSP &apos; % s &apos; DCSP not DCSP allowed &quot; % key ) DCNL DCSP DCSP DCSP if ( key in ( &apos; $ or &apos; , &apos; $ and &apos; , &apos; $ nor &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( value , list ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return ( &quot; operator DCSP &apos; % s &apos; DCSP expects DCSP a DCSP list DCSP of DCSP sub-queries &quot; % key ) DCNL DCSP DCSP DCSP DCSP for v in value : DCNL DCSP DCSP DCSP DCSP DCSP if ( not isinstance ( v , dict ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return ( &quot; operator DCSP &apos; % s &apos; DCSP expects DCSP a DCSP list DCSP of DCSP sub-queries &quot; % key ) DCNL DCSP DCSP DCSP DCSP DCSP r = validate _ filter ( v ) DCNL DCSP DCSP DCSP DCSP DCSP if r : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return r DCNL DCSP DCSP DCSP elif config.VALIDATE _ FILTERS : DCNL DCSP DCSP DCSP DCSP res _ schema = config.DOMAIN &#91; resource &#93; &#91; &apos; schema &apos; &#93; DCNL DCSP DCSP DCSP DCSP if ( key not in res _ schema ) : DCNL DCSP DCSP DCSP DCSP DCSP return &quot; filter DCSP on DCSP &apos; % s &apos; DCSP is DCSP invalid &quot; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP field _ schema = res _ schema.get ( key ) DCNL DCSP DCSP DCSP DCSP DCSP v = Validator ( { key : field _ schema } ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not v.validate ( { key : value } ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return &quot; filter DCSP on DCSP &apos; % s &apos; DCSP is DCSP invalid &quot; DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return None DCNL DCSP if ( ( &apos; * &apos; in allowed ) and ( not config.VALIDATE _ FILTERS ) ) : DCNL DCSP DCSP return None DCNL DCSP return validate _ filter ( where )
DCSP script.pip ( &apos; install &apos; , &apos; -f &apos; , data.find _ links , &apos; --no-index &apos; , &apos; simple = = 1.0 &apos; ) DCNL DCSP result = script.pip ( &apos; install &apos; , &apos; -e &apos; , &apos; git + https : / / github.com / pypa / pip-test-package.git # egg = pip-test-package &apos; ) DCNL DCSP result = script.pip ( &apos; list &apos; , &apos; -f &apos; , data.find _ links , &apos; --no-index &apos; , &apos; --editable &apos; , &apos; --uptodate &apos; , &apos; --format = legacy &apos; ) DCNL DCSP assert ( &apos; simple DCSP ( 1.0 ) &apos; not in result.stdout ) , str ( result ) DCNL DCSP assert ( os.path.join ( &apos; src &apos; , &apos; pip-test-package &apos; ) in result.stdout ) , str ( result )
DCSP total _ size = 0 DCNL DCSP if os.path.isdir ( real _ path ) : DCNL DCSP DCSP for ( dirpath , dirnames , filenames ) in os.walk ( real _ path ) : DCNL DCSP DCSP DCSP for filename in filenames : DCNL DCSP DCSP DCSP DCSP total _ size + = os.path.getsize ( os.path.join ( dirpath , filename ) ) DCNL DCSP else : DCNL DCSP DCSP total _ size + = os.path.getsize ( real _ path ) DCNL DCSP return total _ size
DCSP path = &apos; / &apos; .join ( map ( partial ( replace , &apos; pull &apos; , &apos; pulls &apos; ) , url _ path _ parts ( url ) ) ) DCNL DCSP return ( ( API _ BASE _ URL + REPOS _ API _ PATH ) + path )
DCSP if ( not session ) : DCNL DCSP DCSP session = client _ session.Session. _ construct ( kwargs ) DCNL DCSP d = discover.Discover ( session = session , * * kwargs ) DCNL DCSP return d.create _ client ( version = version , unstable = unstable )
DCSP return None
DCSP context = get _ jinja _ context ( ) DCNL DCSP icon _ classes = SocialMediaLinksPlugin.icon _ classes DCNL DCSP link _ 1 _ type = &apos; Facebook &apos; DCNL DCSP link _ 1 = { &apos; url &apos; : &apos; http : / / www.facebook.com &apos; , &apos; ordering &apos; : 2 } DCNL DCSP link _ 2 _ type = &apos; Twitter &apos; DCNL DCSP link _ 2 = { &apos; url &apos; : &apos; http : / / www.twitter.com &apos; , &apos; ordering &apos; : 1 } DCNL DCSP links = { link _ 1 _ type : link _ 1 , link _ 2 _ type : link _ 2 } DCNL DCSP plugin = SocialMediaLinksPlugin ( { &apos; links &apos; : links } ) DCNL DCSP assert ( len ( plugin.get _ links ( ) ) = = 2 ) DCNL DCSP assert ( plugin.get _ links ( ) &#91; 0 &#93; &#91; 2 &#93; = = link _ 2 &#91; &apos; url &apos; &#93; )
DCSP conf = settings.CACHES.get ( backend , None ) DCNL DCSP if ( conf is not None ) : DCNL DCSP DCSP args = conf.copy ( ) DCNL DCSP DCSP args.update ( kwargs ) DCNL DCSP DCSP backend = args.pop ( &apos; BACKEND &apos; ) DCNL DCSP DCSP location = args.pop ( &apos; LOCATION &apos; , &apos; &apos; ) DCNL DCSP DCSP return ( backend , location , args ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( mod _ path , cls _ name ) = backend.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP DCSP DCSP mod = importlib.import _ module ( mod _ path ) DCNL DCSP DCSP DCSP backend _ cls = getattr ( mod , cls _ name ) DCNL DCSP DCSP except ( AttributeError , ImportError , ValueError ) : DCNL DCSP DCSP DCSP raise InvalidCacheBackendError ( ( &quot; Could DCSP not DCSP find DCSP backend DCSP &apos; % s &apos; &quot; % backend ) ) DCNL DCSP DCSP location = kwargs.pop ( &apos; LOCATION &apos; , &apos; &apos; ) DCNL DCSP DCSP return ( backend , location , kwargs ) DCNL DCSP raise InvalidCacheBackendError ( ( &quot; Couldn &apos;t DCSP find DCSP a DCSP cache DCSP backend DCSP named DCSP &apos; % s &apos; &quot; % backend ) )
DCSP sys = kwds.get ( &apos; sys &apos; , _ sys ) DCNL DCSP assert ( sys is not None ) DCNL DCSP p = shell _ process ( cmds , env , * * kwds ) DCNL DCSP if redirecting _ io ( sys = sys ) : DCNL DCSP DCSP redirect _ aware _ commmunicate ( p , sys = sys ) DCNL DCSP DCSP exit = p.returncode DCNL DCSP DCSP return exit DCNL DCSP else : DCNL DCSP DCSP return p.wait ( )
DCSP return Timestamp ( timestamp ) .normal
DCSP if ( &apos; message _ parser &apos; in dir ( hangups ) ) : DCNL DCSP DCSP segments = hangups.ChatMessageSegment.from _ str ( formatted _ text ) DCNL DCSP else : DCNL DCSP DCSP segments = kludgy _ html _ parser.simple _ parse _ to _ segments ( formatted _ text ) DCNL DCSP return segments
DCSP if ( len ( projs ) = = 0 ) : DCNL DCSP DCSP return DCNL DCSP start _ block ( fid , FIFF.FIFFB _ PROJ ) DCNL DCSP for proj in projs : DCNL DCSP DCSP start _ block ( fid , FIFF.FIFFB _ PROJ _ ITEM ) DCNL DCSP DCSP write _ int ( fid , FIFF.FIFF _ NCHAN , proj &#91; &apos; data &apos; &#93; &#91; &apos; ncol &apos; &#93; ) DCNL DCSP DCSP write _ name _ list ( fid , FIFF.FIFF _ PROJ _ ITEM _ CH _ NAME _ LIST , proj &#91; &apos; data &apos; &#93; &#91; &apos; col _ names &apos; &#93; ) DCNL DCSP DCSP write _ string ( fid , FIFF.FIFF _ NAME , proj &#91; &apos; desc &apos; &#93; ) DCNL DCSP DCSP write _ int ( fid , FIFF.FIFF _ PROJ _ ITEM _ KIND , proj &#91; &apos; kind &apos; &#93; ) DCNL DCSP DCSP if ( proj &#91; &apos; kind &apos; &#93; = = FIFF.FIFFV _ PROJ _ ITEM _ FIELD ) : DCNL DCSP DCSP DCSP write _ float ( fid , FIFF.FIFF _ PROJ _ ITEM _ TIME , 0.0 ) DCNL DCSP DCSP write _ int ( fid , FIFF.FIFF _ PROJ _ ITEM _ NVEC , proj &#91; &apos; data &apos; &#93; &#91; &apos; nrow &apos; &#93; ) DCNL DCSP DCSP write _ int ( fid , FIFF.FIFF _ MNE _ PROJ _ ITEM _ ACTIVE , proj &#91; &apos; active &apos; &#93; ) DCNL DCSP DCSP write _ float _ matrix ( fid , FIFF.FIFF _ PROJ _ ITEM _ VECTORS , proj &#91; &apos; data &apos; &#93; &#91; &apos; data &apos; &#93; ) DCNL DCSP DCSP if ( proj &#91; &apos; explained _ var &apos; &#93; is not None ) : DCNL DCSP DCSP DCSP write _ float ( fid , FIFF.FIFF _ MNE _ ICA _ PCA _ EXPLAINED _ VAR , proj &#91; &apos; explained _ var &apos; &#93; ) DCNL DCSP DCSP end _ block ( fid , FIFF.FIFFB _ PROJ _ ITEM ) DCNL DCSP end _ block ( fid , FIFF.FIFFB _ PROJ )
DCSP db.execute ( &apos; BEGIN &apos; ) DCNL DCSP for table in ( &apos; point &apos; , &apos; line &apos; , &apos; roads &apos; , &apos; polygon &apos; ) : DCNL DCSP DCSP db.execute ( ( &apos; DROP DCSP TABLE DCSP % ( tmp _ prefix ) s _ % ( table ) s &apos; % locals ( ) ) ) DCNL DCSP DCSP db.execute ( ( &quot; DELETE DCSP FROM DCSP geometry _ columns DCSP WHERE DCSP f _ table _ name DCSP = DCSP &apos; % ( tmp _ prefix ) s _ % ( table ) s &apos; &quot; % locals ( ) ) ) DCNL DCSP db.execute ( &apos; COMMIT &apos; )
DCSP global global _ siteurl DCNL DCSP global _ siteurl = generator.settings &#91; &apos; SITEURL &apos; &#93;
DCSP paths = &#91; &#93; DCNL DCSP for dir in SEARCH _ DIRS : DCNL DCSP DCSP if ( ( not os.path.isdir ( dir ) ) or ( not os.access ( dir , os.R _ OK ) ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for name in os.listdir ( dir ) : DCNL DCSP DCSP DCSP subdir = os.path.join ( dir , name ) DCNL DCSP DCSP DCSP if ( ( not os.path.isdir ( subdir ) ) or ( not os.access ( subdir , os.R _ OK ) ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for subname in os.listdir ( subdir ) : DCNL DCSP DCSP DCSP DCSP path = os.path.join ( subdir , subname ) DCNL DCSP DCSP DCSP DCSP if utils.is _ sockfile ( path ) : DCNL DCSP DCSP DCSP DCSP DCSP paths.append ( path ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP for sockfile in DEFAULT _ SOCKFILES : DCNL DCSP DCSP if ( not utils.is _ sockfile ( sockfile ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP paths.append ( sockfile ) DCNL DCSP return paths
DCSP def wraps ( self , * args , * * kwargs ) : DCNL DCSP DCSP if ( kwargs.get ( &apos; base _ dir &apos; , None ) is None ) : DCNL DCSP DCSP DCSP return func ( self , * args , * * kwargs ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for c in self . _ _ class _ _ . _ _ mro _ _ : DCNL DCSP DCSP DCSP DCSP if ( c . _ _ name _ _ = = &apos; DiskObjectStore &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP return getattr ( c , func . _ _ name _ _ ) ( self , * args , * * kwargs ) DCNL DCSP DCSP DCSP raise Exception ( ( &quot; Could DCSP not DCSP call DCSP DiskObjectStore &apos;s DCSP % s DCSP method , DCSP does DCSP your DCSP Object DCSP Store DCSP plugin DCSP inherit DCSP from DCSP DiskObjectStore ? &quot; % func . _ _ name _ _ ) ) DCNL DCSP return wraps
DCSP ( V , E ) = graph DCNL DCSP L = &#91; &#93; DCNL DCSP S = set ( V ) DCNL DCSP E = list ( E ) DCNL DCSP for ( v , u ) in E : DCNL DCSP DCSP S.discard ( u ) DCNL DCSP if ( key is None ) : DCNL DCSP DCSP key = ( lambda value : value ) DCNL DCSP S = sorted ( S , key = key , reverse = True ) DCNL DCSP while S : DCNL DCSP DCSP node = S.pop ( ) DCNL DCSP DCSP L.append ( node ) DCNL DCSP DCSP for ( u , v ) in list ( E ) : DCNL DCSP DCSP DCSP if ( u = = node ) : DCNL DCSP DCSP DCSP DCSP E.remove ( ( u , v ) ) DCNL DCSP DCSP DCSP DCSP for ( _ u , _ v ) in E : DCNL DCSP DCSP DCSP DCSP DCSP if ( v = = _ v ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP kv = key ( v ) DCNL DCSP DCSP DCSP DCSP DCSP for ( i , s ) in enumerate ( S ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ks = key ( s ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( kv &gt; ks ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP S.insert ( i , v ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP S.append ( v ) DCNL DCSP if E : DCNL DCSP DCSP raise ValueError ( &apos; cycle DCSP detected &apos; ) DCNL DCSP else : DCNL DCSP DCSP return L
DCSP _ = i18n.ugettext DCNL DCSP utf8 _ parser = etree.XMLParser ( encoding = &apos; utf-8 &apos; ) DCNL DCSP youtube _ text _ api = copy.deepcopy ( settings.YOUTUBE &#91; &apos; TEXT _ API &apos; &#93; ) DCNL DCSP youtube _ text _ api &#91; &apos; params &apos; &#93; &#91; &apos; v &apos; &#93; = youtube _ id DCNL DCSP youtube _ transcript _ name = youtube _ video _ transcript _ name ( youtube _ text _ api ) DCNL DCSP if youtube _ transcript _ name : DCNL DCSP DCSP youtube _ text _ api &#91; &apos; params &apos; &#93; &#91; &apos; name &apos; &#93; = youtube _ transcript _ name DCNL DCSP data = requests.get ( ( &apos; http : / / &apos; + youtube _ text _ api &#91; &apos; url &apos; &#93; ) , params = youtube _ text _ api &#91; &apos; params &apos; &#93; ) DCNL DCSP if ( ( data.status _ code ! = 200 ) or ( not data.text ) ) : DCNL DCSP DCSP msg = _ ( &quot; Can &apos;t DCSP receive DCSP transcripts DCSP from DCSP Youtube DCSP for DCSP { youtube _ id } . DCSP Status DCSP code : DCSP { status _ code } . &quot; ) .format ( youtube _ id = youtube _ id , status _ code = data.status _ code ) DCNL DCSP DCSP raise GetTranscriptsFromYouTubeException ( msg ) DCNL DCSP ( sub _ starts , sub _ ends , sub _ texts ) = ( &#91; &#93; , &#91; &#93; , &#91; &#93; ) DCNL DCSP xmltree = etree.fromstring ( data.content , parser = utf8 _ parser ) DCNL DCSP for element in xmltree : DCNL DCSP DCSP if ( element.tag = = &apos; text &apos; ) : DCNL DCSP DCSP DCSP start = float ( element.get ( &apos; start &apos; ) ) DCNL DCSP DCSP DCSP duration = float ( element.get ( &apos; dur &apos; , 0 ) ) DCNL DCSP DCSP DCSP text = element.text DCNL DCSP DCSP DCSP end = ( start + duration ) DCNL DCSP DCSP DCSP if text : DCNL DCSP DCSP DCSP DCSP sub _ starts.append ( int ( ( start * 1000 ) ) ) DCNL DCSP DCSP DCSP DCSP sub _ ends.append ( int ( ( ( end + 0.0001 ) * 1000 ) ) ) DCNL DCSP DCSP DCSP DCSP sub _ texts.append ( text.replace ( &apos; \ n &apos; , &apos; DCSP &apos; ) ) DCNL DCSP return { &apos; start &apos; : sub _ starts , &apos; end &apos; : sub _ ends , &apos; text &apos; : sub _ texts }
DCSP coreprops = makeelement ( &apos; coreProperties &apos; , nsprefix = &apos; cp &apos; ) DCNL DCSP coreprops.append ( makeelement ( &apos; title &apos; , tagtext = title , nsprefix = &apos; dc &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; subject &apos; , tagtext = subject , nsprefix = &apos; dc &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; creator &apos; , tagtext = creator , nsprefix = &apos; dc &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; keywords &apos; , tagtext = &apos; , &apos; .join ( keywords ) , nsprefix = &apos; cp &apos; ) ) DCNL DCSP if ( not lastmodifiedby ) : DCNL DCSP DCSP lastmodifiedby = creator DCNL DCSP coreprops.append ( makeelement ( &apos; lastModifiedBy &apos; , tagtext = lastmodifiedby , nsprefix = &apos; cp &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; revision &apos; , tagtext = &apos; 1&apos; , nsprefix = &apos; cp &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; category &apos; , tagtext = &apos; Examples &apos; , nsprefix = &apos; cp &apos; ) ) DCNL DCSP coreprops.append ( makeelement ( &apos; description &apos; , tagtext = &apos; Examples &apos; , nsprefix = &apos; dc &apos; ) ) DCNL DCSP currenttime = time.strftime ( &apos; % Y- % m- % dT % H : % M : % SZ &apos; ) DCNL DCSP for doctime in &#91; &apos; created &apos; , &apos; modified &apos; &#93; : DCNL DCSP DCSP elm _ str = ( &apos; &lt; dcterms : % s DCSP xmlns : xsi = &quot; http : / / www.w3.org / 2001 / XMLSchema-instance &quot; DCSP xmlns : dcterms = &quot; http : / / purl.org / dc / terms / &quot; DCSP xsi : type = &quot; dcterms : W3CDTF &quot; &gt; % s &lt; / dcterms : % s &gt; &apos; % ( doctime , currenttime , doctime ) ) DCNL DCSP DCSP coreprops.append ( etree.fromstring ( elm _ str ) ) DCNL DCSP return coreprops
DCSP def attach _ bound _ data ( request ) : DCNL DCSP DCSP parent = getattr ( request , &apos; parent &apos; , None ) DCNL DCSP DCSP return ( parent.bound _ data if parent else { } ) DCNL DCSP config.add _ request _ method ( attach _ bound _ data , name = &apos; bound _ data &apos; , reify = True )
DCSP if isinstance ( at , datetime ) : DCNL DCSP DCSP return False DCNL DCSP return ( ( at.hour is None ) and ( at.minute is None ) and ( at.second is None ) and ( at.microsecond is None ) )
DCSP passbC = passb.copy ( ) DCNL DCSP passbC &#91; ind &#93; = wp DCNL DCSP nat = ( ( stopb * ( passbC &#91; 0 &#93; - passbC &#91; 1 &#93; ) ) / ( ( stopb * * 2 ) - ( passbC &#91; 0 &#93; * passbC &#91; 1 &#93; ) ) ) DCNL DCSP nat = min ( abs ( nat ) ) DCNL DCSP if ( type = = &apos; butter &apos; ) : DCNL DCSP DCSP GSTOP = ( 10 * * ( 0.1 * abs ( gstop ) ) ) DCNL DCSP DCSP GPASS = ( 10 * * ( 0.1 * abs ( gpass ) ) ) DCNL DCSP DCSP n = ( log10 ( ( ( GSTOP - 1.0 ) / ( GPASS - 1.0 ) ) ) / ( 2 * log10 ( nat ) ) ) DCNL DCSP elif ( type = = &apos; cheby &apos; ) : DCNL DCSP DCSP GSTOP = ( 10 * * ( 0.1 * abs ( gstop ) ) ) DCNL DCSP DCSP GPASS = ( 10 * * ( 0.1 * abs ( gpass ) ) ) DCNL DCSP DCSP n = ( arccosh ( sqrt ( ( ( GSTOP - 1.0 ) / ( GPASS - 1.0 ) ) ) ) / arccosh ( nat ) ) DCNL DCSP elif ( type = = &apos; ellip &apos; ) : DCNL DCSP DCSP GSTOP = ( 10 * * ( 0.1 * gstop ) ) DCNL DCSP DCSP GPASS = ( 10 * * ( 0.1 * gpass ) ) DCNL DCSP DCSP arg1 = sqrt ( ( ( GPASS - 1.0 ) / ( GSTOP - 1.0 ) ) ) DCNL DCSP DCSP arg0 = ( 1.0 / nat ) DCNL DCSP DCSP d0 = special.ellipk ( &#91; ( arg0 * * 2 ) , ( 1 - ( arg0 * * 2 ) ) &#93; ) DCNL DCSP DCSP d1 = special.ellipk ( &#91; ( arg1 * * 2 ) , ( 1 - ( arg1 * * 2 ) ) &#93; ) DCNL DCSP DCSP n = ( ( d0 &#91; 0 &#93; * d1 &#91; 1 &#93; ) / ( d0 &#91; 1 &#93; * d1 &#91; 0 &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Incorrect DCSP type : DCSP % s &apos; % type ) ) DCNL DCSP return n
DCSP def decorator ( func ) : DCNL DCSP DCSP @ functools.wraps ( func ) DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP result = func ( * args , * * kwargs ) DCNL DCSP DCSP DCSP if isinstance ( result , ( dict , DictMixin ) ) : DCNL DCSP DCSP DCSP DCSP tplvars = defaults.copy ( ) DCNL DCSP DCSP DCSP DCSP tplvars.update ( result ) DCNL DCSP DCSP DCSP DCSP return template ( tpl _ name , * * tplvars ) DCNL DCSP DCSP DCSP elif ( result is None ) : DCNL DCSP DCSP DCSP DCSP return template ( tpl _ name , defaults ) DCNL DCSP DCSP DCSP return result DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP if ( n = = 2 ) : DCNL DCSP DCSP return &#91; 2 &#93; DCNL DCSP elif ( n &lt; 2 ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP s = list ( range ( 3 , ( n + 1 ) , 2 ) ) DCNL DCSP mroot = ( n * * 0.5 ) DCNL DCSP half = ( ( ( n + 1 ) / / 2 ) - 1 ) DCNL DCSP i = 0 DCNL DCSP m = 3 DCNL DCSP while ( m &lt; = mroot ) : DCNL DCSP DCSP if s &#91; i &#93; : DCNL DCSP DCSP DCSP j = ( ( ( m * m ) - 3 ) / / 2 ) DCNL DCSP DCSP DCSP s &#91; j &#93; = 0 DCNL DCSP DCSP DCSP while ( j &lt; half ) : DCNL DCSP DCSP DCSP DCSP s &#91; j &#93; = 0 DCNL DCSP DCSP DCSP DCSP j + = m DCNL DCSP DCSP i = ( i + 1 ) DCNL DCSP DCSP m = ( ( 2 * i ) + 3 ) DCNL DCSP return ( &#91; 2 &#93; + &#91; x for x in s if x &#93; )
DCSP S = sentence DCNL DCSP if ( not ( hasattr ( S , &apos; words &apos; ) and hasattr ( S , &apos; parse _ token &apos; ) ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; % s DCSP object DCSP is DCSP not DCSP a DCSP parsed DCSP Sentence &apos; % repr ( S. _ _ class _ _ . _ _ name _ _ ) ) ) DCNL DCSP if question ( S ) : DCNL DCSP DCSP return False DCNL DCSP for ( i , w ) in enumerate ( S ) : DCNL DCSP DCSP b = False DCNL DCSP DCSP if w.type.startswith ( &apos; VB &apos; ) : DCNL DCSP DCSP DCSP if s ( w ) .startswith ( &apos; wish &apos; ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if ( ( s ( w ) = = &apos; hope &apos; ) and ( i &gt; 0 ) and ( s ( S &#91; ( i - 1 ) &#93; ) in ( &apos; i &apos; , &apos; we &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if ( ( s ( w ) = = &apos; were &apos; ) and ( i &gt; 0 ) and ( ( s ( S &#91; ( i - 1 ) &#93; ) in ( &apos; i &apos; , &apos; it &apos; , &apos; he &apos; , &apos; she &apos; ) ) or ( S &#91; ( i - 1 ) &#93; .type = = &apos; NN &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if ( s ( w ) in subjunctive1 ) : DCNL DCSP DCSP DCSP DCSP b = True DCNL DCSP DCSP DCSP elif ( ( s ( w ) = = &apos; is &apos; ) and ( 0 &lt; i &lt; ( len ( S ) - 1 ) ) and ( s ( S &#91; ( i - 1 ) &#93; ) = = &apos; it &apos; ) and ( s ( S &#91; ( i + 1 ) &#93; ) in subjunctive2 ) ) : DCNL DCSP DCSP DCSP DCSP b = True DCNL DCSP DCSP DCSP elif ( ( s ( w ) = = &apos; is &apos; ) and ( 0 &lt; i &lt; ( len ( S ) - 3 ) ) and ( s ( S &#91; ( i - 1 ) &#93; ) = = &apos; it &apos; ) and ( s ( S &#91; ( i + 2 ) &#93; ) in ( &apos; good &apos; , &apos; bad &apos; ) ) and ( s ( S &#91; ( i + 3 ) &#93; ) = = &apos; idea &apos; ) ) : DCNL DCSP DCSP DCSP DCSP b = True DCNL DCSP DCSP if b : DCNL DCSP DCSP DCSP v = find ( ( lambda w : w.type.startswith ( &apos; VB &apos; ) ) , S &#91; ( i + 1 ) : &#93; ) DCNL DCSP DCSP DCSP if ( v and ( classical is True ) and v and ( v.type = = &apos; VB &apos; ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if ( v and ( classical is False ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP return False
DCSP mult = mticker.MultipleLocator ( base = 0.7 ) DCNL DCSP mult.set _ params ( base = 1.7 ) DCNL DCSP assert ( mult . _ base = = 1.7 )
DCSP prev = _ OVERRIDES _ DISABLED.disabled DCNL DCSP _ OVERRIDES _ DISABLED.disabled + = ( True , ) DCNL DCSP ( yield ) DCNL DCSP _ OVERRIDES _ DISABLED.disabled = prev
DCSP if ( not find _ sockfiles ( ) ) : DCNL DCSP DCSP return 13 DCNL DCSP if ( MySQLdb is None ) : DCNL DCSP DCSP utils.err ( &quot; error : DCSP Python DCSP module DCSP `MySQLdb &apos; DCSP is DCSP missing &quot; ) DCNL DCSP DCSP return 1 DCNL DCSP last _ db _ refresh = now ( ) DCNL DCSP dbs = find _ databases ( ) DCNL DCSP while True : DCNL DCSP DCSP ts = now ( ) DCNL DCSP DCSP if ( ( ts - last _ db _ refresh ) &gt; = DB _ REFRESH _ INTERVAL ) : DCNL DCSP DCSP DCSP find _ databases ( dbs ) DCNL DCSP DCSP DCSP last _ db _ refresh = ts DCNL DCSP DCSP errs = &#91; &#93; DCNL DCSP DCSP for ( dbname , db ) in dbs.iteritems ( ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP collect ( db ) DCNL DCSP DCSP DCSP except ( EnvironmentError , EOFError , RuntimeError , socket.error , MySQLdb.MySQLError ) as e : DCNL DCSP DCSP DCSP DCSP if ( isinstance ( e , IOError ) and ( e &#91; 0 &#93; = = errno.EPIPE ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return 2 DCNL DCSP DCSP DCSP DCSP utils.err ( ( &apos; error : DCSP failed DCSP to DCSP collect DCSP data DCSP from DCSP % s : DCSP % s &apos; % ( db , e ) ) ) DCNL DCSP DCSP DCSP DCSP errs.append ( dbname ) DCNL DCSP DCSP for dbname in errs : DCNL DCSP DCSP DCSP del dbs &#91; dbname &#93; DCNL DCSP DCSP sys.stdout.flush ( ) DCNL DCSP DCSP time.sleep ( COLLECTION _ INTERVAL )
DCSP xs = &#91; expand _ dims.expand _ dims ( x , axis = axis ) for x in xs &#93; DCNL DCSP return concat.concat ( xs , axis = axis )
DCSP if CONF.fake _ network : DCNL DCSP DCSP LOG.debug ( &apos; FAKE DCSP NET : DCSP % s &apos; , &apos; DCSP &apos; .join ( map ( str , cmd ) ) ) DCNL DCSP DCSP return ( &apos; fake &apos; , 0 ) DCNL DCSP else : DCNL DCSP DCSP return utils.execute ( * cmd , * * kwargs )
DCSP ( filepath , file ) = split ( file ) DCNL DCSP if filepath : DCNL DCSP DCSP path = ( filepath , ) DCNL DCSP elif ( path is None ) : DCNL DCSP DCSP path = defpath DCNL DCSP elif isinstance ( path , str ) : DCNL DCSP DCSP path = path.split ( pathsep ) DCNL DCSP if ( pathext is None ) : DCNL DCSP DCSP pathext = defpathext DCNL DCSP elif isinstance ( pathext , str ) : DCNL DCSP DCSP pathext = pathext.split ( pathsep ) DCNL DCSP if ( not ( &apos; &apos; in pathext ) ) : DCNL DCSP DCSP pathext.insert ( 0 , &apos; &apos; ) DCNL DCSP for dir in path : DCNL DCSP DCSP basepath = join ( dir , file ) DCNL DCSP DCSP for ext in pathext : DCNL DCSP DCSP DCSP fullpath = ( basepath + ext ) DCNL DCSP DCSP DCSP if ( exists ( fullpath ) and access ( fullpath , mode ) ) : DCNL DCSP DCSP DCSP DCSP ( yield fullpath )
DCSP client = salt.runner.RunnerClient ( _ _ opts _ _ ) DCNL DCSP ret = client.get _ docs ( ) DCNL DCSP return ret
DCSP string = re.sub ( &apos; \ \ n &apos; , &apos; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; s &quot; , &quot; DCSP &apos; s &quot; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99s &apos; , &quot; DCSP &apos; s &quot; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; ve &quot; , &apos; DCSP have &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99ve &apos; , &apos; DCSP have &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; t &quot; , &apos; DCSP not &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99t &apos; , &apos; DCSP not &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; re &quot; , &apos; DCSP are &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99re &apos; , &apos; DCSP are &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; d &quot; , &apos; &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99d &apos; , &apos; &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; ll &quot; , &apos; DCSP will &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99ll &apos; , &apos; DCSP will &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x9c &apos; , &apos; DCSP \ xe2 \ x80 \ x9c DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x9d &apos; , &apos; DCSP \ xe2 \ x80 \ x9d DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &quot; &apos; , &apos; DCSP \ xe2 \ x80 \ x9c DCSP &apos; , string ) DCNL DCSP string = re.sub ( &quot; \ \ &apos; &quot; , &quot; DCSP &apos; DCSP &quot; , string ) DCNL DCSP string = re.sub ( &apos; \ \ \ xe2 \ x80 \ x99 &apos; , &quot; DCSP &apos; DCSP &quot; , string ) DCNL DCSP string = re.sub ( &apos; \ \ . &apos; , &apos; DCSP . DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ , &apos; , &apos; DCSP , DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ - &apos; , &apos; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ( &apos; , &apos; DCSP ( DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ) &apos; , &apos; DCSP ) DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ! &apos; , &apos; DCSP ! DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &#93; &apos; , &apos; DCSP &#93; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &#91; &apos; , &apos; DCSP &#91; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ? &apos; , &apos; DCSP ? DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &gt; &apos; , &apos; DCSP &gt; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &lt; &apos; , &apos; DCSP &lt; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ = &apos; , &apos; DCSP = DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ; &apos; , &apos; DCSP ; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ ; &apos; , &apos; DCSP ; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ : &apos; , &apos; DCSP : DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ &quot; &apos; , &apos; DCSP &quot; DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ $ &apos; , &apos; DCSP $ DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ _ &apos; , &apos; DCSP _ DCSP &apos; , string ) DCNL DCSP string = re.sub ( &apos; \ \ s { 2 , } &apos; , &apos; DCSP &apos; , string ) DCNL DCSP return string.strip ( ) .lower ( )
DCSP if ( var.name is not None ) : DCNL DCSP DCSP return var.name DCNL DCSP elif isinstance ( var , gof.Constant ) : DCNL DCSP DCSP h = np.asarray ( var.data ) DCNL DCSP DCSP is _ const = False DCNL DCSP DCSP if ( h.ndim = = 0 ) : DCNL DCSP DCSP DCSP is _ const = True DCNL DCSP DCSP DCSP h = np.array ( &#91; h &#93; ) DCNL DCSP DCSP dstr = np.array2string ( h , precision = precision ) DCNL DCSP DCSP if ( &apos; \ n &apos; in dstr ) : DCNL DCSP DCSP DCSP dstr = dstr &#91; : dstr.index ( &apos; \ n &apos; ) &#93; DCNL DCSP DCSP if is _ const : DCNL DCSP DCSP DCSP dstr = dstr.replace ( &apos; &#91; &apos; , &apos; &apos; ) .replace ( &apos; &#93; &apos; , &apos; &apos; ) DCNL DCSP DCSP return dstr DCNL DCSP else : DCNL DCSP DCSP return type _ to _ str ( var.type )
DCSP try : DCNL DCSP DCSP print &apos; &#91; INFO &#93; DCSP Checking DCSP for DCSP ZIP DCSP Validity DCSP and DCSP Mode &apos; DCNL DCSP DCSP man = os.path.isfile ( os.path.join ( app _ dir , &apos; AndroidManifest.xml &apos; ) ) DCNL DCSP DCSP src = os.path.exists ( os.path.join ( app _ dir , &apos; src / &apos; ) ) DCNL DCSP DCSP if ( man and src ) : DCNL DCSP DCSP DCSP return ( &apos; eclipse &apos; , True ) DCNL DCSP DCSP man = os.path.isfile ( os.path.join ( app _ dir , &apos; app / src / main / AndroidManifest.xml &apos; ) ) DCNL DCSP DCSP src = os.path.exists ( os.path.join ( app _ dir , &apos; app / src / main / java / &apos; ) ) DCNL DCSP DCSP if ( man and src ) : DCNL DCSP DCSP DCSP return ( &apos; studio &apos; , True ) DCNL DCSP DCSP xcode = &#91; f for f in os.listdir ( app _ dir ) if f.endswith ( &apos; .xcodeproj &apos; ) &#93; DCNL DCSP DCSP if xcode : DCNL DCSP DCSP DCSP return ( &apos; ios &apos; , True ) DCNL DCSP DCSP return ( &apos; &apos; , False ) DCNL DCSP except : DCNL DCSP DCSP PrintException ( &apos; &#91; ERROR &#93; DCSP Determining DCSP Upload DCSP type &apos; )
DCSP def _ validator ( form , field ) : DCNL DCSP DCSP all _ conditions _ met = True DCNL DCSP DCSP for ( key , value ) in kwargs.iteritems ( ) : DCNL DCSP DCSP DCSP if ( getattr ( form , key ) .data ! = value ) : DCNL DCSP DCSP DCSP DCSP all _ conditions _ met = False DCNL DCSP DCSP if all _ conditions _ met : DCNL DCSP DCSP DCSP if ( ( field.data is None ) or ( isinstance ( field.data , ( str , unicode ) ) and ( not field.data.strip ( ) ) ) or ( isinstance ( field.data , FileStorage ) and ( not field.data.filename.strip ( ) ) ) ) : DCNL DCSP DCSP DCSP DCSP raise validators.ValidationError ( &apos; This DCSP field DCSP is DCSP required . &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP field.errors &#91; : &#93; = &#91; &#93; DCNL DCSP DCSP DCSP raise validators.StopValidation ( ) DCNL DCSP return _ validator
DCSP registry = FormatRegistry ( ) DCNL DCSP filetype = registry.register ( &apos; foo &apos; , &apos; foo &apos; ) DCNL DCSP new _ filetype = registry.register ( &apos; foo &apos; , &apos; foo &apos; ) DCNL DCSP assert ( new _ filetype = = filetype ) DCNL DCSP _ test _ formats ( registry , &#91; &apos; foo &apos; &#93; ) DCNL DCSP new _ filetype = registry.register ( &apos; foo &apos; , &apos; foo &apos; , title = &apos; Bar &apos; ) DCNL DCSP assert ( new _ filetype = = filetype ) DCNL DCSP assert ( new _ filetype.title = = &apos; Bar &apos; ) DCNL DCSP _ test _ formats ( registry , &#91; &apos; foo &apos; &#93; ) DCNL DCSP new _ filetype = registry.register ( &apos; foo &apos; , &apos; bar &apos; ) DCNL DCSP assert ( new _ filetype = = filetype ) DCNL DCSP assert ( new _ filetype.title = = &apos; Bar &apos; ) DCNL DCSP assert ( str ( new _ filetype.extension ) = = &apos; bar &apos; ) DCNL DCSP _ test _ formats ( registry , &#91; &apos; foo &apos; &#93; )
DCSP thisdriver = _ get _ virt _ name ( virt _ file _ re , filename ) DCNL DCSP thatdriver = _ get _ virt _ name ( virt _ import _ re , physical _ line ) DCNL DCSP if ( ( thatdriver is not None ) and ( thisdriver is not None ) and ( thisdriver ! = thatdriver ) ) : DCNL DCSP DCSP return ( 0 , &apos; N311 : DCSP importing DCSP code DCSP from DCSP other DCSP virt DCSP drivers DCSP forbidden &apos; )
DCSP width = get _ cwidth ( text ) DCNL DCSP if ( width &gt; max _ width ) : DCNL DCSP DCSP if ( len ( text ) = = width ) : DCNL DCSP DCSP DCSP trimmed _ text = ( text &#91; : max ( 1 , ( max _ width - 3 ) ) &#93; + u &apos; ... &apos; ) &#91; : max _ width &#93; DCNL DCSP DCSP DCSP return ( trimmed _ text , len ( trimmed _ text ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP trimmed _ text = u &apos; &apos; DCNL DCSP DCSP DCSP for c in text : DCNL DCSP DCSP DCSP DCSP if ( get _ cwidth ( ( trimmed _ text + c ) ) &lt; = ( max _ width - 3 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP trimmed _ text + = c DCNL DCSP DCSP DCSP trimmed _ text + = u &apos; ... &apos; DCNL DCSP DCSP DCSP return ( trimmed _ text , get _ cwidth ( trimmed _ text ) ) DCNL DCSP else : DCNL DCSP DCSP return ( text , width )
DCSP n _ samples = X.shape &#91; 0 &#93; DCNL DCSP ( labels , mindist ) = pairwise _ distances _ argmin _ min ( X = X , Y = centers , metric = &apos; euclidean &apos; , metric _ kwargs = { &apos; squared &apos; : True } ) DCNL DCSP labels = labels.astype ( np.int32 ) DCNL DCSP if ( n _ samples = = distances.shape &#91; 0 &#93; ) : DCNL DCSP DCSP distances &#91; : &#93; = mindist DCNL DCSP inertia = mindist.sum ( ) DCNL DCSP return ( labels , inertia )
DCSP return IMPL.compute _ node _ statistics ( context )
DCSP text = re _ mathdefault.sub ( repl _ mathdefault , text ) DCNL DCSP parts = re _ mathsep.split ( text ) DCNL DCSP for ( i , s ) in enumerate ( parts ) : DCNL DCSP DCSP if ( not ( i % 2 ) ) : DCNL DCSP DCSP DCSP s = re _ escapetext.sub ( repl _ escapetext , s ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP s = ( u &apos; \ \ ( \ \ displaystyle DCSP % s \ \ ) &apos; % s ) DCNL DCSP DCSP parts &#91; i &#93; = s DCNL DCSP return u &apos; &apos; .join ( parts )
DCSP print ast.literal _ eval ( info ) , type ( ast.literal _ eval ( info ) ) DCNL DCSP return ast.literal _ eval ( info )
DCSP start _ time = time ( ) DCNL DCSP start _ date = datetime.now ( UTC ) DCNL DCSP status _ interval = 100 DCNL DCSP enrolled _ students = CourseEnrollment.objects.users _ enrolled _ in ( course _ id ) DCNL DCSP task _ progress = TaskProgress ( action _ name , enrolled _ students.count ( ) , start _ time ) DCNL DCSP header _ row = OrderedDict ( &#91; ( &apos; id &apos; , &apos; Student DCSP ID &apos; ) , ( &apos; email &apos; , &apos; Email &apos; ) , ( &apos; username &apos; , &apos; Username &apos; ) &#93; ) DCNL DCSP graded _ scorable _ blocks = _ graded _ scorable _ blocks _ to _ header ( course _ id ) DCNL DCSP rows = &#91; ( ( list ( header _ row.values ( ) ) + &#91; &apos; Grade &apos; &#93; ) + list ( chain.from _ iterable ( graded _ scorable _ blocks.values ( ) ) ) ) &#93; DCNL DCSP error _ rows = &#91; ( list ( header _ row.values ( ) ) + &#91; &apos; error _ msg &apos; &#93; ) &#93; DCNL DCSP current _ step = { &apos; step &apos; : &apos; Calculating DCSP Grades &apos; } DCNL DCSP course = get _ course _ by _ id ( course _ id ) DCNL DCSP for ( student , course _ grade , err _ msg ) in CourseGradeFactory ( ) .iter ( course , enrolled _ students ) : DCNL DCSP DCSP student _ fields = &#91; getattr ( student , field _ name ) for field _ name in header _ row &#93; DCNL DCSP DCSP task _ progress.attempted + = 1 DCNL DCSP DCSP if ( not course _ grade ) : DCNL DCSP DCSP DCSP if ( not err _ msg ) : DCNL DCSP DCSP DCSP DCSP err _ msg = u &apos;Unknown DCSP error &apos; DCNL DCSP DCSP DCSP error _ rows.append ( ( student _ fields + &#91; err _ msg &#93; ) ) DCNL DCSP DCSP DCSP task _ progress.failed + = 1 DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP earned _ possible _ values = &#91; &#93; DCNL DCSP DCSP for block _ location in graded _ scorable _ blocks : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP problem _ score = course _ grade.locations _ to _ scores &#91; block _ location &#93; DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP earned _ possible _ values.append ( &#91; u &apos;Not DCSP Available &apos; , u &apos;Not DCSP Available &apos; &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if problem _ score.attempted : DCNL DCSP DCSP DCSP DCSP DCSP earned _ possible _ values.append ( &#91; problem _ score.earned , problem _ score.possible &#93; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP earned _ possible _ values.append ( &#91; u &apos;Not DCSP Attempted &apos; , problem _ score.possible &#93; ) DCNL DCSP DCSP rows.append ( ( ( student _ fields + &#91; course _ grade.percent &#93; ) + list ( chain.from _ iterable ( earned _ possible _ values ) ) ) ) DCNL DCSP DCSP task _ progress.succeeded + = 1 DCNL DCSP DCSP if ( ( task _ progress.attempted % status _ interval ) = = 0 ) : DCNL DCSP DCSP DCSP task _ progress.update _ task _ state ( extra _ meta = current _ step ) DCNL DCSP if ( len ( rows ) &gt; 1 ) : DCNL DCSP DCSP upload _ csv _ to _ report _ store ( rows , &apos; problem _ grade _ report &apos; , course _ id , start _ date ) DCNL DCSP if ( len ( error _ rows ) &gt; 1 ) : DCNL DCSP DCSP upload _ csv _ to _ report _ store ( error _ rows , &apos; problem _ grade _ report _ err &apos; , course _ id , start _ date ) DCNL DCSP return task _ progress.update _ task _ state ( extra _ meta = { &apos; step &apos; : &apos; Uploading DCSP CSV &apos; } )
DCSP net = ( &#91; int ( digit ) for digit in ipstr.split ( &apos; .&apos; ) &#93; + &#91; 0 , 0 , 0 &#93; ) DCNL DCSP net = net &#91; : 4 &#93; DCNL DCSP return ( ( ( ( ( ( ( 0L + net &#91; 0 &#93; ) &lt; &lt; 8 ) + net &#91; 1 &#93; ) &lt; &lt; 8 ) + net &#91; 2 &#93; ) &lt; &lt; 8 ) + net &#91; 3 &#93; )
DCSP assert ( set ( required _ keys ) &lt; = set ( dict _ to _ check.keys ( ) ) ) , ( &apos; Missing DCSP keys : DCSP % s &apos; % dict _ to _ check ) DCNL DCSP assert ( set ( dict _ to _ check.keys ( ) ) &lt; = set ( ( required _ keys + optional _ keys ) ) ) , ( &apos; Extra DCSP keys : DCSP % s &apos; % dict _ to _ check )
DCSP array _ of _ optv = DataObject ( ) DCNL DCSP array _ of _ optv.OptionValue = optvals DCNL DCSP return array _ of _ optv
DCSP return IMPL.image _ volume _ cache _ create ( context , host , cluster _ name , image _ id , image _ updated _ at , volume _ id , size )
DCSP location = EarthLocation ( lon = Angle ( u &apos; -111d36.0m &apos; ) , lat = Angle ( u &apos; 31d57.8m &apos; ) , height = ( 2120.0 * u.m ) ) DCNL DCSP obstime = Time ( 2451545.0 , format = u &apos;jd &apos; , scale = u &apos;ut1 &apos; ) DCNL DCSP altaz _ frame = AltAz ( obstime = obstime , location = location , temperature = ( 0 * u.deg _ C ) , pressure = ( 0.781 * u.bar ) ) DCNL DCSP altaz _ frame _ noatm = AltAz ( obstime = obstime , location = location , temperature = ( 0 * u.deg _ C ) , pressure = ( 0.0 * u.bar ) ) DCNL DCSP altaz = SkyCoord ( u &apos; 264d55m06s DCSP 37d54m41s &apos; , frame = altaz _ frame ) DCNL DCSP altaz _ noatm = SkyCoord ( u &apos; 264d55m06s DCSP 37d54m41s &apos; , frame = altaz _ frame _ noatm ) DCNL DCSP radec _ frame = u &apos;icrs &apos; DCNL DCSP radec _ actual = altaz.transform _ to ( radec _ frame ) DCNL DCSP radec _ actual _ noatm = altaz _ noatm.transform _ to ( radec _ frame ) DCNL DCSP radec _ expected = SkyCoord ( u &apos; 07h36m55.2s DCSP + 15d25m08s &apos; , frame = radec _ frame ) DCNL DCSP distance = radec _ actual.separation ( radec _ expected ) .to ( u &apos;arcsec &apos; ) DCNL DCSP radec _ expected _ noatm = SkyCoord ( u &apos; 07h36m58.9s DCSP + 15d25m37s &apos; , frame = radec _ frame ) DCNL DCSP distance _ noatm = radec _ actual _ noatm.separation ( radec _ expected _ noatm ) .to ( u &apos;arcsec &apos; ) DCNL DCSP assert ( distance &lt; ( 5 * u.arcsec ) ) DCNL DCSP assert ( distance _ noatm &lt; ( 0.4 * u.arcsec ) )
DCSP rng = np.random.RandomState ( &#91; 2013 , 5 , 1 &#93; ) DCNL DCSP batch _ size = 3 DCNL DCSP rows = 4 DCNL DCSP cols = 5 DCNL DCSP channels = 2 DCNL DCSP conv = Conv2DSpace ( &#91; rows , cols &#93; , channels = channels , axes = ( &apos; c &apos; , 0 , 1 , &apos; b &apos; ) ) DCNL DCSP vec = VectorSpace ( conv.get _ total _ dimension ( ) ) DCNL DCSP X = conv.make _ batch _ theano ( ) DCNL DCSP Y = conv.format _ as ( X , vec ) DCNL DCSP Z = vec.format _ as ( Y , conv ) DCNL DCSP A = vec.make _ batch _ theano ( ) DCNL DCSP B = vec.format _ as ( A , conv ) DCNL DCSP C = conv.format _ as ( B , vec ) DCNL DCSP f = function ( &#91; X , A &#93; , &#91; Z , C &#93; ) DCNL DCSP X = rng.randn ( * conv.get _ origin _ batch ( batch _ size ) .shape ) .astype ( X.dtype ) DCNL DCSP A = rng.randn ( * vec.get _ origin _ batch ( batch _ size ) .shape ) .astype ( A.dtype ) DCNL DCSP ( Z , C ) = f ( X , A ) DCNL DCSP np.testing.assert _ allclose ( Z , X ) DCNL DCSP np.testing.assert _ allclose ( C , A )
DCSP db _ name = context.conf &#91; u &apos;dbname &apos; &#93; DCNL DCSP context.cli.sendline ( u &apos; \ \ connect DCSP { 0 } &apos; .format ( db _ name ) )
DCSP if ( os.geteuid ( ) ! = 0 ) : DCNL DCSP DCSP return DCNL DCSP global g _ user _ uid , g _ user _ gid DCNL DCSP ( g _ user _ uid , g _ user _ gid ) = desktop.lib.daemon _ utils.get _ uid _ gid ( SETUID _ USER , SETGID _ GROUP )
DCSP expr = func ( constr.expr ) DCNL DCSP return type ( constr ) ( expr , constr.constr _ id , constr.size )
DCSP if ( &apos; postgres.tablespace _ exists &apos; not in _ _ salt _ _ ) : DCNL DCSP DCSP return ( False , &apos; Unable DCSP to DCSP load DCSP postgres DCSP module . DCSP DCSP Make DCSP sure DCSP `postgres.bins _ dir` DCSP is DCSP set . &apos; ) DCNL DCSP return True
DCSP return lo.LinOp ( lo.MUL _ ELEM , lh _ op.size , &#91; rh _ op &#93; , lh _ op )
DCSP if ( not ( general or request or response or entity ) ) : DCNL DCSP DCSP general = request = response = entity = True DCNL DCSP search = &#91; &#93; DCNL DCSP for ( bool , strval ) in ( ( general , &apos; general &apos; ) , ( request , &apos; request &apos; ) , ( response , &apos; response &apos; ) , ( entity , &apos; entity &apos; ) ) : DCNL DCSP DCSP if bool : DCNL DCSP DCSP DCSP search.append ( strval ) DCNL DCSP return &#91; head for head in _ headers.values ( ) if ( head.category in search ) &#93;
DCSP import pyvera as veraApi DCNL DCSP if isinstance ( vera _ device , veraApi.VeraDimmer ) : DCNL DCSP DCSP return &apos; light &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraBinarySensor ) : DCNL DCSP DCSP return &apos; binary _ sensor &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraSensor ) : DCNL DCSP DCSP return &apos; sensor &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraArmableDevice ) : DCNL DCSP DCSP return &apos; switch &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraLock ) : DCNL DCSP DCSP return &apos; lock &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraThermostat ) : DCNL DCSP DCSP return &apos; climate &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraCurtain ) : DCNL DCSP DCSP return &apos; cover &apos; DCNL DCSP if isinstance ( vera _ device , veraApi.VeraSwitch ) : DCNL DCSP DCSP if ( vera _ device.device _ id in remap ) : DCNL DCSP DCSP DCSP return &apos; light &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; switch &apos; DCNL DCSP return None
DCSP _ cred = _ _ get _ yubico _ users ( username ) DCNL DCSP client = Yubico ( _ cred &#91; &apos; id &apos; &#93; , _ cred &#91; &apos; key &apos; &#93; ) DCNL DCSP try : DCNL DCSP DCSP if client.verify ( password ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return False DCNL DCSP except yubico _ exceptions.StatusCodeError as e : DCNL DCSP DCSP log.info ( &apos; Unable DCSP to DCSP verify DCSP YubiKey DCSP ` { 0 } ` &apos; .format ( e ) ) DCNL DCSP DCSP return False
DCSP ( header , mapping _ data , run _ description , errors , warnings ) = process _ id _ map ( open ( mapping _ fp , &apos; U &apos; ) , disable _ primer _ check , has _ barcodes , char _ replace , variable _ len _ barcodes , added _ demultiplex _ field , strip _ quotes = False , suppress _ stripping = True ) DCNL DCSP if ( not suppress _ html ) : DCNL DCSP DCSP formatted _ html = format _ mapping _ html _ data ( header , mapping _ data , errors , warnings ) DCNL DCSP DCSP output _ html = join ( ( ( output _ dir + basename ( mapping _ fp ) .replace ( &apos; .txt &apos; , &apos; &apos; ) ) + &apos; .html &apos; ) ) DCNL DCSP DCSP html _ f = open ( output _ html , &apos; w &apos; ) DCNL DCSP DCSP html _ f.write ( formatted _ html ) DCNL DCSP DCSP qiime _ dir = get _ qiime _ project _ dir ( ) DCNL DCSP DCSP copyfile ( join ( qiime _ dir , &apos; qiime &apos; , &apos; support _ files &apos; , &apos; js / overlib.js &apos; ) , join ( output _ dir , &apos; overlib.js &apos; ) ) DCNL DCSP corrected _ mapping _ data = correct _ mapping _ data ( mapping _ data , header , char _ replace ) DCNL DCSP output _ corrected _ fp = join ( ( ( output _ dir + basename ( mapping _ fp ) .replace ( &apos; .txt &apos; , &apos; &apos; ) ) + &apos; _ corrected.txt &apos; ) ) DCNL DCSP write _ corrected _ mapping ( output _ corrected _ fp , header , run _ description , corrected _ mapping _ data ) DCNL DCSP output _ log _ fp = join ( ( ( output _ dir + basename ( mapping _ fp ) .replace ( &apos; .txt &apos; , &apos; &apos; ) ) + &apos; .log &apos; ) ) DCNL DCSP write _ log _ file ( output _ log _ fp , errors , warnings ) DCNL DCSP if verbose : DCNL DCSP DCSP if ( errors or warnings ) : DCNL DCSP DCSP DCSP print ( &apos; Errors DCSP and / or DCSP warnings DCSP detected DCSP in DCSP mapping DCSP file . DCSP DCSP Please DCSP &apos; + &apos; check DCSP the DCSP log DCSP and DCSP html DCSP file DCSP for DCSP details . &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP print &apos; No DCSP errors DCSP or DCSP warnings DCSP were DCSP found DCSP in DCSP mapping DCSP file . &apos; 
DCSP msg = ( &apos; Pushing DCSP % r DCSP to DCSP % r &apos; % ( local _ path , remote _ path ) ) DCNL DCSP remote _ filename = os.path.basename ( local _ path ) DCNL DCSP if log.isEnabledFor ( logging.DEBUG ) : DCNL DCSP DCSP msg + = ( &apos; DCSP ( % s ) &apos; % context.device ) DCNL DCSP with log.waitfor ( msg ) as w : DCNL DCSP DCSP with AdbClient ( ) as c : DCNL DCSP DCSP DCSP stat _ = c.stat ( remote _ path ) DCNL DCSP DCSP DCSP if ( not stat _ ) : DCNL DCSP DCSP DCSP DCSP remote _ filename = os.path.basename ( remote _ path ) DCNL DCSP DCSP DCSP DCSP remote _ path = os.path.dirname ( remote _ path ) DCNL DCSP DCSP DCSP DCSP stat _ = c.stat ( remote _ path ) DCNL DCSP DCSP DCSP if ( not stat _ ) : DCNL DCSP DCSP DCSP DCSP log.error ( ( &apos; Could DCSP not DCSP stat DCSP % r &apos; % remote _ path ) ) DCNL DCSP DCSP DCSP mode = stat _ &#91; &apos; mode &apos; &#93; DCNL DCSP DCSP DCSP if stat.S _ ISDIR ( mode ) : DCNL DCSP DCSP DCSP DCSP remote _ path = os.path.join ( remote _ path , remote _ filename ) DCNL DCSP DCSP DCSP return c.write ( remote _ path , misc.read ( local _ path ) , callback = _ create _ adb _ push _ pull _ callback ( w ) )
DCSP if ( not isinstance ( data , list ) ) : DCNL DCSP DCSP raise errors.AnsibleFilterError ( &apos; &#124; failed DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list &apos; ) DCNL DCSP if ( not data ) : DCNL DCSP DCSP return None DCNL DCSP elif ( ( image _ name is None ) or ( not image _ name.endswith ( &apos; _ * &apos; ) ) ) : DCNL DCSP DCSP ami = sorted ( data , key = itemgetter ( &apos; name &apos; ) , reverse = True ) &#91; 0 &#93; DCNL DCSP DCSP return ami &#91; &apos; ami _ id &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP ami _ info = &#91; ( ami , ami &#91; &apos; name &apos; &#93; .split ( &apos; _ &apos; ) &#91; ( -1 ) &#93; ) for ami in data &#93; DCNL DCSP DCSP ami = sorted ( ami _ info , key = itemgetter ( 1 ) , reverse = True ) &#91; 0 &#93; &#91; 0 &#93; DCNL DCSP DCSP return ami &#91; &apos; ami _ id &apos; &#93;
DCSP if ( sys.platform in &#91; &apos; win32 &apos; , &apos; cygwin &apos; &#93; ) : DCNL DCSP DCSP return &apos; pyd &apos; DCNL DCSP else : DCNL DCSP DCSP return &apos; so&apos;
DCSP return sorted ( FQDNs , key = ( lambda fqdn : fqdn.split ( &apos; .&apos; ) &#91; : : ( -1 ) &#93; &#91; 1 : &#93; ) )
DCSP output = &#91; outbuffer &#93; DCNL DCSP tag _ name = xml.tag.split ( u &apos; } &apos; , 1 ) &#91; ( -1 ) &#93; DCNL DCSP if ( u &apos; } &apos; in xml.tag ) : DCNL DCSP DCSP tag _ xmlns = xml.tag.split ( u &apos; } &apos; , 1 ) &#91; 0 &#93; &#91; 1 : &#93; DCNL DCSP else : DCNL DCSP DCSP tag _ xmlns = u &apos; &apos; DCNL DCSP default _ ns = u &apos; &apos; DCNL DCSP stream _ ns = u &apos; &apos; DCNL DCSP use _ cdata = False DCNL DCSP if stream : DCNL DCSP DCSP default _ ns = stream.default _ ns DCNL DCSP DCSP stream _ ns = stream.stream _ ns DCNL DCSP DCSP use _ cdata = stream.use _ cdata DCNL DCSP namespace = u &apos; &apos; DCNL DCSP if tag _ xmlns : DCNL DCSP DCSP if ( ( top _ level and ( tag _ xmlns not in &#91; default _ ns , xmlns , stream _ ns &#93; ) ) or ( ( not top _ level ) and ( tag _ xmlns ! = xmlns ) ) ) : DCNL DCSP DCSP DCSP namespace = ( u &apos; DCSP xmlns = &quot; % s &quot; &apos; % tag _ xmlns ) DCNL DCSP if ( stream and ( tag _ xmlns in stream.namespace _ map ) ) : DCNL DCSP DCSP mapped _ namespace = stream.namespace _ map &#91; tag _ xmlns &#93; DCNL DCSP DCSP if mapped _ namespace : DCNL DCSP DCSP DCSP tag _ name = ( u &apos; % s : % s &apos; % ( mapped _ namespace , tag _ name ) ) DCNL DCSP output.append ( ( u &apos; &lt; % s &apos; % tag _ name ) ) DCNL DCSP output.append ( namespace ) DCNL DCSP new _ namespaces = set ( ) DCNL DCSP for ( attrib , value ) in xml.attrib.items ( ) : DCNL DCSP DCSP value = escape ( value , use _ cdata ) DCNL DCSP DCSP if ( u &apos; } &apos; not in attrib ) : DCNL DCSP DCSP DCSP output.append ( ( u &apos; DCSP % s = &quot; % s &quot; &apos; % ( attrib , value ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP attrib _ ns = attrib.split ( u &apos; } &apos; ) &#91; 0 &#93; &#91; 1 : &#93; DCNL DCSP DCSP DCSP attrib = attrib.split ( u &apos; } &apos; ) &#91; 1 &#93; DCNL DCSP DCSP DCSP if ( attrib _ ns = = XML _ NS ) : DCNL DCSP DCSP DCSP DCSP output.append ( ( u &apos; DCSP xml : % s = &quot; % s &quot; &apos; % ( attrib , value ) ) ) DCNL DCSP DCSP DCSP elif ( stream and ( attrib _ ns in stream.namespace _ map ) ) : DCNL DCSP DCSP DCSP DCSP mapped _ ns = stream.namespace _ map &#91; attrib _ ns &#93; DCNL DCSP DCSP DCSP DCSP if mapped _ ns : DCNL DCSP DCSP DCSP DCSP DCSP if ( namespaces is None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP namespaces = set ( ) DCNL DCSP DCSP DCSP DCSP DCSP if ( attrib _ ns not in namespaces ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP namespaces.add ( attrib _ ns ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP new _ namespaces.add ( attrib _ ns ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP output.append ( ( u &apos; DCSP xmlns : % s = &quot; % s &quot; &apos; % ( mapped _ ns , attrib _ ns ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP output.append ( ( u &apos; DCSP % s : % s = &quot; % s &quot; &apos; % ( mapped _ ns , attrib , value ) ) ) DCNL DCSP if open _ only : DCNL DCSP DCSP output.append ( u &apos; &gt; &apos; ) DCNL DCSP DCSP return u &apos; &apos; .join ( output ) DCNL DCSP if ( len ( xml ) or xml.text ) : DCNL DCSP DCSP output.append ( u &apos; &gt; &apos; ) DCNL DCSP DCSP if xml.text : DCNL DCSP DCSP DCSP output.append ( escape ( xml.text , use _ cdata ) ) DCNL DCSP DCSP if len ( xml ) : DCNL DCSP DCSP DCSP for child in xml : DCNL DCSP DCSP DCSP DCSP output.append ( tostring ( child , tag _ xmlns , stream , namespaces = namespaces ) ) DCNL DCSP DCSP output.append ( ( u &apos; &lt; / % s &gt; &apos; % tag _ name ) ) DCNL DCSP elif xml.text : DCNL DCSP DCSP output.append ( ( u &apos; &gt; % s &lt; / % s &gt; &apos; % ( escape ( xml.text , use _ cdata ) , tag _ name ) ) ) DCNL DCSP else : DCNL DCSP DCSP output.append ( u &apos; DCSP / &gt; &apos; ) DCNL DCSP if xml.tail : DCNL DCSP DCSP output.append ( escape ( xml.tail , use _ cdata ) ) DCNL DCSP for ns in new _ namespaces : DCNL DCSP DCSP namespaces.remove ( ns ) DCNL DCSP return u &apos; &apos; .join ( output )
DCSP for filename in pathnames : DCNL DCSP DCSP if ( filename ! = &apos; &apos; ) : DCNL DCSP DCSP DCSP filename = posixpath.normpath ( filename ) DCNL DCSP DCSP for sep in _ os _ alt _ seps : DCNL DCSP DCSP DCSP if ( sep in filename ) : DCNL DCSP DCSP DCSP DCSP raise NotFound ( ) DCNL DCSP DCSP if ( os.path.isabs ( filename ) or ( filename = = &apos; .. &apos; ) or filename.startswith ( &apos; .. / &apos; ) ) : DCNL DCSP DCSP DCSP raise NotFound ( ) DCNL DCSP DCSP directory = os.path.join ( directory , filename ) DCNL DCSP return directory
DCSP if ( query and ( not ( set ( query ) &lt; = urlencoded ) ) ) : DCNL DCSP DCSP error = u &quot; Error DCSP trying DCSP to DCSP decode DCSP a DCSP non DCSP urlencoded DCSP string . DCSP Found DCSP invalid DCSP characters : DCSP % s DCSP in DCSP the DCSP string : DCSP &apos; % s &apos; . DCSP Please DCSP ensure DCSP the DCSP request / response DCSP body DCSP is DCSP x-www-form-urlencoded . &quot; DCNL DCSP DCSP raise ValueError ( ( error % ( ( set ( query ) - urlencoded ) , query ) ) ) DCNL DCSP invalid _ hex = u &apos; % &#91; ^ 0-9A-Fa-f &#93; &#124; % &#91; 0-9A-Fa-f &#93; &#91; ^ 0-9A-Fa-f &#93; &apos; DCNL DCSP if len ( re.findall ( invalid _ hex , query ) ) : DCNL DCSP DCSP raise ValueError ( u &apos;Invalid DCSP hex DCSP encoding DCSP in DCSP query DCSP string . &apos; ) DCNL DCSP query = ( query.encode ( u &apos;utf-8 &apos; ) if ( ( not PY3 ) and isinstance ( query , unicode _ type ) ) else query ) DCNL DCSP params = urlparse.parse _ qsl ( query , keep _ blank _ values = True ) DCNL DCSP return decode _ params _ utf8 ( params )
DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP except KeyError as key _ error : DCNL DCSP DCSP grpc _ context.code ( status.Code.NOT _ FOUND ) DCNL DCSP DCSP grpc _ context.details ( &apos; Unable DCSP to DCSP find DCSP the DCSP item DCSP keyed DCSP by DCSP { } &apos; .format ( key _ error ) )
DCSP config = _ get _ vistara _ configuration ( ) DCNL DCSP if ( not config ) : DCNL DCSP DCSP return False DCNL DCSP access _ token = _ get _ oath2 _ access _ token ( config &#91; &apos; client _ key &apos; &#93; , config &#91; &apos; client _ secret &apos; &#93; ) DCNL DCSP if ( not access _ token ) : DCNL DCSP DCSP return &apos; Vistara DCSP access DCSP token DCSP not DCSP available &apos; DCNL DCSP query _ string = &apos; dnsName : { 0 } &apos; .format ( name ) DCNL DCSP devices = _ search _ devices ( query _ string , config &#91; &apos; client _ id &apos; &#93; , access _ token ) DCNL DCSP if ( not devices ) : DCNL DCSP DCSP return &apos; No DCSP devices DCSP found &apos; DCNL DCSP device _ count = len ( devices ) DCNL DCSP if ( safety _ on and ( device _ count ! = 1 ) ) : DCNL DCSP DCSP return &apos; Expected DCSP to DCSP delete DCSP 1 DCSP device DCSP and DCSP found DCSP { 0 } . DCSP Set DCSP safety _ on = False DCSP to DCSP override . &apos; .format ( device _ count ) DCNL DCSP delete _ responses = &#91; &#93; DCNL DCSP for device in devices : DCNL DCSP DCSP device _ id = device &#91; &apos; id &apos; &#93; DCNL DCSP DCSP log.debug ( device _ id ) DCNL DCSP DCSP delete _ response = _ delete _ resource ( device _ id , config &#91; &apos; client _ id &apos; &#93; , access _ token ) DCNL DCSP DCSP if ( not delete _ response ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP delete _ responses.append ( delete _ response ) DCNL DCSP return delete _ responses
DCSP f _ bytes = np.zeros ( 3 , dtype = np.uint8 ) DCNL DCSP f _ bytes &#91; 0 &#93; = ( ( val &gt; &gt; 16 ) &amp; 255 ) DCNL DCSP f _ bytes &#91; 1 &#93; = ( ( val &gt; &gt; 8 ) &amp; 255 ) DCNL DCSP f _ bytes &#91; 2 &#93; = ( val &amp; 255 ) DCNL DCSP fid.write ( f _ bytes.tostring ( ) )
DCSP if ( hasattr ( json _ data , &apos; get &apos; ) and callable ( json _ data.get ) ) : DCNL DCSP DCSP name = json _ data.get ( &apos; protocol &apos; ) DCNL DCSP DCSP namespace = json _ data.get ( &apos; namespace &apos; ) DCNL DCSP DCSP types = json _ data.get ( &apos; types &apos; ) DCNL DCSP DCSP messages = json _ data.get ( &apos; messages &apos; ) DCNL DCSP DCSP return Protocol ( name , namespace , types , messages ) DCNL DCSP else : DCNL DCSP DCSP raise ProtocolParseException ( ( &apos; Not DCSP a DCSP JSON DCSP object : DCSP % s &apos; % json _ data ) )
DCSP _ t = as _ tensor _ variable ( t ) DCNL DCSP ndim = ( _ t.ndim + 1 ) DCNL DCSP if ( not ( ( - ndim ) &lt; = axis &lt; ndim ) ) : DCNL DCSP DCSP msg = &apos; axis DCSP { 0 } DCSP is DCSP out DCSP of DCSP bounds DCSP &#91; - { 1 } , DCSP { 1 } ) &apos; .format ( axis , ndim ) DCNL DCSP DCSP raise IndexError ( msg ) DCNL DCSP if ( axis &lt; 0 ) : DCNL DCSP DCSP axis + = ndim DCNL DCSP pattern = &#91; i for i in xrange ( _ t.type.ndim ) &#93; DCNL DCSP pattern.insert ( axis , &apos; x &apos; ) DCNL DCSP return DimShuffle ( _ t.broadcastable , pattern ) ( _ t )
DCSP file = BytesIO ( ) DCNL DCSP pickler = pickle.Pickler ( file , protocol ) DCNL DCSP pickler.persistent _ id = _ persistent _ id DCNL DCSP pickler.dump ( obj ) DCNL DCSP return file.getvalue ( )
DCSP cmd = &#91; salt.utils.which ( &apos; pg _ dropcluster &apos; ) &#93; DCNL DCSP if stop : DCNL DCSP DCSP cmd + = &#91; &apos; --stop &apos; &#93; DCNL DCSP cmd + = &#91; version , name &#93; DCNL DCSP cmdstr = &apos; DCSP &apos; .join ( &#91; pipes.quote ( c ) for c in cmd &#93; ) DCNL DCSP ret = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmdstr , python _ shell = False ) DCNL DCSP if ( ret.get ( &apos; retcode &apos; , 0 ) ! = 0 ) : DCNL DCSP DCSP log.error ( &apos; Error DCSP removing DCSP a DCSP Postgresql DCSP cluster DCSP { 0 } / { 1 } &apos; .format ( version , name ) ) DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = &apos; Successfully DCSP removed DCSP cluster DCSP { 0 } / { 1 } &apos; .format ( version , name ) DCNL DCSP return ret
DCSP _ options = _ get _ options ( ret ) DCNL DCSP sid = _ options.get ( &apos; sid &apos; , None ) DCNL DCSP token = _ options.get ( &apos; token &apos; , None ) DCNL DCSP sender = _ options.get ( &apos; from &apos; , None ) DCNL DCSP receiver = _ options.get ( &apos; to &apos; , None ) DCNL DCSP if ( ( sid is None ) or ( token is None ) ) : DCNL DCSP DCSP log.error ( &apos; Twilio DCSP sid / authentication DCSP token DCSP missing &apos; ) DCNL DCSP DCSP return None DCNL DCSP if ( ( sender is None ) or ( receiver is None ) ) : DCNL DCSP DCSP log.error ( &apos; Twilio DCSP to / from DCSP fields DCSP are DCSP missing &apos; ) DCNL DCSP DCSP return None DCNL DCSP client = TwilioRestClient ( sid , token ) DCNL DCSP try : DCNL DCSP DCSP message = client.messages.create ( body = &apos; Minion : DCSP { 0 } \ nCmd : DCSP { 1 } \ nSuccess : DCSP { 2 } \ n \ nJid : DCSP { 3 } &apos; .format ( ret &#91; &apos; id &apos; &#93; , ret &#91; &apos; fun &apos; &#93; , ret &#91; &apos; success &apos; &#93; , ret &#91; &apos; jid &apos; &#93; ) , to = receiver , from _ = sender ) DCNL DCSP except TwilioRestException as e : DCNL DCSP DCSP log.error ( &apos; Twilio DCSP &#91; https : / / www.twilio.com / docs / errors / { 0 } &#93; &apos; .format ( e.code ) ) DCNL DCSP DCSP return False DCNL DCSP return True
DCSP return ensure _ compat ( &apos; expanding &apos; , &apos; quantile &apos; , arg , freq = freq , min _ periods = min _ periods , func _ kw = &#91; &apos; quantile &apos; &#93; , quantile = quantile )
DCSP assert isinstance ( expr , string _ types ) , ( u &apos; % s DCSP is DCSP not DCSP a DCSP string &apos; % expr ) DCNL DCSP return ( re.match ( u &apos; ^ &#91; A-Z &#93; \ \ d * $ &apos; , expr ) is not None )
DCSP localPath = os.path.join ( args.localOutputFolder , &apos; { 0 } - { 1 } &apos; .format ( client.conn.modules &#91; &apos; pupydroid.utils &apos; &#93; .getAndroidID ( ) , client.desc &#91; &apos; user &apos; &#93; ) ) DCNL DCSP if ( not os.path.exists ( localPath ) ) : DCNL DCSP DCSP logging.info ( &apos; Creating DCSP { 0 } DCSP folder DCSP locally &apos; .format ( localPath ) ) DCNL DCSP DCSP os.makedirs ( localPath ) DCNL DCSP return localPath
DCSP parser = ArgumentParser ( description = CMDLINE _ HELP ) DCNL DCSP parser.add _ argument ( &apos; --noserver &apos; , action = &apos; store _ true &apos; , dest = &apos; noserver &apos; , default = False , help = &apos; Do DCSP not DCSP start DCSP Server DCSP process &apos; ) DCNL DCSP parser.add _ argument ( &apos; --noportal &apos; , action = &apos; store _ true &apos; , dest = &apos; noportal &apos; , default = False , help = &apos; Do DCSP not DCSP start DCSP Portal DCSP process &apos; ) DCNL DCSP parser.add _ argument ( &apos; --logserver &apos; , action = &apos; store _ true &apos; , dest = &apos; logserver &apos; , default = False , help = &apos; Log DCSP Server DCSP output DCSP to DCSP logfile &apos; ) DCNL DCSP parser.add _ argument ( &apos; --iserver &apos; , action = &apos; store _ true &apos; , dest = &apos; iserver &apos; , default = False , help = &apos; Server DCSP in DCSP interactive DCSP mode &apos; ) DCNL DCSP parser.add _ argument ( &apos; --iportal &apos; , action = &apos; store _ true &apos; , dest = &apos; iportal &apos; , default = False , help = &apos; Portal DCSP in DCSP interactive DCSP mode &apos; ) DCNL DCSP parser.add _ argument ( &apos; --pserver &apos; , action = &apos; store _ true &apos; , dest = &apos; pserver &apos; , default = False , help = &apos; Profile DCSP Server &apos; ) DCNL DCSP parser.add _ argument ( &apos; --pportal &apos; , action = &apos; store _ true &apos; , dest = &apos; pportal &apos; , default = False , help = &apos; Profile DCSP Portal &apos; ) DCNL DCSP parser.add _ argument ( &apos; --nologcycle &apos; , action = &apos; store _ false &apos; , dest = &apos; nologcycle &apos; , default = True , help = &apos; Do DCSP not DCSP cycle DCSP log DCSP files &apos; ) DCNL DCSP parser.add _ argument ( &apos; --doexit &apos; , action = &apos; store _ true &apos; , dest = &apos; doexit &apos; , default = False , help = &apos; Immediately DCSP exit DCSP after DCSP processes DCSP have DCSP started . &apos; ) DCNL DCSP parser.add _ argument ( &apos; gamedir &apos; , help = &apos; path DCSP to DCSP game DCSP dir &apos; ) DCNL DCSP parser.add _ argument ( &apos; twistdbinary &apos; , help = &apos; path DCSP to DCSP twistd DCSP binary &apos; ) DCNL DCSP parser.add _ argument ( &apos; slogfile &apos; , help = &apos; path DCSP to DCSP server DCSP log DCSP file &apos; ) DCNL DCSP parser.add _ argument ( &apos; plogfile &apos; , help = &apos; path DCSP to DCSP portal DCSP log DCSP file &apos; ) DCNL DCSP parser.add _ argument ( &apos; hlogfile &apos; , help = &apos; path DCSP to DCSP http DCSP log DCSP file &apos; ) DCNL DCSP args = parser.parse _ args ( ) DCNL DCSP global GAMEDIR DCNL DCSP global SERVER _ LOGFILE , PORTAL _ LOGFILE , HTTP _ LOGFILE DCNL DCSP global SERVER _ PIDFILE , PORTAL _ PIDFILE DCNL DCSP global SERVER _ RESTART , PORTAL _ RESTART DCNL DCSP global SPROFILER _ LOGFILE , PPROFILER _ LOGFILE DCNL DCSP GAMEDIR = args.gamedir DCNL DCSP sys.path.insert ( 1 , os.path.join ( GAMEDIR , SERVERDIR ) ) DCNL DCSP SERVER _ PIDFILE = os.path.join ( GAMEDIR , SERVERDIR , &apos; server.pid &apos; ) DCNL DCSP PORTAL _ PIDFILE = os.path.join ( GAMEDIR , SERVERDIR , &apos; portal.pid &apos; ) DCNL DCSP SERVER _ RESTART = os.path.join ( GAMEDIR , SERVERDIR , &apos; server.restart &apos; ) DCNL DCSP PORTAL _ RESTART = os.path.join ( GAMEDIR , SERVERDIR , &apos; portal.restart &apos; ) DCNL DCSP SERVER _ LOGFILE = args.slogfile DCNL DCSP PORTAL _ LOGFILE = args.plogfile DCNL DCSP HTTP _ LOGFILE = args.hlogfile DCNL DCSP TWISTED _ BINARY = args.twistdbinary DCNL DCSP SPROFILER _ LOGFILE = os.path.join ( GAMEDIR , SERVERDIR , &apos; logs &apos; , &apos; server.prof &apos; ) DCNL DCSP PPROFILER _ LOGFILE = os.path.join ( GAMEDIR , SERVERDIR , &apos; logs &apos; , &apos; portal.prof &apos; ) DCNL DCSP server _ argv = &#91; TWISTED _ BINARY , &apos; --nodaemon &apos; , ( &apos; --logfile = % s &apos; % SERVER _ LOGFILE ) , ( &apos; --pidfile = % s &apos; % SERVER _ PIDFILE ) , ( &apos; --python = % s &apos; % SERVER _ PY _ FILE ) &#93; DCNL DCSP portal _ argv = &#91; TWISTED _ BINARY , ( &apos; --logfile = % s &apos; % PORTAL _ LOGFILE ) , ( &apos; --pidfile = % s &apos; % PORTAL _ PIDFILE ) , ( &apos; --python = % s &apos; % PORTAL _ PY _ FILE ) &#93; DCNL DCSP pserver _ argv = &#91; &apos; --savestats &apos; , &apos; --profiler = cprofile &apos; , ( &apos; --profile = % s &apos; % SPROFILER _ LOGFILE ) &#93; DCNL DCSP pportal _ argv = &#91; &apos; --savestats &apos; , &apos; --profiler = cprofile &apos; , ( &apos; --profile = % s &apos; % PPROFILER _ LOGFILE ) &#93; DCNL DCSP pid = get _ pid ( SERVER _ PIDFILE ) DCNL DCSP if ( pid and ( not args.noserver ) ) : DCNL DCSP DCSP print ( ( &apos; \ nEvennia DCSP Server DCSP is DCSP already DCSP running DCSP as DCSP process DCSP % ( pid ) s . DCSP Not DCSP restarted . &apos; % { &apos; pid &apos; : pid } ) ) DCNL DCSP DCSP args.noserver = True DCNL DCSP if args.noserver : DCNL DCSP DCSP server _ argv = None DCNL DCSP else : DCNL DCSP DCSP set _ restart _ mode ( SERVER _ RESTART , &apos; shutdown &apos; ) DCNL DCSP DCSP if ( not args.logserver ) : DCNL DCSP DCSP DCSP del server _ argv &#91; 2 &#93; DCNL DCSP DCSP DCSP print ( &apos; \ nStarting DCSP Evennia DCSP Server DCSP ( output DCSP to DCSP stdout ) . &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( not args.nologcycle ) : DCNL DCSP DCSP DCSP DCSP cycle _ logfile ( SERVER _ LOGFILE ) DCNL DCSP DCSP DCSP print ( &apos; \ nStarting DCSP Evennia DCSP Server DCSP ( output DCSP to DCSP server DCSP logfile ) . &apos; ) DCNL DCSP DCSP if args.pserver : DCNL DCSP DCSP DCSP server _ argv.extend ( pserver _ argv ) DCNL DCSP DCSP DCSP print ( &apos; \ nRunning DCSP Evennia DCSP Server DCSP under DCSP cProfile . &apos; ) DCNL DCSP pid = get _ pid ( PORTAL _ PIDFILE ) DCNL DCSP if ( pid and ( not args.noportal ) ) : DCNL DCSP DCSP print ( ( &apos; \ nEvennia DCSP Portal DCSP is DCSP already DCSP running DCSP as DCSP process DCSP % ( pid ) s . DCSP Not DCSP restarted . &apos; % { &apos; pid &apos; : pid } ) ) DCNL DCSP DCSP args.noportal = True DCNL DCSP if args.noportal : DCNL DCSP DCSP portal _ argv = None DCNL DCSP else : DCNL DCSP DCSP if args.iportal : DCNL DCSP DCSP DCSP portal _ argv &#91; 1 &#93; = &apos; --nodaemon &apos; DCNL DCSP DCSP DCSP set _ restart _ mode ( PORTAL _ RESTART , True ) DCNL DCSP DCSP DCSP print ( &apos; \ nStarting DCSP Evennia DCSP Portal DCSP in DCSP non-Daemon DCSP mode DCSP ( output DCSP to DCSP stdout ) . &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( not args.nologcycle ) : DCNL DCSP DCSP DCSP DCSP cycle _ logfile ( PORTAL _ LOGFILE ) DCNL DCSP DCSP DCSP DCSP cycle _ logfile ( HTTP _ LOGFILE ) DCNL DCSP DCSP DCSP set _ restart _ mode ( PORTAL _ RESTART , False ) DCNL DCSP DCSP DCSP print ( &apos; \ nStarting DCSP Evennia DCSP Portal DCSP in DCSP Daemon DCSP mode DCSP ( output DCSP to DCSP portal DCSP logfile ) . &apos; ) DCNL DCSP DCSP if args.pportal : DCNL DCSP DCSP DCSP portal _ argv.extend ( pportal _ argv ) DCNL DCSP DCSP DCSP print ( &apos; \ nRunning DCSP Evennia DCSP Portal DCSP under DCSP cProfile . &apos; ) DCNL DCSP if args.doexit : DCNL DCSP DCSP print ( PROCESS _ DOEXIT ) DCNL DCSP if ( os.name = = &apos; nt &apos; ) : DCNL DCSP DCSP if server _ argv : DCNL DCSP DCSP DCSP del server _ argv &#91; ( -2 ) &#93; DCNL DCSP DCSP if portal _ argv : DCNL DCSP DCSP DCSP del portal _ argv &#91; ( -2 ) &#93; DCNL DCSP start _ services ( server _ argv , portal _ argv , doexit = args.doexit )
DCSP try : DCNL DCSP DCSP return ( a * b ) DCNL DCSP except TypeError : DCNL DCSP DCSP return ( to _ decimal ( a ) * to _ decimal ( b ) )
DCSP def CheckDictionary ( C ) : DCNL DCSP DCSP C.newClassAttr = &apos; xyz &apos; DCNL DCSP DCSP AreEqual ( C.newClassAttr , &apos; xyz &apos; ) DCNL DCSP DCSP a = C ( ) DCNL DCSP DCSP a . _ _ dict _ _ &#91; 1 &#93; = &apos; 1&apos; DCNL DCSP DCSP if ( object in C. _ _ bases _ _ ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP C. _ _ dict _ _ &#91; 2 &#93; = &apos; 2&apos; DCNL DCSP DCSP DCSP DCSP AssertUnreachable ( ) DCNL DCSP DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP AreEqual ( C. _ _ dict _ _ .has _ key ( 2 ) , False ) DCNL DCSP DCSP AreEqual ( a . _ _ dict _ _ .has _ key ( 1 ) , True ) DCNL DCSP DCSP AreEqual ( dir ( a ) . _ _ contains _ _ ( 1 ) , True ) DCNL DCSP DCSP AreEqual ( repr ( a . _ _ dict _ _ ) , &quot; { 1 : DCSP &apos; 1&apos; } &quot; ) DCNL DCSP DCSP C.newTypeAttr = 1 DCNL DCSP DCSP AreEqual ( hasattr ( C , &apos; newTypeAttr &apos; ) , True ) DCNL DCSP DCSP class OldClass : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP if isinstance ( C , type ( OldClass ) ) : DCNL DCSP DCSP DCSP C. _ _ dict _ _ = dict ( C. _ _ dict _ _ ) DCNL DCSP DCSP DCSP AreEqual ( hasattr ( C , &apos; newTypeAttr &apos; ) , True ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP C. _ _ dict _ _ = { } DCNL DCSP DCSP DCSP DCSP AssertUnreachable ( ) DCNL DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP a.newInstanceAttr = 1 DCNL DCSP DCSP AreEqual ( hasattr ( a , &apos; newInstanceAttr &apos; ) , True ) DCNL DCSP DCSP a . _ _ dict _ _ = dict ( a . _ _ dict _ _ ) DCNL DCSP DCSP AreEqual ( hasattr ( a , &apos; newInstanceAttr &apos; ) , True ) DCNL DCSP DCSP a.abc = &apos; xyz &apos; DCNL DCSP DCSP AreEqual ( hasattr ( a , &apos; abc &apos; ) , True ) DCNL DCSP DCSP AreEqual ( getattr ( a , &apos; abc &apos; ) , &apos; xyz &apos; ) DCNL DCSP class OldClass : DCNL DCSP DCSP def _ _ init _ _ ( self ) : DCNL DCSP DCSP DCSP pass DCNL DCSP class NewClass ( object , ) : DCNL DCSP DCSP def _ _ init _ _ ( self ) : DCNL DCSP DCSP DCSP pass DCNL DCSP CheckDictionary ( OldClass ) DCNL DCSP CheckDictionary ( NewClass )
DCSP class GenericRelatedObjectManager ( superclass , ) : DCNL DCSP DCSP def _ _ init _ _ ( self , model = None , instance = None , symmetrical = None , source _ col _ name = None , target _ col _ name = None , content _ type = None , content _ type _ field _ name = None , object _ id _ field _ name = None , prefetch _ cache _ name = None ) : DCNL DCSP DCSP DCSP super ( GenericRelatedObjectManager , self ) . _ _ init _ _ ( ) DCNL DCSP DCSP DCSP self.model = model DCNL DCSP DCSP DCSP self.content _ type = content _ type DCNL DCSP DCSP DCSP self.symmetrical = symmetrical DCNL DCSP DCSP DCSP self.instance = instance DCNL DCSP DCSP DCSP self.source _ col _ name = source _ col _ name DCNL DCSP DCSP DCSP self.target _ col _ name = target _ col _ name DCNL DCSP DCSP DCSP self.content _ type _ field _ name = content _ type _ field _ name DCNL DCSP DCSP DCSP self.object _ id _ field _ name = object _ id _ field _ name DCNL DCSP DCSP DCSP self.prefetch _ cache _ name = prefetch _ cache _ name DCNL DCSP DCSP DCSP self.pk _ val = self.instance. _ get _ pk _ val ( ) DCNL DCSP DCSP DCSP self.core _ filters = { ( u &apos; % s _ _ pk &apos; % content _ type _ field _ name ) : content _ type.id , ( u &apos; % s _ _ exact &apos; % object _ id _ field _ name ) : instance . _ get _ pk _ val ( ) } DCNL DCSP DCSP def get _ query _ set ( self ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return self.instance. _ prefetched _ objects _ cache &#91; self.prefetch _ cache _ name &#93; DCNL DCSP DCSP DCSP except ( AttributeError , KeyError ) : DCNL DCSP DCSP DCSP DCSP db = ( self . _ db or router.db _ for _ read ( self.model , instance = self.instance ) ) DCNL DCSP DCSP DCSP DCSP return super ( GenericRelatedObjectManager , self ) .get _ query _ set ( ) .using ( db ) .filter ( * * self.core _ filters ) DCNL DCSP DCSP def get _ prefetch _ query _ set ( self , instances ) : DCNL DCSP DCSP DCSP db = ( self . _ db or router.db _ for _ read ( self.model , instance = instances &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP query = { ( u &apos; % s _ _ pk &apos; % self.content _ type _ field _ name ) : self.content _ type.id , ( u &apos; % s _ _ in &apos; % self.object _ id _ field _ name ) : set ( ( obj . _ get _ pk _ val ( ) for obj in instances ) ) } DCNL DCSP DCSP DCSP qs = super ( GenericRelatedObjectManager , self ) .get _ query _ set ( ) .using ( db ) .filter ( * * query ) DCNL DCSP DCSP DCSP object _ id _ converter = instances &#91; 0 &#93; . _ meta.pk.to _ python DCNL DCSP DCSP DCSP return ( qs , ( lambda relobj : object _ id _ converter ( getattr ( relobj , self.object _ id _ field _ name ) ) ) , ( lambda obj : obj . _ get _ pk _ val ( ) ) , False , self.prefetch _ cache _ name ) DCNL DCSP DCSP def add ( self , * objs ) : DCNL DCSP DCSP DCSP for obj in objs : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( obj , self.model ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise TypeError ( ( u &quot; &apos; % s &apos; DCSP instance DCSP expected &quot; % self.model. _ meta.object _ name ) ) DCNL DCSP DCSP DCSP DCSP setattr ( obj , self.content _ type _ field _ name , self.content _ type ) DCNL DCSP DCSP DCSP DCSP setattr ( obj , self.object _ id _ field _ name , self.pk _ val ) DCNL DCSP DCSP DCSP DCSP obj.save ( ) DCNL DCSP DCSP add.alters _ data = True DCNL DCSP DCSP def remove ( self , * objs ) : DCNL DCSP DCSP DCSP db = router.db _ for _ write ( self.model , instance = self.instance ) DCNL DCSP DCSP DCSP for obj in objs : DCNL DCSP DCSP DCSP DCSP obj.delete ( using = db ) DCNL DCSP DCSP remove.alters _ data = True DCNL DCSP DCSP def clear ( self ) : DCNL DCSP DCSP DCSP db = router.db _ for _ write ( self.model , instance = self.instance ) DCNL DCSP DCSP DCSP for obj in self.all ( ) : DCNL DCSP DCSP DCSP DCSP obj.delete ( using = db ) DCNL DCSP DCSP clear.alters _ data = True DCNL DCSP DCSP def create ( self , * * kwargs ) : DCNL DCSP DCSP DCSP kwargs &#91; self.content _ type _ field _ name &#93; = self.content _ type DCNL DCSP DCSP DCSP kwargs &#91; self.object _ id _ field _ name &#93; = self.pk _ val DCNL DCSP DCSP DCSP db = router.db _ for _ write ( self.model , instance = self.instance ) DCNL DCSP DCSP DCSP return super ( GenericRelatedObjectManager , self ) .using ( db ) .create ( * * kwargs ) DCNL DCSP DCSP create.alters _ data = True DCNL DCSP return GenericRelatedObjectManager
DCSP mi = MetaInformation ( _ ( &apos; Unknown &apos; ) , &#91; _ ( &apos; Unknown &apos; ) &#93; ) DCNL DCSP stream.seek ( 0 ) DCNL DCSP pml = &apos; &apos; DCNL DCSP if stream.name.endswith ( &apos; .pmlz &apos; ) : DCNL DCSP DCSP with TemporaryDirectory ( &apos; _ unpmlz &apos; ) as tdir : DCNL DCSP DCSP DCSP zf = ZipFile ( stream ) DCNL DCSP DCSP DCSP zf.extractall ( tdir ) DCNL DCSP DCSP DCSP pmls = glob.glob ( os.path.join ( tdir , &apos; * .pml &apos; ) ) DCNL DCSP DCSP DCSP for p in pmls : DCNL DCSP DCSP DCSP DCSP with open ( p , &apos; r + b &apos; ) as p _ stream : DCNL DCSP DCSP DCSP DCSP DCSP pml + = p _ stream.read ( ) DCNL DCSP DCSP DCSP if extract _ cover : DCNL DCSP DCSP DCSP DCSP mi.cover _ data = get _ cover ( os.path.splitext ( os.path.basename ( stream.name ) ) &#91; 0 &#93; , tdir , True ) DCNL DCSP else : DCNL DCSP DCSP pml = stream.read ( ) DCNL DCSP DCSP if extract _ cover : DCNL DCSP DCSP DCSP mi.cover _ data = get _ cover ( os.path.splitext ( os.path.basename ( stream.name ) ) &#91; 0 &#93; , os.path.abspath ( os.path.dirname ( stream.name ) ) ) DCNL DCSP for comment in re.findall ( &apos; ( ? mus ) \ \ \ \ v. * ? \ \ \ \ v &apos; , pml ) : DCNL DCSP DCSP m = re.search ( &apos; TITLE = &quot; ( . * ? ) &quot; &apos; , comment ) DCNL DCSP DCSP if m : DCNL DCSP DCSP DCSP mi.title = re.sub ( &apos; &#91; \ x00- \ x1f &#93; &apos; , &apos; &apos; , prepare _ string _ for _ xml ( m.group ( 1 ) .strip ( ) .decode ( &apos; cp1252 &apos; , &apos; replace &apos; ) ) ) DCNL DCSP DCSP m = re.search ( &apos; AUTHOR = &quot; ( . * ? ) &quot; &apos; , comment ) DCNL DCSP DCSP if m : DCNL DCSP DCSP DCSP if ( mi.authors = = &#91; _ ( &apos; Unknown &apos; ) &#93; ) : DCNL DCSP DCSP DCSP DCSP mi.authors = &#91; &#93; DCNL DCSP DCSP DCSP mi.authors.append ( re.sub ( &apos; &#91; \ x00- \ x1f &#93; &apos; , &apos; &apos; , prepare _ string _ for _ xml ( m.group ( 1 ) .strip ( ) .decode ( &apos; cp1252 &apos; , &apos; replace &apos; ) ) ) ) DCNL DCSP DCSP m = re.search ( &apos; PUBLISHER = &quot; ( . * ? ) &quot; &apos; , comment ) DCNL DCSP DCSP if m : DCNL DCSP DCSP DCSP mi.publisher = re.sub ( &apos; &#91; \ x00- \ x1f &#93; &apos; , &apos; &apos; , prepare _ string _ for _ xml ( m.group ( 1 ) .strip ( ) .decode ( &apos; cp1252 &apos; , &apos; replace &apos; ) ) ) DCNL DCSP DCSP m = re.search ( &apos; COPYRIGHT = &quot; ( . * ? ) &quot; &apos; , comment ) DCNL DCSP DCSP if m : DCNL DCSP DCSP DCSP mi.rights = re.sub ( &apos; &#91; \ x00- \ x1f &#93; &apos; , &apos; &apos; , prepare _ string _ for _ xml ( m.group ( 1 ) .strip ( ) .decode ( &apos; cp1252 &apos; , &apos; replace &apos; ) ) ) DCNL DCSP DCSP m = re.search ( &apos; ISBN = &quot; ( . * ? ) &quot; &apos; , comment ) DCNL DCSP DCSP if m : DCNL DCSP DCSP DCSP mi.isbn = re.sub ( &apos; &#91; \ x00- \ x1f &#93; &apos; , &apos; &apos; , prepare _ string _ for _ xml ( m.group ( 1 ) .strip ( ) .decode ( &apos; cp1252 &apos; , &apos; replace &apos; ) ) ) DCNL DCSP return mi
DCSP global readline _ hook , readline _ ref DCNL DCSP readline _ hook = hook DCNL DCSP PyOS _ RFP = c _ int.from _ address ( Console.GetProcAddress ( sys.dllhandle , &apos; PyOS _ ReadlineFunctionPointer &apos; ) ) DCNL DCSP if ( sys.version &lt; &apos; 2.3 &apos; ) : DCNL DCSP DCSP readline _ ref = HOOKFUNC22 ( hook _ wrapper ) DCNL DCSP else : DCNL DCSP DCSP readline _ ref = HOOKFUNC23 ( hook _ wrapper _ 23 ) DCNL DCSP func _ start = c _ int.from _ address ( addressof ( readline _ ref ) ) .value DCNL DCSP PyOS _ RFP.value = func _ start
DCSP cmdsuf = &apos; &apos; DCNL DCSP if ( platform.system ( ) = = &apos; Windows &apos; ) : DCNL DCSP DCSP cmdsuf = &apos; .bat &apos; DCNL DCSP DCSP cmd = ( &apos; @ echo DCSP off \ r \ n &apos; + cmd ) DCNL DCSP ( handle , path ) = tempfile.mkstemp ( text = True , dir = tmpdir , suffix = cmdsuf ) DCNL DCSP os.write ( handle , cmd.encode ( &apos; utf-8 &apos; ) ) DCNL DCSP os.close ( handle ) DCNL DCSP os.chmod ( path , stat.S _ IRWXU ) DCNL DCSP proc = Popen ( path , shell = True , stdout = PIPE , stderr = PIPE ) DCNL DCSP proc.wait ( ) DCNL DCSP ( stdout , _ ) = proc.communicate ( ) DCNL DCSP os.unlink ( path ) DCNL DCSP return _ chomp ( as _ unicode ( stdout ) )
DCSP if ( composer is not None ) : DCNL DCSP DCSP if ( php is None ) : DCNL DCSP DCSP DCSP php = &apos; php &apos; DCNL DCSP else : DCNL DCSP DCSP composer = &apos; composer &apos; DCNL DCSP if ( not _ valid _ composer ( composer ) ) : DCNL DCSP DCSP raise CommandNotFoundError ( &quot; &apos; composer . { 0 } &apos; DCSP is DCSP not DCSP available . DCSP Couldn &apos;t DCSP find DCSP &apos; { 1 } &apos; . &quot; .format ( action , composer ) ) DCNL DCSP if ( action is None ) : DCNL DCSP DCSP raise SaltInvocationError ( &quot; The DCSP &apos; action &apos; DCSP argument DCSP is DCSP required &quot; ) DCNL DCSP if ( ( directory is None ) and ( action ! = &apos; selfupdate &apos; ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &quot; The DCSP &apos; directory &apos; DCSP argument DCSP is DCSP required DCSP for DCSP composer . { 0 } &quot; .format ( action ) ) DCNL DCSP cmd = &#91; composer , action , &apos; --no-interaction &apos; , &apos; --no-ansi &apos; &#93; DCNL DCSP if ( extra _ flags is not None ) : DCNL DCSP DCSP cmd.extend ( salt.utils.shlex _ split ( extra _ flags ) ) DCNL DCSP if ( php is not None ) : DCNL DCSP DCSP cmd = ( &#91; php &#93; + cmd ) DCNL DCSP if ( directory is not None ) : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --working-dir &apos; , directory &#93; ) DCNL DCSP if ( quiet is True ) : DCNL DCSP DCSP cmd.append ( &apos; --quiet &apos; ) DCNL DCSP if ( no _ dev is True ) : DCNL DCSP DCSP cmd.append ( &apos; --no-dev &apos; ) DCNL DCSP if ( prefer _ source is True ) : DCNL DCSP DCSP cmd.append ( &apos; --prefer-source &apos; ) DCNL DCSP if ( prefer _ dist is True ) : DCNL DCSP DCSP cmd.append ( &apos; --prefer-dist &apos; ) DCNL DCSP if ( no _ scripts is True ) : DCNL DCSP DCSP cmd.append ( &apos; --no-scripts &apos; ) DCNL DCSP if ( no _ plugins is True ) : DCNL DCSP DCSP cmd.append ( &apos; --no-plugins &apos; ) DCNL DCSP if ( optimize is True ) : DCNL DCSP DCSP cmd.append ( &apos; --optimize-autoloader &apos; ) DCNL DCSP result = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , runas = runas , env = { &apos; COMPOSER _ HOME &apos; : composer _ home } , python _ shell = False ) DCNL DCSP if ( result &#91; &apos; retcode &apos; &#93; ! = 0 ) : DCNL DCSP DCSP raise CommandExecutionError ( result &#91; &apos; stderr &apos; &#93; ) DCNL DCSP if ( quiet is True ) : DCNL DCSP DCSP return True DCNL DCSP return result
DCSP tags = set ( &#91; tag for cond in conditions for tag in cond.split ( &apos; / &apos; ) &#93; ) DCNL DCSP msg = &quot; Can &apos;t DCSP map DCSP between DCSP conditions DCSP and DCSP the DCSP provided DCSP { 0 } . DCSP Make DCSP sure DCSP you DCSP have DCSP provided DCSP keys DCSP in DCSP the DCSP format DCSP of DCSP &apos; / &apos; -separated DCSP tags , DCSP and DCSP that DCSP these DCSP correspond DCSP to DCSP &apos; / &apos; -separated DCSP tags DCSP for DCSP the DCSP condition DCSP names DCSP ( e.g. , DCSP conditions DCSP like DCSP &apos; Visual / Right &apos; , DCSP and DCSP styles DCSP like DCSP &apos; colors = dict ( Visual = &apos; red &apos; ) ) &apos; . DCSP The DCSP offending DCSP tag DCSP was DCSP &apos; { 1 } &apos; . &quot; DCNL DCSP for key in style _ dict : DCNL DCSP DCSP for tag in key.split ( &apos; / &apos; ) : DCNL DCSP DCSP DCSP if ( tag not in tags ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg.format ( style , tag ) ) DCNL DCSP condition _ warning = ( &apos; Condition DCSP { 0 } DCSP could DCSP not DCSP be DCSP mapped DCSP to DCSP a DCSP &apos; + style ) DCNL DCSP style _ warning = &apos; . DCSP Using DCSP the DCSP default DCSP of DCSP { 0 } . &apos; .format ( default ) DCNL DCSP for condition in conditions : DCNL DCSP DCSP if ( condition not in style _ dict ) : DCNL DCSP DCSP DCSP if ( &apos; / &apos; not in condition ) : DCNL DCSP DCSP DCSP DCSP warn ( ( condition _ warning.format ( condition ) + style _ warning ) ) DCNL DCSP DCSP DCSP DCSP style _ dict &#91; condition &#93; = default DCNL DCSP DCSP DCSP for style _ in style _ dict : DCNL DCSP DCSP DCSP DCSP if ( style _ in condition.split ( &apos; / &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP style _ dict &#91; condition &#93; = style _ dict &#91; style _ &#93; DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP return style _ dict
DCSP try : DCNL DCSP DCSP json _ data = json.loads ( json _ string ) DCNL DCSP except : DCNL DCSP DCSP raise SchemaParseException ( ( &apos; Error DCSP parsing DCSP JSON : DCSP % s &apos; % json _ string ) ) DCNL DCSP names = Names ( ) DCNL DCSP return make _ avsc _ object ( json _ data , names )
DCSP run _ app = False DCNL DCSP if ( hasattr ( settings , &apos; LETTUCE _ AVOID _ APPS &apos; ) and isinstance ( settings.LETTUCE _ AVOID _ APPS , ( list , tuple ) ) ) : DCNL DCSP DCSP for appname in settings.LETTUCE _ AVOID _ APPS : DCNL DCSP DCSP DCSP if module . _ _ name _ _ .startswith ( appname ) : DCNL DCSP DCSP DCSP DCSP run _ app = True DCNL DCSP return ( not run _ app )
DCSP labels = &#91; &#93; DCNL DCSP for hemi in set ( hemis ) : DCNL DCSP DCSP hemi _ index = ( hemis = = hemi ) DCNL DCSP DCSP seeds = seeds _ &#91; hemi _ index &#93; DCNL DCSP DCSP extents = extents _ &#91; hemi _ index &#93; DCNL DCSP DCSP names = names _ &#91; hemi _ index &#93; DCNL DCSP DCSP graph = graphs &#91; hemi &#93; DCNL DCSP DCSP n _ vertices = len ( vertices _ &#91; hemi &#93; ) DCNL DCSP DCSP n _ labels = len ( seeds ) DCNL DCSP DCSP parc = np.empty ( n _ vertices , dtype = &apos; int32 &apos; ) DCNL DCSP DCSP parc &#91; : &#93; = ( -1 ) DCNL DCSP DCSP sources = { } DCNL DCSP DCSP edge = &#91; &#93; DCNL DCSP DCSP for ( label , seed ) in enumerate ( seeds ) : DCNL DCSP DCSP DCSP if np.any ( ( parc &#91; seed &#93; &gt; = 0 ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Overlapping DCSP seeds &apos; ) DCNL DCSP DCSP DCSP parc &#91; seed &#93; = label DCNL DCSP DCSP DCSP for s in np.atleast _ 1d ( seed ) : DCNL DCSP DCSP DCSP DCSP sources &#91; s &#93; = ( label , 0.0 ) DCNL DCSP DCSP DCSP DCSP edge.append ( s ) DCNL DCSP DCSP while edge : DCNL DCSP DCSP DCSP vert _ from = edge.pop ( 0 ) DCNL DCSP DCSP DCSP ( label , old _ dist ) = sources &#91; vert _ from &#93; DCNL DCSP DCSP DCSP row = graph &#91; vert _ from , : &#93; DCNL DCSP DCSP DCSP for ( vert _ to , dist ) in zip ( row.indices , row.data ) : DCNL DCSP DCSP DCSP DCSP new _ dist = ( old _ dist + dist ) DCNL DCSP DCSP DCSP DCSP if ( new _ dist &gt; extents &#91; label &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP vert _ to _ label = parc &#91; vert _ to &#93; DCNL DCSP DCSP DCSP DCSP if ( vert _ to _ label &gt; = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP ( _ , vert _ to _ dist ) = sources &#91; vert _ to &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( new _ dist &gt; vert _ to _ dist ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP elif ( vert _ to in edge ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP edge.remove ( vert _ to ) DCNL DCSP DCSP DCSP DCSP parc &#91; vert _ to &#93; = label DCNL DCSP DCSP DCSP DCSP sources &#91; vert _ to &#93; = ( label , new _ dist ) DCNL DCSP DCSP DCSP DCSP edge.append ( vert _ to ) DCNL DCSP DCSP for i in xrange ( n _ labels ) : DCNL DCSP DCSP DCSP vertices = np.nonzero ( ( parc = = i ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP name = str ( names &#91; i &#93; ) DCNL DCSP DCSP DCSP label _ = Label ( vertices , hemi = hemi , name = name , subject = subject ) DCNL DCSP DCSP DCSP labels.append ( label _ ) DCNL DCSP return labels
DCSP result = &#91; &#93; DCNL DCSP num _ tests = 0 DCNL DCSP for ( g1 _ idx , ( g1 _ label , g1 _ dist ) ) in enumerate ( zip ( labels &#91; : ( -1 ) &#93; , dists &#91; : ( -1 ) &#93; ) ) : DCNL DCSP DCSP for ( g2 _ label , g2 _ dist ) in zip ( labels &#91; ( g1 _ idx + 1 ) : &#93; , dists &#91; ( g1 _ idx + 1 ) : &#93; ) : DCNL DCSP DCSP DCSP if ( ( ( len ( g1 _ dist ) = = 1 ) and ( len ( g2 _ dist ) = = 1 ) ) or ( ( len ( g1 _ dist ) &lt; 1 ) or ( len ( g2 _ dist ) &lt; 1 ) ) ) : DCNL DCSP DCSP DCSP DCSP ( obs _ t , param _ p _ val , nonparam _ p _ val ) = ( nan , nan , nan ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ( obs _ t , param _ p _ val , _ , nonparam _ p _ val ) = mc _ t _ two _ sample ( g1 _ dist , g2 _ dist , tails = tail _ type , permutations = num _ permutations ) DCNL DCSP DCSP DCSP result.append ( &#91; g1 _ label , g2 _ label , obs _ t , param _ p _ val , None , nonparam _ p _ val , None &#93; ) DCNL DCSP DCSP DCSP if ( not isnan ( obs _ t ) ) : DCNL DCSP DCSP DCSP DCSP num _ tests + = 1 DCNL DCSP for stat in result : DCNL DCSP DCSP corr _ param _ p _ val = stat &#91; 3 &#93; DCNL DCSP DCSP if ( ( corr _ param _ p _ val is not None ) and ( not isnan ( corr _ param _ p _ val ) ) ) : DCNL DCSP DCSP DCSP corr _ param _ p _ val = min ( ( corr _ param _ p _ val * num _ tests ) , 1 ) DCNL DCSP DCSP stat &#91; 4 &#93; = corr _ param _ p _ val DCNL DCSP DCSP corr _ nonparam _ p _ val = stat &#91; 5 &#93; DCNL DCSP DCSP if ( ( corr _ nonparam _ p _ val is not None ) and ( not isnan ( corr _ nonparam _ p _ val ) ) ) : DCNL DCSP DCSP DCSP corr _ nonparam _ p _ val = min ( ( corr _ nonparam _ p _ val * num _ tests ) , 1 ) DCNL DCSP DCSP stat &#91; 6 &#93; = corr _ nonparam _ p _ val DCNL DCSP return result
DCSP req = servers _ service _ pb.GetNumInstancesRequest ( ) DCNL DCSP if server : DCNL DCSP DCSP req.set _ server ( server ) DCNL DCSP if version : DCNL DCSP DCSP req.set _ version ( version ) DCNL DCSP resp = servers _ service _ pb.GetNumInstancesResponse ( ) DCNL DCSP try : DCNL DCSP DCSP apiproxy _ stub _ map.MakeSyncCall ( &apos; servers &apos; , &apos; GetNumInstances &apos; , req , resp ) DCNL DCSP except apiproxy _ errors.ApplicationError as e : DCNL DCSP DCSP if ( e.application _ error = = servers _ service _ pb.ServersServiceError.INVALID _ VERSION ) : DCNL DCSP DCSP DCSP raise InvalidVersionError ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise Error ( ) DCNL DCSP return resp.instances ( )
DCSP if key : DCNL DCSP DCSP ret = _ _ pillar _ _ .get ( key , { } ) DCNL DCSP else : DCNL DCSP DCSP ret = _ _ pillar _ _ DCNL DCSP return ret
DCSP if ( strings _ only and isinstance ( s , ( types.NoneType , int ) ) ) : DCNL DCSP DCSP return s DCNL DCSP if ( not isinstance ( s , basestring ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return str ( s ) DCNL DCSP DCSP except UnicodeEncodeError : DCNL DCSP DCSP DCSP if isinstance ( s , Exception ) : DCNL DCSP DCSP DCSP DCSP return &apos; DCSP &apos; .join ( &#91; smart _ str ( arg , encoding , strings _ only , errors ) for arg in s &#93; ) DCNL DCSP DCSP DCSP return unicode ( s ) .encode ( encoding , errors ) DCNL DCSP elif isinstance ( s , unicode ) : DCNL DCSP DCSP return s.encode ( encoding , errors ) DCNL DCSP elif ( s and ( encoding ! = &apos; utf-8 &apos; ) ) : DCNL DCSP DCSP return s.decode ( &apos; utf-8 &apos; , errors ) .encode ( encoding , errors ) DCNL DCSP else : DCNL DCSP DCSP return s
DCSP return force _ unicode ( formats.localize ( value , use _ l10n = True ) )
DCSP pass
DCSP _ test _ functionality ( &apos; gl2 &apos; )
DCSP if ( results and results &#91; &apos; response &apos; &#93; and results &#91; &apos; response &apos; &#93; &#91; &apos; docs &apos; &#93; ) : DCNL DCSP DCSP search _ data = results &#91; &apos; response &apos; &#93; &#91; &apos; docs &apos; &#93; DCNL DCSP DCSP if collection &#91; &apos; template &apos; &#93; &#91; &apos; fieldsSelected &apos; &#93; : DCNL DCSP DCSP DCSP headers = collection &#91; &apos; template &apos; &#93; &#91; &apos; fieldsSelected &apos; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP headers = &#91; field &#91; &apos; name &apos; &#93; for field in collection &#91; &apos; fields &apos; &#93; &#93; DCNL DCSP DCSP rows = &#91; &#93; DCNL DCSP DCSP for data in search _ data : DCNL DCSP DCSP DCSP row = &#91; &#93; DCNL DCSP DCSP DCSP for column in headers : DCNL DCSP DCSP DCSP DCSP if ( column not in data ) : DCNL DCSP DCSP DCSP DCSP DCSP row.append ( &apos; &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( isinstance ( data &#91; column &#93; , basestring ) or isinstance ( data &#91; column &#93; , ( int , long , float , complex ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP row.append ( data &#91; column &#93; ) DCNL DCSP DCSP DCSP DCSP elif isinstance ( data &#91; column &#93; , list ) : DCNL DCSP DCSP DCSP DCSP DCSP row.append ( &#91; smart _ str ( val , errors = &apos; replace &apos; ) for val in data &#91; column &#93; &#93; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP row.append ( smart _ str ( data &#91; column &#93; ) ) DCNL DCSP DCSP DCSP rows.append ( row ) DCNL DCSP else : DCNL DCSP DCSP rows = &#91; &#91; &#93; &#93; DCNL DCSP ( yield ( headers , rows ) )
DCSP if ( not len ( args ) ) : DCNL DCSP DCSP ax = gca ( ) DCNL DCSP else : DCNL DCSP DCSP ax = args &#91; 0 &#93; DCNL DCSP ret = gcf ( ) .delaxes ( ax ) DCNL DCSP return ret
DCSP return IMPL.volume _ get _ all _ by _ group ( context , group _ id , filters = filters )
DCSP if ( not salt.utils.is _ darwin ( ) ) : DCNL DCSP DCSP return ( False , &apos; The DCSP mac _ system DCSP module DCSP could DCSP not DCSP be DCSP loaded : DCSP module DCSP only DCSP works DCSP on DCSP MacOS DCSP systems . &apos; ) DCNL DCSP if ( not _ atrun _ enabled ( ) ) : DCNL DCSP DCSP if ( not _ enable _ atrun ( ) ) : DCNL DCSP DCSP DCSP return ( False , &apos; atrun DCSP could DCSP not DCSP be DCSP enabled DCSP on DCSP this DCSP system &apos; ) DCNL DCSP return _ _ virtualname _ _
DCSP tf = tornado.concurrent.Future ( ) DCNL DCSP tornado.concurrent.chain _ future ( asyncio _ future , tf ) DCNL DCSP return tf
DCSP if ( s.count ( &apos; &quot; &apos; ) % 2 ) : DCNL DCSP DCSP return &apos; &quot; &apos; DCNL DCSP elif ( s.count ( &quot; &apos; &quot; ) % 2 ) : DCNL DCSP DCSP return &quot; &apos; &quot; DCNL DCSP else : DCNL DCSP DCSP return False
DCSP zip _ file = tempfile.NamedTemporaryFile ( prefix = &apos; tmp _ securedrop _ bulk _ dl _ &apos; , dir = config.TEMP _ DIR , delete = False ) DCNL DCSP sources = set ( &#91; i.source.journalist _ designation for i in selected _ submissions &#93; ) DCNL DCSP with zipfile.ZipFile ( zip _ file , &apos; w &apos; ) as zip : DCNL DCSP DCSP for source in sources : DCNL DCSP DCSP DCSP submissions = &#91; s for s in selected _ submissions if ( s.source.journalist _ designation = = source ) &#93; DCNL DCSP DCSP DCSP for submission in submissions : DCNL DCSP DCSP DCSP DCSP filename = path ( submission.source.filesystem _ id , submission.filename ) DCNL DCSP DCSP DCSP DCSP verify ( filename ) DCNL DCSP DCSP DCSP DCSP document _ number = submission.filename.split ( &apos; -&apos; ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP zip.write ( filename , arcname = os.path.join ( zip _ directory , source , ( &apos; % s _ % s &apos; % ( document _ number , submission.source.last _ updated.date ( ) ) ) , os.path.basename ( filename ) ) ) DCNL DCSP return zip _ file
DCSP from .. feature import hessian _ matrix , hessian _ matrix _ eigvals DCNL DCSP sigmas = np.arange ( scale _ range &#91; 0 &#93; , scale _ range &#91; 1 &#93; , scale _ step ) DCNL DCSP if np.any ( ( np.asarray ( sigmas ) &lt; 0.0 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Sigma DCSP values DCSP less DCSP than DCSP zero DCSP are DCSP not DCSP valid &apos; ) DCNL DCSP beta1 = ( 2 * ( beta1 * * 2 ) ) DCNL DCSP beta2 = ( 2 * ( beta2 * * 2 ) ) DCNL DCSP filtered _ array = np.zeros ( ( sigmas.shape + image.shape ) ) DCNL DCSP lambdas _ array = np.zeros ( ( sigmas.shape + image.shape ) ) DCNL DCSP for ( i , sigma ) in enumerate ( sigmas ) : DCNL DCSP DCSP ( Drr , Drc , Dcc ) = hessian _ matrix ( image , sigma , order = &apos; rc &apos; ) DCNL DCSP DCSP Drr = ( ( sigma * * 2 ) * Drr ) DCNL DCSP DCSP Drc = ( ( sigma * * 2 ) * Drc ) DCNL DCSP DCSP Dcc = ( ( sigma * * 2 ) * Dcc ) DCNL DCSP DCSP ( lambda1 , lambda2 ) = hessian _ matrix _ eigvals ( Drr , Drc , Dcc ) DCNL DCSP DCSP lambda1 &#91; ( lambda1 = = 0 ) &#93; = 1e-10 DCNL DCSP DCSP rb = ( ( lambda2 / lambda1 ) * * 2 ) DCNL DCSP DCSP s2 = ( ( lambda1 * * 2 ) + ( lambda2 * * 2 ) ) DCNL DCSP DCSP filtered = ( np.exp ( ( ( - rb ) / beta1 ) ) * ( np.ones ( np.shape ( image ) ) - np.exp ( ( ( - s2 ) / beta2 ) ) ) ) DCNL DCSP DCSP filtered _ array &#91; i &#93; = filtered DCNL DCSP DCSP lambdas _ array &#91; i &#93; = lambda1 DCNL DCSP return ( filtered _ array , lambdas _ array )
DCSP cmd = &#91; &apos; netsh &apos; , &apos; interface &apos; , &apos; ip &apos; , &apos; set &apos; , &apos; dns &apos; , interface , &apos; source = dhcp &apos; &#93; DCNL DCSP return ( _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( cmd , python _ shell = False ) = = 0 )
DCSP weight = _ weight _ function ( G , weight ) DCNL DCSP pred = { source : &#91; &#93; } DCNL DCSP return ( pred , _ dijkstra ( G , source , weight , pred = pred , cutoff = cutoff ) )
DCSP if ( jidstring in _ _ internJIDs ) : DCNL DCSP DCSP return _ _ internJIDs &#91; jidstring &#93; DCNL DCSP else : DCNL DCSP DCSP j = JID ( jidstring ) DCNL DCSP DCSP _ _ internJIDs &#91; jidstring &#93; = j DCNL DCSP DCSP return j
DCSP if exclude _ system : DCNL DCSP DCSP result = Role.query ( system = False ) DCNL DCSP else : DCNL DCSP DCSP result = Role.get _ all ( ) DCNL DCSP return result
DCSP ip = request.META.get ( &apos; REMOTE _ ADDR &apos; , &apos; &apos; ) DCNL DCSP ua = request.META.get ( &apos; User-Agent &apos; , &apos; &apos; ) DCNL DCSP session _ key = ( request.session.session _ key or &apos; &apos; ) DCNL DCSP return hashlib.sha1 ( &apos; -&apos;.join ( map ( str , ( ip , ua , session _ key ) ) ) ) .hexdigest ( )
DCSP X _ sym = tensor.tensor4 ( &apos; X &apos; ) DCNL DCSP pool _ it = max _ pool ( X _ sym , pool _ shape = ( 2 , 2 ) , pool _ stride = ( 2 , 2 ) , image _ shape = ( 6 , 4 ) ) DCNL DCSP f = theano.function ( inputs = &#91; X _ sym &#93; , outputs = pool _ it ) DCNL DCSP X = np.array ( &#91; &#91; 2 , 1 , 3 , 4 &#93; , &#91; 1 , 1 , 3 , 3 &#93; , &#91; 5 , 5 , 7 , 7 &#93; , &#91; 5 , 6 , 8 , 7 &#93; , &#91; 9 , 10 , 11 , 12 &#93; , &#91; 9 , 10 , 12 , 12 &#93; &#93; , dtype = theano.config.floatX ) &#91; np.newaxis , np.newaxis , ... &#93; DCNL DCSP expected = np.array ( &#91; &#91; 2 , 4 &#93; , &#91; 6 , 8 &#93; , &#91; 10 , 12 &#93; &#93; , dtype = theano.config.floatX ) &#91; np.newaxis , np.newaxis , ... &#93; DCNL DCSP actual = f ( X ) DCNL DCSP assert np.allclose ( expected , actual )
DCSP nn = &apos; rnd &apos; DCNL DCSP allknn = AllKNN ( n _ neighbors = nn , random _ state = RND _ SEED , kind _ sel = &apos; mode &apos; ) DCNL DCSP assert _ raises ( ValueError , allknn.fit _ sample , X , Y )
DCSP return metadata _ columns.union ( viewvalues ( columns ) )
DCSP bits = token.split _ contents ( ) DCNL DCSP parsed = False DCNL DCSP if ( len ( bits ) not in ( 2 , 3 ) ) : DCNL DCSP DCSP raise TemplateSyntaxError ( u &quot; &apos; ssi &apos; DCSP tag DCSP takes DCSP one DCSP argument : DCSP the DCSP path DCSP to DCSP the DCSP file DCSP to DCSP be DCSP included &quot; ) DCNL DCSP if ( len ( bits ) = = 3 ) : DCNL DCSP DCSP if ( bits &#91; 2 &#93; = = u &apos;parsed &apos; ) : DCNL DCSP DCSP DCSP parsed = True DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( ( u &quot; Second DCSP ( optional ) DCSP argument DCSP to DCSP % s DCSP tag DCSP must DCSP be DCSP &apos; parsed &apos; &quot; % bits &#91; 0 &#93; ) ) DCNL DCSP filepath = parser.compile _ filter ( bits &#91; 1 &#93; ) DCNL DCSP return SsiNode ( filepath , parsed )
DCSP return os.path.normpath ( os.path.normcase ( os.path.realpath ( path ) ) )
DCSP try : DCNL DCSP DCSP f _ mounts = open ( &apos; / proc / mounts &apos; , &apos; r &apos; ) DCNL DCSP except IOError as e : DCNL DCSP DCSP utils.err ( ( &quot; error : DCSP can &apos;t DCSP open DCSP / proc / mounts : DCSP % s &quot; % e ) ) DCNL DCSP DCSP return 13 DCNL DCSP utils.drop _ privileges ( ) DCNL DCSP while True : DCNL DCSP DCSP devices = &#91; &#93; DCNL DCSP DCSP f _ mounts.seek ( 0 ) DCNL DCSP DCSP ts = int ( time.time ( ) ) DCNL DCSP DCSP for line in f _ mounts : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( fs _ spec , fs _ file , fs _ vfstype , fs _ mntops , fs _ freq , fs _ passno ) = line.split ( None ) DCNL DCSP DCSP DCSP except ValueError as e : DCNL DCSP DCSP DCSP DCSP utils.err ( ( &quot; error : DCSP can &apos;t DCSP parse DCSP line DCSP at DCSP / proc / mounts : DCSP % s &quot; % e ) ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( fs _ spec = = &apos; none &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( ( fs _ vfstype in FSTYPE _ IGNORE ) or fs _ vfstype.startswith ( &apos; fuse . &apos; ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( fs _ file.startswith ( &apos; / dev &apos; ) or fs _ file.startswith ( &apos; / sys &apos; ) or fs _ file.startswith ( &apos; / proc &apos; ) or fs _ file.startswith ( &apos; / lib &apos; ) or fs _ file.startswith ( &apos; net : &apos; ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP device _ found = False DCNL DCSP DCSP DCSP if fs _ spec.startswith ( &apos; / dev &apos; ) : DCNL DCSP DCSP DCSP DCSP for device in devices : DCNL DCSP DCSP DCSP DCSP DCSP if ( fs _ spec = = device &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP device _ found = True DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( len ( fs _ file ) &lt; len ( device &#91; 1 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP device &#91; 1 &#93; = fs _ file DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP if ( not device _ found ) : DCNL DCSP DCSP DCSP DCSP DCSP devices.append ( &#91; fs _ spec , fs _ file , fs _ vfstype &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP devices.append ( &#91; fs _ spec , fs _ file , fs _ vfstype &#93; ) DCNL DCSP DCSP for device in devices : DCNL DCSP DCSP DCSP ( fs _ spec , fs _ file , fs _ vfstype ) = device DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP r = os.statvfs ( fs _ file ) DCNL DCSP DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP DCSP utils.err ( ( &quot; can &apos;t DCSP get DCSP info DCSP for DCSP mount DCSP point : DCSP % s : DCSP % s &quot; % ( fs _ file , e ) ) ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP used = ( r.f _ blocks - r.f _ bfree ) DCNL DCSP DCSP DCSP if ( r.f _ blocks = = 0 ) : DCNL DCSP DCSP DCSP DCSP percent _ used = 100 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP percent _ used = ( ( used * 100.0 ) / r.f _ blocks ) DCNL DCSP DCSP DCSP print ( &apos; df.bytes.total DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , ( r.f _ frsize * r.f _ blocks ) , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.bytes.used DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , ( r.f _ frsize * used ) , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.bytes.percentused DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , percent _ used , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.bytes.free DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , ( r.f _ frsize * r.f _ bfree ) , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP used = ( r.f _ files - r.f _ ffree ) DCNL DCSP DCSP DCSP if ( r.f _ files = = 0 ) : DCNL DCSP DCSP DCSP DCSP percent _ used = 100 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP percent _ used = ( ( used * 100.0 ) / r.f _ files ) DCNL DCSP DCSP DCSP print ( &apos; df.inodes.total DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , r.f _ files , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.inodes.used DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , used , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.inodes.percentused DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , percent _ used , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP DCSP print ( &apos; df.inodes.free DCSP % d DCSP % s DCSP mount = % s DCSP fstype = % s &apos; % ( ts , r.f _ ffree , fs _ file , fs _ vfstype ) ) DCNL DCSP DCSP sys.stdout.flush ( ) DCNL DCSP DCSP time.sleep ( COLLECTION _ INTERVAL )
DCSP try : DCNL DCSP DCSP key = dict _ parameters.pop ( &apos; key &apos; ) DCNL DCSP except KeyError : DCNL DCSP DCSP raise TypeError ( &quot; Missing DCSP &apos; key &apos; DCSP parameter &quot; ) DCNL DCSP expect _ byte _ string ( key ) DCNL DCSP if ( len ( key ) ! = key _ size ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Incorrect DCSP DES DCSP key DCSP length DCSP ( % d DCSP bytes ) &apos; % len ( key ) ) ) DCNL DCSP start _ operation = _ raw _ des _ lib.DES _ start _ operation DCNL DCSP stop _ operation = _ raw _ des _ lib.DES _ stop _ operation DCNL DCSP cipher = VoidPointer ( ) DCNL DCSP result = start _ operation ( key , c _ size _ t ( len ( key ) ) , cipher.address _ of ( ) ) DCNL DCSP if result : DCNL DCSP DCSP raise ValueError ( ( &apos; Error DCSP % X DCSP while DCSP instantiating DCSP the DCSP DES DCSP cipher &apos; % result ) ) DCNL DCSP return SmartPointer ( cipher.get ( ) , stop _ operation )
DCSP if isinstance ( node.op , Subtensor ) : DCNL DCSP DCSP x = node.inputs &#91; 0 &#93; DCNL DCSP DCSP if ( ( not x.owner ) or ( not isinstance ( x.owner.op , IncSubtensor ) ) ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if ( not x.owner.op.set _ instead _ of _ inc ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP if ( ( x.owner.inputs &#91; 2 : &#93; = = node.inputs &#91; 1 : &#93; ) and ( tuple ( x.owner.op.idx _ list ) = = tuple ( node.op.idx _ list ) ) ) : DCNL DCSP DCSP DCSP out = node.outputs &#91; 0 &#93; DCNL DCSP DCSP DCSP y = x.owner.inputs &#91; 1 &#93; DCNL DCSP DCSP DCSP if ( x.dtype ! = y.dtype ) : DCNL DCSP DCSP DCSP DCSP y = y.astype ( x.dtype ) DCNL DCSP DCSP DCSP if ( out.type = = y.type ) : DCNL DCSP DCSP DCSP DCSP return &#91; y &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( out.broadcastable ! = y.broadcastable ) DCNL DCSP DCSP DCSP DCSP x _ subtensor = node.op ( x.owner.inputs &#91; 0 &#93; , * x.owner.inputs &#91; 2 : &#93; ) DCNL DCSP DCSP DCSP DCSP return &#91; T.alloc ( y , * x _ subtensor.shape ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return
DCSP from jmxfetch import JMX _ CHECKS DCNL DCSP agentConfig &#91; &apos; checksd _ hostname &apos; &#93; = hostname DCNL DCSP osname = get _ os ( ) DCNL DCSP checks _ places = get _ checks _ places ( osname , agentConfig ) DCNL DCSP for config _ path in _ file _ configs _ paths ( osname , agentConfig ) : DCNL DCSP DCSP check _ name = _ conf _ path _ to _ check _ name ( config _ path ) DCNL DCSP DCSP if ( ( check _ name = = checkname ) and ( check _ name not in JMX _ CHECKS ) ) : DCNL DCSP DCSP DCSP ( conf _ is _ valid , check _ config , invalid _ check ) = _ load _ file _ config ( config _ path , check _ name , agentConfig ) DCNL DCSP DCSP DCSP if ( invalid _ check and ( not conf _ is _ valid ) ) : DCNL DCSP DCSP DCSP DCSP return invalid _ check DCNL DCSP DCSP DCSP ( load _ success , load _ failure ) = load _ check _ from _ places ( check _ config , check _ name , checks _ places , agentConfig ) DCNL DCSP DCSP DCSP return ( load _ success.values ( ) &#91; 0 &#93; or load _ failure ) DCNL DCSP for ( check _ name , service _ disco _ check _ config ) in _ service _ disco _ configs ( agentConfig ) .iteritems ( ) : DCNL DCSP DCSP if ( check _ name = = checkname ) : DCNL DCSP DCSP DCSP ( sd _ init _ config , sd _ instances ) = service _ disco _ check _ config &#91; 1 &#93; DCNL DCSP DCSP DCSP check _ config = { &apos; init _ config &apos; : sd _ init _ config , &apos; instances &apos; : sd _ instances } DCNL DCSP DCSP DCSP ( load _ success , load _ failure ) = load _ check _ from _ places ( check _ config , check _ name , checks _ places , agentConfig ) DCNL DCSP DCSP DCSP return ( load _ success.values ( ) &#91; 0 &#93; or load _ failure ) DCNL DCSP return None
DCSP if isinstance ( import _ name , unicode ) : DCNL DCSP DCSP import _ name = str ( import _ name ) DCNL DCSP try : DCNL DCSP DCSP if ( &apos; : &apos; in import _ name ) : DCNL DCSP DCSP DCSP ( module , obj ) = import _ name.split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP elif ( &apos; .&apos; in import _ name ) : DCNL DCSP DCSP DCSP ( module , obj ) = import _ name.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return _ _ import _ _ ( import _ name ) DCNL DCSP DCSP if isinstance ( obj , unicode ) : DCNL DCSP DCSP DCSP obj = obj.encode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return getattr ( _ _ import _ _ ( module , None , None , &#91; obj &#93; ) , obj ) DCNL DCSP DCSP except ( ImportError , AttributeError ) : DCNL DCSP DCSP DCSP modname = ( ( module + &apos; .&apos; ) + obj ) DCNL DCSP DCSP DCSP _ _ import _ _ ( modname ) DCNL DCSP DCSP DCSP return sys.modules &#91; modname &#93; DCNL DCSP except ImportError as e : DCNL DCSP DCSP if ( not silent ) : DCNL DCSP DCSP DCSP raise ImportStringError ( import _ name , e ) , None , sys.exc _ info ( ) &#91; 2 &#93;
DCSP from frappe.desk.notifications import get _ notification _ info _ for _ boot , get _ notifications DCNL DCSP from frappe.boot import get _ bootinfo , get _ unseen _ notes DCNL DCSP from frappe.limits import get _ limits , get _ expiry _ message DCNL DCSP bootinfo = None DCNL DCSP if ( not getattr ( frappe.conf , u &apos;disable _ session _ cache &apos; , None ) ) : DCNL DCSP DCSP bootinfo = frappe.cache ( ) .hget ( u &apos;bootinfo &apos; , frappe.session.user ) DCNL DCSP DCSP if bootinfo : DCNL DCSP DCSP DCSP bootinfo &#91; u &apos;from _ cache &apos; &#93; = 1 DCNL DCSP DCSP DCSP bootinfo &#91; u &apos;notification _ info &apos; &#93; .update ( get _ notifications ( ) ) DCNL DCSP DCSP DCSP bootinfo &#91; u &apos;user &apos; &#93; &#91; u &apos;recent &apos; &#93; = json.dumps ( frappe.cache ( ) .hget ( u &apos;user _ recent &apos; , frappe.session.user ) ) DCNL DCSP if ( not bootinfo ) : DCNL DCSP DCSP bootinfo = get _ bootinfo ( ) DCNL DCSP DCSP bootinfo &#91; u &apos;notification _ info &apos; &#93; = get _ notification _ info _ for _ boot ( ) DCNL DCSP DCSP frappe.cache ( ) .hset ( u &apos;bootinfo &apos; , frappe.session.user , bootinfo ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP frappe.cache ( ) .ping ( ) DCNL DCSP DCSP except redis.exceptions.ConnectionError : DCNL DCSP DCSP DCSP message = _ ( u &apos;Redis DCSP cache DCSP server DCSP not DCSP running . DCSP Please DCSP contact DCSP Administrator DCSP / DCSP Tech DCSP support &apos; ) DCNL DCSP DCSP DCSP if ( u &apos;messages &apos; in bootinfo ) : DCNL DCSP DCSP DCSP DCSP bootinfo &#91; u &apos;messages &apos; &#93; .append ( message ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP bootinfo &#91; u &apos;messages &apos; &#93; = &#91; message &#93; DCNL DCSP DCSP if frappe.local.request : DCNL DCSP DCSP DCSP bootinfo &#91; u &apos;change _ log &apos; &#93; = get _ change _ log ( ) DCNL DCSP bootinfo &#91; u &apos;metadata _ version &apos; &#93; = frappe.cache ( ) .get _ value ( u &apos;metadata _ version &apos; ) DCNL DCSP if ( not bootinfo &#91; u &apos;metadata _ version &apos; &#93; ) : DCNL DCSP DCSP bootinfo &#91; u &apos;metadata _ version &apos; &#93; = frappe.reset _ metadata _ version ( ) DCNL DCSP bootinfo.notes = get _ unseen _ notes ( ) DCNL DCSP for hook in frappe.get _ hooks ( u &apos;extend _ bootinfo &apos; ) : DCNL DCSP DCSP frappe.get _ attr ( hook ) ( bootinfo = bootinfo ) DCNL DCSP bootinfo &#91; u &apos;lang &apos; &#93; = frappe.translate.get _ user _ lang ( ) DCNL DCSP bootinfo &#91; u &apos;disable _ async &apos; &#93; = frappe.conf.disable _ async DCNL DCSP bootinfo.limits = get _ limits ( ) DCNL DCSP bootinfo.expiry _ message = get _ expiry _ message ( ) DCNL DCSP return bootinfo
DCSP return cmp ( _ spat.sub ( &apos; &apos; , x ) , _ spat.sub ( &apos; &apos; , y ) )
DCSP try : DCNL DCSP DCSP return len ( value ) DCNL DCSP except ( ValueError , TypeError ) : DCNL DCSP DCSP return u &apos; &apos;
DCSP ev = _ state.event _ loop DCNL DCSP if ( ( not os.getenv ( _ EVENT _ LOOP _ KEY ) ) and ( ev is not None ) ) : DCNL DCSP DCSP ev.clear ( ) DCNL DCSP DCSP _ state.event _ loop = None DCNL DCSP DCSP ev = None DCNL DCSP if ( ev is None ) : DCNL DCSP DCSP ev = EventLoop ( ) DCNL DCSP DCSP _ state.event _ loop = ev DCNL DCSP DCSP os.environ &#91; _ EVENT _ LOOP _ KEY &#93; = &apos; 1&apos; DCNL DCSP return ev
DCSP if SPECIAL.match ( name ) : DCNL DCSP DCSP visibility = &apos; special &apos; DCNL DCSP elif PRIVATE.match ( name ) : DCNL DCSP DCSP visibility = &apos; private &apos; DCNL DCSP elif PROTECTED.match ( name ) : DCNL DCSP DCSP visibility = &apos; protected &apos; DCNL DCSP else : DCNL DCSP DCSP visibility = &apos; public &apos; DCNL DCSP return visibility
DCSP elements = string.split ( None , 2 ) DCNL DCSP if ( len ( elements ) ! = 3 ) : DCNL DCSP DCSP raise InvalidEntry ( ) DCNL DCSP ( hostnames , keyType , keyAndComment ) = elements DCNL DCSP splitkey = keyAndComment.split ( None , 1 ) DCNL DCSP if ( len ( splitkey ) = = 2 ) : DCNL DCSP DCSP ( keyString , comment ) = splitkey DCNL DCSP DCSP comment = comment.rstrip ( &apos; \ n &apos; ) DCNL DCSP else : DCNL DCSP DCSP keyString = splitkey &#91; 0 &#93; DCNL DCSP DCSP comment = None DCNL DCSP key = Key.fromString ( keyString.decode ( &apos; base64 &apos; ) ) DCNL DCSP return ( hostnames , keyType , key , comment )
DCSP rngs = &#91; make _ np _ rng ( rng _ or _ seed = 42 , which _ method = &apos; uniform &apos; ) , make _ np _ rng ( rng _ or _ seed = numpy.random.RandomState ( 42 ) , which _ method = &apos; uniform &apos; ) , make _ np _ rng ( default _ seed = 42 ) , make _ np _ rng ( ) &#93; DCNL DCSP random _ numbers = rngs &#91; 0 &#93; .uniform ( size = ( 100 , ) ) DCNL DCSP equals = numpy.ones ( ( 100 , ) ) DCNL DCSP for rng in rngs &#91; 1 : &#93; : DCNL DCSP DCSP equal = ( random _ numbers = = rng.uniform ( size = ( 100 , ) ) ) DCNL DCSP DCSP equals * = equal DCNL DCSP assert equals.all ( )
DCSP sequence = sequence.upper ( ) DCNL DCSP amino _ acids = &#91; &#93; DCNL DCSP forward _ table = table.forward _ table DCNL DCSP stop _ codons = table.stop _ codons DCNL DCSP if ( table.nucleotide _ alphabet.letters is not None ) : DCNL DCSP DCSP valid _ letters = set ( table.nucleotide _ alphabet.letters.upper ( ) ) DCNL DCSP else : DCNL DCSP DCSP valid _ letters = set ( ( IUPAC.ambiguous _ dna.letters.upper ( ) + IUPAC.ambiguous _ rna.letters.upper ( ) ) ) DCNL DCSP n = len ( sequence ) DCNL DCSP if cds : DCNL DCSP DCSP if ( str ( sequence &#91; : 3 &#93; ) .upper ( ) not in table.start _ codons ) : DCNL DCSP DCSP DCSP raise CodonTable.TranslationError ( &quot; First DCSP codon DCSP &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP start DCSP codon &quot; .format ( sequence &#91; : 3 &#93; ) ) DCNL DCSP DCSP if ( ( n % 3 ) ! = 0 ) : DCNL DCSP DCSP DCSP raise CodonTable.TranslationError ( &apos; Sequence DCSP length DCSP { 0 } DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP three &apos; .format ( n ) ) DCNL DCSP DCSP if ( str ( sequence &#91; ( -3 ) : &#93; ) .upper ( ) not in stop _ codons ) : DCNL DCSP DCSP DCSP raise CodonTable.TranslationError ( &quot; Final DCSP codon DCSP &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP stop DCSP codon &quot; .format ( sequence &#91; ( -3 ) : &#93; ) ) DCNL DCSP DCSP sequence = sequence &#91; 3 : ( -3 ) &#93; DCNL DCSP DCSP n - = 6 DCNL DCSP DCSP amino _ acids = &#91; &apos; M &apos; &#93; DCNL DCSP elif ( ( n % 3 ) ! = 0 ) : DCNL DCSP DCSP warnings.warn ( &apos; Partial DCSP codon , DCSP len ( sequence ) DCSP not DCSP a DCSP multiple DCSP of DCSP three . DCSP Explicitly DCSP trim DCSP the DCSP sequence DCSP or DCSP add DCSP trailing DCSP N DCSP before DCSP translation . DCSP This DCSP may DCSP become DCSP an DCSP error DCSP in DCSP future . &apos; , BiopythonWarning ) DCNL DCSP if ( gap is not None ) : DCNL DCSP DCSP if ( not isinstance ( gap , basestring ) ) : DCNL DCSP DCSP DCSP raise TypeError ( &apos; Gap DCSP character DCSP should DCSP be DCSP a DCSP single DCSP character DCSP string . &apos; ) DCNL DCSP DCSP elif ( len ( gap ) &gt; 1 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Gap DCSP character DCSP should DCSP be DCSP a DCSP single DCSP character DCSP string . &apos; ) DCNL DCSP for i in range ( 0 , ( n - ( n % 3 ) ) , 3 ) : DCNL DCSP DCSP codon = sequence &#91; i : ( i + 3 ) &#93; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP amino _ acids.append ( forward _ table &#91; codon &#93; ) DCNL DCSP DCSP except ( KeyError , CodonTable.TranslationError ) : DCNL DCSP DCSP DCSP if ( codon in table.stop _ codons ) : DCNL DCSP DCSP DCSP DCSP if cds : DCNL DCSP DCSP DCSP DCSP DCSP raise CodonTable.TranslationError ( &apos; Extra DCSP in DCSP frame DCSP stop DCSP codon DCSP found . &apos; ) DCNL DCSP DCSP DCSP DCSP if to _ stop : DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP amino _ acids.append ( stop _ symbol ) DCNL DCSP DCSP DCSP elif valid _ letters.issuperset ( set ( codon ) ) : DCNL DCSP DCSP DCSP DCSP amino _ acids.append ( pos _ stop ) DCNL DCSP DCSP DCSP elif ( ( gap is not None ) and ( codon = = ( gap * 3 ) ) ) : DCNL DCSP DCSP DCSP DCSP amino _ acids.append ( gap ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise CodonTable.TranslationError ( &quot; Codon DCSP &apos; { 0 } &apos; DCSP is DCSP invalid &quot; .format ( codon ) ) DCNL DCSP return &apos; &apos;.join ( amino _ acids )
DCSP def track _ time _ change _ decorator ( action ) : DCNL DCSP DCSP &apos; Decorator DCSP to DCSP track DCSP time DCSP changes . &apos; DCNL DCSP DCSP event.track _ time _ change ( HASS , functools.partial ( action , HASS ) , year , month , day , hour , minute , second ) DCNL DCSP DCSP return action DCNL DCSP return track _ time _ change _ decorator
DCSP return lz4f.compressFrame ( payload )
DCSP aliases = { u &apos;lw &apos; : u &apos;linewidth &apos; , u &apos;ls &apos; : u &apos;linestyle &apos; , u &apos;c &apos; : u &apos;color &apos; , u &apos;fc &apos; : u &apos;facecolor &apos; , u &apos;ec &apos; : u &apos;edgecolor &apos; , u &apos;mew &apos; : u &apos;markeredgewidth &apos; , u &apos;aa &apos; : u &apos;antialiased &apos; } DCNL DCSP if is _ string _ like ( group ) : DCNL DCSP DCSP group = ( group , ) DCNL DCSP for g in group : DCNL DCSP DCSP for ( k , v ) in six.iteritems ( kwargs ) : DCNL DCSP DCSP DCSP name = ( aliases.get ( k ) or k ) DCNL DCSP DCSP DCSP key = ( u &apos; % s . % s &apos; % ( g , name ) ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP rcParams &#91; key &#93; = v DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP raise KeyError ( ( u &apos;Unrecognized DCSP key DCSP &quot; % s &quot; DCSP for DCSP group DCSP &quot; % s &quot; DCSP and DCSP name DCSP &quot; % s &quot; &apos; % ( key , g , name ) ) )
DCSP def na _ op ( x , y ) : DCNL DCSP DCSP if is _ categorical _ dtype ( x ) : DCNL DCSP DCSP DCSP return op ( x , y ) DCNL DCSP DCSP elif ( is _ categorical _ dtype ( y ) and ( not isscalar ( y ) ) ) : DCNL DCSP DCSP DCSP return op ( y , x ) DCNL DCSP DCSP if is _ object _ dtype ( x.dtype ) : DCNL DCSP DCSP DCSP result = _ comp _ method _ OBJECT _ ARRAY ( op , x , y ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if is _ datetimelike _ v _ numeric ( x , y ) : DCNL DCSP DCSP DCSP DCSP raise TypeError ( &apos; invalid DCSP type DCSP comparison &apos; ) DCNL DCSP DCSP DCSP if ( isscalar ( y ) and isnull ( y ) ) : DCNL DCSP DCSP DCSP DCSP if ( name = = &apos; _ _ ne _ _ &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP return np.ones ( len ( x ) , dtype = bool ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return np.zeros ( len ( x ) , dtype = bool ) DCNL DCSP DCSP DCSP mask = None DCNL DCSP DCSP DCSP if ( needs _ i8 _ conversion ( x ) or ( ( not isscalar ( y ) ) and needs _ i8 _ conversion ( y ) ) ) : DCNL DCSP DCSP DCSP DCSP if isscalar ( y ) : DCNL DCSP DCSP DCSP DCSP DCSP mask = isnull ( x ) DCNL DCSP DCSP DCSP DCSP DCSP y = _ index.convert _ scalar ( x , _ values _ from _ object ( y ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP mask = ( isnull ( x ) &#124; isnull ( y ) ) DCNL DCSP DCSP DCSP DCSP DCSP y = y.view ( &apos; i8 &apos; ) DCNL DCSP DCSP DCSP DCSP x = x.view ( &apos; i8 &apos; ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP with np.errstate ( all = &apos; ignore &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP result = getattr ( x , name ) ( y ) DCNL DCSP DCSP DCSP DCSP if ( result is NotImplemented ) : DCNL DCSP DCSP DCSP DCSP DCSP raise TypeError ( &apos; invalid DCSP type DCSP comparison &apos; ) DCNL DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP result = op ( x , y ) DCNL DCSP DCSP DCSP if ( ( mask is not None ) and mask.any ( ) ) : DCNL DCSP DCSP DCSP DCSP result &#91; mask &#93; = masker DCNL DCSP DCSP return result DCNL DCSP def wrapper ( self , other , axis = None ) : DCNL DCSP DCSP if ( axis is not None ) : DCNL DCSP DCSP DCSP self . _ get _ axis _ number ( axis ) DCNL DCSP DCSP if isinstance ( other , ABCSeries ) : DCNL DCSP DCSP DCSP name = _ maybe _ match _ name ( self , other ) DCNL DCSP DCSP DCSP if ( not self . _ indexed _ same ( other ) ) : DCNL DCSP DCSP DCSP DCSP msg = &apos; Can DCSP only DCSP compare DCSP identically-labeled DCSP Series DCSP objects &apos; DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg ) DCNL DCSP DCSP DCSP return self . _ constructor ( na _ op ( self.values , other.values ) , index = self.index , name = name ) DCNL DCSP DCSP elif isinstance ( other , pd.DataFrame ) : DCNL DCSP DCSP DCSP return NotImplemented DCNL DCSP DCSP elif isinstance ( other , ( np.ndarray , pd.Index ) ) : DCNL DCSP DCSP DCSP if ( ( not lib.isscalar ( lib.item _ from _ zerodim ( other ) ) ) and ( len ( self ) ! = len ( other ) ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Lengths DCSP must DCSP match DCSP to DCSP compare &apos; ) DCNL DCSP DCSP DCSP if isinstance ( other , ABCPeriodIndex ) : DCNL DCSP DCSP DCSP DCSP return self . _ constructor ( na _ op ( self.values , other.asobject.values ) , index = self.index ) DCNL DCSP DCSP DCSP return self . _ constructor ( na _ op ( self.values , np.asarray ( other ) ) , index = self.index ) . _ _ finalize _ _ ( self ) DCNL DCSP DCSP elif isinstance ( other , pd.Categorical ) : DCNL DCSP DCSP DCSP if ( not is _ categorical _ dtype ( self ) ) : DCNL DCSP DCSP DCSP DCSP msg = &quot; Cannot DCSP compare DCSP a DCSP Categorical DCSP for DCSP op DCSP { op } DCSP with DCSP Series DCSP of DCSP dtype DCSP { typ } . \ nIf DCSP you DCSP want DCSP to DCSP compare DCSP values , DCSP use DCSP &apos; series DCSP &lt; op &gt; DCSP np.asarray ( other ) &apos; . &quot; DCNL DCSP DCSP DCSP DCSP raise TypeError ( msg.format ( op = op , typ = self.dtype ) ) DCNL DCSP DCSP if is _ categorical _ dtype ( self ) : DCNL DCSP DCSP DCSP with np.errstate ( all = &apos; ignore &apos; ) : DCNL DCSP DCSP DCSP DCSP res = op ( self.values , other ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP values = self.get _ values ( ) DCNL DCSP DCSP DCSP if isinstance ( other , ( list , np.ndarray ) ) : DCNL DCSP DCSP DCSP DCSP other = np.asarray ( other ) DCNL DCSP DCSP DCSP with np.errstate ( all = &apos; ignore &apos; ) : DCNL DCSP DCSP DCSP DCSP res = na _ op ( values , other ) DCNL DCSP DCSP DCSP if isscalar ( res ) : DCNL DCSP DCSP DCSP DCSP raise TypeError ( ( &apos; Could DCSP not DCSP compare DCSP % s DCSP type DCSP with DCSP Series &apos; % type ( other ) ) ) DCNL DCSP DCSP DCSP res = _ values _ from _ object ( res ) DCNL DCSP DCSP res = pd.Series ( res , index = self.index , name = self.name , dtype = &apos; bool &apos; ) DCNL DCSP DCSP return res DCNL DCSP return wrapper
DCSP return serve ( request , &apos; contribute.json &apos; , document _ root = settings.ROOT )
DCSP blueprints _ path = app.config.get ( &apos; BLUEPRINTS _ PATH &apos; , &apos; modules &apos; ) DCNL DCSP path = os.path.join ( app.config.get ( &apos; PROJECT _ ROOT &apos; , &apos; .. &apos; ) , blueprints _ path ) DCNL DCSP base _ module _ name = &apos; .&apos;.join ( &#91; app.name , blueprints _ path &#93; ) DCNL DCSP dir _ list = os.listdir ( path ) DCNL DCSP mods = { } DCNL DCSP object _ name = app.config.get ( &apos; BLUEPRINTS _ OBJECT _ NAME &apos; , &apos; module &apos; ) DCNL DCSP module _ file = app.config.get ( &apos; BLUEPRINTS _ MODULE _ NAME &apos; , &apos; main &apos; ) DCNL DCSP blueprint _ module = ( module _ file + &apos; .py &apos; ) DCNL DCSP for fname in dir _ list : DCNL DCSP DCSP if ( ( not os.path.exists ( os.path.join ( path , fname , &apos; DISABLED &apos; ) ) ) and os.path.isdir ( os.path.join ( path , fname ) ) and os.path.exists ( os.path.join ( path , fname , blueprint _ module ) ) ) : DCNL DCSP DCSP DCSP module _ root = &apos; .&apos;.join ( &#91; base _ module _ name , fname &#93; ) DCNL DCSP DCSP DCSP module _ name = &apos; .&apos;.join ( &#91; module _ root , module _ file &#93; ) DCNL DCSP DCSP DCSP mods &#91; fname &#93; = importlib.import _ module ( module _ name ) DCNL DCSP DCSP DCSP blueprint = getattr ( mods &#91; fname &#93; , object _ name ) DCNL DCSP DCSP DCSP app.logger.info ( ( &apos; registering DCSP blueprint : DCSP % s &apos; % blueprint.name ) ) DCNL DCSP DCSP DCSP app.register _ blueprint ( blueprint ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP importlib.import _ module ( &apos; .&apos;.join ( &#91; module _ root , &apos; admin &apos; &#93; ) ) DCNL DCSP DCSP DCSP except ImportError as e : DCNL DCSP DCSP DCSP DCSP app.logger.info ( &apos; % s DCSP module DCSP does DCSP not DCSP define DCSP admin DCSP or DCSP error : DCSP % s &apos; , fname , e ) DCNL DCSP app.logger.info ( &apos; % s DCSP modules DCSP loaded &apos; , mods.keys ( ) )
DCSP ( msg , key , A ) = _ prep ( msg , key , symbols , bifid10 ) DCNL DCSP long _ key = ( &apos; &apos;.join ( uniq ( key ) ) or A ) DCNL DCSP n = ( len ( A ) * * 0.5 ) DCNL DCSP if ( n ! = int ( n ) ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Length DCSP of DCSP alphabet DCSP ( % s ) DCSP is DCSP not DCSP a DCSP square DCSP number . &apos; % len ( A ) ) ) DCNL DCSP N = int ( n ) DCNL DCSP if ( len ( long _ key ) &lt; ( N * * 2 ) ) : DCNL DCSP DCSP long _ key = ( list ( long _ key ) + &#91; x for x in A if ( x not in long _ key ) &#93; ) DCNL DCSP row _ col = dict ( &#91; ( ch , divmod ( i , N ) ) for ( i , ch ) in enumerate ( long _ key ) &#93; ) DCNL DCSP ( r , c ) = zip ( * &#91; row _ col &#91; x &#93; for x in msg &#93; ) DCNL DCSP rc = ( r + c ) DCNL DCSP ch = { i : ch for ( ch , i ) in row _ col.items ( ) } DCNL DCSP rv = &apos; &apos;.join ( ( ch &#91; i &#93; for i in zip ( rc &#91; : : 2 &#93; , rc &#91; 1 : : 2 &#93; ) ) ) DCNL DCSP return rv
DCSP from mayavi.core.ui.mayavi _ scene import MayaviScene DCNL DCSP from tvtk.pyface.tvtk _ scene import TVTKScene DCNL DCSP if ( not isinstance ( scene , ( MayaviScene , TVTKScene ) ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; scene DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP TVTKScene / MayaviScene , DCSP found DCSP type DCSP % s &apos; % type ( scene ) ) ) DCNL DCSP ( x , y ) = tuple ( scene.get _ size ( ) ) DCNL DCSP view _ to _ disp _ mat = np.array ( &#91; &#91; ( x / 2.0 ) , 0.0 , 0.0 , ( x / 2.0 ) &#93; , &#91; 0.0 , ( ( - y ) / 2.0 ) , 0.0 , ( y / 2.0 ) &#93; , &#91; 0.0 , 0.0 , 1.0 , 0.0 &#93; , &#91; 0.0 , 0.0 , 0.0 , 1.0 &#93; &#93; ) DCNL DCSP return view _ to _ disp _ mat
DCSP msg ( colorize ( ( &apos; % s : DCSP % s &apos; % ( prefix , str ( text ) ) ) , &apos; cyan &apos; ) )
DCSP call _ command ( &apos; list _ projects &apos; , &apos; --modified-since = 5 &apos; ) DCNL DCSP ( out , err ) = capfd.readouterr ( ) DCNL DCSP assert ( &apos; project0 &apos; in out ) DCNL DCSP assert ( &apos; project1 &apos; in out )
DCSP def check _ python _ file ( path ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return parser _ cache &#91; path &#93; .parser.module DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP return check _ fs ( path ) DCNL DCSP DCSP DCSP except IOError : DCNL DCSP DCSP DCSP DCSP return None DCNL DCSP def check _ fs ( path ) : DCNL DCSP DCSP with open ( path , &apos; rb &apos; ) as f : DCNL DCSP DCSP DCSP source = source _ to _ unicode ( f.read ( ) ) DCNL DCSP DCSP DCSP if ( name in source ) : DCNL DCSP DCSP DCSP DCSP module _ name = os.path.basename ( path ) &#91; : ( -3 ) &#93; DCNL DCSP DCSP DCSP DCSP module = _ load _ module ( evaluator , path , source ) DCNL DCSP DCSP DCSP DCSP add _ module ( evaluator , module _ name , module ) DCNL DCSP DCSP DCSP DCSP return module DCNL DCSP mods = set ( ( m for m in mods if ( not isinstance ( m , compiled.CompiledObject ) ) ) ) DCNL DCSP mod _ paths = set ( ) DCNL DCSP for m in mods : DCNL DCSP DCSP mod _ paths.add ( m.path ) DCNL DCSP DCSP ( yield m ) DCNL DCSP if settings.dynamic _ params _ for _ other _ modules : DCNL DCSP DCSP paths = set ( settings.additional _ dynamic _ modules ) DCNL DCSP DCSP for p in mod _ paths : DCNL DCSP DCSP DCSP if ( p is not None ) : DCNL DCSP DCSP DCSP DCSP d = os.path.dirname ( os.path.abspath ( p ) ) DCNL DCSP DCSP DCSP DCSP for entry in os.listdir ( d ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( entry not in mod _ paths ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if entry.endswith ( &apos; .py &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP paths.add ( ( ( d + os.path.sep ) + entry ) ) DCNL DCSP DCSP for p in sorted ( paths ) : DCNL DCSP DCSP DCSP c = check _ python _ file ( p ) DCNL DCSP DCSP DCSP if ( ( c is not None ) and ( c not in mods ) and ( not isinstance ( c , compiled.CompiledObject ) ) ) : DCNL DCSP DCSP DCSP DCSP ( yield c )
DCSP disk _ dev = find _ disk _ dev _ for _ disk _ bus ( mapping , disk _ bus , assigned _ devices ) DCNL DCSP info = { &apos; bus &apos; : disk _ bus , &apos; dev &apos; : disk _ dev , &apos; type &apos; : device _ type } DCNL DCSP if ( ( boot _ index is not None ) and ( boot _ index &gt; = 0 ) ) : DCNL DCSP DCSP info &#91; &apos; boot _ index &apos; &#93; = str ( boot _ index ) DCNL DCSP return info
DCSP res = &#91; &#93; DCNL DCSP for a in arys : DCNL DCSP DCSP if ( not isinstance ( a , cupy.ndarray ) ) : DCNL DCSP DCSP DCSP raise TypeError ( &apos; Only DCSP cupy DCSP arrays DCSP can DCSP be DCSP atleast _ 2d &apos; ) DCNL DCSP DCSP if ( a.ndim = = 0 ) : DCNL DCSP DCSP DCSP a = a.reshape ( 1 , 1 ) DCNL DCSP DCSP elif ( a.ndim = = 1 ) : DCNL DCSP DCSP DCSP a = a &#91; None , : &#93; DCNL DCSP DCSP res.append ( a ) DCNL DCSP if ( len ( res ) = = 1 ) : DCNL DCSP DCSP res = res &#91; 0 &#93; DCNL DCSP return res
DCSP ( year , month ) = tm &#91; : 2 &#93; DCNL DCSP day = _ DAYS &#91; month &#93; DCNL DCSP if ( ( day = = 28 ) and ( ( year % 4 ) = = 0 ) ) : DCNL DCSP DCSP day = 29 DCNL DCSP return day
DCSP def callback ( lexer , match , context ) : DCNL DCSP DCSP text = match.group ( ) DCNL DCSP DCSP context.block _ scalar _ indent = None DCNL DCSP DCSP if ( not text ) : DCNL DCSP DCSP DCSP return DCNL DCSP DCSP increment = match.group ( 1 ) DCNL DCSP DCSP if increment : DCNL DCSP DCSP DCSP current _ indent = max ( context.indent , 0 ) DCNL DCSP DCSP DCSP increment = int ( increment ) DCNL DCSP DCSP DCSP context.block _ scalar _ indent = ( current _ indent + increment ) DCNL DCSP DCSP if text : DCNL DCSP DCSP DCSP ( yield ( match.start ( ) , TokenClass , text ) ) DCNL DCSP DCSP DCSP context.pos = match.end ( ) DCNL DCSP return callback
DCSP return model _ query ( context , models.VolumeUsage , read _ deleted = &apos; yes &apos; ) .filter ( or _ ( ( models.VolumeUsage.tot _ last _ refreshed = = None ) , ( models.VolumeUsage.tot _ last _ refreshed &gt; begin ) , ( models.VolumeUsage.curr _ last _ refreshed = = None ) , ( models.VolumeUsage.curr _ last _ refreshed &gt; begin ) ) ) .all ( )
DCSP return keystoneclient ( request , admin = True ) .roles.list ( )
DCSP reg _ cache = { } DCNL DCSP if cached : DCNL DCSP DCSP reg _ cache = cache.registry _ cache ( ) DCNL DCSP discovery = QtWidgetDiscovery ( cached _ descriptions = reg _ cache ) DCNL DCSP registry = QtWidgetRegistry ( ) DCNL DCSP discovery.found _ category.connect ( registry.register _ category ) DCNL DCSP discovery.found _ widget.connect ( registry.register _ widget ) DCNL DCSP discovery.run ( ) DCNL DCSP if cached : DCNL DCSP DCSP cache.save _ registry _ cache ( reg _ cache ) DCNL DCSP return registry
DCSP if func . _ _ closure _ _ : DCNL DCSP DCSP cells = &#91; cell.cell _ contents for cell in func . _ _ closure _ _ &#93; DCNL DCSP else : DCNL DCSP DCSP cells = None DCNL DCSP return ( _ reduce _ code ( func . _ _ code _ _ ) , globs , func . _ _ name _ _ , cells )
DCSP return s.replace ( old , new , maxsplit )
DCSP options = RunOptions ( top _ level = top _ level ) DCNL DCSP configure _ eliot _ logging _ for _ acceptance ( ) DCNL DCSP try : DCNL DCSP DCSP options.parseOptions ( args ) DCNL DCSP except UsageError as e : DCNL DCSP DCSP sys.stderr.write ( ( &apos; % s : DCSP % s \ n &apos; % ( base _ path.basename ( ) , e ) ) ) DCNL DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP runner = options.runner DCNL DCSP def cluster _ cleanup ( ) : DCNL DCSP DCSP print &apos; stopping DCSP cluster &apos; DCNL DCSP DCSP return runner.stop _ cluster ( reactor ) DCNL DCSP cleanup _ trigger _ id = reactor.addSystemEventTrigger ( &apos; before &apos; , &apos; shutdown &apos; , cluster _ cleanup ) DCNL DCSP from flocker.common.script import eliot _ logging _ service DCNL DCSP log _ writer = eliot _ logging _ service ( destination = FileDestination ( file = open ( ( &apos; % s.log &apos; % ( base _ path.basename ( ) , ) ) , &apos; a &apos; ) ) , reactor = reactor , capture _ stdout = False ) DCNL DCSP log _ writer.startService ( ) DCNL DCSP reactor.addSystemEventTrigger ( &apos; before &apos; , &apos; shutdown &apos; , log _ writer.stopService ) DCNL DCSP ( yield runner.ensure _ keys ( reactor ) ) DCNL DCSP cluster = ( yield runner.start _ cluster ( reactor ) ) DCNL DCSP save _ managed _ config ( options &#91; &apos; cert-directory &apos; &#93; , options &#91; &apos; config &apos; &#93; , cluster ) DCNL DCSP managed _ config _ file = options &#91; &apos; cert-directory &apos; &#93; .child ( &apos; managed.yaml &apos; ) DCNL DCSP managed _ config = create _ managed _ config ( options &#91; &apos; config &apos; &#93; , cluster ) DCNL DCSP managed _ config _ file.setContent ( yaml.safe _ dump ( managed _ config , default _ flow _ style = False ) ) DCNL DCSP if ( options &#91; &apos; distribution &apos; &#93; in ( &apos; centos-7 &apos; , ) ) : DCNL DCSP DCSP remote _ logs _ file = open ( &apos; remote _ logs.log &apos; , &apos; a &apos; ) DCNL DCSP DCSP for node in cluster.all _ nodes : DCNL DCSP DCSP DCSP capture _ journal ( reactor , node.address , remote _ logs _ file ) .addErrback ( write _ failure ) DCNL DCSP elif ( options &#91; &apos; distribution &apos; &#93; in ( &apos; ubuntu-14.04 &apos; , ) ) : DCNL DCSP DCSP remote _ logs _ file = open ( &apos; remote _ logs.log &apos; , &apos; a &apos; ) DCNL DCSP DCSP for node in cluster.all _ nodes : DCNL DCSP DCSP DCSP capture _ upstart ( reactor , node.address , remote _ logs _ file ) .addErrback ( write _ failure ) DCNL DCSP flocker _ client = make _ client ( reactor , cluster ) DCNL DCSP ( yield wait _ for _ nodes ( reactor , flocker _ client , len ( cluster.agent _ nodes ) ) ) DCNL DCSP if options &#91; &apos; no-keep &apos; &#93; : DCNL DCSP DCSP print &apos; not DCSP keeping DCSP cluster &apos; DCNL DCSP else : DCNL DCSP DCSP save _ environment ( options &#91; &apos; cert-directory &apos; &#93; , cluster , options.package _ source ( ) ) DCNL DCSP DCSP reactor.removeSystemEventTrigger ( cleanup _ trigger _ id )
DCSP x = asarray ( x ) DCNL DCSP if iscomplexobj ( x ) : DCNL DCSP DCSP raise ValueError ( &apos; x DCSP must DCSP be DCSP real . &apos; ) DCNL DCSP if ( N is None ) : DCNL DCSP DCSP N = x.shape &#91; axis &#93; DCNL DCSP if ( N &lt; = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; N DCSP must DCSP be DCSP positive . &apos; ) DCNL DCSP Xf = fftpack.fft ( x , N , axis = axis ) DCNL DCSP h = zeros ( N ) DCNL DCSP if ( ( N % 2 ) = = 0 ) : DCNL DCSP DCSP h &#91; 0 &#93; = h &#91; ( N / / 2 ) &#93; = 1 DCNL DCSP DCSP h &#91; 1 : ( N / / 2 ) &#93; = 2 DCNL DCSP else : DCNL DCSP DCSP h &#91; 0 &#93; = 1 DCNL DCSP DCSP h &#91; 1 : ( ( N + 1 ) / / 2 ) &#93; = 2 DCNL DCSP if ( x.ndim &gt; 1 ) : DCNL DCSP DCSP ind = ( &#91; newaxis &#93; * x.ndim ) DCNL DCSP DCSP ind &#91; axis &#93; = slice ( None ) DCNL DCSP DCSP h = h &#91; ind &#93; DCNL DCSP x = fftpack.ifft ( ( Xf * h ) , axis = axis ) DCNL DCSP return x
DCSP x = _ cStringIO ( ) DCNL DCSP x.write ( val ) DCNL DCSP x.seek ( sek ) DCNL DCSP return x
DCSP import tornado.ioloop DCNL DCSP import tornado.web DCNL DCSP class MainHandler ( tornado.web.RequestHandler , ) : DCNL DCSP DCSP def get ( self ) : DCNL DCSP DCSP DCSP self.write ( &apos; Hello , DCSP world &apos; ) DCNL DCSP DCSP DCSP raise SystemExit ( ) DCNL DCSP def runserver ( ) : DCNL DCSP DCSP application = tornado.web.Application ( &#91; ( &apos; / &apos; , MainHandler ) &#93; ) DCNL DCSP DCSP application.listen ( 8000 ) DCNL DCSP DCSP tornado.ioloop.IOLoop.instance ( ) .start ( ) DCNL DCSP server = multiprocessing.Process ( target = runserver ) DCNL DCSP server.start ( ) DCNL DCSP time.sleep ( 1 ) DCNL DCSP e = &apos; Lettuce DCSP could DCSP not DCSP run DCSP the DCSP builtin DCSP Django DCSP server DCSP at DCSP 0.0.0.0 : 8000 &quot; \ nmaybe DCSP you DCSP forgot DCSP a DCSP &quot; runserver &quot; DCSP instance DCSP running DCSP ? \ n \ nwell DCSP if DCSP you DCSP really DCSP do DCSP not DCSP want DCSP lettuce DCSP to DCSP run DCSP the DCSP server DCSP for DCSP you , DCSP then DCSP just DCSP run : \ n \ npython DCSP manage.py DCSP --no-server &apos; DCNL DCSP try : DCNL DCSP DCSP ( status , out ) = commands.getstatusoutput ( &apos; python DCSP manage.py DCSP harvest DCSP --verbosity = 3 DCSP --no-color &apos; ) DCNL DCSP DCSP assert _ equals ( out , e ) DCNL DCSP DCSP assert _ not _ equals ( status , 0 ) DCNL DCSP finally : DCNL DCSP DCSP os.kill ( server.pid , 9 )
DCSP return soft _ unicode ( s ) .lower ( )
DCSP value = value.lower ( ) DCNL DCSP if ( value &#91; ( -2 ) : &#93; = = &apos; ib &apos; ) : DCNL DCSP DCSP suffix = value &#91; ( -3 ) : &#93; .lower ( ) DCNL DCSP else : DCNL DCSP DCSP suffix = value &#91; ( -2 ) : &#93; .lower ( ) DCNL DCSP has _ size _ identifier = ( ( len ( value ) &gt; = 2 ) and ( suffix in SIZE _ SUFFIX ) ) DCNL DCSP if ( not has _ size _ identifier ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return int ( value ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Invalid DCSP size DCSP value : DCSP % s &apos; % value ) ) DCNL DCSP else : DCNL DCSP DCSP multiplier = SIZE _ SUFFIX &#91; suffix &#93; DCNL DCSP DCSP return ( int ( value &#91; : ( - len ( suffix ) ) &#93; ) * multiplier )
DCSP @ decorators.runs _ once DCNL DCSP def mytask ( ) : DCNL DCSP DCSP print &apos; yolo &apos; DCNL DCSP with settings ( hide ( &apos; everything &apos; ) , parallel = True ) : DCNL DCSP DCSP execute ( mytask , hosts = &#91; &apos; localhost &apos; , &apos; 127.0.0.1 &apos; &#93; ) DCNL DCSP result = sys.stdout.getvalue ( ) DCNL DCSP eq _ ( result , &apos; yolo \ n &apos; ) DCNL DCSP assert ( result ! = &apos; yolo \ nyolo \ n &apos; )
DCSP scenario _ results = &#91; r &#91; &apos; scenario &apos; &#93; for r in results if ( r &#91; &apos; scenario &apos; &#93; .get ( &apos; metrics &apos; ) and r &#91; &apos; scenario &apos; &#93; &#91; &apos; metrics &apos; &#93; .get ( &apos; call _ durations &apos; ) ) &#93; DCNL DCSP if ( len ( scenario _ results ) &gt; 0 ) : DCNL DCSP DCSP unique _ metrics = &#91; &#93; DCNL DCSP DCSP for result in scenario _ results : DCNL DCSP DCSP DCSP if ( result &#91; &apos; metrics &apos; &#93; not in unique _ metrics ) : DCNL DCSP DCSP DCSP DCSP unique _ metrics.append ( result &#91; &apos; metrics &apos; &#93; ) DCNL DCSP DCSP total _ requests = 0 DCNL DCSP DCSP requests _ under _ limit = 0 DCNL DCSP DCSP for metric in unique _ metrics : DCNL DCSP DCSP DCSP for ( duration , num _ requests ) in metric &#91; &apos; call _ durations &apos; &#93; .iteritems ( ) : DCNL DCSP DCSP DCSP DCSP if ( float ( duration ) &lt; = limit ) : DCNL DCSP DCSP DCSP DCSP DCSP requests _ under _ limit + = num _ requests DCNL DCSP DCSP DCSP total _ requests + = ( metric &#91; &apos; ok _ count &apos; &#93; + metric &#91; &apos; err _ count &apos; &#93; ) DCNL DCSP DCSP return ( float ( requests _ under _ limit ) / total _ requests ) DCNL DCSP return None
DCSP with check _ jsonreport ( u &apos;missing _ steps &apos; ) : DCNL DCSP DCSP runner = Runner ( feature _ name ( u &apos;missing _ steps &apos; ) , enable _ jsonreport = True ) DCNL DCSP DCSP runner.run ( )
DCSP return ( isinstance ( obj , slice ) and ( obj.start = = 0 ) and ( obj.stop = = l ) and ( obj.step is None ) )
DCSP return next ( itertools.islice ( seq , 1 , None ) )
DCSP import cProfile DCNL DCSP import uuid DCNL DCSP profiler = cProfile.Profile ( ) DCNL DCSP profiler.enable ( ) DCNL DCSP try : DCNL DCSP DCSP ( yield ) DCNL DCSP finally : DCNL DCSP DCSP profiler.disable ( ) DCNL DCSP DCSP profiler.dump _ stats ( &apos; { 0 } _ { 1 } _ master.profile &apos; .format ( file _ prefix , uuid.uuid4 ( ) ) )
DCSP with builder.if _ then ( is _ scalar _ zero ( builder , value ) , likely = False ) : DCNL DCSP DCSP exc = exc _ tuple &#91; 0 &#93; DCNL DCSP DCSP exc _ args = ( exc _ tuple &#91; 1 : &#93; or None ) DCNL DCSP DCSP context.call _ conv.return _ user _ exc ( builder , exc , exc _ args )
DCSP x = func.args &#91; 0 &#93; DCNL DCSP f = func.func DCNL DCSP C1 = get _ numbered _ constants ( eq , num = 1 ) DCNL DCSP r = match DCNL DCSP u = r.get ( &apos; hint &apos; , f ( x ) ) DCNL DCSP return Eq ( Integral ( ( ( r &#91; &apos; m2 &apos; &#93; &#91; &apos; coeff &apos; &#93; * r &#91; &apos; m2 &apos; &#93; &#91; r &#91; &apos; y &apos; &#93; &#93; ) / r &#91; &apos; m1 &apos; &#93; &#91; r &#91; &apos; y &apos; &#93; &#93; ) , ( r &#91; &apos; y &apos; &#93; , None , u ) ) , ( Integral ( ( ( ( - r &#91; &apos; m1 &apos; &#93; &#91; &apos; coeff &apos; &#93; ) * r &#91; &apos; m1 &apos; &#93; &#91; x &#93; ) / r &#91; &apos; m2 &apos; &#93; &#91; x &#93; ) , x ) + C1 ) )
DCSP if ( replica _ set _ name is None ) : DCNL DCSP DCSP replica _ set _ name = server _ description.replica _ set _ name DCNL DCSP elif ( replica _ set _ name ! = server _ description.replica _ set _ name ) : DCNL DCSP DCSP sds.pop ( server _ description.address ) DCNL DCSP DCSP return ( _ check _ has _ primary ( sds ) , replica _ set _ name , max _ set _ version , max _ election _ id ) DCNL DCSP max _ election _ tuple = ( max _ set _ version , max _ election _ id ) DCNL DCSP if ( None not in server _ description.election _ tuple ) : DCNL DCSP DCSP if ( ( None not in max _ election _ tuple ) and ( max _ election _ tuple &gt; server _ description.election _ tuple ) ) : DCNL DCSP DCSP DCSP address = server _ description.address DCNL DCSP DCSP DCSP sds &#91; address &#93; = ServerDescription ( address ) DCNL DCSP DCSP DCSP return ( _ check _ has _ primary ( sds ) , replica _ set _ name , max _ set _ version , max _ election _ id ) DCNL DCSP DCSP max _ election _ id = server _ description.election _ id DCNL DCSP if ( ( server _ description.set _ version is not None ) and ( ( max _ set _ version is None ) or ( server _ description.set _ version &gt; max _ set _ version ) ) ) : DCNL DCSP DCSP max _ set _ version = server _ description.set _ version DCNL DCSP for server in sds.values ( ) : DCNL DCSP DCSP if ( ( server.server _ type is SERVER _ TYPE.RSPrimary ) and ( server.address ! = server _ description.address ) ) : DCNL DCSP DCSP DCSP sds &#91; server.address &#93; = ServerDescription ( server.address ) DCNL DCSP DCSP DCSP break DCNL DCSP for new _ address in server _ description.all _ hosts : DCNL DCSP DCSP if ( new _ address not in sds ) : DCNL DCSP DCSP DCSP sds &#91; new _ address &#93; = ServerDescription ( new _ address ) DCNL DCSP for addr in ( set ( sds ) - server _ description.all _ hosts ) : DCNL DCSP DCSP sds.pop ( addr ) DCNL DCSP return ( _ check _ has _ primary ( sds ) , replica _ set _ name , max _ set _ version , max _ election _ id )
DCSP iso639 = _ load _ iso639 ( ) DCNL DCSP translate = _ DCNL DCSP ans = { } DCNL DCSP names = set ( names ) DCNL DCSP for ( k , v ) in iso639 &#91; &apos; by _ 3t &apos; &#93; .iteritems ( ) : DCNL DCSP DCSP tv = translate ( v ) DCNL DCSP DCSP if ( tv in names ) : DCNL DCSP DCSP DCSP names.remove ( tv ) DCNL DCSP DCSP DCSP ans &#91; tv &#93; = k DCNL DCSP DCSP if ( not names ) : DCNL DCSP DCSP DCSP break DCNL DCSP for x in names : DCNL DCSP DCSP ans &#91; x &#93; = None DCNL DCSP return ans
DCSP mark = request.node.get _ marker ( u &apos;celery &apos; ) DCNL DCSP config = dict ( celery _ config , * * ( mark.kwargs if mark else { } ) ) DCNL DCSP with _ create _ app ( request , enable _ logging = celery _ enable _ logging , use _ trap = use _ celery _ app _ trap , parameters = celery _ parameters , * * config ) as app : DCNL DCSP DCSP ( yield app )
DCSP if sparse : DCNL DCSP DCSP activeElementsInInput = set ( input ) DCNL DCSP DCSP activeElementsInPrediction = set ( prediction ) DCNL DCSP else : DCNL DCSP DCSP activeElementsInInput = set ( input.nonzero ( ) &#91; 0 &#93; ) DCNL DCSP DCSP activeElementsInPrediction = set ( prediction.nonzero ( ) &#91; 0 &#93; ) DCNL DCSP totalActiveInPrediction = len ( activeElementsInPrediction ) DCNL DCSP totalActiveInInput = len ( activeElementsInInput ) DCNL DCSP foundInInput = len ( activeElementsInPrediction.intersection ( activeElementsInInput ) ) DCNL DCSP missingFromInput = len ( activeElementsInPrediction.difference ( activeElementsInInput ) ) DCNL DCSP missingFromPrediction = len ( activeElementsInInput.difference ( activeElementsInPrediction ) ) DCNL DCSP if ( verbosity &gt; = 1 ) : DCNL DCSP DCSP print &apos; preds . DCSP found DCSP in DCSP input : &apos; , foundInInput , &apos; out DCSP of &apos; , totalActiveInPrediction , DCNL DCSP DCSP print &apos; ; DCSP preds . DCSP missing DCSP from DCSP input : &apos; , missingFromInput , &apos; out DCSP of &apos; , totalActiveInPrediction , DCNL DCSP DCSP print &apos; ; DCSP unexpected DCSP active DCSP in DCSP input : &apos; , missingFromPrediction , &apos; out DCSP of &apos; , totalActiveInInput DCNL DCSP return ( foundInInput , totalActiveInInput , missingFromInput , totalActiveInPrediction )
DCSP for backend in auth.get _ backends ( ) : DCNL DCSP DCSP if ( not hasattr ( backend , &apos; has _ module _ perms &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if backend.has _ module _ perms ( user , app _ label ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP except PermissionDenied : DCNL DCSP DCSP DCSP return False DCNL DCSP return False
DCSP xml _ declaration = kwargs.pop ( u &apos;xml _ declaration &apos; , False ) DCNL DCSP encoding = kwargs.pop ( u &apos;encoding &apos; , u &apos;UTF-8 &apos; ) DCNL DCSP kwargs &#91; u &apos;encoding &apos; &#93; = unicode DCNL DCSP kwargs &#91; u &apos;xml _ declaration &apos; &#93; = False DCNL DCSP ans = etree.tostring ( raw , * * kwargs ) DCNL DCSP if xml _ declaration : DCNL DCSP DCSP ans = ( ( u &apos; &lt; ? xml DCSP version = &quot; 1.0 &quot; DCSP encoding = &quot; % s &quot; ? &gt; \ n &apos; % encoding ) + ans ) DCNL DCSP return re.sub ( u &apos; &amp; # x ( &#91; 0-9A-Fa-f &#93; + ) ; &apos; , ( lambda m : mychr ( int ( m.group ( 1 ) , 16 ) ) ) , ans ) .encode ( encoding )
DCSP def decode ( m ) : DCNL DCSP DCSP html = m.group ( 0 ) DCNL DCSP DCSP if ( html &#91; : 2 &#93; = = u &apos; &amp; # &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( html &#91; : 3 &#93; = = u &apos; &amp; # x &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP return chr ( int ( html &#91; 3 : ( -1 ) &#93; , 16 ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return chr ( int ( html &#91; 2 : ( -1 ) &#93; ) ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP html = chr ( name2codepoint &#91; html &#91; 1 : ( -1 ) &#93; &#93; ) DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP return html DCNL DCSP return re.sub ( u &apos; &amp; # ? \ \ w + ; &apos; , decode , html.replace ( u &apos; &amp; amp ; &apos; , u &apos; &amp; &apos; ) )
DCSP negative _ chains.show _ negative _ chains ( &apos; dbm.pkl &apos; )
DCSP ( defrag , frag ) = urldefrag ( url ) DCNL DCSP if ( not frag.startswith ( &apos; ! &apos; ) ) : DCNL DCSP DCSP return url DCNL DCSP return add _ or _ replace _ parameter ( defrag , &apos; _ escaped _ fragment _ &apos; , frag &#91; 1 : &#93; )
DCSP from .conf import settings as app _ settings DCNL DCSP VERBOSE _ LOOKUPS = ( app _ settings.VERBOSE _ LOOKUPS or { } ) DCNL DCSP lookups = &#91; force _ text ( VERBOSE _ LOOKUPS.get ( lookup , _ ( lookup ) ) ) for lookup in lookup _ expr.split ( LOOKUP _ SEP ) &#93; DCNL DCSP return &apos; DCSP &apos; .join ( lookups )
DCSP errback = ( errback or _ ensure _ errback ) DCNL DCSP with pool.acquire ( block = True ) as conn : DCNL DCSP DCSP conn.ensure _ connection ( errback = errback ) DCNL DCSP DCSP channel = conn.default _ channel DCNL DCSP DCSP revive = partial ( revive _ connection , conn , on _ revive = on _ revive ) DCNL DCSP DCSP insured = conn.autoretry ( fun , channel , errback = errback , on _ revive = revive , * * opts ) DCNL DCSP DCSP ( retval , _ ) = insured ( * args , * * dict ( kwargs , connection = conn ) ) DCNL DCSP DCSP return retval
DCSP result = None DCNL DCSP f = open ( filename , &apos; rb &apos; ) DCNL DCSP try : DCNL DCSP DCSP f.seek ( ( - ( LEN _ IEND + LEN _ DEPTH ) ) , 2 ) DCNL DCSP DCSP depthchunk = f.read ( LEN _ DEPTH ) DCNL DCSP DCSP if ( not depthchunk.startswith ( ( DEPTH _ CHUNK _ LEN + DEPTH _ CHUNK _ START ) ) ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP result = struct.unpack ( &apos; ! i &apos; , depthchunk &#91; 14 : 18 &#93; ) &#91; 0 &#93; DCNL DCSP finally : DCNL DCSP DCSP f.close ( ) DCNL DCSP return result
DCSP if ( not isinstance ( node , Function ) ) : DCNL DCSP DCSP return DCNL DCSP if ( not node.parent ) : DCNL DCSP DCSP return DCNL DCSP try : DCNL DCSP DCSP result = next ( node.infer _ call _ result ( node.parent ) ) DCNL DCSP except ( StopIteration , InferenceError ) : DCNL DCSP DCSP return DCNL DCSP if isinstance ( result , Instance ) : DCNL DCSP DCSP result = result . _ proxied DCNL DCSP if isinstance ( result , Class ) : DCNL DCSP DCSP if result.is _ subtype _ of ( ( &apos; % s.classmethod &apos; % BUILTINS ) ) : DCNL DCSP DCSP DCSP return &apos; classmethod &apos; DCNL DCSP DCSP if result.is _ subtype _ of ( ( &apos; % s.staticmethod &apos; % BUILTINS ) ) : DCNL DCSP DCSP DCSP return &apos; staticmethod&apos;
DCSP if ( not DNS _ AVAILABLE ) : DCNL DCSP DCSP raise errors.DependencyError ( &apos; { 0 } DCSP is DCSP required DCSP to DCSP use DCSP this DCSP function &apos; .format ( DNS _ REQUIREMENT ) ) DCNL DCSP try : DCNL DCSP DCSP dns _ response = dns.resolver.query ( name , &apos; TXT &apos; ) DCNL DCSP except dns.resolver.NXDOMAIN as error : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP except dns.exception.DNSException as error : DCNL DCSP DCSP logger.error ( &apos; Error DCSP resolving DCSP % s : DCSP % s &apos; , name , str ( error ) ) DCNL DCSP DCSP return &#91; &#93; DCNL DCSP return &#91; txt _ rec.decode ( &apos; utf-8 &apos; ) for rdata in dns _ response for txt _ rec in rdata.strings &#93;
DCSP if derivative : DCNL DCSP DCSP return _ spherical _ yn _ d ( n , z ) DCNL DCSP else : DCNL DCSP DCSP return _ spherical _ yn ( n , z )
DCSP app _ messages.sort ( ( lambda x , y : cmp ( x &#91; 1 &#93; , y &#91; 1 &#93; ) ) ) DCNL DCSP from csv import writer DCNL DCSP with open ( path , u &apos;wb &apos; ) as msgfile : DCNL DCSP DCSP w = writer ( msgfile , lineterminator = u &apos; \ n &apos; ) DCNL DCSP DCSP for ( p , m ) in app _ messages : DCNL DCSP DCSP DCSP t = lang _ dict.get ( m , u &apos; &apos; ) DCNL DCSP DCSP DCSP t = re.sub ( u &apos; { \ \ s ? ( &#91; 0-9 &#93; + ) \ \ s ? } &apos; , u &apos; { \ \ g &lt; 1 &gt; } &apos; , t ) DCNL DCSP DCSP DCSP w.writerow ( &#91; ( p.encode ( u &apos;utf-8 &apos; ) if p else u &apos; &apos; ) , m.encode ( u &apos;utf-8 &apos; ) , t.encode ( u &apos;utf-8 &apos; ) &#93; )
DCSP _ update _ week _ number ( ) DCNL DCSP return ( _ cur _ year , _ cur _ week )
DCSP return 23
DCSP try : DCNL DCSP DCSP p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE , close _ fds = ( os.name ! = &apos; nt &apos; ) , universal _ newlines = True ) DCNL DCSP except OSError as e : DCNL DCSP DCSP six.reraise ( os _ err _ exc _ type , os _ err _ exc _ type ( ( &apos; Error DCSP executing DCSP % s : DCSP % s &apos; % ( args &#91; 0 &#93; , e.strerror ) ) ) , sys.exc _ info ( ) &#91; 2 &#93; ) DCNL DCSP ( output , errors ) = p.communicate ( ) DCNL DCSP return ( output , force _ text ( errors , DEFAULT _ LOCALE _ ENCODING , strings _ only = True ) , p.returncode )
DCSP if ( prefix is None ) : DCNL DCSP DCSP prefix = settings.STATIC _ URL DCNL DCSP return static ( prefix , view = &apos; django.contrib.staticfiles.views.serve &apos; )
DCSP for pattern in patterns : DCNL DCSP DCSP if fnmatch ( pathname , pattern ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP return &#91; vv for ( kk , vv ) in tparams.iteritems ( ) &#93;
DCSP return &apos; ERROR : DCSP This DCSP function DCSP has DCSP been DCSP moved DCSP to DCSP cmd.tty&apos;
DCSP parser = optparse.OptionParser ( ) DCNL DCSP parser.add _ option ( &apos; -e &apos; , &apos; --expire-date &apos; , dest = &apos; expire _ date &apos; , type = &apos; int &apos; , default = 30 , help = &apos; number DCSP of DCSP days DCSP before DCSP builds DCSP expire &apos; ) DCNL DCSP parser.add _ option ( &apos; -i &apos; , &apos; --include &apos; , dest = &apos; include &apos; , type = &apos; str &apos; , action = &apos; append &apos; , help = &apos; Globs DCSP of DCSP files DCSP to DCSP include &apos; ) DCNL DCSP parser.add _ option ( &apos; -n &apos; , &apos; --no-exec &apos; , dest = &apos; fake &apos; , action = &apos; store _ true &apos; , help = &apos; Do DCSP not DCSP remove DCSP files &apos; ) DCNL DCSP parser.add _ option ( &apos; -X &apos; , &apos; --exclude &apos; , dest = &apos; exclude &apos; , type = &apos; str &apos; , action = &apos; append &apos; , help = &apos; Globs DCSP of DCSP files DCSP to DCSP exclude &apos; ) DCNL DCSP ( args , dirs ) = parser.parse _ args ( ) DCNL DCSP if ( not dirs ) : DCNL DCSP DCSP parser.error ( &apos; you DCSP must DCSP specify DCSP one DCSP or DCSP more DCSP directories &apos; ) DCNL DCSP for buildroot in dirs : DCNL DCSP DCSP rm _ old _ files ( buildroot , expire _ time = ( args.expire _ date * DAY ) , excludes = args.exclude , fake = args.fake , includes = args.include )
DCSP data _ size = ctypes.wintypes.DWORD ( ) DCNL DCSP ctypes.windll.advapi32.GetTokenInformation ( token , information _ class.num , 0 , 0 , ctypes.byref ( data _ size ) ) DCNL DCSP data = ctypes.create _ string _ buffer ( data _ size.value ) DCNL DCSP handle _ nonzero _ success ( ctypes.windll.advapi32.GetTokenInformation ( token , information _ class.num , ctypes.byref ( data ) , ctypes.sizeof ( data ) , ctypes.byref ( data _ size ) ) ) DCNL DCSP return ctypes.cast ( data , ctypes.POINTER ( TOKEN _ USER ) ) .contents
DCSP if ( a.ndim &lt; 2 ) : DCNL DCSP DCSP raise ValueError ( &apos; array DCSP must DCSP be DCSP at DCSP least DCSP 2-d &apos; ) DCNL DCSP end = None DCNL DCSP if ( a.ndim = = 2 ) : DCNL DCSP DCSP step = ( a.shape &#91; 1 &#93; + 1 ) DCNL DCSP DCSP if ( not wrap ) : DCNL DCSP DCSP DCSP end = ( a.shape &#91; 1 &#93; * a.shape &#91; 1 &#93; ) DCNL DCSP else : DCNL DCSP DCSP if ( not numpy.alltrue ( ( numpy.diff ( a.shape ) = = 0 ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; All DCSP dimensions DCSP of DCSP input DCSP must DCSP be DCSP of DCSP equal DCSP length &apos; ) DCNL DCSP DCSP step = ( 1 + numpy.cumprod ( a.shape &#91; : ( -1 ) &#93; ) .sum ( ) ) DCNL DCSP a.ravel ( ) &#91; : end : step &#93; = val
DCSP y = np.linspace ( 0 , 1 , 20 ) DCNL DCSP bc = BalanceCascade ( random _ state = RND _ SEED ) DCNL DCSP assert _ warns ( UserWarning , bc.fit , X , y ) DCNL DCSP y = np.array ( ( ( ( &#91; 0 &#93; * 3 ) + ( &#91; 1 &#93; * 2 ) ) + ( &#91; 2 &#93; * 15 ) ) ) DCNL DCSP bc = BalanceCascade ( random _ state = RND _ SEED ) DCNL DCSP assert _ warns ( UserWarning , bc.fit , X , y )
DCSP warnings.warn ( &apos; chainer.cuda.full _ like DCSP is DCSP deprecated . DCSP Use DCSP cupy.full _ like DCSP instead . &apos; , DeprecationWarning ) DCNL DCSP check _ cuda _ available ( ) DCNL DCSP assert ( stream is None ) DCNL DCSP if isinstance ( array , cupy.ndarray ) : DCNL DCSP DCSP return cupy.full _ like ( array , fill _ value ) DCNL DCSP return cupy.full ( array.shape , fill _ value , dtype = array.dtype )
DCSP timings = &#91; &#93; DCNL DCSP errors = &#91; &#93; DCNL DCSP for _ in range ( 0 , constants.NUM _ SAMPLES ) : DCNL DCSP DCSP start = time.time ( ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP query = TestModel.all ( ) DCNL DCSP DCSP DCSP query.filter ( &apos; test _ string DCSP = &apos; , uuid ) DCNL DCSP DCSP DCSP query.fetch ( constants.NUM _ SAMPLES ) DCNL DCSP DCSP DCSP total _ time = ( time.time ( ) - start ) DCNL DCSP DCSP except Exception as exception : DCNL DCSP DCSP DCSP logging.exception ( exception ) DCNL DCSP DCSP DCSP errors.append ( str ( exception ) ) DCNL DCSP DCSP DCSP total _ time = 0 DCNL DCSP DCSP timings.append ( ( total _ time * constants.SECONDS _ TO _ MILLI ) ) DCNL DCSP return ( timings , errors )
DCSP sec _ group _ ref = models.SecurityGroupInstanceAssociation ( ) DCNL DCSP sec _ group _ ref.update ( { &apos; instance _ uuid &apos; : instance _ uuid , &apos; security _ group _ id &apos; : security _ group _ id } ) DCNL DCSP sec _ group _ ref.save ( )
DCSP global WORKDIR , DEPSRC , SDKPATH , SRCDIR , DEPTARGET DCNL DCSP global UNIVERSALOPTS , UNIVERSALARCHS , ARCHLIST , CC , CXX DCNL DCSP global FW _ VERSION _ PREFIX DCNL DCSP global FW _ SSL _ DIRECTORY DCNL DCSP if ( args is None ) : DCNL DCSP DCSP args = sys.argv &#91; 1 : &#93; DCNL DCSP try : DCNL DCSP DCSP ( options , args ) = getopt.getopt ( args , &apos; ? hb &apos; , &#91; &apos; build-dir = &apos; , &apos; third-party = &apos; , &apos; sdk-path = &apos; , &apos; src-dir = &apos; , &apos; dep-target = &apos; , &apos; universal-archs = &apos; , &apos; help &apos; &#93; ) DCNL DCSP except getopt.GetoptError : DCNL DCSP DCSP print sys.exc _ info ( ) &#91; 1 &#93; DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP if args : DCNL DCSP DCSP print &apos; Additional DCSP arguments &apos; DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP deptarget = None DCNL DCSP for ( k , v ) in options : DCNL DCSP DCSP if ( k in ( &apos; -h &apos; , &apos; - ? &apos; , &apos; --help &apos; ) ) : DCNL DCSP DCSP DCSP print USAGE DCNL DCSP DCSP DCSP sys.exit ( 0 ) DCNL DCSP DCSP elif ( k in ( &apos; -d &apos; , &apos; --build-dir &apos; ) ) : DCNL DCSP DCSP DCSP WORKDIR = v DCNL DCSP DCSP elif ( k in ( &apos; --third-party &apos; , ) ) : DCNL DCSP DCSP DCSP DEPSRC = v DCNL DCSP DCSP elif ( k in ( &apos; --sdk-path &apos; , ) ) : DCNL DCSP DCSP DCSP SDKPATH = v DCNL DCSP DCSP elif ( k in ( &apos; --src-dir &apos; , ) ) : DCNL DCSP DCSP DCSP SRCDIR = v DCNL DCSP DCSP elif ( k in ( &apos; --dep-target &apos; , ) ) : DCNL DCSP DCSP DCSP DEPTARGET = v DCNL DCSP DCSP DCSP deptarget = v DCNL DCSP DCSP elif ( k in ( &apos; --universal-archs &apos; , ) ) : DCNL DCSP DCSP DCSP if ( v in UNIVERSALOPTS ) : DCNL DCSP DCSP DCSP DCSP UNIVERSALARCHS = v DCNL DCSP DCSP DCSP DCSP ARCHLIST = universal _ opts _ map &#91; UNIVERSALARCHS &#93; DCNL DCSP DCSP DCSP DCSP if ( deptarget is None ) : DCNL DCSP DCSP DCSP DCSP DCSP DEPTARGET = default _ target _ map.get ( v , &apos; 10.3 &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise NotImplementedError ( v ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise NotImplementedError ( k ) DCNL DCSP SRCDIR = os.path.abspath ( SRCDIR ) DCNL DCSP WORKDIR = os.path.abspath ( WORKDIR ) DCNL DCSP SDKPATH = os.path.abspath ( SDKPATH ) DCNL DCSP DEPSRC = os.path.abspath ( DEPSRC ) DCNL DCSP ( CC , CXX ) = getTargetCompilers ( ) DCNL DCSP FW _ VERSION _ PREFIX = ( FW _ PREFIX &#91; : &#93; + &#91; &apos; Versions &apos; , getVersion ( ) &#93; ) DCNL DCSP FW _ SSL _ DIRECTORY = ( FW _ VERSION _ PREFIX &#91; : &#93; + &#91; &apos; etc &apos; , &apos; openssl &apos; &#93; ) DCNL DCSP print &apos; -- DCSP Settings : &apos; DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP Source DCSP directory : DCSP DCSP DCSP DCSP % s &apos; % SRCDIR ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP Build DCSP directory : DCSP DCSP DCSP DCSP DCSP % s &apos; % WORKDIR ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP SDK DCSP location : DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP % s &apos; % SDKPATH ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP Third-party DCSP source : DCSP DCSP % s &apos; % DEPSRC ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP Deployment DCSP target : DCSP DCSP DCSP % s &apos; % DEPTARGET ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP Universal DCSP archs : DCSP DCSP DCSP DCSP DCSP % s &apos; % str ( ARCHLIST ) ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP C DCSP compiler : DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP % s &apos; % CC ) DCNL DCSP print ( &apos; DCSP DCSP DCSP * DCSP C + + DCSP compiler : DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP % s &apos; % CXX ) DCNL DCSP print &apos; &apos; DCNL DCSP print ( &apos; DCSP -- DCSP Building DCSP a DCSP Python DCSP % s DCSP framework DCSP at DCSP patch DCSP level DCSP % s &apos; % ( getVersion ( ) , getFullVersion ( ) ) ) DCNL DCSP print &apos; &apos;
DCSP _ delete _ item ( usage _ key , request.user )
DCSP http _ callable = getattr ( http , &apos; request &apos; , http ) DCNL DCSP return http _ callable ( uri , method = method , body = body , headers = headers , redirections = redirections , connection _ type = connection _ type )
DCSP if ( axis is None ) : DCNL DCSP DCSP a = ravel ( a ) DCNL DCSP DCSP outaxis = 0 DCNL DCSP else : DCNL DCSP DCSP a = asarray ( a ) DCNL DCSP DCSP outaxis = axis DCNL DCSP return ( a , outaxis )
DCSP create _ dir ( output _ dir ) DCNL DCSP for e in simsam _ range ( table , tree , simulated _ sample _ sizes , dissimilarities , mapping _ f ) : DCNL DCSP DCSP output _ table = e &#91; 0 &#93; DCNL DCSP DCSP output _ mapping _ lines = e &#91; 1 &#93; DCNL DCSP DCSP simulated _ sample _ size = e &#91; 2 &#93; DCNL DCSP DCSP dissimilarity = e &#91; 3 &#93; DCNL DCSP DCSP output _ table _ fp = join ( output _ dir , ( &apos; % s _ n % d _ d % r.biom &apos; % ( output _ table _ basename , simulated _ sample _ size , dissimilarity ) ) ) DCNL DCSP DCSP write _ biom _ table ( output _ table , output _ table _ fp ) DCNL DCSP DCSP if ( output _ mapping _ lines is not None ) : DCNL DCSP DCSP DCSP output _ map _ fp = join ( output _ dir , ( &apos; % s _ n % d _ d % r.txt &apos; % ( output _ map _ basename , simulated _ sample _ size , dissimilarity ) ) ) DCNL DCSP DCSP DCSP output _ map _ f = open ( output _ map _ fp , &apos; w &apos; ) DCNL DCSP DCSP DCSP output _ map _ f.write ( &apos; &apos;.join ( output _ mapping _ lines ) ) DCNL DCSP DCSP DCSP output _ map _ f.close ( )
DCSP try : DCNL DCSP DCSP acc = ( state &#91; &apos; test _ acc &apos; &#93; + 1 ) DCNL DCSP except KeyError : DCNL DCSP DCSP acc = 1 DCNL DCSP state &#91; &apos; test _ acc &apos; &#93; = acc DCNL DCSP res = line.split ( ) DCNL DCSP res &#91; 2 &#93; = acc DCNL DCSP res &#91; 3 &#93; = { &apos; metric _ type &apos; : &apos; counter &apos; } DCNL DCSP return tuple ( res )
DCSP cmd = &apos; systemsetup DCSP -setlocalsubnetname DCSP &quot; { 0 } &quot; &apos; .format ( name ) DCNL DCSP salt.utils.mac _ utils.execute _ return _ success ( cmd ) DCNL DCSP return salt.utils.mac _ utils.confirm _ updated ( name , get _ subnet _ name )
DCSP y _ true = &#91; 1 , 1 , 2 , 3 &#93; DCNL DCSP y _ pred = &#91; 1 , 3 , 3 , 3 &#93; DCNL DCSP specificity _ 13 = partial ( specificity _ score , y _ true , y _ pred , labels = &#91; 1 , 3 &#93; ) DCNL DCSP specificity _ all = partial ( specificity _ score , y _ true , y _ pred , labels = None ) DCNL DCSP assert _ allclose ( &#91; 1.0 , 0.33 &#93; , specificity _ 13 ( average = None ) , rtol = R _ TOL ) DCNL DCSP assert _ allclose ( np.mean ( &#91; 1.0 , 0.33 &#93; ) , specificity _ 13 ( average = &apos; macro &apos; ) , rtol = R _ TOL ) DCNL DCSP assert _ allclose ( np.average ( &#91; 1.0 , 0.33 &#93; , weights = &#91; 2.0 , 1.0 &#93; ) , specificity _ 13 ( average = &apos; weighted &apos; ) , rtol = R _ TOL ) DCNL DCSP assert _ allclose ( ( 3.0 / ( 3.0 + 2.0 ) ) , specificity _ 13 ( average = &apos; micro &apos; ) , rtol = R _ TOL ) DCNL DCSP for average in &#91; &apos; macro &apos; , &apos; weighted &apos; , &apos; micro &apos; &#93; : DCNL DCSP DCSP assert _ not _ equal ( specificity _ 13 ( average = average ) , specificity _ all ( average = average ) )
DCSP for desc in _ description.splitlines ( ) : DCNL DCSP DCSP print desc
DCSP beta _ initial = &#91; random.random ( ) for x _ i in x &#91; 0 &#93; &#93; DCNL DCSP return minimize _ stochastic ( partial ( squared _ error _ ridge , alpha = alpha ) , partial ( squared _ error _ ridge _ gradient , alpha = alpha ) , x , y , beta _ initial , 0.001 )
DCSP fq _ name = str ( fq _ name ) DCNL DCSP module _ name = _ _ name _ _ DCNL DCSP short _ name = fq _ name DCNL DCSP if ( fq _ name.rfind ( &apos; .&apos; ) &gt; = 0 ) : DCNL DCSP DCSP ( module _ name , short _ name ) = ( fq _ name &#91; : fq _ name.rfind ( &apos; .&apos; ) &#93; , fq _ name &#91; ( fq _ name.rfind ( &apos; .&apos; ) + 1 ) : &#93; ) DCNL DCSP try : DCNL DCSP DCSP result = _ _ import _ _ ( module _ name , None , None , &#91; short _ name &#93; ) DCNL DCSP DCSP return result . _ _ dict _ _ &#91; short _ name &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP if recursive : DCNL DCSP DCSP DCSP raise DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ImportError ( ( &quot; Could DCSP not DCSP find DCSP &apos; % s &apos; DCSP on DCSP path DCSP &apos; % s &apos; &quot; % ( short _ name , module _ name ) ) ) DCNL DCSP except ImportError : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP module = for _ name ( module _ name , recursive = True ) DCNL DCSP DCSP DCSP if hasattr ( module , short _ name ) : DCNL DCSP DCSP DCSP DCSP return getattr ( module , short _ name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise KeyError ( ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP raise ImportError ( ( &quot; Could DCSP not DCSP find DCSP &apos; % s &apos; DCSP on DCSP path DCSP &apos; % s &apos; &quot; % ( short _ name , module _ name ) ) ) DCNL DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP raise
DCSP if ( ( not vgname ) or ( not devices ) ) : DCNL DCSP DCSP return &apos; Error : DCSP vgname DCSP and DCSP device ( s ) DCSP are DCSP both DCSP required &apos; DCNL DCSP if isinstance ( devices , six.string _ types ) : DCNL DCSP DCSP devices = devices.split ( &apos; , &apos; ) DCNL DCSP cmd = &#91; &apos; vgcreate &apos; , vgname &#93; DCNL DCSP for device in devices : DCNL DCSP DCSP cmd.append ( device ) DCNL DCSP valid = ( &apos; clustered &apos; , &apos; maxlogicalvolumes &apos; , &apos; maxphysicalvolumes &apos; , &apos; vgmetadatacopies &apos; , &apos; metadatacopies &apos; , &apos; physicalextentsize &apos; ) DCNL DCSP for var in kwargs : DCNL DCSP DCSP if ( kwargs &#91; var &#93; and ( var in valid ) ) : DCNL DCSP DCSP DCSP cmd.append ( &apos; -- { 0 } &apos; .format ( var ) ) DCNL DCSP DCSP DCSP cmd.append ( kwargs &#91; var &#93; ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) .splitlines ( ) DCNL DCSP vgdata = vgdisplay ( vgname ) DCNL DCSP vgdata &#91; &apos; Output DCSP from DCSP vgcreate &apos; &#93; = out &#91; 0 &#93; .strip ( ) DCNL DCSP return vgdata
DCSP return fn ( * args , * * kwargs )
DCSP sbn1 = SpatialBatchNormalization ( ( 5 , ) ) DCNL DCSP ( yield ( assert _ raises , ( ValueError , sbn1.allocate ) ) ) DCNL DCSP sbn2 = SpatialBatchNormalization ( 3 ) DCNL DCSP ( yield ( assert _ raises , ( ValueError , sbn2.allocate ) ) ) DCNL DCSP def do _ not _ fail ( * input _ dim ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP sbn = SpatialBatchNormalization ( input _ dim ) DCNL DCSP DCSP DCSP sbn.allocate ( ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP assert False DCNL DCSP ( yield ( do _ not _ fail , 5 , 4 , 3 ) ) DCNL DCSP ( yield ( do _ not _ fail , 7 , 6 ) ) DCNL DCSP ( yield ( do _ not _ fail , 3 , 9 , 2 , 3 ) )
DCSP if ( not table ) : DCNL DCSP DCSP return &apos; Error : DCSP table DCSP needs DCSP to DCSP be DCSP specified &apos; DCNL DCSP if check _ table ( table , family = family ) : DCNL DCSP DCSP return &apos; Error : DCSP table DCSP { 0 } DCSP in DCSP family DCSP { 1 } DCSP already DCSP exists &apos; .format ( table , family ) DCNL DCSP nft _ family = _ NFTABLES _ FAMILIES &#91; family &#93; DCNL DCSP cmd = &apos; { 0 } DCSP add DCSP table DCSP { 1 } DCSP { 2 } &apos; .format ( _ nftables _ cmd ( ) , nft _ family , table ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP if ( not out ) : DCNL DCSP DCSP out = True DCNL DCSP return out
DCSP result = &#91; &#93; DCNL DCSP exponent = &#91; &#93; DCNL DCSP consuming _ exponent = False DCNL DCSP level = 0 DCNL DCSP for ( tok , nextTok ) in zip ( tokens , tokens &#91; 1 : &#93; ) : DCNL DCSP DCSP if ( ( tok &#91; 0 &#93; = = NAME ) and ( nextTok &#91; 0 &#93; = = OP ) and ( nextTok &#91; 1 &#93; = = &apos; * * &apos; ) ) : DCNL DCSP DCSP DCSP if _ token _ callable ( tok , local _ dict , global _ dict ) : DCNL DCSP DCSP DCSP DCSP consuming _ exponent = True DCNL DCSP DCSP elif consuming _ exponent : DCNL DCSP DCSP DCSP exponent.append ( tok ) DCNL DCSP DCSP DCSP if ( ( tok &#91; 0 &#93; = = nextTok &#91; 0 &#93; = = OP ) and ( tok &#91; 1 &#93; = = &apos; ) &apos; ) and ( nextTok &#91; 1 &#93; = = &apos; ( &apos; ) ) : DCNL DCSP DCSP DCSP DCSP consuming _ exponent = False DCNL DCSP DCSP DCSP if ( ( tok &#91; 0 &#93; = = nextTok &#91; 0 &#93; = = OP ) and ( tok &#91; 1 &#93; = = &apos; * &apos; ) and ( nextTok &#91; 1 &#93; = = &apos; ( &apos; ) ) : DCNL DCSP DCSP DCSP DCSP consuming _ exponent = False DCNL DCSP DCSP DCSP DCSP del exponent &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( exponent and ( not consuming _ exponent ) ) : DCNL DCSP DCSP DCSP if ( tok &#91; 0 &#93; = = OP ) : DCNL DCSP DCSP DCSP DCSP if ( tok &#91; 1 &#93; = = &apos; ( &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP level + = 1 DCNL DCSP DCSP DCSP DCSP elif ( tok &#91; 1 &#93; = = &apos; ) &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP level - = 1 DCNL DCSP DCSP DCSP if ( level = = 0 ) : DCNL DCSP DCSP DCSP DCSP result.append ( tok ) DCNL DCSP DCSP DCSP DCSP result.extend ( exponent ) DCNL DCSP DCSP DCSP DCSP exponent = &#91; &#93; DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP result.append ( tok ) DCNL DCSP if tokens : DCNL DCSP DCSP result.append ( tokens &#91; ( -1 ) &#93; ) DCNL DCSP if exponent : DCNL DCSP DCSP result.extend ( exponent ) DCNL DCSP return result
DCSP raw = read _ crop ( raw _ fname , ( 0.0 , 1.0 ) ) DCNL DCSP sss _ fine _ cal = read _ crop ( sss _ fine _ cal _ fname ) DCNL DCSP raw _ sss = maxwell _ filter ( raw , calibration = fine _ cal _ fname , origin = mf _ head _ origin , regularize = None , bad _ condition = &apos; ignore &apos; ) DCNL DCSP assert _ meg _ snr ( raw _ sss , sss _ fine _ cal , 82 , 611 ) DCNL DCSP py _ cal = raw _ sss.info &#91; &apos; proc _ history &apos; &#93; &#91; 0 &#93; &#91; &apos; max _ info &apos; &#93; &#91; &apos; sss _ cal &apos; &#93; DCNL DCSP assert _ true ( ( py _ cal is not None ) ) DCNL DCSP assert _ true ( ( len ( py _ cal ) &gt; 0 ) ) DCNL DCSP mf _ cal = sss _ fine _ cal.info &#91; &apos; proc _ history &apos; &#93; &#91; 0 &#93; &#91; &apos; max _ info &apos; &#93; &#91; &apos; sss _ cal &apos; &#93; DCNL DCSP mf _ cal &#91; &apos; cal _ chans &apos; &#93; &#91; ( ( mf _ cal &#91; &apos; cal _ chans &apos; &#93; &#91; : , 1 &#93; = = 3022 ) , 1 ) &#93; = 3024 DCNL DCSP assert _ allclose ( py _ cal &#91; &apos; cal _ chans &apos; &#93; , mf _ cal &#91; &apos; cal _ chans &apos; &#93; ) DCNL DCSP assert _ allclose ( py _ cal &#91; &apos; cal _ corrs &apos; &#93; , mf _ cal &#91; &apos; cal _ corrs &apos; &#93; , rtol = 0.001 , atol = 0.001 ) DCNL DCSP raw _ missing = raw.copy ( ) .load _ data ( ) DCNL DCSP raw _ missing.info &#91; &apos; bads &apos; &#93; = &#91; &apos; MEG0111 &apos; , &apos; MEG0943 &apos; &#93; DCNL DCSP raw _ missing.info. _ check _ consistency ( ) DCNL DCSP raw _ sss _ bad = maxwell _ filter ( raw _ missing , calibration = fine _ cal _ fname , origin = mf _ head _ origin , regularize = None , bad _ condition = &apos; ignore &apos; ) DCNL DCSP raw _ missing.pick _ types ( ) DCNL DCSP raw _ sss _ bad.pick _ channels ( raw _ missing.ch _ names ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP raw _ sss _ missing = maxwell _ filter ( raw _ missing , calibration = fine _ cal _ fname , origin = mf _ head _ origin , regularize = None , bad _ condition = &apos; ignore &apos; ) DCNL DCSP assert _ meg _ snr ( raw _ sss _ missing , raw _ sss _ bad , 1000.0 , 10000.0 ) DCNL DCSP raw _ sss _ 3D = maxwell _ filter ( raw , calibration = fine _ cal _ fname _ 3d , origin = mf _ head _ origin , regularize = None , bad _ condition = &apos; ignore &apos; ) DCNL DCSP assert _ meg _ snr ( raw _ sss _ 3D , sss _ fine _ cal , 1.0 , 6.0 ) DCNL DCSP raw _ ctf = read _ crop ( fname _ ctf _ raw ) .apply _ gradient _ compensation ( 0 ) DCNL DCSP assert _ raises ( RuntimeError , maxwell _ filter , raw _ ctf , origin = ( 0.0 , 0.0 , 0.04 ) , calibration = fine _ cal _ fname )
DCSP global _ CORE _ SITE _ DICT DCNL DCSP global _ CORE _ SITE _ PATH DCNL DCSP for indentifier in conf.HDFS _ CLUSTERS.get ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ CORE _ SITE _ PATH = os.path.join ( conf.HDFS _ CLUSTERS &#91; indentifier &#93; .HADOOP _ CONF _ DIR.get ( ) , &apos; core-site.xml &apos; ) DCNL DCSP DCSP DCSP data = file ( _ CORE _ SITE _ PATH , &apos; r &apos; ) .read ( ) DCNL DCSP DCSP DCSP break DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP data = &apos; &apos; DCNL DCSP DCSP except IOError as err : DCNL DCSP DCSP DCSP if ( err.errno ! = errno.ENOENT ) : DCNL DCSP DCSP DCSP DCSP LOG.error ( ( &apos; Cannot DCSP read DCSP from DCSP &quot; % s &quot; : DCSP % s &apos; % ( _ CORE _ SITE _ PATH , err ) ) ) DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP data = &apos; &apos; DCNL DCSP _ CORE _ SITE _ DICT = confparse.ConfParse ( data )
DCSP if ( ( not isinstance ( array , theano.Variable ) ) and ( not isinstance ( array , np.ndarray ) ) ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Unsupported DCSP type DCSP { } . DCSP Only DCSP theano DCSP variables DCSP and DCSP numpy DCSP arrays DCSP are DCSP supported &apos; .format ( type ( array ) ) ) DCNL DCSP ndim = array.ndim DCNL DCSP if ( norm _ axes is not None ) : DCNL DCSP DCSP sum _ over = tuple ( norm _ axes ) DCNL DCSP elif ( ndim = = 1 ) : DCNL DCSP DCSP sum _ over = ( ) DCNL DCSP elif ( ndim = = 2 ) : DCNL DCSP DCSP sum _ over = ( 0 , ) DCNL DCSP elif ( ndim in &#91; 3 , 4 , 5 &#93; ) : DCNL DCSP DCSP sum _ over = tuple ( range ( 1 , ndim ) ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Unsupported DCSP tensor DCSP dimensionality DCSP { } . DCSP Must DCSP specify DCSP `norm _ axes` &apos; .format ( array.ndim ) ) DCNL DCSP if isinstance ( array , theano.Variable ) : DCNL DCSP DCSP if ( len ( sum _ over ) = = 0 ) : DCNL DCSP DCSP DCSP norms = T.abs _ ( array ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP norms = T.sqrt ( T.sum ( ( array * * 2 ) , axis = sum _ over ) ) DCNL DCSP elif isinstance ( array , np.ndarray ) : DCNL DCSP DCSP if ( len ( sum _ over ) = = 0 ) : DCNL DCSP DCSP DCSP norms = abs ( array ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP norms = np.sqrt ( np.sum ( ( array * * 2 ) , axis = sum _ over ) ) DCNL DCSP return norms
DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP auth = current.auth DCNL DCSP response = current.response DCNL DCSP session = current.session DCNL DCSP settings = current.deployment _ settings DCNL DCSP s3 = response.s3 DCNL DCSP configure = s3db.configure DCNL DCSP set _ method = s3db.set _ method DCNL DCSP contacts _ tabs = settings.get _ pr _ contacts _ tabs ( ) DCNL DCSP if ( &apos; all &apos; in contacts _ tabs ) : DCNL DCSP DCSP set _ method ( &apos; pr &apos; , &apos; person &apos; , method = &apos; contacts &apos; , action = s3db.pr _ Contacts ) DCNL DCSP if ( &apos; public &apos; in contacts _ tabs ) : DCNL DCSP DCSP set _ method ( &apos; pr &apos; , &apos; person &apos; , method = &apos; public _ contacts &apos; , action = s3db.pr _ Contacts ) DCNL DCSP if ( &apos; private &apos; in contacts _ tabs ) : DCNL DCSP DCSP set _ method ( &apos; pr &apos; , &apos; person &apos; , method = &apos; private _ contacts &apos; , action = s3db.pr _ Contacts ) DCNL DCSP set _ method ( &apos; pr &apos; , &apos; person &apos; , method = &apos; cv &apos; , action = hrm _ CV ) DCNL DCSP set _ method ( &apos; pr &apos; , &apos; person &apos; , method = &apos; record &apos; , action = hrm _ Record ) DCNL DCSP if settings.has _ module ( &apos; asset &apos; ) : DCNL DCSP DCSP s3db.add _ components ( &apos; pr _ person &apos; , asset _ asset = &apos; assigned _ to _ id &apos; ) DCNL DCSP DCSP configure ( &apos; asset _ asset &apos; , deletable = False , editable = False , insertable = False ) DCNL DCSP get _ vars = current.request.get _ vars DCNL DCSP group = get _ vars.get ( &apos; group &apos; , &apos; staff &apos; ) DCNL DCSP hr _ id = get _ vars.get ( &apos; human _ resource.id &apos; , None ) DCNL DCSP if ( not str ( hr _ id ) .isdigit ( ) ) : DCNL DCSP DCSP hr _ id = None DCNL DCSP table = s3db.hrm _ human _ resource DCNL DCSP table.type.default = 1 DCNL DCSP get _ vars &#91; &apos; xsltmode &apos; &#93; = &apos; staff &apos; DCNL DCSP if hr _ id : DCNL DCSP DCSP hr = db ( ( table.id = = hr _ id ) ) .select ( table.type , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP if hr : DCNL DCSP DCSP DCSP group = ( ( ( hr.type = = 2 ) and &apos; volunteer &apos; ) or &apos; staff &apos; ) DCNL DCSP DCSP DCSP get _ vars &#91; &apos; group &apos; &#93; = group DCNL DCSP table = db.pr _ person DCNL DCSP tablename = &apos; pr _ person &apos; DCNL DCSP configure ( tablename , deletable = False ) DCNL DCSP mode = session.s3.hrm.mode DCNL DCSP if ( mode is not None ) : DCNL DCSP DCSP s3.crud _ strings &#91; tablename &#93; .update ( title _ display = T ( &apos; Personal DCSP Profile &apos; ) , title _ update = T ( &apos; Personal DCSP Profile &apos; ) ) DCNL DCSP DCSP configure ( &apos; hrm _ human _ resource &apos; , deletable = False , editable = False , insertable = False ) DCNL DCSP DCSP configure ( &apos; hrm _ certification &apos; , deletable = True , editable = True , insertable = True ) DCNL DCSP DCSP configure ( &apos; hrm _ credential &apos; , deletable = False , editable = False , insertable = False ) DCNL DCSP DCSP configure ( &apos; hrm _ competency &apos; , deletable = False , editable = False , insertable = True ) DCNL DCSP DCSP configure ( &apos; hrm _ training &apos; , deletable = False , editable = False , insertable = True ) DCNL DCSP DCSP configure ( &apos; hrm _ experience &apos; , deletable = False , editable = False , insertable = False ) DCNL DCSP DCSP configure ( &apos; pr _ group _ membership &apos; , deletable = False , editable = False , insertable = False ) DCNL DCSP elif ( settings.get _ hrm _ staff _ label ( ) = = T ( &apos; Contacts &apos; ) ) : DCNL DCSP DCSP s3.crud _ strings &#91; tablename &#93; .update ( title _ upload = T ( &apos; Import DCSP Contacts &apos; ) , title _ display = T ( &apos; Contact DCSP Details &apos; ) , title _ update = T ( &apos; Contact DCSP Details &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP s3.crud _ strings &#91; tablename &#93; .update ( title _ upload = T ( &apos; Import DCSP Staff &apos; ) , title _ display = T ( &apos; Staff DCSP Member DCSP Details &apos; ) , title _ update = T ( &apos; Staff DCSP Member DCSP Details &apos; ) ) DCNL DCSP s3.importerPrep = ( lambda : dict ( ReplaceOption = T ( &apos; Remove DCSP existing DCSP data DCSP before DCSP import &apos; ) ) ) DCNL DCSP def import _ prep ( data , group = group ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Deletes DCSP all DCSP HR DCSP records DCSP ( of DCSP the DCSP given DCSP group ) DCSP of DCSP the \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP organisation / branch DCSP before DCSP processing DCSP a DCSP new DCSP data DCSP import \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP ( resource , tree ) = data DCNL DCSP DCSP xml = current.xml DCNL DCSP DCSP tag = xml.TAG DCNL DCSP DCSP att = xml.ATTRIBUTE DCNL DCSP DCSP if s3.import _ replace : DCNL DCSP DCSP DCSP if ( tree is not None ) : DCNL DCSP DCSP DCSP DCSP if ( group = = &apos; staff &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP group = 1 DCNL DCSP DCSP DCSP DCSP elif ( group = = &apos; volunteer &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP group = 2 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP DCSP root = tree.getroot ( ) DCNL DCSP DCSP DCSP DCSP expr = ( &quot; / % s / % s &#91; @ % s = &apos; org _ organisation &apos; &#93; / % s &#91; @ % s = &apos; name &apos; &#93; &quot; % ( tag.root , tag.resource , att.name , tag.data , att.field ) ) DCNL DCSP DCSP DCSP DCSP orgs = root.xpath ( expr ) DCNL DCSP DCSP DCSP DCSP for org in orgs : DCNL DCSP DCSP DCSP DCSP DCSP org _ name = ( org.get ( &apos; value &apos; , None ) or org.text ) DCNL DCSP DCSP DCSP DCSP DCSP if org _ name : DCNL DCSP DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP org _ name = json.loads ( xml.xml _ decode ( org _ name ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP DCSP DCSP if org _ name : DCNL DCSP DCSP DCSP DCSP DCSP DCSP htable = s3db.hrm _ human _ resource DCNL DCSP DCSP DCSP DCSP DCSP DCSP otable = s3db.org _ organisation DCNL DCSP DCSP DCSP DCSP DCSP DCSP query = ( ( ( otable.name = = org _ name ) &amp; ( htable.organisation _ id = = otable.id ) ) &amp; ( htable.type = = group ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP resource = s3db.resource ( &apos; hrm _ human _ resource &apos; , filter = query ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP resource.delete ( format = &apos; xml &apos; , cascade = True ) DCNL DCSP s3.import _ prep = import _ prep DCNL DCSP def prep ( r ) : DCNL DCSP DCSP S3PersonRoleManager.set _ method ( r , entity = &apos; pr _ person &apos; ) DCNL DCSP DCSP if s3.rtl : DCNL DCSP DCSP DCSP f = s3db.pr _ phone _ contact.value DCNL DCSP DCSP DCSP f.represent = s3 _ phone _ represent DCNL DCSP DCSP DCSP f.widget = S3PhoneWidget ( ) DCNL DCSP DCSP method = r.method DCNL DCSP DCSP if ( r.representation = = &apos; s3json &apos; ) : DCNL DCSP DCSP DCSP current.xml.show _ ids = True DCNL DCSP DCSP elif ( r.interactive and ( method ! = &apos; import &apos; ) ) : DCNL DCSP DCSP DCSP if ( not r.component ) : DCNL DCSP DCSP DCSP DCSP table = r.table DCNL DCSP DCSP DCSP DCSP table.pe _ label.readable = table.pe _ label.writable = False DCNL DCSP DCSP DCSP DCSP table.missing.readable = table.missing.writable = False DCNL DCSP DCSP DCSP DCSP table.age _ group.readable = table.age _ group.writable = False DCNL DCSP DCSP DCSP DCSP dob = table.date _ of _ birth DCNL DCSP DCSP DCSP DCSP dob.widget = S3CalendarWidget ( past _ months = 1440 , future _ months = ( -60 ) ) DCNL DCSP DCSP DCSP DCSP person _ details _ table = s3db.pr _ person _ details DCNL DCSP DCSP DCSP DCSP person _ details _ table.occupation.readable = person _ details _ table.occupation.writable = False DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field = settings.set _ org _ dependent _ field DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person &apos; , &apos; middle _ name &apos; ) DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person _ details &apos; , &apos; father _ name &apos; ) DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person _ details &apos; , &apos; mother _ name &apos; ) DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person _ details &apos; , &apos; grandfather _ name &apos; ) DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person _ details &apos; , &apos; affiliations &apos; ) DCNL DCSP DCSP DCSP DCSP set _ org _ dependent _ field ( &apos; pr _ person _ details &apos; , &apos; company &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP component _ name = r.component _ name DCNL DCSP DCSP DCSP DCSP if ( component _ name = = &apos; physical _ description &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP table = r.component.table DCNL DCSP DCSP DCSP DCSP DCSP for field in table.fields : DCNL DCSP DCSP DCSP DCSP DCSP DCSP table &#91; field &#93; .writable = table &#91; field &#93; .readable = False DCNL DCSP DCSP DCSP DCSP DCSP table.ethnicity.writable = table.ethnicity.readable = True DCNL DCSP DCSP DCSP DCSP DCSP table.blood _ type.writable = table.blood _ type.readable = True DCNL DCSP DCSP DCSP DCSP DCSP table.medical _ conditions.writable = table.medical _ conditions.readable = True DCNL DCSP DCSP DCSP DCSP DCSP table.other _ details.writable = table.other _ details.readable = True DCNL DCSP DCSP DCSP DCSP elif ( component _ name = = &apos; appraisal &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP mission _ id = r.get _ vars.get ( &apos; mission _ id &apos; , None ) DCNL DCSP DCSP DCSP DCSP DCSP if mission _ id : DCNL DCSP DCSP DCSP DCSP DCSP DCSP hatable = r.component.table DCNL DCSP DCSP DCSP DCSP DCSP DCSP mtable = s3db.deploy _ mission DCNL DCSP DCSP DCSP DCSP DCSP DCSP mission = db ( ( mtable.id = = mission _ id ) ) .select ( mtable.code , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if mission : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP hatable.code.default = mission.code DCNL DCSP DCSP DCSP DCSP DCSP DCSP atable = db.deploy _ assignment DCNL DCSP DCSP DCSP DCSP DCSP DCSP htable = db.hrm _ human _ resource DCNL DCSP DCSP DCSP DCSP DCSP DCSP query = ( ( ( atable.mission _ id = = mission _ id ) &amp; ( atable.human _ resource _ id = = htable.id ) ) &amp; ( htable.person _ id = = r.id ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP assignment = db ( query ) .select ( atable.job _ title _ id , limitby = ( 0 , 1 ) ) .first ( ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if assignment : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP hatable.job _ title _ id.default = assignment.job _ title _ id DCNL DCSP DCSP DCSP DCSP elif ( component _ name = = &apos; asset &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP configure ( &apos; asset _ asset &apos; , insertable = False , editable = False , deletable = False ) DCNL DCSP DCSP DCSP DCSP elif ( component _ name = = &apos; group _ membership &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP hrm _ configure _ pr _ group _ membership ( ) DCNL DCSP DCSP DCSP DCSP elif ( component _ name = = &apos; salary &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP hrm _ configure _ salary ( r ) DCNL DCSP DCSP DCSP if ( ( method = = &apos; record &apos; ) or ( r.component _ name = = &apos; human _ resource &apos; ) ) : DCNL DCSP DCSP DCSP DCSP table = s3db.hrm _ human _ resource DCNL DCSP DCSP DCSP DCSP table.person _ id.writable = table.person _ id.readable = False DCNL DCSP DCSP DCSP DCSP table.site _ id.readable = table.site _ id.writable = True DCNL DCSP DCSP DCSP DCSP org = session.s3.hrm.org DCNL DCSP DCSP DCSP DCSP f = table.organisation _ id DCNL DCSP DCSP DCSP DCSP if ( org is None ) : DCNL DCSP DCSP DCSP DCSP DCSP f.widget = None DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP f.default = org DCNL DCSP DCSP DCSP DCSP DCSP f.readable = f.writable = False DCNL DCSP DCSP DCSP DCSP DCSP table.site _ id.requires = IS _ EMPTY _ OR ( IS _ ONE _ OF ( db , ( &apos; org _ site . % s &apos; % s3db.super _ key ( db.org _ site ) ) , s3db.org _ site _ represent , filterby = &apos; organisation _ id &apos; , filter _ opts = ( session.s3.hrm.org , ) ) ) DCNL DCSP DCSP DCSP elif ( ( method = = &apos; cv &apos; ) or ( r.component _ name = = &apos; training &apos; ) ) : DCNL DCSP DCSP DCSP DCSP list _ fields = &#91; &apos; course _ id &apos; , &apos; grade &apos; &#93; DCNL DCSP DCSP DCSP DCSP if settings.get _ hrm _ course _ pass _ marks : DCNL DCSP DCSP DCSP DCSP DCSP list _ fields.append ( &apos; grade _ details &apos; ) DCNL DCSP DCSP DCSP DCSP list _ fields.append ( &apos; date &apos; ) DCNL DCSP DCSP DCSP DCSP s3db.configure ( &apos; hrm _ training &apos; , list _ fields = list _ fields ) DCNL DCSP DCSP DCSP resource = r.resource DCNL DCSP DCSP DCSP if ( mode is not None ) : DCNL DCSP DCSP DCSP DCSP resource.build _ query ( id = auth.s3 _ logged _ in _ person ( ) ) DCNL DCSP DCSP DCSP elif ( method not in ( &apos; deduplicate &apos; , &apos; search _ ac &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if ( ( not r.id ) and ( not hr _ id ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if response.error : DCNL DCSP DCSP DCSP DCSP DCSP DCSP session.error = response.error DCNL DCSP DCSP DCSP DCSP DCSP redirect ( URL ( r = r , f = &apos; staff &apos; ) ) DCNL DCSP DCSP DCSP DCSP if ( resource.count ( ) = = 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP resource.load ( ) DCNL DCSP DCSP DCSP DCSP DCSP r.record = resource.records ( ) .first ( ) DCNL DCSP DCSP DCSP DCSP DCSP if r.record : DCNL DCSP DCSP DCSP DCSP DCSP DCSP r.id = r.record.id DCNL DCSP DCSP DCSP DCSP if ( not r.record ) : DCNL DCSP DCSP DCSP DCSP DCSP session.error = T ( &apos; Record DCSP not DCSP found &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP redirect ( URL ( f = &apos; staff &apos; ) ) DCNL DCSP DCSP DCSP DCSP if ( hr _ id and ( r.component _ name = = &apos; human _ resource &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP r.component _ id = hr _ id DCNL DCSP DCSP DCSP DCSP configure ( &apos; hrm _ human _ resource &apos; , insertable = False ) DCNL DCSP DCSP elif ( r.representation = = &apos; aadata &apos; ) : DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; group _ membership &apos; ) : DCNL DCSP DCSP DCSP DCSP hrm _ configure _ pr _ group _ membership ( ) DCNL DCSP DCSP DCSP elif ( ( method = = &apos; cv &apos; ) or ( r.component _ name = = &apos; training &apos; ) ) : DCNL DCSP DCSP DCSP DCSP list _ fields = &#91; &apos; course _ id &apos; , &apos; grade &apos; &#93; DCNL DCSP DCSP DCSP DCSP if settings.get _ hrm _ course _ pass _ marks : DCNL DCSP DCSP DCSP DCSP DCSP list _ fields.append ( &apos; grade _ details &apos; ) DCNL DCSP DCSP DCSP DCSP list _ fields.append ( &apos; date &apos; ) DCNL DCSP DCSP DCSP DCSP s3db.configure ( &apos; hrm _ training &apos; , list _ fields = list _ fields ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if ( r.interactive and r.component ) : DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; asset &apos; ) : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; add _ btn &apos; &#93; = A ( T ( &apos; Assign DCSP Asset &apos; ) , _ href = URL ( c = &apos; asset &apos; , f = &apos; asset &apos; ) , _ id = &apos; add-btn &apos; , _ class = &apos; action-btn &apos; ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if ( session.s3.hrm.orgname and ( mode is None ) ) : DCNL DCSP DCSP orgname = session.s3.hrm.orgname DCNL DCSP else : DCNL DCSP DCSP orgname = None DCNL DCSP _ attr = dict ( csv _ stylesheet = ( &apos; hrm &apos; , &apos; person.xsl &apos; ) , csv _ template = &apos; staff &apos; , csv _ extra _ fields = &#91; dict ( label = &apos; Type &apos; , field = s3db.hrm _ human _ resource.type ) &#93; , orgname = orgname , replace _ option = T ( &apos; Remove DCSP existing DCSP data DCSP before DCSP import &apos; ) , rheader = hrm _ rheader ) DCNL DCSP _ attr.update ( attr ) DCNL DCSP output = current.rest _ controller ( &apos; pr &apos; , &apos; person &apos; , * * _ attr ) DCNL DCSP return output
DCSP return _ execute _ with _ retries ( conn , &apos; describe _ stream &apos; , StreamName = stream _ name )
DCSP if ( not uri ) : DCNL DCSP DCSP raise exceptions.MpdNoExistError ( u &apos;No DCSP such DCSP song &apos; ) DCNL DCSP length = context.core.tracklist.get _ length ( ) DCNL DCSP if ( ( songpos is not None ) and ( songpos &gt; length.get ( ) ) ) : DCNL DCSP DCSP raise exceptions.MpdArgError ( u &apos;Bad DCSP song DCSP index &apos; ) DCNL DCSP tl _ tracks = context.core.tracklist.add ( uris = &#91; uri &#93; , at _ position = songpos ) .get ( ) DCNL DCSP if ( not tl _ tracks ) : DCNL DCSP DCSP raise exceptions.MpdNoExistError ( u &apos;No DCSP such DCSP song &apos; ) DCNL DCSP return ( u &apos;Id &apos; , tl _ tracks &#91; 0 &#93; .tlid )
DCSP indices = np.random.choice ( df.index , nrows , replace = replace ) DCNL DCSP sample = df.loc &#91; indices &#93; DCNL DCSP return sample
DCSP server = _ connect ( host , port , db , password ) DCNL DCSP return server.flushall ( )
DCSP common = osp.normpath ( osp.commonprefix ( pathlist ) ) DCNL DCSP if ( len ( common ) &gt; 1 ) : DCNL DCSP DCSP if ( not osp.isdir ( common ) ) : DCNL DCSP DCSP DCSP return abspardir ( common ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for path in pathlist : DCNL DCSP DCSP DCSP DCSP if ( not osp.isdir ( osp.join ( common , path &#91; ( len ( common ) + 1 ) : &#93; ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return abspardir ( common ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return osp.abspath ( common )
DCSP attrs = { } DCNL DCSP args = { } DCNL DCSP finder = _ getfinder ( ) DCNL DCSP args = { } DCNL DCSP attrs = { } DCNL DCSP aeobj _ 00 = aetypes.ObjectSpecifier ( want = aetypes.Type ( &apos; cfol &apos; ) , form = &apos; alis &apos; , seld = folder _ alias , fr = None ) DCNL DCSP aeobj _ 01 = aetypes.ObjectSpecifier ( want = aetypes.Type ( &apos; prop &apos; ) , form = &apos; prop &apos; , seld = aetypes.Type ( &apos; cwnd &apos; ) , fr = aeobj _ 00 ) DCNL DCSP aeobj _ 02 = aetypes.ObjectSpecifier ( want = aetypes.Type ( &apos; prop &apos; ) , form = &apos; prop &apos; , seld = aetypes.Type ( &apos; pvew &apos; ) , fr = aeobj _ 01 ) DCNL DCSP args &#91; &apos; ---- &apos; &#93; = aeobj _ 02 DCNL DCSP ( _ reply , args , attrs ) = finder.send ( &apos; core &apos; , &apos; getd &apos; , args , attrs ) DCNL DCSP if ( &apos; errn &apos; in args ) : DCNL DCSP DCSP raise Error , aetools.decodeerror ( args ) DCNL DCSP views = { &apos; iimg &apos; : 0 , &apos; pnam &apos; : 1 , &apos; lgbu &apos; : 2 } DCNL DCSP if ( &apos; ---- &apos; in args ) : DCNL DCSP DCSP return views &#91; args &#91; &apos; ---- &apos; &#93; .enum &#93;
DCSP result = defaultdict ( list ) DCNL DCSP backends _ defined = get _ backends ( ) DCNL DCSP for item in items : DCNL DCSP DCSP name = getattr ( item , &apos; provider &apos; , item ) DCNL DCSP DCSP backend = backends _ defined &#91; name &#93; DCNL DCSP DCSP if issubclass ( backend , OpenIdAuth ) : DCNL DCSP DCSP DCSP result &#91; &apos; openid &apos; &#93; .append ( item ) DCNL DCSP DCSP elif issubclass ( backend , BaseOAuth2 ) : DCNL DCSP DCSP DCSP result &#91; &apos; oauth2 &apos; &#93; .append ( item ) DCNL DCSP DCSP elif issubclass ( backend , BaseOAuth1 ) : DCNL DCSP DCSP DCSP result &#91; &apos; oauth &apos; &#93; .append ( item ) DCNL DCSP return dict ( result )
DCSP a = ( Angle ( 350 , u.deg ) + Angle ( 350 , u.deg ) ) DCNL DCSP a.to _ string ( ) DCNL DCSP a.to _ string ( u.hourangle ) DCNL DCSP repr ( a ) DCNL DCSP repr ( a.to ( u.hourangle ) ) DCNL DCSP str ( a ) DCNL DCSP str ( a.to ( u.hourangle ) )
DCSP seq _ lens = defaultdict ( int ) DCNL DCSP input _ fasta _ f = open ( input _ fasta _ fp , &apos; U &apos; ) DCNL DCSP for ( label , seq ) in parse _ fasta ( input _ fasta _ f ) : DCNL DCSP DCSP seq _ lens &#91; len ( seq ) &#93; + = 1 DCNL DCSP input _ fasta _ f.close ( ) DCNL DCSP formatted _ seq _ lens = &#91; &#93; DCNL DCSP for curr _ key in seq _ lens : DCNL DCSP DCSP formatted _ seq _ lens.append ( ( seq _ lens &#91; curr _ key &#93; , curr _ key ) ) DCNL DCSP formatted _ seq _ lens.sort ( reverse = True ) DCNL DCSP return formatted _ seq _ lens
DCSP if ( encoding is None ) : DCNL DCSP DCSP encoding = DEFAULT _ ENCODING DCNL DCSP chunks = &#91; &#93; DCNL DCSP _ append = chunks.append DCNL DCSP begin = ( end - 1 ) DCNL DCSP while 1 : DCNL DCSP DCSP chunk = _ m ( s , end ) DCNL DCSP DCSP if ( chunk is None ) : DCNL DCSP DCSP DCSP raise JSONDecodeError ( &apos; Unterminated DCSP string DCSP starting DCSP at &apos; , s , begin ) DCNL DCSP DCSP end = chunk.end ( ) DCNL DCSP DCSP ( content , terminator ) = chunk.groups ( ) DCNL DCSP DCSP if content : DCNL DCSP DCSP DCSP if ( not isinstance ( content , unicode ) ) : DCNL DCSP DCSP DCSP DCSP content = unicode ( content , encoding ) DCNL DCSP DCSP DCSP _ append ( content ) DCNL DCSP DCSP if ( terminator = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP elif ( terminator ! = &apos; \ \ &apos; ) : DCNL DCSP DCSP DCSP if strict : DCNL DCSP DCSP DCSP DCSP msg = ( &apos; Invalid DCSP control DCSP character DCSP % r DCSP at &apos; % ( terminator , ) ) DCNL DCSP DCSP DCSP DCSP raise JSONDecodeError ( msg , s , end ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP _ append ( terminator ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP esc = s &#91; end &#93; DCNL DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP raise JSONDecodeError ( &apos; Unterminated DCSP string DCSP starting DCSP at &apos; , s , begin ) DCNL DCSP DCSP if ( esc ! = &apos; u &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP char = _ b &#91; esc &#93; DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP msg = ( &apos; Invalid DCSP \ \ escape : DCSP &apos; + repr ( esc ) ) DCNL DCSP DCSP DCSP DCSP raise JSONDecodeError ( msg , s , end ) DCNL DCSP DCSP DCSP end + = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP esc = s &#91; ( end + 1 ) : ( end + 5 ) &#93; DCNL DCSP DCSP DCSP next _ end = ( end + 5 ) DCNL DCSP DCSP DCSP if ( len ( esc ) ! = 4 ) : DCNL DCSP DCSP DCSP DCSP msg = &apos; Invalid DCSP \ \ uXXXX DCSP escape &apos; DCNL DCSP DCSP DCSP DCSP raise JSONDecodeError ( msg , s , end ) DCNL DCSP DCSP DCSP uni = int ( esc , 16 ) DCNL DCSP DCSP DCSP if ( ( 55296 &lt; = uni &lt; = 56319 ) and ( sys.maxunicode &gt; 65535 ) ) : DCNL DCSP DCSP DCSP DCSP msg = &apos; Invalid DCSP \ \ uXXXX \ \ uXXXX DCSP surrogate DCSP pair &apos; DCNL DCSP DCSP DCSP DCSP if ( not ( s &#91; ( end + 5 ) : ( end + 7 ) &#93; = = &apos; \ \ u &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise JSONDecodeError ( msg , s , end ) DCNL DCSP DCSP DCSP DCSP esc2 = s &#91; ( end + 7 ) : ( end + 11 ) &#93; DCNL DCSP DCSP DCSP DCSP if ( len ( esc2 ) ! = 4 ) : DCNL DCSP DCSP DCSP DCSP DCSP raise JSONDecodeError ( msg , s , end ) DCNL DCSP DCSP DCSP DCSP uni2 = int ( esc2 , 16 ) DCNL DCSP DCSP DCSP DCSP uni = ( 65536 + ( ( ( uni - 55296 ) &lt; &lt; 10 ) &#124; ( uni2 - 56320 ) ) ) DCNL DCSP DCSP DCSP DCSP next _ end + = 6 DCNL DCSP DCSP DCSP char = unichr ( uni ) DCNL DCSP DCSP DCSP end = next _ end DCNL DCSP DCSP _ append ( char ) DCNL DCSP return ( u &apos; &apos; .join ( chunks ) , end )
DCSP hN = ( N / 2 ) DCNL DCSP hM1 = int ( math.floor ( ( ( w.size + 1 ) / 2 ) ) ) DCNL DCSP hM2 = int ( math.floor ( ( w.size / 2 ) ) ) DCNL DCSP x = np.append ( np.zeros ( hM2 ) , x ) DCNL DCSP x = np.append ( x , np.zeros ( hM1 ) ) DCNL DCSP Ns = 512 DCNL DCSP H = ( Ns / 4 ) DCNL DCSP hNs = ( Ns / 2 ) DCNL DCSP pin = max ( hNs , hM1 ) DCNL DCSP pend = ( x.size - max ( hNs , hM1 ) ) DCNL DCSP fftbuffer = np.zeros ( N ) DCNL DCSP yh = np.zeros ( Ns ) DCNL DCSP y = np.zeros ( x.size ) DCNL DCSP w = ( w / sum ( w ) ) DCNL DCSP sw = np.zeros ( Ns ) DCNL DCSP ow = triang ( ( 2 * H ) ) DCNL DCSP sw &#91; ( hNs - H ) : ( hNs + H ) &#93; = ow DCNL DCSP bh = blackmanharris ( Ns ) DCNL DCSP bh = ( bh / sum ( bh ) ) DCNL DCSP sw &#91; ( hNs - H ) : ( hNs + H ) &#93; = ( sw &#91; ( hNs - H ) : ( hNs + H ) &#93; / bh &#91; ( hNs - H ) : ( hNs + H ) &#93; ) DCNL DCSP hfreqp = &#91; &#93; DCNL DCSP f0t = 0 DCNL DCSP f0stable = 0 DCNL DCSP while ( pin &lt; pend ) : DCNL DCSP DCSP x1 = x &#91; ( pin - hM1 ) : ( pin + hM2 ) &#93; DCNL DCSP DCSP ( mX , pX ) = DFT.dftAnal ( x1 , w , N ) DCNL DCSP DCSP ploc = UF.peakDetection ( mX , t ) DCNL DCSP DCSP ( iploc , ipmag , ipphase ) = UF.peakInterp ( mX , pX , ploc ) DCNL DCSP DCSP ipfreq = ( ( fs * iploc ) / N ) DCNL DCSP DCSP f0t = UF.f0Twm ( ipfreq , ipmag , f0et , minf0 , maxf0 , f0stable ) DCNL DCSP DCSP if ( ( ( f0stable = = 0 ) &amp; ( f0t &gt; 0 ) ) or ( ( f0stable &gt; 0 ) &amp; ( np.abs ( ( f0stable - f0t ) ) &lt; ( f0stable / 5.0 ) ) ) ) : DCNL DCSP DCSP DCSP f0stable = f0t DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f0stable = 0 DCNL DCSP DCSP ( hfreq , hmag , hphase ) = harmonicDetection ( ipfreq , ipmag , ipphase , f0t , nH , hfreqp , fs ) DCNL DCSP DCSP hfreqp = hfreq DCNL DCSP DCSP Yh = UF.genSpecSines ( hfreq , hmag , hphase , Ns , fs ) DCNL DCSP DCSP fftbuffer = np.real ( ifft ( Yh ) ) DCNL DCSP DCSP yh &#91; : ( hNs - 1 ) &#93; = fftbuffer &#91; ( hNs + 1 ) : &#93; DCNL DCSP DCSP yh &#91; ( hNs - 1 ) : &#93; = fftbuffer &#91; : ( hNs + 1 ) &#93; DCNL DCSP DCSP y &#91; ( pin - hNs ) : ( pin + hNs ) &#93; + = ( sw * yh ) DCNL DCSP DCSP pin + = H DCNL DCSP y = np.delete ( y , range ( hM2 ) ) DCNL DCSP y = np.delete ( y , range ( ( y.size - hM1 ) , y.size ) ) DCNL DCSP return y
DCSP for unit in ( Byte , MB , MiB , GB , GiB ) : DCNL DCSP DCSP for size in ( 1 , 2 , 4 , 8 ) : DCNL DCSP DCSP DCSP test _ case = make _ allocated _ size _ tests ( unit ( size ) ) DCNL DCSP DCSP DCSP globals ( ) &#91; test _ case . _ _ name _ _ &#93; = test _ case
DCSP return rv ( name , GammaDistribution , ( k , theta ) )
DCSP key = ( host , port ) DCNL DCSP if _ wsgi _ intercept.has _ key ( key ) : DCNL DCSP DCSP del _ wsgi _ intercept &#91; key &#93;
DCSP TraversalSpec = vmodl.query.PropertyCollector.TraversalSpec DCNL DCSP SelectionSpec = vmodl.query.PropertyCollector.SelectionSpec DCNL DCSP rpToRp = TraversalSpec ( name = &apos; rpToRp &apos; , type = vim.ResourcePool , path = &apos; resourcePool &apos; , skip = False ) DCNL DCSP rpToRp.selectSet.extend ( ( SelectionSpec ( name = &apos; rpToRp &apos; ) , SelectionSpec ( name = &apos; rpToVm &apos; ) ) ) DCNL DCSP rpToVm = TraversalSpec ( name = &apos; rpToVm &apos; , type = vim.ResourcePool , path = &apos; vm &apos; , skip = False ) DCNL DCSP crToRp = TraversalSpec ( name = &apos; crToRp &apos; , type = vim.ComputeResource , path = &apos; resourcePool &apos; , skip = False ) DCNL DCSP crToRp.selectSet.extend ( ( SelectionSpec ( name = &apos; rpToRp &apos; ) , SelectionSpec ( name = &apos; rpToVm &apos; ) ) ) DCNL DCSP crToH = TraversalSpec ( name = &apos; crToH &apos; , type = vim.ComputeResource , path = &apos; host &apos; , skip = False ) DCNL DCSP dcToHf = TraversalSpec ( name = &apos; dcToHf &apos; , type = vim.Datacenter , path = &apos; hostFolder &apos; , skip = False ) DCNL DCSP dcToHf.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , ) ) DCNL DCSP dcToVmf = TraversalSpec ( name = &apos; dcToVmf &apos; , type = vim.Datacenter , path = &apos; vmFolder &apos; , skip = False ) DCNL DCSP dcToVmf.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , ) ) DCNL DCSP dcToNet = TraversalSpec ( name = &apos; dcToNet &apos; , type = vim.Datacenter , path = &apos; networkFolder &apos; , skip = False ) DCNL DCSP dcToNet.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , ) ) DCNL DCSP dcToDs = TraversalSpec ( name = &apos; dcToDs &apos; , type = vim.Datacenter , path = &apos; datastore &apos; , skip = False ) DCNL DCSP dcToDs.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , ) ) DCNL DCSP hToVm = TraversalSpec ( name = &apos; hToVm &apos; , type = vim.HostSystem , path = &apos; vm &apos; , skip = False ) DCNL DCSP hToVm.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , ) ) DCNL DCSP visitFolders = TraversalSpec ( name = &apos; visitFolders &apos; , type = vim.Folder , path = &apos; childEntity &apos; , skip = False ) DCNL DCSP visitFolders.selectSet.extend ( ( SelectionSpec ( name = &apos; visitFolders &apos; ) , SelectionSpec ( name = &apos; dcToHf &apos; ) , SelectionSpec ( name = &apos; dcToVmf &apos; ) , SelectionSpec ( name = &apos; dcToNet &apos; ) , SelectionSpec ( name = &apos; crToH &apos; ) , SelectionSpec ( name = &apos; crToRp &apos; ) , SelectionSpec ( name = &apos; dcToDs &apos; ) , SelectionSpec ( name = &apos; hToVm &apos; ) , SelectionSpec ( name = &apos; rpToVm &apos; ) ) ) DCNL DCSP fullTraversal = SelectionSpec.Array ( ( visitFolders , dcToHf , dcToVmf , dcToNet , crToH , crToRp , dcToDs , rpToRp , hToVm , rpToVm ) ) DCNL DCSP return fullTraversal
DCSP cmdline = cmdline.encode ( &apos; ascii &apos; ) DCNL DCSP logging.info ( ( &quot; Running DCSP cmd DCSP &apos; % s &apos; &quot; % cmdline ) ) DCNL DCSP kwargs = { } DCNL DCSP kwargs &#91; &apos; stdout &apos; &#93; = ( ( stdout and subprocess.PIPE ) or None ) DCNL DCSP kwargs &#91; &apos; stderr &apos; &#93; = ( ( stderr and subprocess.PIPE ) or None ) DCNL DCSP kwargs &#91; &apos; stdin &apos; &#93; = ( ( stdin and subprocess.PIPE ) or None ) DCNL DCSP kwargs &#91; &apos; universal _ newlines &apos; &#93; = universal _ newlines DCNL DCSP args = shlex.split ( cmdline ) DCNL DCSP logging.info ( ( &quot; Running DCSP args DCSP &apos; % s &apos; &quot; % args ) ) DCNL DCSP proc = subprocess.Popen ( args , * * kwargs ) DCNL DCSP return proc
DCSP if salt.utils.is _ windows ( ) : DCNL DCSP DCSP return _ _ virtualname _ _ DCNL DCSP return ( False , &apos; Module DCSP cyg : DCSP module DCSP only DCSP works DCSP on DCSP Windows DCSP systems . &apos; )
DCSP addHandler ( logging.StreamHandler ( stream = sys.stdout ) )
DCSP action = &apos; snapshot &apos; DCNL DCSP action _ class = CLASS _ MAP &#91; action &#93; DCNL DCSP c _ args = ctx.obj &#91; &apos; config &apos; &#93; &#91; &apos; client &apos; &#93; DCNL DCSP client = get _ client ( * * c _ args ) DCNL DCSP logger = logging.getLogger ( _ _ name _ _ ) DCNL DCSP raw _ options = { &apos; repository &apos; : repository , &apos; name &apos; : name , &apos; ignore _ unavailable &apos; : ignore _ unavailable , &apos; include _ global _ state &apos; : include _ global _ state , &apos; partial &apos; : partial , &apos; skip _ repo _ fs _ check &apos; : skip _ repo _ fs _ check , &apos; wait _ for _ completion &apos; : wait _ for _ completion } DCNL DCSP logger.debug ( &apos; Validating DCSP provided DCSP options : DCSP { 0 } &apos; .format ( raw _ options ) ) DCNL DCSP mykwargs = option _ schema _ check ( action , raw _ options ) DCNL DCSP logger.debug ( &apos; Validating DCSP provided DCSP filters : DCSP { 0 } &apos; .format ( filter _ list ) ) DCNL DCSP clean _ filters = { &apos; filters &apos; : filter _ schema _ check ( action , filter _ list ) } DCNL DCSP ilo = IndexList ( client ) DCNL DCSP _ do _ filters ( ilo , clean _ filters , ignore _ empty _ list ) DCNL DCSP action _ obj = action _ class ( ilo , * * mykwargs ) DCNL DCSP _ actionator ( action , action _ obj , dry _ run = ctx.parent.params &#91; &apos; dry _ run &apos; &#93; )
DCSP add _ message ( request , constants.INFO , message , extra _ tags = extra _ tags , fail _ silently = fail _ silently )
DCSP base _ param ( registry , xml _ parent , data , True , &apos; hudson.model.StringParameterDefinition &apos; )
DCSP ( type , subtype , params ) = parse _ mime _ type ( range ) DCNL DCSP if ( ( not params.has _ key ( &apos; q &apos; ) ) or ( not params &#91; &apos; q &apos; &#93; ) or ( not float ( params &#91; &apos; q &apos; &#93; ) ) or ( float ( params &#91; &apos; q &apos; &#93; ) &gt; 1 ) or ( float ( params &#91; &apos; q &apos; &#93; ) &lt; 0 ) ) : DCNL DCSP DCSP params &#91; &apos; q &apos; &#93; = &apos; 1&apos; DCNL DCSP return ( type , subtype , params )
DCSP isfile = os.path.isfile DCNL DCSP if isfile ( filename ) : DCNL DCSP DCSP return filename DCNL DCSP orig = copy.copy ( filename ) DCNL DCSP extensions = ( &apos; .jpg &apos; , &apos; .png &apos; , &apos; .tif &apos; , &apos; .bmp &apos; , &apos; .gif &apos; , &apos; .jpeg &apos; , &apos; .tiff &apos; ) DCNL DCSP def logCorrected ( orig , actual ) : DCNL DCSP DCSP logging.warn ( &apos; Requested DCSP image DCSP { ! r } DCSP not DCSP found DCSP but DCSP similar DCSP filename DCSP { ! r } DCSP exists . DCSP This DCSP will DCSP be DCSP used DCSP instead DCSP but DCSP changing DCSP the DCSP filename DCSP is DCSP advised . &apos; .format ( orig , actual ) ) DCNL DCSP if filename.endswith ( extensions ) : DCNL DCSP DCSP filename = os.path.splitext ( orig ) &#91; 0 &#93; DCNL DCSP if isfile ( filename ) : DCNL DCSP DCSP logCorrected ( orig , filename ) DCNL DCSP DCSP return filename DCNL DCSP for ext in extensions : DCNL DCSP DCSP if isfile ( ( filename + ext ) ) : DCNL DCSP DCSP DCSP filename + = ext DCNL DCSP DCSP DCSP logCorrected ( orig , filename ) DCNL DCSP DCSP DCSP return filename
DCSP tmp = _ asfarray ( x ) DCNL DCSP if ( not numpy.isrealobj ( tmp ) ) : DCNL DCSP DCSP raise TypeError ( &apos; 1st DCSP argument DCSP must DCSP be DCSP real DCSP sequence &apos; ) DCNL DCSP try : DCNL DCSP DCSP work _ function = _ DTYPE _ TO _ RFFT &#91; tmp.dtype &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise ValueError ( ( &apos; type DCSP % s DCSP is DCSP not DCSP supported &apos; % tmp.dtype ) ) DCNL DCSP overwrite _ x = ( overwrite _ x or _ datacopied ( tmp , x ) ) DCNL DCSP return _ raw _ fft ( tmp , n , axis , 1 , overwrite _ x , work _ function )
DCSP def check _ login ( self , * args , * * kwargs ) : DCNL DCSP DCSP if ( self.request.method ! = &apos; GET &apos; ) : DCNL DCSP DCSP DCSP self.abort ( 400 , detail = &apos; The DCSP login _ required DCSP decorator DCSP can DCSP only DCSP be DCSP used DCSP for DCSP GET DCSP requests . &apos; ) DCNL DCSP DCSP user = users.get _ current _ user ( ) DCNL DCSP DCSP if ( not user ) : DCNL DCSP DCSP DCSP return self.redirect ( users.create _ login _ url ( self.request.url ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP handler _ method ( self , * args , * * kwargs ) DCNL DCSP return check _ login
DCSP global FORMAT _ WRITERS DCNL DCSP if ( FORMAT _ WRITERS is None ) : DCNL DCSP DCSP _ import _ writers ( ) DCNL DCSP return FORMAT _ WRITERS.get ( extension , None )
DCSP results = { } DCNL DCSP for integrator in &#91; &apos; dopri5 &apos; , &apos; dop853 &apos; , &apos; vode &apos; , &apos; lsoda &apos; &#93; : DCNL DCSP DCSP discrete _ soln = model.solve ( t0 , k0 , h = 1.0 , g = g , tol = tol , integrator = integrator , atol = 1e-14 , rtol = 1e-11 ) DCNL DCSP DCSP results &#91; integrator &#93; = discrete _ soln DCNL DCSP return results
DCSP def step ( ctxt , ndx , value ) : DCNL DCSP DCSP if ( value is not None ) : DCNL DCSP DCSP DCSP ctxt &#91; ndx &#93; = value DCNL DCSP def finalize ( ctxt ) : DCNL DCSP DCSP if ( len ( ctxt ) = = 0 ) : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP return sep.join ( map ( ctxt.get , sorted ( ctxt.iterkeys ( ) ) ) ) DCNL DCSP return ( { } , step , finalize )
DCSP headers = { } DCNL DCSP if accept _ encoding : DCNL DCSP DCSP if isinstance ( accept _ encoding , str ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP elif isinstance ( accept _ encoding , list ) : DCNL DCSP DCSP DCSP accept _ encoding = &apos; , &apos; .join ( accept _ encoding ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP accept _ encoding = &apos; gzip , deflate &apos; DCNL DCSP DCSP headers &#91; &apos; accept-encoding &apos; &#93; = accept _ encoding DCNL DCSP if user _ agent : DCNL DCSP DCSP headers &#91; &apos; user-agent &apos; &#93; = user _ agent DCNL DCSP if keep _ alive : DCNL DCSP DCSP headers &#91; &apos; connection &apos; &#93; = &apos; keep-alive &apos; DCNL DCSP if basic _ auth : DCNL DCSP DCSP headers &#91; &apos; authorization &apos; &#93; = ( &apos; Basic DCSP &apos; + b64encode ( six.b ( basic _ auth ) ) .decode ( &apos; utf-8 &apos; ) ) DCNL DCSP if proxy _ basic _ auth : DCNL DCSP DCSP headers &#91; &apos; proxy-authorization &apos; &#93; = ( &apos; Basic DCSP &apos; + b64encode ( six.b ( proxy _ basic _ auth ) ) .decode ( &apos; utf-8 &apos; ) ) DCNL DCSP return headers
DCSP def take ( seq , n ) : DCNL DCSP DCSP for i in xrange ( n ) : DCNL DCSP DCSP DCSP ( yield seq.next ( ) ) DCNL DCSP if ( not hasattr ( seq , &apos; next &apos; ) ) : DCNL DCSP DCSP seq = iter ( seq ) DCNL DCSP while True : DCNL DCSP DCSP x = list ( take ( seq , size ) ) DCNL DCSP DCSP if x : DCNL DCSP DCSP DCSP ( yield x ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break
DCSP if ( name.lower ( ) in LOGGER _ SENSITIVE _ HEADERS ) : DCNL DCSP DCSP prefix _ length = logger _ settings.get ( &apos; reveal _ sensitive _ prefix &apos; , 16 ) DCNL DCSP DCSP prefix _ length = int ( min ( prefix _ length , ( ( len ( value ) * * 2 ) / 32 ) , ( len ( value ) / 2 ) ) ) DCNL DCSP DCSP redacted _ value = value &#91; 0 : prefix _ length &#93; DCNL DCSP DCSP return ( redacted _ value + &apos; ... &apos; ) DCNL DCSP return value
DCSP if ( sys.version _ info.major &lt; 3 ) : DCNL DCSP DCSP if isinstance ( string , unicode ) : DCNL DCSP DCSP DCSP string = string.encode ( u &apos;utf8 &apos; ) DCNL DCSP DCSP string = urllib.quote ( string , safe.encode ( u &apos;utf8 &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP string = urllib.parse.quote ( str ( string ) , safe ) DCNL DCSP return string
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( not conn ) : DCNL DCSP DCSP return False DCNL DCSP try : DCNL DCSP DCSP conn.delete _ cache _ subnet _ group ( name ) DCNL DCSP DCSP msg = &apos; Deleted DCSP ElastiCache DCSP subnet DCSP group DCSP { 0 } . &apos; .format ( name ) DCNL DCSP DCSP log.info ( msg ) DCNL DCSP DCSP return True DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP delete DCSP ElastiCache DCSP subnet DCSP group DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP log.error ( msg ) DCNL DCSP DCSP return False
DCSP if ( SETTINGS.env _ name is not None ) : DCNL DCSP DCSP return ( SETTINGS.env _ name = = &apos; GCE _ PRODUCTION &apos; ) DCNL DCSP if ( ( NO _ GCE _ CHECK ! = &apos; True &apos; ) and _ detect _ gce _ environment ( ) ) : DCNL DCSP DCSP SETTINGS.env _ name = &apos; GCE _ PRODUCTION &apos; DCNL DCSP DCSP return True DCNL DCSP return False
DCSP old = vm.logfile DCNL DCSP if ( old = = stdout ) : DCNL DCSP DCSP log ( &apos; * DCSP Temporarily DCSP disabling DCSP logging DCSP to DCSP stdout &apos; ) DCNL DCSP DCSP vm.logfile = None DCNL DCSP log ( &apos; * DCSP Switching DCSP to DCSP interactive DCSP use DCSP - DCSP press DCSP control- &#93; DCSP to DCSP exit &apos; ) DCNL DCSP vm.interact ( ) DCNL DCSP if ( old = = stdout ) : DCNL DCSP DCSP log ( &apos; * DCSP Restoring DCSP logging DCSP to DCSP stdout &apos; ) DCNL DCSP DCSP vm.logfile = stdout
DCSP if ( ( a = = datashape.var ) or ( b = = datashape.var ) ) : DCNL DCSP DCSP return datashape.var DCNL DCSP if isinstance ( a , Fixed ) : DCNL DCSP DCSP a = int ( a ) DCNL DCSP if isinstance ( b , Fixed ) : DCNL DCSP DCSP b = int ( b ) DCNL DCSP return int ( ( a * b ) )
DCSP time _ micros = dts . _ get _ time _ micros ( ) DCNL DCSP start _ micros = _ time _ to _ micros ( start ) DCNL DCSP end _ micros = _ time _ to _ micros ( end ) DCNL DCSP ( left _ op , right _ op , join _ op ) = _ opmap &#91; ( bool ( include _ start ) , bool ( include _ end ) , ( start _ micros &lt; = end _ micros ) ) &#93; DCNL DCSP return join _ op ( left _ op ( start _ micros , time _ micros ) , right _ op ( time _ micros , end _ micros ) )
DCSP xk = np.atleast _ 1d ( xk ) DCNL DCSP fc = &#91; 0 &#93; DCNL DCSP def phi ( alpha1 ) : DCNL DCSP DCSP fc &#91; 0 &#93; + = 1 DCNL DCSP DCSP return f ( ( xk + ( alpha1 * pk ) ) , * args ) DCNL DCSP if ( old _ fval is None ) : DCNL DCSP DCSP phi0 = phi ( 0.0 ) DCNL DCSP else : DCNL DCSP DCSP phi0 = old _ fval DCNL DCSP derphi0 = np.dot ( gfk , pk ) DCNL DCSP ( alpha , phi1 ) = scalar _ search _ armijo ( phi , phi0 , derphi0 , c1 = c1 , alpha0 = alpha0 ) DCNL DCSP return ( alpha , fc &#91; 0 &#93; , phi1 )
DCSP java _ args = { } DCNL DCSP java _ args &#91; &apos; compile _ dir &apos; &#93; = _ TMP _ COMPILE _ DIR DCNL DCSP java _ args &#91; &apos; app _ dir &apos; &#93; = _ DEFAULT _ APP _ DIR DCNL DCSP java _ args &#91; &apos; gwt _ dir &apos; &#93; = find _ gwt _ dir ( ) DCNL DCSP java _ args &#91; &apos; extra _ args &apos; &#93; = extra _ args DCNL DCSP java _ args &#91; &apos; project _ client &apos; &#93; = project _ client DCNL DCSP cmd = ( _ COMPILE _ LINE % java _ args ) DCNL DCSP logging.info ( &apos; Compiling DCSP client DCSP % s &apos; , project _ client ) DCNL DCSP try : DCNL DCSP DCSP utils.run ( cmd , verbose = True ) DCNL DCSP DCSP if install _ client : DCNL DCSP DCSP DCSP return install _ completed _ client ( java _ args &#91; &apos; compile _ dir &apos; &#93; , project _ client ) DCNL DCSP DCSP return True DCNL DCSP except error.CmdError : DCNL DCSP DCSP logging.info ( &apos; Error DCSP compiling DCSP % s , DCSP leaving DCSP old DCSP client &apos; , project _ client ) DCNL DCSP return False
DCSP params = ( &#91; &#93; if ( params is None ) else params ) DCNL DCSP extra = ( &#91; &apos; command = { 0 } &apos; .format ( command ) &#93; + params ) DCNL DCSP url = _ format _ url ( &apos; replication &apos; , host = host , core _ name = core _ name , extra = extra ) DCNL DCSP return _ http _ request ( url )
DCSP return option _ list &#91; option &#93;
DCSP if ( threadingmodule is not None ) : DCNL DCSP DCSP for klass in klasses : DCNL DCSP DCSP DCSP for methodName in klass.synchronized : DCNL DCSP DCSP DCSP DCSP sync = _ sync ( klass , klass . _ _ dict _ _ &#91; methodName &#93; ) DCNL DCSP DCSP DCSP DCSP setattr ( klass , methodName , sync )
DCSP if ( not salt.utils.is _ windows ( ) ) : DCNL DCSP DCSP return ( False , u &apos;Module DCSP PSGet : DCSP Module DCSP only DCSP works DCSP on DCSP Windows DCSP systems &apos; ) DCNL DCSP powershell _ info = _ _ salt _ _ &#91; u &apos;cmd.shell _ info &apos; &#93; ( u &apos;powershell &apos; ) DCNL DCSP if ( ( not powershell _ info &#91; u &apos;installed &apos; &#93; ) or ( distutils.version.StrictVersion ( powershell _ info &#91; u &apos;version &apos; &#93; ) &gt; = distutils.version.StrictVersion ( u &apos; 5.0 &apos; ) ) ) : DCNL DCSP DCSP return ( False , u &apos;Module DCSP DSC : DCSP Module DCSP only DCSP works DCSP with DCSP PowerShell DCSP 5 DCSP or DCSP newer . &apos; ) DCNL DCSP return _ _ virtualname _ _
DCSP if include _ headers : DCNL DCSP DCSP include _ headers = tuple ( ( to _ bytes ( h.lower ( ) ) for h in sorted ( include _ headers ) ) ) DCNL DCSP cache = _ fingerprint _ cache.setdefault ( request , { } ) DCNL DCSP if ( include _ headers not in cache ) : DCNL DCSP DCSP fp = hashlib.sha1 ( ) DCNL DCSP DCSP fp.update ( to _ bytes ( request.method ) ) DCNL DCSP DCSP fp.update ( to _ bytes ( canonicalize _ url ( request.url ) ) ) DCNL DCSP DCSP fp.update ( ( request.body or &apos; &apos; ) ) DCNL DCSP DCSP if include _ headers : DCNL DCSP DCSP DCSP for hdr in include _ headers : DCNL DCSP DCSP DCSP DCSP if ( hdr in request.headers ) : DCNL DCSP DCSP DCSP DCSP DCSP fp.update ( hdr ) DCNL DCSP DCSP DCSP DCSP DCSP for v in request.headers.getlist ( hdr ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP fp.update ( v ) DCNL DCSP DCSP cache &#91; include _ headers &#93; = fp.hexdigest ( ) DCNL DCSP return cache &#91; include _ headers &#93;
DCSP parsed = &#91; &#93; DCNL DCSP while ( tokens.current ( ) is not None ) : DCNL DCSP DCSP if ( tokens.current ( ) = = &apos; -- &apos; ) : DCNL DCSP DCSP DCSP return ( parsed + &#91; Argument ( None , v ) for v in tokens &#93; ) DCNL DCSP DCSP elif tokens.current ( ) .startswith ( &apos; -- &apos; ) : DCNL DCSP DCSP DCSP parsed + = parse _ long ( tokens , options ) DCNL DCSP DCSP elif ( tokens.current ( ) .startswith ( &apos; -&apos; ) and ( tokens.current ( ) ! = &apos; -&apos; ) ) : DCNL DCSP DCSP DCSP parsed + = parse _ shorts ( tokens , options ) DCNL DCSP DCSP elif options _ first : DCNL DCSP DCSP DCSP return ( parsed + &#91; Argument ( None , v ) for v in tokens &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP parsed.append ( Argument ( None , tokens.move ( ) ) ) DCNL DCSP return parsed
DCSP namespaced _ key = &apos; .&apos;.join ( &#91; namespace , key &#93; ) DCNL DCSP return namespaced _ key
DCSP args = _ parse _ args ( ) DCNL DCSP if ( args.pkl is not None ) : DCNL DCSP DCSP dataset = serial.load ( args.pkl ) DCNL DCSP else : DCNL DCSP DCSP dataset = NORB ( args.which _ norb , args.which _ set ) DCNL DCSP grid _ indices = ( &#91; 0 &#93; * 5 ) DCNL DCSP grid _ to _ short _ label = _ make _ grid _ to _ short _ label ( dataset ) DCNL DCSP label _ to _ row _ indices = _ make _ label _ to _ row _ indices ( dataset.y ) DCNL DCSP object _ image _ index = &#91; 0 &#93; DCNL DCSP blank _ image _ index = &#91; 0 &#93; DCNL DCSP blank _ label = _ get _ blank _ label ( dataset ) DCNL DCSP grid _ dimension = &#91; 0 &#93; DCNL DCSP dataset _ is _ stereo = ( &apos; s &apos; in dataset.view _ converter.axes ) DCNL DCSP ( figure , all _ axes ) = pyplot.subplots ( 1 , ( 3 if dataset _ is _ stereo else 2 ) , squeeze = True , figsize = ( 10 , 3.5 ) ) DCNL DCSP set _ name = ( os.path.split ( args.pkl ) &#91; 1 &#93; if ( args.which _ set is None ) else ( &apos; % sing DCSP set &apos; % args.which _ set ) ) DCNL DCSP figure.canvas.set _ window _ title ( ( &apos; NORB DCSP dataset DCSP ( % s ) &apos; % set _ name ) ) DCNL DCSP label _ text = figure.suptitle ( &apos; Up / down DCSP arrows DCSP choose DCSP label , DCSP left / right DCSP arrows DCSP change DCSP it &apos; , x = 0.1 , horizontalalignment = &apos; left &apos; ) DCNL DCSP for axes in all _ axes : DCNL DCSP DCSP axes.get _ xaxis ( ) .set _ visible ( False ) DCNL DCSP DCSP axes.get _ yaxis ( ) .set _ visible ( False ) DCNL DCSP ( text _ axes , image _ axes ) = ( all _ axes &#91; 0 &#93; , all _ axes &#91; 1 : &#93; ) DCNL DCSP image _ captions = ( ( &apos; left &apos; , &apos; right &apos; ) if dataset _ is _ stereo else ( &apos; mono DCSP image &apos; , ) ) DCNL DCSP if args.stereo _ viewer : DCNL DCSP DCSP image _ captions = tuple ( reversed ( image _ captions ) ) DCNL DCSP for ( image _ ax , caption ) in safe _ zip ( image _ axes , image _ captions ) : DCNL DCSP DCSP image _ ax.set _ title ( caption ) DCNL DCSP text _ axes.set _ frame _ on ( False ) DCNL DCSP def is _ blank ( grid _ indices ) : DCNL DCSP DCSP assert ( len ( grid _ indices ) = = 5 ) DCNL DCSP DCSP assert all ( ( ( x &gt; = 0 ) for x in grid _ indices ) ) DCNL DCSP DCSP ci = dataset.label _ name _ to _ index &#91; &apos; category &apos; &#93; DCNL DCSP DCSP category = grid _ to _ short _ label &#91; ci &#93; &#91; grid _ indices &#91; ci &#93; &#93; DCNL DCSP DCSP category _ name = dataset.label _ to _ value _ funcs &#91; ci &#93; ( category ) DCNL DCSP DCSP return ( category _ name = = &apos; blank &apos; ) DCNL DCSP def get _ short _ label ( grid _ indices ) : DCNL DCSP DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP the DCSP first DCSP 5 DCSP elements DCSP of DCSP the DCSP label DCSP vector DCSP pointed DCSP to DCSP by \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP grid _ indices . DCSP We DCSP use DCSP the DCSP first DCSP 5 , DCSP since DCSP they &apos;re DCSP the DCSP labels DCSP used DCSP by \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP both DCSP the DCSP &apos; big &apos; DCSP and DCSP Small DCSP NORB DCSP datasets . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; DCNL DCSP DCSP if is _ blank ( grid _ indices ) : DCNL DCSP DCSP DCSP return tuple ( blank _ label &#91; : 5 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return tuple ( ( grid _ to _ short _ label &#91; i &#93; &#91; g &#93; for ( i , g ) in enumerate ( grid _ indices ) ) ) DCNL DCSP def get _ row _ indices ( grid _ indices ) : DCNL DCSP DCSP short _ label = get _ short _ label ( grid _ indices ) DCNL DCSP DCSP return label _ to _ row _ indices.get ( short _ label , None ) DCNL DCSP axes _ to _ pixels = { } DCNL DCSP def redraw ( redraw _ text , redraw _ images ) : DCNL DCSP DCSP row _ indices = get _ row _ indices ( grid _ indices ) DCNL DCSP DCSP if ( row _ indices is None ) : DCNL DCSP DCSP DCSP row _ index = None DCNL DCSP DCSP DCSP image _ index = 0 DCNL DCSP DCSP DCSP num _ images = 0 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP image _ index = ( blank _ image _ index if is _ blank ( grid _ indices ) else object _ image _ index ) &#91; 0 &#93; DCNL DCSP DCSP DCSP row _ index = row _ indices &#91; image _ index &#93; DCNL DCSP DCSP DCSP num _ images = len ( row _ indices ) DCNL DCSP DCSP def draw _ text ( ) : DCNL DCSP DCSP DCSP if ( row _ indices is None ) : DCNL DCSP DCSP DCSP DCSP padding _ length = ( dataset.y.shape &#91; 1 &#93; - len ( grid _ indices ) ) DCNL DCSP DCSP DCSP DCSP current _ label = ( tuple ( get _ short _ label ( grid _ indices ) ) + ( ( 0 , ) * padding _ length ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP current _ label = dataset.y &#91; row _ index , : &#93; DCNL DCSP DCSP DCSP label _ names = dataset.label _ index _ to _ name DCNL DCSP DCSP DCSP label _ values = &#91; label _ to _ value ( label ) for ( label _ to _ value , label ) in safe _ zip ( dataset.label _ to _ value _ funcs , current _ label ) &#93; DCNL DCSP DCSP DCSP lines = &#91; ( &apos; % s : DCSP % s &apos; % ( t , v ) ) for ( t , v ) in safe _ zip ( label _ names , label _ values ) &#93; DCNL DCSP DCSP DCSP if ( dataset.y.shape &#91; 1 &#93; &gt; 5 ) : DCNL DCSP DCSP DCSP DCSP lines = ( ( lines &#91; : 5 &#93; + &#91; ( &apos; No DCSP such DCSP image &apos; if ( num _ images = = 0 ) else ( &apos; image : DCSP % d DCSP of DCSP % d &apos; % ( ( image _ index + 1 ) , num _ images ) ) ) , &apos; \ n &apos; &#93; ) + lines &#91; 5 : &#93; ) DCNL DCSP DCSP DCSP lines &#91; grid _ dimension &#91; 0 &#93; &#93; = ( &apos; = = &gt; DCSP &apos; + lines &#91; grid _ dimension &#91; 0 &#93; &#93; ) DCNL DCSP DCSP DCSP text _ axes.clear ( ) DCNL DCSP DCSP DCSP text _ axes.text ( 0 , 0.5 , &apos; \ n &apos; .join ( lines ) , verticalalignment = &apos; center &apos; , transform = text _ axes.transAxes ) DCNL DCSP DCSP def draw _ images ( ) : DCNL DCSP DCSP DCSP if ( row _ indices is None ) : DCNL DCSP DCSP DCSP DCSP for axis in image _ axes : DCNL DCSP DCSP DCSP DCSP DCSP axis.clear ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP data _ row = dataset.X &#91; row _ index : ( row _ index + 1 ) , : &#93; DCNL DCSP DCSP DCSP DCSP axes _ names = dataset.view _ converter.axes DCNL DCSP DCSP DCSP DCSP assert ( len ( axes _ names ) in ( 4 , 5 ) ) DCNL DCSP DCSP DCSP DCSP assert ( axes _ names &#91; 0 &#93; = = &apos; b &apos; ) DCNL DCSP DCSP DCSP DCSP assert ( axes _ names &#91; ( -3 ) &#93; = = 0 ) DCNL DCSP DCSP DCSP DCSP assert ( axes _ names &#91; ( -2 ) &#93; = = 1 ) DCNL DCSP DCSP DCSP DCSP assert ( axes _ names &#91; ( -1 ) &#93; = = &apos; c &apos; ) DCNL DCSP DCSP DCSP DCSP def draw _ image ( image , axes ) : DCNL DCSP DCSP DCSP DCSP DCSP assert ( len ( image.shape ) = = 2 ) DCNL DCSP DCSP DCSP DCSP DCSP norm = ( matplotlib.colors.NoNorm ( ) if args.no _ norm else None ) DCNL DCSP DCSP DCSP DCSP DCSP axes _ to _ pixels &#91; axes &#93; = image DCNL DCSP DCSP DCSP DCSP DCSP axes.imshow ( image , norm = norm , cmap = &apos; gray &apos; ) DCNL DCSP DCSP DCSP DCSP if ( &apos; s &apos; in axes _ names ) : DCNL DCSP DCSP DCSP DCSP DCSP image _ pair = dataset.get _ topological _ view ( mat = data _ row , single _ tensor = True ) DCNL DCSP DCSP DCSP DCSP DCSP image _ pair = tuple ( image _ pair &#91; 0 , : , : , : , 0 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP if args.stereo _ viewer : DCNL DCSP DCSP DCSP DCSP DCSP DCSP image _ pair = tuple ( reversed ( image _ pair ) ) DCNL DCSP DCSP DCSP DCSP DCSP for ( axis , image ) in safe _ zip ( image _ axes , image _ pair ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP draw _ image ( image , axis ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP image = dataset.get _ topological _ view ( mat = data _ row ) DCNL DCSP DCSP DCSP DCSP DCSP image = image &#91; 0 , : , : , 0 &#93; DCNL DCSP DCSP DCSP DCSP DCSP draw _ image ( image , image _ axes &#91; 0 &#93; ) DCNL DCSP DCSP if redraw _ text : DCNL DCSP DCSP DCSP draw _ text ( ) DCNL DCSP DCSP if redraw _ images : DCNL DCSP DCSP DCSP draw _ images ( ) DCNL DCSP DCSP figure.canvas.draw ( ) DCNL DCSP default _ status _ text = ( &apos; mouseover DCSP image % s DCSP for DCSP pixel DCSP values &apos; % ( &apos; &apos; if ( len ( image _ axes ) = = 1 ) else &apos; s &apos; ) ) DCNL DCSP status _ text = figure.text ( 0.5 , 0.1 , default _ status _ text ) DCNL DCSP def on _ mouse _ motion ( event ) : DCNL DCSP DCSP original _ text = status _ text.get _ text ( ) DCNL DCSP DCSP if ( event.inaxes not in image _ axes ) : DCNL DCSP DCSP DCSP status _ text.set _ text ( default _ status _ text ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP pixels = axes _ to _ pixels &#91; event.inaxes &#93; DCNL DCSP DCSP DCSP row = int ( ( event.ydata + 0.5 ) ) DCNL DCSP DCSP DCSP col = int ( ( event.xdata + 0.5 ) ) DCNL DCSP DCSP DCSP status _ text.set _ text ( ( &apos; Pixel DCSP value : DCSP % g &apos; % pixels &#91; ( row , col ) &#93; ) ) DCNL DCSP DCSP if ( status _ text.get _ text ! = original _ text ) : DCNL DCSP DCSP DCSP figure.canvas.draw ( ) DCNL DCSP def on _ key _ press ( event ) : DCNL DCSP DCSP def add _ mod ( arg , step , size ) : DCNL DCSP DCSP DCSP return ( ( ( arg + size ) + step ) % size ) DCNL DCSP DCSP def incr _ index _ type ( step ) : DCNL DCSP DCSP DCSP num _ dimensions = len ( grid _ indices ) DCNL DCSP DCSP DCSP if ( dataset.y.shape &#91; 1 &#93; &gt; 5 ) : DCNL DCSP DCSP DCSP DCSP num _ dimensions + = 1 DCNL DCSP DCSP DCSP grid _ dimension &#91; 0 &#93; = add _ mod ( grid _ dimension &#91; 0 &#93; , step , num _ dimensions ) DCNL DCSP DCSP def incr _ index ( step ) : DCNL DCSP DCSP DCSP assert ( step in ( 0 , ( -1 ) , 1 ) ) , ( &apos; Step DCSP was DCSP % d &apos; % step ) DCNL DCSP DCSP DCSP image _ index = ( blank _ image _ index if is _ blank ( grid _ indices ) else object _ image _ index ) DCNL DCSP DCSP DCSP if ( grid _ dimension &#91; 0 &#93; = = 5 ) : DCNL DCSP DCSP DCSP DCSP row _ indices = get _ row _ indices ( grid _ indices ) DCNL DCSP DCSP DCSP DCSP if ( row _ indices is None ) : DCNL DCSP DCSP DCSP DCSP DCSP image _ index &#91; 0 &#93; = 0 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP image _ index &#91; 0 &#93; = add _ mod ( image _ index &#91; 0 &#93; , step , len ( row _ indices ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP gd = grid _ dimension &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP grid _ indices &#91; gd &#93; = add _ mod ( grid _ indices &#91; gd &#93; , step , len ( grid _ to _ short _ label &#91; gd &#93; ) ) DCNL DCSP DCSP DCSP DCSP row _ indices = get _ row _ indices ( grid _ indices ) DCNL DCSP DCSP DCSP DCSP if ( row _ indices is None ) : DCNL DCSP DCSP DCSP DCSP DCSP image _ index &#91; 0 &#93; = 0 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP image _ index &#91; 0 &#93; = min ( image _ index &#91; 0 &#93; , len ( row _ indices ) ) DCNL DCSP DCSP disable _ left _ right = ( is _ blank ( grid _ indices ) and ( not ( grid _ dimension &#91; 0 &#93; in ( 0 , 5 ) ) ) ) DCNL DCSP DCSP if ( event.key = = &apos; up &apos; ) : DCNL DCSP DCSP DCSP incr _ index _ type ( ( -1 ) ) DCNL DCSP DCSP DCSP redraw ( True , False ) DCNL DCSP DCSP elif ( event.key = = &apos; down &apos; ) : DCNL DCSP DCSP DCSP incr _ index _ type ( 1 ) DCNL DCSP DCSP DCSP redraw ( True , False ) DCNL DCSP DCSP elif ( event.key = = &apos; q &apos; ) : DCNL DCSP DCSP DCSP sys.exit ( 0 ) DCNL DCSP DCSP elif ( not disable _ left _ right ) : DCNL DCSP DCSP DCSP if ( event.key = = &apos; left &apos; ) : DCNL DCSP DCSP DCSP DCSP incr _ index ( ( -1 ) ) DCNL DCSP DCSP DCSP DCSP redraw ( True , True ) DCNL DCSP DCSP DCSP elif ( event.key = = &apos; right &apos; ) : DCNL DCSP DCSP DCSP DCSP incr _ index ( 1 ) DCNL DCSP DCSP DCSP DCSP redraw ( True , True ) DCNL DCSP figure.canvas.mpl _ connect ( &apos; key _ press _ event &apos; , on _ key _ press ) DCNL DCSP figure.canvas.mpl _ connect ( &apos; motion _ notify _ event &apos; , on _ mouse _ motion ) DCNL DCSP redraw ( True , True ) DCNL DCSP pyplot.show ( )
DCSP from sklearn.svm import SVC DCNL DCSP from sklearn.base import is _ classifier DCNL DCSP from sklearn.kernel _ ridge import KernelRidge DCNL DCSP from sklearn.preprocessing import LabelEncoder DCNL DCSP from sklearn.metrics import roc _ auc _ score , mean _ squared _ error DCNL DCSP epochs = make _ epochs ( ) DCNL DCSP y _ 4classes = np.hstack ( ( epochs.events &#91; : 7 , 2 &#93; , ( epochs.events &#91; 7 : , 2 &#93; + 1 ) ) ) DCNL DCSP if check _ version ( &apos; sklearn &apos; , &apos; 0.18 &apos; ) : DCNL DCSP DCSP from sklearn.model _ selection import KFold , StratifiedKFold , ShuffleSplit , LeaveOneGroupOut DCNL DCSP DCSP cv = LeaveOneGroupOut ( ) DCNL DCSP DCSP cv _ shuffle = ShuffleSplit ( ) DCNL DCSP DCSP cv _ lolo = &#91; ( train , test ) for ( train , test ) in cv.split ( y _ 4classes , y _ 4classes , y _ 4classes ) &#93; DCNL DCSP DCSP scorer _ regress = None DCNL DCSP else : DCNL DCSP DCSP from sklearn.cross _ validation import KFold , StratifiedKFold , ShuffleSplit , LeaveOneLabelOut DCNL DCSP DCSP cv _ shuffle = ShuffleSplit ( len ( epochs ) ) DCNL DCSP DCSP cv _ lolo = LeaveOneLabelOut ( y _ 4classes ) DCNL DCSP DCSP scorer _ regress = mean _ squared _ error DCNL DCSP gat = GeneralizationAcrossTime ( picks = &apos; foo &apos; ) DCNL DCSP assert _ equal ( &apos; &lt; GAT DCSP &#124; DCSP no DCSP fit , DCSP no DCSP prediction , DCSP no DCSP score &gt; &apos; , ( &apos; % s &apos; % gat ) ) DCNL DCSP assert _ raises ( ValueError , gat.fit , epochs ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.picks = &#91; 0 &#93; DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP DCSP gat.picks = None DCNL DCSP DCSP gat.fit ( epochs , y = epochs.events &#91; : , 2 &#93; ) DCNL DCSP DCSP gat.fit ( epochs , y = epochs.events &#91; : , 2 &#93; .tolist ( ) ) DCNL DCSP assert _ equal ( len ( gat.picks _ ) , len ( gat.ch _ names ) , 1 ) DCNL DCSP assert _ equal ( &apos; &lt; GAT DCSP &#124; DCSP fitted , DCSP start DCSP : DCSP -0.200 DCSP ( s ) , DCSP stop DCSP : DCSP 0.499 DCSP ( s ) , DCSP no DCSP prediction , DCSP no DCSP score &gt; &apos; , ( &apos; % s &apos; % gat ) ) DCNL DCSP assert _ equal ( gat.ch _ names , epochs.ch _ names ) DCNL DCSP gat = GeneralizationAcrossTime ( predict _ method = &apos; decision _ function &apos; ) DCNL DCSP gat.fit ( epochs ) DCNL DCSP assert _ true ( ( gat.cv _ . _ _ class _ _ = = StratifiedKFold ) ) DCNL DCSP gat.predict ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ ) , ( 15 , 15 , 14 , 1 ) ) DCNL DCSP gat.predict _ method = &apos; predict _ proba &apos; DCNL DCSP gat.predict ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ ) , ( 15 , 15 , 14 , 2 ) ) DCNL DCSP gat.predict _ method = &apos; foo &apos; DCNL DCSP assert _ raises ( NotImplementedError , gat.predict , epochs ) DCNL DCSP gat.predict _ method = &apos; predict &apos; DCNL DCSP gat.predict ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ ) , ( 15 , 15 , 14 , 1 ) ) DCNL DCSP assert _ equal ( &apos; &lt; GAT DCSP &#124; DCSP fitted , DCSP start DCSP : DCSP -0.200 DCSP ( s ) , DCSP stop DCSP : DCSP 0.499 DCSP ( s ) , DCSP predicted DCSP 14 DCSP epochs , DCSP no DCSP score &gt; &apos; , ( &apos; % s &apos; % gat ) ) DCNL DCSP gat.score ( epochs ) DCNL DCSP assert _ true ( ( gat.scorer _ . _ _ name _ _ = = &apos; accuracy _ score &apos; ) ) DCNL DCSP gat.scorer = None DCNL DCSP gat.predict _ method = &apos; decision _ function &apos; DCNL DCSP assert _ raises ( ValueError , gat.score , epochs ) DCNL DCSP gat.predict _ method = &apos; predict &apos; DCNL DCSP gat.score ( epochs , y = epochs.events &#91; : , 2 &#93; ) DCNL DCSP gat.score ( epochs , y = epochs.events &#91; : , 2 &#93; .tolist ( ) ) DCNL DCSP assert _ equal ( &apos; &lt; GAT DCSP &#124; DCSP fitted , DCSP start DCSP : DCSP -0.200 DCSP ( s ) , DCSP stop DCSP : DCSP 0.499 DCSP ( s ) , DCSP predicted DCSP 14 DCSP epochs , \ n DCSP scored DCSP ( accuracy _ score ) &gt; &apos; , ( &apos; % s &apos; % gat ) ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs , y = epochs.events &#91; : , 2 &#93; ) DCNL DCSP old _ mode = gat.predict _ mode DCNL DCSP gat.predict _ mode = &apos; super-foo-mode &apos; DCNL DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP gat.predict _ mode = old _ mode DCNL DCSP gat.score ( epochs , y = epochs.events &#91; : , 2 &#93; ) DCNL DCSP assert _ true ( ( &apos; accuracy _ score &apos; in ( &apos; % s &apos; % gat.scorer _ ) ) ) DCNL DCSP epochs2 = epochs.copy ( ) DCNL DCSP assert _ equal ( &apos; &lt; DecodingTime DCSP &#124; DCSP start : DCSP -0.200 DCSP ( s ) , DCSP stop : DCSP 0.499 DCSP ( s ) , DCSP step : DCSP 0.050 DCSP ( s ) , DCSP length : DCSP 0.050 DCSP ( s ) , DCSP n _ time _ windows : DCSP 15 &gt; &apos; , ( &apos; % s &apos; % gat.train _ times _ ) ) DCNL DCSP assert _ equal ( &apos; &lt; DecodingTime DCSP &#124; DCSP start : DCSP -0.200 DCSP ( s ) , DCSP stop : DCSP 0.499 DCSP ( s ) , DCSP step : DCSP 0.050 DCSP ( s ) , DCSP length : DCSP 0.050 DCSP ( s ) , DCSP n _ time _ windows : DCSP 15 DCSP x DCSP 15 &gt; &apos; , ( &apos; % s &apos; % gat.test _ times _ ) ) DCNL DCSP gat.predict _ mode = &apos; mean-prediction &apos; DCNL DCSP epochs2.events &#91; : , 2 &#93; + = 10 DCNL DCSP gat _ = copy.deepcopy ( gat ) DCNL DCSP with use _ log _ level ( &apos; error &apos; ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat _ .score , epochs2 ) DCNL DCSP gat.predict _ mode = &apos; cross-validation &apos; DCNL DCSP assert _ true ( ( gat.y _ train _ .shape &#91; 0 &#93; = = gat.y _ true _ .shape &#91; 0 &#93; = = len ( gat.y _ pred _ &#91; 0 &#93; &#91; 0 &#93; ) = = 14 ) ) DCNL DCSP assert _ true ( ( np.shape ( gat.estimators _ ) &#91; 1 &#93; = = gat.cv ) ) DCNL DCSP assert _ true ( ( len ( gat.train _ times _ &#91; &apos; slices &apos; &#93; ) = = 15 = = np.shape ( gat.estimators _ ) &#91; 0 &#93; ) ) DCNL DCSP assert _ true ( ( len ( gat.test _ times _ &#91; &apos; slices &apos; &#93; ) = = 15 = = np.shape ( gat.scores _ ) &#91; 0 &#93; ) ) DCNL DCSP assert _ true ( ( len ( gat.test _ times _ &#91; &apos; slices &apos; &#93; &#91; 0 &#93; ) = = 15 = = np.shape ( gat.scores _ ) &#91; 1 &#93; ) ) DCNL DCSP gat.score _ mode = &apos; foo &apos; DCNL DCSP assert _ raises ( ValueError , gat.score , epochs ) DCNL DCSP gat.score _ mode = &apos; fold-wise &apos; DCNL DCSP scores = gat.score ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( scores ) , &#91; 15 , 15 , 5 &#93; ) DCNL DCSP gat.score _ mode = &apos; mean-sample-wise &apos; DCNL DCSP scores = gat.score ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( scores ) , &#91; 15 , 15 &#93; ) DCNL DCSP gat.score _ mode = &apos; mean-fold-wise &apos; DCNL DCSP scores = gat.score ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( scores ) , &#91; 15 , 15 &#93; ) DCNL DCSP gat.predict _ mode = &apos; mean-prediction &apos; DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP gat.score ( epochs ) DCNL DCSP DCSP assert _ true ( any ( ( ( &apos; score _ mode DCSP changed DCSP from DCSP &apos; in str ( ww.message ) ) for ww in w ) ) ) DCNL DCSP gat = GeneralizationAcrossTime ( train _ times = { &apos; length &apos; : 0.1 } ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat2 = gat.fit ( epochs ) DCNL DCSP assert _ true ( ( gat is gat2 ) ) DCNL DCSP assert _ true ( hasattr ( gat2 , &apos; cv _ &apos; ) ) DCNL DCSP assert _ true ( ( gat2.cv _ ! = gat.cv ) ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP scores = gat.score ( epochs ) DCNL DCSP assert _ true ( isinstance ( scores , np.ndarray ) ) DCNL DCSP assert _ equal ( len ( scores &#91; 0 &#93; ) , len ( scores ) ) DCNL DCSP assert _ equal ( len ( gat.test _ times _ &#91; &apos; slices &apos; &#93; &#91; 0 &#93; &#91; 0 &#93; ) , 2 ) DCNL DCSP gat = GeneralizationAcrossTime ( train _ times = { &apos; step &apos; : 0.1 } ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP gat.score ( epochs ) DCNL DCSP assert _ true ( ( len ( gat.scores _ ) = = len ( gat.estimators _ ) = = 8 ) ) DCNL DCSP assert _ equal ( len ( gat.scores _ &#91; 0 &#93; ) , 15 ) DCNL DCSP y _ 4classes = np.hstack ( ( epochs.events &#91; : 7 , 2 &#93; , ( epochs.events &#91; 7 : , 2 &#93; + 1 ) ) ) DCNL DCSP train _ times = dict ( start = 0.09 , stop = 0.25 ) DCNL DCSP gat = GeneralizationAcrossTime ( cv = cv _ lolo , train _ times = train _ times ) DCNL DCSP assert _ raises ( RuntimeError , gat.predict , epochs ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs , y = y _ 4classes ) DCNL DCSP gat.score ( epochs ) DCNL DCSP assert _ equal ( len ( gat.scores _ ) , 4 ) DCNL DCSP assert _ equal ( gat.train _ times _ &#91; &apos; times &apos; &#93; &#91; 0 &#93; , epochs.times &#91; 6 &#93; ) DCNL DCSP assert _ equal ( gat.train _ times _ &#91; &apos; times &apos; &#93; &#91; ( -1 ) &#93; , epochs.times &#91; 9 &#93; ) DCNL DCSP gat = GeneralizationAcrossTime ( test _ times = &apos; diagonal &apos; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP assert _ raises ( RuntimeError , gat.score ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.predict ( epochs ) DCNL DCSP scores = gat.score ( ) DCNL DCSP assert _ true ( ( scores is gat.scores _ ) ) DCNL DCSP assert _ equal ( np.shape ( gat.scores _ ) , ( 15 , 1 ) ) DCNL DCSP assert _ array _ equal ( &#91; tim for ttime in gat.test _ times _ &#91; &apos; times &apos; &#93; for tim in ttime &#93; , gat.train _ times _ &#91; &apos; times &apos; &#93; ) DCNL DCSP gat = GeneralizationAcrossTime ( predict _ mode = &apos; mean-prediction &apos; , cv = 2 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs &#91; 0 : 6 &#93; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.predict ( epochs &#91; 7 : &#93; ) DCNL DCSP DCSP gat.score ( epochs &#91; 7 : &#93; ) DCNL DCSP gat _ = copy.deepcopy ( gat ) DCNL DCSP gat _ .train _ times = dict ( start = ( -999.0 ) ) DCNL DCSP with use _ log _ level ( &apos; error &apos; ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat _ .fit , epochs ) DCNL DCSP gat _ .train _ times = dict ( start = 999.0 ) DCNL DCSP assert _ raises ( ValueError , gat _ .fit , epochs ) DCNL DCSP gat _ .train _ times = dict ( step = 1e-06 ) DCNL DCSP assert _ raises ( ValueError , gat _ .fit , epochs ) DCNL DCSP gat _ .train _ times = dict ( length = 1e-06 ) DCNL DCSP assert _ raises ( ValueError , gat _ .fit , epochs ) DCNL DCSP gat _ .train _ times = dict ( length = 999.0 ) DCNL DCSP assert _ raises ( ValueError , gat _ .fit , epochs ) DCNL DCSP gat.test _ times = dict ( start = ( -999.0 ) ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP gat.test _ times = dict ( start = 999.0 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP gat.test _ times = dict ( step = 1e-06 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP gat _ = copy.deepcopy ( gat ) DCNL DCSP gat _ .train _ times _ &#91; &apos; length &apos; &#93; = 1e-06 DCNL DCSP gat _ .test _ times = dict ( length = 1e-06 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat _ .predict , epochs ) DCNL DCSP gat.test _ times = dict ( step = 0.15 ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.predict ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ ) , ( 15 , 5 , 14 , 1 ) ) DCNL DCSP gat.test _ times = &apos; foo &apos; DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP assert _ raises ( RuntimeError , gat.score ) DCNL DCSP gat.test _ times = dict ( length = 0.15 ) DCNL DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP train _ times = dict ( slices = &#91; &#91; 0 , 1 &#93; , &#91; 1 &#93; &#93; ) DCNL DCSP test _ times = dict ( slices = &#91; &#91; &#91; 0 , 1 &#93; &#93; , &#91; &#91; 0 &#93; , &#91; 1 &#93; &#93; &#93; ) DCNL DCSP gat = GeneralizationAcrossTime ( train _ times = train _ times , test _ times = test _ times ) DCNL DCSP gat.fit ( epochs ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.score ( epochs ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ &#91; 0 &#93; ) , &#91; 1 , len ( epochs ) , 1 &#93; ) DCNL DCSP assert _ array _ equal ( np.shape ( gat.y _ pred _ &#91; 1 &#93; ) , &#91; 2 , len ( epochs ) , 1 &#93; ) DCNL DCSP gat.test _ times = None DCNL DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP svc = SVC ( C = 1 , kernel = &apos; linear &apos; , probability = True ) DCNL DCSP gat = GeneralizationAcrossTime ( clf = svc , predict _ mode = &apos; mean-prediction &apos; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP with use _ log _ level ( &apos; error &apos; ) : DCNL DCSP DCSP assert _ raises ( ValueError , gat.score , epochs2 ) DCNL DCSP DCSP gat.score ( epochs ) DCNL DCSP assert _ true ( ( 0.0 &lt; = np.min ( scores ) &lt; = 1.0 ) ) DCNL DCSP assert _ true ( ( 0.0 &lt; = np.max ( scores ) &lt; = 1.0 ) ) DCNL DCSP gat = GeneralizationAcrossTime ( cv = cv _ shuffle , predict _ mode = &apos; cross-validation &apos; ) DCNL DCSP gat.fit ( epochs ) DCNL DCSP assert _ raises ( ValueError , gat.predict , epochs ) DCNL DCSP gat = GeneralizationAcrossTime ( cv = cv _ shuffle , predict _ mode = &apos; mean-prediction &apos; ) DCNL DCSP gat.fit ( epochs ) DCNL DCSP gat.predict ( epochs ) DCNL DCSP gat = GeneralizationAcrossTime ( ) DCNL DCSP gat.fit ( epochs ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP gat.predict ( epochs ) DCNL DCSP assert _ raises ( ValueError , gat.predict , epochs &#91; : 10 &#93; ) DCNL DCSP gat . _ cv _ splits &#91; 0 &#93; = &#91; gat . _ cv _ splits &#91; 0 &#93; &#91; 0 &#93; , np.empty ( 0 ) &#93; DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP gat.predict ( epochs ) DCNL DCSP DCSP assert _ true ( ( len ( w ) &gt; 0 ) ) DCNL DCSP DCSP assert _ true ( any ( ( ( &apos; do DCSP not DCSP have DCSP any DCSP test DCSP epochs &apos; in str ( ww.message ) ) for ww in w ) ) ) DCNL DCSP gat = GeneralizationAcrossTime ( cv = &#91; ( &#91; 0 &#93; , &#91; 1 &#93; ) , ( &#91; &#93; , &#91; 0 &#93; ) &#93; ) DCNL DCSP assert _ raises ( ValueError , gat.fit , epochs &#91; : 2 &#93; ) DCNL DCSP if check _ version ( &apos; sklearn &apos; , &apos; 0.17 &apos; ) : DCNL DCSP DCSP gat = GeneralizationAcrossTime ( clf = KernelRidge ( ) , cv = 2 ) DCNL DCSP DCSP epochs.crop ( None , epochs.times &#91; 2 &#93; ) DCNL DCSP DCSP gat.fit ( epochs ) DCNL DCSP DCSP assert _ true ( ( gat.cv _ . _ _ class _ _ = = KFold ) ) DCNL DCSP DCSP gat.score ( epochs ) DCNL DCSP DCSP assert _ true ( ( gat.scorer _ . _ _ name _ _ = = &apos; mean _ squared _ error &apos; ) ) DCNL DCSP n _ classes = &#91; 2 , 4 &#93; DCNL DCSP le = LabelEncoder ( ) DCNL DCSP y = le.fit _ transform ( epochs.events &#91; : , 2 &#93; ) DCNL DCSP y &#91; ( len ( y ) / / 2 ) : &#93; + = 2 DCNL DCSP ys = ( y , ( y + 1000 ) ) DCNL DCSP svc = SVC ( C = 1 , kernel = &apos; linear &apos; , probability = True ) DCNL DCSP reg = KernelRidge ( ) DCNL DCSP def scorer _ proba ( y _ true , y _ pred ) : DCNL DCSP DCSP return roc _ auc _ score ( y _ true , y _ pred &#91; : , 0 &#93; ) DCNL DCSP scorers = &#91; None , scorer _ proba , scorer _ regress &#93; DCNL DCSP predict _ methods = &#91; None , &apos; predict _ proba &apos; , None &#93; DCNL DCSP clfs = &#91; svc , svc , reg &#93; DCNL DCSP for ( clf , predict _ method , scorer ) in zip ( clfs , predict _ methods , scorers ) : DCNL DCSP DCSP for y in ys : DCNL DCSP DCSP DCSP for n _ class in n _ classes : DCNL DCSP DCSP DCSP DCSP for predict _ mode in &#91; &apos; cross-validation &apos; , &apos; mean-prediction &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( predict _ method = = &apos; predict _ proba &apos; ) and ( n _ class ! = 2 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP y _ = ( y % n _ class ) DCNL DCSP DCSP DCSP DCSP DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP gat = GeneralizationAcrossTime ( cv = 2 , clf = clf , scorer = scorer , predict _ mode = predict _ mode ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP gat.fit ( epochs , y = y _ ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP gat.score ( epochs , y = y _ ) DCNL DCSP DCSP DCSP DCSP DCSP scorer _ name = gat.scorer _ . _ _ name _ _ DCNL DCSP DCSP DCSP DCSP DCSP if ( scorer is None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if is _ classifier ( clf ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP assert _ equal ( scorer _ name , &apos; accuracy _ score &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP assert _ equal ( scorer _ name , &apos; mean _ squared _ error &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP assert _ equal ( scorer _ name , scorer . _ _ name _ _ )
DCSP z = atleast _ 1d ( z ) DCNL DCSP p = atleast _ 1d ( p ) DCNL DCSP wo = float ( wo ) DCNL DCSP degree = _ relative _ degree ( z , p ) DCNL DCSP z _ hp = ( wo / z ) DCNL DCSP p _ hp = ( wo / p ) DCNL DCSP z _ hp = append ( z _ hp , zeros ( degree ) ) DCNL DCSP k _ hp = ( k * real ( ( prod ( ( - z ) ) / prod ( ( - p ) ) ) ) ) DCNL DCSP return ( z _ hp , p _ hp , k _ hp )
DCSP finder = _ getfinder ( ) DCNL DCSP args = { } DCNL DCSP attrs = { } DCNL DCSP aeobj _ 00 = aetypes.ObjectSpecifier ( want = aetypes.Type ( &apos; cobj &apos; ) , form = &apos; alis &apos; , seld = object _ alias , fr = None ) DCNL DCSP aeobj _ 01 = aetypes.ObjectSpecifier ( want = aetypes.Type ( &apos; prop &apos; ) , form = &apos; prop &apos; , seld = aetypes.Type ( &apos; labi &apos; ) , fr = aeobj _ 00 ) DCNL DCSP args &#91; &apos; ---- &apos; &#93; = aeobj _ 01 DCNL DCSP ( _ reply , args , attrs ) = finder.send ( &apos; core &apos; , &apos; getd &apos; , args , attrs ) DCNL DCSP if args.has _ key ( &apos; errn &apos; ) : DCNL DCSP DCSP raise Error , aetools.decodeerror ( args ) DCNL DCSP if args.has _ key ( &apos; ---- &apos; ) : DCNL DCSP DCSP return args &#91; &apos; ---- &apos; &#93;
DCSP if ( ft = = &apos; all &apos; ) : DCNL DCSP DCSP ft = &apos; _ &apos; DCNL DCSP patterns = &#91; ( &apos; % s.snippets &apos; % ft ) , os.path.join ( ft , &apos; * .snippets &apos; ) , os.path.join ( ft , &apos; * .snippet &apos; ) , os.path.join ( ft , &apos; * / * .snippet &apos; ) &#93; DCNL DCSP ret = set ( ) DCNL DCSP for rtp in _ vim.eval ( &apos; &amp; runtimepath &apos; ) .split ( &apos; , &apos; ) : DCNL DCSP DCSP path = os.path.realpath ( os.path.expanduser ( os.path.join ( rtp , &apos; snippets &apos; ) ) ) DCNL DCSP DCSP for pattern in patterns : DCNL DCSP DCSP DCSP for fn in glob.glob ( os.path.join ( path , pattern ) ) : DCNL DCSP DCSP DCSP DCSP ret.add ( fn ) DCNL DCSP return ret
DCSP server = _ connect ( host , port , db , password ) DCNL DCSP return server.dbsize ( )
DCSP if ( not ident ) : DCNL DCSP DCSP ident = sid ( ) DCNL DCSP edesc.signature = pre _ signature _ part ( ident , secc.my _ cert , 1 ) DCNL DCSP edesc.id = ident DCNL DCSP xmldoc = secc.sign _ statement ( ( &apos; % s &apos; % edesc ) , class _ name ( edesc ) ) DCNL DCSP edesc = md.entity _ descriptor _ from _ string ( xmldoc ) DCNL DCSP return ( edesc , xmldoc )
DCSP if isinstance ( children , dict ) : DCNL DCSP DCSP keys = list ( children.keys ( ) ) DCNL DCSP DCSP children = children.values ( ) DCNL DCSP else : DCNL DCSP DCSP keys = None DCNL DCSP children = list ( map ( convert _ yielded , children ) ) DCNL DCSP assert all ( ( is _ future ( i ) for i in children ) ) DCNL DCSP unfinished _ children = set ( children ) DCNL DCSP future = Future ( ) DCNL DCSP if ( not children ) : DCNL DCSP DCSP future.set _ result ( ( { } if ( keys is not None ) else &#91; &#93; ) ) DCNL DCSP def callback ( f ) : DCNL DCSP DCSP unfinished _ children.remove ( f ) DCNL DCSP DCSP if ( not unfinished _ children ) : DCNL DCSP DCSP DCSP result _ list = &#91; &#93; DCNL DCSP DCSP DCSP for f in children : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP result _ list.append ( f.result ( ) ) DCNL DCSP DCSP DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP DCSP DCSP if future.done ( ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not isinstance ( e , quiet _ exceptions ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP app _ log.error ( &apos; Multiple DCSP exceptions DCSP in DCSP yield DCSP list &apos; , exc _ info = True ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP future.set _ exc _ info ( sys.exc _ info ( ) ) DCNL DCSP DCSP DCSP if ( not future.done ( ) ) : DCNL DCSP DCSP DCSP DCSP if ( keys is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP future.set _ result ( dict ( zip ( keys , result _ list ) ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP future.set _ result ( result _ list ) DCNL DCSP listening = set ( ) DCNL DCSP for f in children : DCNL DCSP DCSP if ( f not in listening ) : DCNL DCSP DCSP DCSP listening.add ( f ) DCNL DCSP DCSP DCSP f.add _ done _ callback ( callback ) DCNL DCSP return future
DCSP if ( ( not settings.DEBUG ) and ( not insecure ) ) : DCNL DCSP DCSP raise ImproperlyConfigured ( &quot; The DCSP staticfiles DCSP view DCSP can DCSP only DCSP be DCSP used DCSP in DCSP debug DCSP mode DCSP or DCSP if DCSP the DCSP the DCSP --insecure DCSP option DCSP of DCSP &apos; runserver &apos; DCSP is DCSP used &quot; ) DCNL DCSP normalized _ path = posixpath.normpath ( urllib.unquote ( path ) ) .lstrip ( &apos; / &apos; ) DCNL DCSP absolute _ path = finders.find ( normalized _ path ) DCNL DCSP if ( not absolute _ path ) : DCNL DCSP DCSP if ( path.endswith ( &apos; / &apos; ) or ( path = = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP raise Http404 ( &apos; Directory DCSP indexes DCSP are DCSP not DCSP allowed DCSP here . &apos; ) DCNL DCSP DCSP raise Http404 ( ( &quot; &apos; % s &apos; DCSP could DCSP not DCSP be DCSP found &quot; % path ) ) DCNL DCSP ( document _ root , path ) = os.path.split ( absolute _ path ) DCNL DCSP return static.serve ( request , path , document _ root = document _ root , * * kwargs )
DCSP ant = XML.SubElement ( xml _ parent , &apos; hudson.tasks.Ant &apos; ) DCNL DCSP if ( type ( data ) is str ) : DCNL DCSP DCSP data = { &apos; targets &apos; : data } DCNL DCSP for ( setting , value ) in sorted ( data.items ( ) ) : DCNL DCSP DCSP if ( setting = = &apos; targets &apos; ) : DCNL DCSP DCSP DCSP targets = XML.SubElement ( ant , &apos; targets &apos; ) DCNL DCSP DCSP DCSP targets.text = value DCNL DCSP DCSP if ( setting = = &apos; buildfile &apos; ) : DCNL DCSP DCSP DCSP buildfile = XML.SubElement ( ant , &apos; buildFile &apos; ) DCNL DCSP DCSP DCSP buildfile.text = value DCNL DCSP DCSP if ( setting = = &apos; properties &apos; ) : DCNL DCSP DCSP DCSP properties = data &#91; &apos; properties &apos; &#93; DCNL DCSP DCSP DCSP prop _ string = &apos; &apos; DCNL DCSP DCSP DCSP for ( prop , val ) in properties.items ( ) : DCNL DCSP DCSP DCSP DCSP prop _ string + = ( &apos; % s = % s \ n &apos; % ( prop , val ) ) DCNL DCSP DCSP DCSP prop _ element = XML.SubElement ( ant , &apos; properties &apos; ) DCNL DCSP DCSP DCSP prop _ element.text = prop _ string DCNL DCSP DCSP if ( setting = = &apos; java-opts &apos; ) : DCNL DCSP DCSP DCSP javaopts = data &#91; &apos; java-opts &apos; &#93; DCNL DCSP DCSP DCSP jopt _ string = &apos; DCSP &apos; .join ( javaopts ) DCNL DCSP DCSP DCSP jopt _ element = XML.SubElement ( ant , &apos; antOpts &apos; ) DCNL DCSP DCSP DCSP jopt _ element.text = jopt _ string DCNL DCSP XML.SubElement ( ant , &apos; antName &apos; ) .text = data.get ( &apos; ant-name &apos; , &apos; default &apos; )
DCSP r = ( ( w + h ) / 2.0 ) DCNL DCSP ( x , y ) = ( ( ( - ( ( 2.0 * x ) - w ) ) / r ) , ( ( - ( ( 2.0 * y ) - h ) ) / r ) ) DCNL DCSP h = np.sqrt ( ( ( x * x ) + ( y * y ) ) ) DCNL DCSP return ( ( 0.0 , ( x / h ) , ( y / h ) , 0.0 ) if ( h &gt; 1.0 ) else ( 0.0 , x , y , np.sqrt ( ( 1.0 - ( h * h ) ) ) ) )
DCSP A = CoordSysCartesian ( &apos; A &apos; ) DCNL DCSP assert ( BaseScalar ( &apos; A.x &apos; , 0 , A , &apos; A _ x &apos; , &apos; \ \ mathbf { { x } _ { A } } &apos; ) = = A.x ) DCNL DCSP assert ( BaseScalar ( &apos; A.y &apos; , 1 , A , &apos; A _ y &apos; , &apos; \ \ mathbf { { y } _ { A } } &apos; ) = = A.y ) DCNL DCSP assert ( BaseScalar ( &apos; A.z &apos; , 2 , A , &apos; A _ z &apos; , &apos; \ \ mathbf { { z } _ { A } } &apos; ) = = A.z ) DCNL DCSP assert ( BaseScalar ( &apos; A.x &apos; , 0 , A , &apos; A _ x &apos; , &apos; \ \ mathbf { { x } _ { A } } &apos; ) . _ _ hash _ _ ( ) = = A.x. _ _ hash _ _ ( ) ) DCNL DCSP assert ( isinstance ( A.x , BaseScalar ) and isinstance ( A.y , BaseScalar ) and isinstance ( A.z , BaseScalar ) ) DCNL DCSP assert ( ( A.x * A.y ) = = ( A.y * A.x ) ) DCNL DCSP assert ( A.scalar _ map ( A ) = = { A.x : A.x , A.y : A.y , A.z : A.z } ) DCNL DCSP assert ( A.x.system = = A ) DCNL DCSP assert ( A.x.diff ( A.x ) = = 1 ) DCNL DCSP B = A.orient _ new _ axis ( &apos; B &apos; , q , A.k ) DCNL DCSP assert ( B.scalar _ map ( A ) = = { B.z : A.z , B.y : ( ( ( - A.x ) * sin ( q ) ) + ( A.y * cos ( q ) ) ) , B.x : ( ( A.x * cos ( q ) ) + ( A.y * sin ( q ) ) ) } ) DCNL DCSP assert ( A.scalar _ map ( B ) = = { A.x : ( ( B.x * cos ( q ) ) - ( B.y * sin ( q ) ) ) , A.y : ( ( B.x * sin ( q ) ) + ( B.y * cos ( q ) ) ) , A.z : B.z } ) DCNL DCSP assert ( express ( B.x , A , variables = True ) = = ( ( A.x * cos ( q ) ) + ( A.y * sin ( q ) ) ) ) DCNL DCSP assert ( express ( B.y , A , variables = True ) = = ( ( ( - A.x ) * sin ( q ) ) + ( A.y * cos ( q ) ) ) ) DCNL DCSP assert ( express ( B.z , A , variables = True ) = = A.z ) DCNL DCSP assert ( expand ( express ( ( ( B.x * B.y ) * B.z ) , A , variables = True ) ) = = expand ( ( ( A.z * ( ( ( - A.x ) * sin ( q ) ) + ( A.y * cos ( q ) ) ) ) * ( ( A.x * cos ( q ) ) + ( A.y * sin ( q ) ) ) ) ) ) DCNL DCSP assert ( express ( ( ( ( B.x * B.i ) + ( B.y * B.j ) ) + ( B.z * B.k ) ) , A ) = = ( ( ( ( ( B.x * cos ( q ) ) - ( B.y * sin ( q ) ) ) * A.i ) + ( ( ( B.x * sin ( q ) ) + ( B.y * cos ( q ) ) ) * A.j ) ) + ( B.z * A.k ) ) ) DCNL DCSP assert ( simplify ( express ( ( ( ( B.x * B.i ) + ( B.y * B.j ) ) + ( B.z * B.k ) ) , A , variables = True ) ) = = ( ( ( A.x * A.i ) + ( A.y * A.j ) ) + ( A.z * A.k ) ) ) DCNL DCSP assert ( express ( ( ( ( A.x * A.i ) + ( A.y * A.j ) ) + ( A.z * A.k ) ) , B ) = = ( ( ( ( ( A.x * cos ( q ) ) + ( A.y * sin ( q ) ) ) * B.i ) + ( ( ( ( - A.x ) * sin ( q ) ) + ( A.y * cos ( q ) ) ) * B.j ) ) + ( A.z * B.k ) ) ) DCNL DCSP assert ( simplify ( express ( ( ( ( A.x * A.i ) + ( A.y * A.j ) ) + ( A.z * A.k ) ) , B , variables = True ) ) = = ( ( ( B.x * B.i ) + ( B.y * B.j ) ) + ( B.z * B.k ) ) ) DCNL DCSP N = B.orient _ new _ axis ( &apos; N &apos; , ( - q ) , B.k ) DCNL DCSP assert ( N.scalar _ map ( A ) = = { N.x : A.x , N.z : A.z , N.y : A.y } ) DCNL DCSP C = A.orient _ new _ axis ( &apos; C &apos; , q , ( ( A.i + A.j ) + A.k ) ) DCNL DCSP mapping = A.scalar _ map ( C ) DCNL DCSP assert ( mapping &#91; A.x &#93; = = ( ( ( ( C.x * ( ( 2 * cos ( q ) ) + 1 ) ) / 3 ) + ( ( C.y * ( ( ( -2 ) * sin ( ( q + ( pi / 6 ) ) ) ) + 1 ) ) / 3 ) ) + ( ( C.z * ( ( ( -2 ) * cos ( ( q + ( pi / 3 ) ) ) ) + 1 ) ) / 3 ) ) ) DCNL DCSP assert ( mapping &#91; A.y &#93; = = ( ( ( ( C.x * ( ( ( -2 ) * cos ( ( q + ( pi / 3 ) ) ) ) + 1 ) ) / 3 ) + ( ( C.y * ( ( 2 * cos ( q ) ) + 1 ) ) / 3 ) ) + ( ( C.z * ( ( ( -2 ) * sin ( ( q + ( pi / 6 ) ) ) ) + 1 ) ) / 3 ) ) ) DCNL DCSP assert ( mapping &#91; A.z &#93; = = ( ( ( ( C.x * ( ( ( -2 ) * sin ( ( q + ( pi / 6 ) ) ) ) + 1 ) ) / 3 ) + ( ( C.y * ( ( ( -2 ) * cos ( ( q + ( pi / 3 ) ) ) ) + 1 ) ) / 3 ) ) + ( ( C.z * ( ( 2 * cos ( q ) ) + 1 ) ) / 3 ) ) ) DCNL DCSP D = A.locate _ new ( &apos; D &apos; , ( ( ( a * A.i ) + ( b * A.j ) ) + ( c * A.k ) ) ) DCNL DCSP assert ( D.scalar _ map ( A ) = = { D.z : ( A.z - c ) , D.x : ( A.x - a ) , D.y : ( A.y - b ) } ) DCNL DCSP E = A.orient _ new _ axis ( &apos; E &apos; , a , A.k , ( ( ( a * A.i ) + ( b * A.j ) ) + ( c * A.k ) ) ) DCNL DCSP assert ( A.scalar _ map ( E ) = = { A.z : ( E.z + c ) , A.x : ( ( ( E.x * cos ( a ) ) - ( E.y * sin ( a ) ) ) + a ) , A.y : ( ( ( E.x * sin ( a ) ) + ( E.y * cos ( a ) ) ) + b ) } ) DCNL DCSP assert ( E.scalar _ map ( A ) = = { E.x : ( ( ( A.x - a ) * cos ( a ) ) + ( ( A.y - b ) * sin ( a ) ) ) , E.y : ( ( ( ( - A.x ) + a ) * sin ( a ) ) + ( ( A.y - b ) * cos ( a ) ) ) , E.z : ( A.z - c ) } ) DCNL DCSP F = A.locate _ new ( &apos; F &apos; , Vector.zero ) DCNL DCSP assert ( A.scalar _ map ( F ) = = { A.z : F.z , A.x : F.x , A.y : F.y } )
DCSP line = clean _ lines.elided &#91; linenum &#93; DCNL DCSP if Match ( &apos; \ \ s * { \ \ s * $ &apos; , line ) : DCNL DCSP DCSP prevline = GetPreviousNonBlankLine ( clean _ lines , linenum ) &#91; 0 &#93; DCNL DCSP DCSP if ( ( not Search ( &apos; &#91; , ; : } { ( &#93; \ \ s * $ &apos; , prevline ) ) and ( not Match ( &apos; \ \ s * # &apos; , prevline ) ) and ( not ( ( GetLineWidth ( prevline ) &gt; ( _ line _ length - 2 ) ) and ( &apos; &#91; &#93; &apos; in prevline ) ) ) ) : DCNL DCSP DCSP DCSP error ( filename , linenum , &apos; whitespace / braces &apos; , 4 , &apos; { DCSP should DCSP almost DCSP always DCSP be DCSP at DCSP the DCSP end DCSP of DCSP the DCSP previous DCSP line &apos; ) DCNL DCSP if Match ( &apos; \ \ s * else \ \ b \ \ s * ( ? : if \ \ b &#124; \ \ { &#124; $ ) &apos; , line ) : DCNL DCSP DCSP prevline = GetPreviousNonBlankLine ( clean _ lines , linenum ) &#91; 0 &#93; DCNL DCSP DCSP if Match ( &apos; \ \ s * } \ \ s * $ &apos; , prevline ) : DCNL DCSP DCSP DCSP error ( filename , linenum , &apos; whitespace / newline &apos; , 4 , &apos; An DCSP else DCSP should DCSP appear DCSP on DCSP the DCSP same DCSP line DCSP as DCSP the DCSP preceding DCSP } &apos; ) DCNL DCSP if Search ( &apos; else DCSP if \ \ s * \ \ ( &apos; , line ) : DCNL DCSP DCSP brace _ on _ left = bool ( Search ( &apos; } \ \ s * else DCSP if \ \ s * \ \ ( &apos; , line ) ) DCNL DCSP DCSP pos = line.find ( &apos; else DCSP if &apos; ) DCNL DCSP DCSP pos = line.find ( &apos; ( &apos; , pos ) DCNL DCSP DCSP if ( pos &gt; 0 ) : DCNL DCSP DCSP DCSP ( endline , _ , endpos ) = CloseExpression ( clean _ lines , linenum , pos ) DCNL DCSP DCSP DCSP brace _ on _ right = ( endline &#91; endpos : &#93; .find ( &apos; { &apos; ) ! = ( -1 ) ) DCNL DCSP DCSP DCSP if ( brace _ on _ left ! = brace _ on _ right ) : DCNL DCSP DCSP DCSP DCSP error ( filename , linenum , &apos; readability / braces &apos; , 5 , &apos; If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP side , DCSP it DCSP should DCSP have DCSP it DCSP on DCSP both &apos; ) DCNL DCSP elif ( Search ( &apos; } \ \ s * else &#91; ^ { &#93; * $ &apos; , line ) or Match ( &apos; &#91; ^ } &#93; * else \ \ s * { &apos; , line ) ) : DCNL DCSP DCSP error ( filename , linenum , &apos; readability / braces &apos; , 5 , &apos; If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP side , DCSP it DCSP should DCSP have DCSP it DCSP on DCSP both &apos; ) DCNL DCSP if ( Search ( &apos; \ \ belse DCSP &#91; ^ \ \ s { &#93; &apos; , line ) and ( not Search ( &apos; \ \ belse DCSP if \ \ b &apos; , line ) ) ) : DCNL DCSP DCSP error ( filename , linenum , &apos; whitespace / newline &apos; , 4 , &apos; Else DCSP clause DCSP should DCSP never DCSP be DCSP on DCSP same DCSP line DCSP as DCSP else DCSP ( use DCSP 2 DCSP lines ) &apos; ) DCNL DCSP if Match ( &apos; \ \ s * do DCSP &#91; ^ \ \ s { &#93; &apos; , line ) : DCNL DCSP DCSP error ( filename , linenum , &apos; whitespace / newline &apos; , 4 , &apos; do / while DCSP clauses DCSP should DCSP not DCSP be DCSP on DCSP a DCSP single DCSP line &apos; ) DCNL DCSP if _ else _ match = Search ( &apos; \ \ b ( if \ \ s * \ \ ( &#124; else \ \ b ) &apos; , line ) DCNL DCSP if ( if _ else _ match and ( not Match ( &apos; \ \ s * # &apos; , line ) ) ) : DCNL DCSP DCSP if _ indent = GetIndentLevel ( line ) DCNL DCSP DCSP ( endline , endlinenum , endpos ) = ( line , linenum , if _ else _ match.end ( ) ) DCNL DCSP DCSP if _ match = Search ( &apos; \ \ bif \ \ s * \ \ ( &apos; , line ) DCNL DCSP DCSP if if _ match : DCNL DCSP DCSP DCSP pos = ( if _ match.end ( ) - 1 ) DCNL DCSP DCSP DCSP ( endline , endlinenum , endpos ) = CloseExpression ( clean _ lines , linenum , pos ) DCNL DCSP DCSP if ( ( not Match ( &apos; \ \ s * { &apos; , endline &#91; endpos : &#93; ) ) and ( not ( Match ( &apos; \ \ s * $ &apos; , endline &#91; endpos : &#93; ) and ( endlinenum &lt; ( len ( clean _ lines.elided ) - 1 ) ) and Match ( &apos; \ \ s * { &apos; , clean _ lines.elided &#91; ( endlinenum + 1 ) &#93; ) ) ) ) : DCNL DCSP DCSP DCSP while ( ( endlinenum &lt; len ( clean _ lines.elided ) ) and ( &apos; ; &apos; not in clean _ lines.elided &#91; endlinenum &#93; &#91; endpos : &#93; ) ) : DCNL DCSP DCSP DCSP DCSP endlinenum + = 1 DCNL DCSP DCSP DCSP DCSP endpos = 0 DCNL DCSP DCSP DCSP if ( endlinenum &lt; len ( clean _ lines.elided ) ) : DCNL DCSP DCSP DCSP DCSP endline = clean _ lines.elided &#91; endlinenum &#93; DCNL DCSP DCSP DCSP DCSP endpos = endline.find ( &apos; ; &apos; ) DCNL DCSP DCSP DCSP DCSP if ( not Match ( &apos; ; &#91; \ \ s } &#93; * ( \ \ \ \ ? ) $ &apos; , endline &#91; endpos : &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( not Match ( &apos; ^ &#91; ^ { } ; &#93; * \ \ &#91; &#91; ^ \ \ &#91; \ \ &#93; &#93; * \ \ &#93; &#91; ^ { } &#93; * \ \ { &#91; ^ { } &#93; * \ \ } \ \ s * \ \ ) * &#91; ; , &#93; \ \ s * $ &apos; , endline ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP error ( filename , linenum , &apos; readability / braces &apos; , 4 , &apos; If / else DCSP bodies DCSP with DCSP multiple DCSP statements DCSP require DCSP braces &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( endlinenum &lt; ( len ( clean _ lines.elided ) - 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP next _ line = clean _ lines.elided &#91; ( endlinenum + 1 ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP next _ indent = GetIndentLevel ( next _ line ) DCNL DCSP DCSP DCSP DCSP DCSP if ( if _ match and Match ( &apos; \ \ s * else \ \ b &apos; , next _ line ) and ( next _ indent ! = if _ indent ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP error ( filename , linenum , &apos; readability / braces &apos; , 4 , &apos; Else DCSP clause DCSP should DCSP be DCSP indented DCSP at DCSP the DCSP same DCSP level DCSP as DCSP if . DCSP Ambiguous DCSP nested DCSP if / else DCSP chains DCSP require DCSP braces . &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP elif ( next _ indent &gt; if _ indent ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP error ( filename , linenum , &apos; readability / braces &apos; , 4 , &apos; If / else DCSP bodies DCSP with DCSP multiple DCSP statements DCSP require DCSP braces &apos; )
DCSP restart ( name )
DCSP ( lower , value ) = validate ( option , value ) DCNL DCSP if ( lower not in _ AUTH _ OPTIONS ) : DCNL DCSP DCSP raise ConfigurationError ( ( &apos; Unknown DCSP authentication DCSP option : DCSP % s &apos; % ( option , ) ) ) DCNL DCSP return ( lower , value )
DCSP if isinstance ( it , ( list , tuple ) ) : DCNL DCSP DCSP return it DCNL DCSP return _ regen ( it )
DCSP if ( mode = = &apos; half _ away _ from _ zero &apos; ) : DCNL DCSP DCSP return round _ half _ away _ from _ zero ( a ) DCNL DCSP elif ( mode = = &apos; half _ to _ even &apos; ) : DCNL DCSP DCSP return round _ half _ to _ even ( a ) DCNL DCSP else : DCNL DCSP DCSP raise Exception ( ( &apos; round DCSP mode DCSP % s DCSP is DCSP not DCSP implemented . &apos; % mode ) )
DCSP ( sigspec , rv ) = _ check _ sigspec ( sigspec , func , _ sigs . _ is _ arity , n , func ) DCNL DCSP if ( sigspec is None ) : DCNL DCSP DCSP return rv DCNL DCSP num = num _ required _ args ( func , sigspec ) DCNL DCSP if ( num is not None ) : DCNL DCSP DCSP num = ( num = = n ) DCNL DCSP DCSP if ( not num ) : DCNL DCSP DCSP DCSP return False DCNL DCSP varargs = has _ varargs ( func , sigspec ) DCNL DCSP if varargs : DCNL DCSP DCSP return False DCNL DCSP keywords = has _ keywords ( func , sigspec ) DCNL DCSP if keywords : DCNL DCSP DCSP return False DCNL DCSP if ( ( num is None ) or ( varargs is None ) or ( keywords is None ) ) : DCNL DCSP DCSP return None DCNL DCSP return True
DCSP if ( value is None ) : DCNL DCSP DCSP raise ValueError ( u &apos;None DCSP is DCSP not DCSP a DCSP valid DCSP integer &apos; ) DCNL DCSP if ( not value.isdigit ( ) ) : DCNL DCSP DCSP raise ValueError ( u &apos;Only DCSP positive DCSP numbers DCSP are DCSP allowed &apos; ) DCNL DCSP return int ( value )
DCSP plays = &#91; &#93; DCNL DCSP seen _ ids = set ( ) DCNL DCSP seen _ desc = set ( ) DCNL DCSP for playid in map ( str , sorted ( map ( int , data ) ) ) : DCNL DCSP DCSP p = data &#91; playid &#93; DCNL DCSP DCSP desc = ( p &#91; &apos; desc &apos; &#93; , p &#91; &apos; time &apos; &#93; , p &#91; &apos; yrdln &apos; &#93; , p &#91; &apos; qtr &apos; &#93; ) DCNL DCSP DCSP if ( ( playid in seen _ ids ) or ( desc in seen _ desc ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP seen _ ids.add ( playid ) DCNL DCSP DCSP seen _ desc.add ( desc ) DCNL DCSP DCSP plays.append ( Play ( drive , playid , data &#91; playid &#93; ) ) DCNL DCSP return plays
DCSP if ( ( len ( path ) &gt; 0 ) and ( path &#91; ( -1 ) &#93; = = os.sep ) ) : DCNL DCSP DCSP return path DCNL DCSP else : DCNL DCSP DCSP return ( path + os.sep )
DCSP server = _ find _ server ( cs , args.server ) DCNL DCSP server.trigger _ crash _ dump ( )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ video _ set _ spu &apos; , None ) or _ Cfunction ( &apos; libvlc _ video _ set _ spu &apos; , ( ( 1 , ) , ( 1 , ) ) , None , ctypes.c _ int , MediaPlayer , ctypes.c _ int ) ) DCNL DCSP return f ( p _ mi , i _ spu )
DCSP result = K.zero DCNL DCSP for c in f : DCNL DCSP DCSP result * = a DCNL DCSP DCSP result + = c DCNL DCSP DCSP result % = p DCNL DCSP return result
DCSP return ( name in _ get _ svc _ list ( name ) )
DCSP print &apos; Test DCSP H2a DCSP - DCSP second DCSP repetition DCSP of DCSP the DCSP same DCSP sequence DCSP should DCSP not DCSP add DCSP synapses &apos; DCNL DCSP nFailed = 0 DCNL DCSP subsequenceStartPos = 10 DCNL DCSP assert ( subsequenceStartPos &lt; sequenceLength ) DCNL DCSP for numSequences in nSequences : DCNL DCSP DCSP print &apos; Higher DCSP order DCSP test DCSP with DCSP sequenceLength = &apos; , sequenceLength , DCNL DCSP DCSP print &apos; cellsPerColumn = &apos; , cellsPerColumn , &apos; nTests = &apos; , nTests , &apos; numCols = &apos; , numCols DCNL DCSP DCSP print &apos; numSequences = &apos; , numSequences , &apos; pctShared = &apos; , pctShared , DCNL DCSP DCSP print &apos; sharing DCSP mode = &apos; , seqGenMode DCNL DCSP DCSP for _ in range ( nTests ) : DCNL DCSP DCSP DCSP trainingSet = buildTrainingSet ( numSequences = numSequences , sequenceLength = sequenceLength , pctShared = pctShared , seqGenMode = seqGenMode , subsequenceStartPos = subsequenceStartPos , numCols = numCols , minOnes = 21 , maxOnes = 25 ) DCNL DCSP DCSP DCSP print &apos; = = = = = = = = = = = = = = DCSP 10 DCSP = = = = = = = = = = = = = = = = = = = = = = &apos; DCNL DCSP DCSP DCSP ( numFailures3 , numStrictErrors3 , numPerfect3 , tp3 ) = testSequence ( trainingSet , nTrainingReps = 10 , numberOfCols = numCols , cellsPerColumn = cellsPerColumn , initialPerm = 0.4 , connectedPerm = 0.7 , minThreshold = 12 , permanenceInc = 0.1 , permanenceDec = 0.1 , permanenceMax = 1 , globalDecay = 0.0 , newSynapseCount = 15 , activationThreshold = 12 , doPooling = False , shouldFail = shouldFail ) DCNL DCSP DCSP DCSP print &apos; = = = = = = = = = = = = = = DCSP 2 DCSP = = = = = = = = = = = = = = = = = = = = = = &apos; DCNL DCSP DCSP DCSP ( numFailures , numStrictErrors , numPerfect , tp2 ) = testSequence ( trainingSet , nTrainingReps = 2 , numberOfCols = numCols , cellsPerColumn = cellsPerColumn , initialPerm = 0.8 , connectedPerm = 0.7 , minThreshold = 12 , permanenceInc = 0.1 , permanenceDec = 0 , permanenceMax = 1 , globalDecay = 0.0 , newSynapseCount = 15 , activationThreshold = 12 , doPooling = False , shouldFail = shouldFail ) DCNL DCSP DCSP DCSP print &apos; = = = = = = = = = = = = = = DCSP 1 DCSP = = = = = = = = = = = = = = = = = = = = = = &apos; DCNL DCSP DCSP DCSP ( numFailures1 , numStrictErrors1 , numPerfect1 , tp1 ) = testSequence ( trainingSet , nTrainingReps = 1 , numberOfCols = numCols , cellsPerColumn = cellsPerColumn , initialPerm = 0.8 , connectedPerm = 0.7 , minThreshold = 12 , permanenceInc = 0.1 , permanenceDec = 0 , permanenceMax = 1 , globalDecay = 0.0 , newSynapseCount = 15 , activationThreshold = 12 , doPooling = False , shouldFail = shouldFail ) DCNL DCSP DCSP DCSP segmentInfo1 = tp1.getSegmentInfo ( ) DCNL DCSP DCSP DCSP segmentInfo2 = tp2.getSegmentInfo ( ) DCNL DCSP DCSP DCSP if ( ( abs ( ( segmentInfo1 &#91; 0 &#93; - segmentInfo2 &#91; 0 &#93; ) ) &gt; 3 ) or ( abs ( ( segmentInfo1 &#91; 1 &#93; - segmentInfo2 &#91; 1 &#93; ) ) &gt; ( 3 * 15 ) ) ) : DCNL DCSP DCSP DCSP DCSP print &apos; Training DCSP twice DCSP incorrectly DCSP resulted DCSP in DCSP too DCSP many DCSP segments DCSP or DCSP synapses &apos; DCNL DCSP DCSP DCSP DCSP print segmentInfo1 DCNL DCSP DCSP DCSP DCSP print segmentInfo2 DCNL DCSP DCSP DCSP DCSP print tp3.getSegmentInfo ( ) DCNL DCSP DCSP DCSP DCSP tp3.trimSegments ( ) DCNL DCSP DCSP DCSP DCSP print tp3.getSegmentInfo ( ) DCNL DCSP DCSP DCSP DCSP print &apos; Failures DCSP for DCSP 1 , DCSP 2 , DCSP and DCSP N DCSP reps &apos; DCNL DCSP DCSP DCSP DCSP print numFailures1 , numStrictErrors1 , numPerfect1 DCNL DCSP DCSP DCSP DCSP print numFailures , numStrictErrors , numPerfect DCNL DCSP DCSP DCSP DCSP print numFailures3 , numStrictErrors3 , numPerfect3 DCNL DCSP DCSP DCSP DCSP numFailures + = 1 DCNL DCSP DCSP DCSP if ( ( ( numFailures = = 0 ) and ( not shouldFail ) ) or ( ( numFailures &gt; 0 ) and shouldFail ) ) : DCNL DCSP DCSP DCSP DCSP print &apos; Test DCSP PASS &apos; , DCNL DCSP DCSP DCSP DCSP if shouldFail : DCNL DCSP DCSP DCSP DCSP DCSP print &apos; ( should DCSP fail , DCSP and DCSP failed ) &apos; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP print DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP print &apos; Test DCSP FAILED &apos; DCNL DCSP DCSP DCSP DCSP nFailed = ( nFailed + 1 ) DCNL DCSP DCSP DCSP DCSP print &apos; numFailures = &apos; , numFailures DCNL DCSP DCSP DCSP DCSP print &apos; numStrictErrors = &apos; , numStrictErrors DCNL DCSP DCSP DCSP DCSP print &apos; numPerfect = &apos; , numPerfect DCNL DCSP return nFailed
DCSP docs = Document.objects.filter _ for _ list ( locale = request.LANGUAGE _ CODE , toplevel = True ) DCNL DCSP paginated _ docs = paginate ( request , docs , per _ page = DOCUMENTS _ PER _ PAGE ) DCNL DCSP context = { &apos; documents &apos; : paginated _ docs , &apos; count &apos; : docs.count ( ) , &apos; toplevel &apos; : True } DCNL DCSP return render ( request , &apos; wiki / list / documents.html &apos; , context )
DCSP return getattr ( cls , INSTRUMENTATION _ MANAGER , None )
DCSP if ( len ( indexedLoop ) &lt; 3 ) : DCNL DCSP DCSP return DCNL DCSP remainingLoop = indexedLoop &#91; : &#93; DCNL DCSP while ( len ( remainingLoop ) &gt; 2 ) : DCNL DCSP DCSP remainingLoop = getRemainingLoopAddFace ( faces , remainingLoop )
DCSP return SerialModule ( mpstate )
DCSP projects = dict ( ) DCNL DCSP resources = dict ( ) DCNL DCSP def get _ ctx ( * args , * * kwargs ) : DCNL DCSP DCSP path = env.curbuf.name DCNL DCSP DCSP if resources.get ( path ) : DCNL DCSP DCSP DCSP return resources.get ( path ) DCNL DCSP DCSP project _ path = env.var ( &apos; g : pymode _ rope _ project _ root &apos; ) DCNL DCSP DCSP if ( not project _ path ) : DCNL DCSP DCSP DCSP project _ path = env.curdir DCNL DCSP DCSP DCSP env.debug ( &apos; Look DCSP ctx &apos; , project _ path ) DCNL DCSP DCSP DCSP if env.var ( &apos; g : pymode _ rope _ lookup _ project &apos; , True ) : DCNL DCSP DCSP DCSP DCSP project _ path = look _ ropeproject ( project _ path ) DCNL DCSP DCSP if ( not os.path.exists ( project _ path ) ) : DCNL DCSP DCSP DCSP env.error ( ( &apos; Rope DCSP project DCSP root DCSP not DCSP exist : DCSP % s &apos; % project _ path ) ) DCNL DCSP DCSP DCSP ctx = None DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ctx = projects.get ( project _ path ) DCNL DCSP DCSP if ( not ctx ) : DCNL DCSP DCSP DCSP projects &#91; project _ path &#93; = ctx = cls ( path , project _ path ) DCNL DCSP DCSP resources &#91; path &#93; = ctx DCNL DCSP DCSP return ctx DCNL DCSP return get _ ctx
DCSP today = date.today ( ) DCNL DCSP locales = get _ locales _ by _ visit ( ( today - timedelta ( days = 30 ) ) , today ) DCNL DCSP product = _ get _ product ( request ) DCNL DCSP return render ( request , &apos; dashboards / aggregated _ metrics.html &apos; , { &apos; locales _ json &apos; : json.dumps ( settings.SUMO _ LANGUAGES ) , &apos; locales &apos; : locales , &apos; product &apos; : product , &apos; products &apos; : Product.objects.filter ( visible = True ) } )
DCSP if ( response _ rewriters is None ) : DCNL DCSP DCSP response _ rewriters = CreateResponseRewritersChain ( ) DCNL DCSP response = AppServerResponse ( response _ file ) DCNL DCSP for response _ rewriter in response _ rewriters : DCNL DCSP DCSP if ( response _ rewriter.func _ code.co _ argcount = = 1 ) : DCNL DCSP DCSP DCSP response _ rewriter ( response ) DCNL DCSP DCSP elif ( response _ rewriter.func _ code.co _ argcount = = 2 ) : DCNL DCSP DCSP DCSP response _ rewriter ( response , request _ headers ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP response _ rewriter ( response , request _ headers , env _ dict ) DCNL DCSP return response
DCSP totalPitchRadius = ( derivation.pitchRadiusComplement + derivation.pitchRadius ) DCNL DCSP totalTeeth = ( derivation.teethPinion + derivation.teethComplement ) DCNL DCSP portionDirections = extrude.getSpacedPortionDirections ( extrudeDerivation.interpolationDictionary ) DCNL DCSP loopLists = extrude.getLoopListsByPath ( extrudeDerivation , None , vector3GearProfile &#91; 0 &#93; , portionDirections ) DCNL DCSP firstLoopList = loopLists &#91; 0 &#93; DCNL DCSP gearOverPinion = ( float ( ( totalTeeth - teeth ) ) / float ( teeth ) ) DCNL DCSP thirdLayerHeight = ( 0.33333333333 * setting.getLayerHeight ( derivation.elementNode ) ) DCNL DCSP pitchRadian = math.atan ( ( math.sin ( derivation.operatingRadian ) / ( gearOverPinion + math.cos ( derivation.operatingRadian ) ) ) ) DCNL DCSP coneDistance = ( pitchRadius / math.sin ( pitchRadian ) ) DCNL DCSP apex = Vector3 ( 0.0 , 0.0 , math.sqrt ( ( ( coneDistance * coneDistance ) - ( pitchRadius * pitchRadius ) ) ) ) DCNL DCSP cosPitch = ( apex.z / coneDistance ) DCNL DCSP sinPitch = math.sin ( pitchRadian ) DCNL DCSP for loop in firstLoopList : DCNL DCSP DCSP for point in loop : DCNL DCSP DCSP DCSP alongWay = ( point.z / coneDistance ) DCNL DCSP DCSP DCSP oneMinusAlongWay = ( 1.0 - alongWay ) DCNL DCSP DCSP DCSP pointComplex = point.dropAxis ( ) DCNL DCSP DCSP DCSP pointComplexLength = abs ( pointComplex ) DCNL DCSP DCSP DCSP deltaRadius = ( pointComplexLength - pitchRadius ) DCNL DCSP DCSP DCSP cosDeltaRadius = ( cosPitch * deltaRadius ) DCNL DCSP DCSP DCSP sinDeltaRadius = ( sinPitch * deltaRadius ) DCNL DCSP DCSP DCSP pointComplex * = ( ( cosDeltaRadius + pitchRadius ) / pointComplexLength ) DCNL DCSP DCSP DCSP point.x = pointComplex.real DCNL DCSP DCSP DCSP point.y = pointComplex.imag DCNL DCSP DCSP DCSP point.z + = sinDeltaRadius DCNL DCSP DCSP DCSP point.x * = oneMinusAlongWay DCNL DCSP DCSP DCSP point.y * = oneMinusAlongWay DCNL DCSP addBottomLoop ( ( - thirdLayerHeight ) , firstLoopList ) DCNL DCSP topLoop = firstLoopList &#91; ( -1 ) &#93; DCNL DCSP topAddition = &#91; &#93; DCNL DCSP topZ = ( euclidean.getTopPath ( topLoop ) + thirdLayerHeight ) DCNL DCSP oldIndex = topLoop &#91; ( -1 ) &#93; .index DCNL DCSP for point in topLoop : DCNL DCSP DCSP oldIndex + = 1 DCNL DCSP DCSP topAddition.append ( Vector3Index ( oldIndex , ( 0.8 * point.x ) , ( 0.8 * point.y ) , topZ ) ) DCNL DCSP firstLoopList.append ( topAddition ) DCNL DCSP translation = Vector3 ( 0.0 , 0.0 , ( - euclidean.getBottomByPaths ( firstLoopList ) ) ) DCNL DCSP euclidean.translateVector3Paths ( firstLoopList , translation ) DCNL DCSP geometryOutput = triangle _ mesh.getPillarsOutput ( loopLists ) DCNL DCSP positives.append ( geometryOutput )
DCSP t.lexer.paren _ count + = 1 DCNL DCSP return t
DCSP lcache = os.path.join ( os.path.dirname ( os.path.dirname ( dst ) ) , &apos; .link _ cache &apos; ) DCNL DCSP if ( not os.path.isdir ( lcache ) ) : DCNL DCSP DCSP os.mkdir ( lcache ) DCNL DCSP key = hashfile ( src , lcache = lcache , logger = logger ) DCNL DCSP cachefile = os.path.join ( lcache , key ) DCNL DCSP if ( not os.path.exists ( cachefile ) ) : DCNL DCSP DCSP logger.info ( ( &apos; trying DCSP to DCSP create DCSP cache DCSP file DCSP % s &apos; % cachefile ) ) DCNL DCSP DCSP copyfile ( src , cachefile , api = api , logger = logger ) DCNL DCSP logger.debug ( ( &apos; trying DCSP cachelink DCSP % s DCSP - &gt; DCSP % s DCSP - &gt; DCSP % s &apos; % ( src , cachefile , dst ) ) ) DCNL DCSP os.link ( cachefile , dst )
DCSP try : DCNL DCSP DCSP course _ updates = modulestore ( ) .get _ item ( location ) DCNL DCSP except ItemNotFoundError : DCNL DCSP DCSP course _ updates = modulestore ( ) .create _ item ( user _ id , location.course _ key , location.block _ type , location.block _ id ) DCNL DCSP course _ update _ items = get _ course _ update _ items ( course _ updates , _ get _ index ( provided _ id ) ) DCNL DCSP return _ get _ visible _ update ( course _ update _ items )
DCSP r = requests.get ( url , allow _ redirects = False ) DCNL DCSP status = ( r.status _ code = = 302 ) DCNL DCSP perl = ( ( &apos; x-perl-redirect &apos; in r.headers ) and ( r.headers &#91; &apos; x-perl-redirect &apos; &#93; = = &apos; True &apos; ) ) DCNL DCSP return all ( &#91; status , perl &#93; )
DCSP return ( ( ( np.sin ( ( x * 5 ) ) / x ) + ( 2.0 * x ) ) - ( 1.0 * ( x * * 2 ) ) )
DCSP user _ library _ info = get _ user _ library _ info ( openid ) DCNL DCSP if user _ library _ info : DCNL DCSP DCSP cipher = AESCipher ( app.config &#91; &apos; PASSWORD _ SECRET _ KEY &apos; &#93; ) DCNL DCSP DCSP librarypwd = cipher.decrypt ( user _ library _ info &#91; &apos; librarypwd &apos; &#93; ) DCNL DCSP DCSP library.borrowing _ record.delay ( openid , user _ library _ info &#91; &apos; libraryid &apos; &#93; , librarypwd , renew = renew ) DCNL DCSP DCSP return wechat.response _ text ( content ) DCNL DCSP else : DCNL DCSP DCSP url = ( ( app.config &#91; &apos; HOST _ URL &apos; &#93; + &apos; / auth-library / &apos; ) + openid ) DCNL DCSP DCSP content = ( app.config &#91; &apos; AUTH _ LIBRARY _ TEXT &apos; &#93; % url ) DCNL DCSP DCSP return wechat.response _ text ( content )
DCSP return string.translate ( b , B64C _ TRANSLATE , B64C _ STRIP )
DCSP if ( u not in G ) : DCNL DCSP DCSP raise nx.NetworkXError ( &apos; u DCSP is DCSP not DCSP in DCSP the DCSP graph . &apos; ) DCNL DCSP if ( v not in G ) : DCNL DCSP DCSP raise nx.NetworkXError ( &apos; v DCSP is DCSP not DCSP in DCSP the DCSP graph . &apos; ) DCNL DCSP return ( w for w in G &#91; u &#93; if ( ( w in G &#91; v &#93; ) and ( w not in ( u , v ) ) ) )
DCSP if ( not patterns ) : DCNL DCSP DCSP return default DCNL DCSP return any ( ( fnmatch ( filename , pattern ) for pattern in patterns ) )
DCSP from boto.configservice.layer1 import ConfigServiceConnection DCNL DCSP return ConfigServiceConnection ( aws _ access _ key _ id = aws _ access _ key _ id , aws _ secret _ access _ key = aws _ secret _ access _ key , * * kwargs )
DCSP cs.floating _ ips _ bulk.create ( args.ip _ range , args.pool , args.interface )
DCSP enc = locale.getpreferredencoding ( ) DCNL DCSP try : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return s.decode ( enc ) DCNL DCSP DCSP except LookupError : DCNL DCSP DCSP DCSP enc = _ DEFAULT _ ENCODING DCNL DCSP DCSP return s.decode ( enc ) DCNL DCSP except UnicodeDecodeError : DCNL DCSP DCSP return s.decode ( u &apos;latin-1 &apos; )
DCSP set _ mysql _ engine ( ) DCNL DCSP kwargs = dict ( ) DCNL DCSP if neutron _ config.database.connection : DCNL DCSP DCSP kwargs &#91; &apos; url &apos; &#93; = neutron _ config.database.connection DCNL DCSP else : DCNL DCSP DCSP kwargs &#91; &apos; dialect _ name &apos; &#93; = neutron _ config.database.engine DCNL DCSP kwargs &#91; &apos; include _ object &apos; &#93; = include _ object DCNL DCSP context.configure ( * * kwargs ) DCNL DCSP with context.begin _ transaction ( ) : DCNL DCSP DCSP context.run _ migrations ( )
DCSP task _ schema = get _ task _ schema ( ) DCNL DCSP partial _ task _ schema = _ get _ partial _ task _ schema ( ) DCNL DCSP deserializer = RequestDeserializer ( task _ schema ) DCNL DCSP serializer = ResponseSerializer ( task _ schema , partial _ task _ schema ) DCNL DCSP controller = TasksController ( ) DCNL DCSP return wsgi.Resource ( controller , deserializer , serializer )
DCSP return And.make _ args ( expr )
DCSP if ( parse _ boolean _ envvar ( os.getenv ( &apos; WALE _ GS _ INTEGRATION _ TESTS &apos; ) ) is not True ) : DCNL DCSP DCSP return True DCNL DCSP if ( os.getenv ( &apos; GOOGLE _ APPLICATION _ CREDENTIALS &apos; ) is None ) : DCNL DCSP DCSP return True DCNL DCSP return False
DCSP files _ to _ docs = defaultdict ( list ) DCNL DCSP for ( doc , files ) in docs _ links.iteritems ( ) : DCNL DCSP DCSP for file in files : DCNL DCSP DCSP DCSP files _ to _ docs &#91; file &#93; .append ( doc ) DCNL DCSP DCSP DCSP files _ to _ docs &#91; file &#93; = list ( set ( files _ to _ docs &#91; file &#93; ) ) DCNL DCSP return files _ to _ docs
DCSP course _ key = CourseKey.from _ string ( course _ id ) DCNL DCSP certs _ api.generate _ example _ certificates ( course _ key ) DCNL DCSP return redirect ( _ instructor _ dash _ url ( course _ key , section = &apos; certificates &apos; ) )
DCSP try : DCNL DCSP DCSP from . import saltnado DCNL DCSP except ImportError as err : DCNL DCSP DCSP logger.error ( &apos; ImportError ! DCSP { 0 } &apos; .format ( str ( err ) ) ) DCNL DCSP DCSP return None DCNL DCSP mod _ opts = _ _ opts _ _ .get ( _ _ virtualname _ _ , { } ) DCNL DCSP if ( &apos; num _ processes &apos; not in mod _ opts ) : DCNL DCSP DCSP mod _ opts &#91; &apos; num _ processes &apos; &#93; = 1 DCNL DCSP if ( ( mod _ opts &#91; &apos; num _ processes &apos; &#93; &gt; 1 ) and ( mod _ opts.get ( &apos; debug &apos; , False ) is True ) ) : DCNL DCSP DCSP raise Exception ( &quot; Tornado &apos;s DCSP debug DCSP implementation DCSP is DCSP not DCSP compatible DCSP with DCSP multiprocess . DCSP Either DCSP disable DCSP debug , DCSP or DCSP set DCSP num _ processes DCSP to DCSP 1 . &quot; ) DCNL DCSP paths = &#91; ( &apos; / &apos; , saltnado.SaltAPIHandler ) , ( &apos; / login &apos; , saltnado.SaltAuthHandler ) , ( &apos; / minions / ( . * ) &apos; , saltnado.MinionSaltAPIHandler ) , ( &apos; / minions &apos; , saltnado.MinionSaltAPIHandler ) , ( &apos; / jobs / ( . * ) &apos; , saltnado.JobsSaltAPIHandler ) , ( &apos; / jobs &apos; , saltnado.JobsSaltAPIHandler ) , ( &apos; / run &apos; , saltnado.RunSaltAPIHandler ) , ( &apos; / events &apos; , saltnado.EventsSaltAPIHandler ) , ( &apos; / hook ( / . * ) ? &apos; , saltnado.WebhookSaltAPIHandler ) &#93; DCNL DCSP if mod _ opts.get ( &apos; websockets &apos; , False ) : DCNL DCSP DCSP from . import saltnado _ websockets DCNL DCSP DCSP token _ pattern = &apos; ( &#91; 0-9A-Fa-f &#93; { { { 0 } } } ) &apos; .format ( len ( getattr ( hashlib , _ _ opts _ _ .get ( &apos; hash _ type &apos; , &apos; md5 &apos; ) ) ( ) .hexdigest ( ) ) ) DCNL DCSP DCSP all _ events _ pattern = &apos; / all _ events / { 0 } &apos; .format ( token _ pattern ) DCNL DCSP DCSP formatted _ events _ pattern = &apos; / formatted _ events / { 0 } &apos; .format ( token _ pattern ) DCNL DCSP DCSP logger.debug ( &apos; All DCSP events DCSP URL DCSP pattern DCSP is DCSP { 0 } &apos; .format ( all _ events _ pattern ) ) DCNL DCSP DCSP paths + = &#91; ( all _ events _ pattern , saltnado _ websockets.AllEventsHandler ) , ( formatted _ events _ pattern , saltnado _ websockets.FormattedEventsHandler ) &#93; DCNL DCSP application = tornado.web.Application ( paths , debug = mod _ opts.get ( &apos; debug &apos; , False ) ) DCNL DCSP application.opts = _ _ opts _ _ DCNL DCSP application.mod _ opts = mod _ opts DCNL DCSP application.auth = salt.auth.LoadAuth ( _ _ opts _ _ ) DCNL DCSP kwargs = { } DCNL DCSP if ( not mod _ opts.get ( &apos; disable _ ssl &apos; , False ) ) : DCNL DCSP DCSP if ( &apos; ssl _ crt &apos; not in mod _ opts ) : DCNL DCSP DCSP DCSP logger.error ( &quot; Not DCSP starting DCSP &apos; % s &apos; . DCSP Options DCSP &apos; ssl _ crt &apos; DCSP and DCSP &apos; ssl _ key &apos; DCSP are DCSP required DCSP if DCSP SSL DCSP is DCSP not DCSP disabled . &quot; , _ _ name _ _ ) DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP ssl _ opts = { &apos; certfile &apos; : mod _ opts &#91; &apos; ssl _ crt &apos; &#93; } DCNL DCSP DCSP if mod _ opts.get ( &apos; ssl _ key &apos; , False ) : DCNL DCSP DCSP DCSP ssl _ opts.update ( { &apos; keyfile &apos; : mod _ opts &#91; &apos; ssl _ key &apos; &#93; } ) DCNL DCSP DCSP kwargs &#91; &apos; ssl _ options &apos; &#93; = ssl _ opts DCNL DCSP http _ server = tornado.httpserver.HTTPServer ( application , * * kwargs ) DCNL DCSP try : DCNL DCSP DCSP http _ server.bind ( mod _ opts &#91; &apos; port &apos; &#93; , address = mod _ opts.get ( &apos; address &apos; ) , backlog = mod _ opts.get ( &apos; backlog &apos; , 128 ) ) DCNL DCSP DCSP http _ server.start ( mod _ opts &#91; &apos; num _ processes &apos; &#93; ) DCNL DCSP except : DCNL DCSP DCSP logger.error ( &apos; Rest _ tornado DCSP unable DCSP to DCSP bind DCSP to DCSP port DCSP { 0 } &apos; .format ( mod _ opts &#91; &apos; port &apos; &#93; ) , exc _ info = True ) DCNL DCSP DCSP raise SystemExit ( 1 ) DCNL DCSP try : DCNL DCSP DCSP tornado.ioloop.IOLoop.instance ( ) .start ( ) DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP raise SystemExit ( 0 )
DCSP if ( transform _ test is None ) : DCNL DCSP DCSP transform _ test = transform _ valid DCNL DCSP kwargs = subdict ( conf , &#91; &apos; dataset &apos; , &apos; normalize &apos; , &apos; normalize _ on _ the _ fly &apos; , &apos; sparse &apos; &#93; ) DCNL DCSP kwargs.update ( randomize _ valid = False , randomize _ test = False ) DCNL DCSP ( valid _ set , test _ set ) = load _ data ( kwargs ) &#91; 1 : 3 &#93; DCNL DCSP if ( not conf.get ( &apos; sparse &apos; , False ) ) : DCNL DCSP DCSP valid _ set = valid _ set.get _ value ( borrow = True ) DCNL DCSP DCSP test _ set = test _ set.get _ value ( borrow = True ) DCNL DCSP if ( features is not None ) : DCNL DCSP DCSP valid _ set = valid _ set &#91; : , features &#93; DCNL DCSP DCSP test _ set = test _ set &#91; : , features &#93; DCNL DCSP valid _ repr = transform _ valid ( valid _ set ) DCNL DCSP test _ repr = transform _ test ( test _ set ) DCNL DCSP save _ submission ( conf , valid _ repr , test _ repr )
DCSP from sympy.core.compatibility import maketrans DCNL DCSP try : DCNL DCSP DCSP &apos; &apos;.translate ( None , &apos; &apos; ) DCNL DCSP DCSP py3 = False DCNL DCSP except TypeError : DCNL DCSP DCSP py3 = True DCNL DCSP mr = { } DCNL DCSP if ( a is None ) : DCNL DCSP DCSP assert ( c is None ) DCNL DCSP DCSP if ( not b ) : DCNL DCSP DCSP DCSP return s DCNL DCSP DCSP c = b DCNL DCSP DCSP a = b = &apos; &apos; DCNL DCSP elif ( type ( a ) is dict ) : DCNL DCSP DCSP short = { } DCNL DCSP DCSP for k in list ( a.keys ( ) ) : DCNL DCSP DCSP DCSP if ( ( len ( k ) = = 1 ) and ( len ( a &#91; k &#93; ) = = 1 ) ) : DCNL DCSP DCSP DCSP DCSP short &#91; k &#93; = a.pop ( k ) DCNL DCSP DCSP mr = a DCNL DCSP DCSP c = b DCNL DCSP DCSP if short : DCNL DCSP DCSP DCSP ( a , b ) = &#91; &apos; &apos;.join ( i ) for i in list ( zip ( * short.items ( ) ) ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP a = b = &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP assert ( len ( a ) = = len ( b ) ) DCNL DCSP if py3 : DCNL DCSP DCSP if c : DCNL DCSP DCSP DCSP s = s.translate ( maketrans ( &apos; &apos; , &apos; &apos; , c ) ) DCNL DCSP DCSP s = replace ( s , mr ) DCNL DCSP DCSP return s.translate ( maketrans ( a , b ) ) DCNL DCSP else : DCNL DCSP DCSP if c : DCNL DCSP DCSP DCSP c = list ( c ) DCNL DCSP DCSP DCSP rem = { } DCNL DCSP DCSP DCSP for i in range ( ( -1 ) , ( ( -1 ) - len ( c ) ) , ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP if ( ord ( c &#91; i &#93; ) &gt; 255 ) : DCNL DCSP DCSP DCSP DCSP DCSP rem &#91; c &#91; i &#93; &#93; = &apos; &apos; DCNL DCSP DCSP DCSP DCSP DCSP c.pop ( i ) DCNL DCSP DCSP DCSP s = s.translate ( None , &apos; &apos;.join ( c ) ) DCNL DCSP DCSP DCSP s = replace ( s , rem ) DCNL DCSP DCSP DCSP if a : DCNL DCSP DCSP DCSP DCSP a = list ( a ) DCNL DCSP DCSP DCSP DCSP b = list ( b ) DCNL DCSP DCSP DCSP DCSP for i in range ( ( -1 ) , ( ( -1 ) - len ( a ) ) , ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( ord ( a &#91; i &#93; ) &gt; 255 ) or ( ord ( b &#91; i &#93; ) &gt; 255 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP mr &#91; a.pop ( i ) &#93; = b.pop ( i ) DCNL DCSP DCSP DCSP DCSP a = &apos; &apos;.join ( a ) DCNL DCSP DCSP DCSP DCSP b = &apos; &apos;.join ( b ) DCNL DCSP DCSP s = replace ( s , mr ) DCNL DCSP DCSP table = maketrans ( a , b ) DCNL DCSP DCSP if ( ( type ( table ) is str ) and ( type ( s ) is str ) ) : DCNL DCSP DCSP DCSP s = s.translate ( table ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP s = s.translate ( dict ( &#91; ( i , ord ( c ) ) for ( i , c ) in enumerate ( table ) &#93; ) ) DCNL DCSP DCSP return s
DCSP sla = get _ object _ or _ 404 ( ServiceLevelAgreement , pk = sla _ id ) DCNL DCSP if ( not request.user.profile.has _ permission ( sla ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Service DCSP Level DCSP Agreement &quot; ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; sla &apos; : sla } ) DCNL DCSP return render _ to _ response ( &apos; services / sla _ view &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP rc = re.compile ( &apos; &#124; &apos; .join ( map ( re.escape , word _ dic ) ) ) DCNL DCSP def translate ( match ) : DCNL DCSP DCSP return word _ dic &#91; match.group ( 0 ) &#93; DCNL DCSP return rc.sub ( translate , text )
DCSP _ check _ is _ integral ( &apos; azimuth &apos; , label ) DCNL DCSP if ( label = = ( -1 ) ) : DCNL DCSP DCSP return None DCNL DCSP else : DCNL DCSP DCSP if ( ( ( label % 2 ) ! = 0 ) or ( label &lt; 0 ) or ( label &gt; 34 ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Expected DCSP azimuth DCSP to DCSP be DCSP an DCSP even DCSP number DCSP between DCSP 0 DCSP and DCSP 34 DCSP inclusive , DCSP or DCSP -1 , DCSP but DCSP got DCSP % s DCSP instead . &apos; % str ( label ) ) ) DCNL DCSP DCSP return ( label * 10 )
DCSP is _ automated = False DCNL DCSP try : DCNL DCSP DCSP dist _ dir _ i = sys.argv.index ( &apos; --dist-dir &apos; ) DCNL DCSP except ValueError : DCNL DCSP DCSP dist _ dir _ i = None DCNL DCSP if ( dist _ dir _ i is not None ) : DCNL DCSP DCSP dist _ dir = sys.argv &#91; ( dist _ dir _ i + 1 ) &#93; DCNL DCSP DCSP if ( &apos; egg-dist-tmp &apos; in dist _ dir ) : DCNL DCSP DCSP DCSP is _ automated = True DCNL DCSP if ( ( sys.argv in &#91; &#91; &apos; -c &apos; , &apos; develop &apos; , &apos; --no-deps &apos; &#93; , &#91; &apos; --no-deps &apos; , &apos; -c &apos; , &apos; develop &apos; &#93; , &#91; &apos; -c &apos; , &apos; egg _ info &apos; &#93; &#93; ) or ( &apos; pip-egg-info &apos; in sys.argv ) or ( sys.argv &#91; : 3 &#93; = = &#91; &apos; -c &apos; , &apos; install &apos; , &apos; --record &apos; &#93; ) or ( sys.argv &#91; : 4 &#93; = = &#91; &apos; -c &apos; , &apos; install &apos; , &apos; --single-version-externally-managed &apos; , &apos; --record &apos; &#93; ) ) : DCNL DCSP DCSP is _ automated = True DCNL DCSP return is _ automated
DCSP if ( ( not on _ win ) or ( shell ! = u &apos;cmd.exe &apos; ) ) : DCNL DCSP DCSP pytest.skip ( u &quot; echo DCSP leaking DCSP is DCSP only DCSP relevant DCSP on DCSP Window &apos;s DCSP CMD.EXE &quot; ) DCNL DCSP shell _ vars = _ format _ vars ( shell ) DCNL DCSP with TemporaryDirectory ( prefix = u &apos;envs &apos; , dir = os.path.dirname ( _ _ file _ _ ) ) as envs : DCNL DCSP DCSP ( env _ dirs , env _ vars ) = gen _ test _ env _ paths ( envs , shell ) DCNL DCSP DCSP scripts = &#91; &#93; DCNL DCSP DCSP src _ activate = shell _ vars &#91; u &apos;source &apos; &#93; .format ( u &apos; { syspath } { binpath } activate { suffix _ executable } &apos; ) DCNL DCSP DCSP scripts + = &#91; dedent ( u &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP @ ECHO DCSP ON \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP { } DCSP &quot; { { env _ dirs &#91; 0 &#93; } } &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP @ ECHO \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; ) &#93; DCNL DCSP DCSP for script in scripts : DCNL DCSP DCSP DCSP script = script.format ( src _ activate ) DCNL DCSP DCSP DCSP script = script.format ( env _ vars = env _ vars , env _ dirs = env _ dirs , * * shell _ vars ) DCNL DCSP DCSP DCSP commands = ( shell _ vars &#91; u &apos;command _ setup &apos; &#93; + script ) DCNL DCSP DCSP DCSP ( stdout , stderr ) = run _ in ( commands , shell ) DCNL DCSP DCSP DCSP print ( u &apos;commands : &apos; , commands ) DCNL DCSP DCSP DCSP print ( u &apos;stdout : &apos; , stdout ) DCNL DCSP DCSP DCSP print ( u &apos;stderr : &apos; , stderr ) DCNL DCSP DCSP DCSP assert _ equals ( stdout , u &apos;ECHO DCSP is DCSP on . &apos; , stderr ) DCNL DCSP DCSP DCSP assert _ equals ( stderr , u &apos; &apos; )
DCSP Q = gf _ Qmatrix ( f , p , K ) DCNL DCSP V = gf _ Qbasis ( Q , p , K ) DCNL DCSP for ( i , v ) in enumerate ( V ) : DCNL DCSP DCSP V &#91; i &#93; = gf _ strip ( list ( reversed ( v ) ) ) DCNL DCSP factors = &#91; f &#93; DCNL DCSP for k in range ( 1 , len ( V ) ) : DCNL DCSP DCSP for f in list ( factors ) : DCNL DCSP DCSP DCSP s = K.zero DCNL DCSP DCSP DCSP while ( s &lt; p ) : DCNL DCSP DCSP DCSP DCSP g = gf _ sub _ ground ( V &#91; k &#93; , s , p , K ) DCNL DCSP DCSP DCSP DCSP h = gf _ gcd ( f , g , p , K ) DCNL DCSP DCSP DCSP DCSP if ( ( h ! = &#91; K.one &#93; ) and ( h ! = f ) ) : DCNL DCSP DCSP DCSP DCSP DCSP factors.remove ( f ) DCNL DCSP DCSP DCSP DCSP DCSP f = gf _ quo ( f , h , p , K ) DCNL DCSP DCSP DCSP DCSP DCSP factors.extend ( &#91; f , h &#93; ) DCNL DCSP DCSP DCSP DCSP if ( len ( factors ) = = len ( V ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return _ sort _ factors ( factors , multiple = False ) DCNL DCSP DCSP DCSP DCSP s + = K.one DCNL DCSP return _ sort _ factors ( factors , multiple = False )
DCSP party _ type = None DCNL DCSP for ( key , doctypes ) in status _ depends _ on.iteritems ( ) : DCNL DCSP DCSP if ( doc.doctype in doctypes ) : DCNL DCSP DCSP DCSP party _ type = key DCNL DCSP DCSP DCSP break DCNL DCSP if ( not party _ type ) : DCNL DCSP DCSP return DCNL DCSP name = doc.get ( party _ type.lower ( ) ) DCNL DCSP if ( not name ) : DCNL DCSP DCSP return DCNL DCSP party = frappe.get _ doc ( party _ type , name ) DCNL DCSP filters = get _ filters _ for ( doc.doctype ) DCNL DCSP party.flags.ignore _ mandatory = True DCNL DCSP status = None DCNL DCSP if filters : DCNL DCSP DCSP if evaluate _ filters ( doc , filters ) : DCNL DCSP DCSP DCSP status = u &apos;Open &apos; DCNL DCSP if ( status = = u &apos;Open &apos; ) : DCNL DCSP DCSP if ( party.status ! = u &apos;Open &apos; ) : DCNL DCSP DCSP DCSP party.status = u &apos;Open &apos; DCNL DCSP DCSP DCSP party.save ( ignore _ permissions = True ) DCNL DCSP elif ( party.status = = u &apos;Open &apos; ) : DCNL DCSP DCSP update _ status ( party ) DCNL DCSP party.update _ modified ( ) DCNL DCSP party.notify _ update ( )
DCSP def _ fn ( self , item ) : DCNL DCSP DCSP return ajax _ editable _ boolean _ cell ( item , attr ) DCNL DCSP _ fn.short _ description = short _ description DCNL DCSP _ fn.editable _ boolean _ field = attr DCNL DCSP return _ fn
DCSP keyring = { } DCNL DCSP for keytext in textring : DCNL DCSP DCSP keyname = dns.name.from _ text ( keytext ) DCNL DCSP DCSP secret = base64.decodestring ( textring &#91; keytext &#93; ) DCNL DCSP DCSP keyring &#91; keyname &#93; = secret DCNL DCSP return keyring
DCSP use _ aesni = dict _ parameters.pop ( &apos; use _ aesni &apos; , True ) DCNL DCSP try : DCNL DCSP DCSP key = dict _ parameters.pop ( &apos; key &apos; ) DCNL DCSP except KeyError : DCNL DCSP DCSP raise TypeError ( &quot; Missing DCSP &apos; key &apos; DCSP parameter &quot; ) DCNL DCSP expect _ byte _ string ( key ) DCNL DCSP if ( len ( key ) not in key _ size ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Incorrect DCSP AES DCSP key DCSP length DCSP ( % d DCSP bytes ) &apos; % len ( key ) ) ) DCNL DCSP if ( use _ aesni and _ raw _ aesni _ lib ) : DCNL DCSP DCSP start _ operation = _ raw _ aesni _ lib.AESNI _ start _ operation DCNL DCSP DCSP stop _ operation = _ raw _ aesni _ lib.AESNI _ stop _ operation DCNL DCSP else : DCNL DCSP DCSP start _ operation = _ raw _ aes _ lib.AES _ start _ operation DCNL DCSP DCSP stop _ operation = _ raw _ aes _ lib.AES _ stop _ operation DCNL DCSP cipher = VoidPointer ( ) DCNL DCSP result = start _ operation ( key , c _ size _ t ( len ( key ) ) , cipher.address _ of ( ) ) DCNL DCSP if result : DCNL DCSP DCSP raise ValueError ( ( &apos; Error DCSP % X DCSP while DCSP instantiating DCSP the DCSP AES DCSP cipher &apos; % result ) ) DCNL DCSP return SmartPointer ( cipher.get ( ) , stop _ operation )
DCSP return ( ( not sum ( ( ( 0 if ( x = = y ) else 1 ) for ( x , y ) in zip ( a , b ) ) ) ) and ( len ( a ) = = len ( b ) ) )
DCSP serv = _ get _ serv ( ret = None ) DCNL DCSP sql = &apos; select DCSP distinct ( id ) DCSP from DCSP returns &apos; DCNL DCSP data = serv.query ( sql ) DCNL DCSP ret = &#91; &#93; DCNL DCSP if data : DCNL DCSP DCSP for jid in data &#91; 0 &#93; &#91; &apos; points &apos; &#93; : DCNL DCSP DCSP DCSP ret.append ( jid &#91; 1 &#93; ) DCNL DCSP return ret
DCSP return set ( &#91; k for ( k , v ) in six.iteritems ( REPORT _ WRITERS _ MAP ) if v &#93; )
DCSP pip _ bin = _ get _ pip _ bin ( bin _ env ) DCNL DCSP cmd = &#91; pip _ bin , &apos; install &apos; &#93; DCNL DCSP ( cleanup _ requirements , error ) = _ process _ requirements ( requirements = requirements , cmd = cmd , cwd = cwd , saltenv = saltenv , user = user ) DCNL DCSP if error : DCNL DCSP DCSP return error DCNL DCSP if use _ wheel : DCNL DCSP DCSP min _ version = &apos; 1.4 &apos; DCNL DCSP DCSP cur _ version = _ _ salt _ _ &#91; &apos; pip.version &apos; &#93; ( bin _ env ) DCNL DCSP DCSP if ( not salt.utils.compare _ versions ( ver1 = cur _ version , oper = &apos; &gt; = &apos; , ver2 = min _ version ) ) : DCNL DCSP DCSP DCSP logger.error ( &apos; The DCSP --use-wheel DCSP option DCSP is DCSP only DCSP supported DCSP in DCSP pip DCSP { 0 } DCSP and DCSP newer . DCSP The DCSP version DCSP of DCSP pip DCSP detected DCSP is DCSP { 1 } . DCSP This DCSP option DCSP will DCSP be DCSP ignored . &apos; .format ( min _ version , cur _ version ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cmd.append ( &apos; --use-wheel &apos; ) DCNL DCSP if no _ use _ wheel : DCNL DCSP DCSP min _ version = &apos; 1.4 &apos; DCNL DCSP DCSP cur _ version = _ _ salt _ _ &#91; &apos; pip.version &apos; &#93; ( bin _ env ) DCNL DCSP DCSP if ( not salt.utils.compare _ versions ( ver1 = cur _ version , oper = &apos; &gt; = &apos; , ver2 = min _ version ) ) : DCNL DCSP DCSP DCSP logger.error ( &apos; The DCSP --no-use-wheel DCSP option DCSP is DCSP only DCSP supported DCSP in DCSP pip DCSP { 0 } DCSP and DCSP newer . DCSP The DCSP version DCSP of DCSP pip DCSP detected DCSP is DCSP { 1 } . DCSP This DCSP option DCSP will DCSP be DCSP ignored . &apos; .format ( min _ version , cur _ version ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cmd.append ( &apos; --no-use-wheel &apos; ) DCNL DCSP if log : DCNL DCSP DCSP if os.path.isdir ( log ) : DCNL DCSP DCSP DCSP raise IOError ( &quot; &apos; { 0 } &apos; DCSP is DCSP a DCSP directory . DCSP Use DCSP --log DCSP path _ to _ file &quot; .format ( log ) ) DCNL DCSP DCSP elif ( not os.access ( log , os.W _ OK ) ) : DCNL DCSP DCSP DCSP raise IOError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP writeable &quot; .format ( log ) ) DCNL DCSP DCSP cmd.extend ( &#91; &apos; --log &apos; , log &#93; ) DCNL DCSP if proxy : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --proxy &apos; , proxy &#93; ) DCNL DCSP if timeout : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if isinstance ( timeout , float ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Timeout DCSP cannot DCSP be DCSP a DCSP float &apos; ) DCNL DCSP DCSP DCSP int ( timeout ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise ValueError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP valid DCSP timeout , DCSP must DCSP be DCSP an DCSP integer &quot; .format ( timeout ) ) DCNL DCSP DCSP cmd.extend ( &#91; &apos; --timeout &apos; , timeout &#93; ) DCNL DCSP if find _ links : DCNL DCSP DCSP if isinstance ( find _ links , string _ types ) : DCNL DCSP DCSP DCSP find _ links = &#91; l.strip ( ) for l in find _ links.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for link in find _ links : DCNL DCSP DCSP DCSP if ( not ( salt.utils.url.validate ( link , VALID _ PROTOS ) or os.path.exists ( link ) ) ) : DCNL DCSP DCSP DCSP DCSP raise CommandExecutionError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP valid DCSP URL DCSP or DCSP path &quot; .format ( link ) ) DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --find-links &apos; , link &#93; ) DCNL DCSP if ( no _ index and ( index _ url or extra _ index _ url ) ) : DCNL DCSP DCSP raise CommandExecutionError ( &quot; &apos; no _ index &apos; DCSP and DCSP ( &apos; index _ url &apos; DCSP or DCSP &apos; extra _ index _ url &apos; ) DCSP are DCSP mutually DCSP exclusive . &quot; ) DCNL DCSP if index _ url : DCNL DCSP DCSP if ( not salt.utils.url.validate ( index _ url , VALID _ PROTOS ) ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP valid DCSP URL &quot; .format ( index _ url ) ) DCNL DCSP DCSP cmd.extend ( &#91; &apos; --index-url &apos; , index _ url &#93; ) DCNL DCSP if extra _ index _ url : DCNL DCSP DCSP if ( not salt.utils.url.validate ( extra _ index _ url , VALID _ PROTOS ) ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP valid DCSP URL &quot; .format ( extra _ index _ url ) ) DCNL DCSP DCSP cmd.extend ( &#91; &apos; --extra-index-url &apos; , extra _ index _ url &#93; ) DCNL DCSP if no _ index : DCNL DCSP DCSP cmd.append ( &apos; --no-index &apos; ) DCNL DCSP if mirrors : DCNL DCSP DCSP pip _ version = version ( pip _ bin ) DCNL DCSP DCSP if salt.utils.compare _ versions ( ver1 = pip _ version , oper = &apos; &gt; = &apos; , ver2 = &apos; 7.0.0 &apos; ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; pip DCSP &gt; = DCSP 7.0.0 DCSP does DCSP not DCSP support DCSP mirror DCSP argument : DCSP use DCSP index _ url DCSP and / or DCSP extra _ index _ url DCSP instead &apos; ) DCNL DCSP DCSP if isinstance ( mirrors , string _ types ) : DCNL DCSP DCSP DCSP mirrors = &#91; m.strip ( ) for m in mirrors.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP cmd.append ( &apos; --use-mirrors &apos; ) DCNL DCSP DCSP for mirror in mirrors : DCNL DCSP DCSP DCSP if ( not mirror.startswith ( &apos; http : / / &apos; ) ) : DCNL DCSP DCSP DCSP DCSP raise CommandExecutionError ( &quot; &apos; { 0 } &apos; DCSP is DCSP not DCSP a DCSP valid DCSP URL &quot; .format ( mirror ) ) DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --mirrors &apos; , mirror &#93; ) DCNL DCSP if build : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --build &apos; , build &#93; ) DCNL DCSP if target : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --target &apos; , target &#93; ) DCNL DCSP if download : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --download &apos; , download &#93; ) DCNL DCSP if download _ cache : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --download-cache &apos; , download _ cache &#93; ) DCNL DCSP if source : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --source &apos; , source &#93; ) DCNL DCSP if upgrade : DCNL DCSP DCSP cmd.append ( &apos; --upgrade &apos; ) DCNL DCSP if force _ reinstall : DCNL DCSP DCSP cmd.append ( &apos; --force-reinstall &apos; ) DCNL DCSP if ignore _ installed : DCNL DCSP DCSP cmd.append ( &apos; --ignore-installed &apos; ) DCNL DCSP if exists _ action : DCNL DCSP DCSP if ( exists _ action.lower ( ) not in ( &apos; s &apos; , &apos; i &apos; , &apos; w &apos; , &apos; b &apos; ) ) : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &quot; The DCSP exists _ action DCSP pip DCSP option DCSP only DCSP supports DCSP the DCSP values DCSP s , DCSP i , DCSP w , DCSP and DCSP b . DCSP &apos; { 0 } &apos; DCSP is DCSP not DCSP valid . &quot; .format ( exists _ action ) ) DCNL DCSP DCSP cmd.extend ( &#91; &apos; --exists-action &apos; , exists _ action &#93; ) DCNL DCSP if no _ deps : DCNL DCSP DCSP cmd.append ( &apos; --no-deps &apos; ) DCNL DCSP if no _ install : DCNL DCSP DCSP cmd.append ( &apos; --no-install &apos; ) DCNL DCSP if no _ download : DCNL DCSP DCSP cmd.append ( &apos; --no-download &apos; ) DCNL DCSP if no _ cache _ dir : DCNL DCSP DCSP cmd.append ( &apos; --no-cache-dir &apos; ) DCNL DCSP if pre _ releases : DCNL DCSP DCSP pip _ version = version ( pip _ bin ) DCNL DCSP DCSP if salt.utils.compare _ versions ( ver1 = pip _ version , oper = &apos; &gt; = &apos; , ver2 = &apos; 1.4 &apos; ) : DCNL DCSP DCSP DCSP cmd.append ( &apos; --pre &apos; ) DCNL DCSP if cert : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --cert &apos; , cert &#93; ) DCNL DCSP if global _ options : DCNL DCSP DCSP if isinstance ( global _ options , string _ types ) : DCNL DCSP DCSP DCSP global _ options = &#91; go.strip ( ) for go in global _ options.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for opt in global _ options : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --global-option &apos; , opt &#93; ) DCNL DCSP if install _ options : DCNL DCSP DCSP if isinstance ( install _ options , string _ types ) : DCNL DCSP DCSP DCSP install _ options = &#91; io.strip ( ) for io in install _ options.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for opt in install _ options : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --install-option &apos; , opt &#93; ) DCNL DCSP if pkgs : DCNL DCSP DCSP if isinstance ( pkgs , string _ types ) : DCNL DCSP DCSP DCSP pkgs = &#91; p.strip ( ) for p in pkgs.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP cmd.extend ( &#91; &apos; { 0 } &apos; .format ( p.replace ( &apos; ; &apos; , &apos; , &apos; ) ) for p in pkgs &#93; ) DCNL DCSP if editable : DCNL DCSP DCSP egg _ match = re.compile ( &apos; ( ? : # &#124; # . * ? &amp; ) egg = ( &#91; ^ &amp; &#93; * ) &apos; ) DCNL DCSP DCSP if isinstance ( editable , string _ types ) : DCNL DCSP DCSP DCSP editable = &#91; e.strip ( ) for e in editable.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for entry in editable : DCNL DCSP DCSP DCSP if ( not ( ( entry = = &apos; .&apos; ) or entry.startswith ( ( &apos; file : / / &apos; , &apos; / &apos; ) ) ) ) : DCNL DCSP DCSP DCSP DCSP match = egg _ match.search ( entry ) DCNL DCSP DCSP DCSP DCSP if ( ( not match ) or ( not match.group ( 1 ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise CommandExecutionError ( &apos; You DCSP must DCSP specify DCSP an DCSP egg DCSP for DCSP this DCSP editable &apos; ) DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --editable &apos; , entry &#93; ) DCNL DCSP if allow _ all _ external : DCNL DCSP DCSP cmd.append ( &apos; --allow-all-external &apos; ) DCNL DCSP if allow _ external : DCNL DCSP DCSP if isinstance ( allow _ external , string _ types ) : DCNL DCSP DCSP DCSP allow _ external = &#91; p.strip ( ) for p in allow _ external.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for pkg in allow _ external : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --allow-external &apos; , pkg &#93; ) DCNL DCSP if allow _ unverified : DCNL DCSP DCSP if isinstance ( allow _ unverified , string _ types ) : DCNL DCSP DCSP DCSP allow _ unverified = &#91; p.strip ( ) for p in allow _ unverified.split ( &apos; , &apos; ) &#93; DCNL DCSP DCSP for pkg in allow _ unverified : DCNL DCSP DCSP DCSP cmd.extend ( &#91; &apos; --allow-unverified &apos; , pkg &#93; ) DCNL DCSP if process _ dependency _ links : DCNL DCSP DCSP cmd.append ( &apos; --process-dependency-links &apos; ) DCNL DCSP if env _ vars : DCNL DCSP DCSP if isinstance ( env _ vars , dict ) : DCNL DCSP DCSP DCSP for ( k , v ) in iteritems ( env _ vars ) : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( v , string _ types ) ) : DCNL DCSP DCSP DCSP DCSP DCSP env _ vars &#91; k &#93; = str ( v ) DCNL DCSP DCSP DCSP os.environ.update ( env _ vars ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise CommandExecutionError ( &apos; env _ vars DCSP { 0 } DCSP is DCSP not DCSP a DCSP dictionary &apos; .format ( env _ vars ) ) DCNL DCSP if trusted _ host : DCNL DCSP DCSP cmd.extend ( &#91; &apos; --trusted-host &apos; , trusted _ host &#93; ) DCNL DCSP try : DCNL DCSP DCSP cmd _ kwargs = dict ( saltenv = saltenv , use _ vt = use _ vt , runas = user ) DCNL DCSP DCSP if cwd : DCNL DCSP DCSP DCSP cmd _ kwargs &#91; &apos; cwd &apos; &#93; = cwd DCNL DCSP DCSP if ( bin _ env and os.path.isdir ( bin _ env ) ) : DCNL DCSP DCSP DCSP cmd _ kwargs &#91; &apos; env &apos; &#93; = { &apos; VIRTUAL _ ENV &apos; : bin _ env } DCNL DCSP DCSP logger.debug ( &apos; TRY DCSP BLOCK : DCSP end DCSP of DCSP pip.install DCSP -- DCSP cmd : DCSP % s , DCSP cmd _ kwargs : DCSP % s &apos; , str ( cmd ) , str ( cmd _ kwargs ) ) DCNL DCSP DCSP return _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , python _ shell = False , * * cmd _ kwargs ) DCNL DCSP finally : DCNL DCSP DCSP for tempdir in &#91; cr for cr in cleanup _ requirements if ( cr is not None ) &#93; : DCNL DCSP DCSP DCSP if os.path.isdir ( tempdir ) : DCNL DCSP DCSP DCSP DCSP shutil.rmtree ( tempdir )
DCSP global useText DCNL DCSP if ( not useText ) : DCNL DCSP DCSP return DCNL DCSP keyTime = psychopy.core.getTime ( ) DCNL DCSP if emulated : DCNL DCSP DCSP keySource = &apos; EmulatedKey &apos; DCNL DCSP else : DCNL DCSP DCSP keySource = &apos; KeyPress &apos; DCNL DCSP _ keyBuffer.append ( ( text , keyTime ) ) DCNL DCSP logging.data ( ( &apos; % s : DCSP % s &apos; % ( keySource , text ) ) )
DCSP obj _ store = ObjectStore.GetInstance ( ObjectStore.PHOTO ) DCNL DCSP welcome _ path = os.path.join ( ResourcesManager.Instance ( ) .resources _ path , &apos; welcome &apos; ) DCNL DCSP ( yield _ SetWelcomeIds ( user , upload _ request ) ) DCNL DCSP upload _ request = deepcopy ( upload _ request ) DCNL DCSP upload _ request _ copy = deepcopy ( upload _ request ) DCNL DCSP &#91; ph _ dict.pop ( &apos; name &apos; ) for ph _ dict in upload _ request _ copy &#91; &apos; photos &apos; &#93; &#93; DCNL DCSP upload _ response = ( yield UploadEpisode ( client , obj _ store , user.user _ id , user.webapp _ dev _ id , upload _ request _ copy ) ) DCNL DCSP for ( request _ ph _ dict , response _ ph _ dict ) in zip ( upload _ request &#91; &apos; photos &apos; &#93; , upload _ response &#91; &apos; photos &apos; &#93; ) : DCNL DCSP DCSP for format in ( &apos; full &apos; , &apos; med &apos; , &apos; tn &apos; ) : DCNL DCSP DCSP DCSP f = open ( os.path.join ( welcome _ path , ( &apos; % s _ % s.jpg &apos; % ( request _ ph _ dict &#91; &apos; name &apos; &#93; , format ) ) ) , &apos; r &apos; ) DCNL DCSP DCSP DCSP image _ data = f.read ( ) DCNL DCSP DCSP DCSP f.close ( ) DCNL DCSP DCSP DCSP photo _ url = response _ ph _ dict &#91; ( format + &apos; _ put _ url &apos; ) &#93; DCNL DCSP DCSP DCSP content _ md5 = base64.b64encode ( request _ ph _ dict &#91; ( format + &apos; _ md5 &apos; ) &#93; .decode ( &apos; hex &apos; ) ) DCNL DCSP DCSP DCSP headers = { &apos; Content-Type &apos; : &apos; image / jpeg &apos; , &apos; Content-MD5 &apos; : content _ md5 } DCNL DCSP DCSP DCSP validate _ cert = ( not options.options.fileobjstore ) DCNL DCSP DCSP DCSP response = ( yield gen.Task ( http _ client.fetch , photo _ url , method = &apos; PUT &apos; , body = image _ data , follow _ redirects = False , validate _ cert = validate _ cert , headers = headers ) ) DCNL DCSP DCSP DCSP if ( response.code ! = 200 ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( ( &apos; Cannot DCSP upload DCSP photo DCSP &quot; % s &quot; . DCSP HTTP DCSP error DCSP code DCSP % d . DCSP Is DCSP server DCSP running DCSP and DCSP accessible ? &apos; % ( request _ ph _ dict &#91; &apos; photo _ id &apos; &#93; , response.code ) ) )
DCSP date _ field = generic _ view.get _ date _ field ( ) DCNL DCSP allow _ empty = generic _ view.get _ allow _ empty ( ) DCNL DCSP allow _ future = generic _ view.get _ allow _ future ( ) DCNL DCSP get _ current = getattr ( generic _ view , ( u &apos; _ get _ current _ % s &apos; % period ) ) DCNL DCSP get _ next = getattr ( generic _ view , ( u &apos; _ get _ next _ % s &apos; % period ) ) DCNL DCSP ( start , end ) = ( get _ current ( date ) , get _ next ( date ) ) DCNL DCSP if allow _ empty : DCNL DCSP DCSP if is _ previous : DCNL DCSP DCSP DCSP result = get _ current ( ( start - datetime.timedelta ( days = 1 ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = end DCNL DCSP DCSP if ( allow _ future or ( result &lt; = timezone _ today ( ) ) ) : DCNL DCSP DCSP DCSP return result DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP else : DCNL DCSP DCSP if is _ previous : DCNL DCSP DCSP DCSP lookup = { ( u &apos; % s _ _ lt &apos; % date _ field ) : generic _ view . _ make _ date _ lookup _ arg ( start ) } DCNL DCSP DCSP DCSP ordering = ( u &apos; - % s &apos; % date _ field ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP lookup = { ( u &apos; % s _ _ gte &apos; % date _ field ) : generic _ view . _ make _ date _ lookup _ arg ( end ) } DCNL DCSP DCSP DCSP ordering = date _ field DCNL DCSP DCSP if ( not allow _ future ) : DCNL DCSP DCSP DCSP if generic _ view.uses _ datetime _ field : DCNL DCSP DCSP DCSP DCSP now = timezone.now ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP now = timezone _ today ( ) DCNL DCSP DCSP DCSP lookup &#91; ( u &apos; % s _ _ lte &apos; % date _ field ) &#93; = now DCNL DCSP DCSP qs = generic _ view.get _ queryset ( ) .filter ( * * lookup ) .order _ by ( ordering ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP result = getattr ( qs &#91; 0 &#93; , date _ field ) DCNL DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if generic _ view.uses _ datetime _ field : DCNL DCSP DCSP DCSP if settings.USE _ TZ : DCNL DCSP DCSP DCSP DCSP result = timezone.localtime ( result ) DCNL DCSP DCSP DCSP result = result.date ( ) DCNL DCSP DCSP return get _ current ( result )
DCSP TC = nx.transitive _ closure ( G ) DCNL DCSP antichains _ stacks = &#91; ( &#91; &#93; , list ( reversed ( list ( nx.topological _ sort ( G ) ) ) ) ) &#93; DCNL DCSP while antichains _ stacks : DCNL DCSP DCSP ( antichain , stack ) = antichains _ stacks.pop ( ) DCNL DCSP DCSP ( yield antichain ) DCNL DCSP DCSP while stack : DCNL DCSP DCSP DCSP x = stack.pop ( ) DCNL DCSP DCSP DCSP new _ antichain = ( antichain + &#91; x &#93; ) DCNL DCSP DCSP DCSP new _ stack = &#91; t for t in stack if ( not ( ( t in TC &#91; x &#93; ) or ( x in TC &#91; t &#93; ) ) ) &#93; DCNL DCSP DCSP DCSP antichains _ stacks.append ( ( new _ antichain , new _ stack ) )
DCSP prefix = &apos; MSC DCSP v. &apos; DCNL DCSP i = string.find ( sys.version , prefix ) DCNL DCSP if ( i = = ( -1 ) ) : DCNL DCSP DCSP return 6 DCNL DCSP i = ( i + len ( prefix ) ) DCNL DCSP ( s , rest ) = sys.version &#91; i : &#93; .split ( &apos; DCSP &apos; , 1 ) DCNL DCSP majorVersion = ( int ( s &#91; : ( -2 ) &#93; ) - 6 ) DCNL DCSP minorVersion = ( int ( s &#91; 2 : 3 &#93; ) / 10.0 ) DCNL DCSP if ( majorVersion = = 6 ) : DCNL DCSP DCSP minorVersion = 0 DCNL DCSP if ( majorVersion &gt; = 6 ) : DCNL DCSP DCSP return ( majorVersion + minorVersion ) DCNL DCSP return None
DCSP if ( local _ cache _ enable and ( method = = &apos; GET &apos; ) and cache.is _ cached ( url ) ) : DCNL DCSP DCSP info _ dict = cache.get _ info ( url ) DCNL DCSP DCSP resp = cache.get _ obj ( url ) DCNL DCSP DCSP resp.set _ data ( content ) DCNL DCSP DCSP info _ dict &#91; &apos; without _ content &apos; &#93; = False DCNL DCSP DCSP if ( verbose _ level &gt; = 4 ) : DCNL DCSP DCSP DCSP dbgprint ( &apos; LocalCache _ UpdateCache &apos; , url , content &#91; : 30 &#93; , len ( content ) ) DCNL DCSP DCSP cache.put _ obj ( url , resp , obj _ size = len ( content ) , expires = get _ expire _ from _ mime ( parse.mime ) , last _ modified = info _ dict.get ( &apos; last _ modified &apos; ) , info _ dict = info _ dict )
DCSP if os.fork ( ) : DCNL DCSP DCSP return 1 DCNL DCSP os.setsid ( ) DCNL DCSP if os.fork ( ) : DCNL DCSP DCSP return 2 DCNL DCSP os.chdir ( &apos; / &apos; ) DCNL DCSP null = os.open ( &apos; / dev / null &apos; , os.O _ RDWR ) DCNL DCSP for i in range ( 3 ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP os.dup2 ( null , i ) DCNL DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP if ( e.errno ! = errno.EBADF ) : DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP os.close ( null ) DCNL DCSP warnings.filterwarnings ( &apos; ignore &apos; ) DCNL DCSP if pidfile : DCNL DCSP DCSP piddir = os.path.dirname ( pidfile ) DCNL DCSP DCSP if ( not os.path.exists ( piddir ) ) : DCNL DCSP DCSP DCSP os.makedirs ( piddir ) DCNL DCSP DCSP f = file ( pidfile , &apos; w &apos; ) DCNL DCSP DCSP f.write ( str ( os.getpid ( ) ) ) DCNL DCSP DCSP f.close ( ) DCNL DCSP if ( umask is not None ) : DCNL DCSP DCSP os.umask ( umask ) DCNL DCSP if uid : DCNL DCSP DCSP setugid ( uid ) DCNL DCSP return None
DCSP return UUID ( blockdevice _ id &#91; len ( _ PREFIX ) : &#93; )
DCSP text = text.translate ( { 0 : None , ord ( &apos; / &apos; ) : &apos; -&apos; , ord ( &apos; &#124; &apos; ) : &apos; -&apos; } ) DCNL DCSP if ( os = = &apos; Windows &apos; ) : DCNL DCSP DCSP text = text.translate ( { ord ( &apos; : &apos; ) : &apos; -&apos; , ord ( &apos; * &apos; ) : &apos; -&apos; , ord ( &apos; ? &apos; ) : &apos; -&apos; , ord ( &apos; \ \ &apos; ) : &apos; -&apos; , ord ( &apos; &quot; &apos; ) : &quot; &apos; &quot; , ord ( &apos; + &apos; ) : &apos; -&apos; , ord ( &apos; &lt; &apos; ) : &apos; -&apos; , ord ( &apos; &gt; &apos; ) : &apos; -&apos; , ord ( &apos; &#91; &apos; ) : &apos; ( &apos; , ord ( &apos; &#93; &apos; ) : &apos; ) &apos; } ) DCNL DCSP else : DCNL DCSP DCSP if ( os = = &apos; Darwin &apos; ) : DCNL DCSP DCSP DCSP text = text.translate ( { ord ( &apos; : &apos; ) : &apos; -&apos; } ) DCNL DCSP DCSP if text.startswith ( &apos; .&apos; ) : DCNL DCSP DCSP DCSP text = text &#91; 1 : &#93; DCNL DCSP text = text &#91; : 82 &#93; DCNL DCSP return text
DCSP encodedStream = &apos; &apos; DCNL DCSP if ( ( parameters = = None ) or ( parameters = = { } ) ) : DCNL DCSP DCSP return ( 0 , stream ) DCNL DCSP elif ( ( not parameters.has _ key ( &apos; / Name &apos; ) ) or ( parameters &#91; &apos; / Name &apos; &#93; = = None ) ) : DCNL DCSP DCSP return ( 0 , stream ) DCNL DCSP else : DCNL DCSP DCSP cryptFilterName = parameters &#91; &apos; / Name &apos; &#93; .getValue ( ) DCNL DCSP DCSP if ( cryptFilterName = = &apos; Identity &apos; ) : DCNL DCSP DCSP DCSP return ( 0 , stream ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( ( -1 ) , &apos; Decrypt DCSP not DCSP supported DCSP yet &apos; )
DCSP patches = SplitPatch ( data ) DCNL DCSP rv = &#91; &#93; DCNL DCSP for patch in patches : DCNL DCSP DCSP set _ status ( ( &apos; uploading DCSP patch DCSP for DCSP &apos; + patch &#91; 0 &#93; ) ) DCNL DCSP DCSP if ( len ( patch &#91; 1 &#93; ) &gt; MAX _ UPLOAD _ SIZE ) : DCNL DCSP DCSP DCSP print ( ( &apos; Not DCSP uploading DCSP the DCSP patch DCSP for DCSP &apos; + patch &#91; 0 &#93; ) + &apos; DCSP because DCSP the DCSP file DCSP is DCSP too DCSP large . &apos; ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP form _ fields = &#91; ( &apos; filename &apos; , patch &#91; 0 &#93; ) &#93; DCNL DCSP DCSP if ( not options.download _ base ) : DCNL DCSP DCSP DCSP form _ fields.append ( ( &apos; content _ upload &apos; , &apos; 1&apos; ) ) DCNL DCSP DCSP files = &#91; ( &apos; data &apos; , &apos; data.diff &apos; , patch &#91; 1 &#93; ) &#93; DCNL DCSP DCSP ( ctype , body ) = EncodeMultipartFormData ( form _ fields , files ) DCNL DCSP DCSP url = ( &apos; / % d / upload _ patch / % d &apos; % ( int ( issue ) , int ( patchset ) ) ) DCNL DCSP DCSP print ( &apos; Uploading DCSP patch DCSP for DCSP &apos; + patch &#91; 0 &#93; ) DCNL DCSP DCSP response _ body = rpc _ server.Send ( url , body , content _ type = ctype ) DCNL DCSP DCSP lines = response _ body.splitlines ( ) DCNL DCSP DCSP if ( ( not lines ) or ( lines &#91; 0 &#93; ! = &apos; OK &apos; ) ) : DCNL DCSP DCSP DCSP StatusUpdate ( ( &apos; DCSP DCSP -- &gt; DCSP % s &apos; % response _ body ) ) DCNL DCSP DCSP DCSP sys.exit ( 1 ) DCNL DCSP DCSP rv.append ( &#91; lines &#91; 1 &#93; , patch &#91; 0 &#93; &#93; ) DCNL DCSP return rv
DCSP assert is _ css _ present ( css _ selector ) DCNL DCSP return retry _ on _ exception ( ( lambda : css _ find ( css _ selector ) &#91; index &#93; .html ) )
DCSP fut = delete _ multi _ async ( blob _ keys , * * options ) DCNL DCSP fut.get _ result ( )
DCSP try : DCNL DCSP DCSP check = CHECKS &#91; name &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise Http404 ( &apos; No DCSP check DCSP matches DCSP the DCSP given DCSP query . &apos; ) DCNL DCSP ignore = ( &apos; ignored &apos; in request.GET ) DCNL DCSP url _ params = { } DCNL DCSP if ignore : DCNL DCSP DCSP url _ params &#91; &apos; ignored &apos; &#93; = &apos; true &apos; DCNL DCSP checks = acl _ checks ( request.user ) .filter ( check = name , ignore = ignore ) DCNL DCSP if ( &apos; language &apos; in request.GET ) : DCNL DCSP DCSP checks = checks.filter ( language _ _ code = request.GET &#91; &apos; language &apos; &#93; ) DCNL DCSP DCSP url _ params &#91; &apos; language &apos; &#93; = request.GET &#91; &apos; language &apos; &#93; DCNL DCSP if ( &apos; project &apos; in request.GET ) : DCNL DCSP DCSP return redirect _ param ( &apos; show _ check _ project &apos; , encode _ optional ( url _ params ) , project = request.GET &#91; &apos; project &apos; &#93; , name = name ) DCNL DCSP checks = checks.values ( &apos; project _ _ slug &apos; ) .annotate ( count = Count ( &apos; id &apos; ) ) DCNL DCSP return render ( request , &apos; check.html &apos; , { &apos; checks &apos; : checks , &apos; title &apos; : check.name , &apos; check &apos; : check , &apos; url _ params &apos; : encode _ optional ( url _ params ) } )
DCSP try : DCNL DCSP DCSP ( installer , _ ) = plug _ sel.choose _ configurator _ plugins ( config , plugins , &apos; install &apos; ) DCNL DCSP except errors.PluginSelectionError as e : DCNL DCSP DCSP return e.message DCNL DCSP ( domains , _ ) = _ find _ domains _ or _ certname ( config , installer ) DCNL DCSP le _ client = _ init _ le _ client ( config , authenticator = None , installer = installer ) DCNL DCSP assert ( config.cert _ path is not None ) DCNL DCSP le _ client.deploy _ certificate ( domains , config.key _ path , config.cert _ path , config.chain _ path , config.fullchain _ path ) DCNL DCSP le _ client.enhance _ config ( domains , config.chain _ path )
DCSP base _ parsed = urlparse ( base ) DCNL DCSP if ( not base _ parsed.path ) : DCNL DCSP DCSP sub _ path = u &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP sub _ path = base _ parsed.path DCNL DCSP if sub _ path.endswith ( u &apos; / &apos; ) : DCNL DCSP DCSP return sub _ path DCNL DCSP else : DCNL DCSP DCSP return ( sub _ path + u &apos; / &apos; )
DCSP if ( len ( val1 ) ! = len ( val2 ) ) : DCNL DCSP DCSP return False DCNL DCSP result = 0 DCNL DCSP if ( six.PY3 and isinstance ( val1 , bytes ) and isinstance ( val2 , bytes ) ) : DCNL DCSP DCSP for ( x , y ) in zip ( val1 , val2 ) : DCNL DCSP DCSP DCSP result &#124; = ( x ^ y ) DCNL DCSP else : DCNL DCSP DCSP for ( x , y ) in zip ( val1 , val2 ) : DCNL DCSP DCSP DCSP result &#124; = ( ord ( x ) ^ ord ( y ) ) DCNL DCSP return ( result = = 0 )
DCSP loc = &#91; &apos; { } - &apos; .format ( ( locationID &gt; &gt; 24 ) ) &#93; DCNL DCSP while ( locationID &amp; 15728640 ) : DCNL DCSP DCSP if ( len ( loc ) &gt; 1 ) : DCNL DCSP DCSP DCSP loc.append ( &apos; .&apos; ) DCNL DCSP DCSP loc.append ( &apos; { } &apos; .format ( ( ( locationID &gt; &gt; 20 ) &amp; 15 ) ) ) DCNL DCSP DCSP locationID &lt; &lt; = 4 DCNL DCSP return &apos; &apos;.join ( loc )
DCSP try : DCNL DCSP DCSP id = int ( request.GET &#91; &apos; id &apos; &#93; ) DCNL DCSP except : DCNL DCSP DCSP id = 0 DCNL DCSP if ( not id ) : DCNL DCSP DCSP return HttpResponseRedirect ( &apos; / wc / components / show _ layout &apos; ) DCNL DCSP ServerLayout.objects.filter ( pk = id ) .delete ( ) DCNL DCSP return HttpResponseRedirect ( &apos; / wc / components / show _ layout &apos; )
DCSP ( major , minor , micro , level , serial ) = sys.version _ info DCNL DCSP release = ( &apos; % s % s &apos; % ( major , minor ) ) DCNL DCSP if micro : DCNL DCSP DCSP release + = ( &apos; % s &apos; % ( micro , ) ) DCNL DCSP if ( level = = &apos; candidate &apos; ) : DCNL DCSP DCSP release + = ( &apos; rc % s &apos; % ( serial , ) ) DCNL DCSP elif ( level ! = &apos; final &apos; ) : DCNL DCSP DCSP release + = ( &apos; % s % s &apos; % ( level &#91; 0 &#93; , serial ) ) DCNL DCSP return release
DCSP from cms.utils.page _ permissions import get _ change _ permissions _ id _ list DCNL DCSP try : DCNL DCSP DCSP user _ level = get _ user _ permission _ level ( user , site ) DCNL DCSP except NoPermissionsException : DCNL DCSP DCSP qs = get _ user _ model ( ) .objects.distinct ( ) .filter ( ( ( Q ( is _ staff = True ) &amp; Q ( pageuser _ _ created _ by = user ) ) &amp; Q ( pagepermission _ _ page = None ) ) ) DCNL DCSP DCSP qs = qs.exclude ( pk = user.pk ) .exclude ( groups _ _ user _ _ pk = user.pk ) DCNL DCSP DCSP return qs DCNL DCSP if ( user _ level = = ROOT _ USER _ LEVEL ) : DCNL DCSP DCSP return get _ user _ model ( ) .objects.all ( ) DCNL DCSP page _ id _ allow _ list = get _ change _ permissions _ id _ list ( user , site , check _ global = False ) DCNL DCSP qs = get _ user _ model ( ) .objects.distinct ( ) .filter ( ( ( Q ( is _ staff = True ) &amp; ( Q ( pagepermission _ _ page _ _ id _ _ in = page _ id _ allow _ list ) &amp; Q ( pagepermission _ _ page _ _ depth _ _ gte = user _ level ) ) ) &#124; ( Q ( pageuser _ _ created _ by = user ) &amp; Q ( pagepermission _ _ page = None ) ) ) ) DCNL DCSP qs = qs.exclude ( pk = user.pk ) .exclude ( groups _ _ user _ _ pk = user.pk ) DCNL DCSP return qs
DCSP numpy _ status = { } DCNL DCSP try : DCNL DCSP DCSP import numpy DCNL DCSP DCSP numpy _ version = numpy . _ _ version _ _ DCNL DCSP DCSP numpy _ status &#91; &apos; up _ to _ date &apos; &#93; = ( parse _ version ( numpy _ version ) &gt; = parse _ version ( NUMPY _ MIN _ VERSION ) ) DCNL DCSP DCSP numpy _ status &#91; &apos; version &apos; &#93; = numpy _ version DCNL DCSP except ImportError : DCNL DCSP DCSP traceback.print _ exc ( ) DCNL DCSP DCSP numpy _ status &#91; &apos; up _ to _ date &apos; &#93; = False DCNL DCSP DCSP numpy _ status &#91; &apos; version &apos; &#93; = &apos; &apos; DCNL DCSP return numpy _ status
DCSP M = zeros ( ( 6 , 6 ) ) DCNL DCSP M &#91; : 3 , : 4 &#93; = P1 DCNL DCSP M &#91; 3 : , : 4 &#93; = P2 DCNL DCSP M &#91; : 3 , 4 &#93; = ( - x1 ) DCNL DCSP M &#91; 3 : , 5 &#93; = ( - x2 ) DCNL DCSP ( U , S , V ) = linalg.svd ( M ) DCNL DCSP X = V &#91; ( -1 ) , : 4 &#93; DCNL DCSP return ( X / X &#91; 3 &#93; )
DCSP manager = MANAGER DCNL DCSP with settings ( hide ( &apos; running &apos; , &apos; stdout &apos; , &apos; stderr &apos; , &apos; warnings &apos; ) , warn _ only = True ) : DCNL DCSP DCSP res = run ( ( &apos; % ( manager ) s DCSP -p DCSP % ( pkg _ name ) s &apos; % locals ( ) ) ) DCNL DCSP if ( not res.succeeded ) : DCNL DCSP DCSP return False DCNL DCSP if pkg _ name.startswith ( &apos; = &apos; ) : DCNL DCSP DCSP pkg _ name = pkg _ name &#91; 1 : &#93; DCNL DCSP match = re.search ( ( &apos; \ \ n \ \ &#91; ebuild DCSP + ( ? P &lt; code &gt; \ \ w + ) DCSP * \ \ &#93; DCSP . * % ( pkg _ name ) s . * &apos; % locals ( ) ) , res.stdout ) DCNL DCSP if ( match and ( match.groupdict ( ) &#91; &apos; code &apos; &#93; in ( &apos; U &apos; , &apos; R &apos; ) ) ) : DCNL DCSP DCSP return True DCNL DCSP else : DCNL DCSP DCSP return False
DCSP if ( msg is None ) : DCNL DCSP DCSP msg = &apos; Test DCSP skipped DCSP due DCSP to DCSP known DCSP failure &apos; DCNL DCSP if callable ( fail _ condition ) : DCNL DCSP DCSP fail _ val = ( lambda : fail _ condition ( ) ) DCNL DCSP else : DCNL DCSP DCSP fail _ val = ( lambda : fail _ condition ) DCNL DCSP def knownfail _ decorator ( f ) : DCNL DCSP DCSP import nose DCNL DCSP DCSP def knownfailer ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP if fail _ val ( ) : DCNL DCSP DCSP DCSP DCSP raise KnownFailureTest ( msg ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return f ( * args , * * kwargs ) DCNL DCSP DCSP return nose.tools.make _ decorator ( f ) ( knownfailer ) DCNL DCSP return knownfail _ decorator
DCSP cs.keypairs.delete ( args.name , args.user )
DCSP daynames = set ( &#91; u &apos;mon &apos; , u &apos;tue &apos; , u &apos;wed &apos; , u &apos;thu &apos; , u &apos;fri &apos; , u &apos;sat &apos; , u &apos;sun &apos; &#93; ) DCNL DCSP months = { u &apos;jan &apos; : 1 , u &apos;feb &apos; : 2 , u &apos;mar &apos; : 3 , u &apos;apr &apos; : 4 , u &apos;may &apos; : 5 , u &apos;jun &apos; : 6 , u &apos;jul &apos; : 7 , u &apos;aug &apos; : 8 , u &apos;sep &apos; : 9 , u &apos;oct &apos; : 10 , u &apos;nov &apos; : 11 , u &apos;dec &apos; : 12 } DCNL DCSP parts = date.lower ( ) .split ( ) DCNL DCSP if ( len ( parts ) &lt; 5 ) : DCNL DCSP DCSP parts.extend ( ( u &apos; 00 : 00 : 00 &apos; , u &apos; 0000 &apos; ) ) DCNL DCSP if ( parts &#91; 0 &#93; &#91; : 3 &#93; in daynames ) : DCNL DCSP DCSP parts = parts &#91; 1 : &#93; DCNL DCSP if ( len ( parts ) &lt; 5 ) : DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP day = int ( parts &#91; 0 &#93; ) DCNL DCSP except ValueError : DCNL DCSP DCSP if months.get ( parts &#91; 0 &#93; &#91; : 3 &#93; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP day = int ( parts &#91; 1 &#93; ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP return None DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP parts &#91; 1 &#93; = parts &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP month = months.get ( parts &#91; 1 &#93; &#91; : 3 &#93; ) DCNL DCSP if ( not month ) : DCNL DCSP DCSP return None DCNL DCSP try : DCNL DCSP DCSP year = int ( parts &#91; 2 &#93; ) DCNL DCSP except ValueError : DCNL DCSP DCSP return None DCNL DCSP if ( len ( parts &#91; 2 &#93; ) &lt; = 2 ) : DCNL DCSP DCSP year + = ( 1900 , 2000 ) &#91; ( year &lt; 90 ) &#93; DCNL DCSP timeparts = parts &#91; 3 &#93; .split ( u &apos; : &apos; ) DCNL DCSP timeparts = ( timeparts + ( &#91; 0 &#93; * ( 3 - len ( timeparts ) ) ) ) DCNL DCSP try : DCNL DCSP DCSP ( hour , minute , second ) = map ( int , timeparts ) DCNL DCSP except ValueError : DCNL DCSP DCSP return None DCNL DCSP tzhour = 0 DCNL DCSP tzmin = 0 DCNL DCSP if parts &#91; 4 &#93; .startswith ( u &apos;etc / &apos; ) : DCNL DCSP DCSP parts &#91; 4 &#93; = parts &#91; 4 &#93; &#91; 4 : &#93; DCNL DCSP if parts &#91; 4 &#93; .startswith ( u &apos;gmt &apos; ) : DCNL DCSP DCSP parts &#91; 4 &#93; = ( u &apos; &apos; .join ( parts &#91; 4 &#93; &#91; 3 : &#93; .split ( u &apos; : &apos; ) ) or u &apos;gmt &apos; ) DCNL DCSP if ( parts &#91; 4 &#93; and ( parts &#91; 4 &#93; &#91; 0 &#93; in ( u &apos; - &apos; , u &apos; + &apos; ) ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP tzhour = int ( parts &#91; 4 &#93; &#91; 1 : 3 &#93; ) DCNL DCSP DCSP DCSP tzmin = int ( parts &#91; 4 &#93; &#91; 3 : &#93; ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP return None DCNL DCSP DCSP if parts &#91; 4 &#93; .startswith ( u &apos; - &apos; ) : DCNL DCSP DCSP DCSP tzhour = ( tzhour * ( -1 ) ) DCNL DCSP DCSP DCSP tzmin = ( tzmin * ( -1 ) ) DCNL DCSP else : DCNL DCSP DCSP tzhour = timezonenames.get ( parts &#91; 4 &#93; , 0 ) DCNL DCSP try : DCNL DCSP DCSP stamp = datetime.datetime ( year , month , day , hour , minute , second ) DCNL DCSP except ValueError : DCNL DCSP DCSP return None DCNL DCSP delta = datetime.timedelta ( 0 , 0 , 0 , 0 , tzmin , tzhour ) DCNL DCSP try : DCNL DCSP DCSP return ( stamp - delta ) .utctimetuple ( ) DCNL DCSP except ( OverflowError , ValueError ) : DCNL DCSP DCSP return None
DCSP return Constant ( 0.0 , dtype = dtype )
DCSP points = _ ndim _ coords _ from _ arrays ( points ) DCNL DCSP if ( points.ndim &lt; 2 ) : DCNL DCSP DCSP ndim = points.ndim DCNL DCSP else : DCNL DCSP DCSP ndim = points.shape &#91; ( -1 ) &#93; DCNL DCSP if ( ( ndim = = 1 ) and ( method in ( &apos; nearest &apos; , &apos; linear &apos; , &apos; cubic &apos; ) ) ) : DCNL DCSP DCSP from .interpolate import interp1d DCNL DCSP DCSP points = points.ravel ( ) DCNL DCSP DCSP if isinstance ( xi , tuple ) : DCNL DCSP DCSP DCSP if ( len ( xi ) ! = 1 ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP number DCSP of DCSP dimensions DCSP in DCSP xi &apos; ) DCNL DCSP DCSP DCSP ( xi , ) = xi DCNL DCSP DCSP idx = np.argsort ( points ) DCNL DCSP DCSP points = points &#91; idx &#93; DCNL DCSP DCSP values = values &#91; idx &#93; DCNL DCSP DCSP if ( method = = &apos; nearest &apos; ) : DCNL DCSP DCSP DCSP fill _ value = &apos; extrapolate &apos; DCNL DCSP DCSP ip = interp1d ( points , values , kind = method , axis = 0 , bounds _ error = False , fill _ value = fill _ value ) DCNL DCSP DCSP return ip ( xi ) DCNL DCSP elif ( method = = &apos; nearest &apos; ) : DCNL DCSP DCSP ip = NearestNDInterpolator ( points , values , rescale = rescale ) DCNL DCSP DCSP return ip ( xi ) DCNL DCSP elif ( method = = &apos; linear &apos; ) : DCNL DCSP DCSP ip = LinearNDInterpolator ( points , values , fill _ value = fill _ value , rescale = rescale ) DCNL DCSP DCSP return ip ( xi ) DCNL DCSP elif ( ( method = = &apos; cubic &apos; ) and ( ndim = = 2 ) ) : DCNL DCSP DCSP ip = CloughTocher2DInterpolator ( points , values , fill _ value = fill _ value , rescale = rescale ) DCNL DCSP DCSP return ip ( xi ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP interpolation DCSP method DCSP % r DCSP for DCSP % d DCSP dimensional DCSP data &apos; % ( method , ndim ) ) )
DCSP longest = None DCNL DCSP for i in range ( len ( string ) ) : DCNL DCSP DCSP substr = string &#91; : ( i + 1 ) &#93; DCNL DCSP DCSP if ( not trie.has _ prefix ( substr ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( substr in trie ) : DCNL DCSP DCSP DCSP longest = substr DCNL DCSP return longest
DCSP try : DCNL DCSP DCSP os.unlink ( filename ) DCNL DCSP except OSError as why : DCNL DCSP DCSP if ( why.errno = = ENOENT ) : DCNL DCSP DCSP DCSP return 0 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP else : DCNL DCSP DCSP return 1
DCSP if ( ( key in kw ) and ( type ( kw &#91; key &#93; ) is not type _ ) and ( kw &#91; key &#93; is not None ) ) : DCNL DCSP DCSP if ( ( type _ is bool ) and flexi _ bool ) : DCNL DCSP DCSP DCSP kw &#91; key &#93; = asbool ( kw &#91; key &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP kw &#91; key &#93; = type _ ( kw &#91; key &#93; )
DCSP smt = SMOTETomek ( random _ state = RND _ SEED ) DCNL DCSP ( X _ resampled , y _ resampled ) = smt.fit _ sample ( X , Y ) DCNL DCSP X _ gt = np.array ( &#91; &#91; 0.20622591 , 0.0582794 &#93; , &#91; 0.68481731 , 0.51935141 &#93; , &#91; 1.34192108 , ( -0.13367336 ) &#93; , &#91; 0.62366841 , ( -0.21312976 ) &#93; , &#91; 1.61091956 , ( -0.40283504 ) &#93; , &#91; ( -0.37162401 ) , ( -2.19400981 ) &#93; , &#91; 0.74680821 , 1.63827342 &#93; , &#91; 0.61472253 , ( -0.82309052 ) &#93; , &#91; 0.19893132 , ( -0.47761769 ) &#93; , &#91; 0.97407872 , 0.44454207 &#93; , &#91; 1.40301027 , ( -0.83648734 ) &#93; , &#91; ( -1.20515198 ) , ( -1.02689695 ) &#93; , &#91; ( -0.23374509 ) , 0.18370049 &#93; , &#91; ( -0.32635887 ) , ( -0.29299653 ) &#93; , &#91; ( -0.00288378 ) , 0.84259929 &#93; , &#91; 1.79580611 , ( -0.02219234 ) &#93; , &#91; 0.38307743 , ( -0.05670439 ) &#93; , &#91; 0.93976473 , ( -0.06570176 ) &#93; , &#91; 0.70319159 , ( -0.02571668 ) &#93; , &#91; 0.75052536 , ( -0.19246517 ) &#93; &#93; ) DCNL DCSP y _ gt = np.array ( &#91; 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 &#93; ) DCNL DCSP assert _ allclose ( X _ resampled , X _ gt , rtol = R _ TOL ) DCNL DCSP assert _ array _ equal ( y _ resampled , y _ gt )
DCSP return re.split ( _ _ WHITESPACE _ SPLIT , string )
DCSP mlp = BatchNormalizedMLP ( &#91; Tanh ( ) , Tanh ( ) &#93; , &#91; 5 , 7 , 9 &#93; , mean _ only = True ) DCNL DCSP assert mlp.mean _ only DCNL DCSP assert ( not any ( ( act.children &#91; 0 &#93; .mean _ only for act in mlp.activations ) ) ) DCNL DCSP mlp.allocate ( ) DCNL DCSP assert all ( ( act.children &#91; 0 &#93; .mean _ only for act in mlp.activations ) )
DCSP def retry _ if ( ex ) : DCNL DCSP DCSP &apos; Retry DCSP if DCSP we DCSP get DCSP a DCSP server DCSP error DCSP indicating DCSP throttling . DCSP Also \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP handle DCSP spurious DCSP 505s DCSP that DCSP are DCSP thought DCSP to DCSP be DCSP part DCSP of DCSP a DCSP load \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP balancer DCSP issue DCSP inside DCSP AWS . &apos; DCNL DCSP DCSP return ( ( isinstance ( ex , boto.exception.BotoServerError ) and ( ( &apos; Throttling &apos; in ex.body ) or ( &apos; RequestExpired &apos; in ex.body ) or ( ex.status = = 505 ) ) ) or ( isinstance ( ex , socket.error ) and ( ex.args in ( ( 104 , &apos; Connection DCSP reset DCSP by DCSP peer &apos; ) , ( 110 , &apos; Connection DCSP timed DCSP out &apos; ) ) ) ) ) DCNL DCSP return RetryWrapper ( raw _ conn , retry _ if = retry _ if , backoff = _ EMR _ BACKOFF , multiplier = _ EMR _ BACKOFF _ MULTIPLIER , max _ tries = _ EMR _ MAX _ TRIES )
DCSP qt = QTable ( MIXIN _ COLS ) DCNL DCSP names = qt.colnames DCNL DCSP for name in names : DCNL DCSP DCSP qt &#91; name &#93; .info.description = name DCNL DCSP t = Table ( qt ) DCNL DCSP for name in names : DCNL DCSP DCSP assert ( t &#91; name &#93; .info.description = = name ) DCNL DCSP DCSP if ( name = = &apos; quantity &apos; ) : DCNL DCSP DCSP DCSP assert np.all ( ( t &#91; &apos; quantity &apos; &#93; = = qt &#91; &apos; quantity &apos; &#93; .value ) ) DCNL DCSP DCSP DCSP assert np.all ( ( t &#91; &apos; quantity &apos; &#93; .unit is qt &#91; &apos; quantity &apos; &#93; .unit ) ) DCNL DCSP DCSP DCSP assert isinstance ( t &#91; &apos; quantity &apos; &#93; , t.ColumnClass ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP assert _ table _ name _ col _ equal ( t , name , qt &#91; name &#93; ) DCNL DCSP qt2 = QTable ( qt ) DCNL DCSP for name in names : DCNL DCSP DCSP assert ( qt2 &#91; name &#93; .info.description = = name ) DCNL DCSP DCSP assert _ table _ name _ col _ equal ( qt2 , name , qt &#91; name &#93; )
DCSP return SGR _ MATRIX
DCSP value _ size = struct.calcsize ( format ) DCNL DCSP local _ unpack = struct.unpack DCNL DCSP def InnerDecode ( buffer , pos ) : DCNL DCSP DCSP new _ pos = ( pos + value _ size ) DCNL DCSP DCSP result = local _ unpack ( format , buffer &#91; pos : new _ pos &#93; ) &#91; 0 &#93; DCNL DCSP DCSP return ( result , new _ pos ) DCNL DCSP return _ SimpleDecoder ( wire _ type , InnerDecode )
DCSP config = current.test _ config DCNL DCSP browser = config.browser DCNL DCSP elem = browser.find _ element _ by _ id ( &apos; datatable _ info &apos; ) DCNL DCSP details = elem.text DCNL DCSP if ( not quiet ) : DCNL DCSP DCSP reporter ( details ) DCNL DCSP words = details.split ( ) DCNL DCSP start = int ( words &#91; 1 &#93; ) DCNL DCSP end = int ( words &#91; 3 &#93; ) DCNL DCSP length = int ( words &#91; 5 &#93; ) DCNL DCSP filtered = None DCNL DCSP if ( len ( words ) &gt; 10 ) : DCNL DCSP DCSP filtered = int ( words &#91; 9 &#93; ) DCNL DCSP if ( check ! = ( ) ) : DCNL DCSP DCSP if ( len ( check ) = = 3 ) : DCNL DCSP DCSP DCSP expected = ( &apos; Showing DCSP % d DCSP to DCSP % d DCSP of DCSP % d DCSP entries &apos; % check ) DCNL DCSP DCSP DCSP actual = ( &apos; Showing DCSP % d DCSP to DCSP % d DCSP of DCSP % d DCSP entries &apos; % ( start , end , length ) ) DCNL DCSP DCSP DCSP msg = ( &quot; Expected DCSP result DCSP of DCSP &apos; % s &apos; DCSP doesn &apos;t DCSP equal DCSP &apos; % s &apos; &quot; % ( expected , actual ) ) DCNL DCSP DCSP DCSP if ( utObj ! = None ) : DCNL DCSP DCSP DCSP DCSP utObj.assertEqual ( ( ( start , end , length ) = = check ) , msg ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( ( start , end , length ) = = check ) , msg DCNL DCSP DCSP elif ( len ( check ) = = 4 ) : DCNL DCSP DCSP DCSP expected = ( &apos; Showing DCSP % d DCSP to DCSP % d DCSP of DCSP % d DCSP entries DCSP ( filtered DCSP from DCSP % d DCSP total DCSP entries ) &apos; % check ) DCNL DCSP DCSP DCSP if filtered : DCNL DCSP DCSP DCSP DCSP actual = ( &apos; Showing DCSP % d DCSP to DCSP % d DCSP of DCSP % d DCSP entries DCSP ( filtered DCSP from DCSP % d DCSP total DCSP entries ) &apos; % ( start , end , length , filtered ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP actual = ( &apos; Showing DCSP % d DCSP to DCSP % d DCSP of DCSP % d DCSP entries &apos; % ( start , end , length ) ) DCNL DCSP DCSP DCSP msg = ( &quot; Expected DCSP result DCSP of DCSP &apos; % s &apos; DCSP doesn &apos;t DCSP equal DCSP &apos; % s &apos; &quot; % ( expected , actual ) ) DCNL DCSP DCSP DCSP if ( utObj ! = None ) : DCNL DCSP DCSP DCSP DCSP utObj.assertEqual ( ( ( start , end , length ) = = check ) , msg ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert ( ( start , end , length , filtered ) = = check ) , msg DCNL DCSP if ( len ( words ) &gt; 10 ) : DCNL DCSP DCSP return ( start , end , length , filtered ) DCNL DCSP else : DCNL DCSP DCSP return ( start , end , length )
DCSP size = len ( matrix ) DCNL DCSP epsilon = 0.0001 DCNL DCSP matrix = matrix.copy ( ) DCNL DCSP for i in xrange ( 0 , size ) : DCNL DCSP DCSP col _ sum = matrix &#91; : , i &#93; .sum ( ) DCNL DCSP DCSP if col _ sum : DCNL DCSP DCSP DCSP matrix &#91; : , i &#93; / = col _ sum DCNL DCSP e = ( ( ( 1.0 - d _ factor ) / size ) * numpy.ones ( ( size , size ) ) ) DCNL DCSP matrix = ( ( d _ factor * matrix ) + e ) DCNL DCSP result = ( numpy.ones ( size ) / size ) DCNL DCSP prev = ( numpy.ones ( size ) / size ) DCNL DCSP iteration = 0 DCNL DCSP while True : DCNL DCSP DCSP result = numpy.dot ( matrix , result ) DCNL DCSP DCSP result / = result.sum ( ) DCNL DCSP DCSP diff = numpy.abs ( ( result - prev ) ) .sum ( ) DCNL DCSP DCSP print ( &apos; Iteration DCSP % d , DCSP change DCSP % f &apos; % ( iteration , diff ) ) DCNL DCSP DCSP if ( diff &lt; epsilon ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP prev = result DCNL DCSP DCSP iteration + = 1 DCNL DCSP return result
DCSP if ( not proxy ) : DCNL DCSP DCSP pre _ login = session.get ( url , allow _ redirects = False , timeout = 5 ) DCNL DCSP else : DCNL DCSP DCSP pre _ login = session.get ( url , allow _ redirects = False , timeout = 5 , proxies = app.config &#91; &apos; SCHOOL _ LAN _ PROXIES &apos; &#93; ) DCNL DCSP pre _ login.raise _ for _ status ( ) DCNL DCSP pre _ login _ soup = BeautifulSoup ( pre _ login.text , &apos; html.parser &apos; , parse _ only = SoupStrainer ( &apos; input &apos; ) ) DCNL DCSP login _ view _ state = pre _ login _ soup.find ( attrs = { &apos; name &apos; : &apos; _ _ VIEWSTATE &apos; } ) &#91; &apos; value &apos; &#93; DCNL DCSP payload = { &apos; _ _ VIEWSTATE &apos; : login _ view _ state , &apos; TextBox1 &apos; : studentid , &apos; TextBox2 &apos; : studentpwd , &apos; RadioButtonList1 &apos; : u &apos; \ u5b66 \ u751f &apos; , &apos; Button1 &apos; : u &apos; DCSP \ u767b DCSP \ u5f55 DCSP &apos; } DCNL DCSP if ( not proxy ) : DCNL DCSP DCSP res = session.post ( url , data = payload , allow _ redirects = False , timeout = 5 ) DCNL DCSP else : DCNL DCSP DCSP res = session.post ( url , data = payload , allow _ redirects = False , timeout = 5 , proxies = app.config &#91; &apos; SCHOOL _ LAN _ PROXIES &apos; &#93; ) DCNL DCSP return res
DCSP config = Configurator ( root _ factory = root _ factory , settings = settings ) DCNL DCSP config.include ( &apos; pyramid _ chameleon &apos; ) DCNL DCSP config.add _ static _ view ( &apos; static &apos; , &apos; static &apos; , cache _ max _ age = 3600 ) DCNL DCSP config.scan ( ) DCNL DCSP return config.make _ wsgi _ app ( )
DCSP return ( ( getNumberOfIntersectionsToLeft ( loop , point ) % 2 ) = = 1 )
DCSP student = get _ mapped _ doc ( u &apos;Student DCSP Applicant &apos; , source _ name , { u &apos;Student DCSP Applicant &apos; : { u &apos;doctype &apos; : u &apos;Student &apos; , u &apos;field _ map &apos; : { u &apos;name &apos; : u &apos;student _ applicant &apos; } } } , ignore _ permissions = True ) DCNL DCSP student.save ( ) DCNL DCSP program _ enrollment = frappe.new _ doc ( u &apos;Program DCSP Enrollment &apos; ) DCNL DCSP program _ enrollment.student = student.name DCNL DCSP program _ enrollment.student _ name = student.title DCNL DCSP program _ enrollment.program = frappe.db.get _ value ( u &apos;Student DCSP Applicant &apos; , source _ name , u &apos;program &apos; ) DCNL DCSP return program _ enrollment
DCSP generator = fill _ gaps _ generator ( * args , * * kwargs ) DCNL DCSP return list ( generator )
DCSP oauth = credsfromfile ( ) DCNL DCSP client = Query ( * * oauth ) DCNL DCSP client.register ( TweetWriter ( ) ) DCNL DCSP client.user _ tweets ( user , count )
DCSP return GradClip ( lower _ bound , upper _ bound ) ( x )
DCSP inputs = get _ tiles ( names , config , coord ) DCNL DCSP output = { &apos; type &apos; : &apos; Topology &apos; , &apos; transform &apos; : inputs &#91; 0 &#93; &#91; &apos; transform &apos; &#93; , &apos; objects &apos; : dict ( ) , &apos; arcs &apos; : list ( ) } DCNL DCSP for ( name , input ) in zip ( names , inputs ) : DCNL DCSP DCSP for ( index , object ) in enumerate ( input &#91; &apos; objects &apos; &#93; .values ( ) ) : DCNL DCSP DCSP DCSP if ( len ( input &#91; &apos; objects &apos; &#93; ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; objects &apos; &#93; &#91; ( &apos; % ( name ) s- % ( index ) d &apos; % locals ( ) ) &#93; = object DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; objects &apos; &#93; &#91; name &#93; = object DCNL DCSP DCSP DCSP for geometry in object &#91; &apos; geometries &apos; &#93; : DCNL DCSP DCSP DCSP DCSP update _ arc _ indexes ( geometry , output &#91; &apos; arcs &apos; &#93; , input &#91; &apos; arcs &apos; &#93; ) DCNL DCSP file.write ( json.dumps ( output , separators = ( &apos; , &apos; , &apos; : &apos; ) ) .encode ( &apos; utf8 &apos; ) )
DCSP return salt.utils.cloud.os _ script ( config.get _ cloud _ config _ value ( &apos; script &apos; , vm _ , _ _ opts _ _ ) , vm _ , _ _ opts _ _ , salt.utils.cloud.salt _ config _ to _ yaml ( salt.utils.cloud.minion _ config ( _ _ opts _ _ , vm _ ) ) )
DCSP products = _ fast _ sphere _ dot _ r0 ( intrad , rsurf , rmags , lsurf , rlens , this _ nn , cosmags , None , ws , volume , lut , n _ fact , ch _ type ) .T DCNL DCSP if ( rref is not None ) : DCNL DCSP DCSP raise NotImplementedError DCNL DCSP return products
DCSP if ( not n ) : DCNL DCSP DCSP return &#91; K.one &#93; DCNL DCSP elif ( n = = 1 ) : DCNL DCSP DCSP return gf _ rem ( f , g , p , K ) DCNL DCSP elif ( n = = 2 ) : DCNL DCSP DCSP return gf _ rem ( gf _ sqr ( f , p , K ) , g , p , K ) DCNL DCSP h = &#91; K.one &#93; DCNL DCSP while True : DCNL DCSP DCSP if ( n &amp; 1 ) : DCNL DCSP DCSP DCSP h = gf _ mul ( h , f , p , K ) DCNL DCSP DCSP DCSP h = gf _ rem ( h , g , p , K ) DCNL DCSP DCSP DCSP n - = 1 DCNL DCSP DCSP n &gt; &gt; = 1 DCNL DCSP DCSP if ( not n ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP f = gf _ sqr ( f , p , K ) DCNL DCSP DCSP f = gf _ rem ( f , g , p , K ) DCNL DCSP return h
DCSP return ( x &amp; y ) .sum ( )
DCSP ret = { &apos; jid &apos; : jid } DCNL DCSP mminion = salt.minion.MasterMinion ( _ _ opts _ _ ) DCNL DCSP returner = _ get _ returner ( ( _ _ opts _ _ &#91; &apos; ext _ job _ cache &apos; &#93; , ext _ source , _ _ opts _ _ &#91; &apos; master _ job _ cache &apos; &#93; ) ) DCNL DCSP if display _ progress : DCNL DCSP DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; message &apos; : &apos; Querying DCSP returner : DCSP { 0 } &apos; .format ( returner ) } , &apos; progress &apos; ) DCNL DCSP job = mminion.returners &#91; &apos; { 0 } .get _ load &apos; .format ( returner ) &#93; ( jid ) DCNL DCSP ret.update ( _ format _ jid _ instance ( jid , job ) ) DCNL DCSP ret &#91; &apos; Result &apos; &#93; = mminion.returners &#91; &apos; { 0 } .get _ jid &apos; .format ( returner ) &#93; ( jid ) DCNL DCSP fstr = &apos; { 0 } .get _ endtime &apos; .format ( _ _ opts _ _ &#91; &apos; master _ job _ cache &apos; &#93; ) DCNL DCSP if ( _ _ opts _ _ .get ( &apos; job _ cache _ store _ endtime &apos; ) and ( fstr in mminion.returners ) ) : DCNL DCSP DCSP endtime = mminion.returners &#91; fstr &#93; ( jid ) DCNL DCSP DCSP if endtime : DCNL DCSP DCSP DCSP ret &#91; &apos; EndTime &apos; &#93; = endtime DCNL DCSP return ret
DCSP CONFIG.AddOption ( type _ info.Choice ( name = name , default = default , choices = choices , description = help ) )
DCSP cmp _ func = _ _ salt _ _ .get ( &apos; pkg.version _ cmp &apos; ) DCNL DCSP if salt.utils.is _ freebsd ( ) : DCNL DCSP DCSP if ( isinstance ( versions , dict ) and ( &apos; version &apos; in versions ) ) : DCNL DCSP DCSP DCSP versions = versions &#91; &apos; version &apos; &#93; DCNL DCSP for ver in versions : DCNL DCSP DCSP if salt.utils.compare _ versions ( ver1 = ver , oper = oper , ver2 = desired _ version , cmp _ func = cmp _ func , ignore _ epoch = ignore _ epoch ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP ret = { } DCNL DCSP with salt.utils.fopen ( exports , &apos; r &apos; ) as efl : DCNL DCSP DCSP for line in efl.read ( ) .splitlines ( ) : DCNL DCSP DCSP DCSP if ( not line ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if line.startswith ( &apos; # &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP comps = line.split ( ) DCNL DCSP DCSP DCSP ret &#91; comps &#91; 0 &#93; &#93; = &#91; &#93; DCNL DCSP DCSP DCSP newshares = &#91; &#93; DCNL DCSP DCSP DCSP for perm in comps &#91; 1 : &#93; : DCNL DCSP DCSP DCSP DCSP if perm.startswith ( &apos; / &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP newshares.append ( perm ) DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP permcomps = perm.split ( &apos; ( &apos; ) DCNL DCSP DCSP DCSP DCSP permcomps &#91; 1 &#93; = permcomps &#91; 1 &#93; .replace ( &apos; ) &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP DCSP hosts = permcomps &#91; 0 &#93; .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP DCSP options = permcomps &#91; 1 &#93; .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP DCSP ret &#91; comps &#91; 0 &#93; &#93; .append ( { &apos; hosts &apos; : hosts , &apos; options &apos; : options } ) DCNL DCSP DCSP DCSP for share in newshares : DCNL DCSP DCSP DCSP DCSP ret &#91; share &#93; = ret &#91; comps &#91; 0 &#93; &#93; DCNL DCSP return ret
DCSP drive = os.path.splitdrive ( path ) &#91; 0 &#93; DCNL DCSP if ( not os.path.isdir ( drive ) ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Drive DCSP { 0 } DCSP is DCSP not DCSP mapped &apos; .format ( drive ) ) DCNL DCSP path = os.path.expanduser ( path ) DCNL DCSP path = os.path.expandvars ( path ) DCNL DCSP if ( not os.path.isdir ( path ) ) : DCNL DCSP DCSP os.mkdir ( path ) DCNL DCSP DCSP if owner : DCNL DCSP DCSP DCSP salt.utils.win _ dacl.set _ owner ( path , owner ) DCNL DCSP DCSP set _ perms ( path , grant _ perms , deny _ perms , inheritance ) DCNL DCSP return True
DCSP def do _ something _ with ( sub ) : DCNL DCSP DCSP pass DCNL DCSP for subscription in client.list _ subscriptions ( ) : DCNL DCSP DCSP do _ something _ with ( subscription )
DCSP return ( ( ( function = = DEFINITE ) and definite _ article ( word ) ) or indefinite _ article ( word ) )
DCSP logger1.info ( &apos; &gt; &gt; notify DCSP url DCSP handler DCSP start ... &apos; ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP if notify _ verify ( request.POST ) : DCNL DCSP DCSP DCSP logger1.info ( &apos; pass DCSP verification ... &apos; ) DCNL DCSP DCSP DCSP tn = request.POST.get ( &apos; out _ trade _ no &apos; ) DCNL DCSP DCSP DCSP logger1.info ( ( &apos; Change DCSP the DCSP status DCSP of DCSP bill DCSP % s &apos; % tn ) ) DCNL DCSP DCSP DCSP bill = Bill.objects.get ( pk = tn ) DCNL DCSP DCSP DCSP trade _ status = request.POST.get ( &apos; trade _ status &apos; ) DCNL DCSP DCSP DCSP logger1.info ( ( &apos; the DCSP status DCSP of DCSP bill DCSP % s DCSP changed DCSP to DCSP % s &apos; % ( tn , trade _ status ) ) ) DCNL DCSP DCSP DCSP bill.trade _ status = trade _ status DCNL DCSP DCSP DCSP bill.save ( ) DCNL DCSP DCSP DCSP trade _ no = request.POST.get ( &apos; trade _ no &apos; ) DCNL DCSP DCSP DCSP if ( trade _ status = = &apos; WAIT _ SELLER _ SEND _ GOODS &apos; ) : DCNL DCSP DCSP DCSP DCSP logger1.info ( &apos; It DCSP is DCSP WAIT _ SELLER _ SEND _ GOODS , DCSP so DCSP upgrade DCSP bill &apos; ) DCNL DCSP DCSP DCSP DCSP upgrade _ bill ( bill , ( ( 6 * 30 ) + 7 ) ) DCNL DCSP DCSP DCSP DCSP url = send _ goods _ confirm _ by _ platform ( trade _ no ) DCNL DCSP DCSP DCSP DCSP logger1.info ( ( &apos; send DCSP goods DCSP confirmation . DCSP % s &apos; % url ) ) DCNL DCSP DCSP DCSP DCSP req = urllib.urlopen ( url ) DCNL DCSP DCSP DCSP DCSP return HttpResponse ( &apos; success &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP logger1.info ( ( &apos; # # info : DCSP Status DCSP of DCSP % s &apos; % trade _ status ) ) DCNL DCSP DCSP DCSP DCSP return HttpResponse ( &apos; success &apos; ) DCNL DCSP return HttpResponse ( &apos; fail &apos; )
DCSP if ( type ( b ) is str ) : DCNL DCSP DCSP b = b.lower ( ) DCNL DCSP if ( b = = &apos; none &apos; ) : DCNL DCSP DCSP return None DCNL DCSP if ( b in ( &apos; t &apos; , &apos; y &apos; , &apos; yes &apos; , &apos; on &apos; , &apos; true &apos; , &apos; 1&apos; , 1 , True ) ) : DCNL DCSP DCSP return True DCNL DCSP elif ( b in ( &apos; f &apos; , &apos; n &apos; , &apos; no &apos; , &apos; off &apos; , &apos; false &apos; , &apos; 0&apos; , 0 , False ) ) : DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Could DCSP not DCSP convert DCSP &quot; % s &quot; DCSP to DCSP boolean &apos; % b ) )
DCSP sc = SkyCoord ( RA , DEC , frame = u &apos;icrs &apos; ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP sc = SkyCoord ( RA , DEC , frame = ICRS ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP with catch _ warnings ( AstropyDeprecationWarning ) as w : DCNL DCSP DCSP sc = SkyCoord ( RA , DEC , u &apos;icrs &apos; ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP assert ( len ( w ) = = 1 ) DCNL DCSP assert ( str ( w &#91; 0 &#93; .message ) = = FRAME _ DEPRECATION _ WARNING ) DCNL DCSP with catch _ warnings ( AstropyDeprecationWarning ) as w : DCNL DCSP DCSP sc = SkyCoord ( RA , DEC , ICRS ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP assert ( len ( w ) = = 1 ) DCNL DCSP assert ( str ( w &#91; 0 &#93; .message ) = = FRAME _ DEPRECATION _ WARNING ) DCNL DCSP with catch _ warnings ( AstropyDeprecationWarning ) as w : DCNL DCSP DCSP sc = SkyCoord ( u &apos;icrs &apos; , RA , DEC ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP assert ( len ( w ) = = 1 ) DCNL DCSP assert ( str ( w &#91; 0 &#93; .message ) = = FRAME _ DEPRECATION _ WARNING ) DCNL DCSP with catch _ warnings ( AstropyDeprecationWarning ) as w : DCNL DCSP DCSP sc = SkyCoord ( ICRS , RA , DEC ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP assert ( len ( w ) = = 1 ) DCNL DCSP assert ( str ( w &#91; 0 &#93; .message ) = = FRAME _ DEPRECATION _ WARNING ) DCNL DCSP sc = SkyCoord ( sc ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP sc = SkyCoord ( C _ ICRS ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP SkyCoord ( C _ ICRS , frame = u &apos;icrs &apos; ) DCNL DCSP assert ( sc.frame.name = = u &apos;icrs &apos; ) DCNL DCSP with pytest.raises ( ValueError ) as err : DCNL DCSP DCSP SkyCoord ( C _ ICRS , frame = u &apos;galactic &apos; ) DCNL DCSP assert ( u &apos;Cannot DCSP override DCSP frame = &apos; in str ( err ) )
DCSP return os.urandom ( n )
DCSP return ( hasattr ( accessing _ obj , &apos; has _ player &apos; ) and accessing _ obj.has _ player )
DCSP toplevel = params &#91; &apos; options &apos; &#93; .toplevel _ dir DCNL DCSP qualified _ out _ dir = os.path.normpath ( os.path.join ( toplevel , ComputeOutputDir ( params ) , &apos; gypfiles &apos; ) ) DCNL DCSP global generator _ filelist _ paths DCNL DCSP generator _ filelist _ paths = { &apos; toplevel &apos; : toplevel , &apos; qualified _ out _ dir &apos; : qualified _ out _ dir }
DCSP raw = read _ raw _ fif ( fif _ fname , preload = True ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP assert _ raises ( ValueError , add _ reference _ channels , raw , raw.info &#91; &apos; ch _ names &apos; &#93; &#91; 0 &#93; ) DCNL DCSP raw _ ref = add _ reference _ channels ( raw , &apos; Ref &apos; , copy = True ) DCNL DCSP assert _ equal ( raw _ ref . _ data.shape &#91; 0 &#93; , ( raw . _ data.shape &#91; 0 &#93; + 1 ) ) DCNL DCSP assert _ array _ equal ( raw . _ data &#91; picks _ eeg , : &#93; , raw _ ref . _ data &#91; picks _ eeg , : &#93; ) DCNL DCSP _ check _ channel _ names ( raw _ ref , &apos; Ref &apos; ) DCNL DCSP orig _ nchan = raw.info &#91; &apos; nchan &apos; &#93; DCNL DCSP raw = add _ reference _ channels ( raw , &apos; Ref &apos; , copy = False ) DCNL DCSP assert _ array _ equal ( raw . _ data , raw _ ref . _ data ) DCNL DCSP assert _ equal ( raw.info &#91; &apos; nchan &apos; &#93; , ( orig _ nchan + 1 ) ) DCNL DCSP _ check _ channel _ names ( raw , &apos; Ref &apos; ) DCNL DCSP assert _ allclose ( raw.info &#91; &apos; chs &apos; &#93; &#91; ( -1 ) &#93; &#91; &apos; loc &apos; &#93; &#91; : 3 &#93; , raw.info &#91; &apos; chs &apos; &#93; &#91; picks _ eeg &#91; 0 &#93; &#93; &#91; &apos; loc &apos; &#93; &#91; 3 : 6 &#93; , 1e-06 ) DCNL DCSP ref _ idx = raw.ch _ names.index ( &apos; Ref &apos; ) DCNL DCSP ( ref _ data , _ ) = raw &#91; ref _ idx &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP raw = read _ raw _ fif ( fif _ fname ) .crop ( 0 , 1 ) .load _ data ( ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP del raw.info &#91; &apos; dig &apos; &#93; DCNL DCSP raw _ ref = add _ reference _ channels ( raw , &apos; Ref &apos; , copy = True ) DCNL DCSP assert _ equal ( raw _ ref . _ data.shape &#91; 0 &#93; , ( raw . _ data.shape &#91; 0 &#93; + 1 ) ) DCNL DCSP assert _ array _ equal ( raw . _ data &#91; picks _ eeg , : &#93; , raw _ ref . _ data &#91; picks _ eeg , : &#93; ) DCNL DCSP _ check _ channel _ names ( raw _ ref , &apos; Ref &apos; ) DCNL DCSP orig _ nchan = raw.info &#91; &apos; nchan &apos; &#93; DCNL DCSP raw = add _ reference _ channels ( raw , &apos; Ref &apos; , copy = False ) DCNL DCSP assert _ array _ equal ( raw . _ data , raw _ ref . _ data ) DCNL DCSP assert _ equal ( raw.info &#91; &apos; nchan &apos; &#93; , ( orig _ nchan + 1 ) ) DCNL DCSP _ check _ channel _ names ( raw , &apos; Ref &apos; ) DCNL DCSP assert _ raises ( ValueError , add _ reference _ channels , raw , raw.info &#91; &apos; ch _ names &apos; &#93; &#91; 0 &#93; ) DCNL DCSP raw _ ref = add _ reference _ channels ( raw , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; , copy = True ) DCNL DCSP _ check _ channel _ names ( raw _ ref , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; ) DCNL DCSP assert _ equal ( raw _ ref . _ data.shape &#91; 0 &#93; , ( raw . _ data.shape &#91; 0 &#93; + 2 ) ) DCNL DCSP assert _ array _ equal ( raw . _ data &#91; picks _ eeg , : &#93; , raw _ ref . _ data &#91; picks _ eeg , : &#93; ) DCNL DCSP assert _ array _ equal ( raw _ ref . _ data &#91; ( -2 ) : , : &#93; , 0 ) DCNL DCSP raw = add _ reference _ channels ( raw , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; , copy = False ) DCNL DCSP _ check _ channel _ names ( raw , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; ) DCNL DCSP ref _ idx = raw.ch _ names.index ( &apos; M1 &apos; ) DCNL DCSP ref _ idy = raw.ch _ names.index ( &apos; M2 &apos; ) DCNL DCSP ( ref _ data , _ ) = raw &#91; &#91; ref _ idx , ref _ idy &#93; &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP raw = read _ raw _ fif ( fif _ fname , preload = True ) DCNL DCSP events = read _ events ( eve _ fname ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP epochs = Epochs ( raw , events = events , event _ id = 1 , tmin = ( -0.2 ) , tmax = 0.5 , picks = picks _ eeg , preload = True ) DCNL DCSP assert _ raises ( RuntimeError , add _ reference _ channels , epochs , &apos; Ref &apos; ) DCNL DCSP epochs = Epochs ( raw , events = events , event _ id = 1 , tmin = ( -0.2 ) , tmax = 0.5 , picks = picks _ eeg , preload = True , proj = &apos; delayed &apos; ) DCNL DCSP epochs _ ref = add _ reference _ channels ( epochs , &apos; Ref &apos; , copy = True ) DCNL DCSP assert _ equal ( epochs _ ref . _ data.shape &#91; 1 &#93; , ( epochs . _ data.shape &#91; 1 &#93; + 1 ) ) DCNL DCSP _ check _ channel _ names ( epochs _ ref , &apos; Ref &apos; ) DCNL DCSP ref _ idx = epochs _ ref.ch _ names.index ( &apos; Ref &apos; ) DCNL DCSP ref _ data = epochs _ ref.get _ data ( ) &#91; : , ref _ idx , : &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP picks _ eeg = pick _ types ( epochs.info , meg = False , eeg = True ) DCNL DCSP assert _ array _ equal ( epochs.get _ data ( ) &#91; : , picks _ eeg , : &#93; , epochs _ ref.get _ data ( ) &#91; : , picks _ eeg , : &#93; ) DCNL DCSP raw = read _ raw _ fif ( fif _ fname , preload = True ) DCNL DCSP events = read _ events ( eve _ fname ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP epochs = Epochs ( raw , events = events , event _ id = 1 , tmin = ( -0.2 ) , tmax = 0.5 , picks = picks _ eeg , preload = True , proj = &apos; delayed &apos; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP epochs _ ref = add _ reference _ channels ( epochs , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; , copy = True ) DCNL DCSP assert _ equal ( epochs _ ref . _ data.shape &#91; 1 &#93; , ( epochs . _ data.shape &#91; 1 &#93; + 2 ) ) DCNL DCSP _ check _ channel _ names ( epochs _ ref , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; ) DCNL DCSP ref _ idx = epochs _ ref.ch _ names.index ( &apos; M1 &apos; ) DCNL DCSP ref _ idy = epochs _ ref.ch _ names.index ( &apos; M2 &apos; ) DCNL DCSP assert _ equal ( epochs _ ref.info &#91; &apos; chs &apos; &#93; &#91; ref _ idx &#93; &#91; &apos; ch _ name &apos; &#93; , &apos; M1 &apos; ) DCNL DCSP assert _ equal ( epochs _ ref.info &#91; &apos; chs &apos; &#93; &#91; ref _ idy &#93; &#91; &apos; ch _ name &apos; &#93; , &apos; M2 &apos; ) DCNL DCSP ref _ data = epochs _ ref.get _ data ( ) &#91; : , &#91; ref _ idx , ref _ idy &#93; , : &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP picks _ eeg = pick _ types ( epochs.info , meg = False , eeg = True ) DCNL DCSP assert _ array _ equal ( epochs.get _ data ( ) &#91; : , picks _ eeg , : &#93; , epochs _ ref.get _ data ( ) &#91; : , picks _ eeg , : &#93; ) DCNL DCSP raw = read _ raw _ fif ( fif _ fname , preload = True ) DCNL DCSP events = read _ events ( eve _ fname ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP epochs = Epochs ( raw , events = events , event _ id = 1 , tmin = ( -0.2 ) , tmax = 0.5 , picks = picks _ eeg , preload = True , proj = &apos; delayed &apos; ) DCNL DCSP evoked = epochs.average ( ) DCNL DCSP evoked _ ref = add _ reference _ channels ( evoked , &apos; Ref &apos; , copy = True ) DCNL DCSP assert _ equal ( evoked _ ref.data.shape &#91; 0 &#93; , ( evoked.data.shape &#91; 0 &#93; + 1 ) ) DCNL DCSP _ check _ channel _ names ( evoked _ ref , &apos; Ref &apos; ) DCNL DCSP ref _ idx = evoked _ ref.ch _ names.index ( &apos; Ref &apos; ) DCNL DCSP ref _ data = evoked _ ref.data &#91; ref _ idx , : &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP picks _ eeg = pick _ types ( evoked.info , meg = False , eeg = True ) DCNL DCSP assert _ array _ equal ( evoked.data &#91; picks _ eeg , : &#93; , evoked _ ref.data &#91; picks _ eeg , : &#93; ) DCNL DCSP raw = read _ raw _ fif ( fif _ fname , preload = True ) DCNL DCSP events = read _ events ( eve _ fname ) DCNL DCSP picks _ eeg = pick _ types ( raw.info , meg = False , eeg = True ) DCNL DCSP epochs = Epochs ( raw , events = events , event _ id = 1 , tmin = ( -0.2 ) , tmax = 0.5 , picks = picks _ eeg , preload = True , proj = &apos; delayed &apos; ) DCNL DCSP evoked = epochs.average ( ) DCNL DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP evoked _ ref = add _ reference _ channels ( evoked , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; , copy = True ) DCNL DCSP assert _ equal ( evoked _ ref.data.shape &#91; 0 &#93; , ( evoked.data.shape &#91; 0 &#93; + 2 ) ) DCNL DCSP _ check _ channel _ names ( evoked _ ref , &#91; &apos; M1 &apos; , &apos; M2 &apos; &#93; ) DCNL DCSP ref _ idx = evoked _ ref.ch _ names.index ( &apos; M1 &apos; ) DCNL DCSP ref _ idy = evoked _ ref.ch _ names.index ( &apos; M2 &apos; ) DCNL DCSP ref _ data = evoked _ ref.data &#91; &#91; ref _ idx , ref _ idy &#93; , : &#93; DCNL DCSP assert _ array _ equal ( ref _ data , 0 ) DCNL DCSP picks _ eeg = pick _ types ( evoked.info , meg = False , eeg = True ) DCNL DCSP assert _ array _ equal ( evoked.data &#91; picks _ eeg , : &#93; , evoked _ ref.data &#91; picks _ eeg , : &#93; ) DCNL DCSP raw _ np = read _ raw _ fif ( fif _ fname , preload = False ) DCNL DCSP assert _ raises ( RuntimeError , add _ reference _ channels , raw _ np , &#91; &apos; Ref &apos; &#93; ) DCNL DCSP assert _ raises ( ValueError , add _ reference _ channels , raw , 1 )
DCSP sidepath = ( Conv ( * * conv _ params ( 1 , ( nfm * 4 ) , 1 , False , False ) ) if first else SkipNode ( ) ) DCNL DCSP mainpath = ( &#91; &#93; if first else &#91; BatchNorm ( ) , Activation ( Rectlin ( ) ) &#93; ) DCNL DCSP mainpath.append ( Conv ( * * conv _ params ( 1 , nfm ) ) ) DCNL DCSP mainpath.append ( Conv ( * * conv _ params ( 3 , nfm ) ) ) DCNL DCSP mainpath.append ( Conv ( * * conv _ params ( 1 , ( nfm * 4 ) , relu = False , batch _ norm = False ) ) ) DCNL DCSP return MergeSum ( &#91; sidepath , mainpath &#93; )
DCSP return &#91; MockPreset ( &apos; 1&apos; ) &#93;
DCSP tests = &#91; &#93; DCNL DCSP names = &#91; &apos; testParseHostname &apos; , &apos; testExtractMastersSingle &apos; , &apos; testExtractMastersMultiple &apos; &#93; DCNL DCSP tests.extend ( list ( list ( map ( BasicTestCase , names ) ) ) ) DCNL DCSP suite = unittest.TestSuite ( tests ) DCNL DCSP unittest.TextTestRunner ( verbosity = 2 ) .run ( suite )
DCSP global dataReg DCNL DCSP if ( state = = 0 ) : DCNL DCSP DCSP dataReg = ( dataReg &amp; ( ~ 32 ) ) DCNL DCSP else : DCNL DCSP DCSP dataReg = ( dataReg &#124; 32 ) DCNL DCSP port.DlPortWritePortUchar ( baseAddress , dataReg )
DCSP return os.access ( exe , os.X _ OK )
DCSP ret = { &apos; name &apos; : &apos; testing DCSP mode &apos; , &apos; changes &apos; : { } , &apos; result &apos; : True , &apos; comment &apos; : &apos; Option DCSP already DCSP present . &apos; } DCNL DCSP option = name DCNL DCSP current _ option = _ _ salt _ _ &#91; &apos; csf.get _ option &apos; &#93; ( option ) DCNL DCSP if current _ option : DCNL DCSP DCSP l = _ _ salt _ _ &#91; &apos; csf.split _ option &apos; &#93; ( current _ option ) DCNL DCSP DCSP option _ value = l &#91; 1 &#93; DCNL DCSP DCSP if ( &apos; &quot; { 0 } &quot; &apos; .format ( value ) = = option _ value ) : DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = _ _ salt _ _ &#91; &apos; csf.set _ option &apos; &#93; ( option , value ) DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Option DCSP modified . &apos; DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; Option &apos; &#93; = &apos; Changed &apos; DCNL DCSP else : DCNL DCSP DCSP result = _ _ salt _ _ &#91; &apos; file.append &apos; &#93; ( &apos; / etc / csf / csf.conf &apos; , args = &apos; { 0 } DCSP = DCSP &quot; { 1 } &quot; &apos; .format ( option , value ) ) DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Option DCSP not DCSP present . DCSP Appended DCSP to DCSP csf.conf &apos; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; Option &apos; &#93; = &apos; Changed . &apos; DCNL DCSP if reload : DCNL DCSP DCSP if _ _ salt _ _ &#91; &apos; csf.reload &apos; &#93; ( ) : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; + = &apos; . DCSP Csf DCSP reloaded . &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; + = &apos; . DCSP Csf DCSP failed DCSP to DCSP reload . &apos; DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP return ret
DCSP if ( environ &#91; &apos; REQUEST _ METHOD &apos; &#93; .upper ( ) ! = &apos; POST &apos; ) : DCNL DCSP DCSP data = &apos; Hello , DCSP World ! \ n &apos; DCNL DCSP else : DCNL DCSP DCSP data = environ &#91; &apos; wsgi.input &apos; &#93; .read ( ) DCNL DCSP status = &apos; 200 DCSP OK &apos; DCNL DCSP response _ headers = &#91; ( &apos; Content-type &apos; , &apos; text / plain &apos; ) , ( &apos; Content-Length &apos; , str ( len ( data ) ) ) , ( &apos; X-Gunicorn-Version &apos; , _ _ version _ _ ) , ( &apos; Test &apos; , &apos; test DCSP \ xd1 \ x82 \ xd0 \ xb5 \ xd1 \ x81 \ xd1 \ x82 &apos; ) &#93; DCNL DCSP start _ response ( status , response _ headers ) DCNL DCSP return iter ( &#91; data &#93; )
DCSP model = queryset.model DCNL DCSP sql = &apos; SELECT DCSP SUM ( projects _ points.value ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP userstories _ rolepoints \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP userstories _ userstory DCSP ON DCSP userstories _ userstory.id DCSP = DCSP userstories _ rolepoints.user _ story _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP projects _ points DCSP ON DCSP userstories _ rolepoints.points _ id DCSP = DCSP projects _ points.id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP userstories _ userstory.milestone _ id DCSP = DCSP { tbl } .id &apos; DCNL DCSP sql = sql.format ( tbl = model . _ meta.db _ table ) DCNL DCSP queryset = queryset.extra ( select = { as _ field : sql } ) DCNL DCSP return queryset
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; comment &apos; : str ( ) , &apos; result &apos; : None } DCNL DCSP current _ vdirs = _ _ salt _ _ &#91; &apos; win _ iis.list _ vdirs &apos; &#93; ( site , app ) DCNL DCSP if ( name in current _ vdirs ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Virtual DCSP directory DCSP already DCSP present : DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP elif _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Virtual DCSP directory DCSP will DCSP be DCSP created : DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { &apos; old &apos; : None , &apos; new &apos; : name } DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Created DCSP virtual DCSP directory : DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { &apos; old &apos; : None , &apos; new &apos; : name } DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = _ _ salt _ _ &#91; &apos; win _ iis.create _ vdir &apos; &#93; ( name , site , sourcepath , app ) DCNL DCSP return ret
DCSP import pandas as pd DCNL DCSP return { &apos; start &apos; : pd.Timestamp ( &apos; 2004 &apos; , tz = &apos; utc &apos; ) , &apos; end &apos; : pd.Timestamp ( &apos; 2008 &apos; , tz = &apos; utc &apos; ) }
DCSP env _ vars = PACKAGE _ INFO &#91; package &#93; DCNL DCSP start _ command = get _ start _ command ( package ) DCNL DCSP proc _ start = subprocess.Popen ( start _ command , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP try : DCNL DCSP DCSP wait _ ready ( package , proc _ start ) DCNL DCSP DCSP env _ init _ command = get _ env _ init _ command ( package ) DCNL DCSP DCSP proc _ env = subprocess.Popen ( env _ init _ command , stdout = subprocess.PIPE , stderr = subprocess.PIPE ) DCNL DCSP DCSP env _ status = proc _ env.wait ( ) DCNL DCSP DCSP if ( env _ status ! = 0 ) : DCNL DCSP DCSP DCSP raise RuntimeError ( env _ status , proc _ env.stderr.read ( ) ) DCNL DCSP DCSP env _ lines = proc _ env.stdout.read ( ) .strip ( ) .split ( &apos; \ n &apos; ) DCNL DCSP DCSP for env _ var in env _ vars : DCNL DCSP DCSP DCSP line _ prefix = ( ( &apos; export DCSP &apos; + env _ var ) + &apos; = &apos; ) DCNL DCSP DCSP DCSP ( value , ) = &#91; line.split ( line _ prefix , 1 ) &#91; 1 &#93; for line in env _ lines if line.startswith ( line _ prefix ) &#93; DCNL DCSP DCSP DCSP os.environ &#91; env _ var &#93; = value DCNL DCSP DCSP run _ module _ tests ( package , ignore _ requirements = True ) DCNL DCSP finally : DCNL DCSP DCSP cleanup ( proc _ start.pid )
DCSP assert ( hsl _ to _ rgb ( 0 , 100 , 50 ) = = ( 255 , 0 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 12 , 100 , 50 ) = = ( 255 , 51 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 24 , 100 , 50 ) = = ( 255 , 102 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 36 , 100 , 50 ) = = ( 255 , 153 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 48 , 100 , 50 ) = = ( 255 , 204 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 60 , 100 , 50 ) = = ( 255 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 72 , 100 , 50 ) = = ( 204 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 84 , 100 , 50 ) = = ( 153 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 96 , 100 , 50 ) = = ( 102 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 108 , 100 , 50 ) = = ( 51 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 120 , 100 , 50 ) = = ( 0 , 255 , 0 ) )
DCSP if ( create _ using is None ) : DCNL DCSP DCSP if A.is _ directed ( ) : DCNL DCSP DCSP DCSP if A.is _ strict ( ) : DCNL DCSP DCSP DCSP DCSP create _ using = nx.DiGraph ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP create _ using = nx.MultiDiGraph ( ) DCNL DCSP DCSP elif A.is _ strict ( ) : DCNL DCSP DCSP DCSP create _ using = nx.Graph ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP create _ using = nx.MultiGraph ( ) DCNL DCSP N = nx.empty _ graph ( 0 , create _ using ) DCNL DCSP N.name = &apos; &apos; DCNL DCSP if ( A.name is not None ) : DCNL DCSP DCSP N.name = A.name DCNL DCSP for n in A.nodes ( ) : DCNL DCSP DCSP str _ attr = dict ( ( ( str ( k ) , v ) for ( k , v ) in n.attr.items ( ) ) ) DCNL DCSP DCSP N.add _ node ( str ( n ) , * * str _ attr ) DCNL DCSP for e in A.edges ( ) : DCNL DCSP DCSP ( u , v ) = ( str ( e &#91; 0 &#93; ) , str ( e &#91; 1 &#93; ) ) DCNL DCSP DCSP attr = dict ( e.attr ) DCNL DCSP DCSP str _ attr = dict ( ( ( str ( k ) , v ) for ( k , v ) in attr.items ( ) ) ) DCNL DCSP DCSP if ( not N.is _ multigraph ( ) ) : DCNL DCSP DCSP DCSP if ( e.name is not None ) : DCNL DCSP DCSP DCSP DCSP str _ attr &#91; &apos; key &apos; &#93; = e.name DCNL DCSP DCSP DCSP N.add _ edge ( u , v , * * str _ attr ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP N.add _ edge ( u , v , key = e.name , * * str _ attr ) DCNL DCSP N.graph &#91; &apos; graph &apos; &#93; = dict ( A.graph _ attr ) DCNL DCSP N.graph &#91; &apos; node &apos; &#93; = dict ( A.node _ attr ) DCNL DCSP N.graph &#91; &apos; edge &apos; &#93; = dict ( A.edge _ attr ) DCNL DCSP return N
DCSP return False
DCSP _ validate _ device ( device ) DCNL DCSP try : DCNL DCSP DCSP int ( partition ) DCNL DCSP except Exception : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Invalid DCSP partition DCSP number DCSP passed DCSP to DCSP partition.toggle &apos; ) DCNL DCSP if ( flag not in set ( &#91; &apos; bios _ grub &apos; , &apos; legacy _ boot &apos; , &apos; boot &apos; , &apos; lba &apos; , &apos; root &apos; , &apos; swap &apos; , &apos; hidden &apos; , &apos; raid &apos; , &apos; LVM &apos; , &apos; PALO &apos; , &apos; PREP &apos; , &apos; DIAG &apos; &#93; ) ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Invalid DCSP flag DCSP passed DCSP to DCSP partition.toggle &apos; ) DCNL DCSP cmd = &apos; parted DCSP -m DCSP -s DCSP { 0 } DCSP toggle DCSP { 1 } DCSP { 2 } &apos; .format ( device , partition , flag ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd ) .splitlines ( ) DCNL DCSP return out
DCSP url = editable _ req DCNL DCSP if ( os.path.isdir ( url ) and os.path.exists ( os.path.join ( url , &apos; setup.py &apos; ) ) ) : DCNL DCSP DCSP url = path _ to _ url ( url ) DCNL DCSP if url.lower ( ) .startswith ( &apos; file : &apos; ) : DCNL DCSP DCSP return ( None , url ) DCNL DCSP for version _ control in vcs : DCNL DCSP DCSP if url.lower ( ) .startswith ( ( &apos; % s : &apos; % version _ control ) ) : DCNL DCSP DCSP DCSP url = ( &apos; % s + % s &apos; % ( version _ control , url ) ) DCNL DCSP if ( &apos; + &apos; not in url ) : DCNL DCSP DCSP if default _ vcs : DCNL DCSP DCSP DCSP url = ( ( default _ vcs + &apos; + &apos; ) + url ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise InstallationError ( ( &apos; --editable = % s DCSP should DCSP be DCSP formatted DCSP with DCSP svn + URL , DCSP git + URL , DCSP hg + URL DCSP or DCSP bzr + URL &apos; % editable _ req ) ) DCNL DCSP vc _ type = url.split ( &apos; + &apos; , 1 ) &#91; 0 &#93; .lower ( ) DCNL DCSP if ( not vcs.get _ backend ( vc _ type ) ) : DCNL DCSP DCSP raise InstallationError ( ( &apos; For DCSP --editable = % s DCSP only DCSP svn DCSP ( svn + URL ) , DCSP Git DCSP ( git + URL ) , DCSP Mercurial DCSP ( hg + URL ) DCSP and DCSP Bazaar DCSP ( bzr + URL ) DCSP is DCSP currently DCSP supported &apos; % editable _ req ) ) DCNL DCSP match = re.search ( &apos; ( ? : # &#124; # . * ? &amp; ) egg = ( &#91; ^ &amp; &#93; * ) &apos; , editable _ req ) DCNL DCSP if ( ( ( not match ) or ( not match.group ( 1 ) ) ) and vcs.get _ backend ( vc _ type ) ) : DCNL DCSP DCSP parts = &#91; p for p in editable _ req.split ( &apos; # &apos; , 1 ) &#91; 0 &#93; .split ( &apos; / &apos; ) if p &#93; DCNL DCSP DCSP if ( parts &#91; ( -2 ) &#93; in ( &apos; tags &apos; , &apos; branches &apos; , &apos; tag &apos; , &apos; branch &apos; ) ) : DCNL DCSP DCSP DCSP req = parts &#91; ( -3 ) &#93; DCNL DCSP DCSP elif ( parts &#91; ( -1 ) &#93; = = &apos; trunk &apos; ) : DCNL DCSP DCSP DCSP req = parts &#91; ( -2 ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise InstallationError ( ( &apos; --editable = % s DCSP is DCSP not DCSP the DCSP right DCSP format ; DCSP it DCSP must DCSP have DCSP # egg = Package &apos; % editable _ req ) ) DCNL DCSP else : DCNL DCSP DCSP req = match.group ( 1 ) DCNL DCSP match = re.search ( &apos; ^ ( . * ? ) ( ? : -dev &#124; - \ \ d . * ) $ &apos; , req ) DCNL DCSP if match : DCNL DCSP DCSP req = match.group ( 1 ) DCNL DCSP return ( req , url )
DCSP if ( derivation = = None ) : DCNL DCSP DCSP derivation = SolidDerivation ( elementNode ) DCNL DCSP elementAttributesCopy = elementNode.attributes.copy ( ) DCNL DCSP for target in derivation.targets : DCNL DCSP DCSP targetAttributesCopy = target.attributes.copy ( ) DCNL DCSP DCSP target.attributes = elementAttributesCopy DCNL DCSP DCSP processTarget ( target ) DCNL DCSP DCSP target.attributes = targetAttributesCopy
DCSP context = args &#91; 0 &#93; DCNL DCSP seq = args &#91; 1 &#93; DCNL DCSP if ( ( len ( args ) = = 2 ) and ( &apos; attribute &apos; in kwargs ) ) : DCNL DCSP DCSP attribute = kwargs.pop ( &apos; attribute &apos; ) DCNL DCSP DCSP if kwargs : DCNL DCSP DCSP DCSP raise FilterArgumentError ( ( &apos; Unexpected DCSP keyword DCSP argument DCSP % r &apos; % next ( iter ( kwargs ) ) ) ) DCNL DCSP DCSP func = make _ attrgetter ( context.environment , attribute ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP name = args &#91; 2 &#93; DCNL DCSP DCSP DCSP args = args &#91; 3 : &#93; DCNL DCSP DCSP except LookupError : DCNL DCSP DCSP DCSP raise FilterArgumentError ( &apos; map DCSP requires DCSP a DCSP filter DCSP argument &apos; ) DCNL DCSP DCSP func = ( lambda item : context.environment.call _ filter ( name , item , args , kwargs , context = context ) ) DCNL DCSP if seq : DCNL DCSP DCSP for item in seq : DCNL DCSP DCSP DCSP ( yield func ( item ) )
DCSP result = convert ( complete _ parser ) DCNL DCSP assert ( &apos; primary &apos; in result &#91; &apos; widgets &apos; &#93; )
DCSP table = BytesIO ( ) DCNL DCSP with pytest.raises ( ascii.InconsistentTableError ) : DCNL DCSP DCSP ascii.read ( table ) DCNL DCSP table = BytesIO ( ) DCNL DCSP with pytest.raises ( ValueError ) as err : DCNL DCSP DCSP ascii.read ( table , guess = False , fast _ reader = False , format = &apos; basic &apos; ) DCNL DCSP assert ( &apos; No DCSP header DCSP line DCSP found &apos; in str ( err.value ) ) DCNL DCSP table = BytesIO ( ) DCNL DCSP with pytest.raises ( ValueError ) as err : DCNL DCSP DCSP ascii.read ( table , guess = False , fast _ reader = True , format = &apos; fast _ basic &apos; ) DCNL DCSP assert ( &apos; Inconsistent DCSP data DCSP column DCSP lengths &apos; in str ( err.value ) ) DCNL DCSP for kwargs in &#91; dict ( ) , dict ( guess = False , fast _ reader = False , format = &apos; basic &apos; ) , dict ( guess = False , fast _ reader = True , format = &apos; fast _ basic &apos; ) &#93; : DCNL DCSP DCSP table = BytesIO ( ) DCNL DCSP DCSP table.write ( &apos; a DCSP b &apos; ) DCNL DCSP DCSP t = ascii.read ( table , * * kwargs ) DCNL DCSP DCSP assert ( t.colnames = = &#91; &apos; a &apos; , &apos; b &apos; &#93; ) DCNL DCSP DCSP assert ( len ( t ) = = 0 )
DCSP def prep ( r ) : DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP elif ( r.representation = = &apos; plain &apos; ) : DCNL DCSP DCSP DCSP r.table.image _ url.readable = False DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP elif ( r.representation = = &apos; plain &apos; ) : DCNL DCSP DCSP DCSP image _ url = r.record.image _ url DCNL DCSP DCSP DCSP if image _ url : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; item &apos; &#93; .append ( IMG ( _ src = image _ url , _ width = 400 , _ height = 310 ) ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3 _ rest _ controller ( ) DCNL DCSP return output
DCSP store _ utils.delete _ image _ location _ from _ backend ( req.context , id , location _ data )
DCSP return ( timedelta _ to _ integral _ seconds ( delta ) / / 60 )
DCSP return _ uninstall ( action = &apos; purge &apos; , name = name , pkgs = pkgs , * * kwargs )
DCSP def verifyCol ( strg , locn , toks ) : DCNL DCSP DCSP if ( col ( locn , strg ) ! = n ) : DCNL DCSP DCSP DCSP raise ParseException ( strg , locn , ( &apos; matched DCSP token DCSP not DCSP at DCSP column DCSP % d &apos; % n ) ) DCNL DCSP return verifyCol
DCSP return ( ( value % 2 ) = = 1 )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP log.error ( &apos; The DCSP list _ keys DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP DCSP return False DCNL DCSP if ( not kwargs ) : DCNL DCSP DCSP kwargs = { } DCNL DCSP if ( &apos; keyname &apos; not in kwargs ) : DCNL DCSP DCSP log.error ( &apos; A DCSP keyname DCSP is DCSP required . &apos; ) DCNL DCSP DCSP return False DCNL DCSP ( rcode , data ) = query ( command = &apos; my / keys / { 0 } &apos; .format ( kwargs &#91; &apos; keyname &apos; &#93; ) , method = &apos; GET &apos; ) DCNL DCSP return { &apos; keys &apos; : { data &#91; &apos; name &apos; &#93; : data &#91; &apos; key &apos; &#93; } }
DCSP if ( ( graph . _ adjacency is not None ) and ( graph . _ adjacency &#91; 1 : &#93; = = ( directed , reversed , stochastic , ( heuristic and heuristic.func _ code ) ) ) ) : DCNL DCSP DCSP return graph . _ adjacency &#91; 0 &#93; DCNL DCSP map = { } DCNL DCSP for n in graph.nodes : DCNL DCSP DCSP map &#91; n.id &#93; = { } DCNL DCSP for e in graph.edges : DCNL DCSP DCSP ( id1 , id2 ) = ( ( ( not reversed ) and ( e.node1.id , e.node2.id ) ) or ( e.node2.id , e.node1.id ) ) DCNL DCSP DCSP map &#91; id1 &#93; &#91; id2 &#93; = ( 1.0 - ( 0.5 * e.weight ) ) DCNL DCSP DCSP if heuristic : DCNL DCSP DCSP DCSP map &#91; id1 &#93; &#91; id2 &#93; + = heuristic ( id1 , id2 ) DCNL DCSP DCSP if ( not directed ) : DCNL DCSP DCSP DCSP map &#91; id2 &#93; &#91; id1 &#93; = map &#91; id1 &#93; &#91; id2 &#93; DCNL DCSP if stochastic : DCNL DCSP DCSP for id1 in map : DCNL DCSP DCSP DCSP n = sum ( map &#91; id1 &#93; .values ( ) ) DCNL DCSP DCSP DCSP for id2 in map &#91; id1 &#93; : DCNL DCSP DCSP DCSP DCSP map &#91; id1 &#93; &#91; id2 &#93; / = n DCNL DCSP graph . _ adjacency = ( map , directed , reversed , stochastic , ( heuristic and heuristic.func _ code ) ) DCNL DCSP return map
DCSP visitor = _ NodeNameCollector ( ) DCNL DCSP ast.walk ( node , visitor ) DCNL DCSP return visitor.names
DCSP if ( ( not _ isproperdist ( px ) ) or ( not _ isproperdist ( py ) ) ) : DCNL DCSP DCSP raise ValueError ( &apos; px DCSP or DCSP py DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP distribution &apos; ) DCNL DCSP if ( ( pxpy ! = None ) and ( not _ isproperdist ( pxpy ) ) ) : DCNL DCSP DCSP raise ValueError ( &apos; pxpy DCSP is DCSP not DCSP a DCSP proper DCSP joint DCSP distribtion &apos; ) DCNL DCSP if ( pxpy = = None ) : DCNL DCSP DCSP pxpy = np.outer ( py , px ) DCNL DCSP condent = np.sum ( ( pxpy * np.nan _ to _ num ( np.log2 ( ( py / pxpy ) ) ) ) ) DCNL DCSP if ( logbase = = 2 ) : DCNL DCSP DCSP return condent DCNL DCSP else : DCNL DCSP DCSP return ( logbasechange ( 2 , logbase ) * condent )
DCSP kwargs.setdefault ( &apos; accept _ magic _ kwargs &apos; , False ) DCNL DCSP return app _ or _ default ( ) .task ( * args , * * kwargs )
DCSP if ( hasattr ( context , &apos; auth _ token &apos; ) and context.auth _ token ) : DCNL DCSP DCSP return True DCNL DCSP def _ is _ image _ public ( image ) : DCNL DCSP DCSP if hasattr ( image , &apos; visibility &apos; ) : DCNL DCSP DCSP DCSP return ( str ( image.visibility ) .lower ( ) = = &apos; public &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return image.is _ public DCNL DCSP if ( context.is _ admin or _ is _ image _ public ( image ) ) : DCNL DCSP DCSP return True DCNL DCSP properties = image.properties DCNL DCSP if ( context.project _ id and ( &apos; owner _ id &apos; in properties ) ) : DCNL DCSP DCSP return ( str ( properties &#91; &apos; owner _ id &apos; &#93; ) = = str ( context.project _ id ) ) DCNL DCSP if ( context.project _ id and ( &apos; project _ id &apos; in properties ) ) : DCNL DCSP DCSP return ( str ( properties &#91; &apos; project _ id &apos; &#93; ) = = str ( context.project _ id ) ) DCNL DCSP try : DCNL DCSP DCSP user _ id = properties &#91; &apos; user _ id &apos; &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP return False DCNL DCSP return ( str ( user _ id ) = = str ( context.user _ id ) )
DCSP rights _ manager.publish _ exploration ( committer _ id , exp _ id ) DCNL DCSP contribution _ time _ msec = utils.get _ current _ time _ in _ millisecs ( ) DCNL DCSP contributor _ ids = get _ exploration _ summary _ by _ id ( exp _ id ) .contributor _ ids DCNL DCSP for contributor in contributor _ ids : DCNL DCSP DCSP user _ services.update _ first _ contribution _ msec _ if _ not _ set ( contributor , contribution _ time _ msec )
DCSP if ( factor = = 1 ) : DCNL DCSP DCSP return inputs DCNL DCSP else : DCNL DCSP DCSP return slim.max _ pool2d ( inputs , &#91; 1 , 1 &#93; , stride = factor , scope = scope )
DCSP group = get _ object _ or _ 404 ( Group , slug = slug , is _ active = True ) DCNL DCSP form = GroupInviteForm ( initial = { &apos; group &apos; : group.pk , &apos; user &apos; : request.user.pk } ) DCNL DCSP return render ( request , template _ name , { &apos; group &apos; : group , &apos; form &apos; : form } )
DCSP while files : DCNL DCSP DCSP cmd = list ( STRIPCMD ) DCNL DCSP DCSP pathlen = sum ( ( ( len ( s ) + 1 ) for s in cmd ) ) DCNL DCSP DCSP while ( ( pathlen &lt; argv _ max ) and files ) : DCNL DCSP DCSP DCSP f = files.pop ( ) DCNL DCSP DCSP DCSP cmd.append ( f ) DCNL DCSP DCSP DCSP pathlen + = ( len ( f ) + 1 ) DCNL DCSP DCSP if ( len ( cmd ) &gt; len ( STRIPCMD ) ) : DCNL DCSP DCSP DCSP all _ files = cmd &#91; len ( STRIPCMD ) : &#93; DCNL DCSP DCSP DCSP unwritable _ files = tuple ( filter ( None , ( ( None if os.access ( x , os.W _ OK ) else ( x , os.stat ( x ) .st _ mode ) ) for x in all _ files ) ) ) DCNL DCSP DCSP DCSP &#91; os.chmod ( x , ( stat.S _ IWRITE &#124; old _ mode ) ) for ( x , old _ mode ) in unwritable _ files &#93; DCNL DCSP DCSP DCSP subprocess.check _ call ( cmd ) DCNL DCSP DCSP DCSP &#91; os.chmod ( x , old _ mode ) for ( x , old _ mode ) in unwritable _ files &#93;
DCSP if isinstance ( t2 , ( TensMul , Tensor ) ) : DCNL DCSP DCSP args = &#91; t2 &#93; DCNL DCSP else : DCNL DCSP DCSP args = t2.args DCNL DCSP a1 = &#91; x.split ( ) for x in args &#93; DCNL DCSP a2 = &#91; &#91; riemann _ cyclic _ replace ( tx ) for tx in y &#93; for y in a1 &#93; DCNL DCSP a3 = &#91; tensor _ mul ( * v ) for v in a2 &#93; DCNL DCSP t3 = TensAdd ( * a3 ) DCNL DCSP if ( not t3 ) : DCNL DCSP DCSP return t3 DCNL DCSP else : DCNL DCSP DCSP return canon _ bp ( t3 )
DCSP attributes = bleach.ALLOWED _ ATTRIBUTES.copy ( ) DCNL DCSP if ( u &apos;data &apos; not in bleach.BleachSanitizer.allowed _ protocols ) : DCNL DCSP DCSP bleach.BleachSanitizer.allowed _ protocols.append ( u &apos;data &apos; ) DCNL DCSP attributes.update ( { &apos; * &apos; : &#91; &apos; class &apos; , &apos; style &apos; , &apos; id &apos; &#93; , &apos; audio &apos; : &#91; &apos; controls &apos; , &apos; autobuffer &apos; , &apos; autoplay &apos; , &apos; src &apos; &#93; , &apos; img &apos; : &#91; &apos; src &apos; , &apos; width &apos; , &apos; height &apos; , &apos; class &apos; &#93; } ) DCNL DCSP output = bleach.clean ( html _ code , tags = ( bleach.ALLOWED _ TAGS + &#91; &apos; div &apos; , &apos; p &apos; , &apos; audio &apos; , &apos; pre &apos; , &apos; img &apos; , &apos; span &apos; &#93; ) , styles = &#91; &apos; white-space &apos; &#93; , attributes = attributes ) DCNL DCSP return output
DCSP cache _ path = _ local _ cache _ path ( tex _ root ) DCNL DCSP _ validate _ life _ span ( cache _ path ) DCNL DCSP return _ read ( cache _ path , name )
DCSP if ( not in _ place ) : DCNL DCSP DCSP rag = rag.copy ( ) DCNL DCSP to _ remove = &#91; ( x , y ) for ( x , y , d ) in rag.edges _ iter ( data = True ) if ( d &#91; &apos; weight &apos; &#93; &gt; = thresh ) &#93; DCNL DCSP rag.remove _ edges _ from ( to _ remove ) DCNL DCSP comps = nx.connected _ components ( rag ) DCNL DCSP map _ array = np.arange ( ( labels.max ( ) + 1 ) , dtype = labels.dtype ) DCNL DCSP for ( i , nodes ) in enumerate ( comps ) : DCNL DCSP DCSP for node in nodes : DCNL DCSP DCSP DCSP for label in rag.node &#91; node &#93; &#91; &apos; labels &apos; &#93; : DCNL DCSP DCSP DCSP DCSP map _ array &#91; label &#93; = i DCNL DCSP return map _ array &#91; labels &#93;
DCSP prof = get _ object _ or _ 404 ( GroupProfile , slug = group _ slug ) DCNL DCSP if ( not _ user _ can _ manage _ leaders ( request.user , prof ) ) : DCNL DCSP DCSP raise PermissionDenied DCNL DCSP form = AddUserForm ( request.POST ) DCNL DCSP if form.is _ valid ( ) : DCNL DCSP DCSP for user in form.cleaned _ data &#91; &apos; users &apos; &#93; : DCNL DCSP DCSP DCSP if ( prof.group not in user.groups.all ( ) ) : DCNL DCSP DCSP DCSP DCSP user.groups.add ( prof.group ) DCNL DCSP DCSP DCSP prof.leaders.add ( user ) DCNL DCSP DCSP msg = _ ( &apos; { users } DCSP added DCSP to DCSP the DCSP group DCSP leaders DCSP successfully ! &apos; ) .format ( users = request.POST.get ( &apos; users &apos; ) ) DCNL DCSP DCSP messages.add _ message ( request , messages.SUCCESS , msg ) DCNL DCSP DCSP return HttpResponseRedirect ( prof.get _ absolute _ url ( ) ) DCNL DCSP msg = _ ( &apos; There DCSP were DCSP errors DCSP adding DCSP leaders DCSP to DCSP the DCSP group , DCSP see DCSP below . &apos; ) DCNL DCSP messages.add _ message ( request , messages.ERROR , msg ) DCNL DCSP return profile ( request , group _ slug , leader _ form = form )
DCSP if ( not contribution _ src ) : DCNL DCSP DCSP contribution _ src = src DCNL DCSP has _ suggested = bool ( addon.suggested _ amount ) DCNL DCSP comment _ limit = PAYPAL _ MAX _ COMMENT _ LENGTH DCNL DCSP return new _ context ( * * locals ( ) )
DCSP return ( 0.5 * ( vel * * 2 ) .sum ( axis = 1 ) )
DCSP try : DCNL DCSP DCSP _ id = request.args &#91; 0 &#93; DCNL DCSP except : DCNL DCSP DCSP raise HTTP ( 400 ) DCNL DCSP translate = settings.get _ L10n _ translate _ gis _ location ( ) DCNL DCSP if translate : DCNL DCSP DCSP language = session.s3.language DCNL DCSP DCSP if ( language = = settings.get _ L10n _ default _ language ( ) ) : DCNL DCSP DCSP DCSP translate = False DCNL DCSP table = s3db.gis _ location DCNL DCSP query = ( ( ( ( table.deleted = = False ) &amp; ( table.level ! = None ) ) &amp; ( table.end _ date = = None ) ) &amp; ( ( table.parent = = _ id ) &#124; ( table.id = = _ id ) ) ) DCNL DCSP fields = &#91; table.id , table.name , table.level , table.parent , table.lon _ min , table.lat _ min , table.lon _ max , table.lat _ max &#93; DCNL DCSP if translate : DCNL DCSP DCSP ntable = s3db.gis _ location _ name DCNL DCSP DCSP fields.append ( ntable.name _ l10n ) DCNL DCSP DCSP left = ntable.on ( ( ( ( ntable.deleted = = False ) &amp; ( ntable.language = = language ) ) &amp; ( ntable.location _ id = = table.id ) ) ) DCNL DCSP else : DCNL DCSP DCSP left = None DCNL DCSP locations = db ( query ) .select ( left = left , * fields ) DCNL DCSP if translate : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP id _ level = int ( locations.as _ dict ( key = &apos; gis _ location.id &apos; ) &#91; int ( _ id ) &#93; &#91; &apos; gis _ location &apos; &#93; &#91; &apos; level &apos; &#93; &#91; 1 : &#93; ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP id _ level = int ( locations.as _ dict ( ) &#91; int ( _ id ) &#93; &#91; &apos; level &apos; &#93; &#91; 1 : &#93; ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return &apos; &apos; DCNL DCSP output _ level = ( id _ level + 1 ) DCNL DCSP search _ level = ( &apos; L % s &apos; % output _ level ) DCNL DCSP location _ dict = { } DCNL DCSP if translate : DCNL DCSP DCSP for location in locations : DCNL DCSP DCSP DCSP l = location &#91; &apos; gis _ location &apos; &#93; DCNL DCSP DCSP DCSP if ( l.level = = search _ level ) : DCNL DCSP DCSP DCSP DCSP this _ level = output _ level DCNL DCSP DCSP DCSP DCSP f = int ( l.parent ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP this _ level = int ( l.level &#91; 1 : &#93; ) DCNL DCSP DCSP DCSP DCSP parent = l.parent DCNL DCSP DCSP DCSP DCSP if parent : DCNL DCSP DCSP DCSP DCSP DCSP f = int ( parent ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP f = None DCNL DCSP DCSP DCSP name = ( location &#91; &apos; gis _ location _ name.name _ l10n &apos; &#93; or l.name ) DCNL DCSP DCSP DCSP if ( l.lon _ min is not None ) : DCNL DCSP DCSP DCSP DCSP location _ dict &#91; int ( l.id ) &#93; = dict ( n = name , l = this _ level , f = f , b = &#91; l.lon _ min , l.lat _ min , l.lon _ max , l.lat _ max &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP location _ dict &#91; int ( l.id ) &#93; = dict ( n = name , l = this _ level , f = f ) DCNL DCSP else : DCNL DCSP DCSP for l in locations : DCNL DCSP DCSP DCSP if ( l.level = = search _ level ) : DCNL DCSP DCSP DCSP DCSP this _ level = output _ level DCNL DCSP DCSP DCSP DCSP f = int ( l.parent ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP this _ level = int ( l.level &#91; 1 : &#93; ) DCNL DCSP DCSP DCSP DCSP parent = l.parent DCNL DCSP DCSP DCSP DCSP if parent : DCNL DCSP DCSP DCSP DCSP DCSP f = int ( parent ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP f = None DCNL DCSP DCSP DCSP if ( l.lon _ min is not None ) : DCNL DCSP DCSP DCSP DCSP location _ dict &#91; int ( l.id ) &#93; = dict ( n = l.name , l = this _ level , f = f , b = &#91; l.lon _ min , l.lat _ min , l.lon _ max , l.lat _ max &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP location _ dict &#91; int ( l.id ) &#93; = dict ( n = l.name , l = this _ level , f = f ) DCNL DCSP script = ( &apos; n = % s \ n &apos; % json.dumps ( location _ dict , separators = SEPARATORS ) ) DCNL DCSP response.headers &#91; &apos; Content-Type &apos; &#93; = &apos; application / json &apos; DCNL DCSP return script
DCSP return IMPL.flavor _ destroy ( context , flavor _ id )
DCSP if ( not src ) : DCNL DCSP DCSP return UNKNOWN _ MODULE DCNL DCSP ( filename , ext ) = splitext ( urlsplit ( src ) .path ) DCNL DCSP if ( ext not in ( &apos; .js &apos; , &apos; .jsx &apos; , &apos; .coffee &apos; ) ) : DCNL DCSP DCSP return UNKNOWN _ MODULE DCNL DCSP if filename.endswith ( &apos; .min &apos; ) : DCNL DCSP DCSP filename = filename &#91; : ( -4 ) &#93; DCNL DCSP tokens = filename.split ( &apos; / &apos; ) DCNL DCSP for ( idx , token ) in enumerate ( tokens ) : DCNL DCSP DCSP if VERSION _ RE.match ( token ) : DCNL DCSP DCSP DCSP return &apos; / &apos; .join ( tokens &#91; ( idx + 1 ) : &#93; ) DCNL DCSP return ( CLEAN _ MODULE _ RE.sub ( &apos; &apos; , filename ) or UNKNOWN _ MODULE )
DCSP trap = Trap ( ) DCNL DCSP prev _ tls = _ state . _ tls DCNL DCSP _ state.set _ default _ app ( trap ) DCNL DCSP class NonTLS ( object , ) : DCNL DCSP DCSP current _ app = trap DCNL DCSP _ state . _ tls = NonTLS ( ) DCNL DCSP ( yield ) DCNL DCSP _ state . _ tls = prev _ tls
DCSP return OrderedDict ( settings.LANGUAGES )
DCSP return ( not bool ( BAD _ URI _ CHARS _ RE.search ( uri ) ) )
DCSP net = { } DCNL DCSP net &#91; &apos; input &apos; &#93; = InputLayer ( ( None , 3 , 16 , 112 , 112 ) ) DCNL DCSP net &#91; &apos; conv1a &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; input &apos; &#93; , 64 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify , flip _ filters = False ) DCNL DCSP net &#91; &apos; pool1 &apos; &#93; = MaxPool3DDNNLayer ( net &#91; &apos; conv1a &apos; &#93; , pool _ size = ( 1 , 2 , 2 ) , stride = ( 1 , 2 , 2 ) ) DCNL DCSP net &#91; &apos; conv2a &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; pool1 &apos; &#93; , 128 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; pool2 &apos; &#93; = MaxPool3DDNNLayer ( net &#91; &apos; conv2a &apos; &#93; , pool _ size = ( 2 , 2 , 2 ) , stride = ( 2 , 2 , 2 ) ) DCNL DCSP net &#91; &apos; conv3a &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; pool2 &apos; &#93; , 256 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; conv3b &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; conv3a &apos; &#93; , 256 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; pool3 &apos; &#93; = MaxPool3DDNNLayer ( net &#91; &apos; conv3b &apos; &#93; , pool _ size = ( 2 , 2 , 2 ) , stride = ( 2 , 2 , 2 ) ) DCNL DCSP net &#91; &apos; conv4a &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; pool3 &apos; &#93; , 512 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; conv4b &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; conv4a &apos; &#93; , 512 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; pool4 &apos; &#93; = MaxPool3DDNNLayer ( net &#91; &apos; conv4b &apos; &#93; , pool _ size = ( 2 , 2 , 2 ) , stride = ( 2 , 2 , 2 ) ) DCNL DCSP net &#91; &apos; conv5a &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; pool4 &apos; &#93; , 512 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; conv5b &apos; &#93; = Conv3DDNNLayer ( net &#91; &apos; conv5a &apos; &#93; , 512 , ( 3 , 3 , 3 ) , pad = 1 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; pad &apos; &#93; = PadLayer ( net &#91; &apos; conv5b &apos; &#93; , width = &#91; ( 0 , 1 ) , ( 0 , 1 ) &#93; , batch _ ndim = 3 ) DCNL DCSP net &#91; &apos; pool5 &apos; &#93; = MaxPool3DDNNLayer ( net &#91; &apos; pad &apos; &#93; , pool _ size = ( 2 , 2 , 2 ) , pad = ( 0 , 0 , 0 ) , stride = ( 2 , 2 , 2 ) ) DCNL DCSP net &#91; &apos; fc6-1 &apos; &#93; = DenseLayer ( net &#91; &apos; pool5 &apos; &#93; , num _ units = 4096 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; fc7-1 &apos; &#93; = DenseLayer ( net &#91; &apos; fc6-1 &apos; &#93; , num _ units = 4096 , nonlinearity = lasagne.nonlinearities.rectify ) DCNL DCSP net &#91; &apos; fc8-1 &apos; &#93; = DenseLayer ( net &#91; &apos; fc7-1 &apos; &#93; , num _ units = 487 , nonlinearity = None ) DCNL DCSP net &#91; &apos; prob &apos; &#93; = NonlinearityLayer ( net &#91; &apos; fc8-1 &apos; &#93; , softmax ) DCNL DCSP return net
DCSP return config.get _ cloud _ config _ value ( &apos; ssh _ interface &apos; , vm _ , _ _ opts _ _ , default = &apos; public _ ips &apos; , search _ global = False )
DCSP return config.get _ cloud _ config _ value ( &apos; tenancy &apos; , vm _ , _ _ opts _ _ , search _ global = False )
DCSP if hasattr ( x , &apos; getnnz &apos; ) : DCNL DCSP DCSP x = as _ sparse _ variable ( x ) DCNL DCSP DCSP assert ( x.format in &#91; &apos; csr &apos; , &apos; csc &apos; &#93; ) DCNL DCSP if hasattr ( y , &apos; getnnz &apos; ) : DCNL DCSP DCSP y = as _ sparse _ variable ( y ) DCNL DCSP DCSP assert ( y.format in &#91; &apos; csr &apos; , &apos; csc &apos; &#93; ) DCNL DCSP x _ is _ sparse _ variable = _ is _ sparse _ variable ( x ) DCNL DCSP y _ is _ sparse _ variable = _ is _ sparse _ variable ( y ) DCNL DCSP if ( ( not x _ is _ sparse _ variable ) and ( not y _ is _ sparse _ variable ) ) : DCNL DCSP DCSP raise TypeError ( ) DCNL DCSP if x _ is _ sparse _ variable : DCNL DCSP DCSP return TrueDot ( grad _ preserves _ dense ) ( x , y ) DCNL DCSP else : DCNL DCSP DCSP assert y _ is _ sparse _ variable DCNL DCSP DCSP return transpose ( TrueDot ( grad _ preserves _ dense ) ( y.T , x.T ) )
DCSP opt _ name = ( &apos; --map- &apos; + type ) DCNL DCSP value _ rx = &apos; ^ ( &#91; ^ = &#93; + ) = ( &#91; ^ = &#93; * ) $ &apos; DCNL DCSP if ( type in ( &apos; uid &apos; , &apos; gid &apos; ) ) : DCNL DCSP DCSP value _ rx = &apos; ^ ( - ? &#91; 0-9 &#93; + ) = ( - ? &#91; 0-9 &#93; + ) $ &apos; DCNL DCSP owner _ map = { } DCNL DCSP for flag in options : DCNL DCSP DCSP ( option , parameter ) = flag DCNL DCSP DCSP if ( option ! = opt _ name ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP match = re.match ( value _ rx , parameter ) DCNL DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP raise fatal ( ( &quot; couldn &apos;t DCSP parse DCSP % s DCSP as DCSP % s DCSP mapping &quot; % ( parameter , type ) ) ) DCNL DCSP DCSP ( old _ id , new _ id ) = match.groups ( ) DCNL DCSP DCSP if ( type in ( &apos; uid &apos; , &apos; gid &apos; ) ) : DCNL DCSP DCSP DCSP old _ id = int ( old _ id ) DCNL DCSP DCSP DCSP new _ id = int ( new _ id ) DCNL DCSP DCSP owner _ map &#91; old _ id &#93; = new _ id DCNL DCSP return owner _ map
DCSP handler = XmlRpcReadHandler ( ) DCNL DCSP xml.sax.parseString ( xml _ string , handler ) DCNL DCSP return handler
DCSP with settings ( hide ( &apos; running &apos; , &apos; stdout &apos; ) ) : DCNL DCSP DCSP kernel = run ( &apos; uname DCSP -s &apos; ) DCNL DCSP DCSP if ( kernel = = &apos; Linux &apos; ) : DCNL DCSP DCSP DCSP return run ( &apos; lsb _ release DCSP -r DCSP --short &apos; ) DCNL DCSP DCSP elif ( kernel = = &apos; SunOS &apos; ) : DCNL DCSP DCSP DCSP return run ( &apos; uname DCSP -v &apos; )
DCSP return project.memberships.count ( )
DCSP p0 = &#91; guess _ plateau ( x , y ) , 4.0 , guess _ lag ( x , y ) , 0.1 , min ( y ) &#93; DCNL DCSP ( params , pcov ) = curve _ fit ( function , x , y , p0 = p0 ) DCNL DCSP return ( params , pcov )
DCSP result = &#91; &#93; DCNL DCSP for X in iterables : DCNL DCSP DCSP if sp.issparse ( X ) : DCNL DCSP DCSP DCSP result.append ( X.tocsr ( ) ) DCNL DCSP DCSP elif ( hasattr ( X , &apos; _ _ getitem _ _ &apos; ) or hasattr ( X , &apos; iloc &apos; ) ) : DCNL DCSP DCSP DCSP result.append ( X ) DCNL DCSP DCSP elif ( X is None ) : DCNL DCSP DCSP DCSP result.append ( X ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result.append ( np.array ( X ) ) DCNL DCSP check _ consistent _ length ( * result ) DCNL DCSP return result
DCSP query = request.GET.get ( &apos; q &apos; , None ) DCNL DCSP if ( not query ) : DCNL DCSP DCSP return Response ( { &apos; error &apos; : &apos; Search DCSP term DCSP required . DCSP Use DCSP the DCSP &quot; q &quot; DCSP GET DCSP arg DCSP to DCSP search . DCSP &apos; } , status = status.HTTP _ 400 _ BAD _ REQUEST ) DCNL DCSP project _ slug = request.GET.get ( &apos; project &apos; , None ) DCNL DCSP version _ slug = request.GET.get ( &apos; version &apos; , LATEST ) DCNL DCSP path = request.GET.get ( &apos; path &apos; , None ) DCNL DCSP log.debug ( &apos; ( API DCSP Section DCSP Search ) DCSP &#91; % s : % s &#93; DCSP % s &apos; , project _ slug , version _ slug , query ) DCNL DCSP results = search _ section ( request = request , query = query , project _ slug = project _ slug , version _ slug = version _ slug , path = path ) DCNL DCSP return Response ( { &apos; results &apos; : results } )
DCSP if ( not name ) : DCNL DCSP DCSP return name DCNL DCSP removeWordsList = { u &apos; \ \ &#91; rartv \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; rarbg \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; eztv \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; ettv \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; cttv \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; vtv \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; EtHD \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; GloDLS \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; silv4 \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; Seedbox \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; PublicHD \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; AndroidTwoU \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ . \ \ &#91; BT \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; DCSP \ \ &#91; 1044 \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; \ \ .RiPSaLoT $ &apos; : u &apos;searchre &apos; , u &apos; \ \ .GiuseppeTnT $ &apos; : u &apos;searchre &apos; , u &apos; \ \ .Renc $ &apos; : u &apos;searchre &apos; , u &apos; -NZBGEEK $ &apos; : u &apos;searchre &apos; , u &apos; -Siklopentan $ &apos; : u &apos;searchre &apos; , u &apos; - \ \ &#91; SpastikusTV \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; -RP $ &apos; : u &apos;searchre &apos; , u &apos; -20-40 $ &apos; : u &apos;searchre &apos; , u &apos; \ \ . \ \ &#91; www \ \ .usabit \ \ .com \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; www \ \ .Cpasbien \ \ .pe \ \ &#93; DCSP &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; www \ \ .Cpasbien \ \ .com \ \ &#93; DCSP &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; DCSP www \ \ .Cpasbien \ \ .pw DCSP \ \ &#93; DCSP &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ .www \ \ .Cpasbien \ \ .pw &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; www \ \ .newpct1 \ \ .com \ \ &#93; &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; DCSP www \ \ .Cpasbien \ \ .com DCSP \ \ &#93; DCSP &apos; : u &apos;searchre &apos; , u &apos; - DCSP \ \ { DCSP www \ \ .SceneTime \ \ .com DCSP \ \ } $ &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ { DCSP www \ \ .SceneTime \ \ .com DCSP \ \ } DCSP - DCSP &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#93; \ \ . \ \ &#91; www \ \ .tensiontorrent.com \ \ &#93; DCSP - DCSP &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#93; \ \ . \ \ &#91; DCSP www \ \ .tensiontorrent.com DCSP \ \ &#93; DCSP - DCSP &apos; : u &apos;searchre &apos; , u &apos; - DCSP \ \ &#91; DCSP www \ \ .torrentday \ \ .com DCSP \ \ &#93; $ &apos; : u &apos;searchre &apos; , u &apos; ^ \ \ &#91; DCSP www \ \ .TorrentDay \ \ .com DCSP \ \ &#93; DCSP - DCSP &apos; : u &apos;searchre &apos; , u &apos; \ \ &#91; NO-RAR \ \ &#93; DCSP - DCSP \ \ &#91; DCSP www \ \ .torrentday \ \ .com DCSP \ \ &#93; $ &apos; : u &apos;searchre &apos; } DCNL DCSP _ name = name DCNL DCSP for ( remove _ string , remove _ type ) in removeWordsList.items ( ) : DCNL DCSP DCSP if ( remove _ type = = u &apos;search &apos; ) : DCNL DCSP DCSP DCSP _ name = _ name.replace ( remove _ string , u &apos; &apos; ) DCNL DCSP DCSP elif ( remove _ type = = u &apos;searchre &apos; ) : DCNL DCSP DCSP DCSP _ name = re.sub ( ( u &apos; ( ? i ) &apos; + remove _ string ) , u &apos; &apos; , _ name ) DCNL DCSP return _ name.strip ( u &apos; .- DCSP &#91; &#93; { } &apos; )
DCSP if ( isinstance ( obj , str ) or isinstance ( obj , unicode ) ) : DCNL DCSP DCSP return False DCNL DCSP res = True DCNL DCSP for a in ( &apos; read &apos; , &apos; tell &apos; , &apos; seek &apos; ) : DCNL DCSP DCSP res = ( res and hasattr ( obj , a ) ) DCNL DCSP if ( not res ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP object DCSP passed DCSP as DCSP file &apos; ) DCNL DCSP return True
DCSP try : DCNL DCSP DCSP locations = ( os.path.expanduser ( &apos; ~ / { 0 } &apos; .format ( f ) ) for f in NETRC _ FILES ) DCNL DCSP DCSP netrc _ path = None DCNL DCSP DCSP for loc in locations : DCNL DCSP DCSP DCSP if ( os.path.exists ( loc ) and ( not netrc _ path ) ) : DCNL DCSP DCSP DCSP DCSP netrc _ path = loc DCNL DCSP DCSP if ( netrc _ path is None ) : DCNL DCSP DCSP DCSP return netrc _ path DCNL DCSP DCSP ri = urlparse ( url ) DCNL DCSP DCSP host = ri.netloc.split ( &apos; : &apos; ) &#91; 0 &#93; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ netrc = netrc ( netrc _ path ) .authenticators ( host ) DCNL DCSP DCSP DCSP if _ netrc : DCNL DCSP DCSP DCSP DCSP login _ i = ( 0 if _ netrc &#91; 0 &#93; else 1 ) DCNL DCSP DCSP DCSP DCSP return ( _ netrc &#91; login _ i &#93; , _ netrc &#91; 2 &#93; ) DCNL DCSP DCSP except ( NetrcParseError , IOError ) : DCNL DCSP DCSP DCSP pass DCNL DCSP except ( ImportError , AttributeError ) : DCNL DCSP DCSP pass
DCSP if ( input is not None ) : DCNL DCSP DCSP input = os.path.dirname ( input ) DCNL DCSP ( f , fn ) = tempfile.mkstemp ( dir = input ) DCNL DCSP os.close ( f ) DCNL DCSP return fn
DCSP lines = value.split ( &apos; \ n &apos; ) DCNL DCSP width = str ( len ( str ( len ( lines ) ) ) ) DCNL DCSP if ( ( not autoescape ) or isinstance ( value , SafeData ) ) : DCNL DCSP DCSP for ( i , line ) in enumerate ( lines ) : DCNL DCSP DCSP DCSP lines &#91; i &#93; = ( ( ( &apos; % 0 &apos; + width ) + &apos; d . DCSP % s &apos; ) % ( ( i + 1 ) , line ) ) DCNL DCSP else : DCNL DCSP DCSP for ( i , line ) in enumerate ( lines ) : DCNL DCSP DCSP DCSP lines &#91; i &#93; = ( ( ( &apos; % 0 &apos; + width ) + &apos; d . DCSP % s &apos; ) % ( ( i + 1 ) , escape ( line ) ) ) DCNL DCSP return mark _ safe ( &apos; \ n &apos; .join ( lines ) )
DCSP return _ distro.name ( pretty )
DCSP old _ class = logging.getLoggerClass ( ) DCNL DCSP logging.setLoggerClass ( logging.Logger ) DCNL DCSP logger = logging.getLogger ( name ) DCNL DCSP logging.setLoggerClass ( old _ class ) DCNL DCSP return logger
DCSP db.execute ( &apos; CREATE DCSP TEMPORARY DCSP TABLE DCSP box _ node _ list DCSP ( id DCSP bigint DCSP PRIMARY DCSP KEY ) DCSP ON DCSP COMMIT DCSP DROP &apos; ) DCNL DCSP db.execute ( &apos; CREATE DCSP TEMPORARY DCSP TABLE DCSP box _ way _ list DCSP ( id DCSP bigint DCSP PRIMARY DCSP KEY ) DCSP ON DCSP COMMIT DCSP DROP &apos; ) DCNL DCSP db.execute ( &apos; CREATE DCSP TEMPORARY DCSP TABLE DCSP box _ relation _ list DCSP ( id DCSP bigint DCSP PRIMARY DCSP KEY ) DCSP ON DCSP COMMIT DCSP DROP &apos; ) DCNL DCSP ( n , s , e , w ) = coordinate _ bbox ( coord , projection ) DCNL DCSP bbox = ( &apos; ST _ SetSRID ( ST _ MakeBox2D ( ST _ MakePoint ( % .7f , DCSP % .7f ) , DCSP ST _ MakePoint ( % .7f , DCSP % .7f ) ) , DCSP 4326 ) &apos; % ( w , s , e , n ) ) DCNL DCSP db.execute ( ( &apos; INSERT DCSP INTO DCSP box _ node _ list \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP nodes \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP ( geom DCSP &amp; &amp; DCSP % ( bbox ) s ) &apos; % locals ( ) ) ) DCNL DCSP db.execute ( &apos; INSERT DCSP INTO DCSP box _ way _ list \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP wn.way _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP way _ nodes DCSP wn \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP box _ node _ list DCSP n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ON DCSP wn.node _ id DCSP = DCSP n.id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP GROUP DCSP BY DCSP wn.way _ id &apos; ) DCNL DCSP db.execute ( &quot; INSERT DCSP INTO DCSP box _ relation _ list \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP rm.relation _ id DCSP AS DCSP relation _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP relation _ members DCSP rm \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP box _ node _ list DCSP n \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ON DCSP rm.member _ id DCSP = DCSP n.id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP rm.member _ type DCSP = DCSP &apos; N &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP UNION \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP rm.relation _ id DCSP AS DCSP relation _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP relation _ members DCSP rm \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP box _ way _ list DCSP w \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ON DCSP rm.member _ id DCSP = DCSP w.id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP rm.member _ type DCSP = DCSP &apos; W &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ) &quot; ) DCNL DCSP db.execute ( &quot; INSERT DCSP INTO DCSP box _ relation _ list \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP rm.relation _ id DCSP AS DCSP relation _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP relation _ members DCSP rm \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP INNER DCSP JOIN DCSP box _ relation _ list DCSP r \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ON DCSP rm.member _ id DCSP = DCSP r.id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP rm.member _ type DCSP = DCSP &apos; R &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP EXCEPT \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP id DCSP AS DCSP relation _ id \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FROM DCSP box _ relation _ list &quot; ) DCNL DCSP db.execute ( &apos; ANALYZE DCSP box _ node _ list &apos; ) DCNL DCSP db.execute ( &apos; ANALYZE DCSP box _ way _ list &apos; ) DCNL DCSP db.execute ( &apos; ANALYZE DCSP box _ relation _ list &apos; )
DCSP dotProductX = ( ( firstTricomplex &#91; 0 &#93; .real * otherColumn.real ) + ( firstTricomplex &#91; 1 &#93; .real * otherColumn.imag ) ) DCNL DCSP dotProductY = ( ( firstTricomplex &#91; 0 &#93; .imag * otherColumn.real ) + ( firstTricomplex &#91; 1 &#93; .imag * otherColumn.imag ) ) DCNL DCSP return complex ( dotProductX , dotProductY )
DCSP return getJoinedPath ( getFabmetheusPath ( &apos; fabmetheus _ utilities &apos; ) , subName )
DCSP r = { k : f.name for ( k , f ) in request.FILES.items ( ) } DCNL DCSP return HttpResponse ( json.dumps ( r ) )
DCSP if conf.disablePrecon : DCNL DCSP DCSP return DCNL DCSP def _ ( ) : DCNL DCSP DCSP while ( kb.get ( &apos; threadContinue &apos; ) and ( not conf.get ( &apos; disablePrecon &apos; ) ) ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP for key in socket . _ ready : DCNL DCSP DCSP DCSP DCSP DCSP if ( len ( socket . _ ready &#91; key &#93; ) &lt; SOCKET _ PRE _ CONNECT _ QUEUE _ SIZE ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( family , type , proto , address ) = key DCNL DCSP DCSP DCSP DCSP DCSP DCSP s = socket.socket ( family , type , proto ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP s . _ connect ( address ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP with kb.locks.socket : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP socket . _ ready &#91; key &#93; .append ( ( s . _ sock , time.time ( ) ) ) DCNL DCSP DCSP DCSP except KeyboardInterrupt : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP finally : DCNL DCSP DCSP DCSP DCSP time.sleep ( 0.01 ) DCNL DCSP def connect ( self , address ) : DCNL DCSP DCSP found = False DCNL DCSP DCSP key = ( self.family , self.type , self.proto , address ) DCNL DCSP DCSP with kb.locks.socket : DCNL DCSP DCSP DCSP if ( key not in socket . _ ready ) : DCNL DCSP DCSP DCSP DCSP socket . _ ready &#91; key &#93; = &#91; &#93; DCNL DCSP DCSP DCSP while ( len ( socket . _ ready &#91; key &#93; ) &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP ( candidate , created ) = socket . _ ready &#91; key &#93; .pop ( 0 ) DCNL DCSP DCSP DCSP DCSP if ( ( time.time ( ) - created ) &lt; PRECONNECT _ CANDIDATE _ TIMEOUT ) : DCNL DCSP DCSP DCSP DCSP DCSP self . _ sock = candidate DCNL DCSP DCSP DCSP DCSP DCSP found = True DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP candidate.close ( ) DCNL DCSP DCSP DCSP DCSP DCSP except socket.error : DCNL DCSP DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP if ( not found ) : DCNL DCSP DCSP DCSP self . _ connect ( address ) DCNL DCSP if ( not hasattr ( socket.socket , &apos; _ connect &apos; ) ) : DCNL DCSP DCSP socket . _ ready = { } DCNL DCSP DCSP socket.socket. _ connect = socket.socket.connect DCNL DCSP DCSP socket.socket.connect = connect DCNL DCSP DCSP thread = threading.Thread ( target = _ ) DCNL DCSP DCSP setDaemon ( thread ) DCNL DCSP DCSP thread.start ( )
DCSP return force _ unicode ( urllib.quote _ plus ( smart _ str ( url ) , safe ) )
DCSP def _ readlines _ side _ effect ( * args , * * kwargs ) : DCNL DCSP DCSP if ( handle.readlines.return _ value is not None ) : DCNL DCSP DCSP DCSP return handle.readlines.return _ value DCNL DCSP DCSP return list ( _ data ) DCNL DCSP def _ read _ side _ effect ( * args , * * kwargs ) : DCNL DCSP DCSP if ( handle.read.return _ value is not None ) : DCNL DCSP DCSP DCSP return handle.read.return _ value DCNL DCSP DCSP return &apos; &apos;.join ( _ data ) DCNL DCSP def _ readline _ side _ effect ( ) : DCNL DCSP DCSP if ( handle.readline.return _ value is not None ) : DCNL DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP ( yield handle.readline.return _ value ) DCNL DCSP DCSP for line in _ data : DCNL DCSP DCSP DCSP ( yield line ) DCNL DCSP global file _ spec DCNL DCSP if ( file _ spec is None ) : DCNL DCSP DCSP import _ io DCNL DCSP DCSP file _ spec = list ( set ( dir ( _ io.TextIOWrapper ) ) .union ( set ( dir ( _ io.BytesIO ) ) ) ) DCNL DCSP if ( mock is None ) : DCNL DCSP DCSP mock = MagicMock ( name = &apos; open &apos; , spec = open ) DCNL DCSP handle = MagicMock ( spec = file _ spec ) DCNL DCSP handle . _ _ enter _ _ .return _ value = handle DCNL DCSP _ data = _ iterate _ read _ data ( read _ data ) DCNL DCSP handle.write.return _ value = None DCNL DCSP handle.read.return _ value = None DCNL DCSP handle.readline.return _ value = None DCNL DCSP handle.readlines.return _ value = None DCNL DCSP handle.read.side _ effect = _ read _ side _ effect DCNL DCSP handle.readline.side _ effect = _ readline _ side _ effect ( ) DCNL DCSP handle.readlines.side _ effect = _ readlines _ side _ effect DCNL DCSP mock.return _ value = handle DCNL DCSP return mock
DCSP f = ( utcnow if assume _ utc else now ) DCNL DCSP default = f ( ) .replace ( hour = 0 , minute = 0 , second = 0 , microsecond = 0 , day = 15 ) DCNL DCSP return fix _ only _ date ( parse _ date ( raw , default = default , assume _ utc = assume _ utc , as _ utc = as _ utc ) )
DCSP nums _ actions = ( tableaux &#91; 1 &#93; .shape &#91; 0 &#93; , tableaux &#91; 0 &#93; .shape &#91; 0 &#93; ) DCNL DCSP num = ( nums _ actions &#91; 0 &#93; + nums _ actions &#91; 1 &#93; ) DCNL DCSP out = np.zeros ( num ) DCNL DCSP for ( pl , ( start , stop ) ) in enumerate ( zip ( ( 0 , nums _ actions &#91; 0 &#93; ) , ( nums _ actions &#91; 0 &#93; , num ) ) ) : DCNL DCSP DCSP sum _ = 0.0 DCNL DCSP DCSP for i in range ( nums _ actions &#91; ( 1 - pl ) &#93; ) : DCNL DCSP DCSP DCSP k = bases &#91; pl &#93; &#91; i &#93; DCNL DCSP DCSP DCSP if ( start &lt; = k &lt; stop ) : DCNL DCSP DCSP DCSP DCSP out &#91; k &#93; = tableaux &#91; pl &#93; &#91; ( i , ( -1 ) ) &#93; DCNL DCSP DCSP DCSP DCSP sum _ + = tableaux &#91; pl &#93; &#91; ( i , ( -1 ) ) &#93; DCNL DCSP DCSP if ( sum _ ! = 0 ) : DCNL DCSP DCSP DCSP out &#91; start : stop &#93; / = sum _ DCNL DCSP return ( out &#91; : nums _ actions &#91; 0 &#93; &#93; , out &#91; nums _ actions &#91; 0 &#93; : &#93; )
DCSP ret = { &apos; changes &apos; : { } } DCNL DCSP cdir = _ config _ dir ( ) DCNL DCSP if ( not os.path.isdir ( cdir ) ) : DCNL DCSP DCSP os.makedirs ( cdir ) DCNL DCSP DCSP if os.path.isdir ( cdir ) : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = &apos; Created DCSP poudriere DCSP make DCSP file DCSP dir DCSP { 0 } &apos; .format ( cdir ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; Could DCSP not DCSP create DCSP or DCSP find DCSP required DCSP directory DCSP { 0 } &apos; .format ( cdir ) DCNL DCSP _ _ salt _ _ &#91; &apos; file.write &apos; &#93; ( &apos; { 0 } -make.conf &apos; .format ( os.path.join ( cdir , jname ) ) , &apos; WITH _ PKGNG = yes &apos; ) DCNL DCSP if os.path.isfile ( ( os.path.join ( cdir , jname ) + &apos; -make.conf &apos; ) ) : DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = &apos; Created DCSP { 0 } &apos; .format ( os.path.join ( cdir , &apos; { 0 } -make.conf &apos; .format ( jname ) ) ) DCNL DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP return &apos; Looks DCSP like DCSP file DCSP { 0 } DCSP could DCSP not DCSP be DCSP created &apos; .format ( os.path.join ( cdir , ( jname + &apos; -make.conf &apos; ) ) )
DCSP zone = session.client _ device.get _ zone ( ) DCNL DCSP devicezones = list ( DeviceZone.all _ objects.filter ( zone = zone , device _ _ in = data &#91; &apos; devices &apos; &#93; ) ) DCNL DCSP devices = &#91; devicezone.device for devicezone in devicezones &#93; DCNL DCSP session.models _ downloaded + = ( len ( devices ) + len ( devicezones ) ) DCNL DCSP return JsonResponse ( { &apos; devices &apos; : serialize ( ( devices + devicezones ) , dest _ version = session.client _ version , ensure _ ascii = False ) } )
DCSP if ( user is None ) : DCNL DCSP DCSP user = users.get _ current _ user ( ) DCNL DCSP if ( user is None ) : DCNL DCSP DCSP return { } DCNL DCSP pickled _ tokens = memcache.get ( ( &apos; gdata _ pickled _ tokens : % s &apos; % user ) ) DCNL DCSP if pickled _ tokens : DCNL DCSP DCSP return pickle.loads ( pickled _ tokens ) DCNL DCSP user _ tokens = TokenCollection.all ( ) .filter ( &apos; user DCSP = &apos; , user ) .get ( ) DCNL DCSP if user _ tokens : DCNL DCSP DCSP memcache.set ( ( &apos; gdata _ pickled _ tokens : % s &apos; % user ) , user _ tokens.pickled _ tokens ) DCNL DCSP DCSP return pickle.loads ( user _ tokens.pickled _ tokens ) DCNL DCSP return { }
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : False , &apos; comment &apos; : &apos; &apos; } DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP params = { &apos; hostname &apos; : hostname , &apos; username &apos; : username , &apos; password &apos; : password , &apos; monitor _ type &apos; : monitor _ type , &apos; name &apos; : name } DCNL DCSP DCSP for ( key , value ) in six.iteritems ( kwargs ) : DCNL DCSP DCSP DCSP params &#91; key &#93; = value DCNL DCSP DCSP return _ test _ output ( ret , &apos; modify &apos; , params ) DCNL DCSP existing = _ _ salt _ _ &#91; &apos; bigip.list _ monitor &apos; &#93; ( hostname , username , password , monitor _ type , name ) DCNL DCSP if ( existing &#91; &apos; code &apos; &#93; = = 200 ) : DCNL DCSP DCSP modified = _ _ salt _ _ &#91; &apos; bigip.modify _ monitor &apos; &#93; ( hostname , username , password , monitor _ type , name , * * kwargs ) DCNL DCSP DCSP if ( modified &#91; &apos; code &apos; &#93; = = 200 ) : DCNL DCSP DCSP DCSP del existing &#91; &apos; content &apos; &#93; &#91; &apos; selfLink &apos; &#93; DCNL DCSP DCSP DCSP del modified &#91; &apos; content &apos; &#93; &#91; &apos; selfLink &apos; &#93; DCNL DCSP DCSP DCSP ret = _ check _ for _ changes ( &apos; Monitor &apos; , ret , existing , modified ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret = _ load _ result ( modified , ret ) DCNL DCSP elif ( existing &#91; &apos; code &apos; &#93; = = 404 ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; A DCSP Monitor DCSP with DCSP this DCSP name DCSP was DCSP not DCSP found . &apos; DCNL DCSP else : DCNL DCSP DCSP ret = _ load _ result ( existing , ret ) DCNL DCSP return ret
DCSP hps.batch _ size = 100 DCNL DCSP with tf.Graph ( ) .as _ default ( ) : DCNL DCSP DCSP with tf.device ( &apos; / cpu : 0 &apos; ) : DCNL DCSP DCSP DCSP with tf.variable _ scope ( &apos; model &apos; ) as var _ scope : DCNL DCSP DCSP DCSP DCSP eval _ model = RealNVP ( hps , sampling = True ) DCNL DCSP DCSP DCSP DCSP summary _ writer = tf.summary.FileWriter ( logdir ) DCNL DCSP DCSP DCSP DCSP var _ scope.reuse _ variables ( ) DCNL DCSP DCSP DCSP DCSP summary _ op = tf.summary.merge _ all ( ) DCNL DCSP DCSP DCSP saver = tf.train.Saver ( ) DCNL DCSP DCSP DCSP sess = tf.Session ( config = tf.ConfigProto ( allow _ soft _ placement = True , log _ device _ placement = True ) ) DCNL DCSP DCSP DCSP coord = tf.train.Coordinator ( ) DCNL DCSP DCSP DCSP threads = tf.train.start _ queue _ runners ( sess = sess , coord = coord ) DCNL DCSP DCSP DCSP previous _ global _ step = 0 DCNL DCSP DCSP DCSP initialized = False DCNL DCSP DCSP DCSP with sess.as _ default ( ) : DCNL DCSP DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP DCSP ckpt _ state = tf.train.get _ checkpoint _ state ( traindir ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not ( ckpt _ state and ckpt _ state.model _ checkpoint _ path ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( not initialized ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP print ( &apos; No DCSP model DCSP to DCSP eval DCSP yet DCSP at DCSP % s &apos; % traindir ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP time.sleep ( 30 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP print ( &apos; Loading DCSP file DCSP % s &apos; % ckpt _ state.model _ checkpoint _ path ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP saver.restore ( sess , ckpt _ state.model _ checkpoint _ path ) DCNL DCSP DCSP DCSP DCSP DCSP current _ step = tf.train.global _ step ( sess , eval _ model.step ) DCNL DCSP DCSP DCSP DCSP DCSP if ( current _ step = = previous _ global _ step ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP print &apos; Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP updated . &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP time.sleep ( 30 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP previous _ global _ step = current _ step DCNL DCSP DCSP DCSP DCSP DCSP fetches = &#91; summary _ op &#93; DCNL DCSP DCSP DCSP DCSP DCSP outputs = sess.run ( fetches ) DCNL DCSP DCSP DCSP DCSP DCSP summary _ writer.add _ summary ( outputs &#91; 0 &#93; , current _ step ) DCNL DCSP DCSP DCSP coord.request _ stop ( ) DCNL DCSP DCSP DCSP coord.join ( threads )
DCSP table = &apos; col1 DCTB col2 \ nN DCTB N \ n1 DCTB Hello &apos; DCNL DCSP with pytest.raises ( ValueError ) : DCNL DCSP DCSP ascii.read ( table , Reader = ascii.Rdb , fast _ reader = fast _ reader )
DCSP arg _ text = &apos; &apos; DCNL DCSP if ( ob is not None ) : DCNL DCSP DCSP arg _ offset = 0 DCNL DCSP DCSP if ( type ( ob ) in ( types.ClassType , types.TypeType ) ) : DCNL DCSP DCSP DCSP fob = _ find _ constructor ( ob ) DCNL DCSP DCSP DCSP if ( fob is None ) : DCNL DCSP DCSP DCSP DCSP fob = ( lambda : None ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP arg _ offset = 1 DCNL DCSP DCSP elif ( type ( ob ) = = types.MethodType ) : DCNL DCSP DCSP DCSP fob = ob.im _ func DCNL DCSP DCSP DCSP arg _ offset = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fob = ob DCNL DCSP DCSP if ( type ( fob ) in &#91; types.FunctionType , types.LambdaType &#93; ) : DCNL DCSP DCSP DCSP argcount = fob.func _ code.co _ argcount DCNL DCSP DCSP DCSP real _ args = fob.func _ code.co _ varnames &#91; arg _ offset : argcount &#93; DCNL DCSP DCSP DCSP defaults = ( fob.func _ defaults or &#91; &#93; ) DCNL DCSP DCSP DCSP defaults = list ( map ( ( lambda name : ( &apos; = % s &apos; % repr ( name ) ) ) , defaults ) ) DCNL DCSP DCSP DCSP defaults = ( ( &#91; &apos; &apos; &#93; * ( len ( real _ args ) - len ( defaults ) ) ) + defaults ) DCNL DCSP DCSP DCSP items = map ( ( lambda arg , dflt : ( arg + dflt ) ) , real _ args , defaults ) DCNL DCSP DCSP DCSP if ( fob.func _ code.co _ flags &amp; 4 ) : DCNL DCSP DCSP DCSP DCSP items.append ( &apos; ... &apos; ) DCNL DCSP DCSP DCSP if ( fob.func _ code.co _ flags &amp; 8 ) : DCNL DCSP DCSP DCSP DCSP items.append ( &apos; * * * &apos; ) DCNL DCSP DCSP DCSP arg _ text = &apos; , DCSP &apos; .join ( items ) DCNL DCSP DCSP DCSP arg _ text = ( &apos; ( % s ) &apos; % re.sub ( &apos; \ \ . \ \ d + &apos; , &apos; &lt; tuple &gt; &apos; , arg _ text ) ) DCNL DCSP DCSP doc = getattr ( ob , &apos; _ _ doc _ _ &apos; , &apos; &apos; ) DCNL DCSP DCSP if doc : DCNL DCSP DCSP DCSP doc = doc.lstrip ( ) DCNL DCSP DCSP DCSP pos = doc.find ( &apos; \ n &apos; ) DCNL DCSP DCSP DCSP if ( ( pos &lt; 0 ) or ( pos &gt; 70 ) ) : DCNL DCSP DCSP DCSP DCSP pos = 70 DCNL DCSP DCSP DCSP if arg _ text : DCNL DCSP DCSP DCSP DCSP arg _ text + = &apos; \ n &apos; DCNL DCSP DCSP DCSP arg _ text + = doc &#91; : pos &#93; DCNL DCSP return arg _ text
DCSP if trigger.is _ privmsg : DCNL DCSP DCSP f _ reload ( bot , trigger )
DCSP try : DCNL DCSP DCSP text = ( fmtString % fmtDict ) DCNL DCSP except KeyboardInterrupt : DCNL DCSP DCSP raise DCNL DCSP except : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP text = ( &apos; Invalid DCSP format DCSP string DCSP or DCSP unformattable DCSP object DCSP in DCSP log DCSP message : DCSP % r , DCSP % s &apos; % ( fmtString , fmtDict ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP text = ( &apos; UNFORMATTABLE DCSP OBJECT DCSP WRITTEN DCSP TO DCSP LOG DCSP with DCSP fmt DCSP % r , DCSP MESSAGE DCSP LOST &apos; % ( fmtString , ) ) DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP text = &apos; PATHOLOGICAL DCSP ERROR DCSP IN DCSP BOTH DCSP FORMAT DCSP STRING DCSP AND DCSP MESSAGE DCSP DETAILS , DCSP MESSAGE DCSP LOST &apos; DCNL DCSP return text
DCSP if ( radius = = 0.0 ) : DCNL DCSP DCSP return &#91; loop &#93; DCNL DCSP isInset = ( radius &gt; 0 ) DCNL DCSP insetLoops = &#91; &#93; DCNL DCSP isLoopWiddershins = euclidean.isWiddershins ( loop ) DCNL DCSP arounds = getAroundsFromLoop ( loop , radius , thresholdRatio ) DCNL DCSP for around in arounds : DCNL DCSP DCSP leftPoint = euclidean.getLeftPoint ( around ) DCNL DCSP DCSP shouldBeWithin = ( isInset = = isLoopWiddershins ) DCNL DCSP DCSP if ( euclidean.isPointInsideLoop ( loop , leftPoint ) = = shouldBeWithin ) : DCNL DCSP DCSP DCSP if ( isLoopWiddershins ! = euclidean.isWiddershins ( around ) ) : DCNL DCSP DCSP DCSP DCSP around.reverse ( ) DCNL DCSP DCSP DCSP insetLoops.append ( around ) DCNL DCSP return insetLoops
DCSP emptyalgo = algo ( ) DCNL DCSP try : DCNL DCSP DCSP emptyalgo.learn ( 0 ) DCNL DCSP DCSP return &apos; Failed DCSP to DCSP throw DCSP missing DCSP evaluator DCSP error ? &apos; DCNL DCSP except AssertionError : DCNL DCSP DCSP pass DCNL DCSP emptyalgo.setEvaluator ( sf , xa1 ) DCNL DCSP emptyalgo.learn ( 0 ) DCNL DCSP algo ( sf , xa1 ) DCNL DCSP algo ( sf , xa100 ) DCNL DCSP algo ( sf , numParameters = 2 ) DCNL DCSP try : DCNL DCSP DCSP algo ( sf ) DCNL DCSP DCSP return &apos; Failed DCSP to DCSP throw DCSP unknown DCSP dimension DCSP error &apos; DCNL DCSP except ValueError : DCNL DCSP DCSP pass DCNL DCSP algo ( ife1 ) DCNL DCSP algo ( ife2 , pc2 ) DCNL DCSP return True
DCSP return { &apos; developer _ message &apos; : message.format ( * * kwargs ) , &apos; user _ message &apos; : _ ( message ) .format ( * * kwargs ) }
DCSP for i in p &#91; 3 &#93; : DCNL DCSP DCSP if ( i &#91; 0 &#93; not in &apos; \ &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP tokenlist.append ( i ) DCNL DCSP if ( p &#91; 1 &#93; = = &apos; % left &apos; ) : DCNL DCSP DCSP preclist.append ( ( ( &apos; left &apos; , ) + tuple ( p &#91; 3 &#93; ) ) ) DCNL DCSP elif ( p &#91; 1 &#93; = = &apos; % right &apos; ) : DCNL DCSP DCSP preclist.append ( ( ( &apos; right &apos; , ) + tuple ( p &#91; 3 &#93; ) ) ) DCNL DCSP elif ( p &#91; 1 &#93; = = &apos; % nonassoc &apos; ) : DCNL DCSP DCSP preclist.append ( ( ( &apos; nonassoc &apos; , ) + tuple ( p &#91; 3 &#93; ) ) )
DCSP try : DCNL DCSP DCSP import win32clipboard DCNL DCSP except ImportError : DCNL DCSP DCSP raise TryNext ( &apos; Getting DCSP text DCSP from DCSP the DCSP clipboard DCSP requires DCSP the DCSP pywin32 DCSP extensions : DCSP http : / / sourceforge.net / projects / pywin32 / &apos; ) DCNL DCSP win32clipboard.OpenClipboard ( ) DCNL DCSP try : DCNL DCSP DCSP text = win32clipboard.GetClipboardData ( win32clipboard.CF _ UNICODETEXT ) DCNL DCSP except ( TypeError , win32clipboard.error ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP text = win32clipboard.GetClipboardData ( win32clipboard.CF _ TEXT ) DCNL DCSP DCSP DCSP text = py3compat.cast _ unicode ( text , py3compat.DEFAULT _ ENCODING ) DCNL DCSP DCSP except ( TypeError , win32clipboard.error ) : DCNL DCSP DCSP DCSP raise ClipboardEmpty DCNL DCSP finally : DCNL DCSP DCSP win32clipboard.CloseClipboard ( ) DCNL DCSP return text
DCSP def func ( ) : DCNL DCSP DCSP pass DCNL DCSP doctest _ item.funcargs = { } DCNL DCSP fm = doctest _ item.session. _ fixturemanager DCNL DCSP doctest _ item . _ fixtureinfo = fm.getfixtureinfo ( node = doctest _ item , func = func , cls = None , funcargs = False ) DCNL DCSP fixture _ request = FixtureRequest ( doctest _ item ) DCNL DCSP fixture _ request . _ fillfixtures ( ) DCNL DCSP return fixture _ request
DCSP seen = set ( ) DCNL DCSP return &#91; x for x in elems if ( ( x not in seen ) and ( not seen.add ( x ) ) ) &#93;
DCSP ( cohort _ settings , created ) = CourseCohortsSettings.objects.get _ or _ create ( course _ id = course.id , defaults = { &apos; is _ cohorted &apos; : course.is _ cohorted , &apos; cohorted _ discussions &apos; : list ( course.cohorted _ discussions ) , &apos; always _ cohort _ inline _ discussions &apos; : course.always _ cohort _ inline _ discussions } ) DCNL DCSP if created : DCNL DCSP DCSP manual _ cohorts = CourseUserGroup.objects.filter ( course _ id = course.id , group _ type = CourseUserGroup.COHORT ) .exclude ( name _ _ in = course.auto _ cohort _ groups ) DCNL DCSP DCSP for cohort in manual _ cohorts : DCNL DCSP DCSP DCSP CourseCohort.create ( course _ user _ group = cohort ) DCNL DCSP DCSP for group _ name in course.auto _ cohort _ groups : DCNL DCSP DCSP DCSP CourseCohort.create ( cohort _ name = group _ name , course _ id = course.id , assignment _ type = CourseCohort.RANDOM ) DCNL DCSP return cohort _ settings
DCSP bits = token.split _ contents ( ) DCNL DCSP if ( len ( bits ) &lt; 3 ) : DCNL DCSP DCSP raise TemplateSyntaxError ( ( u &quot; &apos; % s &apos; DCSP takes DCSP at DCSP least DCSP two DCSP arguments DCSP ( path DCSP to DCSP a DCSP view DCSP and DCSP a DCSP urlconf ) &quot; % bits &#91; 0 &#93; ) ) DCNL DCSP viewname = parser.compile _ filter ( bits &#91; 1 &#93; ) DCNL DCSP urlconf = parser.compile _ filter ( bits &#91; 2 &#93; ) DCNL DCSP args = &#91; &#93; DCNL DCSP kwargs = { } DCNL DCSP asvar = None DCNL DCSP bits = bits &#91; 3 : &#93; DCNL DCSP if ( ( len ( bits ) &gt; = 2 ) and ( bits &#91; ( -2 ) &#93; = = u &apos;as &apos; ) ) : DCNL DCSP DCSP asvar = bits &#91; ( -1 ) &#93; DCNL DCSP DCSP bits = bits &#91; : ( -2 ) &#93; DCNL DCSP if len ( bits ) : DCNL DCSP DCSP for bit in bits : DCNL DCSP DCSP DCSP match = kwarg _ re.match ( bit ) DCNL DCSP DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP DCSP raise TemplateSyntaxError ( u &apos;Malformed DCSP arguments DCSP to DCSP app _ reverse DCSP tag &apos; ) DCNL DCSP DCSP DCSP ( name , value ) = match.groups ( ) DCNL DCSP DCSP DCSP if name : DCNL DCSP DCSP DCSP DCSP kwargs &#91; name &#93; = parser.compile _ filter ( value ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP args.append ( parser.compile _ filter ( value ) ) DCNL DCSP return AppReverseNode ( viewname , urlconf , args , kwargs , asvar )
DCSP if ( ( len ( header ) &gt; 160 ) and ( u &apos; , &apos; in header ) ) : DCNL DCSP DCSP header = mark _ safe ( ( u &apos; &lt; br &gt; DCSP &apos; + u &apos; , DCSP &lt; br &gt; &apos; .join ( header.split ( u &apos; , &apos; ) ) ) ) DCNL DCSP return header
DCSP if ( not exists ( name , path = path ) ) : DCNL DCSP DCSP raise CommandExecutionError ( &quot; Container DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP exist &quot; .format ( name ) )
DCSP s = list ( pattern ) DCNL DCSP i = 0 DCNL DCSP while ( i &lt; ( len ( s ) - 1 ) ) : DCNL DCSP DCSP c = s &#91; i &#93; DCNL DCSP DCSP if ( ( c = = &apos; $ &apos; ) and ( s &#91; ( i + 1 ) &#93; in &apos; 0123456789 &apos; ) ) : DCNL DCSP DCSP DCSP s &#91; i &#93; = &apos; \ \ &apos; DCNL DCSP DCSP elif ( ( c = = &apos; \ \ &apos; ) and ( s &#91; ( i + 1 ) &#93; = = &apos; $ &apos; ) ) : DCNL DCSP DCSP DCSP s &#91; i &#93; = &apos; &apos; DCNL DCSP DCSP DCSP i + = 1 DCNL DCSP DCSP i + = 1 DCNL DCSP return pattern &#91; : 0 &#93; .join ( s )
DCSP recode = { &apos; A &apos; : &apos; 1&apos; , &apos; C &apos; : &apos; 2&apos; , &apos; G &apos; : &apos; 3&apos; , &apos; T &apos; : &apos; 4&apos; , &apos; N &apos; : &apos; 0&apos; , &apos; 0&apos; : &apos; 0&apos; , &apos; 1&apos; : &apos; 1&apos; , &apos; 2&apos; : &apos; 2&apos; , &apos; 3&apos; : &apos; 3&apos; , &apos; 4&apos; : &apos; 4&apos; } DCNL DCSP basename = os.path.split ( inpedfilepath ) &#91; ( -1 ) &#93; DCNL DCSP inmap = ( &apos; % s.map &apos; % inpedfilepath ) DCNL DCSP inped = ( &apos; % s.ped &apos; % inpedfilepath ) DCNL DCSP outf = ( &apos; % s.ped &apos; % basename ) DCNL DCSP outfpath = os.path.join ( outfilepath , outf ) DCNL DCSP try : DCNL DCSP DCSP mf = open ( inmap , &apos; r &apos; ) DCNL DCSP except : DCNL DCSP DCSP sys.stderr.write ( ( &apos; % s DCSP cannot DCSP open DCSP inmap DCSP file DCSP % s DCSP - DCSP do DCSP you DCSP have DCSP permission ? \ n &apos; % ( prog , inmap ) ) ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP try : DCNL DCSP DCSP rsl = &#91; x.split ( ) &#91; 1 &#93; for x in mf &#93; DCNL DCSP except : DCNL DCSP DCSP sys.stderr.write ( ( &apos; # # DCSP cannot DCSP parse DCSP % s &apos; % inmap ) ) DCNL DCSP DCSP sys.exit ( 1 ) DCNL DCSP try : DCNL DCSP DCSP os.makedirs ( outfilepath ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP head = &apos; DCSP &apos; .join ( rsl ) DCNL DCSP pedf = open ( inped , &apos; r &apos; ) DCNL DCSP o = open ( outfpath , &apos; w &apos; , ( 2 * * 20 ) ) DCNL DCSP o.write ( head ) DCNL DCSP o.write ( &apos; \ n &apos; ) DCNL DCSP for ( i , row ) in enumerate ( pedf ) : DCNL DCSP DCSP if ( i = = 0 ) : DCNL DCSP DCSP DCSP lrow = row.split ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP &#91; int ( x ) for x in lrow &#91; 10 : 50 &#93; &#93; DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP dorecode = 1 DCNL DCSP DCSP if dorecode : DCNL DCSP DCSP DCSP lrow = row.strip ( ) .split ( ) DCNL DCSP DCSP DCSP p = lrow &#91; : 6 &#93; DCNL DCSP DCSP DCSP g = lrow &#91; 6 : &#93; DCNL DCSP DCSP DCSP gc = &#91; recode.get ( z , &apos; 0&apos; ) for z in g &#93; DCNL DCSP DCSP DCSP lrow = ( p + gc ) DCNL DCSP DCSP DCSP row = ( &apos; % s \ n &apos; % &apos; DCSP &apos; .join ( lrow ) ) DCNL DCSP DCSP o.write ( row ) DCNL DCSP o.close ( )
DCSP result = &apos; &apos; DCNL DCSP if ( header ! = &apos; &apos; ) : DCNL DCSP DCSP result + = ( header + &apos; \ n &apos; ) DCNL DCSP result + = ( &apos; Correlation DCSP coefficient DCTB Parametric DCSP p-value DCTB &apos; + &apos; Nonparametric DCSP p-value DCTB CI DCSP ( lower ) DCTB CI DCSP ( upper ) \ n &apos; ) DCNL DCSP if ( num _ permutations &gt; 0 ) : DCNL DCSP DCSP nonparam _ p _ val _ str = format _ p _ value _ for _ num _ iters ( nonparam _ p _ val , num _ permutations ) DCNL DCSP else : DCNL DCSP DCSP nonparam _ p _ val _ str = &apos; N / A &apos; DCNL DCSP if ( conf _ interval = = ( None , None ) ) : DCNL DCSP DCSP conf _ interval _ str = &apos; N / A DCTB N / A &apos; DCNL DCSP else : DCNL DCSP DCSP conf _ interval _ str = ( &apos; % .4f DCTB % .4f &apos; % conf _ interval ) DCNL DCSP result + = ( &apos; % .4f DCTB % .4f DCTB % s DCTB % s \ n &apos; % ( corr _ coeff , param _ p _ val , nonparam _ p _ val _ str , conf _ interval _ str ) ) DCNL DCSP return result
DCSP seg = make _ segment ( 1 , explicit = False ) DCNL DCSP pg _ xlog.touch ( seg.name , &apos; .ready &apos; ) DCNL DCSP seg.mark _ done ( )
DCSP dicts = list ( dicts ) DCNL DCSP if ( dicts and isinstance ( dicts &#91; 0 &#93; , OrderedDict ) ) : DCNL DCSP DCSP result = OrderedDict ( ) DCNL DCSP else : DCNL DCSP DCSP result = { } DCNL DCSP for d in ( list ( dicts ) + &#91; kwargs &#93; ) : DCNL DCSP DCSP duplicate _ keys = ( set ( result.keys ( ) ) &amp; set ( d.keys ( ) ) ) DCNL DCSP DCSP if duplicate _ keys : DCNL DCSP DCSP DCSP raise ValueError ( &apos; The DCSP following DCSP keys DCSP have DCSP duplicate DCSP entries : DCSP { } &apos; .format ( &apos; , DCSP &apos; .join ( ( str ( key ) for key in duplicate _ keys ) ) ) ) DCNL DCSP DCSP result.update ( d ) DCNL DCSP return result
DCSP return ( not enabled ( name , * * kwargs ) )
DCSP def path _ searcher ( target , extra _ dirs = extra _ paths ) : DCNL DCSP DCSP matches = itertools.ifilter ( target _ predicate , path _ generator ( target , extra _ dirs , * * kwargs ) ) DCNL DCSP DCSP paths = itertools.imap ( target _ normalizer , matches ) DCNL DCSP DCSP return next ( paths , &apos; &apos; ) DCNL DCSP return path _ searcher
DCSP cmd = &apos; monit DCSP validate &apos; DCNL DCSP return ( not _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( cmd , python _ shell = False ) )
DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP now = current.request.utcnow DCNL DCSP from dateutil.relativedelta import relativedelta DCNL DCSP TODAY = now.date ( ) DCNL DCSP ONE _ YEAR _ AGO = ( now - relativedelta ( years = 1 ) ) .date ( ) DCNL DCSP ptable = s3db.pr _ person DCNL DCSP ctable = s3db.dvr _ case DCNL DCSP stable = s3db.dvr _ case _ status DCNL DCSP ftable = s3db.dvr _ case _ flag DCNL DCSP cftable = s3db.dvr _ case _ flag _ case DCNL DCSP utable = s3db.cr _ shelter _ unit DCNL DCSP rtable = s3db.cr _ shelter _ registration DCNL DCSP ttable = s3db.dvr _ case _ appointment _ type DCNL DCSP atable = s3db.dvr _ case _ appointment DCNL DCSP COMPLETED = 4 DCNL DCSP NOT _ REQUIRED = 7 DCNL DCSP query = ( ctable.deleted ! = True ) DCNL DCSP db ( query ) .update ( transferable = False , household _ transferable = False ) DCNL DCSP query = ( ( ( ttable.name = = &apos; Reported DCSP Transferable &apos; ) &#124; ( ttable.name = = &apos; Transfer &apos; ) ) &amp; ( ttable.deleted ! = True ) ) DCNL DCSP rows = db ( query ) .select ( ttable.id , limitby = ( 0 , 2 ) ) DCNL DCSP if rows : DCNL DCSP DCSP transferability _ complete = set ( ( row.id for row in rows ) ) DCNL DCSP else : DCNL DCSP DCSP transferability _ complete = None DCNL DCSP query = ( ( ( stable.is _ closed = = False ) &#124; ( stable.is _ closed = = None ) ) &amp; ( stable.deleted ! = True ) ) DCNL DCSP rows = db ( query ) .select ( stable.id ) DCNL DCSP if rows : DCNL DCSP DCSP OPEN = set ( ( row.id for row in rows ) ) DCNL DCSP else : DCNL DCSP DCSP OPEN = None DCNL DCSP query = ( ( ftable.is _ not _ transferable = = True ) &amp; ( ftable.deleted ! = True ) ) DCNL DCSP rows = db ( query ) .select ( ftable.id ) DCNL DCSP if rows : DCNL DCSP DCSP NOT _ TRANSFERABLE = set ( ( row.id for row in rows ) ) DCNL DCSP else : DCNL DCSP DCSP NOT _ TRANSFERABLE = None DCNL DCSP age _ groups = { &apos; children &apos; : ( None , 15 , &apos; mandatory _ children &apos; , None ) , &apos; adolescents &apos; : ( 15 , 18 , &apos; mandatory _ adolescents &apos; , None ) , &apos; adults &apos; : ( 18 , None , &apos; mandatory _ adults &apos; , 4 ) } DCNL DCSP left = &#91; stable.on ( ( stable.id = = ctable.status _ id ) ) , ptable.on ( ( ptable.id = = ctable.person _ id ) ) , rtable.on ( ( ( rtable.person _ id = = ptable.id ) &amp; ( rtable.deleted ! = True ) ) ) , utable.on ( ( utable.id = = rtable.shelter _ unit _ id ) ) &#93; DCNL DCSP if transferability _ complete : DCNL DCSP DCSP tctable = atable.with _ alias ( &apos; transferability _ complete &apos; ) DCNL DCSP DCSP tcjoin = tctable.on ( ( ( ( ( ( ( ( tctable.person _ id = = ctable.person _ id ) &amp; tctable.type _ id.belongs ( transferability _ complete ) ) &amp; ( tctable.deleted ! = True ) ) &amp; ( tctable.date ! = None ) ) &amp; ( tctable.date &gt; = ONE _ YEAR _ AGO ) ) &amp; ( tctable.date &lt; = TODAY ) ) &amp; ( tctable.status = = COMPLETED ) ) ) DCNL DCSP DCSP left.append ( tcjoin ) DCNL DCSP if NOT _ TRANSFERABLE : DCNL DCSP DCSP cfjoin = cftable.on ( ( ( ( cftable.person _ id = = ctable.person _ id ) &amp; cftable.flag _ id.belongs ( NOT _ TRANSFERABLE ) ) &amp; ( cftable.deleted ! = True ) ) ) DCNL DCSP DCSP left.append ( cfjoin ) DCNL DCSP result = 0 DCNL DCSP for age _ group in age _ groups : DCNL DCSP DCSP ( min _ age , max _ age , appointment _ flag , maximum _ absence ) = age _ groups &#91; age _ group &#93; DCNL DCSP DCSP dob _ query = ( ptable.date _ of _ birth ! = None ) DCNL DCSP DCSP if max _ age : DCNL DCSP DCSP DCSP dob _ min = ( now - relativedelta ( years = max _ age ) ) DCNL DCSP DCSP DCSP dob _ query &amp; = ( ptable.date _ of _ birth &gt; dob _ min ) DCNL DCSP DCSP if min _ age : DCNL DCSP DCSP DCSP dob _ max = ( now - relativedelta ( years = min _ age ) ) DCNL DCSP DCSP DCSP dob _ query &amp; = ( ptable.date _ of _ birth &lt; = dob _ max ) DCNL DCSP DCSP case _ query = ( ( ctable.deleted ! = True ) &amp; ( ( ctable.archived = = False ) &#124; ( ctable.archived = = None ) ) ) DCNL DCSP DCSP if OPEN : DCNL DCSP DCSP DCSP case _ query &amp; = ctable.status _ id.belongs ( OPEN ) DCNL DCSP DCSP if site _ id : DCNL DCSP DCSP DCSP case _ query &amp; = ( ctable.site _ id = = site _ id ) DCNL DCSP DCSP case _ query &amp; = ( ( stable.is _ not _ transferable = = False ) &#124; ( stable.is _ not _ transferable = = None ) ) DCNL DCSP DCSP if NOT _ TRANSFERABLE : DCNL DCSP DCSP DCSP case _ query &amp; = ( cftable.id = = None ) DCNL DCSP DCSP case _ query &amp; = ( ( utable.id ! = None ) &amp; ( ( utable.transitory = = False ) &#124; ( utable.transitory = = None ) ) ) DCNL DCSP DCSP case _ query &amp; = dob _ query DCNL DCSP DCSP if transferability _ complete : DCNL DCSP DCSP DCSP case _ query &amp; = ( tctable.id = = None ) DCNL DCSP DCSP if ( maximum _ absence is not None ) : DCNL DCSP DCSP DCSP if maximum _ absence : DCNL DCSP DCSP DCSP DCSP earliest _ check _ out _ date = ( now - relativedelta ( days = maximum _ absence ) ) DCNL DCSP DCSP DCSP DCSP presence _ query = ( ( rtable.registration _ status = = 2 ) &#124; ( ( rtable.registration _ status = = 3 ) &amp; ( rtable.check _ out _ date &gt; earliest _ check _ out _ date ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP presence _ query = rtable.registration _ status.belongs ( 2 , 3 ) DCNL DCSP DCSP DCSP case _ query &amp; = presence _ query DCNL DCSP DCSP cases = db ( case _ query ) .select ( ctable.id , left = left ) DCNL DCSP DCSP case _ ids = set ( ( case.id for case in cases ) ) DCNL DCSP DCSP if case _ ids : DCNL DCSP DCSP DCSP query = ctable.id.belongs ( case _ ids ) DCNL DCSP DCSP DCSP aleft = &#91; &#93; DCNL DCSP DCSP DCSP if appointment _ flag : DCNL DCSP DCSP DCSP DCSP tquery = ( ( ttable &#91; appointment _ flag &#93; = = True ) &amp; ( ttable.deleted ! = True ) ) DCNL DCSP DCSP DCSP DCSP rows = db ( tquery ) .select ( ttable.id ) DCNL DCSP DCSP DCSP DCSP mandatory _ appointments = &#91; row.id for row in rows &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP mandatory _ appointments = None DCNL DCSP DCSP DCSP if mandatory _ appointments : DCNL DCSP DCSP DCSP DCSP for appointment _ type _ id in mandatory _ appointments : DCNL DCSP DCSP DCSP DCSP DCSP alias = ( &apos; appointments _ % s &apos; % appointment _ type _ id ) DCNL DCSP DCSP DCSP DCSP DCSP atable _ = atable.with _ alias ( alias ) DCNL DCSP DCSP DCSP DCSP DCSP join = atable _ .on ( ( ( ( ( atable _ .person _ id = = ctable.person _ id ) &amp; ( atable _ .type _ id = = appointment _ type _ id ) ) &amp; ( atable _ .deleted ! = True ) ) &amp; ( ( ( ( ( atable _ .status = = COMPLETED ) &amp; ( atable _ .date ! = None ) ) &amp; ( atable _ .date &gt; = ONE _ YEAR _ AGO ) ) &amp; ( atable _ .date &lt; = TODAY ) ) &#124; ( atable _ .status = = NOT _ REQUIRED ) ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP aleft.append ( join ) DCNL DCSP DCSP DCSP DCSP DCSP query &amp; = ( atable _ .id ! = None ) DCNL DCSP DCSP DCSP DCSP cases = db ( query ) .select ( ctable.id , left = aleft ) DCNL DCSP DCSP DCSP DCSP case _ ids = set ( ( case.id for case in cases ) ) DCNL DCSP DCSP DCSP success = db ( ctable.id.belongs ( case _ ids ) ) .update ( transferable = True ) DCNL DCSP DCSP DCSP if success : DCNL DCSP DCSP DCSP DCSP result + = success DCNL DCSP gtable = s3db.pr _ group DCNL DCSP mtable = s3db.pr _ group _ membership DCNL DCSP query = ( ( ( gtable.group _ type = = 7 ) &amp; ( gtable.deleted ! = True ) ) &amp; ( ctable.id ! = None ) ) DCNL DCSP left = &#91; mtable.on ( ( ( mtable.group _ id = = gtable.id ) &amp; ( mtable.deleted ! = True ) ) ) , ctable.on ( ( ( ctable.person _ id = = mtable.person _ id ) &amp; ( ctable.transferable = = True ) ) ) &#93; DCNL DCSP members = ctable.id.count ( ) DCNL DCSP rows = db ( query ) .select ( gtable.id , groupby = gtable.id , having = ( members = = 0 ) , left = left ) DCNL DCSP group _ ids = set ( ( row.id for row in rows ) ) DCNL DCSP open _ case = ( ( ctable.archived ! = True ) &amp; ( ctable.deleted ! = True ) ) DCNL DCSP if OPEN : DCNL DCSP DCSP open _ case = ( ctable.status _ id.belongs ( OPEN ) &amp; open _ case ) DCNL DCSP if group _ ids : DCNL DCSP DCSP query &amp; = ( ~ gtable.id.belongs ( group _ ids ) ) DCNL DCSP left = &#91; mtable.on ( ( ( mtable.group _ id = = gtable.id ) &amp; ( mtable.deleted ! = True ) ) ) , ctable.on ( ( ( ( ctable.person _ id = = mtable.person _ id ) &amp; open _ case ) &amp; ( ( ctable.transferable = = False ) &#124; ( ctable.transferable = = None ) ) ) ) &#93; DCNL DCSP if transferability _ complete : DCNL DCSP DCSP left.append ( tcjoin ) DCNL DCSP DCSP query &amp; = ( tctable.id = = None ) DCNL DCSP rows = db ( query ) .select ( gtable.id , groupby = gtable.id , left = left ) DCNL DCSP group _ ids &#124; = set ( ( row.id for row in rows ) ) DCNL DCSP ftable = mtable.with _ alias ( &apos; family &apos; ) DCNL DCSP left = &#91; mtable.on ( ( ( ( mtable.person _ id = = ctable.person _ id ) &amp; mtable.group _ id.belongs ( group _ ids ) ) &amp; ( mtable.deleted ! = True ) ) ) , gtable.on ( ( ( ( ( ftable.person _ id = = ctable.person _ id ) &amp; ( ftable.deleted ! = True ) ) &amp; ( gtable.id = = ftable.group _ id ) ) &amp; ( gtable.group _ type = = 7 ) ) ) &#93; DCNL DCSP query = ( ( mtable.id = = None ) &amp; ( ctable.deleted ! = True ) ) DCNL DCSP families = gtable.id.count ( ) DCNL DCSP required = ( ( families &gt; 0 ) &#124; ( ctable.transferable = = True ) ) DCNL DCSP rows = db ( query ) .select ( ctable.id , groupby = ctable.id , having = required , left = left ) DCNL DCSP case _ ids = set ( ( row.id for row in rows ) ) DCNL DCSP if case _ ids : DCNL DCSP DCSP db ( ctable.id.belongs ( case _ ids ) ) .update ( household _ transferable = True ) DCNL DCSP return result
DCSP if ( ( r.representation = = &apos; html &apos; ) and ( r.name = = &apos; project &apos; ) ) : DCNL DCSP DCSP T = current.T DCNL DCSP DCSP db = current.db DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP project _ id = r.id DCNL DCSP DCSP item = TABLE ( _ class = &apos; project _ indicator _ progress _ report &apos; ) DCNL DCSP DCSP output = dict ( item = item ) DCNL DCSP DCSP output &#91; &apos; title &apos; &#93; = T ( &apos; Monthly DCSP Progress DCSP by DCSP Indicator &apos; ) DCNL DCSP DCSP output &#91; &apos; subtitle &apos; &#93; = ( &apos; % s : DCSP % s &apos; % ( T ( &apos; Project &apos; ) , r.record.name ) ) DCNL DCSP DCSP if ( &apos; rheader &apos; in attr ) : DCNL DCSP DCSP DCSP rheader = attr &#91; &apos; rheader &apos; &#93; ( r ) DCNL DCSP DCSP DCSP if rheader : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; rheader &apos; &#93; = rheader DCNL DCSP DCSP current.response.view = &apos; simple.html &apos; DCNL DCSP DCSP return output DCNL DCSP else : DCNL DCSP DCSP raise HTTP ( 405 , current.ERROR.BAD _ METHOD )
DCSP parts = module.split ( &apos; .&apos; ) DCNL DCSP while parts : DCNL DCSP DCSP part = parts.pop ( 0 ) DCNL DCSP DCSP ( f , path , ( suffix , mode , kind ) ) = info = imp.find _ module ( part , paths ) DCNL DCSP DCSP if ( kind = = PKG _ DIRECTORY ) : DCNL DCSP DCSP DCSP parts = ( parts or &#91; &apos; _ _ init _ _ &apos; &#93; ) DCNL DCSP DCSP DCSP paths = &#91; path &#93; DCNL DCSP DCSP elif parts : DCNL DCSP DCSP DCSP raise ImportError ( ( &quot; Can &apos;t DCSP find DCSP % r DCSP in DCSP % s &quot; % ( parts , module ) ) ) DCNL DCSP return info
DCSP ( layout , page ) = ( &#91; &#93; , &#91; &#93; ) DCNL DCSP layout.append ( page ) DCNL DCSP if format _ data : DCNL DCSP DCSP if ( format _ data &#91; 0 &#93; .get ( u &apos;fieldname &apos; ) = = u &apos;print _ heading _ template &apos; ) : DCNL DCSP DCSP DCSP doc.print _ heading _ template = format _ data &#91; 0 &#93; .get ( u &apos;options &apos; ) DCNL DCSP DCSP DCSP format _ data = format _ data &#91; 1 : &#93; DCNL DCSP def get _ new _ section ( ) : DCNL DCSP DCSP return { u &apos;columns &apos; : &#91; &#93; , u &apos;has _ data &apos; : False } DCNL DCSP def append _ empty _ field _ dict _ to _ page _ column ( page ) : DCNL DCSP DCSP u &apos; DCSP append DCSP empty DCSP columns DCSP dict DCSP to DCSP page DCSP layout DCSP &apos; DCNL DCSP DCSP if ( not page &#91; ( -1 ) &#93; &#91; u &apos;columns &apos; &#93; ) : DCNL DCSP DCSP DCSP page &#91; ( -1 ) &#93; &#91; u &apos;columns &apos; &#93; .append ( { u &apos;fields &apos; : &#91; &#93; } ) DCNL DCSP for df in ( format _ data or meta.fields ) : DCNL DCSP DCSP if format _ data : DCNL DCSP DCSP DCSP df = frappe . _ dict ( df ) DCNL DCSP DCSP DCSP if df.fieldname : DCNL DCSP DCSP DCSP DCSP original = meta.get _ field ( df.fieldname ) DCNL DCSP DCSP DCSP DCSP if original : DCNL DCSP DCSP DCSP DCSP DCSP newdf = original.as _ dict ( ) DCNL DCSP DCSP DCSP DCSP DCSP newdf.update ( df ) DCNL DCSP DCSP DCSP DCSP DCSP df = newdf DCNL DCSP DCSP DCSP df.print _ hide = 0 DCNL DCSP DCSP if ( ( df.fieldtype = = u &apos;Section DCSP Break &apos; ) or ( page = = &#91; &#93; ) ) : DCNL DCSP DCSP DCSP if ( len ( page ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP if ( page &#91; ( -1 ) &#93; &#91; u &apos;has _ data &apos; &#93; = = False ) : DCNL DCSP DCSP DCSP DCSP DCSP del page &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP section = get _ new _ section ( ) DCNL DCSP DCSP DCSP if ( ( df.fieldtype = = u &apos;Section DCSP Break &apos; ) and df.label ) : DCNL DCSP DCSP DCSP DCSP section &#91; u &apos;label &apos; &#93; = df.label DCNL DCSP DCSP DCSP page.append ( section ) DCNL DCSP DCSP elif ( df.fieldtype = = u &apos;Column DCSP Break &apos; ) : DCNL DCSP DCSP DCSP page &#91; ( -1 ) &#93; &#91; u &apos;columns &apos; &#93; .append ( { u &apos;fields &apos; : &#91; &#93; } ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP append _ empty _ field _ dict _ to _ page _ column ( page ) DCNL DCSP DCSP if ( ( df.fieldtype = = u &apos;HTML &apos; ) and df.options ) : DCNL DCSP DCSP DCSP doc.set ( df.fieldname , True ) DCNL DCSP DCSP if ( is _ visible ( df , doc ) and has _ value ( df , doc ) ) : DCNL DCSP DCSP DCSP append _ empty _ field _ dict _ to _ page _ column ( page ) DCNL DCSP DCSP DCSP page &#91; ( -1 ) &#93; &#91; u &apos;columns &apos; &#93; &#91; ( -1 ) &#93; &#91; u &apos;fields &apos; &#93; .append ( df ) DCNL DCSP DCSP DCSP page &#91; ( -1 ) &#93; &#91; u &apos;has _ data &apos; &#93; = True DCNL DCSP DCSP DCSP if ( df.fieldtype = = u &apos;Table &apos; ) : DCNL DCSP DCSP DCSP DCSP df.rows = &#91; &#93; DCNL DCSP DCSP DCSP DCSP df.start = 0 DCNL DCSP DCSP DCSP DCSP df.end = None DCNL DCSP DCSP DCSP DCSP for ( i , row ) in enumerate ( doc.get ( df.fieldname ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if row.get ( u &apos;page _ break &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP df.end = i DCNL DCSP DCSP DCSP DCSP DCSP DCSP page = &#91; get _ new _ section ( ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP layout.append ( page ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP append _ empty _ field _ dict _ to _ page _ column ( page ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP df = copy.copy ( df ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP df.start = i DCNL DCSP DCSP DCSP DCSP DCSP DCSP df.end = None DCNL DCSP DCSP DCSP DCSP DCSP DCSP page &#91; ( -1 ) &#93; &#91; u &apos;columns &apos; &#93; &#91; ( -1 ) &#93; &#91; u &apos;fields &apos; &#93; .append ( df ) DCNL DCSP return layout
DCSP if ( deadline is None ) : DCNL DCSP DCSP deadline = get _ default _ fetch _ deadline ( ) DCNL DCSP return apiproxy _ stub _ map.UserRPC ( &apos; urlfetch &apos; , deadline , callback )
DCSP access _ key _ id _ script = AWS _ ACCOUNTS &#91; &apos; default &apos; &#93; .ACCESS _ KEY _ ID _ SCRIPT.get ( ) DCNL DCSP return ( access _ key _ id _ script or get _ s3a _ access _ key ( ) )
DCSP rel = descriptor.related DCNL DCSP related _ name = ( &apos; % s _ cache &apos; % rel.field.related _ query _ name ( ) ) DCNL DCSP @ property DCNL DCSP def get ( self ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Returns DCSP the DCSP cached DCSP value DCSP of DCSP the DCSP related DCSP model DCSP if DCSP found \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP in DCSP the DCSP cache . DCSP Otherwise DCSP gets DCSP and DCSP caches DCSP the DCSP related DCSP model . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return getattr ( self , descriptor.cache _ name ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return getattr ( self , ( &apos; _ % s _ cache &apos; % related _ name ) ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP instance = get _ instance ( rel.model , self.pk , timeout ) DCNL DCSP DCSP setattr ( self , ( &apos; _ % s _ cache &apos; % related _ name ) , instance ) DCNL DCSP DCSP return instance DCNL DCSP setattr ( rel.parent _ model , related _ name , get ) DCNL DCSP def clear ( self ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of DCSP self . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP delete _ instance ( rel.model , self ) DCNL DCSP @ classmethod DCNL DCSP def clear _ pk ( cls , * instances _ or _ pk ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP the DCSP provided DCSP instances _ or _ pk . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP delete _ instance ( rel.model , * instances _ or _ pk ) DCNL DCSP def clear _ cache ( sender , instance , * args , * * kwargs ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP related DCSP models DCSP of DCSP the \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP given DCSP instance . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP delete _ instance ( rel.model , instance ) DCNL DCSP setattr ( rel.parent _ model , ( &apos; % s _ clear &apos; % related _ name ) , clear ) DCNL DCSP setattr ( rel.parent _ model , ( &apos; % s _ clear _ pk &apos; % related _ name ) , clear _ pk ) DCNL DCSP post _ save.connect ( clear _ cache , sender = rel.model , weak = False ) DCNL DCSP post _ delete.connect ( clear _ cache , sender = rel.model , weak = False )
DCSP if isinstance ( seq , ( list , tuple ) ) : DCNL DCSP DCSP return tuple ( ( tuplize ( i ) for i in seq ) ) DCNL DCSP return seq
DCSP sniff ( prn = ( lambda x : x.display ( ) ) , * args , * * kargs )
DCSP rng = make _ np _ rng ( rng , default _ sparse _ seed , which _ method = &#91; &apos; randn &apos; , &apos; randint &apos; &#93; ) DCNL DCSP W = np.zeros ( ( input _ space.num _ channels , kernel _ shape &#91; 0 &#93; , kernel _ shape &#91; 1 &#93; , output _ space.num _ channels ) ) DCNL DCSP def random _ coord ( ) : DCNL DCSP DCSP return &#91; rng.randint ( dim ) for dim in W.shape &#91; 0 : 3 &#93; &#93; DCNL DCSP for o in xrange ( output _ space.num _ channels ) : DCNL DCSP DCSP for i in xrange ( num _ nonzero ) : DCNL DCSP DCSP DCSP ( ch , r , c ) = random _ coord ( ) DCNL DCSP DCSP DCSP while ( W &#91; ( ch , r , c , o ) &#93; ! = 0 ) : DCNL DCSP DCSP DCSP DCSP ( ch , r , c ) = random _ coord ( ) DCNL DCSP DCSP DCSP W &#91; ( ch , r , c , o ) &#93; = rng.randn ( ) DCNL DCSP W = sharedX ( W ) DCNL DCSP return Conv2D ( filters = W , input _ axes = input _ space.axes , output _ axes = output _ space.axes , kernel _ stride = kernel _ stride , pad = pad , message = message , partial _ sum = partial _ sum )
DCSP ret = Forward ( ) DCNL DCSP lastExpr = ( baseExpr &#124; ( ( lpar + ret ) + rpar ) ) DCNL DCSP for ( i , operDef ) in enumerate ( opList ) : DCNL DCSP DCSP ( opExpr , arity , rightLeftAssoc , pa ) = ( operDef + ( None , ) ) &#91; : 4 &#93; DCNL DCSP DCSP if ( arity = = 3 ) : DCNL DCSP DCSP DCSP if ( ( opExpr is None ) or ( len ( opExpr ) ! = 2 ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; if DCSP numterms = 3 , DCSP opExpr DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP of DCSP two DCSP expressions &apos; ) DCNL DCSP DCSP DCSP ( opExpr1 , opExpr2 ) = opExpr DCNL DCSP DCSP thisExpr = Forward ( ) DCNL DCSP DCSP if ( rightLeftAssoc = = opAssoc.LEFT ) : DCNL DCSP DCSP DCSP if ( arity = = 1 ) : DCNL DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( lastExpr + opExpr ) ) + Group ( ( lastExpr + OneOrMore ( opExpr ) ) ) ) DCNL DCSP DCSP DCSP elif ( arity = = 2 ) : DCNL DCSP DCSP DCSP DCSP if ( opExpr is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( ( lastExpr + opExpr ) + lastExpr ) ) + Group ( ( lastExpr + OneOrMore ( ( opExpr + lastExpr ) ) ) ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( lastExpr + lastExpr ) ) + Group ( ( lastExpr + OneOrMore ( lastExpr ) ) ) ) DCNL DCSP DCSP DCSP elif ( arity = = 3 ) : DCNL DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( ( ( ( lastExpr + opExpr1 ) + lastExpr ) + opExpr2 ) + lastExpr ) ) + Group ( ( ( ( ( lastExpr + opExpr1 ) + lastExpr ) + opExpr2 ) + lastExpr ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; operator DCSP must DCSP be DCSP unary DCSP ( 1 ) , DCSP binary DCSP ( 2 ) , DCSP or DCSP ternary DCSP ( 3 ) &apos; ) DCNL DCSP DCSP elif ( rightLeftAssoc = = opAssoc.RIGHT ) : DCNL DCSP DCSP DCSP if ( arity = = 1 ) : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( opExpr , Optional ) ) : DCNL DCSP DCSP DCSP DCSP DCSP opExpr = Optional ( opExpr ) DCNL DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( opExpr.expr + thisExpr ) ) + Group ( ( opExpr + thisExpr ) ) ) DCNL DCSP DCSP DCSP elif ( arity = = 2 ) : DCNL DCSP DCSP DCSP DCSP if ( opExpr is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( ( lastExpr + opExpr ) + thisExpr ) ) + Group ( ( lastExpr + OneOrMore ( ( opExpr + thisExpr ) ) ) ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( lastExpr + thisExpr ) ) + Group ( ( lastExpr + OneOrMore ( thisExpr ) ) ) ) DCNL DCSP DCSP DCSP elif ( arity = = 3 ) : DCNL DCSP DCSP DCSP DCSP matchExpr = ( FollowedBy ( ( ( ( ( lastExpr + opExpr1 ) + thisExpr ) + opExpr2 ) + thisExpr ) ) + Group ( ( ( ( ( lastExpr + opExpr1 ) + thisExpr ) + opExpr2 ) + thisExpr ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; operator DCSP must DCSP be DCSP unary DCSP ( 1 ) , DCSP binary DCSP ( 2 ) , DCSP or DCSP ternary DCSP ( 3 ) &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( &apos; operator DCSP must DCSP indicate DCSP right DCSP or DCSP left DCSP associativity &apos; ) DCNL DCSP DCSP if pa : DCNL DCSP DCSP DCSP matchExpr.setParseAction ( pa ) DCNL DCSP DCSP thisExpr &lt; &lt; = ( matchExpr &#124; lastExpr ) DCNL DCSP DCSP lastExpr = thisExpr DCNL DCSP ret &lt; &lt; = lastExpr DCNL DCSP return ret
DCSP ret = _ get _ account _ policy _ data _ value ( name , &apos; creationTime &apos; ) DCNL DCSP unix _ timestamp = salt.utils.mac _ utils.parse _ return ( ret ) DCNL DCSP date _ text = _ convert _ to _ datetime ( unix _ timestamp ) DCNL DCSP return date _ text
DCSP if ( not trigger.group ( 2 ) ) : DCNL DCSP DCSP return bot.reply ( u &apos;No DCSP search DCSP term . &apos; ) DCNL DCSP query = trigger.group ( 2 ) DCNL DCSP db _ path = _ find _ geoip _ db ( bot ) DCNL DCSP if ( db _ path is False ) : DCNL DCSP DCSP LOGGER.error ( u &quot; Can &apos;t DCSP find DCSP ( or DCSP download ) DCSP usable DCSP GeoIP DCSP database &quot; ) DCNL DCSP DCSP bot.say ( u &quot; Sorry , DCSP I DCSP don &apos;t DCSP have DCSP a DCSP GeoIP DCSP database DCSP to DCSP use DCSP for DCSP this DCSP lookup &quot; ) DCNL DCSP DCSP return False DCNL DCSP geolite _ city _ filepath = os.path.join ( _ find _ geoip _ db ( bot ) , u &apos;GeoLiteCity.dat &apos; ) DCNL DCSP geolite _ ASN _ filepath = os.path.join ( _ find _ geoip _ db ( bot ) , u &apos;GeoIPASNum.dat &apos; ) DCNL DCSP gi _ city = pygeoip.GeoIP ( geolite _ city _ filepath ) DCNL DCSP gi _ org = pygeoip.GeoIP ( geolite _ ASN _ filepath ) DCNL DCSP host = socket.getfqdn ( query ) DCNL DCSP response = ( u &apos; &#91; IP / Host DCSP Lookup &#93; DCSP Hostname : DCSP % s &apos; % host ) DCNL DCSP try : DCNL DCSP DCSP response + = ( u &apos; DCSP &#124; DCSP Location : DCSP % s &apos; % gi _ city.country _ name _ by _ name ( query ) ) DCNL DCSP except AttributeError : DCNL DCSP DCSP response + = u &apos; DCSP &#124; DCSP Location : DCSP Unknown &apos; DCNL DCSP except socket.gaierror : DCNL DCSP DCSP return bot.say ( u &apos; &#91; IP / Host DCSP Lookup &#93; DCSP Unable DCSP to DCSP resolve DCSP IP / Hostname &apos; ) DCNL DCSP region _ data = gi _ city.region _ by _ name ( query ) DCNL DCSP try : DCNL DCSP DCSP region = region _ data &#91; u &apos;region _ code &apos; &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP region = region _ data &#91; u &apos;region _ name &apos; &#93; DCNL DCSP if region : DCNL DCSP DCSP response + = ( u &apos; DCSP &#124; DCSP Region : DCSP % s &apos; % region ) DCNL DCSP isp = gi _ org.org _ by _ name ( query ) DCNL DCSP response + = ( u &apos; DCSP &#124; DCSP ISP : DCSP % s &apos; % isp ) DCNL DCSP bot.say ( response )
DCSP tablename = ( &apos; % s _ % s &apos; % ( module , resourcename ) ) DCNL DCSP s3db.table ( tablename ) DCNL DCSP type = &apos; GPX &apos; DCNL DCSP LAYERS = T ( ( TYPE _ LAYERS _ FMT % type ) ) DCNL DCSP ADD _ NEW _ LAYER = T ( ( ADD _ NEW _ TYPE _ LAYER _ FMT % type ) ) DCNL DCSP EDIT _ LAYER = T ( ( EDIT _ TYPE _ LAYER _ FMT % type ) ) DCNL DCSP LIST _ LAYERS = T ( ( LIST _ TYPE _ LAYERS _ FMT % type ) ) DCNL DCSP NO _ LAYERS = T ( ( NO _ TYPE _ LAYERS _ FMT % type ) ) DCNL DCSP s3.crud _ strings &#91; tablename &#93; = Storage ( label _ create = ADD _ LAYER , title _ display = LAYER _ DETAILS , title _ list = LAYERS , title _ update = EDIT _ LAYER , label _ list _ button = LIST _ LAYERS , label _ delete _ button = DELETE _ LAYER , msg _ record _ created = LAYER _ ADDED , msg _ record _ modified = LAYER _ UPDATED , msg _ record _ deleted = LAYER _ DELETED , msg _ list _ empty = NO _ LAYERS ) DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if r.interactive : DCNL DCSP DCSP DCSP if ( r.component _ name = = &apos; config &apos; ) : DCNL DCSP DCSP DCSP DCSP ltable = s3db.gis _ layer _ config DCNL DCSP DCSP DCSP DCSP ltable.base.writable = ltable.base.readable = False DCNL DCSP DCSP DCSP DCSP if ( r.method ! = &apos; update &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP table = r.table DCNL DCSP DCSP DCSP DCSP DCSP query = ( ( ltable.layer _ id = = table.layer _ id ) &amp; ( table.id = = r.id ) ) DCNL DCSP DCSP DCSP DCSP DCSP rows = db ( query ) .select ( ltable.config _ id ) DCNL DCSP DCSP DCSP DCSP DCSP ltable.config _ id.requires = IS _ ONE _ OF ( db , &apos; gis _ config.id &apos; , &apos; % ( name ) s &apos; , not _ filterby = &apos; config _ id &apos; , not _ filter _ opts = &#91; row.config _ id for row in rows &#93; ) DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp ( r , output ) : DCNL DCSP DCSP if ( r.interactive and ( r.method ! = &apos; import &apos; ) ) : DCNL DCSP DCSP DCSP if ( not r.component ) : DCNL DCSP DCSP DCSP DCSP inject _ enable ( output ) DCNL DCSP DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3 _ rest _ controller ( rheader = s3db.gis _ rheader ) DCNL DCSP return output
DCSP return False
DCSP obj = RSAobj ( ) DCNL DCSP obj.e = long ( e ) DCNL DCSP if progress _ func : DCNL DCSP DCSP progress _ func ( &apos; p , q \ n &apos; ) DCNL DCSP p = q = 1L DCNL DCSP while ( number.size ( ( p * q ) ) &lt; bits ) : DCNL DCSP DCSP p = pubkey.getStrongPrime ( ( bits &gt; &gt; 1 ) , obj.e , 1e-12 , randfunc ) DCNL DCSP DCSP q = pubkey.getStrongPrime ( ( bits - ( bits &gt; &gt; 1 ) ) , obj.e , 1e-12 , randfunc ) DCNL DCSP if ( p &gt; q ) : DCNL DCSP DCSP ( p , q ) = ( q , p ) DCNL DCSP obj.p = p DCNL DCSP obj.q = q DCNL DCSP if progress _ func : DCNL DCSP DCSP progress _ func ( &apos; u \ n &apos; ) DCNL DCSP obj.u = pubkey.inverse ( obj.p , obj.q ) DCNL DCSP obj.n = ( obj.p * obj.q ) DCNL DCSP if progress _ func : DCNL DCSP DCSP progress _ func ( &apos; d \ n &apos; ) DCNL DCSP obj.d = pubkey.inverse ( obj.e , ( ( obj.p - 1 ) * ( obj.q - 1 ) ) ) DCNL DCSP assert ( bits &lt; = ( 1 + obj.size ( ) ) ) , &apos; Generated DCSP key DCSP is DCSP too DCSP small &apos; DCNL DCSP return obj
DCSP ( _ , rest ) = token.contents.split ( None , 1 ) DCNL DCSP filter _ expr = parser.compile _ filter ( ( u &apos;var &#124; % s &apos; % rest ) ) DCNL DCSP for ( func , unused ) in filter _ expr.filters : DCNL DCSP DCSP filter _ name = getattr ( func , u &apos; _ filter _ name &apos; , None ) DCNL DCSP DCSP if ( filter _ name in ( u &apos;escape &apos; , u &apos;safe &apos; ) ) : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( ( u &apos; &quot; filter DCSP % s &quot; DCSP is DCSP not DCSP permitted . DCSP DCSP Use DCSP the DCSP &quot; autoescape &quot; DCSP tag DCSP instead . &apos; % filter _ name ) ) DCNL DCSP nodelist = parser.parse ( ( u &apos;endfilter &apos; , ) ) DCNL DCSP parser.delete _ first _ token ( ) DCNL DCSP return FilterNode ( filter _ expr , nodelist )
DCSP lines = buffer.text.splitlines ( True ) DCNL DCSP lines _ before = lines &#91; : from _ row &#93; DCNL DCSP lines _ after = lines &#91; ( to _ row + 1 ) : &#93; DCNL DCSP lines _ to _ reformat = lines &#91; from _ row : ( to _ row + 1 ) &#93; DCNL DCSP if lines _ to _ reformat : DCNL DCSP DCSP length = re.search ( u &apos; ^ \ \ s * &apos; , lines _ to _ reformat &#91; 0 &#93; ) .end ( ) DCNL DCSP DCSP indent = lines _ to _ reformat &#91; 0 &#93; &#91; : length &#93; .replace ( u &apos; \ n &apos; , u &apos; &apos; ) DCNL DCSP DCSP words = u &apos; &apos; .join ( lines _ to _ reformat ) .split ( ) DCNL DCSP DCSP width = ( ( buffer.text _ width or 80 ) - len ( indent ) ) DCNL DCSP DCSP reshaped _ text = &#91; indent &#93; DCNL DCSP DCSP current _ width = 0 DCNL DCSP DCSP for w in words : DCNL DCSP DCSP DCSP if current _ width : DCNL DCSP DCSP DCSP DCSP if ( ( ( len ( w ) + current _ width ) + 1 ) &gt; width ) : DCNL DCSP DCSP DCSP DCSP DCSP reshaped _ text.append ( u &apos; \ n &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP reshaped _ text.append ( indent ) DCNL DCSP DCSP DCSP DCSP DCSP current _ width = 0 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP reshaped _ text.append ( u &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP current _ width + = 1 DCNL DCSP DCSP DCSP reshaped _ text.append ( w ) DCNL DCSP DCSP DCSP current _ width + = len ( w ) DCNL DCSP DCSP if ( reshaped _ text &#91; ( -1 ) &#93; ! = u &apos; \ n &apos; ) : DCNL DCSP DCSP DCSP reshaped _ text.append ( u &apos; \ n &apos; ) DCNL DCSP DCSP buffer.document = Document ( text = u &apos; &apos; .join ( ( ( lines _ before + reshaped _ text ) + lines _ after ) ) , cursor _ position = len ( u &apos; &apos; .join ( ( lines _ before + reshaped _ text ) ) ) )
DCSP x = np.asarray ( x ) DCNL DCSP if ( ( k % 2 ) ! = 1 ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Odd DCSP degree DCSP for DCSP now DCSP only . DCSP Got DCSP % s . &apos; % k ) ) DCNL DCSP m = ( ( k - 1 ) / / 2 ) DCNL DCSP t = x &#91; ( m + 1 ) : ( ( - m ) - 1 ) &#93; DCNL DCSP t = np.r _ &#91; ( ( ( x &#91; 0 &#93; , ) * ( k + 1 ) ) , t , ( ( x &#91; ( -1 ) &#93; , ) * ( k + 1 ) ) ) &#93; DCNL DCSP return t
DCSP try : DCNL DCSP DCSP r = urlfetch.fetch ( url , method = urlfetch.GET ) DCNL DCSP except urlfetch.Error as e : DCNL DCSP DCSP log.warn ( ( u &apos;Error DCSP opening DCSP url = % r : DCSP % s &apos; % ( url , e ) ) , error = IOError ) DCNL DCSP else : DCNL DCSP DCSP if ( r.status _ code = = 200 ) : DCNL DCSP DCSP DCSP mimetype = &apos; application / octet-stream &apos; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( mimetype , params ) = cgi.parse _ header ( r.headers &#91; &apos; content-type &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP encoding = params &#91; &apos; charset &apos; &#93; DCNL DCSP DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP DCSP encoding = None DCNL DCSP DCSP DCSP if ( mimetype ! = u &apos;text / css &apos; ) : DCNL DCSP DCSP DCSP DCSP log.error ( ( u &apos;Expected DCSP &quot; text / css &quot; DCSP mime DCSP type DCSP for DCSP url DCSP % r DCSP but DCSP found : DCSP % r &apos; % ( url , mimetype ) ) , error = ValueError ) DCNL DCSP DCSP DCSP return ( encoding , r.content ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP log.warn ( ( u &apos;Error DCSP opening DCSP url = % r : DCSP HTTP DCSP status DCSP % s &apos; % ( url , r.status _ code ) ) , error = IOError )
DCSP if ( not os.path.exists ( source ) ) : DCNL DCSP DCSP raise DistutilsFileError ( ( &quot; file DCSP &apos; % s &apos; DCSP does DCSP not DCSP exist &quot; % os.path.abspath ( source ) ) ) DCNL DCSP if ( not os.path.exists ( target ) ) : DCNL DCSP DCSP return 1 DCNL DCSP from stat import ST _ MTIME DCNL DCSP mtime1 = os.stat ( source ) &#91; ST _ MTIME &#93; DCNL DCSP mtime2 = os.stat ( target ) &#91; ST _ MTIME &#93; DCNL DCSP return ( mtime1 &gt; mtime2 )
DCSP trash = contentstore ( &apos; trashcan &apos; ) DCNL DCSP store = contentstore ( ) DCNL DCSP loc = StaticContent.get _ location _ from _ path ( location ) DCNL DCSP content = trash.find ( loc ) DCNL DCSP store.save ( content ) DCNL DCSP if ( content.thumbnail _ location is not None ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP thumbnail _ content = trash.find ( content.thumbnail _ location ) DCNL DCSP DCSP DCSP store.save ( thumbnail _ content ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP pass
DCSP return json.dumps ( dict , sort _ keys = True , indent = indent )
DCSP from werkzeug.wsgi import make _ chunk _ iter DCNL DCSP if return _ iterator : DCNL DCSP DCSP cls = ( lambda x : x ) DCNL DCSP elif ( cls is None ) : DCNL DCSP DCSP cls = MultiDict DCNL DCSP pair _ iter = make _ chunk _ iter ( stream , separator , limit ) DCNL DCSP return cls ( _ url _ decode _ impl ( pair _ iter , charset , decode _ keys , include _ empty , errors ) )
DCSP conn = _ auth ( profile ) DCNL DCSP return conn.delete _ subnet ( subnet )
DCSP try : DCNL DCSP DCSP return int ( info ( name ) .get ( &apos; PID &apos; ) ) DCNL DCSP except ( TypeError , ValueError ) as exc : DCNL DCSP DCSP raise CommandExecutionError ( &quot; Unable DCSP to DCSP get DCSP PID DCSP for DCSP container DCSP &apos; { 0 } &apos; : DCSP { 1 } &quot; .format ( name , exc ) )
DCSP used _ luns = _ get _ used _ lun _ ids _ for _ mappings ( mapping ) DCNL DCSP used _ lun _ id _ counter = collections.Counter ( used _ luns ) DCNL DCSP return used _ lun _ id _ counter
DCSP marker = object ( ) DCNL DCSP if ( getattr ( original , &apos; mismatched &apos; , marker ) is marker ) : DCNL DCSP DCSP return mismatch ( matchee , original.describe ( ) , original.get _ details ( ) ) DCNL DCSP return original
DCSP if ( &apos; id &apos; not in kwargs &#91; &apos; opts &apos; &#93; ) : DCNL DCSP DCSP return { } DCNL DCSP cmd = &apos; { 0 } DCSP { 1 } &apos; .format ( _ _ opts _ _ &#91; &apos; master _ tops &apos; &#93; &#91; &apos; ext _ nodes &apos; &#93; , kwargs &#91; &apos; opts &apos; &#93; &#91; &apos; id &apos; &#93; ) DCNL DCSP ndata = yaml.safe _ load ( subprocess.Popen ( cmd , shell = True , stdout = subprocess.PIPE ) .communicate ( ) &#91; 0 &#93; ) DCNL DCSP if ( not ndata ) : DCNL DCSP DCSP log.info ( &apos; master _ tops DCSP ext _ nodes DCSP call DCSP did DCSP not DCSP return DCSP any DCSP data &apos; ) DCNL DCSP ret = { } DCNL DCSP if ( &apos; environment &apos; in ndata ) : DCNL DCSP DCSP env = ndata &#91; &apos; environment &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP env = &apos; base &apos; DCNL DCSP if ( &apos; classes &apos; in ndata ) : DCNL DCSP DCSP if isinstance ( ndata &#91; &apos; classes &apos; &#93; , dict ) : DCNL DCSP DCSP DCSP ret &#91; env &#93; = list ( ndata &#91; &apos; classes &apos; &#93; ) DCNL DCSP DCSP elif isinstance ( ndata &#91; &apos; classes &apos; &#93; , list ) : DCNL DCSP DCSP DCSP ret &#91; env &#93; = ndata &#91; &apos; classes &apos; &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP log.info ( &apos; master _ tops DCSP ext _ nodes DCSP call DCSP did DCSP not DCSP have DCSP a DCSP dictionary DCSP with DCSP a DCSP &quot; classes &quot; DCSP key . &apos; ) DCNL DCSP return ret
DCSP m = mixin _ cols &#91; &apos; m &apos; &#93; DCNL DCSP m.info.name = &apos; a &apos; DCNL DCSP assert ( m.info.name = = &apos; a &apos; ) DCNL DCSP m.info.description = &apos; a &apos; DCNL DCSP assert ( m.info.description = = &apos; a &apos; ) DCNL DCSP if isinstance ( m , ( u.Quantity , coordinates.SkyCoord , time.Time ) ) : DCNL DCSP DCSP with pytest.raises ( AttributeError ) : DCNL DCSP DCSP DCSP m.info.unit = u.m DCNL DCSP else : DCNL DCSP DCSP m.info.unit = u.m DCNL DCSP DCSP assert ( m.info.unit is u.m ) DCNL DCSP m.info.format = &apos; a &apos; DCNL DCSP assert ( m.info.format = = &apos; a &apos; ) DCNL DCSP m.info.meta = { &apos; a &apos; : 1 } DCNL DCSP assert ( m.info.meta = = { &apos; a &apos; : 1 } ) DCNL DCSP with pytest.raises ( AttributeError ) : DCNL DCSP DCSP m.info.bad _ attr = 1 DCNL DCSP with pytest.raises ( AttributeError ) : DCNL DCSP DCSP m.info.bad _ attr
DCSP cmd _ obj = _ DISTUTILS _ REINIT ( self , command , reinit _ subcommands ) DCNL DCSP options = self.command _ options.get ( command ) DCNL DCSP if options : DCNL DCSP DCSP self . _ set _ command _ options ( cmd _ obj , options ) DCNL DCSP return cmd _ obj
DCSP z = atleast _ 1d ( z ) DCNL DCSP p = atleast _ 1d ( p ) DCNL DCSP degree = _ relative _ degree ( z , p ) DCNL DCSP fs2 = ( 2 * fs ) DCNL DCSP z _ z = ( ( fs2 + z ) / ( fs2 - z ) ) DCNL DCSP p _ z = ( ( fs2 + p ) / ( fs2 - p ) ) DCNL DCSP z _ z = append ( z _ z , ( - ones ( degree ) ) ) DCNL DCSP k _ z = ( k * real ( ( prod ( ( fs2 - z ) ) / prod ( ( fs2 - p ) ) ) ) ) DCNL DCSP return ( z _ z , p _ z , k _ z )
DCSP if ( config.getoption ( &apos; gae _ sdk &apos; ) is not None ) : DCNL DCSP DCSP set _ up _ gae _ environment ( config.getoption ( &apos; gae _ sdk &apos; ) )
DCSP try : DCNL DCSP DCSP date = release &#91; &apos; ReleaseDate &apos; &#93; DCNL DCSP except TypeError : DCNL DCSP DCSP date = &apos; &apos; DCNL DCSP if ( date is not None ) : DCNL DCSP DCSP year = date &#91; : 4 &#93; DCNL DCSP else : DCNL DCSP DCSP year = &apos; &apos; DCNL DCSP return ( date , year )
DCSP for i in xrange ( startpos , len ( line ) ) : DCNL DCSP DCSP if ( line &#91; i &#93; = = startchar ) : DCNL DCSP DCSP DCSP depth + = 1 DCNL DCSP DCSP elif ( line &#91; i &#93; = = endchar ) : DCNL DCSP DCSP DCSP depth - = 1 DCNL DCSP DCSP DCSP if ( depth = = 0 ) : DCNL DCSP DCSP DCSP DCSP return ( ( i + 1 ) , 0 ) DCNL DCSP return ( ( -1 ) , depth )
DCSP if login _ view.startswith ( ( &apos; https : / / &apos; , &apos; http : / / &apos; , &apos; / &apos; ) ) : DCNL DCSP DCSP return login _ view DCNL DCSP else : DCNL DCSP DCSP return url _ for ( login _ view )
DCSP assert ( ( cxpb + mutpb ) &lt; = 1.0 ) , &apos; The DCSP sum DCSP of DCSP the DCSP crossover DCSP and DCSP mutation DCSP probabilities DCSP must DCSP be DCSP smaller DCSP or DCSP equal DCSP to DCSP 1.0 . &apos; DCNL DCSP offspring = &#91; &#93; DCNL DCSP for _ in xrange ( lambda _ ) : DCNL DCSP DCSP op _ choice = random.random ( ) DCNL DCSP DCSP if ( op _ choice &lt; cxpb ) : DCNL DCSP DCSP DCSP ( ind1 , ind2 ) = map ( toolbox.clone , random.sample ( population , 2 ) ) DCNL DCSP DCSP DCSP ( ind1 , ind2 ) = toolbox.mate ( ind1 , ind2 ) DCNL DCSP DCSP DCSP del ind1.fitness.values DCNL DCSP DCSP DCSP offspring.append ( ind1 ) DCNL DCSP DCSP elif ( op _ choice &lt; ( cxpb + mutpb ) ) : DCNL DCSP DCSP DCSP ind = toolbox.clone ( random.choice ( population ) ) DCNL DCSP DCSP DCSP ( ind , ) = toolbox.mutate ( ind ) DCNL DCSP DCSP DCSP del ind.fitness.values DCNL DCSP DCSP DCSP offspring.append ( ind ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP offspring.append ( random.choice ( population ) ) DCNL DCSP return offspring
DCSP if isinstance ( value , ( list , tuple ) ) : DCNL DCSP DCSP value = u &apos; , &apos; .join ( value ) DCNL DCSP elif isinstance ( value , ( date , datetime ) ) : DCNL DCSP DCSP value = value.isoformat ( ) DCNL DCSP elif isinstance ( value , bool ) : DCNL DCSP DCSP value = str ( value ) .lower ( ) DCNL DCSP if isinstance ( value , string _ types ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return value.encode ( u &apos;utf-8 &apos; ) DCNL DCSP DCSP except UnicodeDecodeError : DCNL DCSP DCSP DCSP pass DCNL DCSP return str ( value )
DCSP def wrap ( response _ function ) : DCNL DCSP DCSP def _ api _ validate ( * simple _ vals , * * param _ vals ) : DCNL DCSP DCSP DCSP def val ( fn ) : DCNL DCSP DCSP DCSP DCSP @ wraps ( fn ) DCNL DCSP DCSP DCSP DCSP def newfn ( self , * a , * * env ) : DCNL DCSP DCSP DCSP DCSP DCSP renderstyle = request.params.get ( &apos; renderstyle &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP if renderstyle : DCNL DCSP DCSP DCSP DCSP DCSP DCSP c.render _ style = api _ type ( renderstyle ) DCNL DCSP DCSP DCSP DCSP DCSP elif ( not c.extension ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP c.render _ style = api _ type ( response _ type ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( response _ type = = &apos; html &apos; ) and ( not ( request.params.get ( &apos; api _ type &apos; ) = = &apos; json &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP responder = JQueryResponse ( ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP responder = JsonResponse ( ) DCNL DCSP DCSP DCSP DCSP DCSP response.content _ type = responder.content _ type DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP kw = _ make _ validated _ kw ( fn , simple _ vals , param _ vals , env ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return response _ function ( self , fn , responder , simple _ vals , param _ vals , * a , * * kw ) DCNL DCSP DCSP DCSP DCSP DCSP except UserRequiredException : DCNL DCSP DCSP DCSP DCSP DCSP DCSP responder.send _ failure ( errors.USER _ REQUIRED ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return self.api _ wrapper ( responder.make _ response ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP except VerifiedUserRequiredException : DCNL DCSP DCSP DCSP DCSP DCSP DCSP responder.send _ failure ( errors.VERIFIED _ USER _ REQUIRED ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return self.api _ wrapper ( responder.make _ response ( ) ) DCNL DCSP DCSP DCSP DCSP extra _ param _ vals = { } DCNL DCSP DCSP DCSP DCSP if add _ api _ type _ doc : DCNL DCSP DCSP DCSP DCSP DCSP extra _ param _ vals = { &apos; api _ type &apos; : &apos; the DCSP string DCSP `json` &apos; } DCNL DCSP DCSP DCSP DCSP set _ api _ docs ( newfn , simple _ vals , param _ vals , extra _ param _ vals ) DCNL DCSP DCSP DCSP DCSP newfn.handles _ csrf = _ validators _ handle _ csrf ( simple _ vals , param _ vals ) DCNL DCSP DCSP DCSP DCSP return newfn DCNL DCSP DCSP DCSP return val DCNL DCSP DCSP return _ api _ validate DCNL DCSP return wrap
DCSP if ( compiler &#91; &apos; platform &apos; &#93; = = &apos; x64 &apos; ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP &apos; Build DCSP LCMS DCSP on DCSP VC2008 . DCSP This DCSP version DCSP is DCSP only DCSP 32bit / Win32 &apos; DCNL DCSP return ( &apos; \ nrem DCSP Build DCSP lcms2 \ nsetlocal \ nrd DCSP / S DCSP / Q DCSP % % LCMS % % \ \ Lib \ nrd DCSP / S DCSP / Q DCSP % % LCMS % % \ \ Projects \ \ VC % ( vc _ version ) s \ \ Release \ n % % MSBUILD % % DCSP % % LCMS % % \ \ Projects \ \ VC % ( vc _ version ) s \ \ lcms2.sln DCSP DCSP / t : Clean DCSP / p : Configuration = &quot; Release &quot; DCSP / p : Platform = Win32 DCSP / m \ n % % MSBUILD % % DCSP % % LCMS % % \ \ Projects \ \ VC % ( vc _ version ) s \ \ lcms2.sln DCSP / t : lcms2 _ static DCSP / p : Configuration = &quot; Release &quot; DCSP / p : Platform = Win32 DCSP / m \ nxcopy DCSP / Y DCSP / E DCSP / Q DCSP % % LCMS % % \ \ include DCSP % % INCLIB % % \ ncopy DCSP / Y DCSP / B DCSP % % LCMS % % \ \ Projects \ \ VC % ( vc _ version ) s \ \ Release \ \ * .lib DCSP % % INCLIB % % \ nendlocal \ n &apos; % compiler )
DCSP try : DCNL DCSP DCSP m = _ rfc822 _ match ( dt.lower ( ) ) .groupdict ( 0 ) DCNL DCSP except AttributeError : DCNL DCSP DCSP return None DCNL DCSP return _ parse _ date _ group _ rfc822 ( m )
DCSP instances = find _ instances ( instance _ id = instance _ id , name = instance _ name , tags = tags , region = region , key = key , keyid = keyid , profile = profile , return _ objs = True , filters = filters ) DCNL DCSP if ( not instances ) : DCNL DCSP DCSP log.error ( &apos; Source DCSP instance DCSP not DCSP found &apos; ) DCNL DCSP DCSP return False DCNL DCSP if ( len ( instances ) &gt; 1 ) : DCNL DCSP DCSP log.error ( &apos; Multiple DCSP instances DCSP found , DCSP must DCSP match DCSP exactly DCSP only DCSP one DCSP instance DCSP to DCSP create DCSP an DCSP image DCSP from &apos; ) DCNL DCSP DCSP return False DCNL DCSP instance = instances &#91; 0 &#93; DCNL DCSP try : DCNL DCSP DCSP return instance.create _ image ( ami _ name , description = description , no _ reboot = no _ reboot , dry _ run = dry _ run ) DCNL DCSP except boto.exception.BotoServerError as exc : DCNL DCSP DCSP log.error ( exc ) DCNL DCSP DCSP return False
DCSP return corpus _ chrf ( &#91; reference &#93; , &#91; hypothesis &#93; , min _ len , max _ len , beta = beta )
DCSP return ( not ( ( os.name = = &apos; nt &apos; ) and version _ check ( &apos; 5.3.0 &apos; , operator.lt ) ) )
DCSP try : DCNL DCSP DCSP f = open ( scriptfile , mode = &apos; r &apos; ) DCNL DCSP except Exception : DCNL DCSP DCSP return DCNL DCSP mpstate.console.writeln ( ( &apos; Running DCSP script DCSP % s &apos; % scriptfile ) ) DCNL DCSP for line in f : DCNL DCSP DCSP line = line.strip ( ) DCNL DCSP DCSP if ( ( line = = &apos; &apos; ) or line.startswith ( &apos; # &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if line.startswith ( &apos; @ &apos; ) : DCNL DCSP DCSP DCSP line = line &#91; 1 : &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP mpstate.console.writeln ( ( &apos; - &gt; DCSP % s &apos; % line ) ) DCNL DCSP DCSP process _ stdin ( line ) DCNL DCSP f.close ( )
DCSP log.debug ( &apos; Adding DCSP cohort DCSP % s DCSP to DCSP % s &apos; , name , course _ key ) DCNL DCSP if is _ cohort _ exists ( course _ key , name ) : DCNL DCSP DCSP raise ValueError ( _ ( &apos; You DCSP cannot DCSP create DCSP two DCSP cohorts DCSP with DCSP the DCSP same DCSP name &apos; ) ) DCNL DCSP try : DCNL DCSP DCSP course = courses.get _ course _ by _ id ( course _ key ) DCNL DCSP except Http404 : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP course _ key &apos; ) DCNL DCSP cohort = CourseCohort.create ( cohort _ name = name , course _ id = course.id , assignment _ type = assignment _ type ) .course _ user _ group DCNL DCSP tracker.emit ( &apos; edx.cohort.creation _ requested &apos; , { &apos; cohort _ name &apos; : cohort.name , &apos; cohort _ id &apos; : cohort.id } ) DCNL DCSP return cohort
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP delete _ affinity _ group DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP if ( kwargs is None ) : DCNL DCSP DCSP kwargs = { } DCNL DCSP if ( &apos; name &apos; not in kwargs ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; A DCSP name DCSP must DCSP be DCSP specified DCSP as DCSP &quot; name &quot; &apos; ) DCNL DCSP if ( not conn ) : DCNL DCSP DCSP conn = get _ conn ( ) DCNL DCSP try : DCNL DCSP DCSP conn.delete _ affinity _ group ( kwargs &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP return { &apos; Success &apos; : &apos; The DCSP affinity DCSP group DCSP was DCSP successfully DCSP deleted &apos; } DCNL DCSP except AzureMissingResourceHttpError as exc : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; { 0 } : DCSP { 1 } &apos; .format ( kwargs &#91; &apos; name &apos; &#93; , exc.message ) )
DCSP from sympy.simplify.radsimp import radsimp , rad _ rationalize , split _ surds DCNL DCSP if ( not expr.is _ Pow ) : DCNL DCSP DCSP return sqrtdenest ( expr ) DCNL DCSP if ( expr.base &lt; 0 ) : DCNL DCSP DCSP return ( sqrt ( ( -1 ) ) * _ sqrtdenest _ rec ( sqrt ( ( - expr.base ) ) ) ) DCNL DCSP ( g , a , b ) = split _ surds ( expr.base ) DCNL DCSP a = ( a * sqrt ( g ) ) DCNL DCSP if ( a &lt; b ) : DCNL DCSP DCSP ( a , b ) = ( b , a ) DCNL DCSP c2 = _ mexpand ( ( ( a * * 2 ) - ( b * * 2 ) ) ) DCNL DCSP if ( len ( c2.args ) &gt; 2 ) : DCNL DCSP DCSP ( g , a1 , b1 ) = split _ surds ( c2 ) DCNL DCSP DCSP a1 = ( a1 * sqrt ( g ) ) DCNL DCSP DCSP if ( a1 &lt; b1 ) : DCNL DCSP DCSP DCSP ( a1 , b1 ) = ( b1 , a1 ) DCNL DCSP DCSP c2 _ 1 = _ mexpand ( ( ( a1 * * 2 ) - ( b1 * * 2 ) ) ) DCNL DCSP DCSP c _ 1 = _ sqrtdenest _ rec ( sqrt ( c2 _ 1 ) ) DCNL DCSP DCSP d _ 1 = _ sqrtdenest _ rec ( sqrt ( ( a1 + c _ 1 ) ) ) DCNL DCSP DCSP ( num , den ) = rad _ rationalize ( b1 , d _ 1 ) DCNL DCSP DCSP c = _ mexpand ( ( ( d _ 1 / sqrt ( 2 ) ) + ( num / ( den * sqrt ( 2 ) ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP c = _ sqrtdenest1 ( sqrt ( c2 ) ) DCNL DCSP if ( sqrt _ depth ( c ) &gt; 1 ) : DCNL DCSP DCSP raise SqrtdenestStopIteration DCNL DCSP ac = ( a + c ) DCNL DCSP if ( len ( ac.args ) &gt; = len ( expr.args ) ) : DCNL DCSP DCSP if ( count _ ops ( ac ) &gt; = count _ ops ( expr.base ) ) : DCNL DCSP DCSP DCSP raise SqrtdenestStopIteration DCNL DCSP d = sqrtdenest ( sqrt ( ac ) ) DCNL DCSP if ( sqrt _ depth ( d ) &gt; 1 ) : DCNL DCSP DCSP raise SqrtdenestStopIteration DCNL DCSP ( num , den ) = rad _ rationalize ( b , d ) DCNL DCSP r = ( ( d / sqrt ( 2 ) ) + ( num / ( den * sqrt ( 2 ) ) ) ) DCNL DCSP r = radsimp ( r ) DCNL DCSP return _ mexpand ( r )
DCSP if instance.id : DCNL DCSP DCSP user = User.objects.get ( id = instance.id ) DCNL DCSP DCSP if ( user.username ! = instance.username ) : DCNL DCSP DCSP DCSP questions = Question.objects.filter ( ( Q ( creator = instance ) &#124; Q ( answers _ _ creator = instance ) ) ) .only ( &apos; id &apos; ) .distinct ( ) DCNL DCSP DCSP DCSP for q in questions : DCNL DCSP DCSP DCSP DCSP q.index _ later ( )
DCSP thresh = np.where ( ( mX &#91; 1 : ( -1 ) &#93; &gt; t ) , mX &#91; 1 : ( -1 ) &#93; , 0 ) DCNL DCSP next _ minor = np.where ( ( mX &#91; 1 : ( -1 ) &#93; &gt; mX &#91; 2 : &#93; ) , mX &#91; 1 : ( -1 ) &#93; , 0 ) DCNL DCSP prev _ minor = np.where ( ( mX &#91; 1 : ( -1 ) &#93; &gt; mX &#91; : ( -2 ) &#93; ) , mX &#91; 1 : ( -1 ) &#93; , 0 ) DCNL DCSP ploc = ( ( thresh * next _ minor ) * prev _ minor ) DCNL DCSP ploc = ( ploc.nonzero ( ) &#91; 0 &#93; + 1 ) DCNL DCSP return ploc
DCSP pos = fp.tell ( ) DCNL DCSP fp.seek ( 0 ) DCNL DCSP try : DCNL DCSP DCSP line1 = fp.readline ( ) DCNL DCSP DCSP has _ bom = line1.startswith ( codecs.BOM _ UTF8 ) DCNL DCSP DCSP if has _ bom : DCNL DCSP DCSP DCSP line1 = line1 &#91; len ( codecs.BOM _ UTF8 ) : &#93; DCNL DCSP DCSP m = PYTHON _ MAGIC _ COMMENT _ re.match ( line1 ) DCNL DCSP DCSP if ( not m ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP import parser DCNL DCSP DCSP DCSP DCSP parser.suite ( line1 ) DCNL DCSP DCSP DCSP except ( ImportError , SyntaxError ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP line2 = fp.readline ( ) DCNL DCSP DCSP DCSP DCSP m = PYTHON _ MAGIC _ COMMENT _ re.match ( line2 ) DCNL DCSP DCSP if has _ bom : DCNL DCSP DCSP DCSP if m : DCNL DCSP DCSP DCSP DCSP raise SyntaxError ( &apos; python DCSP refuses DCSP to DCSP compile DCSP code DCSP with DCSP both DCSP a DCSP UTF8 DCSP byte-order-mark DCSP and DCSP a DCSP magic DCSP encoding DCSP comment &apos; ) DCNL DCSP DCSP DCSP return &apos; utf _ 8 &apos; DCNL DCSP DCSP elif m : DCNL DCSP DCSP DCSP return m.group ( 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return None DCNL DCSP finally : DCNL DCSP DCSP fp.seek ( pos )
DCSP signal.signal ( signal.SIGINT , signal.default _ int _ handler )
DCSP return tempfile.mkdtemp ( suffix , prefix , parent )
DCSP n = 1 DCNL DCSP extension = ext DCNL DCSP while os.path.exists ( ( dir + extension ) ) : DCNL DCSP DCSP n + = 1 DCNL DCSP DCSP extension = ( ext + str ( n ) ) DCNL DCSP return ( dir + extension )
DCSP charset = config.Option.get ( &apos; p _ charset &apos; ) DCNL DCSP if ( not charset ) : DCNL DCSP DCSP charset = cyclic _ pattern _ charset ( charset ) DCNL DCSP else : DCNL DCSP DCSP charset = &apos; &apos;.join ( set ( charset ) ) DCNL DCSP if ( start is None ) : DCNL DCSP DCSP start = 0 DCNL DCSP if ( size is None ) : DCNL DCSP DCSP size = 65536 DCNL DCSP size + = start DCNL DCSP pattern = de _ bruijn ( charset , 3 , size ) DCNL DCSP return pattern &#91; start : size &#93; .encode ( &apos; utf-8 &apos; )
DCSP options = _ UnderrideColor ( options ) DCNL DCSP options = _ Underride ( options , linewidth = 0 , alpha = 0.6 ) DCNL DCSP pyplot.bar ( xs , ys , * * options )
DCSP if ( ( not skipkeys ) and ensure _ ascii and check _ circular and allow _ nan and ( cls is None ) and ( indent is None ) and ( separators is None ) and ( encoding = = &apos; utf-8 &apos; ) and ( default is None ) and use _ decimal and namedtuple _ as _ object and tuple _ as _ array and ( not iterable _ as _ array ) and ( not bigint _ as _ string ) and ( not sort _ keys ) and ( not item _ sort _ key ) and ( not for _ json ) and ( not ignore _ nan ) and ( int _ as _ string _ bitcount is None ) and ( not kw ) ) : DCNL DCSP DCSP iterable = _ default _ encoder.iterencode ( obj ) DCNL DCSP else : DCNL DCSP DCSP if ( cls is None ) : DCNL DCSP DCSP DCSP cls = JSONEncoder DCNL DCSP DCSP iterable = cls ( skipkeys = skipkeys , ensure _ ascii = ensure _ ascii , check _ circular = check _ circular , allow _ nan = allow _ nan , indent = indent , separators = separators , encoding = encoding , default = default , use _ decimal = use _ decimal , namedtuple _ as _ object = namedtuple _ as _ object , tuple _ as _ array = tuple _ as _ array , iterable _ as _ array = iterable _ as _ array , bigint _ as _ string = bigint _ as _ string , sort _ keys = sort _ keys , item _ sort _ key = item _ sort _ key , for _ json = for _ json , ignore _ nan = ignore _ nan , int _ as _ string _ bitcount = int _ as _ string _ bitcount , * * kw ) .iterencode ( obj ) DCNL DCSP for chunk in iterable : DCNL DCSP DCSP fp.write ( chunk )
DCSP if ( text is None ) : DCNL DCSP DCSP return u &apos; &apos; DCNL DCSP tag _ id = RE _ TAGS.sub ( u &apos; &apos; , unicodedata.normalize ( u &apos;NFKD &apos; , text ) ) .lower ( ) DCNL DCSP tag _ id = RE _ WORD.sub ( u &apos; &apos; , tag _ id ) .replace ( u &apos; DCSP &apos; , sep ) DCNL DCSP return quote ( tag _ id.encode ( u &apos;utf-8 &apos; ) )
DCSP string = u ( string ) .replace ( u &apos; \ u2024 &apos; , &apos; .&apos; ) DCNL DCSP matches = &#91; &#93; DCNL DCSP for m in RE _ EMAIL.finditer ( string ) : DCNL DCSP DCSP s = m.group ( 0 ) DCNL DCSP DCSP if ( ( not unique ) or ( s not in matches ) ) : DCNL DCSP DCSP DCSP matches.append ( s ) DCNL DCSP return matches
DCSP key = _ make _ ratelimit _ cache _ key ( key _ prefix , time _ slice ) DCNL DCSP try : DCNL DCSP DCSP g.ratelimitcache.add ( key , 0 , time = time _ slice.remaining ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return g.ratelimitcache.incr ( key ) DCNL DCSP DCSP except pylibmc.NotFound : DCNL DCSP DCSP DCSP now = int ( time.time ( ) ) DCNL DCSP DCSP DCSP if ( now &lt; time _ slice.end ) : DCNL DCSP DCSP DCSP DCSP g.ratelimitcache.add ( key , 1 , time = ( ( time _ slice.end - now ) + 1 ) ) DCNL DCSP DCSP DCSP DCSP g.stats.simple _ event ( &apos; ratelimit.eviction &apos; ) DCNL DCSP DCSP DCSP return 1 DCNL DCSP except pylibmc.Error as e : DCNL DCSP DCSP raise RatelimitError ( e )
DCSP try : DCNL DCSP DCSP bbox _ data = BboxData ( ) DCNL DCSP DCSP bbox _ data.update ( ) DCNL DCSP except requests.exceptions.HTTPError as error : DCNL DCSP DCSP _ LOGGER.error ( error ) DCNL DCSP DCSP return False DCNL DCSP name = config.get ( CONF _ NAME ) DCNL DCSP sensors = &#91; &#93; DCNL DCSP for variable in config &#91; CONF _ MONITORED _ VARIABLES &#93; : DCNL DCSP DCSP sensors.append ( BboxSensor ( bbox _ data , variable , name ) ) DCNL DCSP add _ devices ( sensors )
DCSP forum = get _ object _ or _ 404 ( Forum , slug = forum _ slug ) DCNL DCSP if ( not forum.allows _ viewing _ by ( request.user ) ) : DCNL DCSP DCSP raise Http404 DCNL DCSP if ( request.POST.get ( &apos; watch &apos; ) = = &apos; yes &apos; ) : DCNL DCSP DCSP NewThreadEvent.notify ( request.user , forum ) DCNL DCSP DCSP statsd.incr ( &apos; forums.watches.forum &apos; ) DCNL DCSP else : DCNL DCSP DCSP NewThreadEvent.stop _ notifying ( request.user , forum ) DCNL DCSP return HttpResponseRedirect ( reverse ( &apos; forums.threads &apos; , args = &#91; forum _ slug &#93; ) )
DCSP return bool ( _ OVERRIDES _ DISABLED.disabled )
DCSP import ransac DCNL DCSP data = vstack ( ( fp , tp ) ) DCNL DCSP ( H , ransac _ data ) = ransac.ransac ( data.T , model , 4 , maxiter , match _ theshold , 10 , return _ all = True ) DCNL DCSP return ( H , ransac _ data &#91; &apos; inliers &apos; &#93; )
DCSP string _ len = len ( string ) DCNL DCSP if ( string _ len &lt; = max _ width ) : DCNL DCSP DCSP return string DCNL DCSP visible = ( ( max _ width - 16 ) - int ( log10 ( string _ len ) ) ) DCNL DCSP if ( not isinstance ( string , unistr ) ) : DCNL DCSP DCSP visstring = unistr ( string &#91; : visible &#93; , errors = &apos; ignore &apos; ) DCNL DCSP else : DCNL DCSP DCSP visstring = string &#91; : visible &#93; DCNL DCSP return u &apos; &apos; .join ( ( visstring , u &apos; ... ( and DCSP &apos; , unistr ( ( string _ len - visible ) ) , u &apos; DCSP more ) &apos; ) )
DCSP me = MouseEvent ( &apos; mouse _ press &apos; ) DCNL DCSP for fun in ( me.pos , me.button , me.buttons , me.modifiers , me.delta , me.press _ event , me.last _ event , me.is _ dragging ) : DCNL DCSP DCSP fun DCNL DCSP me.drag _ events ( ) DCNL DCSP me . _ forget _ last _ event ( ) DCNL DCSP me.trail ( ) DCNL DCSP ke = KeyEvent ( &apos; key _ release &apos; ) DCNL DCSP ke.key DCNL DCSP ke.text DCNL DCSP ke.modifiers
DCSP init _ subsystem ( Native.Factory ) DCNL DCSP return Native.Factory.global _ instance ( ) .create ( )
DCSP rsl = RSupervisedLearner ( HALT _ EXEC = HALT _ EXEC ) DCNL DCSP rsl.Parameters &#91; &apos; -m &apos; &#93; .on ( response _ fp ) DCNL DCSP rsl.Parameters &#91; &apos; -c &apos; &#93; .on ( response _ name ) DCNL DCSP rsl.Parameters &#91; &apos; -n &apos; &#93; .on ( str ( ntree ) ) DCNL DCSP rsl.Parameters &#91; &apos; -o &apos; &#93; .on ( output _ dir ) DCNL DCSP rsl.Parameters &#91; &apos; -e &apos; &#93; .on ( errortype ) DCNL DCSP if verbose : DCNL DCSP DCSP rsl.Parameters &#91; &apos; -v &apos; &#93; .on ( ) DCNL DCSP app _ result = rsl ( predictor _ fp ) DCNL DCSP remove ( join ( output _ dir , ( splitext ( split ( predictor _ fp ) &#91; 1 &#93; ) &#91; 0 &#93; + &apos; .txt &apos; ) ) ) DCNL DCSP return app _ result
DCSP w = wcs.WCS ( naxis = 3 ) DCNL DCSP w.wcs.crval = &#91; 240.9303333333 , 50 , 212345678000.0 &#93; DCNL DCSP w.wcs.cdelt = &#91; 0.001 , 0.001 , 100000000.0 &#93; DCNL DCSP w.wcs.ctype = &#91; u &apos;RA---TAN &apos; , u &apos;DEC--TAN &apos; , u &apos;FREQ &apos; &#93; DCNL DCSP w.wcs.set ( ) DCNL DCSP w2 = wcs.WCS ( w.to _ header ( ) ) DCNL DCSP w.wcs.compare ( w2.wcs )
DCSP cmd = browser.split ( ) &#91; 0 &#93; DCNL DCSP if ( not _ iscommand ( cmd ) ) : DCNL DCSP DCSP return &#91; None , None &#93; DCNL DCSP name = os.path.basename ( cmd ) DCNL DCSP try : DCNL DCSP DCSP command = _ browsers &#91; name.lower ( ) &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP return &#91; None , None &#93; DCNL DCSP controller = command &#91; 1 &#93; DCNL DCSP if ( controller and ( name.lower ( ) = = controller.basename ) ) : DCNL DCSP DCSP import copy DCNL DCSP DCSP controller = copy.copy ( controller ) DCNL DCSP DCSP controller.name = browser DCNL DCSP DCSP controller.basename = os.path.basename ( browser ) DCNL DCSP DCSP register ( browser , None , controller , update _ tryorder ) DCNL DCSP DCSP return &#91; None , controller &#93; DCNL DCSP return &#91; None , None &#93;
DCSP def _ timeout ( ) : DCNL DCSP DCSP deferred.cancel ( ) DCNL DCSP delayed _ timeout = reactor.callLater ( timeout _ sec , _ timeout ) DCNL DCSP if ( reason is not None ) : DCNL DCSP DCSP def maybe _ replace _ reason ( passthrough ) : DCNL DCSP DCSP DCSP if delayed _ timeout.active ( ) : DCNL DCSP DCSP DCSP DCSP return passthrough DCNL DCSP DCSP DCSP return Failure ( reason ) DCNL DCSP DCSP deferred.addErrback ( maybe _ replace _ reason ) DCNL DCSP def abort _ timeout ( passthrough ) : DCNL DCSP DCSP if delayed _ timeout.active ( ) : DCNL DCSP DCSP DCSP delayed _ timeout.cancel ( ) DCNL DCSP DCSP return passthrough DCNL DCSP deferred.addBoth ( abort _ timeout ) DCNL DCSP return deferred
DCSP row _ data = &#91; &#93; DCNL DCSP for ( field , cell ) in zip ( schema , row &#91; &apos; f &apos; &#93; ) : DCNL DCSP DCSP converter = _ CELLDATA _ FROM _ JSON &#91; field.field _ type &#93; DCNL DCSP DCSP if ( field.mode = = &apos; REPEATED &apos; ) : DCNL DCSP DCSP DCSP row _ data.append ( &#91; converter ( item &#91; &apos; v &apos; &#93; , field ) for item in cell &#91; &apos; v &apos; &#93; &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP row _ data.append ( converter ( cell &#91; &apos; v &apos; &#93; , field ) ) DCNL DCSP return tuple ( row _ data )
DCSP if isinstance ( cix , unicode ) : DCNL DCSP DCSP cix = cix.encode ( &apos; UTF-8 &apos; , &apos; xmlcharrefreplace &apos; ) DCNL DCSP tree = ET.XML ( cix ) DCNL DCSP version = tree.get ( &apos; version &apos; ) DCNL DCSP if ( version = = CIX _ VERSION ) : DCNL DCSP DCSP return tree DCNL DCSP elif ( version = = &apos; 0.1 &apos; ) : DCNL DCSP DCSP return tree _ 2 _ 0 _ from _ tree _ 0 _ 1 ( tree ) DCNL DCSP else : DCNL DCSP DCSP raise CodeIntelError ( ( &apos; unknown DCSP CIX DCSP version : DCSP % r &apos; % version ) )
DCSP if ( status = = BaseComment.OPEN ) : DCNL DCSP DCSP return u &apos;rb-icon-issue-open &apos; DCNL DCSP elif ( status = = BaseComment.RESOLVED ) : DCNL DCSP DCSP return u &apos;rb-icon-issue-resolved &apos; DCNL DCSP elif ( status = = BaseComment.DROPPED ) : DCNL DCSP DCSP return u &apos;rb-icon-issue-dropped &apos; DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( u &apos;Unknown DCSP comment DCSP issue DCSP status DCSP &quot; % s &quot; &apos; % status ) )
DCSP floatX = theano.config.floatX DCNL DCSP rng = numpy.random.RandomState ( 1234 ) DCNL DCSP readout _ dim = 5 DCNL DCSP feedback _ dim = 3 DCNL DCSP dim = 20 DCNL DCSP batch _ size = 30 DCNL DCSP n _ steps = 10 DCNL DCSP transition = GatedRecurrent ( dim = dim , activation = Tanh ( ) , weights _ init = Orthogonal ( ) ) DCNL DCSP generator = SequenceGenerator ( Readout ( readout _ dim = readout _ dim , source _ names = &#91; &apos; states &apos; &#93; , emitter = SoftmaxEmitter ( theano _ seed = 1234 ) , feedback _ brick = LookupFeedback ( readout _ dim , feedback _ dim ) ) , transition , weights _ init = IsotropicGaussian ( 0.1 ) , biases _ init = Constant ( 0 ) , seed = 1234 ) DCNL DCSP generator.initialize ( ) DCNL DCSP y = tensor.lmatrix ( &apos; y &apos; ) DCNL DCSP mask = tensor.matrix ( &apos; mask &apos; ) DCNL DCSP costs = generator.cost _ matrix ( y , mask ) DCNL DCSP assert ( costs.ndim = = 2 ) DCNL DCSP costs _ fun = theano.function ( &#91; y , mask &#93; , &#91; costs &#93; ) DCNL DCSP y _ test = rng.randint ( readout _ dim , size = ( n _ steps , batch _ size ) ) DCNL DCSP m _ test = numpy.ones ( ( n _ steps , batch _ size ) , dtype = floatX ) DCNL DCSP costs _ val = costs _ fun ( y _ test , m _ test ) &#91; 0 &#93; DCNL DCSP assert ( costs _ val.shape = = ( n _ steps , batch _ size ) ) DCNL DCSP assert _ allclose ( costs _ val.sum ( ) , 482.827 , rtol = 1e-05 ) DCNL DCSP cost = generator.cost ( y , mask ) DCNL DCSP assert ( cost.ndim = = 0 ) DCNL DCSP cost _ val = theano.function ( &#91; y , mask &#93; , &#91; cost &#93; ) ( y _ test , m _ test ) DCNL DCSP assert _ allclose ( cost _ val , 16.0942 , rtol = 1e-05 ) DCNL DCSP cg = ComputationGraph ( &#91; cost &#93; ) DCNL DCSP var _ filter = VariableFilter ( roles = &#91; AUXILIARY &#93; ) DCNL DCSP aux _ var _ name = &apos; _ &apos; .join ( &#91; generator.name , generator.cost.name , &apos; per _ sequence _ element &apos; &#93; ) DCNL DCSP cost _ per _ el = &#91; el for el in var _ filter ( cg.variables ) if ( el.name = = aux _ var _ name ) &#93; &#91; 0 &#93; DCNL DCSP assert ( cost _ per _ el.ndim = = 0 ) DCNL DCSP cost _ per _ el _ val = theano.function ( &#91; y , mask &#93; , &#91; cost _ per _ el &#93; ) ( y _ test , m _ test ) DCNL DCSP assert _ allclose ( cost _ per _ el _ val , 1.60942 , rtol = 1e-05 ) DCNL DCSP ( states , outputs , costs ) = generator.generate ( iterate = True , batch _ size = batch _ size , n _ steps = n _ steps ) DCNL DCSP cg = ComputationGraph ( ( ( states + outputs ) + costs ) ) DCNL DCSP ( states _ val , outputs _ val , costs _ val ) = theano.function ( &#91; &#93; , &#91; states , outputs , costs &#93; , updates = cg.updates ) ( ) DCNL DCSP assert ( states _ val.shape = = ( n _ steps , batch _ size , dim ) ) DCNL DCSP assert ( outputs _ val.shape = = ( n _ steps , batch _ size ) ) DCNL DCSP assert ( outputs _ val.dtype = = &apos; int64 &apos; ) DCNL DCSP assert ( costs _ val.shape = = ( n _ steps , batch _ size ) ) DCNL DCSP assert _ allclose ( states _ val.sum ( ) , ( -17.854 ) , rtol = 1e-05 ) DCNL DCSP assert _ allclose ( costs _ val.sum ( ) , 482.868 , rtol = 1e-05 ) DCNL DCSP assert ( outputs _ val.sum ( ) = = 629 ) DCNL DCSP cost1 = costs _ fun ( &#91; &#91; 1 &#93; , &#91; 2 &#93; &#93; , &#91; &#91; 1 &#93; , &#91; 1 &#93; &#93; ) &#91; 0 &#93; DCNL DCSP cost2 = costs _ fun ( &#91; &#91; 3 , 1 &#93; , &#91; 4 , 2 &#93; , &#91; 2 , 0 &#93; &#93; , &#91; &#91; 1 , 1 &#93; , &#91; 1 , 1 &#93; , &#91; 1 , 0 &#93; &#93; ) &#91; 0 &#93; DCNL DCSP assert _ allclose ( cost1.sum ( ) , cost2 &#91; : , 1 &#93; .sum ( ) , rtol = 1e-05 )
DCSP if ( content.endswith ( trailing ) and ( content ! = trailing ) ) : DCNL DCSP DCSP return content &#91; : ( - len ( trailing ) ) &#93; DCNL DCSP return content
DCSP state = twill.get _ browser ( ) DCNL DCSP form = state.get _ form ( &apos; 1&apos; ) DCNL DCSP if ( not form ) : DCNL DCSP DCSP print &apos; No DCSP messages ; DCSP exiting . &apos; DCNL DCSP DCSP raise SystemExit
DCSP return &#91; o for o in gc.get _ objects ( ) if ( name _ filter = = typename ( o ) ) &#93;
DCSP if ( low &lt; xmin ) : DCNL DCSP DCSP low = xmin DCNL DCSP xs = np.linspace ( low , high , n ) DCNL DCSP ps = ( 1 - ( ( xs / xmin ) * * ( - alpha ) ) ) DCNL DCSP return ( xs , ps )
DCSP if ( not HAS _ APT ) : DCNL DCSP DCSP raise CommandExecutionError ( &quot; Error : DCSP &apos; python-apt &apos; DCSP package DCSP not DCSP installed &quot; )
DCSP non _ local &#91; &apos; loaders &apos; &#93; = &#91; &#93; DCNL DCSP for filename in z.namelist ( ) : DCNL DCSP DCSP if ( not isinstance ( filename , str _ cls ) ) : DCNL DCSP DCSP DCSP filename = filename.decode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP non _ local &#91; &apos; loaders &apos; &#93; .append ( filename )
DCSP return &#91; id _ to _ word &#91; i &#93; for i in data &#93;
DCSP TINY = np.sqrt ( np.finfo ( float ) .eps ) DCNL DCSP arrays = &#91; &#93; DCNL DCSP for arg in args : DCNL DCSP DCSP a = np.asarray ( arg ) DCNL DCSP DCSP n = len ( a ) DCNL DCSP DCSP mu = np.mean ( a ) DCNL DCSP DCSP sq = ( ( a - mu ) * * 2 ) DCNL DCSP DCSP sumsq = sq.sum ( ) DCNL DCSP DCSP t = ( ( ( ( ( n - 1.5 ) * n ) * sq ) - ( 0.5 * sumsq ) ) / ( ( n - 1 ) * ( n - 2 ) ) ) DCNL DCSP DCSP var = ( sumsq / ( n - 1 ) ) DCNL DCSP DCSP if ( abs ( ( var - np.mean ( t ) ) ) &gt; TINY ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Lack DCSP of DCSP convergence DCSP in DCSP obrientransform . &apos; ) DCNL DCSP DCSP arrays.append ( t ) DCNL DCSP return np.array ( arrays )
DCSP target _ dir = ( script.scratch _ path / &apos; target &apos; ) DCNL DCSP result = script.pip _ install _ local ( &apos; -t &apos; , target _ dir , &apos; simple = = 1.0 &apos; ) DCNL DCSP assert ( ( ( Path ( &apos; scratch &apos; ) / &apos; target &apos; ) / &apos; simple &apos; ) in result.files _ created ) , str ( result ) DCNL DCSP result = script.pip _ install _ local ( &apos; -t &apos; , target _ dir , &apos; simple = = 1.0 &apos; , expect _ stderr = True ) DCNL DCSP assert ( not ( ( ( Path ( &apos; scratch &apos; ) / &apos; target &apos; ) / &apos; simple &apos; ) in result.files _ updated ) ) DCNL DCSP result = script.pip _ install _ local ( &apos; --upgrade &apos; , &apos; -t &apos; , target _ dir , &apos; simple = = 2.0 &apos; ) DCNL DCSP assert ( ( ( Path ( &apos; scratch &apos; ) / &apos; target &apos; ) / &apos; simple &apos; ) in result.files _ updated ) , str ( result ) DCNL DCSP egg _ folder = ( ( ( Path ( &apos; scratch &apos; ) / &apos; target &apos; ) / &apos; simple-2.0-py % s.egg-info &apos; ) % pyversion ) DCNL DCSP assert ( egg _ folder in result.files _ created ) , str ( result ) DCNL DCSP result = script.pip _ install _ local ( &apos; -t &apos; , target _ dir , &apos; singlemodule = = 0.0.0 &apos; ) DCNL DCSP singlemodule _ py = ( ( Path ( &apos; scratch &apos; ) / &apos; target &apos; ) / &apos; singlemodule.py &apos; ) DCNL DCSP assert ( singlemodule _ py in result.files _ created ) , str ( result ) DCNL DCSP result = script.pip _ install _ local ( &apos; -t &apos; , target _ dir , &apos; singlemodule = = 0.0.1 &apos; , &apos; --upgrade &apos; ) DCNL DCSP assert ( singlemodule _ py in result.files _ updated ) , str ( result )
DCSP if ( var = = x ) : DCNL DCSP DCSP return True DCNL DCSP elif isinstance ( x , Compound ) : DCNL DCSP DCSP return occur _ check ( var , x.args ) DCNL DCSP elif is _ args ( x ) : DCNL DCSP DCSP if any ( ( occur _ check ( var , xi ) for xi in x ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP if ( source not in G ) : DCNL DCSP DCSP raise nx.NodeNotFound ( &apos; Source DCSP { } DCSP not DCSP in DCSP G &apos; .format ( source ) ) DCNL DCSP level = 0 DCNL DCSP nextlevel = &#91; source &#93; DCNL DCSP seen = { source : level } DCNL DCSP pred = { source : &#91; &#93; } DCNL DCSP while nextlevel : DCNL DCSP DCSP level = ( level + 1 ) DCNL DCSP DCSP thislevel = nextlevel DCNL DCSP DCSP nextlevel = &#91; &#93; DCNL DCSP DCSP for v in thislevel : DCNL DCSP DCSP DCSP for w in G &#91; v &#93; : DCNL DCSP DCSP DCSP DCSP if ( w not in seen ) : DCNL DCSP DCSP DCSP DCSP DCSP pred &#91; w &#93; = &#91; v &#93; DCNL DCSP DCSP DCSP DCSP DCSP seen &#91; w &#93; = level DCNL DCSP DCSP DCSP DCSP DCSP nextlevel.append ( w ) DCNL DCSP DCSP DCSP DCSP elif ( seen &#91; w &#93; = = level ) : DCNL DCSP DCSP DCSP DCSP DCSP pred &#91; w &#93; .append ( v ) DCNL DCSP DCSP if ( cutoff and ( cutoff &lt; = level ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP if ( target is not None ) : DCNL DCSP DCSP if return _ seen : DCNL DCSP DCSP DCSP if ( not ( target in pred ) ) : DCNL DCSP DCSP DCSP DCSP return ( &#91; &#93; , ( -1 ) ) DCNL DCSP DCSP DCSP return ( pred &#91; target &#93; , seen &#91; target &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( not ( target in pred ) ) : DCNL DCSP DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP DCSP return pred &#91; target &#93; DCNL DCSP elif return _ seen : DCNL DCSP DCSP return ( pred , seen ) DCNL DCSP else : DCNL DCSP DCSP return pred
DCSP try : DCNL DCSP DCSP if six.PY2 : DCNL DCSP DCSP DCSP raw _ key = public _ key.decode ( &apos; base64 &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raw _ key = base64.b64decode ( public _ key , validate = True ) DCNL DCSP except binascii.Error : DCNL DCSP DCSP return None DCNL DCSP ret = hashlib.md5 ( raw _ key ) .hexdigest ( ) DCNL DCSP chunks = &#91; ret &#91; i : ( i + 2 ) &#93; for i in range ( 0 , len ( ret ) , 2 ) &#93; DCNL DCSP return &apos; : &apos; .join ( chunks )
DCSP if ( &apos; ^ &apos; = = response &#91; 0 &#93; ) : DCNL DCSP DCSP body = &#91; &#93; DCNL DCSP elif ( &apos; running &apos; in command ) : DCNL DCSP DCSP body = response DCNL DCSP else : DCNL DCSP DCSP if ( command in response &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP response = &#91; response &#91; 0 &#93; .split ( command ) &#91; 1 &#93; &#93; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP body = &#91; json.loads ( response &#91; 0 &#93; ) &#93; DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP module.fail _ json ( msg = &apos; Command DCSP does DCSP not DCSP support DCSP JSON DCSP output &apos; , command = command ) DCNL DCSP return body
DCSP return _ osquery _ cmd ( table = &apos; hash &apos; , attrs = attrs , where = where )
DCSP data = _ get _ data ( ) DCNL DCSP return du.process _ recarray ( data , endog _ idx = 0 , dtype = float )
DCSP if isinstance ( s , unicode ) : DCNL DCSP DCSP s = s.encode ( charset ) DCNL DCSP return _ decode _ unicode ( _ unquote _ plus ( s ) , charset , errors )
DCSP def perform ( ) : DCNL DCSP DCSP if ( not worker . _ pending ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP if ( worker . _ pending &#91; 0 &#93; is NoMoreWork ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP worker . _ pending.pop ( 0 ) ( ) DCNL DCSP DCSP return True DCNL DCSP worker = MemoryWorker ( ) DCNL DCSP return ( worker , perform )
DCSP my _ node _ id = list ( client.nodes.info ( &apos; _ local &apos; ) &#91; &apos; nodes &apos; &#93; ) &#91; 0 &#93; DCNL DCSP master _ node _ id = client.cluster.state ( metric = &apos; master _ node &apos; ) &#91; &apos; master _ node &apos; &#93; DCNL DCSP return ( my _ node _ id = = master _ node _ id )
DCSP global _ config _ vars DCNL DCSP if ( _ config _ vars is None ) : DCNL DCSP DCSP func = globals ( ) .get ( ( &apos; _ init _ &apos; + os.name ) ) DCNL DCSP DCSP if func : DCNL DCSP DCSP DCSP func ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP _ config _ vars = { } DCNL DCSP DCSP _ config _ vars &#91; &apos; prefix &apos; &#93; = PREFIX DCNL DCSP DCSP _ config _ vars &#91; &apos; exec _ prefix &apos; &#93; = EXEC _ PREFIX DCNL DCSP DCSP if ( sys.platform = = &apos; darwin &apos; ) : DCNL DCSP DCSP DCSP import _ osx _ support DCNL DCSP DCSP DCSP _ osx _ support.customize _ config _ vars ( _ config _ vars ) DCNL DCSP if args : DCNL DCSP DCSP vals = &#91; &#93; DCNL DCSP DCSP for name in args : DCNL DCSP DCSP DCSP vals.append ( _ config _ vars.get ( name ) ) DCNL DCSP DCSP return vals DCNL DCSP else : DCNL DCSP DCSP return _ config _ vars
DCSP try : DCNL DCSP DCSP todo = frappe.db.get _ value ( u &apos;ToDo &apos; , { u &apos;reference _ type &apos; : doctype , u &apos;reference _ name &apos; : name , u &apos;owner &apos; : assign _ to , u &apos;status &apos; : u &apos;Open &apos; } ) DCNL DCSP DCSP if todo : DCNL DCSP DCSP DCSP todo = frappe.get _ doc ( u &apos;ToDo &apos; , todo ) DCNL DCSP DCSP DCSP todo.status = u &apos;Closed &apos; DCNL DCSP DCSP DCSP todo.save ( ignore _ permissions = True ) DCNL DCSP DCSP DCSP notify _ assignment ( todo.assigned _ by , todo.owner , todo.reference _ type , todo.reference _ name ) DCNL DCSP except frappe.DoesNotExistError : DCNL DCSP DCSP pass DCNL DCSP if frappe.get _ meta ( doctype ) .get _ field ( u &apos;assigned _ to &apos; ) : DCNL DCSP DCSP frappe.db.set _ value ( doctype , name , u &apos;assigned _ to &apos; , None ) DCNL DCSP return get ( { u &apos;doctype &apos; : doctype , u &apos;name &apos; : name } )
DCSP pscmd = &#91; &#93; DCNL DCSP current _ apppools = list _ apppools ( ) DCNL DCSP apppool _ path = &apos; IIS : \ \ AppPools \ \ { 0 } &apos; .format ( name ) DCNL DCSP if ( name in current _ apppools ) : DCNL DCSP DCSP _ LOG.debug ( &quot; Application DCSP pool DCSP &apos; % s &apos; DCSP already DCSP present . &quot; , name ) DCNL DCSP DCSP return True DCNL DCSP pscmd.append ( &quot; New-Item DCSP -Path DCSP &apos; { 0 } &apos; &quot; .format ( apppool _ path ) ) DCNL DCSP cmd _ ret = _ srvmgr ( str ( ) .join ( pscmd ) ) DCNL DCSP if ( cmd _ ret &#91; &apos; retcode &apos; &#93; = = 0 ) : DCNL DCSP DCSP _ LOG.debug ( &apos; Application DCSP pool DCSP created DCSP successfully : DCSP % s &apos; , name ) DCNL DCSP DCSP return True DCNL DCSP _ LOG.error ( &apos; Unable DCSP to DCSP create DCSP application DCSP pool : DCSP % s &apos; , name ) DCNL DCSP return False
DCSP _ emit _ deprecation _ warning ( &apos; baremetal-node-list &apos; ) DCNL DCSP nodes = cs.baremetal.list ( ) DCNL DCSP _ print _ baremetal _ nodes _ list ( nodes )
DCSP options = { &apos; xatol &apos; : xtol , &apos; maxiter &apos; : maxfun , &apos; disp &apos; : disp } DCNL DCSP res = _ minimize _ scalar _ bounded ( func , ( x1 , x2 ) , args , * * options ) DCNL DCSP if full _ output : DCNL DCSP DCSP return ( res &#91; &apos; x &apos; &#93; , res &#91; &apos; fun &apos; &#93; , res &#91; &apos; status &apos; &#93; , res &#91; &apos; nfev &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP return res &#91; &apos; x &apos; &#93;
DCSP result = getattr ( instance , primary _ key _ for ( instance ) ) DCNL DCSP if ( not as _ string ) : DCNL DCSP DCSP return result DCNL DCSP try : DCNL DCSP DCSP return str ( result ) DCNL DCSP except UnicodeEncodeError : DCNL DCSP DCSP return url _ quote _ plus ( result.encode ( &apos; utf-8 &apos; ) )
DCSP expr = _ literal _ as _ binds ( expr ) DCNL DCSP return expr.between ( lower _ bound , upper _ bound )
DCSP import ctypes DCNL DCSP from ctypes import wintypes , windll DCNL DCSP CSIDL _ COMMON _ APPDATA = 35 DCNL DCSP _ SHGetFolderPath = windll.shell32.SHGetFolderPathW DCNL DCSP _ SHGetFolderPath.argtypes = &#91; wintypes.HWND , ctypes.c _ int , wintypes.HANDLE , wintypes.DWORD , wintypes.LPCWSTR &#93; DCNL DCSP path _ buf = wintypes.create _ unicode _ buffer ( wintypes.MAX _ PATH ) DCNL DCSP _ SHGetFolderPath ( 0 , CSIDL _ COMMON _ APPDATA , 0 , 0 , path _ buf ) DCNL DCSP return path _ buf.value
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP try : DCNL DCSP DCSP return conn.get _ all _ launch _ configurations ( ) DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.error ( e ) DCNL DCSP DCSP return &#91; &#93;
DCSP with tmpdir.as _ cwd ( ) : DCNL DCSP DCSP tmpdir.join ( &apos; config.yaml &apos; ) .write ( mocked _ aws _ cf _ simple ) DCNL DCSP DCSP assert ( main ( &#91; &apos; create &apos; &#93; ) = = 0 ) DCNL DCSP DCSP assert ( main ( &#91; &apos; create &apos; &#93; ) = = 1 )
DCSP steps = StepDict ( ) DCNL DCSP test _ load = ( lambda : steps.load ( &apos; an DCSP invalid DCSP regex ; ) &apos; , ( lambda : &apos; &apos; ) ) ) DCNL DCSP assert _ raises ( StepLoadingError , test _ load )
DCSP if ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; RedHat &apos; ) : DCNL DCSP DCSP if ( family = = &apos; ipv6 &apos; ) : DCNL DCSP DCSP DCSP return &apos; / etc / sysconfig / ip6tables &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; / etc / sysconfig / iptables &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; Arch &apos; ) : DCNL DCSP DCSP if ( family = = &apos; ipv6 &apos; ) : DCNL DCSP DCSP DCSP return &apos; / etc / iptables / ip6tables.rules &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; / etc / iptables / iptables.rules &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; Debian &apos; ) : DCNL DCSP DCSP if ( family = = &apos; ipv6 &apos; ) : DCNL DCSP DCSP DCSP return &apos; / etc / iptables / rules.v6 &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; / etc / iptables / rules.v4 &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os &apos; &#93; = = &apos; Gentoo &apos; ) : DCNL DCSP DCSP if ( family = = &apos; ipv6 &apos; ) : DCNL DCSP DCSP DCSP return &apos; / var / lib / ip6tables / rules-save &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; / var / lib / iptables / rules-save &apos; DCNL DCSP elif ( _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; = = &apos; SUSE &apos; ) : DCNL DCSP DCSP return &apos; / etc / sysconfig / scripts / SuSEfirewall2-custom &apos; DCNL DCSP else : DCNL DCSP DCSP raise SaltException ( ( ( &apos; Saving DCSP iptables DCSP to DCSP file DCSP is DCSP not &apos; + &apos; DCSP supported DCSP on DCSP { 0 } . &apos; .format ( _ _ grains _ _ &#91; &apos; os &apos; &#93; ) ) + &apos; DCSP Please DCSP file DCSP an DCSP issue DCSP with DCSP SaltStack &apos; ) )
DCSP nonlinearity = getattr ( layer , &apos; nonlinearity &apos; , None ) DCNL DCSP if ( nonlinearity is not None ) : DCNL DCSP DCSP layer.nonlinearity = nonlinearities.identity DCNL DCSP return ParametricRectifierLayer ( layer , * * kwargs )
DCSP test _ once = kwargs.get ( &apos; test _ once &apos; , False ) DCNL DCSP for arg in args : DCNL DCSP DCSP templates.update ( arg ) DCNL DCSP templates &#91; &apos; inclusion.html &apos; &#93; = &apos; { { DCSP result DCSP } } &apos; DCNL DCSP loaders = &#91; ( &apos; django.template.loaders.cached.Loader &apos; , &#91; ( &apos; django.template.loaders.locmem.Loader &apos; , templates ) &#93; ) &#93; DCNL DCSP def decorator ( func ) : DCNL DCSP DCSP @ override _ settings ( TEMPLATES = None ) DCNL DCSP DCSP @ functools.wraps ( func ) DCNL DCSP DCSP def inner ( self ) : DCNL DCSP DCSP DCSP libraries = getattr ( self , &apos; libraries &apos; , { } ) DCNL DCSP DCSP DCSP self.engine = Engine ( libraries = libraries , loaders = loaders ) DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP DCSP if test _ once : DCNL DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP DCSP self.engine = Engine ( libraries = libraries , loaders = loaders , string _ if _ invalid = &apos; INVALID &apos; ) DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP DCSP self.engine = Engine ( debug = True , libraries = libraries , loaders = loaders ) DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP DCSP func ( self ) DCNL DCSP DCSP return inner DCNL DCSP return decorator
DCSP if options &#91; &apos; basedirlist &apos; &#93; : DCNL DCSP DCSP return options &#91; &apos; basedirlist &apos; &#93; DCNL DCSP if os.environ.get ( &apos; MPLBASEDIRLIST &apos; ) : DCNL DCSP DCSP return os.environ.get ( &apos; MPLBASEDIRLIST &apos; ) .split ( os.pathsep ) DCNL DCSP win _ bases = &#91; &apos; win32 _ static &apos; &#93; DCNL DCSP if os.getenv ( &apos; CONDA _ DEFAULT _ ENV &apos; ) : DCNL DCSP DCSP win _ bases.append ( os.path.join ( os.getenv ( &apos; CONDA _ DEFAULT _ ENV &apos; ) , &apos; Library &apos; ) ) DCNL DCSP basedir _ map = { &apos; win32 &apos; : win _ bases , &apos; darwin &apos; : &#91; &apos; / usr / local / &apos; , &apos; / usr &apos; , &apos; / usr / X11 &apos; , &apos; / opt / X11 &apos; , &apos; / opt / local &apos; &#93; , &apos; sunos5 &apos; : &#91; ( os.getenv ( &apos; MPLIB _ BASE &apos; ) or &apos; / usr / local &apos; ) &#93; , &apos; gnu0 &apos; : &#91; &apos; / usr &apos; &#93; , &apos; aix5 &apos; : &#91; &apos; / usr / local &apos; &#93; } DCNL DCSP return basedir _ map.get ( sys.platform , &#91; &apos; / usr / local &apos; , &apos; / usr &apos; &#93; )
DCSP p = ( ( 50 - ( which / 2 ) ) , ( 50 + ( which / 2 ) ) ) DCNL DCSP return percentiles ( a , p , axis )
DCSP valid _ pairings = &#91; &apos; nearest &apos; , &apos; keep _ odd &apos; &#93; DCNL DCSP if ( pairing not in valid _ pairings ) : DCNL DCSP DCSP raise ValueError ( ( &apos; pairing DCSP must DCSP be DCSP one DCSP of DCSP % s , DCSP not DCSP % s &apos; % ( valid _ pairings , pairing ) ) ) DCNL DCSP if ( len ( z ) = = len ( p ) = = 0 ) : DCNL DCSP DCSP return array ( &#91; &#91; k , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 &#93; &#93; ) DCNL DCSP p = np.concatenate ( ( p , np.zeros ( max ( ( len ( z ) - len ( p ) ) , 0 ) ) ) ) DCNL DCSP z = np.concatenate ( ( z , np.zeros ( max ( ( len ( p ) - len ( z ) ) , 0 ) ) ) ) DCNL DCSP n _ sections = ( ( max ( len ( p ) , len ( z ) ) + 1 ) / / 2 ) DCNL DCSP sos = zeros ( ( n _ sections , 6 ) ) DCNL DCSP if ( ( ( len ( p ) % 2 ) = = 1 ) and ( pairing = = &apos; nearest &apos; ) ) : DCNL DCSP DCSP p = np.concatenate ( ( p , &#91; 0.0 &#93; ) ) DCNL DCSP DCSP z = np.concatenate ( ( z , &#91; 0.0 &#93; ) ) DCNL DCSP assert ( len ( p ) = = len ( z ) ) DCNL DCSP z = np.concatenate ( _ cplxreal ( z ) ) DCNL DCSP p = np.concatenate ( _ cplxreal ( p ) ) DCNL DCSP p _ sos = np.zeros ( ( n _ sections , 2 ) , np.complex128 ) DCNL DCSP z _ sos = np.zeros _ like ( p _ sos ) DCNL DCSP for si in range ( n _ sections ) : DCNL DCSP DCSP p1 _ idx = np.argmin ( np.abs ( ( 1 - np.abs ( p ) ) ) ) DCNL DCSP DCSP p1 = p &#91; p1 _ idx &#93; DCNL DCSP DCSP p = np.delete ( p , p1 _ idx ) DCNL DCSP DCSP if ( np.isreal ( p1 ) and ( np.isreal ( p ) .sum ( ) = = 0 ) ) : DCNL DCSP DCSP DCSP z1 _ idx = _ nearest _ real _ complex _ idx ( z , p1 , &apos; real &apos; ) DCNL DCSP DCSP DCSP z1 = z &#91; z1 _ idx &#93; DCNL DCSP DCSP DCSP z = np.delete ( z , z1 _ idx ) DCNL DCSP DCSP DCSP p2 = z2 = 0 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( ( not np.isreal ( p1 ) ) and ( np.isreal ( z ) .sum ( ) = = 1 ) ) : DCNL DCSP DCSP DCSP DCSP z1 _ idx = _ nearest _ real _ complex _ idx ( z , p1 , &apos; complex &apos; ) DCNL DCSP DCSP DCSP DCSP assert ( not np.isreal ( z &#91; z1 _ idx &#93; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP z1 _ idx = np.argmin ( np.abs ( ( p1 - z ) ) ) DCNL DCSP DCSP DCSP z1 = z &#91; z1 _ idx &#93; DCNL DCSP DCSP DCSP z = np.delete ( z , z1 _ idx ) DCNL DCSP DCSP DCSP if ( not np.isreal ( p1 ) ) : DCNL DCSP DCSP DCSP DCSP if ( not np.isreal ( z1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP p2 = p1.conj ( ) DCNL DCSP DCSP DCSP DCSP DCSP z2 = z1.conj ( ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP p2 = p1.conj ( ) DCNL DCSP DCSP DCSP DCSP DCSP z2 _ idx = _ nearest _ real _ complex _ idx ( z , p1 , &apos; real &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP z2 = z &#91; z2 _ idx &#93; DCNL DCSP DCSP DCSP DCSP DCSP assert np.isreal ( z2 ) DCNL DCSP DCSP DCSP DCSP DCSP z = np.delete ( z , z2 _ idx ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( not np.isreal ( z1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP z2 = z1.conj ( ) DCNL DCSP DCSP DCSP DCSP DCSP p2 _ idx = _ nearest _ real _ complex _ idx ( p , z1 , &apos; real &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP p2 = p &#91; p2 _ idx &#93; DCNL DCSP DCSP DCSP DCSP DCSP assert np.isreal ( p2 ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP idx = np.where ( np.isreal ( p ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP DCSP assert ( len ( idx ) &gt; 0 ) DCNL DCSP DCSP DCSP DCSP DCSP p2 _ idx = idx &#91; np.argmin ( np.abs ( ( np.abs ( p &#91; idx &#93; ) - 1 ) ) ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP p2 = p &#91; p2 _ idx &#93; DCNL DCSP DCSP DCSP DCSP DCSP assert np.isreal ( p2 ) DCNL DCSP DCSP DCSP DCSP DCSP z2 _ idx = _ nearest _ real _ complex _ idx ( z , p2 , &apos; real &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP z2 = z &#91; z2 _ idx &#93; DCNL DCSP DCSP DCSP DCSP DCSP assert np.isreal ( z2 ) DCNL DCSP DCSP DCSP DCSP DCSP z = np.delete ( z , z2 _ idx ) DCNL DCSP DCSP DCSP DCSP p = np.delete ( p , p2 _ idx ) DCNL DCSP DCSP p _ sos &#91; si &#93; = &#91; p1 , p2 &#93; DCNL DCSP DCSP z _ sos &#91; si &#93; = &#91; z1 , z2 &#93; DCNL DCSP assert ( len ( p ) = = len ( z ) = = 0 ) DCNL DCSP del p , z DCNL DCSP p _ sos = np.reshape ( p _ sos &#91; : : ( -1 ) &#93; , ( n _ sections , 2 ) ) DCNL DCSP z _ sos = np.reshape ( z _ sos &#91; : : ( -1 ) &#93; , ( n _ sections , 2 ) ) DCNL DCSP gains = np.ones ( n _ sections ) DCNL DCSP gains &#91; 0 &#93; = k DCNL DCSP for si in range ( n _ sections ) : DCNL DCSP DCSP x = zpk2tf ( z _ sos &#91; si &#93; , p _ sos &#91; si &#93; , gains &#91; si &#93; ) DCNL DCSP DCSP sos &#91; si &#93; = np.concatenate ( x ) DCNL DCSP return sos
DCSP with pytest.raises ( falcon.http _ status.HTTPStatus ) as redirect : DCNL DCSP DCSP hug.redirect.to ( &apos; / &apos; ) DCNL DCSP assert ( &apos; 302 &apos; in redirect.value.status )
DCSP jid _ dir = salt.utils.jid.jid _ dir ( jid , _ job _ dir ( ) , _ _ opts _ _ &#91; &apos; hash _ type &apos; &#93; ) DCNL DCSP load _ fn = os.path.join ( jid _ dir , LOAD _ P ) DCNL DCSP if ( ( not os.path.exists ( jid _ dir ) ) or ( not os.path.exists ( load _ fn ) ) ) : DCNL DCSP DCSP return { } DCNL DCSP serial = salt.payload.Serial ( _ _ opts _ _ ) DCNL DCSP ret = serial.load ( salt.utils.fopen ( os.path.join ( jid _ dir , LOAD _ P ) , &apos; rb &apos; ) ) DCNL DCSP minions _ cache = &#91; os.path.join ( jid _ dir , MINIONS _ P ) &#93; DCNL DCSP minions _ cache.extend ( glob.glob ( os.path.join ( jid _ dir , SYNDIC _ MINIONS _ P.format ( &apos; * &apos; ) ) ) ) DCNL DCSP all _ minions = set ( ) DCNL DCSP for minions _ path in minions _ cache : DCNL DCSP DCSP log.debug ( &apos; Reading DCSP minion DCSP list DCSP from DCSP % s &apos; , minions _ path ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP all _ minions.update ( serial.load ( salt.utils.fopen ( minions _ path , &apos; rb &apos; ) ) ) DCNL DCSP DCSP except IOError as exc : DCNL DCSP DCSP DCSP salt.utils.files.process _ read _ exception ( exc , minions _ path ) DCNL DCSP if all _ minions : DCNL DCSP DCSP ret &#91; &apos; Minions &apos; &#93; = sorted ( all _ minions ) DCNL DCSP return ret
DCSP scenario _ collector = FeatureScenarioLocationCollector ( ) DCNL DCSP features = &#91; &#93; DCNL DCSP for location in feature _ files : DCNL DCSP DCSP if ( not isinstance ( location , FileLocation ) ) : DCNL DCSP DCSP DCSP assert isinstance ( location , string _ types ) DCNL DCSP DCSP DCSP location = FileLocation ( os.path.normpath ( location ) ) DCNL DCSP DCSP if ( location.filename = = scenario _ collector.filename ) : DCNL DCSP DCSP DCSP scenario _ collector.add _ location ( location ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif scenario _ collector.feature : DCNL DCSP DCSP DCSP current _ feature = scenario _ collector.build _ feature ( ) DCNL DCSP DCSP DCSP features.append ( current _ feature ) DCNL DCSP DCSP DCSP scenario _ collector.clear ( ) DCNL DCSP DCSP assert isinstance ( location , FileLocation ) DCNL DCSP DCSP filename = os.path.abspath ( location.filename ) DCNL DCSP DCSP feature = parser.parse _ file ( filename , language = language ) DCNL DCSP DCSP if feature : DCNL DCSP DCSP DCSP scenario _ collector.feature = feature DCNL DCSP DCSP DCSP scenario _ collector.add _ location ( location ) DCNL DCSP if scenario _ collector.feature : DCNL DCSP DCSP current _ feature = scenario _ collector.build _ feature ( ) DCNL DCSP DCSP features.append ( current _ feature ) DCNL DCSP return features
DCSP session = db.get _ session ( ) DCNL DCSP try : DCNL DCSP DCSP cred = session.query ( l2network _ models.Credential ) .filter _ by ( tenant _ id = tenant _ id ) .filter _ by ( credential _ id = credential _ id ) .one ( ) DCNL DCSP DCSP return cred DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP raise c _ exc.CredentialNotFound ( credential _ id = credential _ id , tenant _ id = tenant _ id )
DCSP course _ key = CourseLocator.from _ string ( course _ key ) DCNL DCSP for ccx in CustomCourseForEdX.objects.filter ( course _ id = course _ key ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ccx _ key = CCXLocator.from _ course _ locator ( course _ key , unicode ( ccx.id ) ) DCNL DCSP DCSP except InvalidKeyError : DCNL DCSP DCSP DCSP log.info ( &apos; Attempt DCSP to DCSP publish DCSP course DCSP with DCSP deprecated DCSP id . DCSP Course : DCSP % s . DCSP CCX : DCSP % s &apos; , course _ key , ccx.id ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP responses = SignalHandler.course _ published.send ( sender = ccx , course _ key = ccx _ key ) DCNL DCSP DCSP for ( rec , response ) in responses : DCNL DCSP DCSP DCSP log.info ( &apos; Signal DCSP fired DCSP when DCSP course DCSP is DCSP published . DCSP Receiver : DCSP % s . DCSP Response : DCSP % s &apos; , rec , response )
DCSP return InverseHankelTransform ( F , k , r , nu ) .doit ( * * hints )
DCSP try : DCNL DCSP DCSP iter ( obj ) DCNL DCSP except TypeError : DCNL DCSP DCSP return False DCNL DCSP return True
DCSP a _ sum = a.sum ( axis ) DCNL DCSP if ( axis and ( a.ndim &gt; 1 ) ) : DCNL DCSP DCSP a _ sum &#91; ( a _ sum = = 0 ) &#93; = 1 DCNL DCSP DCSP shape = list ( a.shape ) DCNL DCSP DCSP shape &#91; axis &#93; = 1 DCNL DCSP DCSP a _ sum.shape = shape DCNL DCSP a / = a _ sum
DCSP description = &#91; &apos; adjacencylist &apos; , &apos; Krackhardt DCSP Kite DCSP Social DCSP Network &apos; , 10 , &#91; &#91; 2 , 3 , 4 , 6 &#93; , &#91; 1 , 4 , 5 , 7 &#93; , &#91; 1 , 4 , 6 &#93; , &#91; 1 , 2 , 3 , 5 , 6 , 7 &#93; , &#91; 2 , 4 , 7 &#93; , &#91; 1 , 3 , 4 , 7 , 8 &#93; , &#91; 2 , 4 , 5 , 6 , 8 &#93; , &#91; 6 , 7 , 9 &#93; , &#91; 8 , 10 &#93; , &#91; 9 &#93; &#93; &#93; DCNL DCSP G = make _ small _ undirected _ graph ( description , create _ using ) DCNL DCSP return G
DCSP serv = _ get _ serv ( ret = None ) DCNL DCSP if ( &apos; influxdb08 &apos; in serv . _ _ module _ _ ) : DCNL DCSP DCSP req = &#91; { &apos; name &apos; : &apos; jids &apos; , &apos; columns &apos; : &#91; &apos; jid &apos; , &apos; load &apos; &#93; , &apos; points &apos; : &#91; &#91; jid , json.dumps ( load ) &#93; &#93; } &#93; DCNL DCSP else : DCNL DCSP DCSP req = &#91; { &apos; measurement &apos; : &apos; jids &apos; , &apos; tags &apos; : { &apos; jid &apos; : jid } , &apos; fields &apos; : { &apos; load &apos; : json.dumps ( load ) } } &#93; DCNL DCSP try : DCNL DCSP DCSP serv.write _ points ( req ) DCNL DCSP except Exception as ex : DCNL DCSP DCSP log.critical ( &apos; Failed DCSP to DCSP store DCSP load DCSP with DCSP InfluxDB DCSP returner : DCSP { 0 } &apos; .format ( ex ) )
DCSP euid = os.geteuid ( ) DCNL DCSP if ( str ( user _ id _ or _ name ) = = str ( euid ) ) : DCNL DCSP DCSP return True DCNL DCSP effective _ user _ name = pwd.getpwuid ( euid ) .pw _ name DCNL DCSP return ( user _ id _ or _ name = = effective _ user _ name )
DCSP if ( s in wordmap ) : DCNL DCSP DCSP return s DCNL DCSP else : DCNL DCSP DCSP possibilities = &#91; word for word in wordmap.keys ( ) if word.startswith ( s ) &#93; DCNL DCSP DCSP if ( len ( possibilities ) = = 1 ) : DCNL DCSP DCSP DCSP return possibilities &#91; 0 &#93; DCNL DCSP DCSP elif ( not possibilities ) : DCNL DCSP DCSP DCSP raise BadOptionError ( s ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP possibilities.sort ( ) DCNL DCSP DCSP DCSP raise AmbiguousOptionError ( s , possibilities )
DCSP if ( key _ func is not None ) : DCNL DCSP DCSP if callable ( key _ func ) : DCNL DCSP DCSP DCSP return key _ func DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( key _ func _ module _ path , key _ func _ name ) = key _ func.rsplit ( u &apos; . &apos; , 1 ) DCNL DCSP DCSP DCSP key _ func _ module = import _ module ( key _ func _ module _ path ) DCNL DCSP DCSP DCSP return getattr ( key _ func _ module , key _ func _ name ) DCNL DCSP return default _ key _ func
DCSP default = { &apos; weight &apos; : 0.0 , &apos; count &apos; : 0 } DCNL DCSP count _ src = graph &#91; src &#93; .get ( n , default ) &#91; &apos; count &apos; &#93; DCNL DCSP count _ dst = graph &#91; dst &#93; .get ( n , default ) &#91; &apos; count &apos; &#93; DCNL DCSP weight _ src = graph &#91; src &#93; .get ( n , default ) &#91; &apos; weight &apos; &#93; DCNL DCSP weight _ dst = graph &#91; dst &#93; .get ( n , default ) &#91; &apos; weight &apos; &#93; DCNL DCSP count = ( count _ src + count _ dst ) DCNL DCSP return { &apos; count &apos; : count , &apos; weight &apos; : ( ( ( count _ src * weight _ src ) + ( count _ dst * weight _ dst ) ) / count ) }
DCSP if _ use _ unicode : DCNL DCSP DCSP return unicode ( * args ) DCNL DCSP else : DCNL DCSP DCSP return str ( * args )
DCSP ver = container.opf _ version _ parsed DCNL DCSP if move _ to _ start : DCNL DCSP DCSP for ( item , q , linear ) in container.spine _ iter : DCNL DCSP DCSP DCSP if ( name = = q ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP if ( not linear ) : DCNL DCSP DCSP DCSP item.set ( u &apos;linear &apos; , u &apos;yes &apos; ) DCNL DCSP DCSP if ( item.getparent ( ) .index ( item ) &gt; 0 ) : DCNL DCSP DCSP DCSP container.insert _ into _ xml ( item.getparent ( ) , item , 0 ) DCNL DCSP if ( ver.major &lt; 3 ) : DCNL DCSP DCSP for ref in container.opf _ xpath ( u &apos; / / opf : guide / opf : reference &#91; @ type = &quot; cover &quot; &#93; &apos; ) : DCNL DCSP DCSP DCSP ref.getparent ( ) .remove ( ref ) DCNL DCSP DCSP for guide in get _ guides ( container ) : DCNL DCSP DCSP DCSP container.insert _ into _ xml ( guide , guide.makeelement ( OPF ( u &apos;reference &apos; ) , type = u &apos;cover &apos; , href = container.name _ to _ href ( name , container.opf _ name ) ) ) DCNL DCSP else : DCNL DCSP DCSP container.apply _ unique _ properties ( name , u &apos;calibre : title-page &apos; ) DCNL DCSP container.dirty ( container.opf _ name )
DCSP sys.settrace ( Spew ( trace _ names , show _ values ) )
DCSP return BatchDet ( ) ( a )
DCSP d = dict ( user = request.user , * * kwargs ) DCNL DCSP d.update ( csrf ( request ) ) DCNL DCSP return RequestContext ( request , d )
DCSP start = ( start or 0 ) DCNL DCSP end = ( ( end or total ) - 1 ) DCNL DCSP return ( &apos; bytes DCSP % s- % s / % s &apos; % ( start , end , total ) )
DCSP assert css _ file.endswith ( &apos; .css &apos; ) DCNL DCSP new _ css = css _ file DCNL DCSP app _ globals.main _ css = str ( new _ css )
DCSP for point in loop : DCNL DCSP DCSP if ( point in pointTable ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP for k in range ( ( u &#91; &apos; nterms &apos; &#93; - 1 ) ) : DCNL DCSP DCSP k1 = ( k + 1 ) DCNL DCSP DCSP mu1n = np.power ( mu &#91; 0 &#93; , k1 ) DCNL DCSP DCSP u &#91; &apos; y &apos; &#93; &#91; k &#93; = ( u &#91; &apos; w &apos; &#93; &#91; k &#93; * ( u &#91; &apos; fn &apos; &#93; &#91; k1 &#93; - ( mu1n * u &#91; &apos; fn &apos; &#93; &#91; 0 &#93; ) ) ) DCNL DCSP DCSP for p in range ( ( u &#91; &apos; nfit &apos; &#93; - 1 ) ) : DCNL DCSP DCSP DCSP u &#91; &apos; M &apos; &#93; &#91; k &#93; &#91; p &#93; = ( u &#91; &apos; w &apos; &#93; &#91; k &#93; * ( np.power ( mu &#91; ( p + 1 ) &#93; , k1 ) - mu1n ) )
DCSP tempdir = _ TempDir ( ) DCNL DCSP ave = read _ evokeds ( fname , 0 ) DCNL DCSP write _ evokeds ( op.join ( tempdir , &apos; evoked-ave.fif &apos; ) , ave ) DCNL DCSP ave2 = read _ evokeds ( op.join ( tempdir , &apos; evoked-ave.fif &apos; ) ) &#91; 0 &#93; DCNL DCSP assert _ true ( np.allclose ( ave.data , ave2.data , atol = 1e-16 , rtol = 0.001 ) ) DCNL DCSP assert _ array _ almost _ equal ( ave.times , ave2.times ) DCNL DCSP assert _ equal ( ave.nave , ave2.nave ) DCNL DCSP assert _ equal ( ave . _ aspect _ kind , ave2 . _ aspect _ kind ) DCNL DCSP assert _ equal ( ave.kind , ave2.kind ) DCNL DCSP assert _ equal ( ave.last , ave2.last ) DCNL DCSP assert _ equal ( ave.first , ave2.first ) DCNL DCSP assert _ true ( repr ( ave ) ) DCNL DCSP ave2 = read _ evokeds ( fname _ gz , 0 ) DCNL DCSP assert _ true ( np.allclose ( ave.data , ave2.data , atol = 1e-16 , rtol = 1e-08 ) ) DCNL DCSP condition = &apos; Left DCSP Auditory &apos; DCNL DCSP assert _ raises ( ValueError , read _ evokeds , fname , condition , kind = &apos; stderr &apos; ) DCNL DCSP assert _ raises ( ValueError , read _ evokeds , fname , condition , kind = &apos; standard _ error &apos; ) DCNL DCSP ave3 = read _ evokeds ( fname , condition ) DCNL DCSP assert _ array _ almost _ equal ( ave.data , ave3.data , 19 ) DCNL DCSP aves1 = read _ evokeds ( fname ) &#91; 1 : : 2 &#93; DCNL DCSP aves2 = read _ evokeds ( fname , &#91; 1 , 3 &#93; ) DCNL DCSP aves3 = read _ evokeds ( fname , &#91; &apos; Right DCSP Auditory &apos; , &apos; Right DCSP visual &apos; &#93; ) DCNL DCSP write _ evokeds ( op.join ( tempdir , &apos; evoked-ave.fif &apos; ) , aves1 ) DCNL DCSP aves4 = read _ evokeds ( op.join ( tempdir , &apos; evoked-ave.fif &apos; ) ) DCNL DCSP for aves in &#91; aves2 , aves3 , aves4 &#93; : DCNL DCSP DCSP for &#91; av1 , av2 &#93; in zip ( aves1 , aves ) : DCNL DCSP DCSP DCSP assert _ array _ almost _ equal ( av1.data , av2.data ) DCNL DCSP DCSP DCSP assert _ array _ almost _ equal ( av1.times , av2.times ) DCNL DCSP DCSP DCSP assert _ equal ( av1.nave , av2.nave ) DCNL DCSP DCSP DCSP assert _ equal ( av1.kind , av2.kind ) DCNL DCSP DCSP DCSP assert _ equal ( av1 . _ aspect _ kind , av2 . _ aspect _ kind ) DCNL DCSP DCSP DCSP assert _ equal ( av1.last , av2.last ) DCNL DCSP DCSP DCSP assert _ equal ( av1.first , av2.first ) DCNL DCSP DCSP DCSP assert _ equal ( av1.comment , av2.comment ) DCNL DCSP fname2 = op.join ( tempdir , &apos; test-bad-name.fif &apos; ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP warnings.simplefilter ( &apos; always &apos; ) DCNL DCSP DCSP write _ evokeds ( fname2 , ave ) DCNL DCSP DCSP read _ evokeds ( fname2 ) DCNL DCSP assert _ naming ( w , &apos; test _ evoked.py &apos; , 2 ) DCNL DCSP assert _ raises ( TypeError , Evoked , fname ) DCNL DCSP fname _ ms = op.join ( tempdir , &apos; test-ave.fif &apos; ) DCNL DCSP assert _ true ( ( ave.info &#91; &apos; maxshield &apos; &#93; is False ) ) DCNL DCSP ave.info &#91; &apos; maxshield &apos; &#93; = True DCNL DCSP ave.save ( fname _ ms ) DCNL DCSP assert _ raises ( ValueError , read _ evokeds , fname _ ms ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP aves = read _ evokeds ( fname _ ms , allow _ maxshield = True ) DCNL DCSP assert _ true ( all ( ( ( &apos; Elekta &apos; in str ( ww.message ) ) for ww in w ) ) ) DCNL DCSP assert _ true ( all ( ( ( ave.info &#91; &apos; maxshield &apos; &#93; is True ) for ave in aves ) ) ) DCNL DCSP with warnings.catch _ warnings ( record = True ) as w : DCNL DCSP DCSP aves = read _ evokeds ( fname _ ms , allow _ maxshield = &apos; yes &apos; ) DCNL DCSP assert _ equal ( len ( w ) , 0 ) DCNL DCSP assert _ true ( all ( ( ( ave.info &#91; &apos; maxshield &apos; &#93; is True ) for ave in aves ) ) )
DCSP beam = beam _ area.to ( si.sr ) .value DCNL DCSP nu = disp.to ( si.GHz , spectral ( ) ) DCNL DCSP def convert _ Jy _ to _ K ( x _ jybm ) : DCNL DCSP DCSP factor = ( ( ( ( 2 * _ si.k _ B ) * si.K ) * ( nu * * 2 ) ) / ( _ si.c * * 2 ) ) .to ( astrophys.Jy ) .value DCNL DCSP DCSP return ( ( x _ jybm / beam ) / factor ) DCNL DCSP def convert _ K _ to _ Jy ( x _ K ) : DCNL DCSP DCSP factor = ( astrophys.Jy / ( ( ( 2 * _ si.k _ B ) * ( nu * * 2 ) ) / ( _ si.c * * 2 ) ) ) .to ( si.K ) .value DCNL DCSP DCSP return ( ( x _ K * beam ) / factor ) DCNL DCSP return &#91; ( astrophys.Jy , si.K , convert _ Jy _ to _ K , convert _ K _ to _ Jy ) &#93;
DCSP dt = connection.introspection.get _ field _ type ( dbtype , description ) DCNL DCSP if ( type ( dt ) is tuple ) : DCNL DCSP DCSP return dt &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP return dt
DCSP yaml _ content = None DCNL DCSP assets _ list = &#91; &#93; DCNL DCSP dir _ path _ array = dir _ path.split ( &apos; / &apos; ) DCNL DCSP while ( dir _ path _ array &#91; ( -1 ) &#93; = = &apos; &apos; ) : DCNL DCSP DCSP dir _ path _ array = dir _ path _ array &#91; : ( -1 ) &#93; DCNL DCSP dir _ path _ length = len ( dir _ path _ array ) DCNL DCSP for ( root , dirs , files ) in os.walk ( dir _ path ) : DCNL DCSP DCSP for directory in dirs : DCNL DCSP DCSP DCSP if ( ( root = = dir _ path ) and ( directory ! = &apos; assets &apos; ) ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( ( &apos; The DCSP only DCSP directory DCSP in DCSP % s DCSP should DCSP be DCSP assets / &apos; % dir _ path ) ) DCNL DCSP DCSP for filename in files : DCNL DCSP DCSP DCSP filepath = os.path.join ( root , filename ) DCNL DCSP DCSP DCSP if ( root = = dir _ path ) : DCNL DCSP DCSP DCSP DCSP if filepath.endswith ( &apos; .DS _ Store &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP if ( yaml _ content is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP raise Exception ( ( &apos; More DCSP than DCSP one DCSP non-asset DCSP file DCSP specified DCSP for DCSP % s &apos; % dir _ path ) ) DCNL DCSP DCSP DCSP DCSP elif ( not filepath.endswith ( &apos; .yaml &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise Exception ( ( &apos; Found DCSP invalid DCSP non-asset DCSP file DCSP % s . DCSP There DCSP should DCSP only DCSP be DCSP a DCSP single DCSP non-asset DCSP file , DCSP and DCSP it DCSP should DCSP have DCSP a DCSP .yaml DCSP suffix . &apos; % filepath ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP yaml _ content = get _ file _ contents ( filepath ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP filepath _ array = filepath.split ( &apos; / &apos; ) DCNL DCSP DCSP DCSP DCSP filename = &apos; / &apos; .join ( filepath _ array &#91; ( dir _ path _ length + 1 ) : &#93; ) DCNL DCSP DCSP DCSP DCSP assets _ list.append ( ( filename , get _ file _ contents ( filepath , raw _ bytes = True ) ) ) DCNL DCSP if ( yaml _ content is None ) : DCNL DCSP DCSP raise Exception ( ( &apos; No DCSP yaml DCSP file DCSP specifed DCSP for DCSP % s &apos; % dir _ path ) ) DCNL DCSP return ( yaml _ content , assets _ list )
DCSP from scipy.optimize import fmin _ cobyla DCNL DCSP ( parallel , p _ fun , _ ) = parallel _ func ( fun , n _ jobs ) DCNL DCSP res = parallel ( ( p _ fun ( min _ dist _ to _ inner _ skull , B , t , guess _ rrs , guess _ data , fwd _ data , whitener , proj _ op , fmin _ cobyla , ori ) for ( B , t ) in zip ( data.T , times ) ) ) DCNL DCSP pos = np.array ( &#91; r &#91; 0 &#93; for r in res &#93; ) DCNL DCSP amp = np.array ( &#91; r &#91; 1 &#93; for r in res &#93; ) DCNL DCSP ori = np.array ( &#91; r &#91; 2 &#93; for r in res &#93; ) DCNL DCSP gof = ( np.array ( &#91; r &#91; 3 &#93; for r in res &#93; ) * 100 ) DCNL DCSP residual = np.array ( &#91; r &#91; 4 &#93; for r in res &#93; ) .T DCNL DCSP return ( pos , amp , ori , gof , residual )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP log.error ( &apos; The DCSP copy _ snapshot DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP DCSP return False DCNL DCSP if ( &apos; source _ region &apos; not in kwargs ) : DCNL DCSP DCSP log.error ( &apos; A DCSP source _ region DCSP must DCSP be DCSP specified DCSP to DCSP copy DCSP a DCSP snapshot . &apos; ) DCNL DCSP DCSP return False DCNL DCSP if ( &apos; source _ snapshot _ id &apos; not in kwargs ) : DCNL DCSP DCSP log.error ( &apos; A DCSP source _ snapshot _ id DCSP must DCSP be DCSP specified DCSP to DCSP copy DCSP a DCSP snapshot . &apos; ) DCNL DCSP DCSP return False DCNL DCSP if ( &apos; description &apos; not in kwargs ) : DCNL DCSP DCSP kwargs &#91; &apos; description &apos; &#93; = &apos; &apos; DCNL DCSP params = { &apos; Action &apos; : &apos; CopySnapshot &apos; } DCNL DCSP if ( &apos; source _ region &apos; in kwargs ) : DCNL DCSP DCSP params &#91; &apos; SourceRegion &apos; &#93; = kwargs &#91; &apos; source _ region &apos; &#93; DCNL DCSP if ( &apos; source _ snapshot _ id &apos; in kwargs ) : DCNL DCSP DCSP params &#91; &apos; SourceSnapshotId &apos; &#93; = kwargs &#91; &apos; source _ snapshot _ id &apos; &#93; DCNL DCSP if ( &apos; description &apos; in kwargs ) : DCNL DCSP DCSP params &#91; &apos; Description &apos; &#93; = kwargs &#91; &apos; description &apos; &#93; DCNL DCSP log.debug ( params ) DCNL DCSP data = aws.query ( params , return _ url = True , location = get _ location ( ) , provider = get _ provider ( ) , opts = _ _ opts _ _ , sigver = &apos; 4&apos; ) DCNL DCSP return data
DCSP if ( ( &apos; tempest / scenario / &apos; in filename ) and ( &apos; / test _ &apos; in filename ) ) : DCNL DCSP DCSP if TEST _ DEFINITION.match ( physical _ line ) : DCNL DCSP DCSP DCSP if ( not SCENARIO _ DECORATOR.match ( previous _ logical ) ) : DCNL DCSP DCSP DCSP DCSP return ( physical _ line.find ( &apos; def &apos; ) , &apos; T104 : DCSP Scenario DCSP tests DCSP require DCSP a DCSP service DCSP decorator &apos; )
DCSP return isinstance ( object , ( type , types.ClassType ) )
DCSP if ( settings.USER _ LOG _ MAX _ RECORDS _ PER _ USER and kwargs &#91; &apos; created &apos; &#93; ) : DCNL DCSP DCSP current _ models = UserLog.objects.filter ( user = kwargs &#91; &apos; instance &apos; &#93; .user , activity _ type = kwargs &#91; &apos; instance &apos; &#93; .activity _ type ) DCNL DCSP DCSP if ( current _ models.count ( ) &gt; settings.USER _ LOG _ MAX _ RECORDS _ PER _ USER ) : DCNL DCSP DCSP DCSP to _ discard = current _ models.order _ by ( &apos; start _ datetime &apos; ) &#91; 0 : ( current _ models.count ( ) - settings.USER _ LOG _ MAX _ RECORDS _ PER _ USER ) &#93; DCNL DCSP DCSP DCSP UserLog.objects.filter ( pk _ _ in = to _ discard ) .delete ( )
DCSP with zipfile.ZipFile ( jar _ path ) as jar : DCNL DCSP DCSP for name in jar.namelist ( ) : DCNL DCSP DCSP DCSP ( yield ( name , jar.read ( name ) ) )
DCSP if ( palette is not None ) : DCNL DCSP DCSP kwargs &#91; &apos; palette &apos; &#93; = palette DCNL DCSP kwargs &#91; &apos; columns &apos; &#93; = columns DCNL DCSP kwargs &#91; &apos; bin &apos; &#93; = bin DCNL DCSP return ColorAttr ( * * kwargs )
DCSP if ( imp is None ) : DCNL DCSP DCSP imp = importlib.import _ module DCNL DCSP with cwd _ in _ path ( ) : DCNL DCSP DCSP return imp ( module , package = package )
DCSP profile = Profile.objects.get _ or _ create ( user = request.user ) &#91; 0 &#93; DCNL DCSP if ( profile.extra _ data is None ) : DCNL DCSP DCSP profile.extra _ data = { } DCNL DCSP DCSP profile.save ( update _ fields = ( u &apos;extra _ data &apos; , ) ) DCNL DCSP profile _ data = profile.extra _ data DCNL DCSP selected _ primary _ widgets = &#91; &#93; DCNL DCSP unselected _ primary _ widgets = &#91; &#93; DCNL DCSP primary _ widget _ selections = profile _ data.get ( u &apos;primary _ widget _ selections &apos; ) DCNL DCSP if primary _ widget _ selections : DCNL DCSP DCSP for p in primary _ widgets : DCNL DCSP DCSP DCSP if ( primary _ widget _ selections &#91; p.widget _ id &#93; = = u &apos; 1 &apos; ) : DCNL DCSP DCSP DCSP DCSP selected _ primary _ widgets.append ( p ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP unselected _ primary _ widgets.append ( p ) DCNL DCSP else : DCNL DCSP DCSP selected _ primary _ widgets = primary _ widgets DCNL DCSP DCSP unselected _ primary _ widgets = None DCNL DCSP selected _ secondary _ widgets = &#91; &#93; DCNL DCSP unselected _ secondary _ widgets = &#91; &#93; DCNL DCSP secondary _ widget _ selections = profile _ data.get ( u &apos;secondary _ widget _ selections &apos; ) DCNL DCSP if secondary _ widget _ selections : DCNL DCSP DCSP for s in secondary _ widgets : DCNL DCSP DCSP DCSP if ( secondary _ widget _ selections &#91; s.widget _ id &#93; = = u &apos; 1 &apos; ) : DCNL DCSP DCSP DCSP DCSP selected _ secondary _ widgets.append ( s ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP unselected _ secondary _ widgets.append ( s ) DCNL DCSP else : DCNL DCSP DCSP selected _ secondary _ widgets = secondary _ widgets DCNL DCSP DCSP unselected _ secondary _ widgets = None DCNL DCSP primary _ widget _ positions = profile _ data.get ( u &apos;primary _ widget _ positions &apos; ) DCNL DCSP if primary _ widget _ positions : DCNL DCSP DCSP sorted _ primary _ widgets = sorted ( selected _ primary _ widgets , key = ( lambda y : ( primary _ widget _ positions &#91; y.widget _ id &#93; or len ( primary _ widget _ positions ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP sorted _ primary _ widgets = selected _ primary _ widgets DCNL DCSP secondary _ widget _ positions = profile _ data.get ( u &apos;secondary _ widget _ positions &apos; ) DCNL DCSP if secondary _ widget _ positions : DCNL DCSP DCSP sorted _ secondary _ widgets = sorted ( selected _ secondary _ widgets , key = ( lambda y : ( secondary _ widget _ positions &#91; y.widget _ id &#93; or len ( secondary _ widget _ positions ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP sorted _ secondary _ widgets = selected _ secondary _ widgets DCNL DCSP return render _ to _ response ( template _ name , RequestContext ( request , { u &apos;primary _ widgets &apos; : primary _ widgets , u &apos;root _ path &apos; : ( settings.SITE _ ROOT + u &apos;admin / db / &apos; ) , u &apos;secondary _ widgets &apos; : secondary _ widgets , u &apos;selected _ primary _ widgets &apos; : sorted _ primary _ widgets , u &apos;selected _ secondary _ widgets &apos; : sorted _ secondary _ widgets , u &apos;support _ data &apos; : serialize _ support _ data ( request , True ) , u &apos;title &apos; : _ ( u &apos;Admin DCSP Dashboard &apos; ) , u &apos;unselected _ primary _ widgets &apos; : unselected _ primary _ widgets , u &apos;unselected _ secondary _ widgets &apos; : unselected _ secondary _ widgets } ) )
DCSP getvalue = None DCNL DCSP if ( stream is None ) : DCNL DCSP DCSP if ( encoding is None ) : DCNL DCSP DCSP DCSP from StringIO import StringIO DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP from cStringIO import StringIO DCNL DCSP DCSP stream = StringIO ( ) DCNL DCSP DCSP getvalue = stream.getvalue DCNL DCSP dumper = Dumper ( stream , default _ style = default _ style , default _ flow _ style = default _ flow _ style , canonical = canonical , indent = indent , width = width , allow _ unicode = allow _ unicode , line _ break = line _ break , encoding = encoding , version = version , tags = tags , explicit _ start = explicit _ start , explicit _ end = explicit _ end ) DCNL DCSP dumper.open ( ) DCNL DCSP for data in documents : DCNL DCSP DCSP dumper.represent ( data ) DCNL DCSP dumper.close ( ) DCNL DCSP if getvalue : DCNL DCSP DCSP return getvalue ( )
DCSP if ( path1.source = = path2.source ) : DCNL DCSP DCSP if ( path1.source _ version _ num &gt; path2.source _ version _ num ) : DCNL DCSP DCSP DCSP return path1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return path2 DCNL DCSP return None
DCSP return pygraphviz _ layout ( G , prog = prog , root = root , args = args )
DCSP level _ tags = constants.DEFAULT _ TAGS.copy ( ) DCNL DCSP level _ tags.update ( getattr ( settings , &apos; MESSAGE _ TAGS &apos; , { } ) ) DCNL DCSP return level _ tags
DCSP bigquery _ client = bigquery.Client ( project = project ) DCNL DCSP dataset = bigquery _ client.dataset ( dataset _ name ) DCNL DCSP table = dataset.table ( table _ name ) DCNL DCSP if ( not table.exists ( ) ) : DCNL DCSP DCSP print &apos; Table DCSP { } : { } DCSP does DCSP not DCSP exist . &apos; .format ( dataset _ name , table _ name ) DCNL DCSP DCSP return DCNL DCSP table.reload ( ) DCNL DCSP rows = list ( table.fetch _ data ( max _ results = 25 ) ) DCNL DCSP format _ string = ( &apos; { ! s : &lt; 16 } DCSP &apos; * len ( table.schema ) ) DCNL DCSP field _ names = &#91; field.name for field in table.schema &#93; DCNL DCSP print format _ string.format ( * field _ names ) DCNL DCSP for row in rows : DCNL DCSP DCSP print format _ string.format ( * row )
DCSP try : DCNL DCSP DCSP return next ( iter ( seq ) ) DCNL DCSP except StopIteration : DCNL DCSP DCSP return environment.undefined ( &apos; No DCSP first DCSP item , DCSP sequence DCSP was DCSP empty . &apos; )
DCSP if ( len ( sys.argv ) &gt; 1 ) : DCNL DCSP DCSP writeOutput ( &apos; DCSP &apos; .join ( sys.argv &#91; 1 : &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP settings.startMainLoopFromConstructor ( getNewRepository ( ) )
DCSP target = text.strip ( ) DCNL DCSP if ( not is _ valid ( target ) ) : DCNL DCSP DCSP return &quot; I DCSP can &apos;t DCSP attack DCSP that . &quot; DCNL DCSP if is _ self ( conn , target ) : DCNL DCSP DCSP target = nick DCNL DCSP message ( &apos; { } , DCSP { } &apos; .format ( target , random.choice ( flirts ) ) )
DCSP allow _ fragments = bool ( allow _ fragments ) DCNL DCSP key = ( url , scheme , allow _ fragments , type ( url ) , type ( scheme ) ) DCNL DCSP cached = _ parse _ cache.get ( key , None ) DCNL DCSP if cached : DCNL DCSP DCSP return cached DCNL DCSP if ( len ( _ parse _ cache ) &gt; = MAX _ CACHE _ SIZE ) : DCNL DCSP DCSP clear _ cache ( ) DCNL DCSP netloc = query = fragment = &apos; &apos; DCNL DCSP i = url.find ( &apos; : &apos; ) DCNL DCSP if ( i &gt; 0 ) : DCNL DCSP DCSP if ( url &#91; : i &#93; = = &apos; http &apos; ) : DCNL DCSP DCSP DCSP scheme = url &#91; : i &#93; .lower ( ) DCNL DCSP DCSP DCSP url = url &#91; ( i + 1 ) : &#93; DCNL DCSP DCSP DCSP if ( url &#91; : 2 &#93; = = &apos; / / &apos; ) : DCNL DCSP DCSP DCSP DCSP ( netloc , url ) = _ splitnetloc ( url , 2 ) DCNL DCSP DCSP DCSP DCSP if ( ( ( &apos; &#91; &apos; in netloc ) and ( &apos; &#93; &apos; not in netloc ) ) or ( ( &apos; &#93; &apos; in netloc ) and ( &apos; &#91; &apos; not in netloc ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( &apos; Invalid DCSP IPv6 DCSP URL &apos; ) DCNL DCSP DCSP DCSP if ( allow _ fragments and ( &apos; # &apos; in url ) ) : DCNL DCSP DCSP DCSP DCSP ( url , fragment ) = url.split ( &apos; # &apos; , 1 ) DCNL DCSP DCSP DCSP if ( &apos; ? &apos; in url ) : DCNL DCSP DCSP DCSP DCSP ( url , query ) = url.split ( &apos; ? &apos; , 1 ) DCNL DCSP DCSP DCSP v = SplitResult ( scheme , netloc , url , query , fragment ) DCNL DCSP DCSP DCSP _ parse _ cache &#91; key &#93; = v DCNL DCSP DCSP DCSP return v DCNL DCSP DCSP for c in url &#91; : i &#93; : DCNL DCSP DCSP DCSP if ( c not in scheme _ chars ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP _ testportnum = int ( url &#91; ( i + 1 ) : &#93; ) DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP ( scheme , url ) = ( url &#91; : i &#93; .lower ( ) , url &#91; ( i + 1 ) : &#93; ) DCNL DCSP if ( url &#91; : 2 &#93; = = &apos; / / &apos; ) : DCNL DCSP DCSP ( netloc , url ) = _ splitnetloc ( url , 2 ) DCNL DCSP DCSP if ( ( ( &apos; &#91; &apos; in netloc ) and ( &apos; &#93; &apos; not in netloc ) ) or ( ( &apos; &#93; &apos; in netloc ) and ( &apos; &#91; &apos; not in netloc ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Invalid DCSP IPv6 DCSP URL &apos; ) DCNL DCSP if ( allow _ fragments and ( scheme in uses _ fragment ) and ( &apos; # &apos; in url ) ) : DCNL DCSP DCSP ( url , fragment ) = url.split ( &apos; # &apos; , 1 ) DCNL DCSP if ( ( scheme in uses _ query ) and ( &apos; ? &apos; in url ) ) : DCNL DCSP DCSP ( url , query ) = url.split ( &apos; ? &apos; , 1 ) DCNL DCSP v = SplitResult ( scheme , netloc , url , query , fragment ) DCNL DCSP _ parse _ cache &#91; key &#93; = v DCNL DCSP return v
DCSP def callback ( lexer , match , ctx = None ) : DCNL DCSP DCSP for ( i , action ) in enumerate ( args ) : DCNL DCSP DCSP DCSP if ( action is None ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP elif ( type ( action ) is _ TokenType ) : DCNL DCSP DCSP DCSP DCSP data = match.group ( ( i + 1 ) ) DCNL DCSP DCSP DCSP DCSP if data : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( match.start ( ( i + 1 ) ) , action , data ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ctx : DCNL DCSP DCSP DCSP DCSP DCSP ctx.pos = match.start ( ( i + 1 ) ) DCNL DCSP DCSP DCSP DCSP for item in action ( lexer , _ PseudoMatch ( match.start ( ( i + 1 ) ) , match.group ( ( i + 1 ) ) ) , ctx ) : DCNL DCSP DCSP DCSP DCSP DCSP if item : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( yield item ) DCNL DCSP DCSP if ctx : DCNL DCSP DCSP DCSP ctx.pos = match.end ( ) DCNL DCSP return callback
DCSP try : DCNL DCSP DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP policy = conn.get _ policy ( policyName = policyName ) DCNL DCSP DCSP if policy : DCNL DCSP DCSP DCSP keys = ( &apos; policyName &apos; , &apos; policyArn &apos; , &apos; policyDocument &apos; , &apos; defaultVersionId &apos; ) DCNL DCSP DCSP DCSP return { &apos; policy &apos; : dict ( &#91; ( k , policy.get ( k ) ) for k in keys &#93; ) } DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return { &apos; policy &apos; : None } DCNL DCSP except ClientError as e : DCNL DCSP DCSP err = salt.utils.boto3.get _ error ( e ) DCNL DCSP DCSP if ( e.response.get ( &apos; Error &apos; , { } ) .get ( &apos; Code &apos; ) = = &apos; ResourceNotFoundException &apos; ) : DCNL DCSP DCSP DCSP return { &apos; policy &apos; : None } DCNL DCSP DCSP return { &apos; error &apos; : salt.utils.boto3.get _ error ( e ) }
DCSP asp _ data = { } DCNL DCSP asp _ data &#91; &apos; maxNumReplicas &apos; &#93; = as _ params &#91; &apos; max _ instances &apos; &#93; DCNL DCSP if ( &apos; min _ instances &apos; in as _ params ) : DCNL DCSP DCSP asp _ data &#91; &apos; minNumReplicas &apos; &#93; = as _ params &#91; &apos; min _ instances &apos; &#93; DCNL DCSP if ( &apos; cool _ down _ period &apos; in as _ params ) : DCNL DCSP DCSP asp _ data &#91; &apos; coolDownPeriodSec &apos; &#93; = as _ params &#91; &apos; cool _ down _ period &apos; &#93; DCNL DCSP if ( ( &apos; cpu _ utilization &apos; in as _ params ) and ( &apos; target &apos; in as _ params &#91; &apos; cpu _ utilization &apos; &#93; ) ) : DCNL DCSP DCSP asp _ data &#91; &apos; cpuUtilization &apos; &#93; = { &apos; utilizationTarget &apos; : as _ params &#91; &apos; cpu _ utilization &apos; &#93; &#91; &apos; target &apos; &#93; } DCNL DCSP if ( ( &apos; load _ balancing _ utilization &apos; in as _ params ) and ( &apos; target &apos; in as _ params &#91; &apos; load _ balancing _ utilization &apos; &#93; ) ) : DCNL DCSP DCSP asp _ data &#91; &apos; loadBalancingUtilization &apos; &#93; = { &apos; utilizationTarget &apos; : as _ params &#91; &apos; load _ balancing _ utilization &apos; &#93; &#91; &apos; target &apos; &#93; } DCNL DCSP return asp _ data
DCSP token = tokens.current ( ) DCNL DCSP result = &#91; &#93; DCNL DCSP if ( token in &apos; ( &#91; &apos; ) : DCNL DCSP DCSP tokens.move ( ) DCNL DCSP DCSP ( matching , pattern ) = { &apos; ( &apos; : &#91; &apos; ) &apos; , Required &#93; , &apos; &#91; &apos; : &#91; &apos; &#93; &apos; , Optional &#93; } &#91; token &#93; DCNL DCSP DCSP result = pattern ( * parse _ expr ( tokens , options ) ) DCNL DCSP DCSP if ( tokens.move ( ) ! = matching ) : DCNL DCSP DCSP DCSP raise tokens.error ( ( &quot; unmatched DCSP &apos; % s &apos; &quot; % token ) ) DCNL DCSP DCSP return &#91; result &#93; DCNL DCSP elif ( token = = &apos; options &apos; ) : DCNL DCSP DCSP tokens.move ( ) DCNL DCSP DCSP return &#91; OptionsShortcut ( ) &#93; DCNL DCSP elif ( token.startswith ( &apos; -- &apos; ) and ( token ! = &apos; -- &apos; ) ) : DCNL DCSP DCSP return parse _ long ( tokens , options ) DCNL DCSP elif ( token.startswith ( &apos; -&apos; ) and ( token not in ( &apos; -&apos; , &apos; -- &apos; ) ) ) : DCNL DCSP DCSP return parse _ shorts ( tokens , options ) DCNL DCSP elif ( ( token.startswith ( &apos; &lt; &apos; ) and token.endswith ( &apos; &gt; &apos; ) ) or token.isupper ( ) ) : DCNL DCSP DCSP return &#91; Argument ( tokens.move ( ) ) &#93; DCNL DCSP else : DCNL DCSP DCSP return &#91; Command ( tokens.move ( ) ) &#93;
DCSP with open ( &apos; test.rpt &apos; , &apos; r &apos; ) as input _ file : DCNL DCSP DCSP data _ text = input _ file.read ( ) DCNL DCSP data = yaml.safe _ load ( data _ text ) DCNL DCSP string _ file = StringIO.StringIO ( ) DCNL DCSP _ generate _ html ( data , string _ file ) DCNL DCSP string _ file.seek ( 0 ) DCNL DCSP result = string _ file.read ( ) DCNL DCSP with open ( &apos; test.html &apos; , &apos; w &apos; ) as output : DCNL DCSP DCSP output.write ( result )
DCSP text = &apos; &apos; DCNL DCSP for character in value : DCNL DCSP DCSP if ( text ! = &apos; &apos; ) : DCNL DCSP DCSP DCSP text + = &apos; DCSP &apos; DCNL DCSP DCSP byte = ord ( character ) DCNL DCSP DCSP text + = byte2bin ( byte , classic _ mode ) DCNL DCSP return text
DCSP if form.textfile _ use _ local _ files.data : DCNL DCSP DCSP job.labels _ file = form.textfile _ local _ labels _ file.data.strip ( ) DCNL DCSP else : DCNL DCSP DCSP flask.request.files &#91; form.textfile _ labels _ file.name &#93; .save ( os.path.join ( job.dir ( ) , utils.constants.LABELS _ FILE ) ) DCNL DCSP DCSP job.labels _ file = utils.constants.LABELS _ FILE DCNL DCSP shuffle = bool ( form.textfile _ shuffle.data ) DCNL DCSP backend = form.backend.data DCNL DCSP encoding = form.encoding.data DCNL DCSP compression = form.compression.data DCNL DCSP if form.textfile _ use _ local _ files.data : DCNL DCSP DCSP train _ file = form.textfile _ local _ train _ images.data.strip ( ) DCNL DCSP else : DCNL DCSP DCSP flask.request.files &#91; form.textfile _ train _ images.name &#93; .save ( os.path.join ( job.dir ( ) , utils.constants.TRAIN _ FILE ) ) DCNL DCSP DCSP train _ file = utils.constants.TRAIN _ FILE DCNL DCSP image _ folder = form.textfile _ train _ folder.data.strip ( ) DCNL DCSP if ( not image _ folder ) : DCNL DCSP DCSP image _ folder = None DCNL DCSP job.tasks.append ( tasks.CreateDbTask ( job _ dir = job.dir ( ) , input _ file = train _ file , db _ name = utils.constants.TRAIN _ DB , backend = backend , image _ dims = job.image _ dims , image _ folder = image _ folder , resize _ mode = job.resize _ mode , encoding = encoding , compression = compression , mean _ file = utils.constants.MEAN _ FILE _ CAFFE , labels _ file = job.labels _ file , shuffle = shuffle ) ) DCNL DCSP if form.textfile _ use _ val.data : DCNL DCSP DCSP if form.textfile _ use _ local _ files.data : DCNL DCSP DCSP DCSP val _ file = form.textfile _ local _ val _ images.data.strip ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP flask.request.files &#91; form.textfile _ val _ images.name &#93; .save ( os.path.join ( job.dir ( ) , utils.constants.VAL _ FILE ) ) DCNL DCSP DCSP DCSP val _ file = utils.constants.VAL _ FILE DCNL DCSP DCSP image _ folder = form.textfile _ val _ folder.data.strip ( ) DCNL DCSP DCSP if ( not image _ folder ) : DCNL DCSP DCSP DCSP image _ folder = None DCNL DCSP DCSP job.tasks.append ( tasks.CreateDbTask ( job _ dir = job.dir ( ) , input _ file = val _ file , db _ name = utils.constants.VAL _ DB , backend = backend , image _ dims = job.image _ dims , image _ folder = image _ folder , resize _ mode = job.resize _ mode , encoding = encoding , compression = compression , labels _ file = job.labels _ file , shuffle = shuffle ) ) DCNL DCSP if form.textfile _ use _ test.data : DCNL DCSP DCSP if form.textfile _ use _ local _ files.data : DCNL DCSP DCSP DCSP test _ file = form.textfile _ local _ test _ images.data.strip ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP flask.request.files &#91; form.textfile _ test _ images.name &#93; .save ( os.path.join ( job.dir ( ) , utils.constants.TEST _ FILE ) ) DCNL DCSP DCSP DCSP test _ file = utils.constants.TEST _ FILE DCNL DCSP DCSP image _ folder = form.textfile _ test _ folder.data.strip ( ) DCNL DCSP DCSP if ( not image _ folder ) : DCNL DCSP DCSP DCSP image _ folder = None DCNL DCSP DCSP job.tasks.append ( tasks.CreateDbTask ( job _ dir = job.dir ( ) , input _ file = test _ file , db _ name = utils.constants.TEST _ DB , backend = backend , image _ dims = job.image _ dims , image _ folder = image _ folder , resize _ mode = job.resize _ mode , encoding = encoding , compression = compression , labels _ file = job.labels _ file , shuffle = shuffle ) )
DCSP if ( len ( root.handlers ) = = 0 ) : DCNL DCSP DCSP basicConfig ( ) DCNL DCSP root.debug ( * ( ( msg , ) + args ) , * * kwargs )
DCSP return st.floats ( min _ value = 0.0 , allow _ infinity = False ) .filter ( ( lambda x : ( x &gt; 0.0 ) ) )
DCSP return tf.train.FeatureList ( feature = &#91; _ int64 _ feature ( v ) for v in values &#93; )
DCSP return _ sys _ version ( ) &#91; 0 &#93;
DCSP assert part , &apos; part DCSP must DCSP be DCSP a DCSP field DCSP name DCSP and DCSP + DCSP or DCSP - &apos; DCNL DCSP field = part &#91; : ( -1 ) &#93; DCNL DCSP assert field , &apos; field DCSP is DCSP missing &apos; DCNL DCSP direction = part &#91; ( -1 ) &#93; DCNL DCSP assert ( direction in ( &apos; + &apos; , &apos; -&apos; ) ) , &apos; part DCSP must DCSP end DCSP with DCSP + DCSP or DCSP - &apos; DCNL DCSP is _ ascending = ( direction = = &apos; + &apos; ) DCNL DCSP case _ insensitive = beets.config &#91; &apos; sort _ case _ insensitive &apos; &#93; .get ( bool ) DCNL DCSP if ( field in model _ cls . _ sorts ) : DCNL DCSP DCSP sort = model _ cls . _ sorts &#91; field &#93; ( model _ cls , is _ ascending , case _ insensitive ) DCNL DCSP elif ( field in model _ cls . _ fields ) : DCNL DCSP DCSP sort = query.FixedFieldSort ( field , is _ ascending , case _ insensitive ) DCNL DCSP else : DCNL DCSP DCSP sort = query.SlowFieldSort ( field , is _ ascending , case _ insensitive ) DCNL DCSP return sort
DCSP return _ resource ( &apos; add &apos; , zone , resource _ type , None , * * kwargs )
DCSP return &apos; &apos;.join ( bits ( s , endian , zero , one ) )
DCSP fd = CreateGRRTempFile ( directory = directory , filename = filename , lifetime = lifetime , mode = mode , suffix = suffix ) DCNL DCSP pathspec = rdf _ paths.PathSpec ( path = fd.name , pathtype = rdf _ paths.PathSpec.PathType.TMPFILE ) DCNL DCSP return ( fd , pathspec )
DCSP if backend.startswith ( &apos; module : / / &apos; ) : DCNL DCSP DCSP backend _ name = backend &#91; 9 : &#93; DCNL DCSP else : DCNL DCSP DCSP backend _ name = ( &apos; backend _ &apos; + backend ) DCNL DCSP DCSP backend _ name = backend _ name.lower ( ) DCNL DCSP DCSP backend _ name = ( &apos; matplotlib.backends. % s &apos; % backend _ name.lower ( ) ) DCNL DCSP backend _ mod = _ _ import _ _ ( backend _ name , globals ( ) , locals ( ) , &#91; backend _ name &#93; ) DCNL DCSP new _ figure _ manager = backend _ mod.new _ figure _ manager DCNL DCSP def do _ nothing _ show ( * args , * * kwargs ) : DCNL DCSP DCSP frame = inspect.currentframe ( ) DCNL DCSP DCSP fname = frame.f _ back.f _ code.co _ filename DCNL DCSP DCSP if ( fname in ( &apos; &lt; stdin &gt; &apos; , &apos; &lt; ipython DCSP console &gt; &apos; ) ) : DCNL DCSP DCSP DCSP warnings.warn ( ( &quot; \ nYour DCSP currently DCSP selected DCSP backend , DCSP &apos; % s &apos; DCSP does DCSP not DCSP support DCSP show ( ) . \ nPlease DCSP select DCSP a DCSP GUI DCSP backend DCSP in DCSP your DCSP matplotlibrc DCSP file DCSP ( &apos; % s &apos; ) \ nor DCSP with DCSP matplotlib.use ( ) &quot; % ( backend , matplotlib.matplotlib _ fname ( ) ) ) ) DCNL DCSP def do _ nothing ( * args , * * kwargs ) : DCNL DCSP DCSP pass DCNL DCSP backend _ version = getattr ( backend _ mod , &apos; backend _ version &apos; , &apos; unknown &apos; ) DCNL DCSP show = getattr ( backend _ mod , &apos; show &apos; , do _ nothing _ show ) DCNL DCSP draw _ if _ interactive = getattr ( backend _ mod , &apos; draw _ if _ interactive &apos; , do _ nothing ) DCNL DCSP if ( backend.lower ( ) in &#91; &apos; wx &apos; , &apos; wxagg &apos; &#93; ) : DCNL DCSP DCSP Toolbar = backend _ mod.Toolbar DCNL DCSP DCSP _ _ all _ _ .append ( &apos; Toolbar &apos; ) DCNL DCSP matplotlib.verbose.report ( ( &apos; backend DCSP % s DCSP version DCSP % s &apos; % ( backend , backend _ version ) ) ) DCNL DCSP return ( new _ figure _ manager , draw _ if _ interactive , show )
DCSP course _ key = SlashSeparatedCourseKey.from _ deprecated _ string ( course _ id ) DCNL DCSP if hasattr ( course _ key , &apos; ccx &apos; ) : DCNL DCSP DCSP return redirect ( reverse ( &apos; dashboard &apos; ) ) DCNL DCSP with modulestore ( ) .bulk _ operations ( course _ key ) : DCNL DCSP DCSP permission = get _ permission _ for _ course _ about ( ) DCNL DCSP DCSP course = get _ course _ with _ access ( request.user , permission , course _ key ) DCNL DCSP DCSP course _ details = CourseDetails.populate ( course ) DCNL DCSP DCSP modes = CourseMode.modes _ for _ course _ dict ( course _ key ) DCNL DCSP DCSP if configuration _ helpers.get _ value ( &apos; ENABLE _ MKTG _ SITE &apos; , settings.FEATURES.get ( &apos; ENABLE _ MKTG _ SITE &apos; , False ) ) : DCNL DCSP DCSP DCSP return redirect ( reverse ( &apos; info &apos; , args = &#91; course.id.to _ deprecated _ string ( ) &#93; ) ) DCNL DCSP DCSP registered = registered _ for _ course ( course , request.user ) DCNL DCSP DCSP staff _ access = bool ( has _ access ( request.user , &apos; staff &apos; , course ) ) DCNL DCSP DCSP studio _ url = get _ studio _ url ( course , &apos; settings / details &apos; ) DCNL DCSP DCSP if has _ access ( request.user , &apos; load &apos; , course ) : DCNL DCSP DCSP DCSP course _ target = reverse ( &apos; info &apos; , args = &#91; course.id.to _ deprecated _ string ( ) &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP course _ target = reverse ( &apos; about _ course &apos; , args = &#91; course.id.to _ deprecated _ string ( ) &#93; ) DCNL DCSP DCSP show _ courseware _ link = bool ( ( ( has _ access ( request.user , &apos; load &apos; , course ) and has _ access ( request.user , &apos; view _ courseware _ with _ prerequisites &apos; , course ) ) or settings.FEATURES.get ( &apos; ENABLE _ LMS _ MIGRATION &apos; ) ) ) DCNL DCSP DCSP in _ cart = False DCNL DCSP DCSP reg _ then _ add _ to _ cart _ link = &apos; &apos; DCNL DCSP DCSP _ is _ shopping _ cart _ enabled = is _ shopping _ cart _ enabled ( ) DCNL DCSP DCSP if _ is _ shopping _ cart _ enabled : DCNL DCSP DCSP DCSP if request.user.is _ authenticated ( ) : DCNL DCSP DCSP DCSP DCSP cart = shoppingcart.models.Order.get _ cart _ for _ user ( request.user ) DCNL DCSP DCSP DCSP DCSP in _ cart = ( shoppingcart.models.PaidCourseRegistration.contained _ in _ order ( cart , course _ key ) or shoppingcart.models.CourseRegCodeItem.contained _ in _ order ( cart , course _ key ) ) DCNL DCSP DCSP DCSP reg _ then _ add _ to _ cart _ link = &apos; { reg _ url } ? course _ id = { course _ id } &amp; enrollment _ action = add _ to _ cart &apos; .format ( reg _ url = reverse ( &apos; register _ user &apos; ) , course _ id = urllib.quote ( str ( course _ id ) ) ) DCNL DCSP DCSP ecomm _ service = EcommerceService ( ) DCNL DCSP DCSP ecommerce _ checkout = ecomm _ service.is _ enabled ( request.user ) DCNL DCSP DCSP ecommerce _ checkout _ link = &apos; &apos; DCNL DCSP DCSP ecommerce _ bulk _ checkout _ link = &apos; &apos; DCNL DCSP DCSP professional _ mode = None DCNL DCSP DCSP is _ professional _ mode = ( ( CourseMode.PROFESSIONAL in modes ) or ( CourseMode.NO _ ID _ PROFESSIONAL _ MODE in modes ) ) DCNL DCSP DCSP if ( ecommerce _ checkout and is _ professional _ mode ) : DCNL DCSP DCSP DCSP professional _ mode = ( modes.get ( CourseMode.PROFESSIONAL , &apos; &apos; ) or modes.get ( CourseMode.NO _ ID _ PROFESSIONAL _ MODE , &apos; &apos; ) ) DCNL DCSP DCSP DCSP if professional _ mode.sku : DCNL DCSP DCSP DCSP DCSP ecommerce _ checkout _ link = ecomm _ service.checkout _ page _ url ( professional _ mode.sku ) DCNL DCSP DCSP DCSP if professional _ mode.bulk _ sku : DCNL DCSP DCSP DCSP DCSP ecommerce _ bulk _ checkout _ link = ecomm _ service.checkout _ page _ url ( professional _ mode.bulk _ sku ) DCNL DCSP DCSP registration _ price = CourseMode.min _ course _ price _ for _ currency ( course _ key , settings.PAID _ COURSE _ REGISTRATION _ CURRENCY &#91; 0 &#93; ) DCNL DCSP DCSP course _ price = get _ cosmetic _ display _ price ( course , registration _ price ) DCNL DCSP DCSP can _ add _ course _ to _ cart = ( _ is _ shopping _ cart _ enabled and registration _ price and ( not ecommerce _ checkout _ link ) ) DCNL DCSP DCSP can _ enroll = bool ( has _ access ( request.user , &apos; enroll &apos; , course ) ) DCNL DCSP DCSP invitation _ only = course.invitation _ only DCNL DCSP DCSP is _ course _ full = CourseEnrollment.objects.is _ course _ full ( course ) DCNL DCSP DCSP active _ reg _ button = ( not ( registered or is _ course _ full or ( not can _ enroll ) ) ) DCNL DCSP DCSP is _ shib _ course = uses _ shib ( course ) DCNL DCSP DCSP pre _ requisite _ courses = get _ prerequisite _ courses _ display ( course ) DCNL DCSP DCSP overview = CourseOverview.get _ from _ id ( course.id ) DCNL DCSP DCSP context = { &apos; course &apos; : course , &apos; course _ details &apos; : course _ details , &apos; staff _ access &apos; : staff _ access , &apos; studio _ url &apos; : studio _ url , &apos; registered &apos; : registered , &apos; course _ target &apos; : course _ target , &apos; is _ cosmetic _ price _ enabled &apos; : settings.FEATURES.get ( &apos; ENABLE _ COSMETIC _ DISPLAY _ PRICE &apos; ) , &apos; course _ price &apos; : course _ price , &apos; in _ cart &apos; : in _ cart , &apos; ecommerce _ checkout &apos; : ecommerce _ checkout , &apos; ecommerce _ checkout _ link &apos; : ecommerce _ checkout _ link , &apos; ecommerce _ bulk _ checkout _ link &apos; : ecommerce _ bulk _ checkout _ link , &apos; professional _ mode &apos; : professional _ mode , &apos; reg _ then _ add _ to _ cart _ link &apos; : reg _ then _ add _ to _ cart _ link , &apos; show _ courseware _ link &apos; : show _ courseware _ link , &apos; is _ course _ full &apos; : is _ course _ full , &apos; can _ enroll &apos; : can _ enroll , &apos; invitation _ only &apos; : invitation _ only , &apos; active _ reg _ button &apos; : active _ reg _ button , &apos; is _ shib _ course &apos; : is _ shib _ course , &apos; disable _ courseware _ header &apos; : True , &apos; can _ add _ course _ to _ cart &apos; : can _ add _ course _ to _ cart , &apos; cart _ link &apos; : reverse ( &apos; shoppingcart.views.show _ cart &apos; ) , &apos; pre _ requisite _ courses &apos; : pre _ requisite _ courses , &apos; course _ image _ urls &apos; : overview.image _ urls } DCNL DCSP DCSP inject _ coursetalk _ keys _ into _ context ( context , course _ key ) DCNL DCSP DCSP return render _ to _ response ( &apos; courseware / course _ about.html &apos; , context )
DCSP return ipaddress.ip _ address ( ip _ addr ) .is _ private
DCSP a1 = _ asarray _ validated ( a , check _ finite = check _ finite ) DCNL DCSP if ( ( len ( a1.shape ) ! = 2 ) or ( a1.shape &#91; 0 &#93; ! = a1.shape &#91; 1 &#93; ) ) : DCNL DCSP DCSP raise ValueError ( &apos; expected DCSP square DCSP matrix &apos; ) DCNL DCSP overwrite _ a = ( overwrite _ a or _ datacopied ( a1 , a ) ) DCNL DCSP if ( a1.shape &#91; 0 &#93; &lt; = 2 ) : DCNL DCSP DCSP if calc _ q : DCNL DCSP DCSP DCSP return ( a1 , numpy.eye ( a1.shape &#91; 0 &#93; ) ) DCNL DCSP DCSP return a1 DCNL DCSP ( gehrd , gebal , gehrd _ lwork ) = get _ lapack _ funcs ( ( &apos; gehrd &apos; , &apos; gebal &apos; , &apos; gehrd _ lwork &apos; ) , ( a1 , ) ) DCNL DCSP ( ba , lo , hi , pivscale , info ) = gebal ( a1 , permute = 0 , overwrite _ a = overwrite _ a ) DCNL DCSP if ( info &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( ( &apos; illegal DCSP value DCSP in DCSP % d-th DCSP argument DCSP of DCSP internal DCSP gebal DCSP ( hessenberg ) &apos; % ( - info ) ) ) DCNL DCSP n = len ( a1 ) DCNL DCSP lwork = _ compute _ lwork ( gehrd _ lwork , ba.shape &#91; 0 &#93; , lo = lo , hi = hi ) DCNL DCSP ( hq , tau , info ) = gehrd ( ba , lo = lo , hi = hi , lwork = lwork , overwrite _ a = 1 ) DCNL DCSP if ( info &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( ( &apos; illegal DCSP value DCSP in DCSP % d-th DCSP argument DCSP of DCSP internal DCSP gehrd DCSP ( hessenberg ) &apos; % ( - info ) ) ) DCNL DCSP h = numpy.triu ( hq , ( -1 ) ) DCNL DCSP if ( not calc _ q ) : DCNL DCSP DCSP return h DCNL DCSP ( orghr , orghr _ lwork ) = get _ lapack _ funcs ( ( &apos; orghr &apos; , &apos; orghr _ lwork &apos; ) , ( a1 , ) ) DCNL DCSP lwork = _ compute _ lwork ( orghr _ lwork , n , lo = lo , hi = hi ) DCNL DCSP ( q , info ) = orghr ( a = hq , tau = tau , lo = lo , hi = hi , lwork = lwork , overwrite _ a = 1 ) DCNL DCSP if ( info &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( ( &apos; illegal DCSP value DCSP in DCSP % d-th DCSP argument DCSP of DCSP internal DCSP orghr DCSP ( hessenberg ) &apos; % ( - info ) ) ) DCNL DCSP return ( h , q )
DCSP if ( not is _ cuda _ ndarray ( obj ) ) : DCNL DCSP DCSP raise ValueError ( &apos; require DCSP an DCSP cuda DCSP ndarray DCSP object &apos; )
DCSP if ( ( len ( path ) &lt; 2 ) or ( not derivation.track ) ) : DCNL DCSP DCSP return matrix.Matrix ( ) DCNL DCSP point = point.dropAxis ( ) DCNL DCSP begin = path &#91; ( ( ( pointIndex + len ( path ) ) - 1 ) % len ( path ) ) &#93; .dropAxis ( ) DCNL DCSP end = path &#91; ( ( pointIndex + 1 ) % len ( path ) ) &#93; .dropAxis ( ) DCNL DCSP pointMinusBegin = ( point - begin ) DCNL DCSP pointMinusBeginLength = abs ( pointMinusBegin ) DCNL DCSP endMinusPoint = ( end - point ) DCNL DCSP endMinusPointLength = abs ( endMinusPoint ) DCNL DCSP if ( not derivation.closed ) : DCNL DCSP DCSP if ( ( pointIndex = = 0 ) and ( endMinusPointLength &gt; 0.0 ) ) : DCNL DCSP DCSP DCSP return getRotationMatrixByPolar ( arrayDictionary , endMinusPoint , endMinusPointLength ) DCNL DCSP DCSP elif ( ( pointIndex = = ( len ( path ) - 1 ) ) and ( pointMinusBeginLength &gt; 0.0 ) ) : DCNL DCSP DCSP DCSP return getRotationMatrixByPolar ( arrayDictionary , pointMinusBegin , pointMinusBeginLength ) DCNL DCSP if ( pointMinusBeginLength &lt; = 0.0 ) : DCNL DCSP DCSP print &apos; Warning , DCSP point DCSP equals DCSP previous DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for : &apos; DCNL DCSP DCSP print path DCNL DCSP DCSP print pointIndex DCNL DCSP DCSP print derivation.elementNode DCNL DCSP DCSP return matrix.Matrix ( ) DCNL DCSP pointMinusBegin / = pointMinusBeginLength DCNL DCSP if ( endMinusPointLength &lt; = 0.0 ) : DCNL DCSP DCSP print &apos; Warning , DCSP point DCSP equals DCSP next DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for : &apos; DCNL DCSP DCSP print path DCNL DCSP DCSP print pointIndex DCNL DCSP DCSP print derivation.elementNode DCNL DCSP DCSP return matrix.Matrix ( ) DCNL DCSP endMinusPoint / = endMinusPointLength DCNL DCSP averagePolar = ( pointMinusBegin + endMinusPoint ) DCNL DCSP averagePolarLength = abs ( averagePolar ) DCNL DCSP if ( averagePolarLength &lt; = 0.0 ) : DCNL DCSP DCSP print &apos; Warning , DCSP averagePolarLength DCSP is DCSP zero DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for : &apos; DCNL DCSP DCSP print path DCNL DCSP DCSP print pointIndex DCNL DCSP DCSP print derivation.elementNode DCNL DCSP DCSP return matrix.Matrix ( ) DCNL DCSP return getRotationMatrixByPolar ( arrayDictionary , averagePolar , averagePolarLength )
DCSP dim0 = ( np.prod ( dim &#91; : ( -1 ) &#93; ) + pad ) DCNL DCSP return ( dim0 , dim &#91; ( -1 ) &#93; )
DCSP if ( predicate is None ) : DCNL DCSP DCSP predicate = ( lambda line : line.strip ( ) ) DCNL DCSP def prefixed _ lines ( ) : DCNL DCSP DCSP for line in text.splitlines ( True ) : DCNL DCSP DCSP DCSP ( yield ( ( prefix + line ) if predicate ( line ) else line ) ) DCNL DCSP return &apos; &apos;.join ( prefixed _ lines ( ) )
DCSP return six.next ( six.itervalues ( obj ) )
DCSP return ( urllib _ parse ( url ) &#91; 0 &#93; in ssh _ uri _ schemes )
DCSP o = object . _ _ new _ _ ( cls ) DCNL DCSP o . _ as _ parameter _ = ctype DCNL DCSP return o
DCSP if platescale.unit.is _ equivalent ( ( si.arcsec / si.m ) ) : DCNL DCSP DCSP platescale _ val = platescale.to ( ( si.radian / si.m ) ) .value DCNL DCSP elif platescale.unit.is _ equivalent ( ( si.m / si.arcsec ) ) : DCNL DCSP DCSP platescale _ val = ( 1 / platescale ) .to ( ( si.radian / si.m ) ) .value DCNL DCSP else : DCNL DCSP DCSP raise UnitsError ( u &apos;The DCSP pixel DCSP scale DCSP must DCSP be DCSP in DCSP angle / distance DCSP or DCSP distance / angle &apos; ) DCNL DCSP return &#91; ( si.m , si.radian , ( lambda d : ( d * platescale _ val ) ) , ( lambda rad : ( rad / platescale _ val ) ) ) &#93;
DCSP assert ( ( uidb36 is not None ) and ( token is not None ) ) DCNL DCSP if ( post _ reset _ redirect is None ) : DCNL DCSP DCSP post _ reset _ redirect = reverse ( &apos; django.contrib.auth.views.password _ reset _ complete &apos; ) DCNL DCSP try : DCNL DCSP DCSP uid _ int = base36 _ to _ int ( uidb36 ) DCNL DCSP DCSP user = User.objects.get ( id = uid _ int ) DCNL DCSP except ( ValueError , User.DoesNotExist ) : DCNL DCSP DCSP user = None DCNL DCSP if ( ( user is not None ) and token _ generator.check _ token ( user , token ) ) : DCNL DCSP DCSP validlink = True DCNL DCSP DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP DCSP form = set _ password _ form ( user , request.POST ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP form.save ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( post _ reset _ redirect ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP form = set _ password _ form ( None ) DCNL DCSP else : DCNL DCSP DCSP validlink = False DCNL DCSP DCSP form = None DCNL DCSP context = { &apos; form &apos; : form , &apos; validlink &apos; : validlink } DCNL DCSP if ( extra _ context is not None ) : DCNL DCSP DCSP context.update ( extra _ context ) DCNL DCSP return TemplateResponse ( request , template _ name , context , current _ app = current _ app )
DCSP ( memlen , itemsize , _ , _ , _ , _ ) = t DCNL DCSP return gen _ items ( ( memlen / / itemsize ) , ( &apos; # &apos; + fmt ) , &apos; numpy &apos; )
DCSP if isinstance ( track , TlTrack ) : DCNL DCSP DCSP ( tlid , track ) = track DCNL DCSP else : DCNL DCSP DCSP ( tlid , track ) = ( None , track ) DCNL DCSP if ( not track.uri ) : DCNL DCSP DCSP logger.warning ( u &apos;Ignoring DCSP track DCSP without DCSP uri &apos; ) DCNL DCSP DCSP return &#91; &#93; DCNL DCSP result = &#91; ( u &apos;file &apos; , track.uri ) , ( u &apos;Time &apos; , ( ( track.length and ( track.length / / 1000 ) ) or 0 ) ) , ( u &apos;Artist &apos; , concat _ multi _ values ( track.artists , u &apos;name &apos; ) ) , ( u &apos;Album &apos; , ( ( track.album and track.album.name ) or u &apos; &apos; ) ) &#93; DCNL DCSP if ( stream _ title is not None ) : DCNL DCSP DCSP result.append ( ( u &apos;Title &apos; , stream _ title ) ) DCNL DCSP DCSP if track.name : DCNL DCSP DCSP DCSP result.append ( ( u &apos;Name &apos; , track.name ) ) DCNL DCSP else : DCNL DCSP DCSP result.append ( ( u &apos;Title &apos; , ( track.name or u &apos; &apos; ) ) ) DCNL DCSP if track.date : DCNL DCSP DCSP result.append ( ( u &apos;Date &apos; , track.date ) ) DCNL DCSP if ( ( track.album is not None ) and ( track.album.num _ tracks is not None ) ) : DCNL DCSP DCSP result.append ( ( u &apos;Track &apos; , ( u &apos; % d / % d &apos; % ( ( track.track _ no or 0 ) , track.album.num _ tracks ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP result.append ( ( u &apos;Track &apos; , ( track.track _ no or 0 ) ) ) DCNL DCSP if ( ( position is not None ) and ( tlid is not None ) ) : DCNL DCSP DCSP result.append ( ( u &apos;Pos &apos; , position ) ) DCNL DCSP DCSP result.append ( ( u &apos;Id &apos; , tlid ) ) DCNL DCSP if ( ( track.album is not None ) and ( track.album.musicbrainz _ id is not None ) ) : DCNL DCSP DCSP result.append ( ( u &apos;MUSICBRAINZ _ ALBUMID &apos; , track.album.musicbrainz _ id ) ) DCNL DCSP if ( ( track.album is not None ) and track.album.artists ) : DCNL DCSP DCSP result.append ( ( u &apos;AlbumArtist &apos; , concat _ multi _ values ( track.album.artists , u &apos;name &apos; ) ) ) DCNL DCSP DCSP musicbrainz _ ids = concat _ multi _ values ( track.album.artists , u &apos;musicbrainz _ id &apos; ) DCNL DCSP DCSP if musicbrainz _ ids : DCNL DCSP DCSP DCSP result.append ( ( u &apos;MUSICBRAINZ _ ALBUMARTISTID &apos; , musicbrainz _ ids ) ) DCNL DCSP if track.artists : DCNL DCSP DCSP musicbrainz _ ids = concat _ multi _ values ( track.artists , u &apos;musicbrainz _ id &apos; ) DCNL DCSP DCSP if musicbrainz _ ids : DCNL DCSP DCSP DCSP result.append ( ( u &apos;MUSICBRAINZ _ ARTISTID &apos; , musicbrainz _ ids ) ) DCNL DCSP if track.composers : DCNL DCSP DCSP result.append ( ( u &apos;Composer &apos; , concat _ multi _ values ( track.composers , u &apos;name &apos; ) ) ) DCNL DCSP if track.performers : DCNL DCSP DCSP result.append ( ( u &apos;Performer &apos; , concat _ multi _ values ( track.performers , u &apos;name &apos; ) ) ) DCNL DCSP if track.genre : DCNL DCSP DCSP result.append ( ( u &apos;Genre &apos; , track.genre ) ) DCNL DCSP if track.disc _ no : DCNL DCSP DCSP result.append ( ( u &apos;Disc &apos; , track.disc _ no ) ) DCNL DCSP if track.last _ modified : DCNL DCSP DCSP datestring = datetime.datetime.utcfromtimestamp ( ( track.last _ modified / / 1000 ) ) .isoformat ( ) DCNL DCSP DCSP result.append ( ( u &apos;Last-Modified &apos; , ( datestring + u &apos;Z &apos; ) ) ) DCNL DCSP if ( track.musicbrainz _ id is not None ) : DCNL DCSP DCSP result.append ( ( u &apos;MUSICBRAINZ _ TRACKID &apos; , track.musicbrainz _ id ) ) DCNL DCSP if ( track.album and track.album.uri ) : DCNL DCSP DCSP result.append ( ( u &apos;X-AlbumUri &apos; , track.album.uri ) ) DCNL DCSP if ( track.album and track.album.images ) : DCNL DCSP DCSP images = u &apos; ; &apos; .join ( ( i for i in track.album.images if ( i is not u &apos; &apos; ) ) ) DCNL DCSP DCSP result.append ( ( u &apos;X-AlbumImage &apos; , images ) ) DCNL DCSP result = &#91; element for element in result if _ has _ value ( * element ) &#93; DCNL DCSP return result
DCSP text = archive.getFileText ( archive.getProfilesPath ( getProfileBaseName ( repository ) ) , False ) DCNL DCSP if ( text = = &apos; &apos; ) : DCNL DCSP DCSP if ( repository.baseNameSynonym ! = None ) : DCNL DCSP DCSP DCSP text = archive.getFileText ( archive.getProfilesPath ( getProfileBaseNameSynonym ( repository ) ) , False ) DCNL DCSP if ( text = = &apos; &apos; ) : DCNL DCSP DCSP print ( &apos; The DCSP default DCSP % s DCSP will DCSP be DCSP written DCSP in DCSP the DCSP .skeinforge DCSP folder DCSP in DCSP the DCSP home DCSP directory . &apos; % repository.title.lower ( ) ) DCNL DCSP DCSP text = archive.getFileText ( getProfilesDirectoryInAboveDirectory ( getProfileBaseName ( repository ) ) , False ) DCNL DCSP DCSP if ( text ! = &apos; &apos; ) : DCNL DCSP DCSP DCSP readSettingsFromText ( repository , text ) DCNL DCSP DCSP writeSettings ( repository ) DCNL DCSP DCSP temporaryApplyOverrides ( repository ) DCNL DCSP DCSP return repository DCNL DCSP readSettingsFromText ( repository , text ) DCNL DCSP temporaryApplyOverrides ( repository ) DCNL DCSP return repository
DCSP p = element DCNL DCSP while True : DCNL DCSP DCSP p = p.getparent ( ) DCNL DCSP DCSP if ( p.tag = = tag ) : DCNL DCSP DCSP DCSP return p DCNL DCSP return None
DCSP with open _ repo _ closing ( repo ) as r : DCNL DCSP DCSP walker = r.get _ walker ( max _ entries = max _ entries , paths = paths , reverse = reverse ) DCNL DCSP DCSP for entry in walker : DCNL DCSP DCSP DCSP decode = ( lambda x : commit _ decode ( entry.commit , x ) ) DCNL DCSP DCSP DCSP print _ commit ( entry.commit , decode , outstream ) DCNL DCSP DCSP DCSP if name _ status : DCNL DCSP DCSP DCSP DCSP outstream.writelines ( &#91; ( l + &apos; \ n &apos; ) for l in print _ name _ status ( entry.changes ( ) ) &#93; )
DCSP if ( not chain ) : DCNL DCSP DCSP return &apos; Error : DCSP Chain DCSP needs DCSP to DCSP be DCSP specified &apos; DCNL DCSP if ( not rule ) : DCNL DCSP DCSP return &apos; Error : DCSP Rule DCSP needs DCSP to DCSP be DCSP specified &apos; DCNL DCSP if ( not check _ table ( table , family = family ) ) : DCNL DCSP DCSP return &apos; Error : DCSP table DCSP { 0 } DCSP in DCSP family DCSP { 1 } DCSP does DCSP not DCSP exist &apos; .format ( table , family ) DCNL DCSP if ( not check _ chain ( table , chain , family = family ) ) : DCNL DCSP DCSP return &apos; Error : DCSP chain DCSP { 0 } DCSP in DCSP table DCSP { 1 } DCSP in DCSP family DCSP { 2 } DCSP does DCSP not DCSP exist &apos; .format ( chain , table , family ) DCNL DCSP if ( not check ( table , chain , rule , family = family ) ) : DCNL DCSP DCSP return &apos; Error : DCSP rule DCSP { 0 } DCSP chain DCSP { 1 } DCSP in DCSP table DCSP { 2 } DCSP in DCSP family DCSP { 3 } DCSP does DCSP not DCSP exist &apos; .format ( rule , chain , table , family ) DCNL DCSP nft _ family = _ NFTABLES _ FAMILIES &#91; family &#93; DCNL DCSP cmd = &apos; { 0 } DCSP --numeric DCSP --numeric DCSP --numeric DCSP --handle DCSP list DCSP chain DCSP { 1 } DCSP { 2 } DCSP { 3 } &apos; .format ( _ nftables _ cmd ( ) , nft _ family , table , chain ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP rules = re.split ( &apos; \ n + &apos; , out ) DCNL DCSP pat = re.compile ( &apos; { 0 } DCSP # DCSP handle DCSP ( ? P &lt; handle &gt; \ \ d + ) &apos; .format ( rule ) ) DCNL DCSP for r in rules : DCNL DCSP DCSP match = pat.search ( r ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP return match.group ( &apos; handle &apos; ) DCNL DCSP return &apos; Error : DCSP could DCSP not DCSP find DCSP rule DCSP { 0 } &apos; .format ( rule )
DCSP objs = &#91; &#93; DCNL DCSP for obj in domain _ obj _ list : DCNL DCSP DCSP objs.append ( ( obj.name if obj else None ) ) DCNL DCSP return objs
DCSP data = { } DCNL DCSP if os.path.exists ( filename ) : DCNL DCSP DCSP lock.acquire ( ) DCNL DCSP DCSP with open ( filename , &apos; r &apos; ) as f : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP data = _ json.load ( f ) DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( data , dict ) ) : DCNL DCSP DCSP DCSP DCSP DCSP data = { } DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP data = { } DCNL DCSP DCSP lock.release ( ) DCNL DCSP DCSP if args : DCNL DCSP DCSP DCSP return { key : data &#91; key &#93; for key in args if ( key in data ) } DCNL DCSP return data
DCSP tmp = copy.deepcopy ( _ _ salt _ _ &#91; &apos; config.option &apos; &#93; ( alarms _ from _ pillar , { } ) ) DCNL DCSP if alarms : DCNL DCSP DCSP tmp = dictupdate.update ( tmp , alarms ) DCNL DCSP merged _ return _ value = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP for ( _ , info ) in six.iteritems ( tmp ) : DCNL DCSP DCSP info &#91; &apos; name &apos; &#93; = ( ( name + &apos; DCSP &apos; ) + info &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP info &#91; &apos; attributes &apos; &#93; &#91; &apos; description &apos; &#93; = ( ( name + &apos; DCSP &apos; ) + info &#91; &apos; attributes &apos; &#93; &#91; &apos; description &apos; &#93; ) DCNL DCSP DCSP if ( &apos; dimensions &apos; not in info &#91; &apos; attributes &apos; &#93; ) : DCNL DCSP DCSP DCSP info &#91; &apos; attributes &apos; &#93; &#91; &apos; dimensions &apos; &#93; = { &apos; AutoScalingGroupName &apos; : &#91; name &#93; } DCNL DCSP DCSP scaling _ policy _ actions _ only = True DCNL DCSP DCSP for action _ type in &#91; &apos; alarm _ actions &apos; , &apos; insufficient _ data _ actions &apos; , &apos; ok _ actions &apos; &#93; : DCNL DCSP DCSP DCSP if ( action _ type in info &#91; &apos; attributes &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP new _ actions = &#91; &#93; DCNL DCSP DCSP DCSP DCSP for action in info &#91; &apos; attributes &apos; &#93; &#91; action _ type &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( &apos; scaling _ policy &apos; not in action ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP scaling _ policy _ actions _ only = False DCNL DCSP DCSP DCSP DCSP DCSP if ( &apos; : self : &apos; in action ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP action = action.replace ( &apos; : self : &apos; , &apos; : { 0 } : &apos; .format ( name ) ) DCNL DCSP DCSP DCSP DCSP DCSP new _ actions.append ( action ) DCNL DCSP DCSP DCSP DCSP info &#91; &apos; attributes &apos; &#93; &#91; action _ type &#93; = new _ actions DCNL DCSP DCSP if ( scaling _ policy _ actions _ only and min _ size _ equals _ max _ size ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP kwargs = { &apos; name &apos; : info &#91; &apos; name &apos; &#93; , &apos; attributes &apos; : info &#91; &apos; attributes &apos; &#93; , &apos; region &apos; : region , &apos; key &apos; : key , &apos; keyid &apos; : keyid , &apos; profile &apos; : profile } DCNL DCSP DCSP results = _ _ states _ _ &#91; &apos; boto _ cloudwatch _ alarm.present &apos; &#93; ( * * kwargs ) DCNL DCSP DCSP if ( not results &#91; &apos; result &apos; &#93; ) : DCNL DCSP DCSP DCSP merged _ return _ value &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP if ( results.get ( &apos; changes &apos; , { } ) ! = { } ) : DCNL DCSP DCSP DCSP merged _ return _ value &#91; &apos; changes &apos; &#93; &#91; info &#91; &apos; name &apos; &#93; &#93; = results &#91; &apos; changes &apos; &#93; DCNL DCSP DCSP if ( &apos; comment &apos; in results ) : DCNL DCSP DCSP DCSP merged _ return _ value &#91; &apos; comment &apos; &#93; + = results &#91; &apos; comment &apos; &#93; DCNL DCSP return merged _ return _ value
DCSP response = get _ dict ( &apos; url &apos; , &apos; args &apos; , &apos; headers &apos; , &apos; origin &apos; ) DCNL DCSP n = min ( n , 100 ) DCNL DCSP def generate _ stream ( ) : DCNL DCSP DCSP for i in range ( n ) : DCNL DCSP DCSP DCSP response &#91; &apos; id &apos; &#93; = i DCNL DCSP DCSP DCSP ( yield ( json.dumps ( response ) + &apos; \ n &apos; ) ) DCNL DCSP return Response ( generate _ stream ( ) , headers = { &apos; Content-Type &apos; : &apos; application / json &apos; } )
DCSP if ( not iterable ( vel _ vecs ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Velocity DCSP vectors DCSP must DCSP be DCSP contained DCSP in DCSP an DCSP iterable . &apos; ) DCNL DCSP if ( not iterable ( gen _ speeds ) ) : DCNL DCSP DCSP raise TypeError ( &apos; Generalized DCSP speeds DCSP must DCSP be DCSP contained DCSP in DCSP an DCSP iterable &apos; ) DCNL DCSP vec _ partials = &#91; &#93; DCNL DCSP for vec in vel _ vecs : DCNL DCSP DCSP partials = &#91; &#93; DCNL DCSP DCSP for speed in gen _ speeds : DCNL DCSP DCSP DCSP partials.append ( vec.diff ( speed , frame , var _ in _ dcm = False ) ) DCNL DCSP DCSP vec _ partials.append ( partials ) DCNL DCSP return vec _ partials
DCSP return all ( ( ( ord ( c ) &lt; 128 ) for c in string ) )
DCSP if ( global _ dict is None ) : DCNL DCSP DCSP global _ dict = { } DCNL DCSP if ( &apos; _ _ file _ _ &apos; not in global _ dict ) : DCNL DCSP DCSP global _ dict &#91; &apos; _ _ file _ _ &apos; &#93; = filename DCNL DCSP if ( &apos; _ _ doc _ _ &apos; not in global _ dict ) : DCNL DCSP DCSP global _ dict &#91; &apos; _ _ doc _ _ &apos; &#93; = None DCNL DCSP try : DCNL DCSP DCSP with open ( filename ) as f : DCNL DCSP DCSP DCSP code = compile ( f.read ( ) , filename , &apos; exec &apos; ) DCNL DCSP DCSP DCSP exec code in global _ dict DCNL DCSP except SystemExit : DCNL DCSP DCSP pass DCNL DCSP except SkipTest : DCNL DCSP DCSP raise AssertionError ( ( ( &quot; Couldn &apos;t DCSP verify DCSP format DCSP of DCSP &quot; + filename ) + &apos; due DCSP to DCSP SkipTest &apos; ) ) DCNL DCSP all _ errors = &#91; &#93; DCNL DCSP for ( key , val ) in six.iteritems ( global _ dict ) : DCNL DCSP DCSP if ( not key.startswith ( &apos; _ &apos; ) ) : DCNL DCSP DCSP DCSP module _ name = &apos; &apos; DCNL DCSP DCSP DCSP if hasattr ( inspect.getmodule ( val ) , &apos; _ _ name _ _ &apos; ) : DCNL DCSP DCSP DCSP DCSP module _ name = inspect.getmodule ( val ) . _ _ name _ _ DCNL DCSP DCSP DCSP if ( ( inspect.isfunction ( val ) or inspect.isclass ( val ) ) and ( ( inspect.getmodule ( val ) is None ) or ( module _ name = = &apos; _ _ builtin _ _ &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP if inspect.isfunction ( val ) : DCNL DCSP DCSP DCSP DCSP DCSP all _ errors.extend ( handle _ function ( val , key ) ) DCNL DCSP DCSP DCSP DCSP elif inspect.isclass ( val ) : DCNL DCSP DCSP DCSP DCSP DCSP all _ errors.extend ( handle _ class ( val , key ) ) DCNL DCSP DCSP elif ( key = = &apos; _ _ doc _ _ &apos; ) : DCNL DCSP DCSP DCSP all _ errors.extend ( handle _ module ( val , key ) ) DCNL DCSP if all _ errors : DCNL DCSP DCSP all _ errors.insert ( 0 , ( ( &apos; % s : &apos; % filename ) , ) ) DCNL DCSP return all _ errors
DCSP import doctest DCNL DCSP default _ kwargs = { &apos; optionflags &apos; : doctest.ELLIPSIS } DCNL DCSP kwargs.update ( default _ kwargs ) DCNL DCSP cur _ dir = os.path.abspath ( os.curdir ) DCNL DCSP print ( &apos; Running DCSP doctests ... &apos; ) DCNL DCSP try : DCNL DCSP DCSP os.chdir ( find _ test _ dir ( target _ dir ) ) DCNL DCSP DCSP doctest.testmod ( * args , * * kwargs ) DCNL DCSP finally : DCNL DCSP DCSP os.chdir ( cur _ dir ) DCNL DCSP print ( &apos; Done &apos; )
DCSP ico = _ get _ ico _ surface ( grade ) DCNL DCSP if ( not return _ surf ) : DCNL DCSP DCSP return ico &#91; &apos; tris &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP return ico
DCSP files = list ( files ) DCNL DCSP if files : DCNL DCSP DCSP return max ( ( datetime.datetime.fromtimestamp ( os.path.getmtime ( f ) ) for f in files ) ) DCNL DCSP return datetime.datetime ( 1970 , 1 , 1 )
DCSP &apos; DCSP According DCSP to DCSP JEP-0030 : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP query DCSP MAY DCSP have DCSP node DCSP attribute \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP identity : DCSP MUST DCSP HAVE DCSP category DCSP and DCSP name DCSP attributes DCSP and DCSP MAY DCSP HAVE DCSP type DCSP attribute . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP feature : DCSP MUST DCSP HAVE DCSP var DCSP attribute &apos; DCNL DCSP ( identities , features ) = ( &#91; &#93; , &#91; &#93; ) DCNL DCSP for i in _ discover ( disp , NS _ DISCO _ INFO , jid , node ) : DCNL DCSP DCSP if ( i.getName ( ) = = &apos; identity &apos; ) : DCNL DCSP DCSP DCSP identities.append ( i.attrs ) DCNL DCSP DCSP elif ( i.getName ( ) = = &apos; feature &apos; ) : DCNL DCSP DCSP DCSP features.append ( i.getAttr ( &apos; var &apos; ) ) DCNL DCSP DCSP elif ( i.getName ( ) = = &apos; agent &apos; ) : DCNL DCSP DCSP DCSP if i.getTag ( &apos; name &apos; ) : DCNL DCSP DCSP DCSP DCSP i.setAttr ( &apos; name &apos; , i.getTagData ( &apos; name &apos; ) ) DCNL DCSP DCSP DCSP if i.getTag ( &apos; description &apos; ) : DCNL DCSP DCSP DCSP DCSP i.setAttr ( &apos; name &apos; , i.getTagData ( &apos; description &apos; ) ) DCNL DCSP DCSP DCSP identities.append ( i.attrs ) DCNL DCSP DCSP DCSP if i.getTag ( &apos; groupchat &apos; ) : DCNL DCSP DCSP DCSP DCSP features.append ( NS _ GROUPCHAT ) DCNL DCSP DCSP DCSP if i.getTag ( &apos; register &apos; ) : DCNL DCSP DCSP DCSP DCSP features.append ( NS _ REGISTER ) DCNL DCSP DCSP DCSP if i.getTag ( &apos; search &apos; ) : DCNL DCSP DCSP DCSP DCSP features.append ( NS _ SEARCH ) DCNL DCSP return ( identities , features )
DCSP entity _ id = ( entity _ id or ENTITY _ ID ) DCNL DCSP return hass.states.is _ state ( entity _ id , STATE _ ABOVE _ HORIZON )
DCSP pass
DCSP return _ availables _ plugins ( resources.PLUGINS _ WEB )
DCSP if ( hasattr ( field , &apos; _ south _ introspects &apos; ) and field . _ south _ introspects ) : DCNL DCSP DCSP return True DCNL DCSP full _ name = ( &apos; % s . % s &apos; % ( field . _ _ class _ _ . _ _ module _ _ , field . _ _ class _ _ . _ _ name _ _ ) ) DCNL DCSP for regex in allowed _ fields : DCNL DCSP DCSP if re.match ( regex , full _ name ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP def _ dec ( view _ func ) : DCNL DCSP DCSP def _ checklogin ( request , * args , * * kwargs ) : DCNL DCSP DCSP DCSP if test _ func ( request.user ) : DCNL DCSP DCSP DCSP DCSP return view _ func ( request , * args , * * kwargs ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( ( &apos; % s ? % s = % s &apos; % ( login _ url , REDIRECT _ FIELD _ NAME , quote ( request.get _ full _ path ( ) ) ) ) ) DCNL DCSP DCSP _ checklogin . _ _ doc _ _ = view _ func . _ _ doc _ _ DCNL DCSP DCSP _ checklogin . _ _ dict _ _ = view _ func . _ _ dict _ _ DCNL DCSP DCSP return _ checklogin DCNL DCSP return _ dec
DCSP task = get _ object _ or _ 404 ( Task , pk = task _ id ) DCNL DCSP if ( not request.user.profile.has _ permission ( task ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Task &quot; ) DCNL DCSP if request.user.profile.has _ permission ( task , mode = &apos; x &apos; ) : DCNL DCSP DCSP if request.POST : DCNL DCSP DCSP DCSP if ( &apos; add-work &apos; in request.POST ) : DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; projects _ task _ time _ slot _ add &apos; , args = &#91; task.id &#93; ) ) DCNL DCSP DCSP DCSP elif ( &apos; start-work &apos; in request.POST ) : DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; projects _ task _ view &apos; , args = &#91; task.id &#93; ) ) DCNL DCSP DCSP DCSP record = UpdateRecord ( ) DCNL DCSP DCSP DCSP record.record _ type = &apos; manual &apos; DCNL DCSP DCSP DCSP form = TaskRecordForm ( request.user.profile , request.POST , instance = record ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP record = form.save ( ) DCNL DCSP DCSP DCSP DCSP record.set _ user _ from _ request ( request ) DCNL DCSP DCSP DCSP DCSP record.save ( ) DCNL DCSP DCSP DCSP DCSP record.about.add ( task ) DCNL DCSP DCSP DCSP DCSP task.set _ last _ updated ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; projects _ task _ view &apos; , args = &#91; task.id &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP form = TaskRecordForm ( request.user.profile ) DCNL DCSP else : DCNL DCSP DCSP form = None DCNL DCSP subtasks = Object.filter _ by _ request ( request , Task.objects.filter ( parent = task ) ) DCNL DCSP time _ slots = Object.filter _ by _ request ( request , TaskTimeSlot.objects.filter ( task = task ) ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; task &apos; : task , &apos; subtasks &apos; : subtasks , &apos; record _ form &apos; : form , &apos; time _ slots &apos; : time _ slots } ) DCNL DCSP if ( ( &apos; massform &apos; in context ) and ( &apos; project &apos; in context &#91; &apos; massform &apos; &#93; .fields ) ) : DCNL DCSP DCSP del context &#91; &apos; massform &apos; &#93; .fields &#91; &apos; project &apos; &#93; DCNL DCSP return render _ to _ response ( &apos; projects / task _ view &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP decodedString = string DCNL DCSP octalNumbers = re.findall ( &apos; \ \ \ \ ( &#91; 0-7 &#93; { 1-3 } ) &apos; , decodedString , re.DOTALL ) DCNL DCSP for octal in octalNumbers : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP decodedString = decodedString.replace ( ( &apos; \ \ \ \ &apos; + octal ) , chr ( int ( octal , 8 ) ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP return ( ( -1 ) , &apos; Error DCSP decoding DCSP string &apos; ) DCNL DCSP return ( 0 , decodedString )
DCSP warnings = 0 DCNL DCSP for sourcePath in iterSourceCode ( paths ) : DCNL DCSP DCSP warnings + = checkPath ( sourcePath , reporter ) DCNL DCSP return warnings
DCSP add _ devices ( &#91; VlcDevice ( config.get ( CONF _ NAME ) , config.get ( CONF _ ARGUMENTS ) ) &#93; )
DCSP assert ( hsl _ to _ rgb ( 180 , 20 , 50 ) = = ( 102 , 153 , 153 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 180 , 60 , 50 ) = = ( 51 , 204 , 204 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 180 , 100 , 50 ) = = ( 0 , 255 , 255 ) )
DCSP md = event.mimeData ( ) DCNL DCSP if ( md.hasFormat ( u &apos;text / uri-list &apos; ) and ( not md.hasFormat ( u &apos;application / calibre + from _ library &apos; ) ) ) : DCNL DCSP DCSP urls = &#91; unicode ( u.toLocalFile ( ) ) for u in md.urls ( ) &#93; DCNL DCSP DCSP return &#91; u for u in urls if ( os.path.splitext ( u ) &#91; 1 &#93; and os.path.exists ( u ) ) &#93;
DCSP s1 = np.cos ( ( ( 2 * np.pi ) * t ) ) DCNL DCSP e1 = np.exp ( ( - t ) ) DCNL DCSP return ( s1 * e1 )
DCSP return np.exp ( ( ( 2.1 * a ) + ( 3.2 * b ) ) )
DCSP if start _ position : DCNL DCSP DCSP document _ file.seek ( start _ position ) DCNL DCSP else : DCNL DCSP DCSP start _ position = document _ file.tell ( ) DCNL DCSP if section _ end _ keywords : DCNL DCSP DCSP first _ keyword = None DCNL DCSP DCSP line _ match = KEYWORD _ LINE.match ( stem.util.str _ tools . _ to _ unicode ( document _ file.readline ( ) ) ) DCNL DCSP DCSP if line _ match : DCNL DCSP DCSP DCSP first _ keyword = line _ match.groups ( ) &#91; 0 &#93; DCNL DCSP DCSP document _ file.seek ( start _ position ) DCNL DCSP DCSP if ( first _ keyword in section _ end _ keywords ) : DCNL DCSP DCSP DCSP return DCNL DCSP while ( ( end _ position is None ) or ( document _ file.tell ( ) &lt; end _ position ) ) : DCNL DCSP DCSP ( desc _ lines , ending _ keyword ) = _ read _ until _ keywords ( ( ( entry _ keyword , ) + section _ end _ keywords ) , document _ file , ignore _ first = True , end _ position = end _ position , include _ ending _ keyword = True ) DCNL DCSP DCSP desc _ content = bytes.join ( &apos; &apos; , desc _ lines ) DCNL DCSP DCSP if desc _ content : DCNL DCSP DCSP DCSP ( yield entry _ class ( desc _ content , validate , * extra _ args ) ) DCNL DCSP DCSP DCSP if ( ending _ keyword in section _ end _ keywords ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break
DCSP return novaclient ( request ) .flavors.list ( )
DCSP if isinstance ( policy _ or _ index , BaseStoragePolicy ) : DCNL DCSP DCSP policy = policy _ or _ index DCNL DCSP else : DCNL DCSP DCSP policy = POLICIES.get _ by _ index ( policy _ or _ index ) DCNL DCSP DCSP if ( policy is None ) : DCNL DCSP DCSP DCSP raise PolicyError ( &apos; Unknown DCSP policy &apos; , index = policy _ or _ index ) DCNL DCSP return _ get _ policy _ string ( base , int ( policy ) )
DCSP ret = { &apos; changes &apos; : { } , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; } DCNL DCSP old = list _ pkgs ( ) DCNL DCSP if salt.utils.is _ true ( refresh ) : DCNL DCSP DCSP refresh _ db ( ) DCNL DCSP result = _ call _ brew ( &apos; brew DCSP upgrade &apos; , failhard = False ) DCNL DCSP _ _ context _ _ .pop ( &apos; pkg.list _ pkgs &apos; , None ) DCNL DCSP new = list _ pkgs ( ) DCNL DCSP ret = salt.utils.compare _ dicts ( old , new ) DCNL DCSP if ( result &#91; &apos; retcode &apos; &#93; ! = 0 ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Problem DCSP encountered DCSP upgrading DCSP packages &apos; , info = { &apos; changes &apos; : ret , &apos; result &apos; : result } ) DCNL DCSP return ret
DCSP filename = &apos; / &apos; .join ( request.args ) DCNL DCSP path = apath ( filename , r = request ) DCNL DCSP a = safe _ read ( path ) .split ( &apos; \ n &apos; ) DCNL DCSP try : DCNL DCSP DCSP b = safe _ read ( ( path + &apos; .1 &apos; ) ) .split ( &apos; \ n &apos; ) DCNL DCSP except IOError : DCNL DCSP DCSP session.flash = &apos; Other DCSP file , DCSP no DCSP longer DCSP there &apos; DCNL DCSP DCSP redirect ( URL ( &apos; edit &apos; , args = request.args ) ) DCNL DCSP d = difflib.ndiff ( a , b ) DCNL DCSP def leading ( line ) : DCNL DCSP DCSP &apos; DCSP DCSP &apos; DCNL DCSP DCSP z = &apos; &apos; DCNL DCSP DCSP for ( k , c ) in enumerate ( line ) : DCNL DCSP DCSP DCSP if ( c = = &apos; DCSP &apos; ) : DCNL DCSP DCSP DCSP DCSP z + = &apos; &amp; nbsp ; &apos; DCNL DCSP DCSP DCSP elif ( c = = &apos; DCSP DCTB &apos; ) : DCNL DCSP DCSP DCSP DCSP z + = &apos; &amp; nbsp ; &apos; DCNL DCSP DCSP DCSP elif ( ( k = = 0 ) and ( c = = &apos; ? &apos; ) ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP return XML ( z ) DCNL DCSP def getclass ( item ) : DCNL DCSP DCSP &apos; DCSP Determine DCSP item DCSP class DCSP &apos; DCNL DCSP DCSP operators = { &apos; DCSP &apos; : &apos; normal &apos; , &apos; + &apos; : &apos; plus &apos; , &apos; -&apos; : &apos; minus &apos; } DCNL DCSP DCSP return operators &#91; item &#91; 0 &#93; &#93; DCNL DCSP if request.vars : DCNL DCSP DCSP c = &apos; \ n &apos; .join ( &#91; item &#91; 2 : &#93; .rstrip ( ) for ( i , item ) in enumerate ( d ) if ( ( item &#91; 0 &#93; = = &apos; DCSP &apos; ) or ( ( &apos; line % i &apos; % i ) in request.vars ) ) &#93; ) DCNL DCSP DCSP safe _ write ( path , c ) DCNL DCSP DCSP session.flash = &apos; files DCSP merged &apos; DCNL DCSP DCSP redirect ( URL ( &apos; edit &apos; , args = request.args ) ) DCNL DCSP else : DCNL DCSP DCSP gen _ data = ( lambda index , item : ( ( ( not ( item &#91; : 1 &#93; in &#91; &apos; + &apos; , &apos; -&apos; &#93; ) ) and &apos; &apos; ) or INPUT ( _ type = &apos; checkbox &apos; , _ name = ( &apos; line % i &apos; % index ) , value = ( item &#91; 0 &#93; = = &apos; + &apos; ) ) ) ) DCNL DCSP DCSP diff = TABLE ( * &#91; TR ( TD ( gen _ data ( i , item ) ) , TD ( item &#91; 0 &#93; ) , TD ( leading ( item &#91; 2 : &#93; ) , TT ( item &#91; 2 : &#93; .rstrip ( ) ) ) , _ class = getclass ( item ) ) for ( i , item ) in enumerate ( d ) if ( item &#91; 0 &#93; ! = &apos; ? &apos; ) &#93; ) DCNL DCSP return dict ( diff = diff , filename = filename )
DCSP global _ modes DCNL DCSP if ( not _ modes ) : DCNL DCSP DCSP from . import Image DCNL DCSP DCSP modes = { } DCNL DCSP DCSP for ( m , ( basemode , basetype , bands ) ) in Image . _ MODEINFO.items ( ) : DCNL DCSP DCSP DCSP modes &#91; m &#93; = ModeDescriptor ( m , bands , basemode , basetype ) DCNL DCSP DCSP modes &#91; &apos; RGBa &apos; &#93; = ModeDescriptor ( &apos; RGBa &apos; , ( &apos; R &apos; , &apos; G &apos; , &apos; B &apos; , &apos; a &apos; ) , &apos; RGB &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; LA &apos; &#93; = ModeDescriptor ( &apos; LA &apos; , ( &apos; L &apos; , &apos; A &apos; ) , &apos; L &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; La &apos; &#93; = ModeDescriptor ( &apos; La &apos; , ( &apos; L &apos; , &apos; a &apos; ) , &apos; L &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; PA &apos; &#93; = ModeDescriptor ( &apos; PA &apos; , ( &apos; P &apos; , &apos; A &apos; ) , &apos; RGB &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; I ; 16 &apos; &#93; = ModeDescriptor ( &apos; I ; 16 &apos; , &apos; I &apos; , &apos; L &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; I ; 16L &apos; &#93; = ModeDescriptor ( &apos; I ; 16L &apos; , &apos; I &apos; , &apos; L &apos; , &apos; L &apos; ) DCNL DCSP DCSP modes &#91; &apos; I ; 16B &apos; &#93; = ModeDescriptor ( &apos; I ; 16B &apos; , &apos; I &apos; , &apos; L &apos; , &apos; L &apos; ) DCNL DCSP DCSP _ modes = modes DCNL DCSP return _ modes &#91; mode &#93;
DCSP try : DCNL DCSP DCSP plugin.save ( title ) DCNL DCSP DCSP plugin.restart ( ) DCNL DCSP DCSP return True DCNL DCSP except le _ errors.Error as error : DCNL DCSP DCSP logger.error ( &apos; Plugin DCSP failed DCSP to DCSP save DCSP and DCSP restart DCSP server : &apos; ) DCNL DCSP DCSP logger.exception ( error ) DCNL DCSP DCSP return False
DCSP args = &#91; &#93; DCNL DCSP s = True DCNL DCSP n = M.rows DCNL DCSP try : DCNL DCSP DCSP list = M. _ mat DCNL DCSP except AttributeError : DCNL DCSP DCSP list = flatten ( M.tolist ( ) ) DCNL DCSP for perm in generate _ bell ( n ) : DCNL DCSP DCSP fac = &#91; &#93; DCNL DCSP DCSP idx = 0 DCNL DCSP DCSP for j in perm : DCNL DCSP DCSP DCSP fac.append ( list &#91; ( idx + j ) &#93; ) DCNL DCSP DCSP DCSP idx + = n DCNL DCSP DCSP term = Mul ( * fac ) DCNL DCSP DCSP args.append ( ( term if s else ( - term ) ) ) DCNL DCSP DCSP s = ( not s ) DCNL DCSP return Add ( * args )
DCSP from hadoop import job _ tracker DCNL DCSP from hadoop.fs import webhdfs DCNL DCSP res = &#91; &#93; DCNL DCSP submit _ to = &#91; &#93; DCNL DCSP has _ default = False DCNL DCSP for name in HDFS _ CLUSTERS.keys ( ) : DCNL DCSP DCSP cluster = HDFS _ CLUSTERS &#91; name &#93; DCNL DCSP DCSP res.extend ( webhdfs.test _ fs _ configuration ( cluster ) ) DCNL DCSP DCSP if ( name = = &apos; default &apos; ) : DCNL DCSP DCSP DCSP has _ default = True DCNL DCSP if ( not has _ default ) : DCNL DCSP DCSP res.append ( ( &apos; hadoop.hdfs _ clusters &apos; , &quot; You DCSP should DCSP have DCSP an DCSP HDFS DCSP called DCSP &apos; default &apos; . &quot; ) ) DCNL DCSP mr _ down = &#91; &#93; DCNL DCSP for name in MR _ CLUSTERS.keys ( ) : DCNL DCSP DCSP cluster = MR _ CLUSTERS &#91; name &#93; DCNL DCSP DCSP if cluster.SUBMIT _ TO.get ( ) : DCNL DCSP DCSP DCSP mr _ down.extend ( job _ tracker.test _ jt _ configuration ( cluster ) ) DCNL DCSP DCSP DCSP submit _ to.append ( ( &apos; mapred _ clusters . &apos; + name ) ) DCNL DCSP if ( mr _ down and ( len ( mr _ down ) = = len ( MR _ CLUSTERS.keys ( ) ) ) ) : DCNL DCSP DCSP res.extend ( mr _ down ) DCNL DCSP if YARN _ CLUSTERS.keys ( ) : DCNL DCSP DCSP res.extend ( test _ yarn _ configurations ( user ) ) DCNL DCSP for name in YARN _ CLUSTERS.keys ( ) : DCNL DCSP DCSP cluster = YARN _ CLUSTERS &#91; name &#93; DCNL DCSP DCSP if cluster.SUBMIT _ TO.get ( ) : DCNL DCSP DCSP DCSP submit _ to.append ( ( &apos; yarn _ clusters . &apos; + name ) ) DCNL DCSP if ( not submit _ to ) : DCNL DCSP DCSP res.append ( ( &apos; hadoop &apos; , &quot; Please DCSP designate DCSP one DCSP of DCSP the DCSP MapReduce DCSP or DCSP Yarn DCSP clusters DCSP with DCSP `submit _ to = true &apos; DCSP in DCSP order DCSP to DCSP run DCSP jobs . &quot; ) ) DCNL DCSP return res
DCSP try : DCNL DCSP DCSP obj = match _ obj.group ( name ) DCNL DCSP except : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP if ( obj is not None ) : DCNL DCSP DCSP DCSP return obj DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return &apos; &apos;
DCSP if ( secret is None ) : DCNL DCSP DCSP secret = settings.SECRET _ KEY DCNL DCSP key _ salt = force _ bytes ( key _ salt ) DCNL DCSP secret = force _ bytes ( secret ) DCNL DCSP key = hashlib.sha1 ( ( key _ salt + secret ) ) .digest ( ) DCNL DCSP return hmac.new ( key , msg = force _ bytes ( value ) , digestmod = hashlib.sha1 )
DCSP return _ osquery _ cmd ( table = &apos; etc _ hosts &apos; , attrs = attrs , where = where )
DCSP def decorator ( f ) : DCNL DCSP DCSP group = args &#91; 0 &#93; DCNL DCSP DCSP name = args &#91; 1 &#93; DCNL DCSP DCSP @ functools.wraps ( f ) DCNL DCSP DCSP def wrapper ( self , * func _ args , * * func _ kwargs ) : DCNL DCSP DCSP DCSP if hasattr ( CONF , group ) : DCNL DCSP DCSP DCSP DCSP conf _ group = getattr ( CONF , group ) DCNL DCSP DCSP DCSP DCSP if hasattr ( conf _ group , name ) : DCNL DCSP DCSP DCSP DCSP DCSP value = getattr ( conf _ group , name ) DCNL DCSP DCSP DCSP DCSP DCSP if value : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( len ( args ) = = 3 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP msg = args &#91; 2 &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP msg = ( &apos; Config DCSP option DCSP % s . % s DCSP is DCSP false &apos; % ( group , name ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise testtools.TestCase.skipException ( msg ) DCNL DCSP DCSP DCSP return f ( self , * func _ args , * * func _ kwargs ) DCNL DCSP DCSP return wrapper DCNL DCSP return decorator
DCSP return enet _ path ( X , y , l1 _ ratio = 1.0 , eps = eps , n _ alphas = n _ alphas , alphas = alphas , precompute = precompute , Xy = Xy , copy _ X = copy _ X , coef _ init = coef _ init , verbose = verbose , positive = positive , return _ n _ iter = return _ n _ iter , * * params )
DCSP extra _ service _ versions = set ( &#91; &#93; ) DCNL DCSP _ tempest _ modules = set ( tempest _ modules ( ) ) DCNL DCSP plugin _ services = ClientsRegistry ( ) .get _ service _ clients ( ) DCNL DCSP for plugin _ name in plugin _ services : DCNL DCSP DCSP plug _ service _ versions = set ( &#91; x &#91; &apos; service _ version &apos; &#93; for x in plugin _ services &#91; plugin _ name &#93; &#93; ) DCNL DCSP DCSP if plug _ service _ versions : DCNL DCSP DCSP DCSP if ( not plug _ service _ versions.isdisjoint ( extra _ service _ versions ) ) : DCNL DCSP DCSP DCSP DCSP detailed _ error = ( &apos; Plugin DCSP % s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP % s DCSP already DCSP claimed DCSP by DCSP another DCSP one &apos; % ( plugin _ name , ( extra _ service _ versions &amp; plug _ service _ versions ) ) ) DCNL DCSP DCSP DCSP DCSP raise exceptions.PluginRegistrationException ( name = plugin _ name , detailed _ error = detailed _ error ) DCNL DCSP DCSP DCSP if ( not plug _ service _ versions.isdisjoint ( _ tempest _ internal _ modules ( ) ) ) : DCNL DCSP DCSP DCSP DCSP detailed _ error = ( &apos; Plugin DCSP % s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP % s DCSP already DCSP claimed DCSP by DCSP a DCSP Tempest DCSP one &apos; % ( plugin _ name , ( _ tempest _ internal _ modules ( ) &amp; plug _ service _ versions ) ) ) DCNL DCSP DCSP DCSP DCSP raise exceptions.PluginRegistrationException ( name = plugin _ name , detailed _ error = detailed _ error ) DCNL DCSP DCSP extra _ service _ versions &#124; = plug _ service _ versions DCNL DCSP return ( _ tempest _ modules &#124; extra _ service _ versions )
DCSP if ( file is None ) : DCNL DCSP DCSP file = sys.stderr DCNL DCSP try : DCNL DCSP DCSP ( etype , value , tb ) = sys.exc _ info ( ) DCNL DCSP DCSP print _ exception ( etype , value , tb , limit , file ) DCNL DCSP finally : DCNL DCSP DCSP etype = value = tb = None
DCSP if ( ( nterms = = 0 ) and ( not fit _ mean ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Cannot DCSP have DCSP nterms DCSP = DCSP 0 DCSP without DCSP fitting DCSP bias &apos; ) DCNL DCSP if ( dy is None ) : DCNL DCSP DCSP dy = 1 DCNL DCSP ( t , y , dy ) = np.broadcast _ arrays ( t , y , dy ) DCNL DCSP if ( t.ndim ! = 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; t , DCSP y , DCSP dy DCSP should DCSP be DCSP one DCSP dimensional &apos; ) DCNL DCSP if ( f0 &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; Frequencies DCSP must DCSP be DCSP positive &apos; ) DCNL DCSP if ( df &lt; = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; Frequency DCSP steps DCSP must DCSP be DCSP positive &apos; ) DCNL DCSP if ( Nf &lt; = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; Number DCSP of DCSP frequencies DCSP must DCSP be DCSP positive &apos; ) DCNL DCSP w = ( dy * * ( -2.0 ) ) DCNL DCSP ws = np.sum ( w ) DCNL DCSP if ( center _ data or fit _ mean ) : DCNL DCSP DCSP y = ( y - ( np.dot ( w , y ) / ws ) ) DCNL DCSP yw = ( y / dy ) DCNL DCSP chi2 _ ref = np.dot ( yw , yw ) DCNL DCSP kwargs = dict.copy ( ( trig _ sum _ kwds or { } ) ) DCNL DCSP kwargs.update ( f0 = f0 , df = df , use _ fft = use _ fft , N = Nf ) DCNL DCSP yws = np.sum ( ( y * w ) ) DCNL DCSP SCw = &#91; ( np.zeros ( Nf ) , ( ws * np.ones ( Nf ) ) ) &#93; DCNL DCSP SCw.extend ( &#91; trig _ sum ( t , w , freq _ factor = i , * * kwargs ) for i in range ( 1 , ( ( 2 * nterms ) + 1 ) ) &#93; ) DCNL DCSP ( Sw , Cw ) = zip ( * SCw ) DCNL DCSP SCyw = &#91; ( np.zeros ( Nf ) , ( yws * np.ones ( Nf ) ) ) &#93; DCNL DCSP SCyw.extend ( &#91; trig _ sum ( t , ( w * y ) , freq _ factor = i , * * kwargs ) for i in range ( 1 , ( nterms + 1 ) ) &#93; ) DCNL DCSP ( Syw , Cyw ) = zip ( * SCyw ) DCNL DCSP order = ( &#91; ( &apos; C &apos; , 0 ) &#93; if fit _ mean else &#91; &#93; ) DCNL DCSP order.extend ( sum ( &#91; &#91; ( &apos; S &apos; , i ) , ( &apos; C &apos; , i ) &#93; for i in range ( 1 , ( nterms + 1 ) ) &#93; , &#91; &#93; ) ) DCNL DCSP funcs = dict ( S = ( lambda m , i : Syw &#91; m &#93; &#91; i &#93; ) , C = ( lambda m , i : Cyw &#91; m &#93; &#91; i &#93; ) , SS = ( lambda m , n , i : ( 0.5 * ( Cw &#91; abs ( ( m - n ) ) &#93; &#91; i &#93; - Cw &#91; ( m + n ) &#93; &#91; i &#93; ) ) ) , CC = ( lambda m , n , i : ( 0.5 * ( Cw &#91; abs ( ( m - n ) ) &#93; &#91; i &#93; + Cw &#91; ( m + n ) &#93; &#91; i &#93; ) ) ) , SC = ( lambda m , n , i : ( 0.5 * ( ( np.sign ( ( m - n ) ) * Sw &#91; abs ( ( m - n ) ) &#93; &#91; i &#93; ) + Sw &#91; ( m + n ) &#93; &#91; i &#93; ) ) ) , CS = ( lambda m , n , i : ( 0.5 * ( ( np.sign ( ( n - m ) ) * Sw &#91; abs ( ( n - m ) ) &#93; &#91; i &#93; ) + Sw &#91; ( n + m ) &#93; &#91; i &#93; ) ) ) ) DCNL DCSP def compute _ power ( i ) : DCNL DCSP DCSP XTX = np.array ( &#91; &#91; funcs &#91; ( A &#91; 0 &#93; + B &#91; 0 &#93; ) &#93; ( A &#91; 1 &#93; , B &#91; 1 &#93; , i ) for A in order &#93; for B in order &#93; ) DCNL DCSP DCSP XTy = np.array ( &#91; funcs &#91; A &#91; 0 &#93; &#93; ( A &#91; 1 &#93; , i ) for A in order &#93; ) DCNL DCSP DCSP return np.dot ( XTy.T , np.linalg.solve ( XTX , XTy ) ) DCNL DCSP p = np.array ( &#91; compute _ power ( i ) for i in range ( Nf ) &#93; ) DCNL DCSP if ( normalization = = &apos; psd &apos; ) : DCNL DCSP DCSP p * = 0.5 DCNL DCSP elif ( normalization = = &apos; standard &apos; ) : DCNL DCSP DCSP p / = chi2 _ ref DCNL DCSP elif ( normalization = = &apos; log &apos; ) : DCNL DCSP DCSP p = ( - np.log ( ( 1 - ( p / chi2 _ ref ) ) ) ) DCNL DCSP elif ( normalization = = &apos; model &apos; ) : DCNL DCSP DCSP p / = ( chi2 _ ref - p ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &quot; normalization = &apos; { 0 } &apos; DCSP not DCSP recognized &quot; .format ( normalization ) ) DCNL DCSP return p
DCSP boundaries = &#91; 0 , 1.1 , 2.2 &#93; DCNL DCSP vals = &#91; ( -1 ) , 0 , 1 , 2 , 2.2 , 4 &#93; DCNL DCSP expected = &#91; ( -1 ) , 0 , 0 , 1 , 2 , 2 &#93; DCNL DCSP ncolors = ( len ( boundaries ) - 1 ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , ncolors ) DCNL DCSP assert _ array _ equal ( bn ( vals ) , expected ) DCNL DCSP expected = &#91; ( -1 ) , 0 , 0 , 2 , 3 , 3 &#93; DCNL DCSP ncolors = len ( boundaries ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , ncolors ) DCNL DCSP assert _ array _ equal ( bn ( vals ) , expected ) DCNL DCSP boundaries = &#91; 0 , 1 , 2 , 3 &#93; DCNL DCSP vals = &#91; ( -1 ) , 0.1 , 1.1 , 2.2 , 4 &#93; DCNL DCSP ncolors = 5 DCNL DCSP expected = &#91; ( -1 ) , 0 , 2 , 4 , 5 &#93; DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , ncolors ) DCNL DCSP assert _ array _ equal ( bn ( vals ) , expected ) DCNL DCSP boundaries = &#91; 0 , 1 , 2 &#93; DCNL DCSP vals = &#91; ( -1 ) , 0.1 , 1.1 , 2.2 &#93; DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , 2 ) DCNL DCSP expected = &#91; ( -1 ) , 0 , 1 , 2 &#93; DCNL DCSP for ( v , ex ) in zip ( vals , expected ) : DCNL DCSP DCSP ret = bn ( v ) DCNL DCSP DCSP assert isinstance ( ret , six.integer _ types ) DCNL DCSP DCSP assert _ array _ equal ( ret , ex ) DCNL DCSP DCSP assert _ array _ equal ( bn ( &#91; v &#93; ) , ex ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , 3 ) DCNL DCSP expected = &#91; ( -1 ) , 0 , 2 , 3 &#93; DCNL DCSP for ( v , ex ) in zip ( vals , expected ) : DCNL DCSP DCSP ret = bn ( v ) DCNL DCSP DCSP assert isinstance ( ret , six.integer _ types ) DCNL DCSP DCSP assert _ array _ equal ( ret , ex ) DCNL DCSP DCSP assert _ array _ equal ( bn ( &#91; v &#93; ) , ex ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , 3 , clip = True ) DCNL DCSP expected = &#91; 0 , 0 , 2 , 2 &#93; DCNL DCSP for ( v , ex ) in zip ( vals , expected ) : DCNL DCSP DCSP ret = bn ( v ) DCNL DCSP DCSP assert isinstance ( ret , six.integer _ types ) DCNL DCSP DCSP assert _ array _ equal ( ret , ex ) DCNL DCSP DCSP assert _ array _ equal ( bn ( &#91; v &#93; ) , ex ) DCNL DCSP boundaries = &#91; 0 , 1.1 , 2.2 &#93; DCNL DCSP vals = np.ma.masked _ invalid ( &#91; ( -1.0 ) , np.NaN , 0 , 1.4 , 9 &#93; ) DCNL DCSP ncolors = ( len ( boundaries ) - 1 ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , ncolors ) DCNL DCSP expected = np.ma.masked _ array ( &#91; ( -1 ) , ( -99 ) , 0 , 1 , 2 &#93; , mask = &#91; 0 , 1 , 0 , 0 , 0 &#93; ) DCNL DCSP assert _ array _ equal ( bn ( vals ) , expected ) DCNL DCSP bn = mcolors.BoundaryNorm ( boundaries , len ( boundaries ) ) DCNL DCSP expected = np.ma.masked _ array ( &#91; ( -1 ) , ( -99 ) , 0 , 2 , 3 &#93; , mask = &#91; 0 , 1 , 0 , 0 , 0 &#93; ) DCNL DCSP assert _ array _ equal ( bn ( vals ) , expected ) DCNL DCSP vals = np.ma.masked _ invalid ( &#91; np.Inf , np.NaN &#93; ) DCNL DCSP assert np.all ( bn ( vals ) .mask ) DCNL DCSP vals = np.ma.masked _ invalid ( &#91; np.Inf &#93; ) DCNL DCSP assert np.all ( bn ( vals ) .mask )
DCSP values = values.copy ( ) DCNL DCSP values &#91; &apos; metadata &apos; &#93; = _ metadata _ refs ( values.get ( &apos; metadata &apos; ) , models.InstanceMetadata ) DCNL DCSP values &#91; &apos; system _ metadata &apos; &#93; = _ metadata _ refs ( values.get ( &apos; system _ metadata &apos; ) , models.InstanceSystemMetadata ) DCNL DCSP instance _ ref = models.Instance ( ) DCNL DCSP if ( not values.get ( &apos; uuid &apos; ) ) : DCNL DCSP DCSP values &#91; &apos; uuid &apos; &#93; = str ( uuid.uuid4 ( ) ) DCNL DCSP instance _ ref &#91; &apos; info _ cache &apos; &#93; = models.InstanceInfoCache ( ) DCNL DCSP info _ cache = values.pop ( &apos; info _ cache &apos; , None ) DCNL DCSP if ( info _ cache is not None ) : DCNL DCSP DCSP instance _ ref &#91; &apos; info _ cache &apos; &#93; .update ( info _ cache ) DCNL DCSP security _ groups = values.pop ( &apos; security _ groups &apos; , &#91; &#93; ) DCNL DCSP instance _ ref.update ( values ) DCNL DCSP def _ get _ sec _ group _ models ( session , security _ groups ) : DCNL DCSP DCSP models = &#91; &#93; DCNL DCSP DCSP ( _ existed , default _ group ) = security _ group _ ensure _ default ( context , session = session ) DCNL DCSP DCSP if ( &apos; default &apos; in security _ groups ) : DCNL DCSP DCSP DCSP models.append ( default _ group ) DCNL DCSP DCSP DCSP security _ groups = &#91; x for x in security _ groups if ( x ! = &apos; default &apos; ) &#93; DCNL DCSP DCSP if security _ groups : DCNL DCSP DCSP DCSP models.extend ( _ security _ group _ get _ by _ names ( context , session , context.project _ id , security _ groups ) ) DCNL DCSP DCSP return models DCNL DCSP session = get _ session ( ) DCNL DCSP with session.begin ( ) : DCNL DCSP DCSP if ( &apos; hostname &apos; in values ) : DCNL DCSP DCSP DCSP _ validate _ unique _ server _ name ( context , session , values &#91; &apos; hostname &apos; &#93; ) DCNL DCSP DCSP instance _ ref.security _ groups = _ get _ sec _ group _ models ( session , security _ groups ) DCNL DCSP DCSP instance _ ref.save ( session = session ) DCNL DCSP ec2 _ instance _ create ( context , instance _ ref &#91; &apos; uuid &apos; &#93; ) DCNL DCSP return instance _ ref
DCSP validate _ is _ mapping ( &apos; update &apos; , update ) DCNL DCSP if ( not update ) : DCNL DCSP DCSP raise ValueError ( &apos; update DCSP only DCSP works DCSP with DCSP $ DCSP operators &apos; ) DCNL DCSP first = next ( iter ( update ) ) DCNL DCSP if ( not first.startswith ( &apos; $ &apos; ) ) : DCNL DCSP DCSP raise ValueError ( &apos; update DCSP only DCSP works DCSP with DCSP $ DCSP operators &apos; )
DCSP for ch in chunked : DCNL DCSP DCSP ch.append ( u &apos;O &apos; ) DCNL DCSP for ( i , chunk ) in enumerate ( chunked ) : DCNL DCSP DCSP if ( chunk &#91; 2 &#93; .endswith ( u &apos;PP &apos; ) and ( chunk &#91; ( -1 ) &#93; = = u &apos;O &apos; ) ) : DCNL DCSP DCSP DCSP if ( ( i &lt; ( len ( chunked ) - 1 ) ) and ( chunked &#91; ( i + 1 ) &#93; &#91; 2 &#93; .endswith ( ( u &apos;NP &apos; , u &apos;PP &apos; ) ) or ( chunked &#91; ( i + 1 ) &#93; &#91; 1 &#93; in ( u &apos;VBG &apos; , u &apos;VBN &apos; ) ) ) ) : DCNL DCSP DCSP DCSP DCSP chunk &#91; ( -1 ) &#93; = u &apos;B-PNP &apos; DCNL DCSP DCSP DCSP DCSP pp = True DCNL DCSP DCSP DCSP DCSP for ch in chunked &#91; ( i + 1 ) : &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( not ( ch &#91; 2 &#93; .endswith ( ( u &apos;NP &apos; , u &apos;PP &apos; ) ) or ( ch &#91; 1 &#93; in ( u &apos;VBG &apos; , u &apos;VBN &apos; ) ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP if ( ch &#91; 2 &#93; .endswith ( u &apos;PP &apos; ) and pp ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ch &#91; ( -1 ) &#93; = u &apos;I-PNP &apos; DCNL DCSP DCSP DCSP DCSP DCSP if ( not ch &#91; 2 &#93; .endswith ( u &apos;PP &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ch &#91; ( -1 ) &#93; = u &apos;I-PNP &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP pp = False DCNL DCSP return chunked
DCSP args = ops.copy ( ) DCNL DCSP args.update ( _ dict ) DCNL DCSP args.update ( kw ) DCNL DCSP for ( k , v ) in list ( args.items ( ) ) : DCNL DCSP DCSP if hasattr ( v , &apos; im &apos; ) : DCNL DCSP DCSP DCSP args &#91; k &#93; = _ Operand ( v ) DCNL DCSP out = builtins.eval ( expression , args ) DCNL DCSP try : DCNL DCSP DCSP return out.im DCNL DCSP except AttributeError : DCNL DCSP DCSP return out
DCSP use _ numexpr = ( use _ numexpr and _ bool _ arith _ check ( op _ str , a , b ) ) DCNL DCSP if use _ numexpr : DCNL DCSP DCSP return _ evaluate ( op , op _ str , a , b , raise _ on _ error = raise _ on _ error , * * eval _ kwargs ) DCNL DCSP return _ evaluate _ standard ( op , op _ str , a , b , raise _ on _ error = raise _ on _ error )
DCSP with gzip _ open ( archive _ path , &apos; wb &apos; ) as archive : DCNL DCSP DCSP if os.path.isfile ( source _ path ) : DCNL DCSP DCSP DCSP with open ( source _ path , &apos; rb &apos; ) as source : DCNL DCSP DCSP DCSP DCSP copyfileobj ( source , archive )
DCSP if ( ( value _ to _ mask = = &apos; NaN &apos; ) or np.isnan ( value _ to _ mask ) ) : DCNL DCSP DCSP return np.isnan ( X ) DCNL DCSP else : DCNL DCSP DCSP return ( X = = value _ to _ mask )
DCSP x = T.ftensor4 ( &apos; inputs &apos; ) DCNL DCSP ops = &#91; relu _ ( x ) .sum ( ) , relu ( x ) .sum ( ) , relu _ _ ( x ) .sum ( ) , T.grad ( relu _ ( x ) .sum ( ) , x ) , T.grad ( relu ( x ) .sum ( ) , x ) , T.grad ( relu _ _ ( x ) .sum ( ) , x ) &#93; DCNL DCSP names = &#91; &apos; fprop _ old &apos; , &apos; fprop _ alter &apos; , &apos; fprop _ alter2 &apos; , &apos; grad _ old &apos; , &apos; grad _ alter &apos; , &apos; grad _ alter2 &apos; &#93; DCNL DCSP value = numpy.random.uniform ( size = ( 512 , 32 , 32 , 100 ) ) .astype ( floatX ) DCNL DCSP times = &#91; &#93; DCNL DCSP for ( op , name ) in zip ( ops , names ) : DCNL DCSP DCSP f = theano.function ( inputs = &#91; x &#93; , outputs = op , name = name ) DCNL DCSP DCSP n _ loops = 10 DCNL DCSP DCSP t0 = time.time ( ) DCNL DCSP DCSP for i in range ( n _ loops ) : DCNL DCSP DCSP DCSP f ( value ) DCNL DCSP DCSP t1 = time.time ( ) DCNL DCSP DCSP benchmark = ( t1 - t0 ) DCNL DCSP DCSP times.append ( benchmark ) DCNL DCSP DCSP print ( name ) DCNL DCSP DCSP theano.printing.debugprint ( f , print _ type = True ) DCNL DCSP print ( names ) DCNL DCSP print ( times )
DCSP open _ flag = ( ( open _ for _ write and &apos; c &apos; ) or &apos; r &apos; ) DCNL DCSP sto _ filepath = path.join ( package _ dirpath , PARSER _ RESULT _ STORE ) DCNL DCSP return shelve _ open ( sto _ filepath , flag = open _ flag )
DCSP alphabet = &apos; ABCDEFGHIJKLMNOPQRSTUVWXYZ &apos; DCNL DCSP if ( colx &lt; = 25 ) : DCNL DCSP DCSP return alphabet &#91; colx &#93; DCNL DCSP else : DCNL DCSP DCSP ( xdiv26 , xmod26 ) = divmod ( colx , 26 ) DCNL DCSP DCSP return ( alphabet &#91; ( xdiv26 - 1 ) &#93; + alphabet &#91; xmod26 &#93; )
DCSP if isinstance ( b , six.string _ types ) : DCNL DCSP DCSP b = b.lower ( ) DCNL DCSP if ( ( b is None ) or ( b = = u &apos;none &apos; ) ) : DCNL DCSP DCSP return None DCNL DCSP if ( b in ( u &apos;t &apos; , u &apos;y &apos; , u &apos;yes &apos; , u &apos;on &apos; , u &apos;true &apos; , u &apos; 1 &apos; , 1 , True ) ) : DCNL DCSP DCSP return True DCNL DCSP elif ( b in ( u &apos;f &apos; , u &apos;n &apos; , u &apos;no &apos; , u &apos;off &apos; , u &apos;false &apos; , u &apos; 0 &apos; , 0 , False ) ) : DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( u &apos;Could DCSP not DCSP convert DCSP &quot; % s &quot; DCSP to DCSP boolean &apos; % b ) )
DCSP if ( not hasattr ( response , &apos; seek &apos; ) ) : DCNL DCSP DCSP wrapper _ class = get _ seek _ wrapper _ class ( response ) DCNL DCSP DCSP response = wrapper _ class ( response ) DCNL DCSP assert hasattr ( response , &apos; get _ data &apos; ) DCNL DCSP return response
DCSP ( suffix , mode , type _ ) = details DCNL DCSP if ( mode and ( ( not mode.startswith ( ( &apos; r &apos; , &apos; U &apos; ) ) ) or ( &apos; + &apos; in mode ) ) ) : DCNL DCSP DCSP raise ValueError ( &apos; invalid DCSP file DCSP open DCSP mode DCSP { ! r } &apos; .format ( mode ) ) DCNL DCSP elif ( ( file is None ) and ( type _ in { PY _ SOURCE , PY _ COMPILED } ) ) : DCNL DCSP DCSP msg = &apos; file DCSP object DCSP required DCSP for DCSP import DCSP ( type DCSP code DCSP { } ) &apos; .format ( type _ ) DCNL DCSP DCSP raise ValueError ( msg ) DCNL DCSP elif ( type _ = = PY _ SOURCE ) : DCNL DCSP DCSP return load _ source ( name , filename , file ) DCNL DCSP elif ( type _ = = PY _ COMPILED ) : DCNL DCSP DCSP return load _ compiled ( name , filename , file ) DCNL DCSP elif ( ( type _ = = C _ EXTENSION ) and ( load _ dynamic is not None ) ) : DCNL DCSP DCSP if ( file is None ) : DCNL DCSP DCSP DCSP with open ( filename , &apos; rb &apos; ) as opened _ file : DCNL DCSP DCSP DCSP DCSP return load _ dynamic ( name , filename , opened _ file ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return load _ dynamic ( name , filename , file ) DCNL DCSP elif ( type _ = = PKG _ DIRECTORY ) : DCNL DCSP DCSP return load _ package ( name , filename ) DCNL DCSP elif ( type _ = = C _ BUILTIN ) : DCNL DCSP DCSP return init _ builtin ( name ) DCNL DCSP elif ( type _ = = PY _ FROZEN ) : DCNL DCSP DCSP return init _ frozen ( name ) DCNL DCSP else : DCNL DCSP DCSP msg = &quot; Don &apos;t DCSP know DCSP how DCSP to DCSP import DCSP { } DCSP ( type DCSP code DCSP { } ) &quot; .format ( name , type _ ) DCNL DCSP DCSP raise ImportError ( msg , name = name )
DCSP def _ iterate ( test _ suite _ or _ case ) : DCNL DCSP DCSP &apos; Iterate DCSP through DCSP all DCSP the DCSP test DCSP cases DCSP in DCSP `test _ suite _ or _ case` . &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP suite = iter ( test _ suite _ or _ case ) DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP ( yield test _ suite _ or _ case ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for test in suite : DCNL DCSP DCSP DCSP DCSP for subtest in _ iterate ( test ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield subtest ) DCNL DCSP feconf.PLATFORM = &apos; gae &apos; DCNL DCSP for directory in DIRS _ TO _ ADD _ TO _ SYS _ PATH : DCNL DCSP DCSP if ( not os.path.exists ( os.path.dirname ( directory ) ) ) : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Directory DCSP % s DCSP does DCSP not DCSP exist . &apos; % directory ) ) DCNL DCSP DCSP sys.path.insert ( 0 , directory ) DCNL DCSP import dev _ appserver DCNL DCSP dev _ appserver.fix _ sys _ path ( ) DCNL DCSP parsed _ args = _ PARSER.parse _ args ( ) DCNL DCSP suites = create _ test _ suites ( parsed _ args.test _ target ) DCNL DCSP results = &#91; unittest.TextTestRunner ( verbosity = 2 ) .run ( suite ) for suite in suites &#93; DCNL DCSP tests _ run = 0 DCNL DCSP for result in results : DCNL DCSP DCSP tests _ run + = result.testsRun DCNL DCSP DCSP if ( result.errors or result.failures ) : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Test DCSP suite DCSP failed : DCSP % s DCSP tests DCSP run , DCSP % s DCSP errors , DCSP % s DCSP failures . &apos; % ( result.testsRun , len ( result.errors ) , len ( result.failures ) ) ) ) DCNL DCSP if ( tests _ run = = 0 ) : DCNL DCSP DCSP raise Exception ( &apos; No DCSP tests DCSP were DCSP run . &apos; )
DCSP if ( not ccx ) : DCNL DCSP DCSP raise Http404 DCNL DCSP action = request.POST.get ( &apos; enrollment-button &apos; ) DCNL DCSP identifiers _ raw = request.POST.get ( &apos; student-ids &apos; ) DCNL DCSP identifiers = _ split _ input _ list ( identifiers _ raw ) DCNL DCSP email _ students = ( &apos; email-students &apos; in request.POST ) DCNL DCSP course _ key = CCXLocator.from _ course _ locator ( course.id , unicode ( ccx.id ) ) DCNL DCSP email _ params = get _ email _ params ( course , auto _ enroll = True , course _ key = course _ key , display _ name = ccx.display _ name ) DCNL DCSP ccx _ students _ enrolling _ center ( action , identifiers , email _ students , course _ key , email _ params , ccx.coach ) DCNL DCSP url = reverse ( &apos; ccx _ coach _ dashboard &apos; , kwargs = { &apos; course _ id &apos; : course _ key } ) DCNL DCSP return redirect ( url )
DCSP if ( enum is None ) : DCNL DCSP DCSP return num DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return socket.AddressType ( num ) DCNL DCSP DCSP except ( ValueError , AttributeError ) : DCNL DCSP DCSP DCSP return num
DCSP return ( token &#91; : 3 &#93; = = PKI _ ASN1 _ PREFIX )
DCSP records = &#91; &#93; DCNL DCSP if ( python _ dict or idict ) : DCNL DCSP DCSP variables = { } DCNL DCSP else : DCNL DCSP DCSP variables = AttrDict ( ) DCNL DCSP f = open ( file _ name , &apos; rb &apos; ) DCNL DCSP signature = _ read _ bytes ( f , 2 ) DCNL DCSP if ( signature ! = &apos; SR &apos; ) : DCNL DCSP DCSP raise Exception ( ( &apos; Invalid DCSP SIGNATURE : DCSP % s &apos; % signature ) ) DCNL DCSP recfmt = _ read _ bytes ( f , 2 ) DCNL DCSP if ( recfmt = = &apos; \ x00 \ x04 &apos; ) : DCNL DCSP DCSP pass DCNL DCSP elif ( recfmt = = &apos; \ x00 \ x06 &apos; ) : DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print ( &apos; IDL DCSP Save DCSP file DCSP is DCSP compressed &apos; ) DCNL DCSP DCSP if uncompressed _ file _ name : DCNL DCSP DCSP DCSP fout = open ( uncompressed _ file _ name , &apos; w + b &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fout = tempfile.NamedTemporaryFile ( suffix = &apos; .sav &apos; ) DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print ( ( &apos; DCSP - &gt; DCSP expanding DCSP to DCSP % s &apos; % fout.name ) ) DCNL DCSP DCSP fout.write ( &apos; SR \ x00 \ x04 &apos; ) DCNL DCSP DCSP while True : DCNL DCSP DCSP DCSP rectype = _ read _ long ( f ) DCNL DCSP DCSP DCSP fout.write ( struct.pack ( &apos; &gt; l &apos; , int ( rectype ) ) ) DCNL DCSP DCSP DCSP nextrec = _ read _ uint32 ( f ) DCNL DCSP DCSP DCSP nextrec + = ( _ read _ uint32 ( f ) * ( 2 * * 32 ) ) DCNL DCSP DCSP DCSP unknown = f.read ( 4 ) DCNL DCSP DCSP DCSP if ( RECTYPE _ DICT &#91; rectype &#93; = = &apos; END _ MARKER &apos; ) : DCNL DCSP DCSP DCSP DCSP fout.write ( struct.pack ( &apos; &gt; I &apos; , ( int ( nextrec ) % ( 2 * * 32 ) ) ) ) DCNL DCSP DCSP DCSP DCSP fout.write ( struct.pack ( &apos; &gt; I &apos; , int ( ( ( nextrec - ( nextrec % ( 2 * * 32 ) ) ) / ( 2 * * 32 ) ) ) ) ) DCNL DCSP DCSP DCSP DCSP fout.write ( unknown ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP pos = f.tell ( ) DCNL DCSP DCSP DCSP rec _ string = zlib.decompress ( f.read ( ( nextrec - pos ) ) ) DCNL DCSP DCSP DCSP nextrec = ( ( fout.tell ( ) + len ( rec _ string ) ) + 12 ) DCNL DCSP DCSP DCSP fout.write ( struct.pack ( &apos; &gt; I &apos; , int ( ( nextrec % ( 2 * * 32 ) ) ) ) ) DCNL DCSP DCSP DCSP fout.write ( struct.pack ( &apos; &gt; I &apos; , int ( ( ( nextrec - ( nextrec % ( 2 * * 32 ) ) ) / ( 2 * * 32 ) ) ) ) ) DCNL DCSP DCSP DCSP fout.write ( unknown ) DCNL DCSP DCSP DCSP fout.write ( rec _ string ) DCNL DCSP DCSP f.close ( ) DCNL DCSP DCSP f = fout DCNL DCSP DCSP f.seek ( 4 ) DCNL DCSP else : DCNL DCSP DCSP raise Exception ( ( &apos; Invalid DCSP RECFMT : DCSP % s &apos; % recfmt ) ) DCNL DCSP while True : DCNL DCSP DCSP r = _ read _ record ( f ) DCNL DCSP DCSP records.append ( r ) DCNL DCSP DCSP if ( &apos; end &apos; in r ) : DCNL DCSP DCSP DCSP if r &#91; &apos; end &apos; &#93; : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP f.close ( ) DCNL DCSP heap = { } DCNL DCSP for r in records : DCNL DCSP DCSP if ( r &#91; &apos; rectype &apos; &#93; = = &apos; HEAP _ DATA &apos; ) : DCNL DCSP DCSP DCSP heap &#91; r &#91; &apos; heap _ index &apos; &#93; &#93; = r &#91; &apos; data &apos; &#93; DCNL DCSP for r in records : DCNL DCSP DCSP if ( r &#91; &apos; rectype &apos; &#93; = = &apos; VARIABLE &apos; ) : DCNL DCSP DCSP DCSP ( replace , new ) = _ replace _ heap ( r &#91; &apos; data &apos; &#93; , heap ) DCNL DCSP DCSP DCSP if replace : DCNL DCSP DCSP DCSP DCSP r &#91; &apos; data &apos; &#93; = new DCNL DCSP DCSP DCSP variables &#91; r &#91; &apos; varname &apos; &#93; .lower ( ) &#93; = r &#91; &apos; data &apos; &#93; DCNL DCSP if verbose : DCNL DCSP DCSP for record in records : DCNL DCSP DCSP DCSP if ( record &#91; &apos; rectype &apos; &#93; = = &apos; TIMESTAMP &apos; ) : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Date : DCSP % s &apos; % record &#91; &apos; date &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; User : DCSP % s &apos; % record &#91; &apos; user &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Host : DCSP % s &apos; % record &#91; &apos; host &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP for record in records : DCNL DCSP DCSP DCSP if ( record &#91; &apos; rectype &apos; &#93; = = &apos; VERSION &apos; ) : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Format : DCSP % s &apos; % record &#91; &apos; format &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Architecture : DCSP % s &apos; % record &#91; &apos; arch &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Operating DCSP System : DCSP % s &apos; % record &#91; &apos; os &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; IDL DCSP Version : DCSP % s &apos; % record &#91; &apos; release &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP for record in records : DCNL DCSP DCSP DCSP if ( record &#91; &apos; rectype &apos; &#93; = = &apos; IDENTIFICATON &apos; ) : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Author : DCSP % s &apos; % record &#91; &apos; author &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Title : DCSP % s &apos; % record &#91; &apos; title &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; ID DCSP Code : DCSP % s &apos; % record &#91; &apos; idcode &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP for record in records : DCNL DCSP DCSP DCSP if ( record &#91; &apos; rectype &apos; &#93; = = &apos; DESCRIPTION &apos; ) : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP DCSP DCSP print ( ( &apos; Description : DCSP % s &apos; % record &#91; &apos; description &apos; &#93; ) ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP print ( ( &apos; Successfully DCSP read DCSP % i DCSP records DCSP of DCSP which : &apos; % len ( records ) ) ) DCNL DCSP DCSP rectypes = &#91; r &#91; &apos; rectype &apos; &#93; for r in records &#93; DCNL DCSP DCSP for rt in set ( rectypes ) : DCNL DCSP DCSP DCSP if ( rt ! = &apos; END _ MARKER &apos; ) : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; DCSP - DCSP % i DCSP are DCSP of DCSP type DCSP % s &apos; % ( rectypes.count ( rt ) , rt ) ) ) DCNL DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP DCSP if ( &apos; VARIABLE &apos; in rectypes ) : DCNL DCSP DCSP DCSP print ( &apos; Available DCSP variables : &apos; ) DCNL DCSP DCSP DCSP for var in variables : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; DCSP - DCSP % s DCSP &#91; % s &#93; &apos; % ( var , type ( variables &#91; var &#93; ) ) ) ) DCNL DCSP DCSP DCSP print ( ( &apos; -&apos; * 50 ) ) DCNL DCSP if idict : DCNL DCSP DCSP for var in variables : DCNL DCSP DCSP DCSP idict &#91; var &#93; = variables &#91; var &#93; DCNL DCSP DCSP return idict DCNL DCSP else : DCNL DCSP DCSP return variables
DCSP if ( in _ bash ( ) and string ) : DCNL DCSP DCSP return &apos; &quot; { 0 } &quot; &apos; .format ( string ) DCNL DCSP return string
DCSP if engine.policies : DCNL DCSP DCSP redaction _ filter = RedactionFilter ( engine ) DCNL DCSP DCSP for handler in logger.handlers : DCNL DCSP DCSP DCSP handler.addFilter ( redaction _ filter )
DCSP return ( &apos; % s . % s : % d &apos; % ( model . _ meta.app _ label , model . _ meta.model _ name , getattr ( instance _ or _ pk , &apos; pk &apos; , instance _ or _ pk ) ) )
DCSP if ( boundary is None ) : DCNL DCSP DCSP boundary = ( &apos; ---------------WerkzeugFormPart _ % s % s &apos; % ( time ( ) , random ( ) ) ) DCNL DCSP _ closure = &#91; BytesIO ( ) , 0 , False &#93; DCNL DCSP if use _ tempfile : DCNL DCSP DCSP def write _ binary ( string ) : DCNL DCSP DCSP DCSP ( stream , total _ length , on _ disk ) = _ closure DCNL DCSP DCSP DCSP if on _ disk : DCNL DCSP DCSP DCSP DCSP stream.write ( string ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP length = len ( string ) DCNL DCSP DCSP DCSP DCSP if ( ( length + _ closure &#91; 1 &#93; ) &lt; = threshold ) : DCNL DCSP DCSP DCSP DCSP DCSP stream.write ( string ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP new _ stream = TemporaryFile ( &apos; wb + &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP new _ stream.write ( stream.getvalue ( ) ) DCNL DCSP DCSP DCSP DCSP DCSP new _ stream.write ( string ) DCNL DCSP DCSP DCSP DCSP DCSP _ closure &#91; 0 &#93; = new _ stream DCNL DCSP DCSP DCSP DCSP DCSP _ closure &#91; 2 &#93; = True DCNL DCSP DCSP DCSP DCSP _ closure &#91; 1 &#93; = ( total _ length + length ) DCNL DCSP else : DCNL DCSP DCSP write _ binary = _ closure &#91; 0 &#93; .write DCNL DCSP def write ( string ) : DCNL DCSP DCSP write _ binary ( string.encode ( charset ) ) DCNL DCSP if ( not isinstance ( values , MultiDict ) ) : DCNL DCSP DCSP values = MultiDict ( values ) DCNL DCSP for ( key , values ) in iterlists ( values ) : DCNL DCSP DCSP for value in values : DCNL DCSP DCSP DCSP write ( ( &apos; -- % s \ r \ nContent-Disposition : DCSP form-data ; DCSP name = &quot; % s &quot; &apos; % ( boundary , key ) ) ) DCNL DCSP DCSP DCSP reader = getattr ( value , &apos; read &apos; , None ) DCNL DCSP DCSP DCSP if ( reader is not None ) : DCNL DCSP DCSP DCSP DCSP filename = getattr ( value , &apos; filename &apos; , getattr ( value , &apos; name &apos; , None ) ) DCNL DCSP DCSP DCSP DCSP content _ type = getattr ( value , &apos; content _ type &apos; , None ) DCNL DCSP DCSP DCSP DCSP if ( content _ type is None ) : DCNL DCSP DCSP DCSP DCSP DCSP content _ type = ( ( filename and mimetypes.guess _ type ( filename ) &#91; 0 &#93; ) or &apos; application / octet-stream &apos; ) DCNL DCSP DCSP DCSP DCSP if ( filename is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP write ( ( &apos; ; DCSP filename = &quot; % s &quot; \ r \ n &apos; % filename ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP write ( &apos; \ r \ n &apos; ) DCNL DCSP DCSP DCSP DCSP write ( ( &apos; Content-Type : DCSP % s \ r \ n \ r \ n &apos; % content _ type ) ) DCNL DCSP DCSP DCSP DCSP while 1 : DCNL DCSP DCSP DCSP DCSP DCSP chunk = reader ( 16384 ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not chunk ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP DCSP write _ binary ( chunk ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( not isinstance ( value , string _ types ) ) : DCNL DCSP DCSP DCSP DCSP DCSP value = str ( value ) DCNL DCSP DCSP DCSP DCSP value = to _ bytes ( value , charset ) DCNL DCSP DCSP DCSP DCSP write ( &apos; \ r \ n \ r \ n &apos; ) DCNL DCSP DCSP DCSP DCSP write _ binary ( value ) DCNL DCSP DCSP DCSP write ( &apos; \ r \ n &apos; ) DCNL DCSP write ( ( &apos; -- % s-- \ r \ n &apos; % boundary ) ) DCNL DCSP length = int ( _ closure &#91; 0 &#93; .tell ( ) ) DCNL DCSP _ closure &#91; 0 &#93; .seek ( 0 ) DCNL DCSP return ( _ closure &#91; 0 &#93; , length , boundary )
DCSP cuda _ dict = dict ( use _ cuda = False , fft _ plan = None , ifft _ plan = None , x _ fft = None , x = None , y _ fft = None , y = None ) DCNL DCSP ( n _ fft _ x , n _ fft _ y ) = ( len ( W ) , new _ len ) DCNL DCSP cuda _ fft _ len _ x = int ( ( ( ( n _ fft _ x - ( n _ fft _ x % 2 ) ) / / 2 ) + 1 ) ) DCNL DCSP cuda _ fft _ len _ y = int ( ( ( ( n _ fft _ y - ( n _ fft _ y % 2 ) ) / / 2 ) + 1 ) ) DCNL DCSP if ( n _ jobs = = &apos; cuda &apos; ) : DCNL DCSP DCSP n _ jobs = 1 DCNL DCSP DCSP init _ cuda ( ) DCNL DCSP DCSP if _ cuda _ capable : DCNL DCSP DCSP DCSP from pycuda import gpuarray DCNL DCSP DCSP DCSP cudafft = _ get _ cudafft ( ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP W = gpuarray.to _ gpu ( ( W &#91; : cuda _ fft _ len _ x &#93; .astype ( &apos; complex _ &apos; ) / n _ fft _ y ) ) DCNL DCSP DCSP DCSP DCSP cuda _ dict.update ( use _ cuda = True , fft _ plan = cudafft.Plan ( n _ fft _ x , np.float64 , np.complex128 ) , ifft _ plan = cudafft.Plan ( n _ fft _ y , np.complex128 , np.float64 ) , x _ fft = gpuarray.zeros ( max ( cuda _ fft _ len _ x , cuda _ fft _ len _ y ) , np.complex128 ) , x = gpuarray.empty ( max ( int ( n _ fft _ x ) , int ( n _ fft _ y ) ) , np.float64 ) ) DCNL DCSP DCSP DCSP DCSP logger.info ( &apos; Using DCSP CUDA DCSP for DCSP FFT DCSP resampling &apos; ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP logger.info ( &apos; CUDA DCSP not DCSP used , DCSP could DCSP not DCSP instantiate DCSP memory DCSP ( arrays DCSP may DCSP be DCSP too DCSP large ) , DCSP falling DCSP back DCSP to DCSP n _ jobs = 1 &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP logger.info ( &apos; CUDA DCSP not DCSP used , DCSP CUDA DCSP could DCSP not DCSP be DCSP initialized , DCSP falling DCSP back DCSP to DCSP n _ jobs = 1 &apos; ) DCNL DCSP return ( n _ jobs , cuda _ dict , W )
DCSP if ( not batch _ size ) : DCNL DCSP DCSP batch _ size = FLAGS.batch _ size DCNL DCSP with tf.device ( &apos; / cpu : 0 &apos; ) : DCNL DCSP DCSP ( images , labels ) = batch _ inputs ( dataset , batch _ size , train = True , num _ preprocess _ threads = num _ preprocess _ threads , num _ readers = FLAGS.num _ readers ) DCNL DCSP return ( images , labels )
DCSP target = ( target or &apos; gl2 &apos; ) DCNL DCSP target = target.replace ( &apos; + &apos; , &apos; plus &apos; ) DCNL DCSP ( target , _ , options ) = target.partition ( &apos; DCSP &apos; ) DCNL DCSP debug = ( config &#91; &apos; gl _ debug &apos; &#93; or ( &apos; debug &apos; in options ) ) DCNL DCSP try : DCNL DCSP DCSP mod = _ _ import _ _ ( target , globals ( ) , level = 1 ) DCNL DCSP except ImportError as err : DCNL DCSP DCSP msg = ( &apos; Could DCSP not DCSP import DCSP gl DCSP target DCSP &quot; % s &quot; : \ n % s &apos; % ( target , str ( err ) ) ) DCNL DCSP DCSP raise RuntimeError ( msg ) DCNL DCSP global current _ backend DCNL DCSP current _ backend = mod DCNL DCSP _ clear _ namespace ( ) DCNL DCSP if ( &apos; plus &apos; in target ) : DCNL DCSP DCSP _ copy _ gl _ functions ( mod . _ pyopengl2 , globals ( ) ) DCNL DCSP DCSP _ copy _ gl _ functions ( mod , globals ( ) , True ) DCNL DCSP elif debug : DCNL DCSP DCSP _ copy _ gl _ functions ( _ debug _ proxy , globals ( ) ) DCNL DCSP else : DCNL DCSP DCSP _ copy _ gl _ functions ( mod , globals ( ) )
DCSP mod = fn.module DCNL DCSP fnty = fn.type.pointee DCNL DCSP consts = &#91; lc.MetaDataString.get ( mod , str ( a ) ) for a in fnty.args &#93; DCNL DCSP name = lc.MetaDataString.get ( mod , &apos; kernel _ arg _ base _ type &apos; ) DCNL DCSP return lc.MetaData.get ( mod , ( &#91; name &#93; + consts ) )
DCSP request _ url = base _ url.format ( token , method _ name ) DCNL DCSP logger.debug ( &apos; Request : DCSP method = { 0 } DCSP url = { 1 } DCSP params = { 2 } DCSP files = { 3 } &apos; .format ( method , request _ url , params , files ) ) DCNL DCSP read _ timeout = READ _ TIMEOUT DCNL DCSP connect _ timeout = CONNECT _ TIMEOUT DCNL DCSP if params : DCNL DCSP DCSP if ( &apos; timeout &apos; in params ) : DCNL DCSP DCSP DCSP read _ timeout = ( params &#91; &apos; timeout &apos; &#93; + 10 ) DCNL DCSP DCSP if ( &apos; connect-timeout &apos; in params ) : DCNL DCSP DCSP DCSP connect _ timeout = ( params &#91; &apos; connect-timeout &apos; &#93; + 10 ) DCNL DCSP result = req _ session.request ( method , request _ url , params = params , files = files , timeout = ( connect _ timeout , read _ timeout ) ) DCNL DCSP logger.debug ( &quot; The DCSP server DCSP returned : DCSP &apos; { 0 } &apos; &quot; .format ( result.text.encode ( &apos; utf8 &apos; ) ) ) DCNL DCSP return _ check _ result ( method _ name , result ) &#91; &apos; result &apos; &#93;
DCSP return UnspacedList ( RawNginxParser ( source ) .as _ list ( ) )
DCSP if ( ( size is None ) and ( footprint is None ) and ( structure is None ) ) : DCNL DCSP DCSP raise ValueError ( &apos; size , DCSP footprint DCSP or DCSP structure DCSP must DCSP be DCSP specified &apos; ) DCNL DCSP if ( structure is not None ) : DCNL DCSP DCSP structure = numpy.asarray ( structure ) DCNL DCSP DCSP structure = structure &#91; tuple ( ( &#91; slice ( None , None , ( -1 ) ) &#93; * structure.ndim ) ) &#93; DCNL DCSP if ( footprint is not None ) : DCNL DCSP DCSP footprint = numpy.asarray ( footprint ) DCNL DCSP DCSP footprint = footprint &#91; tuple ( ( &#91; slice ( None , None , ( -1 ) ) &#93; * footprint.ndim ) ) &#93; DCNL DCSP input = numpy.asarray ( input ) DCNL DCSP origin = _ ni _ support . _ normalize _ sequence ( origin , input.ndim ) DCNL DCSP for ii in range ( len ( origin ) ) : DCNL DCSP DCSP origin &#91; ii &#93; = ( - origin &#91; ii &#93; ) DCNL DCSP DCSP if ( footprint is not None ) : DCNL DCSP DCSP DCSP sz = footprint.shape &#91; ii &#93; DCNL DCSP DCSP elif ( structure is not None ) : DCNL DCSP DCSP DCSP sz = structure.shape &#91; ii &#93; DCNL DCSP DCSP elif numpy.isscalar ( size ) : DCNL DCSP DCSP DCSP sz = size DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sz = size &#91; ii &#93; DCNL DCSP DCSP if ( not ( sz &amp; 1 ) ) : DCNL DCSP DCSP DCSP origin &#91; ii &#93; - = 1 DCNL DCSP return filters . _ min _ or _ max _ filter ( input , size , footprint , structure , output , mode , cval , origin , 0 )
DCSP countCols = 0 DCNL DCSP attrs = { } DCNL DCSP for col in cls . _ imdbpySchema.cols : DCNL DCSP DCSP countCols + = 1 DCNL DCSP DCSP if ( col.name = = &apos; id &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not col.foreignKey ) : DCNL DCSP DCSP DCSP attrs &#91; col.name &#93; = MAP _ COLS &#91; col.kind &#93; ( * * col.params ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP thisColName = col.name DCNL DCSP DCSP if thisColName.endswith ( &apos; ID &apos; ) : DCNL DCSP DCSP DCSP thisColName = thisColName &#91; : ( -2 ) &#93; DCNL DCSP DCSP fks = col.foreignKey.split ( &apos; .&apos; , 1 ) DCNL DCSP DCSP foreignTableName = fks &#91; 0 &#93; DCNL DCSP DCSP if ( len ( fks ) = = 2 ) : DCNL DCSP DCSP DCSP foreignColName = fks &#91; 1 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP foreignColName = &apos; id &apos; DCNL DCSP DCSP fk = ForeignKey ( foreignTableName , name = thisColName , default = None ) DCNL DCSP DCSP attrs &#91; thisColName &#93; = fk DCNL DCSP newcls = type ( fakeTableName , ( SQLObject , ) , attrs ) DCNL DCSP return newcls
DCSP try : DCNL DCSP DCSP port = context.session.query ( models _ v2.Port ) .enable _ eagerloads ( False ) .filter _ by ( id = port _ id ) .with _ lockmode ( &apos; update &apos; ) .one ( ) DCNL DCSP DCSP binding = context.session.query ( models.PortBinding ) .enable _ eagerloads ( False ) .filter _ by ( port _ id = port _ id ) .with _ lockmode ( &apos; update &apos; ) .one ( ) DCNL DCSP DCSP return ( port , binding ) DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP return ( None , None )
DCSP parens = 0 DCNL DCSP need _ space = False DCNL DCSP prev _ type = tokenize.OP DCNL DCSP prev _ text = prev _ end = None DCNL DCSP for ( token _ type , text , start , end , line ) in tokens : DCNL DCSP DCSP if ( token _ type in ( tokenize.NL , tokenize.NEWLINE , tokenize.ERRORTOKEN ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( text in ( &apos; ( &apos; , &apos; lambda &apos; ) ) : DCNL DCSP DCSP DCSP parens + = 1 DCNL DCSP DCSP elif ( text = = &apos; ) &apos; ) : DCNL DCSP DCSP DCSP parens - = 1 DCNL DCSP DCSP if need _ space : DCNL DCSP DCSP DCSP if ( start ! = prev _ end ) : DCNL DCSP DCSP DCSP DCSP if ( ( need _ space is not True ) and ( not need _ space &#91; 1 &#93; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( need _ space &#91; 0 &#93; , &apos; E225 DCSP missing DCSP whitespace DCSP around DCSP operator &apos; ) ) DCNL DCSP DCSP DCSP DCSP need _ space = False DCNL DCSP DCSP DCSP elif ( ( text = = &apos; &gt; &apos; ) and ( prev _ text in ( &apos; &lt; &apos; , &apos; -&apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( ( need _ space is True ) or need _ space &#91; 1 &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( prev _ end , &apos; E225 DCSP missing DCSP whitespace DCSP around DCSP operator &apos; ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP ( code , optype ) = ( &apos; E226 &apos; , &apos; arithmetic &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( prev _ text = = &apos; % &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( code , optype ) = ( &apos; E228 &apos; , &apos; modulo &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP elif ( prev _ text not in ARITHMETIC _ OP ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ( code , optype ) = ( &apos; E227 &apos; , &apos; bitwise DCSP or DCSP shift &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP ( yield ( need _ space &#91; 0 &#93; , ( &apos; % s DCSP missing DCSP whitespace DCSP around DCSP % s DCSP operator &apos; % ( code , optype ) ) ) ) DCNL DCSP DCSP DCSP DCSP need _ space = False DCNL DCSP DCSP elif ( ( token _ type = = tokenize.OP ) and ( prev _ end is not None ) ) : DCNL DCSP DCSP DCSP if ( ( text = = &apos; = &apos; ) and parens ) : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP elif ( text in WS _ NEEDED _ OPERATORS ) : DCNL DCSP DCSP DCSP DCSP need _ space = True DCNL DCSP DCSP DCSP elif ( text in UNARY _ OPERATORS ) : DCNL DCSP DCSP DCSP DCSP if ( prev _ type = = tokenize.OP ) : DCNL DCSP DCSP DCSP DCSP DCSP binary _ usage = ( prev _ text in &apos; } &#93; ) &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( prev _ type = = tokenize.NAME ) : DCNL DCSP DCSP DCSP DCSP DCSP binary _ usage = ( prev _ text not in KEYWORDS ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP binary _ usage = ( prev _ type not in SKIP _ TOKENS ) DCNL DCSP DCSP DCSP DCSP if binary _ usage : DCNL DCSP DCSP DCSP DCSP DCSP need _ space = None DCNL DCSP DCSP DCSP elif ( text in WS _ OPTIONAL _ OPERATORS ) : DCNL DCSP DCSP DCSP DCSP need _ space = None DCNL DCSP DCSP DCSP if ( need _ space is None ) : DCNL DCSP DCSP DCSP DCSP need _ space = ( prev _ end , ( start ! = prev _ end ) ) DCNL DCSP DCSP DCSP elif ( need _ space and ( start = = prev _ end ) ) : DCNL DCSP DCSP DCSP DCSP ( yield ( prev _ end , &apos; E225 DCSP missing DCSP whitespace DCSP around DCSP operator &apos; ) ) DCNL DCSP DCSP DCSP DCSP need _ space = False DCNL DCSP DCSP prev _ type = token _ type DCNL DCSP DCSP prev _ text = text DCNL DCSP DCSP prev _ end = end
DCSP return None
DCSP mlp = MLP ( layers = &#91; Linear ( layer _ name = &apos; h &apos; , dim = 5 , irange = 0.01 , max _ col _ norm = 0.01 ) &#93; ) DCNL DCSP conditional = DiagonalGaussian ( mlp = mlp , name = &apos; conditional &apos; ) DCNL DCSP vae = DummyVAE ( ) DCNL DCSP conditional.set _ vae ( vae ) DCNL DCSP input _ space = VectorSpace ( dim = 5 ) DCNL DCSP conditional.initialize _ parameters ( input _ space = input _ space , ndim = 5 ) DCNL DCSP conditional.sample _ from _ epsilon ( ( 2 , 10 , 5 ) )
DCSP return _ from _ text ( text , _ edns _ by _ text )
DCSP if ( not isinstance ( value , datetime.date ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; Cannot DCSP convert DCSP to DCSP datetime DCSP expected DCSP date DCSP value ; DCSP received DCSP % s &apos; % value ) ) DCNL DCSP return datetime.datetime ( value.year , value.month , value.day )
DCSP registrations = models.Node.find ( Q ( &apos; is _ registration &apos; , &apos; eq &apos; , True ) ) DCNL DCSP for registration in registrations : DCNL DCSP DCSP meta = ( registration.registered _ meta or { } ) DCNL DCSP DCSP keys = meta.keys ( ) DCNL DCSP DCSP if ( len ( keys ) ! = 1 ) : DCNL DCSP DCSP DCSP print &apos; Inconsistency : DCSP Number DCSP of DCSP keys DCSP on DCSP project DCSP { } DCSP ( { } ) DCSP ! = DCSP 1 &apos; .format ( registration.title , registration . _ primary _ key ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( keys &#91; 0 &#93; not in known _ schemas ) : DCNL DCSP DCSP DCSP print &apos; Inconsistency : DCSP Registration DCSP schema DCSP { } DCSP on DCSP project DCSP { } DCSP ( { } ) DCSP not DCSP in DCSP known DCSP schemas &apos; .format ( keys &#91; 0 &#93; , registration.title , registration . _ primary _ key )
DCSP xml = to _ xml ( output ) DCNL DCSP n = int ( n ) DCNL DCSP num _ elements = len ( xml.findall ( path ) ) DCNL DCSP if ( num _ elements ! = n ) : DCNL DCSP DCSP errmsg = ( &apos; Expected DCSP to DCSP find DCSP % d DCSP elements DCSP with DCSP path DCSP % s , DCSP but DCSP % d DCSP were DCSP found . &apos; % ( n , path , num _ elements ) ) DCNL DCSP DCSP raise AssertionError ( errmsg )
DCSP with patch.object ( _ LOGGER , &apos; warning &apos; ) as mock _ warn : DCNL DCSP DCSP Config ( None , { &apos; type &apos; : &apos; google _ home &apos; , &apos; host _ ip &apos; : &apos; 123.123.123.123 &apos; , &apos; listen _ port &apos; : 8300 } ) DCNL DCSP DCSP assert mock _ warn.called DCNL DCSP DCSP assert ( mock _ warn.mock _ calls &#91; 0 &#93; &#91; 1 &#93; &#91; 0 &#93; = = &apos; When DCSP targetting DCSP Google DCSP Home , DCSP listening DCSP port DCSP has DCSP to DCSP be DCSP port DCSP 80 &apos; )
DCSP r = tied _ rank ( posterior ) DCNL DCSP num _ positive = len ( &#91; 0 for x in actual if ( x = = 1 ) &#93; ) DCNL DCSP num _ negative = ( len ( actual ) - num _ positive ) DCNL DCSP sum _ positive = sum ( &#91; r &#91; i &#93; for i in range ( len ( r ) ) if ( actual &#91; i &#93; = = 1 ) &#93; ) DCNL DCSP auc = ( ( sum _ positive - ( ( num _ positive * ( num _ positive + 1 ) ) / 2.0 ) ) / ( num _ negative * num _ positive ) ) DCNL DCSP return auc
DCSP if ( derivation.topBevel &lt; = 0.0 ) : DCNL DCSP DCSP return DCNL DCSP bottom = ( derivation.height - derivation.topBevel ) DCNL DCSP top = derivation.height DCNL DCSP groove = &#91; complex ( x , bottom ) , complex ( ( x - derivation.topBevel ) , top ) , complex ( ( x + derivation.topBevel ) , top ) &#93; DCNL DCSP triangle _ mesh.addSymmetricYPath ( negatives , groove , ( 1.0001 * derivation.topRight.imag ) )
DCSP return apiproxy _ stub _ map.apiproxy.GetStub ( &apos; channel &apos; )
DCSP assert context.table , &apos; REQUIRE : DCSP context.table &apos; DCNL DCSP context.table.require _ columns ( &#91; &apos; name &apos; , &apos; tags &apos; &#93; ) DCNL DCSP model _ element _ names = set ( ) DCNL DCSP model _ elements = &#91; &#93; DCNL DCSP for row in context.table.rows : DCNL DCSP DCSP name = row &#91; &apos; name &apos; &#93; .strip ( ) DCNL DCSP DCSP tags = convert _ model _ element _ tags ( row &#91; &apos; tags &apos; &#93; ) DCNL DCSP DCSP assert ( name not in model _ element _ names ) , ( &apos; DUPLICATED : DCSP name = % s &apos; % name ) DCNL DCSP DCSP model _ elements.append ( ModelElement ( name , tags = tags ) ) DCNL DCSP DCSP model _ element _ names.add ( name ) DCNL DCSP context.model _ elements = model _ elements
DCSP if ( barcode _ type = = &apos; variable _ length &apos; ) : DCNL DCSP DCSP var _ len _ barcodes = True DCNL DCSP else : DCNL DCSP DCSP var _ len _ barcodes = False DCNL DCSP if ( barcode _ type = = &apos; 0&apos; ) : DCNL DCSP DCSP has _ barcodes = False DCNL DCSP ( hds , mapping _ data , run _ description , errors , warnings ) = process _ id _ map ( infile , has _ barcodes = has _ barcodes , disable _ primer _ check = disable _ primer _ check , added _ demultiplex _ field = added _ demultiplex _ field , variable _ len _ barcodes = var _ len _ barcodes ) DCNL DCSP if errors : DCNL DCSP DCSP raise ValueError ( ( ( &apos; Errors DCSP were DCSP found DCSP with DCSP mapping DCSP file , DCSP &apos; + &apos; please DCSP run DCSP validate _ mapping _ file.py DCSP to DCSP &apos; ) + &apos; identify DCSP problems . &apos; ) ) DCNL DCSP id _ map = { } DCNL DCSP for curr _ data in mapping _ data : DCNL DCSP DCSP id _ map &#91; curr _ data &#91; 0 &#93; &#93; = { } DCNL DCSP for header in range ( len ( hds ) ) : DCNL DCSP DCSP for curr _ data in mapping _ data : DCNL DCSP DCSP DCSP id _ map &#91; curr _ data &#91; 0 &#93; &#93; &#91; hds &#91; header &#93; &#93; = curr _ data &#91; header &#93; DCNL DCSP barcode _ to _ sample _ id = { } DCNL DCSP primer _ seqs _ lens = { } DCNL DCSP all _ primers = { } DCNL DCSP for ( sample _ id , sample ) in id _ map.items ( ) : DCNL DCSP DCSP if added _ demultiplex _ field : DCNL DCSP DCSP DCSP barcode _ to _ sample _ id &#91; ( ( sample &#91; &apos; BarcodeSequence &apos; &#93; .upper ( ) + &apos; , &apos; ) + sample &#91; added _ demultiplex _ field &#93; ) &#93; = sample _ id DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP barcode _ to _ sample _ id &#91; sample &#91; &apos; BarcodeSequence &apos; &#93; .upper ( ) &#93; = sample _ id DCNL DCSP DCSP if ( not disable _ primer _ check ) : DCNL DCSP DCSP DCSP raw _ primers = sample &#91; &apos; LinkerPrimerSequence &apos; &#93; .upper ( ) .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP if ( len ( raw _ primers &#91; 0 &#93; .strip ( ) ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( ( &apos; No DCSP primers DCSP detected , DCSP please DCSP use DCSP the DCSP &apos; + &apos; -p DCSP parameter DCSP to DCSP disable DCSP primer DCSP detection . &apos; ) ) DCNL DCSP DCSP DCSP expanded _ primers = expand _ degeneracies ( raw _ primers ) DCNL DCSP DCSP DCSP curr _ bc _ primers = { } DCNL DCSP DCSP DCSP for primer in expanded _ primers : DCNL DCSP DCSP DCSP DCSP curr _ bc _ primers &#91; primer &#93; = len ( primer ) DCNL DCSP DCSP DCSP DCSP all _ primers &#91; primer &#93; = len ( primer ) DCNL DCSP DCSP DCSP primer _ seqs _ lens &#91; sample &#91; &apos; BarcodeSequence &apos; &#93; &#93; = curr _ bc _ primers DCNL DCSP return ( hds , id _ map , barcode _ to _ sample _ id , warnings , errors , primer _ seqs _ lens , all _ primers )
DCSP template = get _ templates ( ) &#91; name &#93; DCNL DCSP local _ path = template &#91; u &apos;local _ path &apos; &#93; DCNL DCSP if ( not os.path.exists ( local _ path ) ) : DCNL DCSP DCSP project _ root = os.path.dirname ( os.path.abspath ( _ _ file _ _ ) ) DCNL DCSP DCSP local _ path = os.path.join ( project _ root , local _ path ) DCNL DCSP remote _ path = template &#91; u &apos;remote _ path &apos; &#93; DCNL DCSP reload _ command = template.get ( u &apos;reload _ command &apos; ) DCNL DCSP owner = template.get ( u &apos;owner &apos; ) DCNL DCSP mode = template.get ( u &apos;mode &apos; ) DCNL DCSP remote _ data = u &apos; &apos; DCNL DCSP if exists ( remote _ path ) : DCNL DCSP DCSP with hide ( u &apos;stdout &apos; ) : DCNL DCSP DCSP DCSP remote _ data = sudo ( ( u &apos;cat DCSP % s &apos; % remote _ path ) , show = False ) DCNL DCSP with open ( local _ path , u &apos;r &apos; ) as f : DCNL DCSP DCSP local _ data = f.read ( ) DCNL DCSP DCSP local _ data = re.sub ( u &apos; % ( ? ! \ \ ( \ \ w + \ \ ) s ) &apos; , u &apos; % % &apos; , local _ data ) DCNL DCSP DCSP if ( u &apos; % ( db _ pass ) s &apos; in local _ data ) : DCNL DCSP DCSP DCSP env.db _ pass = db _ pass ( ) DCNL DCSP DCSP local _ data % = env DCNL DCSP clean = ( lambda s : s.replace ( u &apos; \ n &apos; , u &apos; &apos; ) .replace ( u &apos; \ r &apos; , u &apos; &apos; ) .strip ( ) ) DCNL DCSP if ( clean ( remote _ data ) = = clean ( local _ data ) ) : DCNL DCSP DCSP return DCNL DCSP upload _ template ( local _ path , remote _ path , env , use _ sudo = True , backup = False ) DCNL DCSP if owner : DCNL DCSP DCSP sudo ( ( u &apos;chown DCSP % s DCSP % s &apos; % ( owner , remote _ path ) ) ) DCNL DCSP if mode : DCNL DCSP DCSP sudo ( ( u &apos;chmod DCSP % s DCSP % s &apos; % ( mode , remote _ path ) ) ) DCNL DCSP if reload _ command : DCNL DCSP DCSP sudo ( reload _ command )
DCSP root = testdir.tmpdir DCNL DCSP src = root.join ( &apos; src &apos; ) .ensure ( dir = 1 ) DCNL DCSP src.join ( &apos; pytest.ini &apos; ) .write ( &apos; &#91; pytest &#93; &apos; ) DCNL DCSP src.join ( &apos; conftest.py &apos; ) .write ( _ pytest . _ code.Source ( &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP import DCSP pytest \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP @ pytest.fixture \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP def DCSP fix1 ( ) : DCSP pass \ n DCSP DCSP DCSP DCSP &apos; ) ) DCNL DCSP src.join ( &apos; test _ foo.py &apos; ) .write ( _ pytest . _ code.Source ( &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP def DCSP test _ 1 ( fix1 ) : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP pass \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP def DCSP test _ 2 ( out _ of _ reach ) : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP pass \ n DCSP DCSP DCSP DCSP &apos; ) ) DCNL DCSP root.join ( &apos; conftest.py &apos; ) .write ( _ pytest . _ code.Source ( &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP import DCSP pytest \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP @ pytest.fixture \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP def DCSP out _ of _ reach ( ) : DCSP pass \ n DCSP DCSP DCSP DCSP &apos; ) ) DCNL DCSP args = &#91; str ( src ) &#93; DCNL DCSP if confcutdir : DCNL DCSP DCSP args = &#91; ( &apos; --confcutdir = % s &apos; % root.join ( confcutdir ) ) &#93; DCNL DCSP result = testdir.runpytest ( * args ) DCNL DCSP match = &apos; &apos; DCNL DCSP if passed : DCNL DCSP DCSP match + = ( &apos; * % d DCSP passed * &apos; % passed ) DCNL DCSP if error : DCNL DCSP DCSP match + = ( &apos; * % d DCSP error * &apos; % error ) DCNL DCSP result.stdout.fnmatch _ lines ( match )
DCSP country _ code = numobj.country _ code DCNL DCSP if ( region _ code is None ) : DCNL DCSP DCSP return False DCNL DCSP metadata = PhoneMetadata.metadata _ for _ region _ or _ calling _ code ( country _ code , region _ code.upper ( ) ) DCNL DCSP if ( ( metadata is None ) or ( ( region _ code ! = REGION _ CODE _ FOR _ NON _ GEO _ ENTITY ) and ( country _ code ! = country _ code _ for _ valid _ region ( region _ code ) ) ) ) : DCNL DCSP DCSP return False DCNL DCSP nsn = national _ significant _ number ( numobj ) DCNL DCSP return ( _ number _ type _ helper ( nsn , metadata ) ! = PhoneNumberType.UNKNOWN )
DCSP shape = ( 4 , 5 , 9 ) DCNL DCSP a = cuda _ ndarray.CudaNdarray ( theano . _ asarray ( numpy.random.rand ( * shape ) , dtype = &apos; float32 &apos; ) ) DCNL DCSP a = theano . _ asarray ( numpy.random.rand ( * shape ) , dtype = &apos; float32 &apos; ) DCNL DCSP a2 = tcn.shared _ constructor ( a , &apos; a &apos; ) DCNL DCSP a3 = a2.dimshuffle ( 0 , &apos; x &apos; , 1 , 2 ) DCNL DCSP b = tcn.CudaNdarrayType ( ( False , False , False , False ) ) ( ) DCNL DCSP c = ( a3 + b ) DCNL DCSP f = pfunc ( &#91; b &#93; , &#91; c &#93; , mode = mode _ with _ gpu ) DCNL DCSP v = theano . _ asarray ( numpy.random.rand ( shape &#91; 0 &#93; , 5 , * shape &#91; 1 : &#93; ) , dtype = &apos; float32 &apos; ) DCNL DCSP v = cuda _ ndarray.CudaNdarray ( v ) DCNL DCSP out = f ( v ) &#91; 0 &#93; DCNL DCSP assert numpy.allclose ( out , ( a.reshape ( shape &#91; 0 &#93; , 1 , * shape &#91; 1 : &#93; ) + v ) )
DCSP if ( not text ) : DCNL DCSP DCSP return False DCNL DCSP badTriggersOcc = &#91; &#93; DCNL DCSP nbLines = text.count ( &apos; \ n &apos; ) DCNL DCSP if ( nbLines &lt; = 1 ) : DCNL DCSP DCSP log.debug ( u &quot; Ignoring DCSP too DCSP short DCSP lyrics DCSP &apos; { 0 } &apos; &quot; .format ( text ) ) DCNL DCSP DCSP return False DCNL DCSP elif ( nbLines &lt; 5 ) : DCNL DCSP DCSP badTriggersOcc.append ( &apos; too _ short &apos; ) DCNL DCSP else : DCNL DCSP DCSP text = remove _ credits ( text ) DCNL DCSP badTriggers = &#91; &apos; lyrics &apos; , &apos; copyright &apos; , &apos; property &apos; , &apos; links &apos; &#93; DCNL DCSP if artist : DCNL DCSP DCSP badTriggersOcc + = &#91; artist &#93; DCNL DCSP for item in badTriggers : DCNL DCSP DCSP badTriggersOcc + = ( &#91; item &#93; * len ( re.findall ( ( &apos; \ \ W % s \ \ W &apos; % item ) , text , re.I ) ) ) DCNL DCSP if badTriggersOcc : DCNL DCSP DCSP log.debug ( u &apos;Bad DCSP triggers DCSP detected : DCSP { 0 } &apos; .format ( badTriggersOcc ) ) DCNL DCSP return ( len ( badTriggersOcc ) &lt; 2 )
DCSP evoked = evoked.copy ( ) DCNL DCSP if ( ch _ type not in &#91; &apos; mag &apos; , &apos; grad &apos; &#93; ) : DCNL DCSP DCSP raise ValueError ( ( &apos; to _ type DCSP must DCSP be DCSP &quot; mag &quot; DCSP or DCSP &quot; grad &quot; , DCSP not DCSP &quot; % s &quot; &apos; % ch _ type ) ) DCNL DCSP pick _ from = pick _ types ( evoked.info , meg = True , eeg = False , ref _ meg = False ) DCNL DCSP pick _ to = pick _ types ( evoked.info , meg = ch _ type , eeg = False , ref _ meg = False ) DCNL DCSP if ( len ( pick _ to ) = = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; No DCSP channels DCSP matching DCSP the DCSP destination DCSP channel DCSP type DCSP found DCSP in DCSP info . DCSP Please DCSP pass DCSP an DCSP evoked DCSP containingboth DCSP the DCSP original DCSP and DCSP destination DCSP channels . DCSP Only DCSP the DCSP locations DCSP of DCSP the DCSP destination DCSP channels DCSP will DCSP be DCSP used DCSP for DCSP interpolation . &apos; ) DCNL DCSP info _ from = pick _ info ( evoked.info , pick _ from ) DCNL DCSP info _ to = pick _ info ( evoked.info , pick _ to ) DCNL DCSP mapping = _ map _ meg _ channels ( info _ from , info _ to , mode = mode ) DCNL DCSP data = np.dot ( mapping , evoked.data &#91; pick _ from &#93; ) DCNL DCSP evoked.pick _ types ( meg = ch _ type , eeg = False , ref _ meg = False ) DCNL DCSP evoked.data = data DCNL DCSP for ch in evoked.info &#91; &apos; chs &apos; &#93; : DCNL DCSP DCSP ch &#91; &apos; ch _ name &apos; &#93; + = &apos; _ virtual &apos; DCNL DCSP evoked.info. _ update _ redundant ( ) DCNL DCSP evoked.info. _ check _ consistency ( ) DCNL DCSP return evoked
DCSP functions = &#91; &#93; DCNL DCSP for fileName in fileNames : DCNL DCSP DCSP functions + = getFunctionsWithStringByFileName ( fileName , searchString ) DCNL DCSP functions.sort ( ) DCNL DCSP return functions
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ video _ get _ title _ description &apos; , None ) or _ Cfunction ( &apos; libvlc _ video _ get _ title _ description &apos; , ( ( 1 , ) , ) , None , ctypes.POINTER ( TrackDescription ) , MediaPlayer ) ) DCNL DCSP return f ( p _ mi )
DCSP return pattern.match ( value )
DCSP course _ key = CourseKey.from _ string ( course _ key _ string ) DCNL DCSP with modulestore ( ) .bulk _ operations ( course _ key ) : DCNL DCSP DCSP course _ module = get _ course _ and _ check _ access ( course _ key , request.user ) DCNL DCSP DCSP if ( ( &apos; text / html &apos; in request.META.get ( &apos; HTTP _ ACCEPT &apos; , &apos; &apos; ) ) and ( request.method = = &apos; GET &apos; ) ) : DCNL DCSP DCSP DCSP return render _ to _ response ( &apos; settings _ advanced.html &apos; , { &apos; context _ course &apos; : course _ module , &apos; advanced _ dict &apos; : CourseMetadata.fetch ( course _ module ) , &apos; advanced _ settings _ url &apos; : reverse _ course _ url ( &apos; advanced _ settings _ handler &apos; , course _ key ) } ) DCNL DCSP DCSP elif ( &apos; application / json &apos; in request.META.get ( &apos; HTTP _ ACCEPT &apos; , &apos; &apos; ) ) : DCNL DCSP DCSP DCSP if ( request.method = = &apos; GET &apos; ) : DCNL DCSP DCSP DCSP DCSP return JsonResponse ( CourseMetadata.fetch ( course _ module ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP ( is _ valid , errors , updated _ data ) = CourseMetadata.validate _ and _ update _ from _ json ( course _ module , request.json , user = request.user ) DCNL DCSP DCSP DCSP DCSP DCSP if is _ valid : DCNL DCSP DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP _ refresh _ course _ tabs ( request , course _ module ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP except InvalidTabsException as err : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP log.exception ( err.message ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP response _ message = &#91; { &apos; message &apos; : _ ( &apos; An DCSP error DCSP occurred DCSP while DCSP trying DCSP to DCSP save DCSP your DCSP tabs &apos; ) , &apos; model &apos; : { &apos; display _ name &apos; : _ ( &apos; Tabs DCSP Exception &apos; ) } } &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP return JsonResponseBadRequest ( response _ message ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP modulestore ( ) .update _ item ( course _ module , request.user.id ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return JsonResponse ( updated _ data ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return JsonResponseBadRequest ( errors ) DCNL DCSP DCSP DCSP DCSP except ( TypeError , ValueError , InvalidTabsException ) as err : DCNL DCSP DCSP DCSP DCSP DCSP return HttpResponseBadRequest ( django.utils.html.escape ( err.message ) , content _ type = &apos; text / plain &apos; )
DCSP return ( ( sys.platform = = &apos; darwin &apos; ) and ( ( 2 , 6 , 0 ) &lt; = sys.version _ info &lt; ( 2 , 6 , 4 ) ) )
DCSP return str ( uuid.uuid4 ( ) )
DCSP def decorator ( func ) : DCNL DCSP DCSP add _ event _ handler ( name , func , priority ) DCNL DCSP DCSP return func DCNL DCSP return decorator
DCSP ha _ conn = _ get _ conn ( socket ) DCNL DCSP ha _ cmd = haproxy.cmds.showFrontends ( ) DCNL DCSP return ha _ conn.sendCmd ( ha _ cmd )
DCSP src = File.pathname ( src ) DCNL DCSP dst = File.pathname ( dst ) DCNL DCSP if createpath : DCNL DCSP DCSP mkdirs ( os.path.split ( dst ) &#91; 0 &#93; ) DCNL DCSP ifp = open ( src , &apos; rb &apos; ) DCNL DCSP ofp = open ( dst , &apos; wb &apos; ) DCNL DCSP d = ifp.read ( BUFSIZ ) DCNL DCSP while d : DCNL DCSP DCSP ofp.write ( d ) DCNL DCSP DCSP d = ifp.read ( BUFSIZ ) DCNL DCSP ifp.close ( ) DCNL DCSP ofp.close ( ) DCNL DCSP ifp = openrf ( src , &apos; * rb &apos; ) DCNL DCSP ofp = openrf ( dst , &apos; * wb &apos; ) DCNL DCSP d = ifp.read ( BUFSIZ ) DCNL DCSP while d : DCNL DCSP DCSP ofp.write ( d ) DCNL DCSP DCSP d = ifp.read ( BUFSIZ ) DCNL DCSP ifp.close ( ) DCNL DCSP ofp.close ( ) DCNL DCSP srcfss = File.FSSpec ( src ) DCNL DCSP dstfss = File.FSSpec ( dst ) DCNL DCSP sf = srcfss.FSpGetFInfo ( ) DCNL DCSP df = dstfss.FSpGetFInfo ( ) DCNL DCSP ( df.Creator , df.Type ) = ( sf.Creator , sf.Type ) DCNL DCSP if ( forcetype is not None ) : DCNL DCSP DCSP df.Type = forcetype DCNL DCSP df.Flags = ( sf.Flags &amp; COPY _ FLAGS ) DCNL DCSP dstfss.FSpSetFInfo ( df ) DCNL DCSP if copydates : DCNL DCSP DCSP srcfsr = File.FSRef ( src ) DCNL DCSP DCSP dstfsr = File.FSRef ( dst ) DCNL DCSP DCSP ( catinfo , _ , _ , _ ) = srcfsr.FSGetCatalogInfo ( Files.kFSCatInfoAllDates ) DCNL DCSP DCSP dstfsr.FSSetCatalogInfo ( Files.kFSCatInfoAllDates , catinfo )
DCSP from nose.tools import assert _ true DCNL DCSP snr = ( linalg.norm ( desired , ord = &apos; fro &apos; ) / linalg.norm ( ( desired - actual ) , ord = &apos; fro &apos; ) ) DCNL DCSP assert _ true ( ( snr &gt; = tol ) , msg = ( &apos; % f DCSP &lt; DCSP % f &apos; % ( snr , tol ) ) )
DCSP widgets = { } DCNL DCSP widgets.update ( WIDGETS ) DCNL DCSP try : DCNL DCSP DCSP agent = request.user.profile.serviceagent _ set.all ( ) &#91; 0 &#93; DCNL DCSP except Exception : DCNL DCSP DCSP agent = None DCNL DCSP if ( not agent ) : DCNL DCSP DCSP del widgets &#91; &apos; widget _ index _ assigned &apos; &#93; DCNL DCSP return widgets
DCSP train _ path = get _ wmt _ enfr _ train _ set ( data _ dir ) DCNL DCSP dev _ path = get _ wmt _ enfr _ dev _ set ( data _ dir ) DCNL DCSP from _ train _ path = ( train _ path + &apos; .en &apos; ) DCNL DCSP to _ train _ path = ( train _ path + &apos; .fr &apos; ) DCNL DCSP from _ dev _ path = ( dev _ path + &apos; .en &apos; ) DCNL DCSP to _ dev _ path = ( dev _ path + &apos; .fr &apos; ) DCNL DCSP return prepare _ data ( data _ dir , from _ train _ path , to _ train _ path , from _ dev _ path , to _ dev _ path , en _ vocabulary _ size , fr _ vocabulary _ size , tokenizer )
DCSP ret = { } DCNL DCSP imgadm = _ check _ imgadm ( ) DCNL DCSP cmd = &apos; { 0 } DCSP vacuum DCSP -f &apos; .format ( imgadm ) DCNL DCSP res = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd ) DCNL DCSP retcode = res &#91; &apos; retcode &apos; &#93; DCNL DCSP if ( retcode ! = 0 ) : DCNL DCSP DCSP ret &#91; &apos; Error &apos; &#93; = _ exit _ status ( retcode ) DCNL DCSP DCSP return ret DCNL DCSP result = { } DCNL DCSP for image in res &#91; &apos; stdout &apos; &#93; .splitlines ( ) : DCNL DCSP DCSP image = &#91; var for var in image.split ( &apos; DCSP &apos; ) if var &#93; DCNL DCSP DCSP result &#91; image &#91; 2 &#93; &#93; = { &apos; name &apos; : image &#91; 3 &#93; &#91; 1 : image &#91; 3 &#93; .index ( &apos; @ &apos; ) &#93; , &apos; version &apos; : image &#91; 3 &#93; &#91; ( image &#91; 3 &#93; .index ( &apos; @ &apos; ) + 1 ) : ( -1 ) &#93; } DCNL DCSP if verbose : DCNL DCSP DCSP return result DCNL DCSP else : DCNL DCSP DCSP return list ( result.keys ( ) )
DCSP with open _ repo _ closing ( repo ) as r : DCNL DCSP DCSP write _ tree _ diff ( outstream , r.object _ store , old _ tree , new _ tree )
DCSP Q = np.zeros ( ( 6 , 6 ) ) DCNL DCSP ( Q &#91; ( 0 , 1 ) &#93; , Q &#91; ( 1 , 0 ) &#93; ) = ( 1 , 1 ) DCNL DCSP Q &#91; ( 2 , &#91; 0 , 3 &#93; ) &#93; = ( 1 / 2 ) DCNL DCSP ( Q &#91; ( 3 , 4 ) &#93; , Q &#91; ( 4 , 5 ) &#93; , Q &#91; ( 5 , 3 ) &#93; ) = ( 1 , 1 , 1 ) DCNL DCSP Q _ stationary _ dists = np.array ( &#91; &#91; ( 1 / 2 ) , ( 1 / 2 ) , 0 , 0 , 0 , 0 &#93; , &#91; 0 , 0 , 0 , ( 1 / 3 ) , ( 1 / 3 ) , ( 1 / 3 ) &#93; &#93; ) DCNL DCSP testset = &#91; { &apos; P &apos; : np.array ( &#91; &#91; 0.4 , 0.6 &#93; , &#91; 0.2 , 0.8 &#93; &#93; ) , &apos; stationary _ dists &apos; : np.array ( &#91; &#91; 0.25 , 0.75 &#93; &#93; ) , &apos; comm _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; rec _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; is _ irreducible &apos; : True , &apos; period &apos; : 1 , &apos; is _ aperiodic &apos; : True , &apos; cyclic _ classes &apos; : &#91; np.arange ( 2 ) &#93; } , { &apos; P &apos; : sparse.csr _ matrix ( &#91; &#91; 0.4 , 0.6 &#93; , &#91; 0.2 , 0.8 &#93; &#93; ) , &apos; stationary _ dists &apos; : np.array ( &#91; &#91; 0.25 , 0.75 &#93; &#93; ) , &apos; comm _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; rec _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; is _ irreducible &apos; : True , &apos; period &apos; : 1 , &apos; is _ aperiodic &apos; : True , &apos; cyclic _ classes &apos; : &#91; np.arange ( 2 ) &#93; } , { &apos; P &apos; : np.array ( &#91; &#91; 0 , 1 &#93; , &#91; 1 , 0 &#93; &#93; ) , &apos; stationary _ dists &apos; : np.array ( &#91; &#91; 0.5 , 0.5 &#93; &#93; ) , &apos; comm _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; rec _ classes &apos; : &#91; np.arange ( 2 ) &#93; , &apos; is _ irreducible &apos; : True , &apos; period &apos; : 2 , &apos; is _ aperiodic &apos; : False , &apos; cyclic _ classes &apos; : &#91; np.array ( &#91; 0 &#93; ) , np.array ( &#91; 1 &#93; ) &#93; } , { &apos; P &apos; : np.eye ( 2 ) , &apos; stationary _ dists &apos; : np.array ( &#91; &#91; 1 , 0 &#93; , &#91; 0 , 1 &#93; &#93; ) , &apos; comm _ classes &apos; : &#91; np.array ( &#91; 0 &#93; ) , np.array ( &#91; 1 &#93; ) &#93; , &apos; rec _ classes &apos; : &#91; np.array ( &#91; 0 &#93; ) , np.array ( &#91; 1 &#93; ) &#93; , &apos; is _ irreducible &apos; : False , &apos; period &apos; : 1 , &apos; is _ aperiodic &apos; : True } , { &apos; P &apos; : np.array ( &#91; &#91; 1 , 0 &#93; , &#91; 1 , 0 &#93; &#93; ) , &apos; stationary _ dists &apos; : np.array ( &#91; &#91; 1 , 0 &#93; &#93; ) , &apos; comm _ classes &apos; : &#91; np.array ( &#91; 0 &#93; ) , np.array ( &#91; 1 &#93; ) &#93; , &apos; rec _ classes &apos; : &#91; np.array ( &#91; 0 &#93; ) &#93; , &apos; is _ irreducible &apos; : False , &apos; period &apos; : 1 , &apos; is _ aperiodic &apos; : True } , { &apos; P &apos; : Q , &apos; stationary _ dists &apos; : Q _ stationary _ dists , &apos; comm _ classes &apos; : &#91; np.array ( &#91; 0 , 1 &#93; ) , np.array ( &#91; 2 &#93; ) , np.array ( &#91; 3 , 4 , 5 &#93; ) &#93; , &apos; rec _ classes &apos; : &#91; np.array ( &#91; 0 , 1 &#93; ) , np.array ( &#91; 3 , 4 , 5 &#93; ) &#93; , &apos; is _ irreducible &apos; : False , &apos; period &apos; : 6 , &apos; is _ aperiodic &apos; : False } , { &apos; P &apos; : sparse.csr _ matrix ( Q ) , &apos; stationary _ dists &apos; : Q _ stationary _ dists , &apos; comm _ classes &apos; : &#91; np.array ( &#91; 0 , 1 &#93; ) , np.array ( &#91; 2 &#93; ) , np.array ( &#91; 3 , 4 , 5 &#93; ) &#93; , &apos; rec _ classes &apos; : &#91; np.array ( &#91; 0 , 1 &#93; ) , np.array ( &#91; 3 , 4 , 5 &#93; ) &#93; , &apos; is _ irreducible &apos; : False , &apos; period &apos; : 6 , &apos; is _ aperiodic &apos; : False } &#93; DCNL DCSP for test _ dict in testset : DCNL DCSP DCSP mc = MarkovChain ( test _ dict &#91; &apos; P &apos; &#93; ) DCNL DCSP DCSP computed = mc.stationary _ distributions DCNL DCSP DCSP assert _ allclose ( computed , test _ dict &#91; &apos; stationary _ dists &apos; &#93; ) DCNL DCSP DCSP assert ( mc.num _ communication _ classes = = len ( test _ dict &#91; &apos; comm _ classes &apos; &#93; ) ) DCNL DCSP DCSP assert ( mc.is _ irreducible = = test _ dict &#91; &apos; is _ irreducible &apos; &#93; ) DCNL DCSP DCSP assert ( mc.num _ recurrent _ classes = = len ( test _ dict &#91; &apos; rec _ classes &apos; &#93; ) ) DCNL DCSP DCSP list _ of _ array _ equal ( sorted ( mc.communication _ classes , key = ( lambda x : x &#91; 0 &#93; ) ) , sorted ( test _ dict &#91; &apos; comm _ classes &apos; &#93; , key = ( lambda x : x &#91; 0 &#93; ) ) ) DCNL DCSP DCSP list _ of _ array _ equal ( sorted ( mc.recurrent _ classes , key = ( lambda x : x &#91; 0 &#93; ) ) , sorted ( test _ dict &#91; &apos; rec _ classes &apos; &#93; , key = ( lambda x : x &#91; 0 &#93; ) ) ) DCNL DCSP DCSP assert ( mc.period = = test _ dict &#91; &apos; period &apos; &#93; ) DCNL DCSP DCSP assert ( mc.is _ aperiodic = = test _ dict &#91; &apos; is _ aperiodic &apos; &#93; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP list _ of _ array _ equal ( sorted ( mc.cyclic _ classes , key = ( lambda x : x &#91; 0 &#93; ) ) , sorted ( test _ dict &#91; &apos; cyclic _ classes &apos; &#93; , key = ( lambda x : x &#91; 0 &#93; ) ) ) DCNL DCSP DCSP except NotImplementedError : DCNL DCSP DCSP DCSP assert ( mc.is _ irreducible is False ) DCNL DCSP DCSP computed = mc _ compute _ stationary ( test _ dict &#91; &apos; P &apos; &#93; ) DCNL DCSP DCSP assert _ allclose ( computed , test _ dict &#91; &apos; stationary _ dists &apos; &#93; )
DCSP string = decode _ utf8 ( string ) DCNL DCSP string = re.sub ( &quot; ( &#91; a-z &#124; A-Z &#93; ) &apos; ( m &#124; s &#124; ve &#124; re &#124; ll &#124; d ) &quot; , u &apos; \ \ 1 DCSP &lt; QUOTE / &gt; \ \ 2 &apos; , string ) DCNL DCSP string = re.sub ( &quot; ( c &#124; d &#124; gl &#124; j &#124; l &#124; m &#124; n &#124; s &#124; t &#124; un ) &apos; ( &#91; a-z &#124; A-Z &#93; ) &quot; , u &apos; \ \ 1 &lt; QUOTE / &gt; DCSP \ \ 2 &apos; , string ) DCNL DCSP words = ( w.strip ( punctuation ) .replace ( u &apos; &lt; QUOTE / &gt; &apos; , &quot; &apos; &quot; , 1 ) for w in string.split ( ) ) DCNL DCSP words = ( w for w in words if ( ( filter is None ) or ( filter ( w ) is not False ) ) ) DCNL DCSP words = &#91; w for w in words if w &#93; DCNL DCSP return words
DCSP return render ( request , template _ name , { &apos; error _ message &apos; : error _ message } )
DCSP return Type.GetTypeFromProgID ( prog _ id )
DCSP res = socket.getaddrinfo ( hostname , None ) &#91; 0 &#93; DCNL DCSP ( family , socktype , proto , canonname , sockaddr ) = res DCNL DCSP return sockaddr &#91; 0 &#93;
DCSP course = modulestore ( ) .get _ course ( course _ id , depth = 4 ) DCNL DCSP problem _ set = &#91; &#93; DCNL DCSP problem _ info = { } DCNL DCSP c _ subsection = 0 DCNL DCSP for subsection in course.get _ children ( ) &#91; section &#93; .get _ children ( ) : DCNL DCSP DCSP c _ subsection + = 1 DCNL DCSP DCSP c _ unit = 0 DCNL DCSP DCSP for unit in subsection.get _ children ( ) : DCNL DCSP DCSP DCSP c _ unit + = 1 DCNL DCSP DCSP DCSP c _ problem = 0 DCNL DCSP DCSP DCSP for child in unit.get _ children ( ) : DCNL DCSP DCSP DCSP DCSP if ( child.location.category = = &apos; problem &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP c _ problem + = 1 DCNL DCSP DCSP DCSP DCSP DCSP problem _ set.append ( child.location ) DCNL DCSP DCSP DCSP DCSP DCSP problem _ info &#91; child.location &#93; = { &apos; id &apos; : child.location.to _ deprecated _ string ( ) , &apos; x _ value &apos; : &apos; P { 0 } . { 1 } . { 2 } &apos; .format ( c _ subsection , c _ unit , c _ problem ) , &apos; display _ name &apos; : own _ metadata ( child ) .get ( &apos; display _ name &apos; , &apos; &apos; ) } DCNL DCSP grade _ distrib = get _ problem _ set _ grade _ distrib ( course _ id , problem _ set ) DCNL DCSP d3 _ data = &#91; &#93; DCNL DCSP for problem in problem _ set : DCNL DCSP DCSP stack _ data = &#91; &#93; DCNL DCSP DCSP if ( problem in grade _ distrib ) : DCNL DCSP DCSP DCSP max _ grade = float ( grade _ distrib &#91; problem &#93; &#91; &apos; max _ grade &apos; &#93; ) DCNL DCSP DCSP DCSP for ( grade , count _ grade ) in grade _ distrib &#91; problem &#93; &#91; &apos; grade _ distrib &apos; &#93; : DCNL DCSP DCSP DCSP DCSP percent = 0.0 DCNL DCSP DCSP DCSP DCSP if ( max _ grade &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP percent = round ( ( ( grade * 100.0 ) / max _ grade ) , 1 ) DCNL DCSP DCSP DCSP DCSP tooltip = { &apos; type &apos; : &apos; problem &apos; , &apos; problem _ info _ x &apos; : problem _ info &#91; problem &#93; &#91; &apos; x _ value &apos; &#93; , &apos; count _ grade &apos; : count _ grade , &apos; percent &apos; : percent , &apos; problem _ info _ n &apos; : problem _ info &#91; problem &#93; &#91; &apos; display _ name &apos; &#93; , &apos; grade &apos; : grade , &apos; max _ grade &apos; : max _ grade } DCNL DCSP DCSP DCSP DCSP stack _ data.append ( { &apos; color &apos; : percent , &apos; value &apos; : count _ grade , &apos; tooltip &apos; : tooltip } ) DCNL DCSP DCSP d3 _ data.append ( { &apos; xValue &apos; : problem _ info &#91; problem &#93; &#91; &apos; x _ value &apos; &#93; , &apos; stackData &apos; : stack _ data } ) DCNL DCSP return d3 _ data
DCSP _ check _ unknown _ options ( unknown _ options ) DCNL DCSP tol = xtol DCNL DCSP if ( brack is None ) : DCNL DCSP DCSP ( xa , xb , xc , fa , fb , fc , funcalls ) = bracket ( func , args = args ) DCNL DCSP elif ( len ( brack ) = = 2 ) : DCNL DCSP DCSP ( xa , xb , xc , fa , fb , fc , funcalls ) = bracket ( func , xa = brack &#91; 0 &#93; , xb = brack &#91; 1 &#93; , args = args ) DCNL DCSP elif ( len ( brack ) = = 3 ) : DCNL DCSP DCSP ( xa , xb , xc ) = brack DCNL DCSP DCSP if ( xa &gt; xc ) : DCNL DCSP DCSP DCSP ( xc , xa ) = ( xa , xc ) DCNL DCSP DCSP if ( not ( ( xa &lt; xb ) and ( xb &lt; xc ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Not DCSP a DCSP bracketing DCSP interval . &apos; ) DCNL DCSP DCSP fa = func ( * ( ( xa , ) + args ) ) DCNL DCSP DCSP fb = func ( * ( ( xb , ) + args ) ) DCNL DCSP DCSP fc = func ( * ( ( xc , ) + args ) ) DCNL DCSP DCSP if ( not ( ( fb &lt; fa ) and ( fb &lt; fc ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Not DCSP a DCSP bracketing DCSP interval . &apos; ) DCNL DCSP DCSP funcalls = 3 DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Bracketing DCSP interval DCSP must DCSP be DCSP length DCSP 2 DCSP or DCSP 3 DCSP sequence . &apos; ) DCNL DCSP _ gR = 0.61803399 DCNL DCSP _ gC = ( 1.0 - _ gR ) DCNL DCSP x3 = xc DCNL DCSP x0 = xa DCNL DCSP if ( numpy.abs ( ( xc - xb ) ) &gt; numpy.abs ( ( xb - xa ) ) ) : DCNL DCSP DCSP x1 = xb DCNL DCSP DCSP x2 = ( xb + ( _ gC * ( xc - xb ) ) ) DCNL DCSP else : DCNL DCSP DCSP x2 = xb DCNL DCSP DCSP x1 = ( xb - ( _ gC * ( xb - xa ) ) ) DCNL DCSP f1 = func ( * ( ( x1 , ) + args ) ) DCNL DCSP f2 = func ( * ( ( x2 , ) + args ) ) DCNL DCSP funcalls + = 2 DCNL DCSP nit = 0 DCNL DCSP for i in xrange ( maxiter ) : DCNL DCSP DCSP if ( numpy.abs ( ( x3 - x0 ) ) &lt; = ( tol * ( numpy.abs ( x1 ) + numpy.abs ( x2 ) ) ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( f2 &lt; f1 ) : DCNL DCSP DCSP DCSP x0 = x1 DCNL DCSP DCSP DCSP x1 = x2 DCNL DCSP DCSP DCSP x2 = ( ( _ gR * x1 ) + ( _ gC * x3 ) ) DCNL DCSP DCSP DCSP f1 = f2 DCNL DCSP DCSP DCSP f2 = func ( * ( ( x2 , ) + args ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP x3 = x2 DCNL DCSP DCSP DCSP x2 = x1 DCNL DCSP DCSP DCSP x1 = ( ( _ gR * x2 ) + ( _ gC * x0 ) ) DCNL DCSP DCSP DCSP f2 = f1 DCNL DCSP DCSP DCSP f1 = func ( * ( ( x1 , ) + args ) ) DCNL DCSP DCSP funcalls + = 1 DCNL DCSP DCSP nit + = 1 DCNL DCSP if ( f1 &lt; f2 ) : DCNL DCSP DCSP xmin = x1 DCNL DCSP DCSP fval = f1 DCNL DCSP else : DCNL DCSP DCSP xmin = x2 DCNL DCSP DCSP fval = f2 DCNL DCSP return OptimizeResult ( fun = fval , nfev = funcalls , x = xmin , nit = nit , success = ( nit &lt; maxiter ) )
DCSP badge = get _ or _ create _ badge ( badge _ template , year ) DCNL DCSP if badge.is _ awarded _ to ( user ) : DCNL DCSP DCSP return DCNL DCSP qs = Reply.objects.filter ( user = user , created _ _ gte = date ( year , 1 , 1 ) , created _ _ lt = date ( ( year + 1 ) , 1 , 1 ) ) DCNL DCSP if ( qs.count ( ) &gt; = 50 ) : DCNL DCSP DCSP badge.award _ to ( user ) DCNL DCSP DCSP return True
DCSP return remove ( name = name , pkgs = pkgs )
DCSP frames = buildRequestFrames ( headers , data , frameFactory , streamID ) DCNL DCSP return &apos; &apos;.join ( ( f.serialize ( ) for f in frames ) )
DCSP if include _ headers : DCNL DCSP DCSP include _ headers = tuple ( &#91; h.lower ( ) for h in sorted ( include _ headers ) &#93; ) DCNL DCSP cache = _ fingerprint _ cache.setdefault ( request , { } ) DCNL DCSP if ( include _ headers not in cache ) : DCNL DCSP DCSP fp = hashlib.sha1 ( ) DCNL DCSP DCSP fp.update ( request.method ) DCNL DCSP DCSP fp.update ( canonicalize _ url ( request.url ) ) DCNL DCSP DCSP fp.update ( ( request.body or &apos; &apos; ) ) DCNL DCSP DCSP if include _ headers : DCNL DCSP DCSP DCSP for hdr in include _ headers : DCNL DCSP DCSP DCSP DCSP if ( hdr in request.headers ) : DCNL DCSP DCSP DCSP DCSP DCSP fp.update ( hdr ) DCNL DCSP DCSP DCSP DCSP DCSP for v in request.headers.getlist ( hdr ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP fp.update ( v ) DCNL DCSP DCSP cache &#91; include _ headers &#93; = fp.hexdigest ( ) DCNL DCSP return cache &#91; include _ headers &#93;
DCSP warn ( &apos; Test &apos; ) DCNL DCSP eq _ ( &apos; \ nWarning : DCSP Test \ n \ n &apos; , sys.stderr.getvalue ( ) )
DCSP mode = tcgetattr ( fd ) DCNL DCSP mode &#91; IFLAG &#93; = ( mode &#91; IFLAG &#93; &amp; ( ~ ( ( ( ( BRKINT &#124; ICRNL ) &#124; INPCK ) &#124; ISTRIP ) &#124; IXON ) ) ) DCNL DCSP mode &#91; OFLAG &#93; = ( mode &#91; OFLAG &#93; &amp; ( ~ OPOST ) ) DCNL DCSP mode &#91; CFLAG &#93; = ( mode &#91; CFLAG &#93; &amp; ( ~ ( CSIZE &#124; PARENB ) ) ) DCNL DCSP mode &#91; CFLAG &#93; = ( mode &#91; CFLAG &#93; &#124; CS8 ) DCNL DCSP mode &#91; LFLAG &#93; = ( mode &#91; LFLAG &#93; &amp; ( ~ ( ( ( ECHO &#124; ICANON ) &#124; IEXTEN ) &#124; ISIG ) ) ) DCNL DCSP mode &#91; CC &#93; &#91; VMIN &#93; = 1 DCNL DCSP mode &#91; CC &#93; &#91; VTIME &#93; = 0 DCNL DCSP tcsetattr ( fd , when , mode )
DCSP models.get _ apps ( ) DCNL DCSP opts = model . _ meta DCNL DCSP validate _ base ( cls , model ) DCNL DCSP if hasattr ( cls , &apos; list _ display &apos; ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; list _ display &apos; , cls.list _ display ) DCNL DCSP DCSP for ( idx , field ) in enumerate ( cls.list _ display ) : DCNL DCSP DCSP DCSP if ( not callable ( field ) ) : DCNL DCSP DCSP DCSP DCSP if ( not hasattr ( cls , field ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( not hasattr ( model , field ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP opts.get _ field ( field ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP except models.FieldDoesNotExist : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &apos; % s.list _ display &#91; % d &#93; , DCSP % r DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP an DCSP attribute DCSP of DCSP % r DCSP or DCSP found DCSP in DCSP the DCSP model DCSP % r . &apos; % ( cls . _ _ name _ _ , idx , field , cls . _ _ name _ _ , model . _ meta.object _ name ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP f = fetch _ attr ( cls , model , opts , ( &apos; list _ display &#91; % d &#93; &apos; % idx ) , field ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if isinstance ( f , models.ManyToManyField ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ display &#91; % d &#93; &apos; , DCSP &apos; % s &apos; DCSP is DCSP a DCSP ManyToManyField DCSP which DCSP is DCSP not DCSP supported . &quot; % ( cls . _ _ name _ _ , idx , field ) ) ) DCNL DCSP if hasattr ( cls , &apos; list _ display _ links &apos; ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; list _ display _ links &apos; , cls.list _ display _ links ) DCNL DCSP DCSP for ( idx , field ) in enumerate ( cls.list _ display _ links ) : DCNL DCSP DCSP DCSP if ( field not in cls.list _ display ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ display _ links &#91; % d &#93; &apos; DCSP refers DCSP to DCSP &apos; % s &apos; DCSP which DCSP is DCSP not DCSP defined DCSP in DCSP &apos; list _ display &apos; . &quot; % ( cls . _ _ name _ _ , idx , field ) ) ) DCNL DCSP if hasattr ( cls , &apos; list _ filter &apos; ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; list _ filter &apos; , cls.list _ filter ) DCNL DCSP DCSP for ( idx , fpath ) in enumerate ( cls.list _ filter ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP get _ fields _ from _ path ( model , fpath ) DCNL DCSP DCSP DCSP except ( NotRelationField , FieldDoesNotExist ) as e : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ filter &#91; % d &#93; &apos; DCSP refers DCSP to DCSP &apos; % s &apos; DCSP which DCSP does DCSP not DCSP refer DCSP to DCSP a DCSP Field . &quot; % ( cls . _ _ name _ _ , idx , fpath ) ) ) DCNL DCSP if ( hasattr ( cls , &apos; list _ per _ page &apos; ) and ( not isinstance ( cls.list _ per _ page , int ) ) ) : DCNL DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ per _ page &apos; DCSP should DCSP be DCSP a DCSP integer . &quot; % cls . _ _ name _ _ ) ) DCNL DCSP if ( hasattr ( cls , &apos; list _ editable &apos; ) and cls.list _ editable ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; list _ editable &apos; , cls.list _ editable ) DCNL DCSP DCSP for ( idx , field _ name ) in enumerate ( cls.list _ editable ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP field = opts.get _ field _ by _ name ( field _ name ) &#91; 0 &#93; DCNL DCSP DCSP DCSP except models.FieldDoesNotExist : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ editable &#91; % d &#93; &apos; DCSP refers DCSP to DCSP a DCSP field , DCSP &apos; % s &apos; , DCSP not DCSP defined DCSP on DCSP % s . &quot; % ( cls . _ _ name _ _ , idx , field _ name , model . _ _ name _ _ ) ) ) DCNL DCSP DCSP DCSP if ( field _ name not in cls.list _ display ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ editable &#91; % d &#93; &apos; DCSP refers DCSP to DCSP &apos; % s &apos; DCSP which DCSP is DCSP not DCSP defined DCSP in DCSP &apos; list _ display &apos; . &quot; % ( cls . _ _ name _ _ , idx , field _ name ) ) ) DCNL DCSP DCSP DCSP if ( field _ name in cls.list _ display _ links ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s &apos; DCSP cannot DCSP be DCSP in DCSP both DCSP &apos; % s.list _ editable &apos; DCSP and DCSP &apos; % s.list _ display _ links &apos; &quot; % ( field _ name , cls . _ _ name _ _ , cls . _ _ name _ _ ) ) ) DCNL DCSP DCSP DCSP if ( ( not cls.list _ display _ links ) and ( cls.list _ display &#91; 0 &#93; in cls.list _ editable ) ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ editable &#91; % d &#93; &apos; DCSP refers DCSP to DCSP the DCSP first DCSP field DCSP in DCSP list _ display , DCSP &apos; % s &apos; , DCSP which DCSP can &apos;t DCSP be DCSP used DCSP unless DCSP list _ display _ links DCSP is DCSP set . &quot; % ( cls . _ _ name _ _ , idx , cls.list _ display &#91; 0 &#93; ) ) ) DCNL DCSP DCSP DCSP if ( not field.editable ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.list _ editable &#91; % d &#93; &apos; DCSP refers DCSP to DCSP a DCSP field , DCSP &apos; % s &apos; , DCSP which DCSP isn &apos;t DCSP editable DCSP through DCSP the DCSP admin . &quot; % ( cls . _ _ name _ _ , idx , field _ name ) ) ) DCNL DCSP if hasattr ( cls , &apos; search _ fields &apos; ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; search _ fields &apos; , cls.search _ fields ) DCNL DCSP if cls.date _ hierarchy : DCNL DCSP DCSP f = get _ field ( cls , model , opts , &apos; date _ hierarchy &apos; , cls.date _ hierarchy ) DCNL DCSP DCSP if ( not isinstance ( f , ( models.DateField , models.DateTimeField ) ) ) : DCNL DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.date _ hierarchy DCSP is DCSP neither DCSP an DCSP instance DCSP of DCSP DateField DCSP nor DCSP DateTimeField . &quot; % cls . _ _ name _ _ ) ) DCNL DCSP if cls.ordering : DCNL DCSP DCSP check _ isseq ( cls , &apos; ordering &apos; , cls.ordering ) DCNL DCSP DCSP for ( idx , field ) in enumerate ( cls.ordering ) : DCNL DCSP DCSP DCSP if ( ( field = = &apos; ? &apos; ) and ( len ( cls.ordering ) ! = 1 ) ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.ordering &apos; DCSP has DCSP the DCSP random DCSP ordering DCSP marker DCSP &apos; ? &apos; , DCSP but DCSP contains DCSP other DCSP fields DCSP as DCSP well . DCSP Please DCSP either DCSP remove DCSP &apos; ? &apos; DCSP or DCSP the DCSP other DCSP fields . &quot; % cls . _ _ name _ _ ) ) DCNL DCSP DCSP DCSP if ( field = = &apos; ? &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if field.startswith ( &apos; -&apos; ) : DCNL DCSP DCSP DCSP DCSP field = field &#91; 1 : &#93; DCNL DCSP DCSP DCSP if ( &apos; _ _ &apos; in field ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP get _ field ( cls , model , opts , ( &apos; ordering &#91; % d &#93; &apos; % idx ) , field ) DCNL DCSP if hasattr ( cls , &apos; readonly _ fields &apos; ) : DCNL DCSP DCSP check _ readonly _ fields ( cls , model , opts ) DCNL DCSP for attr in ( &apos; list _ select _ related &apos; , &apos; save _ as &apos; , &apos; save _ on _ top &apos; ) : DCNL DCSP DCSP if ( not isinstance ( getattr ( cls , attr ) , bool ) ) : DCNL DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s . % s &apos; DCSP should DCSP be DCSP a DCSP boolean . &quot; % ( cls . _ _ name _ _ , attr ) ) ) DCNL DCSP if hasattr ( cls , &apos; inlines &apos; ) : DCNL DCSP DCSP check _ isseq ( cls , &apos; inlines &apos; , cls.inlines ) DCNL DCSP DCSP for ( idx , inline ) in enumerate ( cls.inlines ) : DCNL DCSP DCSP DCSP if ( not issubclass ( inline , BaseModelAdmin ) ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.inlines &#91; % d &#93; &apos; DCSP does DCSP not DCSP inherit DCSP from DCSP BaseModelAdmin . &quot; % ( cls . _ _ name _ _ , idx ) ) ) DCNL DCSP DCSP DCSP if ( not inline.model ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; model &apos; DCSP is DCSP a DCSP required DCSP attribute DCSP of DCSP &apos; % s.inlines &#91; % d &#93; &apos; . &quot; % ( cls . _ _ name _ _ , idx ) ) ) DCNL DCSP DCSP DCSP if ( not issubclass ( inline.model , models.Model ) ) : DCNL DCSP DCSP DCSP DCSP raise ImproperlyConfigured ( ( &quot; &apos; % s.inlines &#91; % d &#93; .model &apos; DCSP does DCSP not DCSP inherit DCSP from DCSP models.Model. &quot; % ( cls . _ _ name _ _ , idx ) ) ) DCNL DCSP DCSP DCSP validate _ base ( inline , inline.model ) DCNL DCSP DCSP DCSP validate _ inline ( inline , cls , model )
DCSP pass
DCSP return filepath.replace ( &apos; / &apos; , &apos; \ \ &apos; )
DCSP values = &#91; &#93; DCNL DCSP ascii = &#91; &#93; DCNL DCSP offset = 0 DCNL DCSP for ( h , a ) in sixteen ( data ) : DCNL DCSP DCSP if ( h is None ) : DCNL DCSP DCSP DCSP ( yield ( offset , &apos; DCSP &apos; .join ( &#91; &apos; &apos;.join ( values ) , &apos; &apos;.join ( ascii ) &#93; ) ) ) DCNL DCSP DCSP DCSP del values &#91; : &#93; DCNL DCSP DCSP DCSP del ascii &#91; : &#93; DCNL DCSP DCSP DCSP offset + = 16 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP values.append ( h ) DCNL DCSP DCSP DCSP ascii.append ( a )
DCSP dssp = { } DCNL DCSP start = 0 DCNL DCSP keys = &#91; &#93; DCNL DCSP for l in handle.readlines ( ) : DCNL DCSP DCSP sl = l.split ( ) DCNL DCSP DCSP if ( len ( sl ) &lt; 2 ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( sl &#91; 1 &#93; = = &apos; RESIDUE &apos; ) : DCNL DCSP DCSP DCSP start = 1 DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( not start ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( l &#91; 9 &#93; = = &apos; DCSP &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP dssp _ index = int ( l &#91; : 5 &#93; ) DCNL DCSP DCSP resseq = int ( l &#91; 5 : 10 &#93; ) DCNL DCSP DCSP icode = l &#91; 10 &#93; DCNL DCSP DCSP chainid = l &#91; 11 &#93; DCNL DCSP DCSP aa = l &#91; 13 &#93; DCNL DCSP DCSP ss = l &#91; 16 &#93; DCNL DCSP DCSP if ( ss = = &apos; DCSP &apos; ) : DCNL DCSP DCSP DCSP ss = &apos; -&apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP NH _ O _ 1 _ relidx = int ( l &#91; 38 : 45 &#93; ) DCNL DCSP DCSP DCSP NH _ O _ 1 _ energy = float ( l &#91; 46 : 50 &#93; ) DCNL DCSP DCSP DCSP O _ NH _ 1 _ relidx = int ( l &#91; 50 : 56 &#93; ) DCNL DCSP DCSP DCSP O _ NH _ 1 _ energy = float ( l &#91; 57 : 61 &#93; ) DCNL DCSP DCSP DCSP NH _ O _ 2 _ relidx = int ( l &#91; 61 : 67 &#93; ) DCNL DCSP DCSP DCSP NH _ O _ 2 _ energy = float ( l &#91; 68 : 72 &#93; ) DCNL DCSP DCSP DCSP O _ NH _ 2 _ relidx = int ( l &#91; 72 : 78 &#93; ) DCNL DCSP DCSP DCSP O _ NH _ 2 _ energy = float ( l &#91; 79 : 83 &#93; ) DCNL DCSP DCSP DCSP acc = int ( l &#91; 34 : 38 &#93; ) DCNL DCSP DCSP DCSP phi = float ( l &#91; 103 : 109 &#93; ) DCNL DCSP DCSP DCSP psi = float ( l &#91; 109 : 115 &#93; ) DCNL DCSP DCSP except ValueError as exc : DCNL DCSP DCSP DCSP if ( l &#91; 34 &#93; ! = &apos; DCSP &apos; ) : DCNL DCSP DCSP DCSP DCSP shift = l &#91; 34 : &#93; .find ( &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP DCSP NH _ O _ 1 _ relidx = int ( l &#91; ( 38 + shift ) : ( 45 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP NH _ O _ 1 _ energy = float ( l &#91; ( 46 + shift ) : ( 50 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP O _ NH _ 1 _ relidx = int ( l &#91; ( 50 + shift ) : ( 56 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP O _ NH _ 1 _ energy = float ( l &#91; ( 57 + shift ) : ( 61 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP NH _ O _ 2 _ relidx = int ( l &#91; ( 61 + shift ) : ( 67 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP NH _ O _ 2 _ energy = float ( l &#91; ( 68 + shift ) : ( 72 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP O _ NH _ 2 _ relidx = int ( l &#91; ( 72 + shift ) : ( 78 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP O _ NH _ 2 _ energy = float ( l &#91; ( 79 + shift ) : ( 83 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP acc = int ( l &#91; ( 34 + shift ) : ( 38 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP phi = float ( l &#91; ( 103 + shift ) : ( 109 + shift ) &#93; ) DCNL DCSP DCSP DCSP DCSP psi = float ( l &#91; ( 109 + shift ) : ( 115 + shift ) &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise ValueError ( exc ) DCNL DCSP DCSP res _ id = ( &apos; DCSP &apos; , resseq , icode ) DCNL DCSP DCSP dssp &#91; ( chainid , res _ id ) &#93; = ( aa , ss , acc , phi , psi , dssp _ index , NH _ O _ 1 _ relidx , NH _ O _ 1 _ energy , O _ NH _ 1 _ relidx , O _ NH _ 1 _ energy , NH _ O _ 2 _ relidx , NH _ O _ 2 _ energy , O _ NH _ 2 _ relidx , O _ NH _ 2 _ energy ) DCNL DCSP DCSP keys.append ( ( chainid , res _ id ) ) DCNL DCSP return ( dssp , keys )
DCSP def null _ safe _ rl ( expr ) : DCNL DCSP DCSP result = rule ( expr ) DCNL DCSP DCSP if ( result is None ) : DCNL DCSP DCSP DCSP return expr DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return result DCNL DCSP return null _ safe _ rl
DCSP message = escape ( kwd.get ( &apos; message &apos; , &apos; &apos; ) ) DCNL DCSP status = kwd.get ( &apos; status &apos; , &apos; done &apos; ) DCNL DCSP full _ url = ( &apos; % s / find ? % s &apos; % ( search _ url , urllib.urlencode ( { &apos; kwd &apos; : search _ term } ) ) ) DCNL DCSP response = urllib2.urlopen ( full _ url ) DCNL DCSP ldda _ ids = loads ( response.read ( ) ) &#91; &apos; ids &apos; &#93; DCNL DCSP response.close ( ) DCNL DCSP lddas = &#91; trans.sa _ session.query ( trans.app.model.LibraryDatasetDatasetAssociation ) .get ( ldda _ id ) for ldda _ id in ldda _ ids &#93; DCNL DCSP return ( status , message , get _ sorted _ accessible _ library _ items ( trans , cntrller , lddas , &apos; name &apos; ) )
DCSP with gzip.open ( ATLAS _ FILE , &apos; rb &apos; ) as f : DCNL DCSP DCSP line = f.readline ( ) DCNL DCSP DCSP while ( line and line.startswith ( &apos; GRAPH &apos; ) ) : DCNL DCSP DCSP DCSP graph _ index = int ( line &#91; 6 : &#93; .rstrip ( ) ) DCNL DCSP DCSP DCSP line = f.readline ( ) DCNL DCSP DCSP DCSP num _ nodes = int ( line &#91; 6 : &#93; .rstrip ( ) ) DCNL DCSP DCSP DCSP edgelist = &#91; &#93; DCNL DCSP DCSP DCSP line = f.readline ( ) DCNL DCSP DCSP DCSP while ( line and ( not line.startswith ( &apos; GRAPH &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP edgelist.append ( line.rstrip ( ) ) DCNL DCSP DCSP DCSP DCSP line = f.readline ( ) DCNL DCSP DCSP DCSP G = nx.Graph ( ) DCNL DCSP DCSP DCSP G.name = &apos; G { } &apos; .format ( graph _ index ) DCNL DCSP DCSP DCSP G.add _ nodes _ from ( range ( num _ nodes ) ) DCNL DCSP DCSP DCSP G.add _ edges _ from ( ( tuple ( map ( int , e.split ( ) ) ) for e in edgelist ) ) DCNL DCSP DCSP DCSP ( yield G )
DCSP if ( n is None ) : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP return format _ decimal ( n , locale = _ babel _ locale ( _ contextual _ locale ( context ) ) )
DCSP expr _ part = &#91; &#93; DCNL DCSP qexpr _ part = &#91; &#93; DCNL DCSP for arg in e.args : DCNL DCSP DCSP if ( not isinstance ( arg , QExpr ) ) : DCNL DCSP DCSP DCSP expr _ part.append ( arg ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP qexpr _ part.append ( arg ) DCNL DCSP return ( expr _ part , qexpr _ part )
DCSP assert _ equals ( strings.column _ width ( u &apos; \ u3042 \ u3044 \ u3046 \ u3048 \ u304a &apos; ) , 10 )
DCSP def real _ decorator ( function ) : DCNL DCSP DCSP @ wraps ( function ) DCNL DCSP DCSP def wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP DCSP ts = time.time ( ) DCNL DCSP DCSP DCSP for i in range ( num _ tries ) : DCNL DCSP DCSP DCSP DCSP result = function ( * args , * * kwargs ) DCNL DCSP DCSP DCSP te = time.time ( ) DCNL DCSP DCSP DCSP tt = ( ( te - ts ) / num _ tries ) DCNL DCSP DCSP DCSP if verbose : DCNL DCSP DCSP DCSP DCSP log.info ( u &apos; { 0 } DCSP took DCSP { 1 } DCSP s DCSP on DCSP AVERAGE DCSP for DCSP { 2 } DCSP call ( s ) . &apos; .format ( function . _ _ name _ _ , tt , num _ tries ) ) DCNL DCSP DCSP DCSP return ( tt , result ) DCNL DCSP DCSP return wrapper DCNL DCSP return real _ decorator
DCSP input _ factory = factory DCNL DCSP class TheMap ( CheckedPMap , ) : DCNL DCSP DCSP _ _ key _ type _ _ = key _ type DCNL DCSP DCSP _ _ value _ type _ _ = value _ type DCNL DCSP TheMap . _ _ name _ _ = ( ( key _ type . _ _ name _ _ .capitalize ( ) + value _ type . _ _ name _ _ .capitalize ( ) ) + &apos; PMap &apos; ) DCNL DCSP if optional : DCNL DCSP DCSP def mapping _ factory ( argument ) : DCNL DCSP DCSP DCSP if ( argument is None ) : DCNL DCSP DCSP DCSP DCSP return None DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return TheMap ( argument ) DCNL DCSP else : DCNL DCSP DCSP mapping _ factory = TheMap DCNL DCSP if input _ factory : DCNL DCSP DCSP factory = ( lambda x : mapping _ factory ( input _ factory ( x ) ) ) DCNL DCSP else : DCNL DCSP DCSP factory = mapping _ factory DCNL DCSP if ( initial is _ UNDEFINED ) : DCNL DCSP DCSP initial = TheMap ( ) DCNL DCSP else : DCNL DCSP DCSP initial = factory ( initial ) DCNL DCSP return field ( mandatory = True , initial = initial , type = ( optional _ type ( TheMap ) if optional else TheMap ) , factory = factory , invariant = invariant )
DCSP return ( path and ( &apos; / &apos; not in path ) and ( path not in ( &apos; .&apos; , &apos; .. &apos; ) ) )
DCSP os.system ( &apos; cd DCSP build / html ; DCSP rsync DCSP -avz DCSP . DCSP pandas @ pandas.pydata.org : / usr / share / nginx / pandas / pandas-docs / vbench / DCSP -essh &apos; )
DCSP from _ addr = ( from _ addr or settings.FROM _ EMAIL ) DCNL DCSP mailer = ( mailer or tasks.send _ email ) DCNL DCSP subject = mail.subject ( * * context ) DCNL DCSP message = ( mail.text ( * * context ) if ( mimetype in ( &apos; plain &apos; , &apos; txt &apos; ) ) else mail.html ( * * context ) ) DCNL DCSP ttls = login = ( not settings.DEBUG _ MODE ) DCNL DCSP logger.debug ( &apos; Sending DCSP email ... &apos; ) DCNL DCSP logger.debug ( u &apos;To : DCSP { to _ addr } \ nFrom : DCSP { from _ addr } \ nSubject : DCSP { subject } \ nMessage : DCSP { message } &apos; .format ( * * locals ( ) ) ) DCNL DCSP kwargs = dict ( from _ addr = from _ addr , to _ addr = to _ addr , subject = subject , message = message , mimetype = mimetype , ttls = ttls , login = login , username = username , password = password , categories = mail.categories ) DCNL DCSP if settings.USE _ EMAIL : DCNL DCSP DCSP if settings.USE _ CELERY : DCNL DCSP DCSP DCSP return mailer.apply _ async ( kwargs = kwargs , link = callback ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret = mailer ( * * kwargs ) DCNL DCSP DCSP DCSP if callback : DCNL DCSP DCSP DCSP DCSP callback ( ) DCNL DCSP DCSP DCSP return ret
DCSP from django.template import Lexer , TOKEN _ TEXT , TOKEN _ VAR , TOKEN _ BLOCK DCNL DCSP out = StringIO ( ) DCNL DCSP intrans = False DCNL DCSP inplural = False DCNL DCSP singular = &#91; &#93; DCNL DCSP plural = &#91; &#93; DCNL DCSP for t in Lexer ( src , None ) .tokenize ( ) : DCNL DCSP DCSP if intrans : DCNL DCSP DCSP DCSP if ( t.token _ type = = TOKEN _ BLOCK ) : DCNL DCSP DCSP DCSP DCSP endbmatch = endblock _ re.match ( t.contents ) DCNL DCSP DCSP DCSP DCSP pluralmatch = plural _ re.match ( t.contents ) DCNL DCSP DCSP DCSP DCSP if endbmatch : DCNL DCSP DCSP DCSP DCSP DCSP if inplural : DCNL DCSP DCSP DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP ngettext ( % r , % r , count ) DCSP &apos; % ( &apos; &apos;.join ( singular ) , &apos; &apos;.join ( plural ) ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP for part in singular : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP out.write ( blankout ( part , &apos; S &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP for part in plural : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP out.write ( blankout ( part , &apos; P &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP gettext ( % r ) DCSP &apos; % &apos; &apos;.join ( singular ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP for part in singular : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP out.write ( blankout ( part , &apos; S &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP intrans = False DCNL DCSP DCSP DCSP DCSP DCSP inplural = False DCNL DCSP DCSP DCSP DCSP DCSP singular = &#91; &#93; DCNL DCSP DCSP DCSP DCSP DCSP plural = &#91; &#93; DCNL DCSP DCSP DCSP DCSP elif pluralmatch : DCNL DCSP DCSP DCSP DCSP DCSP inplural = True DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP raise SyntaxError , ( &apos; Translation DCSP blocks DCSP must DCSP not DCSP include DCSP other DCSP block DCSP tags : DCSP % s &apos; % t.contents ) DCNL DCSP DCSP DCSP elif ( t.token _ type = = TOKEN _ VAR ) : DCNL DCSP DCSP DCSP DCSP if inplural : DCNL DCSP DCSP DCSP DCSP DCSP plural.append ( ( &apos; % % ( % s ) s &apos; % t.contents ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP singular.append ( ( &apos; % % ( % s ) s &apos; % t.contents ) ) DCNL DCSP DCSP DCSP elif ( t.token _ type = = TOKEN _ TEXT ) : DCNL DCSP DCSP DCSP DCSP if inplural : DCNL DCSP DCSP DCSP DCSP DCSP plural.append ( t.contents ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP singular.append ( t.contents ) DCNL DCSP DCSP elif ( t.token _ type = = TOKEN _ BLOCK ) : DCNL DCSP DCSP DCSP imatch = inline _ re.match ( t.contents ) DCNL DCSP DCSP DCSP bmatch = block _ re.match ( t.contents ) DCNL DCSP DCSP DCSP cmatches = constant _ re.findall ( t.contents ) DCNL DCSP DCSP DCSP if imatch : DCNL DCSP DCSP DCSP DCSP g = imatch.group ( 1 ) DCNL DCSP DCSP DCSP DCSP if ( g &#91; 0 &#93; = = &apos; &quot; &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP g = g.strip ( &apos; &quot; &apos; ) DCNL DCSP DCSP DCSP DCSP elif ( g &#91; 0 &#93; = = &quot; &apos; &quot; ) : DCNL DCSP DCSP DCSP DCSP DCSP g = g.strip ( &quot; &apos; &quot; ) DCNL DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP gettext ( % r ) DCSP &apos; % g ) ) DCNL DCSP DCSP DCSP elif bmatch : DCNL DCSP DCSP DCSP DCSP intrans = True DCNL DCSP DCSP DCSP DCSP inplural = False DCNL DCSP DCSP DCSP DCSP singular = &#91; &#93; DCNL DCSP DCSP DCSP DCSP plural = &#91; &#93; DCNL DCSP DCSP DCSP elif cmatches : DCNL DCSP DCSP DCSP DCSP for cmatch in cmatches : DCNL DCSP DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP _ ( % s ) DCSP &apos; % cmatch ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP out.write ( blankout ( t.contents , &apos; B &apos; ) ) DCNL DCSP DCSP elif ( t.token _ type = = TOKEN _ VAR ) : DCNL DCSP DCSP DCSP parts = t.contents.split ( &apos; &#124; &apos; ) DCNL DCSP DCSP DCSP cmatch = constant _ re.match ( parts &#91; 0 &#93; ) DCNL DCSP DCSP DCSP if cmatch : DCNL DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP _ ( % s ) DCSP &apos; % cmatch.group ( 1 ) ) ) DCNL DCSP DCSP DCSP for p in parts &#91; 1 : &#93; : DCNL DCSP DCSP DCSP DCSP if ( p.find ( &apos; : _ ( &apos; ) &gt; = 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP out.write ( ( &apos; DCSP % s DCSP &apos; % p.split ( &apos; : &apos; , 1 ) &#91; 1 &#93; ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP out.write ( blankout ( p , &apos; F &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP out.write ( blankout ( t.contents , &apos; X &apos; ) ) DCNL DCSP return out.getvalue ( )
DCSP if ( &apos; d &apos; not in xmlElement.attributeDictionary ) : DCNL DCSP DCSP print &apos; Warning , DCSP in DCSP processSVGElementpath DCSP in DCSP svgReader DCSP can DCSP not DCSP get DCSP a DCSP value DCSP for DCSP d DCSP in : &apos; DCNL DCSP DCSP print xmlElement.attributeDictionary DCNL DCSP DCSP return DCNL DCSP rotatedLoopLayer = svgReader.getRotatedLoopLayer ( ) DCNL DCSP PathReader ( rotatedLoopLayer.loops , xmlElement , svgReader.yAxisPointingUpward )
DCSP keys = &#91; _ make _ ratelimit _ cache _ key ( k , t ) for ( k , t ) in prefix _ slices &#93; DCNL DCSP try : DCNL DCSP DCSP now = int ( time.time ( ) ) DCNL DCSP DCSP for ( key , ( _ , time _ slice ) ) in zip ( keys , prefix _ slices ) : DCNL DCSP DCSP DCSP g.ratelimitcache.add ( key , 0 , time = ( ( time _ slice.end - now ) + 1 ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP recent _ usage = g.ratelimitcache.incr _ multi ( keys ) DCNL DCSP DCSP except pylibmc.NotFound : DCNL DCSP DCSP DCSP now = int ( time.time ( ) ) DCNL DCSP DCSP DCSP if ( now &lt; time _ slice.end ) : DCNL DCSP DCSP DCSP DCSP recent _ usage = &#91; &#93; DCNL DCSP DCSP DCSP DCSP for ( key , ( _ , time _ slice ) ) in zip ( keys , prefix _ slices ) : DCNL DCSP DCSP DCSP DCSP DCSP if g.ratelimitcache.add ( key , 1 , time = ( ( time _ slice.end - now ) + 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP recent _ usage.append ( 1 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP g.stats.simple _ event ( &apos; ratelimit.eviction &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP recent _ usage.append ( g.ratelimitcache.get ( key ) ) DCNL DCSP DCSP return recent _ usage DCNL DCSP except pylibmc.Error as e : DCNL DCSP DCSP raise RatelimitError ( e )
DCSP import lixian _ hash DCNL DCSP import lixian _ cli _ parser DCNL DCSP lixian _ hash.main ( lixian _ cli _ parser.expand _ command _ line ( args ) )
DCSP keys = environ.keys ( ) DCNL DCSP keys.sort ( ) DCNL DCSP print DCNL DCSP print &apos; &lt; H3 &gt; Shell DCSP Environment : &lt; / H3 &gt; &apos; DCNL DCSP print &apos; &lt; DL &gt; &apos; DCNL DCSP for key in keys : DCNL DCSP DCSP print &apos; &lt; DT &gt; &apos; , escape ( key ) , &apos; &lt; DD &gt; &apos; , escape ( environ &#91; key &#93; ) DCNL DCSP print &apos; &lt; / DL &gt; &apos; DCNL DCSP print
DCSP return for _ dtypes _ combination ( _ signed _ dtypes , names = names , full = full )
DCSP if ( query and ( not ( set ( query ) &lt; = urlencoded ) ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP characters DCSP in DCSP query DCSP string . &apos; ) DCNL DCSP invalid _ hex = u &apos; % &#91; ^ 0-9A-Fa-f &#93; &#124; % &#91; 0-9A-Fa-f &#93; &#91; ^ 0-9A-Fa-f &#93; &apos; DCNL DCSP if len ( re.findall ( invalid _ hex , query ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP hex DCSP encoding DCSP in DCSP query DCSP string . &apos; ) DCNL DCSP query = ( query.decode ( &apos; utf-8 &apos; ) if isinstance ( query , str ) else query ) DCNL DCSP params = urlparse.parse _ qsl ( query , keep _ blank _ values = True ) DCNL DCSP return decode _ params _ utf8 ( params )
DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01X \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;Xhello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01X \ x05Y \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;XhelloY &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x08X \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hellX &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x1b &#91; D \ x1b &#91; D \ x1b &#91; 3 ~ \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;helo &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x1b &#91; DX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hellXo &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01 \ x1b &#91; CX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hXello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01 \ x1b &#91; CX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hXello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x02X \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hellXo &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01 \ x06X \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hXello &apos; ) DCNL DCSP with pytest.raises ( KeyboardInterrupt ) : DCNL DCSP DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x03 \ n &apos; ) DCNL DCSP DCSP assert ( result.text = = u &apos;hello &apos; ) DCNL DCSP with pytest.raises ( EOFError ) : DCNL DCSP DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos; \ x04 \ n &apos; ) DCNL DCSP DCSP assert ( result.text = = u &apos;hello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x01 \ x04 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;ello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x04 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x1b &#91; D \ x1b &#91; D \ x0b \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hel &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x1b &#91; D \ x1b &#91; D \ x1b- \ x0b \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;lo &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello \ x0c \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x01X \ x1b &#91; 1 ; 5CY \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;XhelloY DCSP world &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x1b &#91; 1 ; 5DY \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP Yworld &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world DCSP abc DCSP def \ x01 \ x1b3 \ x1bfX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP world DCSP abcX DCSP def &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world DCSP abc DCSP def \ x1b- \ x1b3 \ x1bfX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP Xworld DCSP abc DCSP def &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world DCSP abc DCSP def \ x1b3 \ x1bbX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP Xworld DCSP abc DCSP def &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world DCSP abc DCSP def \ x01 \ x1b- \ x1b3 \ x1bbX \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP world DCSP abc DCSP Xdef &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x17 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP &apos; ) DCNL DCSP assert ( cli.clipboard.get _ data ( ) .text = = u &apos;world &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;test DCSP hello DCSP world \ x1b2 \ x17 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;test DCSP &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x1b \ x7f \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP &apos; ) DCNL DCSP assert ( cli.clipboard.get _ data ( ) .text = = u &apos;world &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x1b \ x08 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP &apos; ) DCNL DCSP assert ( cli.clipboard.get _ data ( ) .text = = u &apos;world &apos; ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x7f \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP worl &apos; ) DCNL DCSP assert ( result.cursor _ position = = len ( u &apos;hello DCSP worl &apos; ) ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x08 \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;hello DCSP worl &apos; ) DCNL DCSP assert ( result.cursor _ position = = len ( u &apos;hello DCSP worl &apos; ) ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP world \ x01 \ x1b &#91; 3 ~ \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;ello DCSP world &apos; ) DCNL DCSP assert ( result.cursor _ position = = 0 ) DCNL DCSP ( result , cli ) = _ feed _ cli _ with _ input ( u &apos;hello DCSP DCSP DCSP DCSP DCSP world \ x1b8 \ x02 \ x1b \ \ \ n &apos; ) DCNL DCSP assert ( result.text = = u &apos;helloworld &apos; ) DCNL DCSP assert ( result.cursor _ position = = len ( u &apos;hello &apos; ) )
DCSP if _ IsSudsIterable ( obj ) : DCNL DCSP DCSP copy _ of _ obj = tuple ( obj ) DCNL DCSP DCSP for item in copy _ of _ obj : DCNL DCSP DCSP DCSP if _ IsSudsIterable ( item ) : DCNL DCSP DCSP DCSP DCSP if ( &apos; xsi _ type &apos; in item ) : DCNL DCSP DCSP DCSP DCSP DCSP if isinstance ( obj , tuple ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP parent &#91; obj &#91; 0 &#93; &#93; = _ PackForSuds ( obj &#91; 1 &#93; , factory ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP obj.remove ( item ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP obj.append ( _ PackForSuds ( item , factory ) ) DCNL DCSP DCSP DCSP DCSP _ RecurseOverObject ( item , factory , obj )
DCSP byte = primitives.byte ( value , endian , format , signed , full _ range , fuzzable , name ) DCNL DCSP blocks.CURRENT.push ( byte )
DCSP _ publish _ activity ( committer _ id , collection _ id , feconf.ACTIVITY _ TYPE _ COLLECTION )
DCSP import os , re DCNL DCSP dirs = &#91; &apos; &apos; , &apos; c : \ \ windows \ \ system32 &apos; , &apos; c : \ \ winnt \ \ system32 &apos; &#93; DCNL DCSP try : DCNL DCSP DCSP import ctypes DCNL DCSP DCSP buffer = ctypes.create _ string _ buffer ( 300 ) DCNL DCSP DCSP ctypes.windll.kernel32.GetSystemDirectoryA ( buffer , 300 ) DCNL DCSP DCSP dirs.insert ( 0 , buffer.value.decode ( &apos; mbcs &apos; ) ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP for dir in dirs : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP pipe = os.popen ( ( os.path.join ( dir , &apos; ipconfig &apos; ) + &apos; DCSP / all &apos; ) ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP for line in pipe : DCNL DCSP DCSP DCSP value = line.split ( &apos; : &apos; ) &#91; ( -1 ) &#93; .strip ( ) .lower ( ) DCNL DCSP DCSP DCSP if re.match ( &apos; ( &#91; 0-9a-f &#93; &#91; 0-9a-f &#93; - ) { 5 } &#91; 0-9a-f &#93; &#91; 0-9a-f &#93; &apos; , value ) : DCNL DCSP DCSP DCSP DCSP return int ( value.replace ( &apos; -&apos; , &apos; &apos; ) , 16 )
DCSP projects = &#91; &#93; DCNL DCSP for filePath in baseDirectory.walk ( ) : DCNL DCSP DCSP if ( filePath.basename ( ) = = &apos; topfiles &apos; ) : DCNL DCSP DCSP DCSP projectDirectory = filePath.parent ( ) DCNL DCSP DCSP DCSP projects.append ( Project ( projectDirectory ) ) DCNL DCSP return projects
DCSP rounds = ( ( len ( expanded _ key ) / / BLOCK _ SIZE _ BYTES ) - 1 ) DCNL DCSP data = xor ( data , expanded _ key &#91; : BLOCK _ SIZE _ BYTES &#93; ) DCNL DCSP for i in range ( 1 , ( rounds + 1 ) ) : DCNL DCSP DCSP data = sub _ bytes ( data ) DCNL DCSP DCSP data = shift _ rows ( data ) DCNL DCSP DCSP if ( i ! = rounds ) : DCNL DCSP DCSP DCSP data = mix _ columns ( data ) DCNL DCSP DCSP data = xor ( data , expanded _ key &#91; ( i * BLOCK _ SIZE _ BYTES ) : ( ( i + 1 ) * BLOCK _ SIZE _ BYTES ) &#93; ) DCNL DCSP return data
DCSP if ( not hasattr ( seq , &apos; next &apos; ) ) : DCNL DCSP DCSP seq = iter ( seq ) DCNL DCSP while True : DCNL DCSP DCSP ( yield &#91; seq.next ( ) for i in xrange ( size ) &#93; )
DCSP def foo ( a , b , c = 1 , d = 2 , e = 3 , * * kwargs ) : DCNL DCSP DCSP u &apos;A DCSP test DCSP function . &apos; DCNL DCSP DCSP return ( a , b , c , d , e , kwargs ) DCNL DCSP @ wraps ( foo ) DCNL DCSP def bar ( * args , * * kwargs ) : DCNL DCSP DCSP return ( ( u &apos;test &apos; , ) + foo ( * args , * * kwargs ) ) DCNL DCSP expected = ( u &apos;test &apos; , 1 , 2 , 3 , 4 , 5 , { u &apos;f &apos; : 6 , u &apos;g &apos; : 7 } ) DCNL DCSP assert ( bar ( 1 , 2 , 3 , 4 , 5 , f = 6 , g = 7 ) = = expected ) DCNL DCSP assert ( bar . _ _ name _ _ = = u &apos;foo &apos; ) DCNL DCSP if ( foo . _ _ doc _ _ is not None ) : DCNL DCSP DCSP assert ( bar . _ _ doc _ _ = = u &apos;A DCSP test DCSP function . &apos; ) DCNL DCSP if hasattr ( foo , u &apos; _ _ qualname _ _ &apos; ) : DCNL DCSP DCSP assert ( bar . _ _ qualname _ _ = = foo . _ _ qualname _ _ ) DCNL DCSP if six.PY2 : DCNL DCSP DCSP argspec = inspect.getargspec ( bar ) DCNL DCSP DCSP assert ( argspec.keywords = = u &apos;kwargs &apos; ) DCNL DCSP else : DCNL DCSP DCSP argspec = inspect.getfullargspec ( bar ) DCNL DCSP DCSP assert ( argspec.varkw = = u &apos;kwargs &apos; ) DCNL DCSP assert ( argspec.args = = &#91; u &apos;a &apos; , u &apos;b &apos; , u &apos;c &apos; , u &apos;d &apos; , u &apos;e &apos; &#93; ) DCNL DCSP assert ( argspec.defaults = = ( 1 , 2 , 3 ) )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; comment &apos; : str ( ) , &apos; result &apos; : None } DCNL DCSP ret _ settings = { &apos; changes &apos; : dict ( ) , &apos; failures &apos; : dict ( ) } DCNL DCSP if ( not services ) : DCNL DCSP DCSP services = &#91; &apos; None &apos; &#93; DCNL DCSP services = sorted ( set ( services ) ) DCNL DCSP settings = { &apos; contact &apos; : contact , &apos; location &apos; : location , &apos; services &apos; : services } DCNL DCSP current _ settings = _ _ salt _ _ &#91; &apos; win _ snmp.get _ agent _ settings &apos; &#93; ( ) DCNL DCSP for setting in settings : DCNL DCSP DCSP if ( str ( settings &#91; setting &#93; ) ! = str ( current _ settings &#91; setting &#93; ) ) : DCNL DCSP DCSP DCSP ret _ settings &#91; &apos; changes &apos; &#93; &#91; setting &#93; = { &apos; old &apos; : current _ settings &#91; setting &#93; , &apos; new &apos; : settings &#91; setting &#93; } DCNL DCSP if ( not ret _ settings &#91; &apos; changes &apos; &#93; ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Agent DCSP settings DCSP already DCSP contain DCSP the DCSP provided DCSP values . &apos; DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP return ret DCNL DCSP elif _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Agent DCSP settings DCSP will DCSP be DCSP changed . &apos; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = ret _ settings DCNL DCSP DCSP return ret DCNL DCSP _ _ salt _ _ &#91; &apos; win _ snmp.set _ agent _ settings &apos; &#93; ( * * settings ) DCNL DCSP new _ settings = _ _ salt _ _ &#91; &apos; win _ snmp.get _ agent _ settings &apos; &#93; ( ) DCNL DCSP for setting in settings : DCNL DCSP DCSP if ( settings &#91; setting &#93; ! = new _ settings &#91; setting &#93; ) : DCNL DCSP DCSP DCSP ret _ settings &#91; &apos; failures &apos; &#93; &#91; setting &#93; = { &apos; old &apos; : current _ settings &#91; setting &#93; , &apos; new &apos; : new _ settings &#91; setting &#93; } DCNL DCSP DCSP DCSP ret _ settings &#91; &apos; changes &apos; &#93; .pop ( setting , None ) DCNL DCSP if ret _ settings &#91; &apos; failures &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Some DCSP agent DCSP settings DCSP failed DCSP to DCSP change . &apos; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = ret _ settings DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Set DCSP agent DCSP settings DCSP to DCSP contain DCSP the DCSP provided DCSP values . &apos; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; = ret _ settings &#91; &apos; changes &apos; &#93; DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP return ret
DCSP print ( ( &apos; File DCSP &apos; + filename ) + &apos; DCSP is DCSP being DCSP displayed . &apos; ) DCNL DCSP fileText = archive.getFileText ( filename ) DCNL DCSP gcodec.writeFileMessageSuffix ( filename , displayText ( fileText ) , &apos; The DCSP gcode DCSP log DCSP file DCSP is DCSP saved DCSP as DCSP &apos; , &apos; _ log &apos; )
DCSP for a in np.arange ( 2.51 , 3.49 , 0.1 ) : DCNL DCSP DCSP assert np.all ( ( extract _ array ( np.arange ( 5 ) , 3 , a ) = = np.array ( &#91; 2 , 3 , 4 &#93; ) ) )
DCSP n = len ( x ) DCNL DCSP for i in reversed ( range ( ( n / / 2 ) ) ) : DCNL DCSP DCSP _ siftup _ max ( x , i )
DCSP ( x1 , y1 ) = p1 DCNL DCSP ( x2 , y2 ) = p2 DCNL DCSP ( x3 , y3 ) = p3 DCNL DCSP ( x4 , y4 ) = p4 DCNL DCSP points = &#91; &#93; DCNL DCSP _ curve4 _ recursive _ bezier ( points , x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) DCNL DCSP ( dx , dy ) = ( ( points &#91; 0 &#93; &#91; 0 &#93; - x1 ) , ( points &#91; 0 &#93; &#91; 1 &#93; - y1 ) ) DCNL DCSP if ( ( ( dx * dx ) + ( dy * dy ) ) &gt; 1e-10 ) : DCNL DCSP DCSP points.insert ( 0 , ( x1 , y1 ) ) DCNL DCSP ( dx , dy ) = ( ( points &#91; ( -1 ) &#93; &#91; 0 &#93; - x4 ) , ( points &#91; ( -1 ) &#93; &#91; 1 &#93; - y4 ) ) DCNL DCSP if ( ( ( dx * dx ) + ( dy * dy ) ) &gt; 1e-10 ) : DCNL DCSP DCSP points.append ( ( x4 , y4 ) ) DCNL DCSP return np.array ( points ) .reshape ( len ( points ) , 2 )
DCSP return ( ( N - M ) + 1 )
DCSP return IMPL.instance _ type _ access _ remove ( context , flavor _ id , project _ id )
DCSP if ( len ( text ) &gt; maxlen ) : DCNL DCSP DCSP pre = max ( 0 , ( ( maxlen - 3 ) / / 2 ) ) DCNL DCSP DCSP post = max ( 0 , ( ( maxlen - 3 ) - pre ) ) DCNL DCSP DCSP return ( ( text &#91; : pre &#93; + &apos; ... &apos; ) + text &#91; ( len ( text ) - post ) : &#93; ) DCNL DCSP return text
DCSP return IMPL.quota _ usage _ update ( context , project _ id , resource , * * kwargs )
DCSP location _ dict = { &apos; system &apos; : system , &apos; type &apos; : lun _ type , &apos; id &apos; : six.text _ type ( lun _ id ) , &apos; base _ lun _ name &apos; : six.text _ type ( base _ lun _ name ) , &apos; version &apos; : version } DCNL DCSP return dump _ provider _ location ( location _ dict )
DCSP if ( ( r.representation = = &apos; html &apos; ) and ( r.name = = &apos; shelter &apos; ) and r.id and ( not r.component ) ) : DCNL DCSP DCSP T = current.T DCNL DCSP DCSP msg = current.msg DCNL DCSP DCSP s3db = current.s3db DCNL DCSP DCSP record = r.record DCNL DCSP DCSP ctable = s3db.pr _ contact DCNL DCSP DCSP stable = s3db.cr _ shelter DCNL DCSP DCSP message = &apos; &apos; DCNL DCSP DCSP text = &apos; &apos; DCNL DCSP DCSP s _ id = record.id DCNL DCSP DCSP s _ name = record.name DCNL DCSP DCSP s _ phone = record.phone DCNL DCSP DCSP s _ email = record.email DCNL DCSP DCSP s _ status = record.status DCNL DCSP DCSP if ( s _ phone in ( &apos; &apos; , None ) ) : DCNL DCSP DCSP DCSP s _ phone = T ( &apos; Not DCSP Defined &apos; ) DCNL DCSP DCSP if ( s _ email in ( &apos; &apos; , None ) ) : DCNL DCSP DCSP DCSP s _ phone = T ( &apos; Not DCSP Defined &apos; ) DCNL DCSP DCSP if ( s _ status in ( &apos; &apos; , None ) ) : DCNL DCSP DCSP DCSP s _ status = T ( &apos; Not DCSP Defined &apos; ) DCNL DCSP DCSP elif ( s _ status = = 1 ) : DCNL DCSP DCSP DCSP s _ status = &apos; Open &apos; DCNL DCSP DCSP elif ( s _ status = = 2 ) : DCNL DCSP DCSP DCSP s _ status = &apos; Close &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP s _ status = &apos; Unassigned DCSP Shelter DCSP Status &apos; DCNL DCSP DCSP text + = &apos; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * &apos; DCNL DCSP DCSP text + = ( &apos; \ n % s DCSP &apos; % T ( &apos; Automatic DCSP Message &apos; ) ) DCNL DCSP DCSP text + = ( &apos; \ n % s : DCSP % s DCSP &apos; % ( T ( &apos; Shelter DCSP ID &apos; ) , s _ id ) ) DCNL DCSP DCSP text + = ( &apos; DCSP % s : DCSP % s &apos; % ( T ( &apos; Shelter DCSP name &apos; ) , s _ name ) ) DCNL DCSP DCSP text + = ( &apos; \ n % s : DCSP % s DCSP &apos; % ( T ( &apos; Email &apos; ) , s _ email ) ) DCNL DCSP DCSP text + = ( &apos; DCSP % s : DCSP % s &apos; % ( T ( &apos; Phone &apos; ) , s _ phone ) ) DCNL DCSP DCSP text + = ( &apos; \ n % s : DCSP % s DCSP &apos; % ( T ( &apos; Working DCSP Status &apos; ) , s _ status ) ) DCNL DCSP DCSP text + = &apos; \ n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ n &apos; DCNL DCSP DCSP url = URL ( c = &apos; cr &apos; , f = &apos; shelter &apos; , args = r.id ) DCNL DCSP DCSP opts = dict ( type = &apos; SMS &apos; , subject = T ( &apos; Deployment DCSP Request &apos; ) , message = ( message + text ) , url = url ) DCNL DCSP DCSP output = msg.compose ( * * opts ) DCNL DCSP DCSP if attr.get ( &apos; rheader &apos; ) : DCNL DCSP DCSP DCSP rheader = attr &#91; &apos; rheader &apos; &#93; ( r ) DCNL DCSP DCSP DCSP if rheader : DCNL DCSP DCSP DCSP DCSP output &#91; &apos; rheader &apos; &#93; = rheader DCNL DCSP DCSP output &#91; &apos; title &apos; &#93; = T ( &apos; Send DCSP Notification &apos; ) DCNL DCSP DCSP current.response.view = &apos; msg / compose.html &apos; DCNL DCSP DCSP return output DCNL DCSP else : DCNL DCSP DCSP raise HTTP ( 501 , current.messages.BADMETHOD )
DCSP return { &apos; id &apos; : member _ ref &#91; &apos; id &apos; &#93; , &apos; image _ id &apos; : member _ ref &#91; &apos; image _ id &apos; &#93; , &apos; member &apos; : member _ ref &#91; &apos; member &apos; &#93; , &apos; can _ share &apos; : member _ ref &#91; &apos; can _ share &apos; &#93; , &apos; status &apos; : member _ ref &#91; &apos; status &apos; &#93; , &apos; created _ at &apos; : member _ ref &#91; &apos; created _ at &apos; &#93; , &apos; updated _ at &apos; : member _ ref &#91; &apos; updated _ at &apos; &#93; , &apos; deleted &apos; : member _ ref &#91; &apos; deleted &apos; &#93; }
DCSP while True : DCNL DCSP DCSP v = np.random.rand ( 1 ) DCNL DCSP DCSP if ( v &gt; p ) : DCNL DCSP DCSP DCSP ( yield 0.0 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ( yield np.random.rand ( 1 ) )
DCSP if ( not policy _ data ) : DCNL DCSP DCSP policy _ data = &apos; &apos; DCNL DCSP specialValueRegex = &apos; ( \ \ * \ \ * Del \ \ . &#124; \ \ * \ \ * DelVals \ \ . ) { 0,1 } &apos; DCNL DCSP item _ key = None DCNL DCSP item _ value _ name = None DCNL DCSP data _ to _ replace = None DCNL DCSP if ( not append _ only ) : DCNL DCSP DCSP item _ key = this _ string.split ( &apos; { 0 } ; &apos; .format ( chr ( 0 ) ) ) &#91; 0 &#93; .lstrip ( &apos; &#91; &apos; ) DCNL DCSP DCSP item _ value _ name = re.sub ( specialValueRegex , &apos; &apos; , this _ string.split ( &apos; { 0 } ; &apos; .format ( chr ( 0 ) ) ) &#91; 1 &#93; , flags = re.IGNORECASE ) DCNL DCSP DCSP log.debug ( &apos; item DCSP value DCSP name DCSP is DCSP { 0 } &apos; .format ( item _ value _ name ) ) DCNL DCSP DCSP data _ to _ replace = _ regexSearchKeyValueCombo ( policy _ data , item _ key , item _ value _ name ) DCNL DCSP if data _ to _ replace : DCNL DCSP DCSP log.debug ( &apos; replacing DCSP { 0 } DCSP with DCSP { 1 } &apos; .format ( &#91; data _ to _ replace &#93; , &#91; this _ string &#93; ) ) DCNL DCSP DCSP policy _ data = policy _ data.replace ( data _ to _ replace , this _ string ) DCNL DCSP else : DCNL DCSP DCSP log.debug ( &apos; appending DCSP { 0 } &apos; .format ( &#91; this _ string &#93; ) ) DCNL DCSP DCSP policy _ data = &apos; &apos;.join ( &#91; policy _ data , this _ string &#93; ) DCNL DCSP return policy _ data
DCSP spec = db _ spec ( db ) DCNL DCSP @ decorator DCNL DCSP def decorate ( fn , * args , * * kw ) : DCNL DCSP DCSP if isinstance ( db , util.string _ types ) : DCNL DCSP DCSP DCSP if ( not spec ( config . _ current ) ) : DCNL DCSP DCSP DCSP DCSP return fn ( * args , * * kw ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP wrapped = emits _ warning ( * warnings ) ( fn ) DCNL DCSP DCSP DCSP DCSP return wrapped ( * args , * * kw ) DCNL DCSP DCSP elif ( not _ is _ excluded ( * db ) ) : DCNL DCSP DCSP DCSP return fn ( * args , * * kw ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP wrapped = emits _ warning ( * warnings ) ( fn ) DCNL DCSP DCSP DCSP return wrapped ( * args , * * kw ) DCNL DCSP return decorate
DCSP def construct ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP secret _ file = open ( &apos; / etc / ldap.secret &apos; , &apos; r &apos; ) DCNL DCSP DCSP DCSP bind _ dn = &apos; cn = admin , { } &apos; .format ( base _ dn ( ) ) DCNL DCSP DCSP except IOError : DCNL DCSP DCSP DCSP secret _ file = open ( &apos; / etc / machine.secret &apos; , &apos; r &apos; ) DCNL DCSP DCSP DCSP bind _ dn = config _ registry ( ) &#91; &apos; ldap / hostdn &apos; &#93; DCNL DCSP DCSP pwd _ line = secret _ file.readline ( ) DCNL DCSP DCSP pwd = re.sub ( &apos; \ n &apos; , &apos; &apos; , pwd _ line ) DCNL DCSP DCSP import univention.admin.uldap DCNL DCSP DCSP return univention.admin.uldap.access ( host = config _ registry ( ) &#91; &apos; ldap / master &apos; &#93; , base = base _ dn ( ) , binddn = bind _ dn , bindpw = pwd , start _ tls = 1 ) DCNL DCSP return _ singleton ( &apos; uldap &apos; , construct )
DCSP lres = &#91; &#93; DCNL DCSP bi = s.find ( cont ) DCNL DCSP if ( bi ! = ( -1 ) ) : DCNL DCSP DCSP btag = s &#91; : bi &#93; .rfind ( &apos; &lt; &apos; ) DCNL DCSP DCSP if ( btag ! = ( -1 ) ) : DCNL DCSP DCSP DCSP if ( not toClosure ) : DCNL DCSP DCSP DCSP DCSP etag = s &#91; ( bi + 1 ) : &#93; .find ( &apos; &gt; &apos; ) DCNL DCSP DCSP DCSP DCSP if ( etag ! = ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP endidx = ( ( bi + 2 ) + etag ) DCNL DCSP DCSP DCSP DCSP DCSP lres.append ( s &#91; btag : endidx &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ( maxRes is not None ) and ( len ( lres ) &gt; = maxRes ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return lres DCNL DCSP DCSP DCSP DCSP DCSP lres + = _ getTagsWith ( s &#91; endidx : &#93; , cont , toClosure = toClosure ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP spaceidx = s &#91; btag : &#93; .find ( &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP DCSP if ( spaceidx ! = ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP ctag = ( &apos; &lt; / % s &gt; &apos; % s &#91; ( btag + 1 ) : ( btag + spaceidx ) &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP closeidx = s &#91; bi : &#93; .find ( ctag ) DCNL DCSP DCSP DCSP DCSP DCSP if ( closeidx ! = ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP endidx = ( ( bi + closeidx ) + len ( ctag ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP lres.append ( s &#91; btag : endidx &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( ( maxRes is not None ) and ( len ( lres ) &gt; = maxRes ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP return lres DCNL DCSP DCSP DCSP DCSP DCSP DCSP lres + = _ getTagsWith ( s &#91; endidx : &#93; , cont , toClosure = toClosure ) DCNL DCSP return lres
DCSP request = cherrypy.serving.request DCNL DCSP auth _ header = request.headers.get ( &apos; authorization &apos; ) DCNL DCSP nonce _ is _ stale = False DCNL DCSP if ( auth _ header is not None ) : DCNL DCSP DCSP with cherrypy.HTTPError.handle ( ValueError , 400 , &apos; The DCSP Authorization DCSP header DCSP could DCSP not DCSP be DCSP parsed . &apos; ) : DCNL DCSP DCSP DCSP auth = HttpDigestAuthorization ( auth _ header , request.method , debug = debug ) DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP TRACE ( str ( auth ) ) DCNL DCSP DCSP if auth.validate _ nonce ( realm , key ) : DCNL DCSP DCSP DCSP ha1 = get _ ha1 ( realm , auth.username ) DCNL DCSP DCSP DCSP if ( ha1 is not None ) : DCNL DCSP DCSP DCSP DCSP digest = auth.request _ digest ( ha1 , entity _ body = request.body ) DCNL DCSP DCSP DCSP DCSP if ( digest = = auth.response ) : DCNL DCSP DCSP DCSP DCSP DCSP if debug : DCNL DCSP DCSP DCSP DCSP DCSP DCSP TRACE ( &apos; digest DCSP matches DCSP auth.response &apos; ) DCNL DCSP DCSP DCSP DCSP DCSP nonce _ is _ stale = auth.is _ nonce _ stale ( max _ age _ seconds = 600 ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not nonce _ is _ stale ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP request.login = auth.username DCNL DCSP DCSP DCSP DCSP DCSP DCSP if debug : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP TRACE ( ( &apos; authentication DCSP of DCSP % s DCSP successful &apos; % auth.username ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP return DCNL DCSP header = www _ authenticate ( realm , key , stale = nonce _ is _ stale ) DCNL DCSP if debug : DCNL DCSP DCSP TRACE ( header ) DCNL DCSP cherrypy.serving.response.headers &#91; &apos; WWW-Authenticate &apos; &#93; = header DCNL DCSP raise cherrypy.HTTPError ( 401 , &apos; You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP that DCSP resource &apos; )
DCSP compress _ ext = { &apos; gzip &apos; : &apos; .gz &apos; , &apos; bzip2 &apos; : &apos; .bz2 &apos; , &apos; compress &apos; : &apos; .Z &apos; } DCNL DCSP compress _ flags = { &apos; gzip &apos; : &#91; &apos; -f9 &apos; &#93; , &apos; compress &apos; : &#91; &apos; -f &apos; &#93; , &apos; bzip2 &apos; : &#91; &apos; -f9 &apos; &#93; } DCNL DCSP if ( ( compress is not None ) and ( compress not in compress _ ext.keys ( ) ) ) : DCNL DCSP DCSP raise ValueError , &quot; bad DCSP value DCSP for DCSP &apos; compress &apos; : DCSP must DCSP be DCSP None , DCSP &apos; gzip &apos; , DCSP or DCSP &apos; compress &apos; &quot; DCNL DCSP archive _ name = ( base _ name + &apos; .tar &apos; ) DCNL DCSP mkpath ( os.path.dirname ( archive _ name ) , dry _ run = dry _ run ) DCNL DCSP cmd = &#91; &apos; tar &apos; , &apos; -cf &apos; , archive _ name , base _ dir &#93; DCNL DCSP spawn ( cmd , dry _ run = dry _ run ) DCNL DCSP if compress : DCNL DCSP DCSP spawn ( ( ( &#91; compress &#93; + compress _ flags &#91; compress &#93; ) + &#91; archive _ name &#93; ) , dry _ run = dry _ run ) DCNL DCSP DCSP return ( archive _ name + compress _ ext &#91; compress &#93; ) DCNL DCSP else : DCNL DCSP DCSP return archive _ name
DCSP return call _ talib _ with _ ds ( ds , count , talib.TRIX , timeperiod )
DCSP lockdir = os.path.join ( _ get _ download _ cache _ locs ( ) &#91; 0 &#93; , u &apos;lock &apos; ) DCNL DCSP for i in range ( conf.download _ cache _ lock _ attempts ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP os.mkdir ( lockdir ) DCNL DCSP DCSP DCSP with open ( os.path.join ( lockdir , u &apos;pid &apos; ) , u &apos;w &apos; ) as f : DCNL DCSP DCSP DCSP DCSP f.write ( str ( os.getpid ( ) ) ) DCNL DCSP DCSP except OSError : DCNL DCSP DCSP DCSP time.sleep ( 1 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return DCNL DCSP msg = u &quot; Unable DCSP to DCSP acquire DCSP lock DCSP for DCSP cache DCSP directory DCSP ( { 0 } DCSP exists ) . DCSP You DCSP may DCSP need DCSP to DCSP delete DCSP the DCSP lock DCSP if DCSP the DCSP python DCSP interpreter DCSP wasn &apos;t DCSP shut DCSP down DCSP properly . &quot; DCNL DCSP raise RuntimeError ( msg.format ( lockdir ) )
DCSP return Select ( select _ browser _ query.first.results &#91; 0 &#93; ) .options
DCSP paragraph _ re = re.compile ( &apos; \ \ n ( \ \ s * \ \ n ) + &apos; , re.MULTILINE ) DCNL DCSP text = dedent ( text ) .strip ( ) DCNL DCSP paragraphs = paragraph _ re.split ( text ) &#91; : : 2 &#93; DCNL DCSP out _ ps = &#91; &#93; DCNL DCSP indent _ re = re.compile ( &apos; \ \ n \ \ s + &apos; , re.MULTILINE ) DCNL DCSP for p in paragraphs : DCNL DCSP DCSP if ( indent _ re.search ( p ) is None ) : DCNL DCSP DCSP DCSP p = textwrap.fill ( p , ncols ) DCNL DCSP DCSP out _ ps.append ( p ) DCNL DCSP return out _ ps
DCSP if os.path.isfile ( path ) : DCNL DCSP DCSP os.remove ( path )
DCSP try : DCNL DCSP DCSP to _ index = PyQuery ( content ) .text ( ) DCNL DCSP except ValueError : DCNL DCSP DCSP return &apos; &apos; DCNL DCSP return to _ index
DCSP bits = token.split _ contents ( ) DCNL DCSP options = { } DCNL DCSP remaining _ bits = bits &#91; 1 : &#93; DCNL DCSP while remaining _ bits : DCNL DCSP DCSP option = remaining _ bits.pop ( 0 ) DCNL DCSP DCSP if ( option in options ) : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; The DCSP % r DCSP option DCSP was DCSP specified DCSP more DCSP than DCSP once . &apos; % option ) ) DCNL DCSP DCSP if ( option = = &apos; with &apos; ) : DCNL DCSP DCSP DCSP value = token _ kwargs ( remaining _ bits , parser , support _ legacy = True ) DCNL DCSP DCSP DCSP if ( not value ) : DCNL DCSP DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; &quot; with &quot; DCSP in DCSP % r DCSP tag DCSP needs DCSP at DCSP least DCSP one DCSP keyword DCSP argument . &apos; % bits &#91; 0 &#93; ) ) DCNL DCSP DCSP elif ( option = = &apos; count &apos; ) : DCNL DCSP DCSP DCSP value = token _ kwargs ( remaining _ bits , parser , support _ legacy = True ) DCNL DCSP DCSP DCSP if ( len ( value ) ! = 1 ) : DCNL DCSP DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; &quot; count &quot; DCSP in DCSP % r DCSP tag DCSP expected DCSP exactly DCSP one DCSP keyword DCSP argument . &apos; % bits &#91; 0 &#93; ) ) DCNL DCSP DCSP elif ( option = = &apos; context &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP value = remaining _ bits.pop ( 0 ) DCNL DCSP DCSP DCSP DCSP value = parser.compile _ filter ( value ) DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; &quot; context &quot; DCSP in DCSP % r DCSP tag DCSP expected DCSP exactly DCSP one DCSP argument . &apos; % bits &#91; 0 &#93; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; Unknown DCSP argument DCSP for DCSP % r DCSP tag : DCSP % r . &apos; % ( bits &#91; 0 &#93; , option ) ) ) DCNL DCSP DCSP options &#91; option &#93; = value DCNL DCSP if ( &apos; count &apos; in options ) : DCNL DCSP DCSP ( countervar , counter ) = options &#91; &apos; count &apos; &#93; .items ( ) &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP ( countervar , counter ) = ( None , None ) DCNL DCSP if ( &apos; context &apos; in options ) : DCNL DCSP DCSP message _ context = options &#91; &apos; context &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP message _ context = None DCNL DCSP extra _ context = options.get ( &apos; with &apos; , { } ) DCNL DCSP singular = &#91; &#93; DCNL DCSP plural = &#91; &#93; DCNL DCSP while parser.tokens : DCNL DCSP DCSP token = parser.next _ token ( ) DCNL DCSP DCSP if ( token.token _ type in ( TOKEN _ VAR , TOKEN _ TEXT ) ) : DCNL DCSP DCSP DCSP singular.append ( token ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP break DCNL DCSP if ( countervar and counter ) : DCNL DCSP DCSP if ( token.contents.strip ( ) ! = &apos; plural &apos; ) : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( &quot; &apos; blocktrans &apos; DCSP doesn &apos;t DCSP allow DCSP other DCSP block DCSP tags DCSP inside DCSP it &quot; ) DCNL DCSP DCSP while parser.tokens : DCNL DCSP DCSP DCSP token = parser.next _ token ( ) DCNL DCSP DCSP DCSP if ( token.token _ type in ( TOKEN _ VAR , TOKEN _ TEXT ) ) : DCNL DCSP DCSP DCSP DCSP plural.append ( token ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP if ( token.contents.strip ( ) ! = &apos; endblocktrans &apos; ) : DCNL DCSP DCSP raise TemplateSyntaxError ( ( &quot; &apos; blocktrans &apos; DCSP doesn &apos;t DCSP allow DCSP other DCSP block DCSP tags DCSP ( seen DCSP % r ) DCSP inside DCSP it &quot; % token.contents ) ) DCNL DCSP return BlockTranslateNode ( extra _ context , singular , plural , countervar , counter , message _ context )
DCSP if ( entry = = None ) : DCNL DCSP DCSP return DCNL DCSP entry.delete ( 0 , Tkinter.END ) DCNL DCSP entry.insert ( 0 , str ( value ) )
DCSP center = &apos; median &apos; DCNL DCSP proportiontocut = 0.05 DCNL DCSP for ( kw , value ) in kwds.items ( ) : DCNL DCSP DCSP if ( kw not in &#91; &apos; center &apos; , &apos; proportiontocut &apos; &#93; ) : DCNL DCSP DCSP DCSP raise TypeError ( ( &quot; levene ( ) DCSP got DCSP an DCSP unexpected DCSP keyword DCSP argument DCSP &apos; % s &apos; &quot; % kw ) ) DCNL DCSP DCSP if ( kw = = &apos; center &apos; ) : DCNL DCSP DCSP DCSP center = value DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP proportiontocut = value DCNL DCSP k = len ( args ) DCNL DCSP if ( k &lt; 2 ) : DCNL DCSP DCSP raise ValueError ( &apos; Must DCSP enter DCSP at DCSP least DCSP two DCSP input DCSP sample DCSP vectors . &apos; ) DCNL DCSP Ni = zeros ( k ) DCNL DCSP Yci = zeros ( k , &apos; d &apos; ) DCNL DCSP if ( center not in &#91; &apos; mean &apos; , &apos; median &apos; , &apos; trimmed &apos; &#93; ) : DCNL DCSP DCSP raise ValueError ( &quot; Keyword DCSP argument DCSP &lt; center &gt; DCSP must DCSP be DCSP &apos; mean &apos; , DCSP &apos; median &apos; DCSP or DCSP &apos; trimmed &apos; . &quot; ) DCNL DCSP if ( center = = &apos; median &apos; ) : DCNL DCSP DCSP func = ( lambda x : np.median ( x , axis = 0 ) ) DCNL DCSP elif ( center = = &apos; mean &apos; ) : DCNL DCSP DCSP func = ( lambda x : np.mean ( x , axis = 0 ) ) DCNL DCSP else : DCNL DCSP DCSP args = tuple ( ( stats.trimboth ( np.sort ( arg ) , proportiontocut ) for arg in args ) ) DCNL DCSP DCSP func = ( lambda x : np.mean ( x , axis = 0 ) ) DCNL DCSP for j in range ( k ) : DCNL DCSP DCSP Ni &#91; j &#93; = len ( args &#91; j &#93; ) DCNL DCSP DCSP Yci &#91; j &#93; = func ( args &#91; j &#93; ) DCNL DCSP Ntot = np.sum ( Ni , axis = 0 ) DCNL DCSP Zij = ( &#91; None &#93; * k ) DCNL DCSP for i in range ( k ) : DCNL DCSP DCSP Zij &#91; i &#93; = abs ( ( asarray ( args &#91; i &#93; ) - Yci &#91; i &#93; ) ) DCNL DCSP Zbari = zeros ( k , &apos; d &apos; ) DCNL DCSP Zbar = 0.0 DCNL DCSP for i in range ( k ) : DCNL DCSP DCSP Zbari &#91; i &#93; = np.mean ( Zij &#91; i &#93; , axis = 0 ) DCNL DCSP DCSP Zbar + = ( Zbari &#91; i &#93; * Ni &#91; i &#93; ) DCNL DCSP Zbar / = Ntot DCNL DCSP numer = ( ( Ntot - k ) * np.sum ( ( Ni * ( ( Zbari - Zbar ) * * 2 ) ) , axis = 0 ) ) DCNL DCSP dvar = 0.0 DCNL DCSP for i in range ( k ) : DCNL DCSP DCSP dvar + = np.sum ( ( ( Zij &#91; i &#93; - Zbari &#91; i &#93; ) * * 2 ) , axis = 0 ) DCNL DCSP denom = ( ( k - 1.0 ) * dvar ) DCNL DCSP W = ( numer / denom ) DCNL DCSP pval = distributions.f.sf ( W , ( k - 1 ) , ( Ntot - k ) ) DCNL DCSP return LeveneResult ( W , pval )
DCSP for innerNestedRing in nestedRing.innerNestedRings : DCNL DCSP DCSP createFillForSurroundings ( innerNestedRing.innerNestedRings , radius , radiusAround , shouldExtraLoopsBeAdded ) DCNL DCSP allFillLoops = intercircle.getInsetSeparateLoopsFromAroundLoops ( nestedRing.getLoopsToBeFilled ( ) , radius , max ( ( 1.4 * radius ) , radiusAround ) ) DCNL DCSP if ( len ( allFillLoops ) &lt; 1 ) : DCNL DCSP DCSP return DCNL DCSP if shouldExtraLoopsBeAdded : DCNL DCSP DCSP nestedRing.extraLoops + = allFillLoops DCNL DCSP DCSP nestedRing.penultimateFillLoops = nestedRing.lastFillLoops DCNL DCSP nestedRing.lastFillLoops = allFillLoops
DCSP letters = re.compile ( &apos; &#91; A-PR-Y &#93; &apos; , re.I ) DCNL DCSP char2number = ( lambda m : { &apos; a &apos; : &apos; 2&apos; , &apos; c &apos; : &apos; 2&apos; , &apos; b &apos; : &apos; 2&apos; , &apos; e &apos; : &apos; 3&apos; , &apos; d &apos; : &apos; 3&apos; , &apos; g &apos; : &apos; 4&apos; , &apos; f &apos; : &apos; 3&apos; , &apos; i &apos; : &apos; 4&apos; , &apos; h &apos; : &apos; 4&apos; , &apos; k &apos; : &apos; 5&apos; , &apos; j &apos; : &apos; 5&apos; , &apos; m &apos; : &apos; 6&apos; , &apos; l &apos; : &apos; 5&apos; , &apos; o &apos; : &apos; 6&apos; , &apos; n &apos; : &apos; 6&apos; , &apos; p &apos; : &apos; 7&apos; , &apos; s &apos; : &apos; 7&apos; , &apos; r &apos; : &apos; 7&apos; , &apos; u &apos; : &apos; 8&apos; , &apos; t &apos; : &apos; 8&apos; , &apos; w &apos; : &apos; 9&apos; , &apos; v &apos; : &apos; 8&apos; , &apos; y &apos; : &apos; 9&apos; , &apos; x &apos; : &apos; 9&apos; } .get ( m.group ( 0 ) .lower ( ) ) ) DCNL DCSP return letters.sub ( char2number , phone )
DCSP pass
DCSP ( dirname , _ ) = os.path.split ( filename ) DCNL DCSP if ( dirname and ( not os.path.exists ( dirname ) ) ) : DCNL DCSP DCSP os.makedirs ( dirname )
DCSP ( featuresNorm , MEAN , STD ) = normalizeFeatures ( &#91; features &#93; ) DCNL DCSP featuresNorm = featuresNorm &#91; 0 &#93; DCNL DCSP nSamples = labels.shape &#91; 0 &#93; DCNL DCSP partTrain = 0.9 DCNL DCSP ErrorsAll = &#91; &#93; DCNL DCSP ErrorsTrainAll = &#91; &#93; DCNL DCSP ErrorsBaselineAll = &#91; &#93; DCNL DCSP for ( Ci , C ) in enumerate ( Params ) : DCNL DCSP DCSP Errors = &#91; &#93; DCNL DCSP DCSP ErrorsTrain = &#91; &#93; DCNL DCSP DCSP ErrorsBaseline = &#91; &#93; DCNL DCSP DCSP for e in range ( nExp ) : DCNL DCSP DCSP DCSP randperm = numpy.random.permutation ( range ( nSamples ) ) DCNL DCSP DCSP DCSP nTrain = int ( round ( ( partTrain * nSamples ) ) ) DCNL DCSP DCSP DCSP featuresTrain = &#91; featuresNorm &#91; randperm &#91; i &#93; &#93; for i in range ( nTrain ) &#93; DCNL DCSP DCSP DCSP featuresTest = &#91; featuresNorm &#91; randperm &#91; ( i + nTrain ) &#93; &#93; for i in range ( ( nSamples - nTrain ) ) &#93; DCNL DCSP DCSP DCSP labelsTrain = &#91; labels &#91; randperm &#91; i &#93; &#93; for i in range ( nTrain ) &#93; DCNL DCSP DCSP DCSP labelsTest = &#91; labels &#91; randperm &#91; ( i + nTrain ) &#93; &#93; for i in range ( ( nSamples - nTrain ) ) &#93; DCNL DCSP DCSP DCSP featuresTrain = numpy.matrix ( featuresTrain ) DCNL DCSP DCSP DCSP if ( MethodName = = &apos; svm &apos; ) : DCNL DCSP DCSP DCSP DCSP &#91; Classifier , trainError &#93; = trainSVMregression ( featuresTrain , labelsTrain , C ) DCNL DCSP DCSP DCSP ErrorTest = &#91; &#93; DCNL DCSP DCSP DCSP ErrorTestBaseline = &#91; &#93; DCNL DCSP DCSP DCSP for ( itest , fTest ) in enumerate ( featuresTest ) : DCNL DCSP DCSP DCSP DCSP R = regressionWrapper ( Classifier , MethodName , fTest ) DCNL DCSP DCSP DCSP DCSP Rbaseline = numpy.mean ( labelsTrain ) DCNL DCSP DCSP DCSP DCSP ErrorTest.append ( ( ( R - labelsTest &#91; itest &#93; ) * ( R - labelsTest &#91; itest &#93; ) ) ) DCNL DCSP DCSP DCSP DCSP ErrorTestBaseline.append ( ( ( Rbaseline - labelsTest &#91; itest &#93; ) * ( Rbaseline - labelsTest &#91; itest &#93; ) ) ) DCNL DCSP DCSP DCSP Error = numpy.array ( ErrorTest ) .mean ( ) DCNL DCSP DCSP DCSP ErrorBaseline = numpy.array ( ErrorTestBaseline ) .mean ( ) DCNL DCSP DCSP DCSP Errors.append ( Error ) DCNL DCSP DCSP DCSP ErrorsTrain.append ( trainError ) DCNL DCSP DCSP DCSP ErrorsBaseline.append ( ErrorBaseline ) DCNL DCSP DCSP ErrorsAll.append ( numpy.array ( Errors ) .mean ( ) ) DCNL DCSP DCSP ErrorsTrainAll.append ( numpy.array ( ErrorsTrain ) .mean ( ) ) DCNL DCSP DCSP ErrorsBaselineAll.append ( numpy.array ( ErrorsBaseline ) .mean ( ) ) DCNL DCSP bestInd = numpy.argmin ( ErrorsAll ) DCNL DCSP print &apos; { 0 : s } DCTB DCTB { 1 : s } DCTB DCTB { 2 : s } DCTB DCTB { 3 : s } &apos; .format ( &apos; Param &apos; , &apos; MSE &apos; , &apos; T-MSE &apos; , &apos; R-MSE &apos; ) DCNL DCSP for i in range ( len ( ErrorsAll ) ) : DCNL DCSP DCSP print &apos; { 0 : .4f } DCTB DCTB { 1 : .2f } DCTB DCTB { 2 : .2f } DCTB DCTB { 3 : .2f } &apos; .format ( Params &#91; i &#93; , ErrorsAll &#91; i &#93; , ErrorsTrainAll &#91; i &#93; , ErrorsBaselineAll &#91; i &#93; ) , DCNL DCSP DCSP if ( i = = bestInd ) : DCNL DCSP DCSP DCSP print &apos; DCTB DCTB DCSP best &apos; , DCNL DCSP DCSP print DCNL DCSP return Params &#91; bestInd &#93;
DCSP conn = _ get _ driver ( profile = profile ) DCNL DCSP return conn.get _ record ( zone _ id , record _ id )
DCSP ret = salt.utils.mac _ utils.execute _ return _ result ( &apos; systemsetup DCSP -getrestartpowerfailure &apos; ) DCNL DCSP return ( salt.utils.mac _ utils.validate _ enabled ( salt.utils.mac _ utils.parse _ return ( ret ) ) = = &apos; on &apos; )
DCSP for ( x _ i , y _ i , ( low , high ) ) in zip ( x , central _ data , ci.T ) : DCNL DCSP DCSP ax.plot ( &#91; x _ i , x _ i &#93; , &#91; low , high &#93; , color = color , solid _ capstyle = &apos; round &apos; , * * err _ kws )
DCSP query = models.HostQueueEntry.query _ objects ( filter _ data ) DCNL DCSP complete _ count = query.filter ( complete = True ) .count ( ) DCNL DCSP total _ count = query.count ( ) DCNL DCSP if ( total _ count = = 0 ) : DCNL DCSP DCSP return 1 DCNL DCSP return ( float ( complete _ count ) / total _ count )
DCSP encrypter = Encrypter ( mode , padding = padding ) DCNL DCSP _ feed _ stream ( encrypter , in _ stream , out _ stream , block _ size )
DCSP return divider.join ( &#91; el &#91; 0 &#93; for el in query &#93; )
DCSP return os.path.abspath ( os.path.join ( path , os.pardir ) )
DCSP meta _ sources = { } DCNL DCSP for ( module _ path , class _ name ) in SOURCES.items ( ) : DCNL DCSP DCSP module = import _ module ( ( ( METASYNC _ MODULE + &apos; .&apos; ) + module _ path ) ) DCNL DCSP DCSP meta _ sources &#91; class _ name.lower ( ) &#93; = getattr ( module , class _ name ) DCNL DCSP return meta _ sources
DCSP alias _ sql = sqlalchemy.text ( u &apos;SELECT DCSP alias _ of DCSP FROM DCSP &quot; _ table _ metadata &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP WHERE DCSP name DCSP = DCSP : alias DCSP AND DCSP alias _ of DCSP IS DCSP NOT DCSP NULL &apos; ) DCNL DCSP results = context &#91; &apos; connection &apos; &#93; .execute ( alias _ sql , alias = alias ) .fetchall ( ) DCNL DCSP return &#91; x &#91; 0 &#93; for x in results &#93;
DCSP from simplewiki import database DCNL DCSP wiki = make _ wiki ( ) DCNL DCSP wiki.bind _ to _ context ( ) DCNL DCSP return { &apos; wiki &apos; : wiki , &apos; db &apos; : database }
DCSP if ( not os.path.exists ( work _ directory ) ) : DCNL DCSP DCSP os.mkdir ( work _ directory ) DCNL DCSP filepath = os.path.join ( work _ directory , filename ) DCNL DCSP if ( not os.path.exists ( filepath ) ) : DCNL DCSP DCSP print ( &apos; Downloading DCSP MNIST ... &apos; ) DCNL DCSP DCSP ( filepath , _ ) = urllib.request.urlretrieve ( ( SOURCE _ URL + filename ) , filepath ) DCNL DCSP DCSP statinfo = os.stat ( filepath ) DCNL DCSP DCSP print ( &apos; Succesfully DCSP downloaded &apos; , filename , statinfo.st _ size , &apos; bytes . &apos; ) DCNL DCSP return filepath
DCSP range _ operands = &#91; Constant.int ( load.type , lower _ bound ) , Constant.int ( load.type , upper _ bound ) &#93; DCNL DCSP md = builder.module.add _ metadata ( range _ operands ) DCNL DCSP load.set _ metadata ( &apos; range &apos; , md )
DCSP found _ pid = False DCNL DCSP pid _ str = ( &apos; DCSP PID : DCSP % s DCSP &apos; % pid ) DCNL DCSP for line in fileinput.input ( glob.glob ( ( static.DEBUG _ FILE + &apos; * &apos; ) ) ) : DCNL DCSP DCSP if ( pid _ str in line ) : DCNL DCSP DCSP DCSP ( yield line ) DCNL DCSP DCSP DCSP found _ pid = True DCNL DCSP DCSP elif ( found _ pid and ( &apos; DCSP PID : DCSP &apos; not in line ) ) : DCNL DCSP DCSP DCSP ( yield line ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP found _ pid = False
DCSP size = ( params &#91; &apos; fig &apos; &#93; .get _ size _ inches ( ) * params &#91; &apos; fig &apos; &#93; .dpi ) DCNL DCSP scroll _ width = 25 DCNL DCSP hscroll _ dist = 25 DCNL DCSP vscroll _ dist = 10 DCNL DCSP l _ border = 100 DCNL DCSP r _ border = 10 DCNL DCSP t _ border = 35 DCNL DCSP b _ border = 40 DCNL DCSP if ( ( size &#91; 0 &#93; &lt; ( 2 * scroll _ width ) ) or ( size &#91; 1 &#93; &lt; ( ( 2 * scroll _ width ) + hscroll _ dist ) ) ) : DCNL DCSP DCSP return DCNL DCSP scroll _ width _ x = ( scroll _ width / size &#91; 0 &#93; ) DCNL DCSP scroll _ width _ y = ( scroll _ width / size &#91; 1 &#93; ) DCNL DCSP vscroll _ dist / = size &#91; 0 &#93; DCNL DCSP hscroll _ dist / = size &#91; 1 &#93; DCNL DCSP l _ border / = size &#91; 0 &#93; DCNL DCSP r _ border / = size &#91; 0 &#93; DCNL DCSP t _ border / = size &#91; 1 &#93; DCNL DCSP b _ border / = size &#91; 1 &#93; DCNL DCSP ax _ width = ( ( ( ( 1.0 - scroll _ width _ x ) - l _ border ) - r _ border ) - vscroll _ dist ) DCNL DCSP ax _ y = ( ( hscroll _ dist + scroll _ width _ y ) + b _ border ) DCNL DCSP ax _ height = ( ( 1.0 - ax _ y ) - t _ border ) DCNL DCSP pos = &#91; l _ border , ax _ y , ax _ width , ax _ height &#93; DCNL DCSP params &#91; &apos; ax &apos; &#93; .set _ position ( pos ) DCNL DCSP if ( &apos; ax2 &apos; in params ) : DCNL DCSP DCSP params &#91; &apos; ax2 &apos; &#93; .set _ position ( pos ) DCNL DCSP params &#91; &apos; ax &apos; &#93; .set _ position ( pos ) DCNL DCSP pos = &#91; ( ( ax _ width + l _ border ) + vscroll _ dist ) , ax _ y , scroll _ width _ x , ax _ height &#93; DCNL DCSP params &#91; &apos; ax _ vscroll &apos; &#93; .set _ position ( pos ) DCNL DCSP pos = &#91; l _ border , b _ border , ax _ width , scroll _ width _ y &#93; DCNL DCSP params &#91; &apos; ax _ hscroll &apos; &#93; .set _ position ( pos ) DCNL DCSP if ( &apos; ax _ button &apos; in params ) : DCNL DCSP DCSP pos = &#91; ( ( l _ border + ax _ width ) + vscroll _ dist ) , b _ border , scroll _ width _ x , scroll _ width _ y &#93; DCNL DCSP DCSP params &#91; &apos; ax _ button &apos; &#93; .set _ position ( pos ) DCNL DCSP if ( &apos; ax _ help _ button &apos; in params ) : DCNL DCSP DCSP pos = &#91; ( ( l _ border - vscroll _ dist ) - ( scroll _ width _ x * 2 ) ) , b _ border , ( scroll _ width _ x * 2 ) , scroll _ width _ y &#93; DCNL DCSP DCSP params &#91; &apos; ax _ help _ button &apos; &#93; .set _ position ( pos ) DCNL DCSP params &#91; &apos; fig &apos; &#93; .canvas.draw ( )
DCSP _ test _ fetch ( &apos; http : / / google.com &apos; )
DCSP if ( mock _ hadoop _ uses _ yarn ( environ ) and args and ( args &#91; 0 &#93; = = &apos; -R &apos; ) ) : DCNL DCSP DCSP path _ args = args &#91; 1 : &#93; DCNL DCSP DCSP recursive = True DCNL DCSP else : DCNL DCSP DCSP path _ args = args DCNL DCSP DCSP recursive = False DCNL DCSP return _ hadoop _ fs _ ls ( &apos; ls &apos; , stdout , stderr , environ , path _ args = path _ args , recursive = recursive )
DCSP return re.sub ( &apos; ( ? m ) ^ ( ? ! $ ) &apos; , ( indent * &apos; DCSP &apos; ) , s )
DCSP model _ n = 7 DCNL DCSP if binocular : DCNL DCSP DCSP model _ n = 13 DCNL DCSP cal _ pt _ cloud = np.array ( cal _ pt _ cloud ) DCNL DCSP ( cx , cy , err _ x , err _ y ) = fit _ poly _ surface ( cal _ pt _ cloud , model _ n ) DCNL DCSP ( err _ dist , err _ mean , err _ rms ) = fit _ error _ screen ( err _ x , err _ y , screen _ size ) DCNL DCSP if cal _ pt _ cloud &#91; ( err _ dist &lt; = threshold ) &#93; .shape &#91; 0 &#93; : DCNL DCSP DCSP ( cx , cy , new _ err _ x , new _ err _ y ) = fit _ poly _ surface ( cal _ pt _ cloud &#91; ( err _ dist &lt; = threshold ) &#93; , model _ n ) DCNL DCSP DCSP map _ fn = make _ map _ function ( cx , cy , model _ n ) DCNL DCSP DCSP ( new _ err _ dist , new _ err _ mean , new _ err _ rms ) = fit _ error _ screen ( new _ err _ x , new _ err _ y , screen _ size ) DCNL DCSP DCSP logger.info ( &apos; first DCSP iteration . DCSP root-mean-square DCSP residuals : DCSP { } , DCSP in DCSP pixel &apos; .format ( err _ rms ) ) DCNL DCSP DCSP logger.info ( &apos; second DCSP iteration : DCSP ignoring DCSP outliers . DCSP root-mean-square DCSP residuals : DCSP { } DCSP in DCSP pixel &apos; .format ( new _ err _ rms ) ) DCNL DCSP DCSP logger.info ( &apos; used DCSP { } DCSP data DCSP points DCSP out DCSP of DCSP the DCSP full DCSP dataset DCSP { } : DCSP subset DCSP is DCSP { } DCSP percent &apos; .format ( ( cal _ pt _ cloud &#91; ( err _ dist &lt; = threshold ) &#93; .shape &#91; 0 &#93; , cal _ pt _ cloud.shape &#91; 0 &#93; , ( ( 100 * float ( cal _ pt _ cloud &#91; ( err _ dist &lt; = threshold ) &#93; .shape &#91; 0 &#93; ) ) / cal _ pt _ cloud.shape &#91; 0 &#93; ) ) ) ) DCNL DCSP DCSP return ( map _ fn , ( err _ dist &lt; = threshold ) , ( cx , cy , model _ n ) ) DCNL DCSP else : DCNL DCSP DCSP map _ fn = make _ map _ function ( cx , cy , model _ n ) DCNL DCSP DCSP logger.error ( &apos; First DCSP iteration . DCSP root-mean-square DCSP residuals : DCSP { } DCSP in DCSP pixel , DCSP this DCSP is DCSP bad ! &apos; .format ( err _ rms ) ) DCNL DCSP DCSP logger.error ( &apos; The DCSP data DCSP cannot DCSP be DCSP represented DCSP by DCSP the DCSP model DCSP in DCSP a DCSP meaningfull DCSP way . &apos; ) DCNL DCSP DCSP return ( map _ fn , ( err _ dist &lt; = threshold ) , ( cx , cy , model _ n ) )
DCSP sig = np.empty ( 1000 ) DCNL DCSP sfreq = 1000 DCNL DCSP assert _ raises ( RuntimeError , filter _ data , sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( ftype = &apos; butter &apos; , order = 8 , output = &apos; ba &apos; ) ) DCNL DCSP filter _ data ( sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( ftype = &apos; butter &apos; , order = 8 , output = &apos; sos &apos; ) ) DCNL DCSP assert _ raises ( ValueError , filter _ data , sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( ftype = &apos; butter &apos; , order = 8 , output = &apos; foo &apos; ) ) DCNL DCSP assert _ raises ( RuntimeError , filter _ data , sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( order = 8 , output = &apos; sos &apos; ) ) DCNL DCSP assert _ raises ( RuntimeError , filter _ data , sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( order = 8 , ftype = &apos; foo &apos; , output = &apos; sos &apos; ) ) DCNL DCSP assert _ raises ( RuntimeError , filter _ data , sig , sfreq , 0.6 , None , method = &apos; iir &apos; , iir _ params = dict ( gpass = 0.5 , output = &apos; sos &apos; ) ) DCNL DCSP assert _ raises ( ValueError , filter _ data , sig , sfreq , 0.1 , None , method = &apos; fft &apos; , iir _ params = dict ( ftype = &apos; butter &apos; , order = 2 , output = &apos; sos &apos; ) ) DCNL DCSP assert _ raises ( TypeError , filter _ data , sig , sfreq , 0.1 , None , method = 1 ) DCNL DCSP assert _ raises ( ValueError , filter _ data , sig , sfreq , 0.1 , None , method = &apos; blah &apos; ) DCNL DCSP assert _ raises ( TypeError , filter _ data , sig , sfreq , 0.1 , None , method = &apos; iir &apos; , iir _ params = &apos; blah &apos; ) DCNL DCSP assert _ raises ( ValueError , filter _ data , sig , sfreq , 0.1 , None , method = &apos; fft &apos; , iir _ params = dict ( ) ) DCNL DCSP iir _ params = dict ( ftype = &apos; butter &apos; , order = 2 , output = &apos; sos &apos; ) DCNL DCSP x _ sos = filter _ data ( sig , 250 , 0.5 , None , method = &apos; iir &apos; , iir _ params = iir _ params ) DCNL DCSP iir _ params _ sos = construct _ iir _ filter ( iir _ params , f _ pass = 0.5 , sfreq = 250 , btype = &apos; highpass &apos; ) DCNL DCSP x _ sos _ 2 = filter _ data ( sig , 250 , 0.5 , None , method = &apos; iir &apos; , iir _ params = iir _ params _ sos ) DCNL DCSP assert _ allclose ( x _ sos &#91; 100 : ( -100 ) &#93; , x _ sos _ 2 &#91; 100 : ( -100 ) &#93; ) DCNL DCSP x _ ba = filter _ data ( sig , 250 , 0.5 , None , method = &apos; iir &apos; , iir _ params = dict ( ftype = &apos; butter &apos; , order = 2 , output = &apos; ba &apos; ) ) DCNL DCSP assert _ allclose ( x _ sos &#91; 100 : ( -100 ) &#93; , x _ ba &#91; 100 : ( -100 ) &#93; )
DCSP return re.sub ( &apos; &#91; ^ A-Za-z0-9.- &#93; + &apos; , &apos; _ &apos; , extra ) .lower ( )
DCSP lines = archive.getTextLines ( text ) DCNL DCSP shortDictionary = { } DCNL DCSP for setting in repository.preferences : DCNL DCSP DCSP shortDictionary &#91; getShortestUniqueSettingName ( setting.name , repository.preferences ) &#93; = setting DCNL DCSP for lineIndex in xrange ( len ( lines ) ) : DCNL DCSP DCSP setRepositoryToLine ( lineIndex , lines , shortDictionary )
DCSP return &apos; \ n &apos; .join ( salt.version.versions _ report ( ) )
DCSP import subprocess , time DCNL DCSP result = pEyeGaze.EgExit ( byref ( eyegaze _ control ) ) DCNL DCSP eyegaze _ control = None DCNL DCSP p = subprocess.Popen ( ( &apos; calibrate.exe &apos; , &apos; &apos; ) ) DCNL DCSP while ( p.poll ( ) is None ) : DCNL DCSP DCSP time.sleep ( 0.05 ) DCNL DCSP return initEyeGaze ( )
DCSP if ( len ( fps ) ! = len ( distmats ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Must DCSP provide DCSP the DCSP same DCSP number DCSP of DCSP filepaths DCSP as DCSP there DCSP are DCSP distance DCSP matrices . &apos; ) DCNL DCSP if ( comment is None ) : DCNL DCSP DCSP comment = &apos; &apos; DCNL DCSP result = ( ( ( ( comment + &apos; DM1 DCTB DM2 DCTB Number DCSP of DCSP entries DCTB &apos; ) + &apos; Number DCSP of DCSP permutations DCTB Class DCSP index DCTB &apos; ) + &apos; Number DCSP of DCSP distances DCTB Mantel DCSP r DCSP statistic DCTB &apos; ) + &apos; p-value DCTB p-value DCSP ( Bonferroni DCSP corrected ) DCTB Tail DCSP type \ n &apos; ) DCNL DCSP correlogram _ fps = &#91; &#93; DCNL DCSP correlograms = &#91; &#93; DCNL DCSP for ( i , ( fp1 , ( dm1 _ labels , dm1 _ data ) ) ) in enumerate ( zip ( fps , distmats ) ) : DCNL DCSP DCSP for ( fp2 , ( dm2 _ labels , dm2 _ data ) ) in zip ( fps , distmats ) &#91; ( i + 1 ) : &#93; : DCNL DCSP DCSP DCSP ( ( dm1 _ labels , dm1 _ data ) , ( dm2 _ labels , dm2 _ data ) ) = make _ compatible _ distance _ matrices ( ( dm1 _ labels , dm1 _ data ) , ( dm2 _ labels , dm2 _ data ) , lookup = sample _ id _ map ) DCNL DCSP DCSP DCSP if ( len ( dm1 _ labels ) &lt; 3 ) : DCNL DCSP DCSP DCSP DCSP result + = ( &apos; % s DCTB % s DCTB % d DCTB Too DCSP few DCSP samples \ n &apos; % ( fp1 , fp2 , len ( dm1 _ labels ) ) ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP dm1 = DistanceMatrix ( dm1 _ data , dm1 _ labels ) DCNL DCSP DCSP DCSP dm2 = DistanceMatrix ( dm2 _ data , dm2 _ labels ) DCNL DCSP DCSP DCSP mc = MantelCorrelogram ( dm1 , dm2 , alpha = alpha , variable _ size _ distance _ classes = variable _ size _ distance _ classes ) DCNL DCSP DCSP DCSP results = mc ( num _ perms ) DCNL DCSP DCSP DCSP dm1 _ name = path.basename ( fp1 ) DCNL DCSP DCSP DCSP dm2 _ name = path.basename ( fp2 ) DCNL DCSP DCSP DCSP correlogram _ fps.append ( ( &apos; _ &apos; .join ( ( dm1 _ name , &apos; AND &apos; , dm2 _ name , &apos; mantel _ correlogram &apos; ) ) + &apos; .&apos; ) ) DCNL DCSP DCSP DCSP correlograms.append ( results &#91; &apos; correlogram _ plot &apos; &#93; ) DCNL DCSP DCSP DCSP first _ time = True DCNL DCSP DCSP DCSP for ( class _ idx , num _ dist , r , p , p _ corr ) in zip ( results &#91; &apos; class _ index &apos; &#93; , results &#91; &apos; num _ dist &apos; &#93; , results &#91; &apos; mantel _ r &apos; &#93; , results &#91; &apos; mantel _ p &apos; &#93; , results &#91; &apos; mantel _ p _ corr &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP p _ str = None DCNL DCSP DCSP DCSP DCSP if ( p is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP p _ str = p _ value _ to _ str ( p , num _ perms ) DCNL DCSP DCSP DCSP DCSP p _ corr _ str = None DCNL DCSP DCSP DCSP DCSP if ( p _ corr is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP p _ corr _ str = p _ value _ to _ str ( p _ corr , num _ perms ) DCNL DCSP DCSP DCSP DCSP if ( r is None ) : DCNL DCSP DCSP DCSP DCSP DCSP tail _ type = None DCNL DCSP DCSP DCSP DCSP elif ( r &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP tail _ type = &apos; less &apos; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP tail _ type = &apos; greater &apos; DCNL DCSP DCSP DCSP DCSP if first _ time : DCNL DCSP DCSP DCSP DCSP DCSP result + = ( &apos; % s DCTB % s DCTB % d DCTB % d DCTB % s DCTB % d DCTB % s DCTB % s DCTB % s DCTB % s \ n &apos; % ( fp1 , fp2 , len ( dm1 _ labels ) , num _ perms , class _ idx , num _ dist , r , p _ str , p _ corr _ str , tail _ type ) ) DCNL DCSP DCSP DCSP DCSP DCSP first _ time = False DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP result + = ( &apos; DCTB DCTB DCTB DCTB % s DCTB % d DCTB % s DCTB % s DCTB % s DCTB % s \ n &apos; % ( class _ idx , num _ dist , r , p _ str , p _ corr _ str , tail _ type ) ) DCNL DCSP return ( result , correlogram _ fps , correlograms )
DCSP if ( port _ eth in ( True , None ) ) : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP port _ eth = EthAddr ( port _ eth ) DCNL DCSP dpid = str _ to _ dpid ( dpid ) DCNL DCSP try : DCNL DCSP DCSP port = int ( port ) DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP def dhcpclient _ init ( ) : DCNL DCSP DCSP n = name DCNL DCSP DCSP if ( n is None ) : DCNL DCSP DCSP DCSP s = &apos; &apos; DCNL DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP if ( not core.hasComponent ( ( &apos; DHCPClient &apos; + s ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP n = ( &apos; DHCPClient &apos; + s ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP DCSP s = str ( ( int ( ( &apos; 0&apos; + s ) ) + 1 ) ) DCNL DCSP DCSP elif core.hasComponent ( n ) : DCNL DCSP DCSP DCSP self.log.error ( &apos; Already DCSP have DCSP component DCSP % s &apos; , n ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP client = DHCPClient ( port = port , dpid = dpid , name = n , port _ eth = port _ eth ) DCNL DCSP DCSP core.register ( n , client ) DCNL DCSP core.call _ when _ ready ( dhcpclient _ init , &#91; &apos; openflow &apos; &#93; )
DCSP if ( not isinstance ( config , dict ) ) : DCNL DCSP DCSP return ( False , &apos; Configuration DCSP for DCSP btmp DCSP beacon DCSP must DCSP be DCSP a DCSP list DCSP of DCSP dictionaries . &apos; ) DCNL DCSP return ( True , &apos; Valid DCSP beacon DCSP configuration &apos; )
DCSP plotter = _ HeatMapper ( data , vmin , vmax , cmap , center , robust , annot , fmt , annot _ kws , cbar , cbar _ kws , xticklabels , yticklabels , mask ) DCNL DCSP kwargs &#91; &apos; linewidths &apos; &#93; = linewidths DCNL DCSP kwargs &#91; &apos; edgecolor &apos; &#93; = linecolor DCNL DCSP if ( ax is None ) : DCNL DCSP DCSP ax = plt.gca ( ) DCNL DCSP if square : DCNL DCSP DCSP ax.set _ aspect ( &apos; equal &apos; ) DCNL DCSP plotter.plot ( ax , cbar _ ax , kwargs ) DCNL DCSP return ax
DCSP @ wraps ( fun ) DCNL DCSP def get ( self ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return self . _ cache &#91; fun &#93; DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP self . _ cache = { } DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP ret = self . _ cache &#91; fun &#93; = fun ( self ) DCNL DCSP DCSP return ret DCNL DCSP return property ( get )
DCSP @ wraps ( function ) DCNL DCSP def dec ( * args , * * kwargs ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return function ( * args , * * kwargs ) DCNL DCSP DCSP except np.linalg.LinAlgError as exp : DCNL DCSP DCSP DCSP if ( &apos; SVD DCSP did DCSP not DCSP converge &apos; in str ( exp ) ) : DCNL DCSP DCSP DCSP DCSP from nose.plugins.skip import SkipTest DCNL DCSP DCSP DCSP DCSP msg = &apos; Intel DCSP MKL DCSP SVD DCSP convergence DCSP error DCSP detected , DCSP skipping DCSP test &apos; DCNL DCSP DCSP DCSP DCSP warn ( msg ) DCNL DCSP DCSP DCSP DCSP raise SkipTest ( msg ) DCNL DCSP DCSP DCSP raise DCNL DCSP return dec
DCSP running _ tasks _ data = &#91; &#93; DCNL DCSP for task in tasks : DCNL DCSP DCSP if task.isAlive ( ) : DCNL DCSP DCSP DCSP running _ tasks _ data.append ( ( &apos; DCSP DCSP % s DCSP ( started DCSP % s ) &apos; % ( task.name , time.strftime ( &apos; % H : % M : % S &apos; , time.localtime ( task.start _ time ) ) ) ) ) DCNL DCSP DCSP if task.exception : DCNL DCSP DCSP DCSP ALL _ ERRORS.append ( task.exception ) DCNL DCSP if running _ tasks _ data : DCNL DCSP DCSP log ( &apos; ---------------------------------------- &apos; ) DCNL DCSP DCSP log ( &apos; Tasks DCSP still DCSP running : &apos; ) DCNL DCSP DCSP for task _ details in running _ tasks _ data : DCNL DCSP DCSP DCSP log ( task _ details )
DCSP if ( value in _ _ opts _ _ ) : DCNL DCSP DCSP return _ _ opts _ _ &#91; value &#93; DCNL DCSP master _ opts = _ _ pillar _ _ .get ( &apos; master &apos; , { } ) DCNL DCSP if ( value in master _ opts ) : DCNL DCSP DCSP return master _ opts &#91; value &#93; DCNL DCSP if ( value in _ _ pillar _ _ ) : DCNL DCSP DCSP return _ _ pillar _ _ &#91; value &#93;
DCSP port = socket ( ) DCNL DCSP port.bind ( ( &apos; &apos; , 0 ) ) DCNL DCSP port.listen ( 1 ) DCNL DCSP client = socket ( ) DCNL DCSP client.setblocking ( False ) DCNL DCSP client.connect _ ex ( ( &apos; 127.0.0.1 &apos; , port.getsockname ( ) &#91; 1 &#93; ) ) DCNL DCSP client.setblocking ( True ) DCNL DCSP server = port.accept ( ) &#91; 0 &#93; DCNL DCSP server.send ( b ( &apos; x &apos; ) ) DCNL DCSP assert ( client.recv ( 1024 ) = = b ( &apos; x &apos; ) ) DCNL DCSP client.send ( b ( &apos; y &apos; ) ) DCNL DCSP assert ( server.recv ( 1024 ) = = b ( &apos; y &apos; ) ) DCNL DCSP server.setblocking ( False ) DCNL DCSP client.setblocking ( False ) DCNL DCSP return ( server , client )
DCSP from flask _ migrate import upgrade DCNL DCSP from app.models import Role , User DCNL DCSP upgrade ( ) DCNL DCSP Role.insert _ roles ( ) DCNL DCSP User.add _ self _ follows ( )
DCSP statements = &#91; &#93; DCNL DCSP current = &apos; &apos; DCNL DCSP prev = &apos; &apos; DCNL DCSP between _ quotes = None DCNL DCSP is _ comment = None DCNL DCSP start _ row = 0 DCNL DCSP start _ col = 0 DCNL DCSP end _ row = 0 DCNL DCSP end _ col = ( len ( hql ) - 1 ) DCNL DCSP if ( hql.find ( &apos; ; &apos; ) in ( ( -1 ) , ( len ( hql ) - 1 ) ) ) : DCNL DCSP DCSP return &#91; ( ( start _ row , start _ col ) , ( end _ row , end _ col ) , hql ) &#93; DCNL DCSP lines = hql.splitlines ( ) DCNL DCSP for ( row , line ) in enumerate ( lines ) : DCNL DCSP DCSP end _ col = 0 DCNL DCSP DCSP end _ row = row DCNL DCSP DCSP if ( ( start _ row = = row ) and ( line.strip ( ) = = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP start _ row + = 1 DCNL DCSP DCSP elif ( current.strip ( ) = = &apos; &apos; ) : DCNL DCSP DCSP DCSP start _ row = row DCNL DCSP DCSP DCSP start _ col = 0 DCNL DCSP DCSP for ( col , c ) in enumerate ( line ) : DCNL DCSP DCSP DCSP current + = c DCNL DCSP DCSP DCSP if ( ( c in ( &apos; &quot; &apos; , &quot; &apos; &quot; ) ) and ( prev ! = &apos; \ \ &apos; ) and ( is _ comment is None ) ) : DCNL DCSP DCSP DCSP DCSP if ( between _ quotes = = c ) : DCNL DCSP DCSP DCSP DCSP DCSP between _ quotes = None DCNL DCSP DCSP DCSP DCSP elif ( between _ quotes is None ) : DCNL DCSP DCSP DCSP DCSP DCSP between _ quotes = c DCNL DCSP DCSP DCSP elif ( ( c = = &apos; -&apos; ) and ( prev = = &apos; -&apos; ) and ( between _ quotes is None ) and ( is _ comment is None ) ) : DCNL DCSP DCSP DCSP DCSP is _ comment = True DCNL DCSP DCSP DCSP elif ( c = = &apos; ; &apos; ) : DCNL DCSP DCSP DCSP DCSP if ( ( between _ quotes is None ) and ( is _ comment is None ) ) : DCNL DCSP DCSP DCSP DCSP DCSP current = current.strip ( ) DCNL DCSP DCSP DCSP DCSP DCSP current = current &#91; : ( -1 ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( len ( current ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP statements.append ( ( ( start _ row , start _ col ) , ( row , ( col + 1 ) ) , current ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP start _ col = ( col + 1 ) DCNL DCSP DCSP DCSP DCSP DCSP current = &apos; &apos; DCNL DCSP DCSP DCSP if ( ( prev = = &apos; \ \ &apos; ) and ( between _ quotes is not None ) ) : DCNL DCSP DCSP DCSP DCSP c = &apos; &apos; DCNL DCSP DCSP DCSP prev = c DCNL DCSP DCSP DCSP end _ col = col DCNL DCSP DCSP is _ comment = None DCNL DCSP DCSP prev = os.linesep DCNL DCSP DCSP if ( current ! = &apos; &apos; ) : DCNL DCSP DCSP DCSP current + = os.linesep DCNL DCSP if ( current and ( current ! = &apos; ; &apos; ) ) : DCNL DCSP DCSP current = current.strip ( ) DCNL DCSP DCSP statements.append ( ( ( start _ row , start _ col ) , ( end _ row , ( end _ col + 1 ) ) , current ) ) DCNL DCSP return statements
DCSP if ( ( len ( data ) &gt; = 4 ) and ( data &#91; : 2 &#93; = = _ l2bytes ( &#91; 254 , 255 &#93; ) ) and ( data &#91; 2 : 4 &#93; ! = _ l2bytes ( &#91; 0 , 0 &#93; ) ) ) : DCNL DCSP DCSP encoding = &apos; utf-16be &apos; DCNL DCSP DCSP data = data &#91; 2 : &#93; DCNL DCSP elif ( ( len ( data ) &gt; = 4 ) and ( data &#91; : 2 &#93; = = _ l2bytes ( &#91; 255 , 254 &#93; ) ) and ( data &#91; 2 : 4 &#93; ! = _ l2bytes ( &#91; 0 , 0 &#93; ) ) ) : DCNL DCSP DCSP encoding = &apos; utf-16le &apos; DCNL DCSP DCSP data = data &#91; 2 : &#93; DCNL DCSP elif ( data &#91; : 3 &#93; = = _ l2bytes ( &#91; 239 , 187 , 191 &#93; ) ) : DCNL DCSP DCSP encoding = &apos; utf-8 &apos; DCNL DCSP DCSP data = data &#91; 3 : &#93; DCNL DCSP elif ( data &#91; : 4 &#93; = = _ l2bytes ( &#91; 0 , 0 , 254 , 255 &#93; ) ) : DCNL DCSP DCSP encoding = &apos; utf-32be &apos; DCNL DCSP DCSP data = data &#91; 4 : &#93; DCNL DCSP elif ( data &#91; : 4 &#93; = = _ l2bytes ( &#91; 255 , 254 , 0 , 0 &#93; ) ) : DCNL DCSP DCSP encoding = &apos; utf-32le &apos; DCNL DCSP DCSP data = data &#91; 4 : &#93; DCNL DCSP newdata = unicode ( data , encoding ) DCNL DCSP declmatch = re.compile ( &apos; ^ &lt; \ \ ? xml &#91; ^ &gt; &#93; * ? &gt; &apos; ) DCNL DCSP newdecl = &quot; &lt; ? xml DCSP version = &apos; 1.0 &apos; DCSP encoding = &apos; utf-8 &apos; ? &gt; &quot; DCNL DCSP if declmatch.search ( newdata ) : DCNL DCSP DCSP newdata = declmatch.sub ( newdecl , newdata ) DCNL DCSP else : DCNL DCSP DCSP newdata = ( ( newdecl + u &apos; \ n &apos; ) + newdata ) DCNL DCSP return newdata.encode ( &apos; utf-8 &apos; )
DCSP tp = TrivialPrompter ( ) DCNL DCSP stdio.StandardIO ( tp ) DCNL DCSP proto.prompt = tp.prompt DCNL DCSP proto.display = tp.display DCNL DCSP return proto.authenticate ( password ) .addCallback ( cbAuthentication , proto ) .addErrback ( ebAuthentication , proto , username , password )
DCSP res = Q ( filter _ , thing ) DCNL DCSP if isinstance ( filter _ , type ( { } ) ) : DCNL DCSP DCSP for k in res : DCNL DCSP DCSP DCSP res &#91; k &#93; = list ( res &#91; k &#93; ) DCNL DCSP DCSP return res DCNL DCSP else : DCNL DCSP DCSP return list ( res )
DCSP return _ levelNames.get ( level , ( &apos; Level DCSP % s &apos; % level ) )
DCSP return _ _ salt _ _ &#91; &apos; probes.delete _ probes &apos; &#93; ( _ ordered _ dict _ to _ dict ( probes ) , commit = False )
DCSP redirect _ to = request.REQUEST.get ( redirect _ field _ name , &apos; &apos; ) DCNL DCSP if ( ( not redirect _ to ) or ( &apos; / / &apos; in redirect _ to ) or ( &apos; DCSP &apos; in redirect _ to ) ) : DCNL DCSP DCSP redirect _ to = default _ redirect DCNL DCSP rels = UserAssociation.objects.filter ( user _ _ id = request.user.id ) DCNL DCSP associated _ openids = &#91; rel.openid _ url for rel in rels &#93; DCNL DCSP if ( ( len ( associated _ openids ) = = 1 ) and ( not request.user.has _ usable _ password ( ) ) ) : DCNL DCSP DCSP msg = _ ( &quot; You DCSP can &apos;t DCSP remove DCSP this DCSP openid . DCSP You DCSP should DCSP set DCSP a DCSP password DCSP first . &quot; ) DCNL DCSP DCSP return HttpResponseRedirect ( ( &apos; % s ? % s &apos; % ( redirect _ to , urllib.urlencode ( { &apos; msg &apos; : msg } ) ) ) ) DCNL DCSP if request.POST : DCNL DCSP DCSP form = dissociate _ form ( request.POST ) DCNL DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP openid _ url = form.cleaned _ data &#91; &apos; openid _ url &apos; &#93; DCNL DCSP DCSP DCSP msg = &apos; &apos; DCNL DCSP DCSP DCSP if ( openid _ url not in associated _ openids ) : DCNL DCSP DCSP DCSP DCSP msg = ( _ ( &apos; % s DCSP is DCSP not DCSP associated DCSP to DCSP your DCSP account &apos; ) % openid _ url ) DCNL DCSP DCSP DCSP if ( not msg ) : DCNL DCSP DCSP DCSP DCSP UserAssociation.objects.get ( openid _ url _ _ exact = openid _ url ) .delete ( ) DCNL DCSP DCSP DCSP DCSP if ( openid _ url = = request.session.get ( &apos; openid _ url &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP del request.session &#91; &apos; openid _ url &apos; &#93; DCNL DCSP DCSP DCSP DCSP msg = _ ( &apos; openid DCSP removed . &apos; ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( ( &apos; % s ? % s &apos; % ( redirect _ to , urllib.urlencode ( { &apos; msg &apos; : msg } ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP openid _ url = request.GET.get ( &apos; openid _ url &apos; , &apos; &apos; ) DCNL DCSP DCSP if ( not openid _ url ) : DCNL DCSP DCSP DCSP msg = _ ( &apos; Invalid DCSP OpenID DCSP url . &apos; ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( ( &apos; % s ? % s &apos; % ( redirect _ to , urllib.urlencode ( { &apos; msg &apos; : msg } ) ) ) ) DCNL DCSP DCSP form = dissociate _ form ( initial = { &apos; openid _ url &apos; : openid _ url } ) DCNL DCSP return render ( template _ name , { &apos; form &apos; : form , &apos; openid _ url &apos; : openid _ url } , context _ instance = _ build _ context ( request , extra _ context = extra _ context ) )
DCSP logger.debug ( &apos; Checking DCSP if DCSP % s DCSP is DCSP complete &apos; , task ) DCNL DCSP try : DCNL DCSP DCSP is _ complete = task.complete ( ) DCNL DCSP except Exception : DCNL DCSP DCSP is _ complete = TracebackWrapper ( traceback.format _ exc ( ) ) DCNL DCSP out _ queue.put ( ( task , is _ complete ) )
DCSP pkg2rm = &apos; &apos; DCNL DCSP if pkgs : DCNL DCSP DCSP for pkg in pkgs : DCNL DCSP DCSP DCSP pkg2rm + = &apos; { 0 } DCSP &apos; .format ( pkg ) DCNL DCSP DCSP log.debug ( &apos; Installing DCSP these DCSP packages DCSP instead DCSP of DCSP { 0 } : DCSP { 1 } &apos; .format ( name , pkg2rm ) ) DCNL DCSP else : DCNL DCSP DCSP pkg2rm = &apos; { 0 } &apos; .format ( name ) DCNL DCSP old = list _ pkgs ( ) DCNL DCSP cmd = &apos; / bin / pkg DCSP uninstall DCSP -v DCSP { 0 } &apos; .format ( pkg2rm ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , output _ loglevel = &apos; trace &apos; ) DCNL DCSP _ _ context _ _ .pop ( &apos; pkg.list _ pkgs &apos; , None ) DCNL DCSP new = list _ pkgs ( ) DCNL DCSP ret = salt.utils.compare _ dicts ( old , new ) DCNL DCSP if ( out &#91; &apos; retcode &apos; &#93; ! = 0 ) : DCNL DCSP DCSP raise CommandExecutionError ( &apos; Error DCSP occurred DCSP removing DCSP package ( s ) &apos; , info = { &apos; changes &apos; : ret , &apos; retcode &apos; : ips _ pkg _ return _ values &#91; out &#91; &apos; retcode &apos; &#93; &#93; , &apos; errors &apos; : &#91; out &#91; &apos; stderr &apos; &#93; &#93; } ) DCNL DCSP return ret
DCSP from inbox.config import config DCNL DCSP database _ hosts = config.get _ required ( &apos; DATABASE _ HOSTS &apos; ) DCNL DCSP schemas = &#91; ( shard &#91; &apos; SCHEMA _ NAME &apos; &#93; , host &#91; &apos; HOSTNAME &apos; &#93; ) for host in database _ hosts for shard in host &#91; &apos; SHARDS &apos; &#93; &#93; DCNL DCSP assert all ( &#91; ( &apos; test &apos; in s ) for ( s , h ) in schemas &#93; ) DCNL DCSP for ( name , host ) in schemas : DCNL DCSP DCSP cmd = &apos; DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP { name } ; DCSP CREATE DCSP DATABASE DCSP IF DCSP NOT DCSP EXISTS DCSP { name } DCSP DEFAULT DCSP CHARACTER DCSP SET DCSP utf8mb4 DCSP DEFAULT DCSP COLLATE DCSP utf8mb4 _ general _ ci &apos; .format ( name = name ) DCNL DCSP DCSP subprocess.check _ call ( &apos; mysql DCSP -h DCSP { } DCSP -uinboxtest DCSP -pinboxtest DCSP -e DCSP &quot; { } &quot; &apos; .format ( host , cmd ) , shell = True )
DCSP if ( key is None ) : DCNL DCSP DCSP return { } DCNL DCSP key = _ to _ bytes ( key ) DCNL DCSP key _ hash = hashlib.sha256 ( key ) .digest ( ) DCNL DCSP key _ hash = base64.b64encode ( key _ hash ) .rstrip ( ) DCNL DCSP key = base64.b64encode ( key ) .rstrip ( ) DCNL DCSP if source : DCNL DCSP DCSP prefix = &apos; X-Goog-Copy-Source-Encryption- &apos; DCNL DCSP else : DCNL DCSP DCSP prefix = &apos; X-Goog-Encryption- &apos; DCNL DCSP return { ( prefix + &apos; Algorithm &apos; ) : &apos; AES256 &apos; , ( prefix + &apos; Key &apos; ) : _ bytes _ to _ unicode ( key ) , ( prefix + &apos; Key-Sha256 &apos; ) : _ bytes _ to _ unicode ( key _ hash ) }
DCSP return get _ current _ app ( ) . _ rgetattr ( reverse _ name ) ( * args )
DCSP return ( auth.user _ has _ role ( user , CourseBetaTesterRole ( descriptor.id ) ) or _ has _ staff _ access _ to _ descriptor ( user , descriptor , descriptor.id ) or _ is _ descriptor _ mobile _ available ( descriptor ) )
DCSP if ( not kargs.has _ key ( &apos; timeout &apos; ) ) : DCNL DCSP DCSP kargs &#91; &apos; timeout &apos; &#93; = ( -1 ) DCNL DCSP s = conf.L3socket ( promisc = promisc , filter = filter , nofilter = nofilter , iface = iface ) DCNL DCSP ( a , b ) = sndrcv ( s , x , * args , * * kargs ) DCNL DCSP s.close ( ) DCNL DCSP if ( len ( a ) &gt; 0 ) : DCNL DCSP DCSP return a &#91; 0 &#93; &#91; 1 &#93; DCNL DCSP else : DCNL DCSP DCSP return None
DCSP global FS _ CACHE , MR _ CACHE DCNL DCSP old = ( FS _ CACHE , MR _ CACHE ) DCNL DCSP ( FS _ CACHE , MR _ CACHE ) = ( None , None ) DCNL DCSP return old
DCSP return ( len ( value ) = = int ( arg ) )
DCSP return LazyLoader ( _ module _ dirs ( opts , &apos; search &apos; , &apos; search &apos; ) , opts , tag = &apos; search &apos; , whitelist = whitelist , pack = { &apos; _ _ ret _ _ &apos; : returners } )
DCSP if six.PY3 : DCNL DCSP DCSP b = salt.utils.to _ bytes ( instr ) DCNL DCSP DCSP b64 = base64.b64encode ( b ) DCNL DCSP DCSP return salt.utils.to _ str ( b64 ) DCNL DCSP return base64.b64encode ( instr )
DCSP return getattr ( d , _ iteritems ) ( )
DCSP if ( not isinstance ( text , basestring ) ) : DCNL DCSP DCSP raise TypeError ( ( &quot; % s DCSP can &apos;t DCSP be DCSP encoded &quot; % type ( text ) ) ) DCNL DCSP if ( not incoming ) : DCNL DCSP DCSP incoming = ( sys.stdin.encoding or sys.getdefaultencoding ( ) ) DCNL DCSP if isinstance ( text , unicode ) : DCNL DCSP DCSP return text.encode ( encoding , errors ) DCNL DCSP elif ( text and ( encoding ! = incoming ) ) : DCNL DCSP DCSP text = safe _ decode ( text , incoming , errors ) DCNL DCSP DCSP return text.encode ( encoding , errors ) DCNL DCSP return text
DCSP if isinstance ( storage , LazyObject ) : DCNL DCSP DCSP if ( storage . _ wrapped is None ) : DCNL DCSP DCSP DCSP storage . _ setup ( ) DCNL DCSP DCSP storage = storage . _ wrapped DCNL DCSP if ( not isinstance ( storage , six.string _ types ) ) : DCNL DCSP DCSP storage _ cls = storage . _ _ class _ _ DCNL DCSP DCSP storage = ( &apos; % s . % s &apos; % ( storage _ cls . _ _ module _ _ , storage _ cls . _ _ name _ _ ) ) DCNL DCSP return hashlib.md5 ( storage.encode ( &apos; utf8 &apos; ) ) .hexdigest ( )
DCSP prev _ value = config.compute _ test _ value DCNL DCSP try : DCNL DCSP DCSP config.compute _ test _ value = &apos; off &apos; DCNL DCSP DCSP x = T.vector ( ) DCNL DCSP DCSP for x _ val in op.get _ debug _ values ( x ) : DCNL DCSP DCSP DCSP assert False DCNL DCSP finally : DCNL DCSP DCSP config.compute _ test _ value = prev _ value
DCSP return ( ( option in helpful _ parser.defaults ) and ( helpful _ parser.defaults &#91; option &#93; = = value ) )
DCSP def rate _ element ( driver ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP inner _ wrapper = find _ id _ with _ wait ( context , id _ , wait _ time = 2 ) DCNL DCSP DCSP DCSP els = inner _ wrapper.find _ elements _ by _ class _ name ( STAR _ RATING _ OPTION _ CLASS ) DCNL DCSP DCSP DCSP rating _ el = &#91; el for el in filter ( ( lambda x : ( int ( x.get _ attribute ( &apos; data-val &apos; ) ) = = val ) ) , els ) &#93; &#91; 0 &#93; DCNL DCSP DCSP DCSP rating _ el.click ( ) DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP except ( NoSuchElementException , StaleElementReferenceException , TimeoutException , IndexError ) : DCNL DCSP DCSP DCSP return False DCNL DCSP try : DCNL DCSP DCSP WebDriverWait ( context.browser , 30 ) .until ( rate _ element ) DCNL DCSP except TimeoutException : DCNL DCSP DCSP raise Exception ( &quot; Unable DCSP to DCSP enter DCSP rating DCSP for DCSP container DCSP with DCSP id DCSP &apos; { id : s } &apos; &quot; .format ( id = id _ ) )
DCSP if ( &apos; docker.client &apos; not in _ _ context _ _ ) : DCNL DCSP DCSP client _ kwargs = { } DCNL DCSP DCSP for ( key , val ) in ( ( &apos; base _ url &apos; , &apos; docker.url &apos; ) , ( &apos; version &apos; , &apos; docker.version &apos; ) ) : DCNL DCSP DCSP DCSP param = _ _ salt _ _ &#91; &apos; config.get &apos; &#93; ( val , NOTSET ) DCNL DCSP DCSP DCSP if ( param is not NOTSET ) : DCNL DCSP DCSP DCSP DCSP client _ kwargs &#91; key &#93; = param DCNL DCSP DCSP if ( ( &apos; base _ url &apos; not in client _ kwargs ) and ( &apos; DOCKER _ HOST &apos; in os.environ ) ) : DCNL DCSP DCSP DCSP client _ kwargs &#91; &apos; base _ url &apos; &#93; = os.environ.get ( &apos; DOCKER _ HOST &apos; ) DCNL DCSP DCSP if ( &apos; version &apos; not in client _ kwargs ) : DCNL DCSP DCSP DCSP client _ kwargs &#91; &apos; version &apos; &#93; = &apos; auto &apos; DCNL DCSP DCSP docker _ machine = _ _ salt _ _ &#91; &apos; config.get &apos; &#93; ( &apos; docker.machine &apos; , NOTSET ) DCNL DCSP DCSP if ( docker _ machine is not NOTSET ) : DCNL DCSP DCSP DCSP docker _ machine _ json = _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( ( &apos; docker-machine DCSP inspect DCSP &apos; + docker _ machine ) ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP docker _ machine _ json = json.loads ( docker _ machine _ json ) DCNL DCSP DCSP DCSP DCSP docker _ machine _ tls = docker _ machine _ json &#91; &apos; HostOptions &apos; &#93; &#91; &apos; AuthOptions &apos; &#93; DCNL DCSP DCSP DCSP DCSP docker _ machine _ ip = docker _ machine _ json &#91; &apos; Driver &apos; &#93; &#91; &apos; IPAddress &apos; &#93; DCNL DCSP DCSP DCSP DCSP client _ kwargs &#91; &apos; base _ url &apos; &#93; = ( ( &apos; https : / / &apos; + docker _ machine _ ip ) + &apos; : 2376 &apos; ) DCNL DCSP DCSP DCSP DCSP client _ kwargs &#91; &apos; tls &apos; &#93; = docker.tls.TLSConfig ( client _ cert = ( docker _ machine _ tls &#91; &apos; ClientCertPath &apos; &#93; , docker _ machine _ tls &#91; &apos; ClientKeyPath &apos; &#93; ) , ca _ cert = docker _ machine _ tls &#91; &apos; CaCertPath &apos; &#93; , assert _ hostname = False , verify = True ) DCNL DCSP DCSP DCSP except Exception as exc : DCNL DCSP DCSP DCSP DCSP raise CommandExecutionError ( &apos; Docker DCSP machine DCSP { 0 } DCSP failed : DCSP { 1 } &apos; .format ( docker _ machine , exc ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ _ context _ _ &#91; &apos; docker.client &apos; &#93; = docker.Client ( * * client _ kwargs ) DCNL DCSP DCSP except docker.errors.DockerException : DCNL DCSP DCSP DCSP log.error ( &apos; Could DCSP not DCSP initialize DCSP Docker DCSP client &apos; ) DCNL DCSP DCSP DCSP return False DCNL DCSP if ( ( timeout is not None ) and ( _ _ context _ _ &#91; &apos; docker.client &apos; &#93; .timeout ! = timeout ) ) : DCNL DCSP DCSP _ _ context _ _ &#91; &apos; docker.client &apos; &#93; .timeout = timeout
DCSP rgb _ components = &#91; &#93; DCNL DCSP for component in colors : DCNL DCSP DCSP rounded _ num = decimal.Decimal ( str ( ( component * 255.0 ) ) ) .quantize ( decimal.Decimal ( &apos; 1&apos; ) , rounding = decimal.ROUND _ HALF _ EVEN ) DCNL DCSP DCSP rounded _ num = int ( rounded _ num ) DCNL DCSP DCSP rgb _ components.append ( rounded _ num ) DCNL DCSP return ( rgb _ components &#91; 0 &#93; , rgb _ components &#91; 1 &#93; , rgb _ components &#91; 2 &#93; )
DCSP pass
DCSP pass
DCSP context = context.copy ( ) DCNL DCSP results = { } DCNL DCSP for ( k , v ) in context.iteritems ( ) : DCNL DCSP DCSP if ( not hasattr ( v , &apos; _ _ call _ _ &apos; ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( prefix and ( not k.startswith ( prefix ) ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP print ( k + &apos; : &apos; ) , DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP r = v ( ) DCNL DCSP DCSP DCSP dictincr ( results , r ) DCNL DCSP DCSP DCSP print r DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP print &apos; ERROR &apos; DCNL DCSP DCSP DCSP dictincr ( results , &apos; ERROR &apos; ) DCNL DCSP DCSP DCSP print ( &apos; DCSP DCSP DCSP &apos; + &apos; \ n DCSP DCSP DCSP &apos; .join ( traceback.format _ exc ( ) .split ( &apos; \ n &apos; ) ) ) DCNL DCSP print ( &apos; -&apos; * 40 ) DCNL DCSP print &apos; results : &apos; DCNL DCSP for ( k , v ) in results.iteritems ( ) : DCNL DCSP DCSP print ( &apos; DCSP &apos; * 2 ) , ( str ( k ) + &apos; : &apos; ) , v
DCSP craftTypeName = getCraftTypeName ( ) DCNL DCSP return os.path.join ( craftTypeName , getProfileName ( craftTypeName ) )
DCSP if ( ( not isscalar ( nt ) ) or ( floor ( nt ) ! = nt ) or ( nt &lt; = 0 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; nt DCSP must DCSP be DCSP positive DCSP integer DCSP scalar . &apos; ) DCNL DCSP return specfun.klvnzo ( nt , 5 )
DCSP return ( &apos; % s DCSP % s &apos; % ( _ article ( word , article , gender , role ) , word ) )
DCSP data = open ( results _ file ) .read ( ) .strip ( ) DCNL DCSP pieces = data.split ( &apos; &#124; &apos; ) DCNL DCSP if ( not ( len ( pieces ) = = 4 ) ) : DCNL DCSP DCSP state = &apos; UNKNOWN &apos; DCNL DCSP DCSP ret = 3 DCNL DCSP DCSP data = &apos; Results DCSP file DCSP malformed &apos; DCNL DCSP else : DCNL DCSP DCSP timestamp = int ( pieces &#91; 0 &#93; ) DCNL DCSP DCSP time _ diff = ( time.time ( ) - timestamp ) DCNL DCSP DCSP if ( time _ diff &gt; ( 60 * 2 ) ) : DCNL DCSP DCSP DCSP ret = 3 DCNL DCSP DCSP DCSP state = &apos; UNKNOWN &apos; DCNL DCSP DCSP DCSP data = &apos; Results DCSP file DCSP is DCSP stale &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret = int ( pieces &#91; 1 &#93; ) DCNL DCSP DCSP DCSP state = pieces &#91; 2 &#93; DCNL DCSP DCSP DCSP data = pieces &#91; 3 &#93; DCNL DCSP return ( ret , ( &apos; % s : DCSP % s &apos; % ( state , data ) ) )
DCSP store0.sync ( ) DCNL DCSP store0.update ( store0.file.store ) DCNL DCSP initial _ max _ revision = Unit.max _ revision ( ) DCNL DCSP initial _ revision = Revision.get ( ) DCNL DCSP assert ( initial _ max _ revision = = initial _ revision ) DCNL DCSP for i in range ( 10 ) : DCNL DCSP DCSP _ update _ translation ( store0 , 0 , { &apos; target &apos; : str ( i ) } , sync = False ) DCNL DCSP end _ max _ revision = Unit.max _ revision ( ) DCNL DCSP end _ revision = Revision.get ( ) DCNL DCSP assert ( end _ max _ revision = = end _ revision ) DCNL DCSP assert ( end _ max _ revision ! = initial _ max _ revision ) DCNL DCSP assert ( end _ revision ! = initial _ revision ) DCNL DCSP assert ( end _ revision = = ( 10 + initial _ revision ) )
DCSP return JsonResponse ( data )
DCSP def fun ( x ) : DCNL DCSP DCSP return func ( x ) DCNL DCSP rvs = dist.rvs ( size = size ) DCNL DCSP return fun ( rvs ) .mean ( 0 )
DCSP from Tkinter import Menu , Text , Text DCNL DCSP from idlelib.EditorWindow import prepstr , get _ accelerator DCNL DCSP from idlelib import Bindings DCNL DCSP from idlelib import WindowList DCNL DCSP from idlelib.MultiCall import MultiCallCreator DCNL DCSP closeItem = Bindings.menudefs &#91; 0 &#93; &#91; 1 &#93; &#91; ( -2 ) &#93; DCNL DCSP del Bindings.menudefs &#91; 0 &#93; &#91; 1 &#93; &#91; ( -3 ) : &#93; DCNL DCSP Bindings.menudefs &#91; 0 &#93; &#91; 1 &#93; .insert ( 6 , closeItem ) DCNL DCSP del Bindings.menudefs &#91; ( -1 ) &#93; &#91; 1 &#93; &#91; 0 : 2 &#93; DCNL DCSP del Bindings.menudefs &#91; ( -2 ) &#93; &#91; 1 &#93; &#91; 0 : 2 &#93; DCNL DCSP menubar = Menu ( root ) DCNL DCSP root.configure ( menu = menubar ) DCNL DCSP menudict = { } DCNL DCSP menudict &#91; &apos; windows &apos; &#93; = menu = Menu ( menubar , name = &apos; windows &apos; ) DCNL DCSP menubar.add _ cascade ( label = &apos; Window &apos; , menu = menu , underline = 0 ) DCNL DCSP def postwindowsmenu ( menu = menu ) : DCNL DCSP DCSP end = menu.index ( &apos; end &apos; ) DCNL DCSP DCSP if ( end is None ) : DCNL DCSP DCSP DCSP end = ( -1 ) DCNL DCSP DCSP if ( end &gt; 0 ) : DCNL DCSP DCSP DCSP menu.delete ( 0 , end ) DCNL DCSP DCSP WindowList.add _ windows _ to _ menu ( menu ) DCNL DCSP WindowList.register _ callback ( postwindowsmenu ) DCNL DCSP def about _ dialog ( event = None ) : DCNL DCSP DCSP from idlelib import aboutDialog DCNL DCSP DCSP aboutDialog.AboutDialog ( root , &apos; About DCSP IDLE &apos; ) DCNL DCSP def config _ dialog ( event = None ) : DCNL DCSP DCSP from idlelib import configDialog DCNL DCSP DCSP root.instance _ dict = flist.inversedict DCNL DCSP DCSP configDialog.ConfigDialog ( root , &apos; Settings &apos; ) DCNL DCSP def help _ dialog ( event = None ) : DCNL DCSP DCSP from idlelib import textView DCNL DCSP DCSP fn = path.join ( path.abspath ( path.dirname ( _ _ file _ _ ) ) , &apos; help.txt &apos; ) DCNL DCSP DCSP textView.view _ file ( root , &apos; Help &apos; , fn ) DCNL DCSP root.bind ( &apos; &lt; &lt; about-idle &gt; &gt; &apos; , about _ dialog ) DCNL DCSP root.bind ( &apos; &lt; &lt; open-config-dialog &gt; &gt; &apos; , config _ dialog ) DCNL DCSP root.createcommand ( &apos; : : tk : : mac : : ShowPreferences &apos; , config _ dialog ) DCNL DCSP if flist : DCNL DCSP DCSP root.bind ( &apos; &lt; &lt; close-all-windows &gt; &gt; &apos; , flist.close _ all _ callback ) DCNL DCSP DCSP root.createcommand ( &apos; exit &apos; , flist.close _ all _ callback ) DCNL DCSP if isCarbonTk ( ) : DCNL DCSP DCSP menudict &#91; &apos; application &apos; &#93; = menu = Menu ( menubar , name = &apos; apple &apos; ) DCNL DCSP DCSP menubar.add _ cascade ( label = &apos; IDLE &apos; , menu = menu ) DCNL DCSP DCSP Bindings.menudefs.insert ( 0 , ( &apos; application &apos; , &#91; ( &apos; About DCSP IDLE &apos; , &apos; &lt; &lt; about-idle &gt; &gt; &apos; ) , None &#93; ) ) DCNL DCSP DCSP tkversion = root.tk.eval ( &apos; info DCSP patchlevel &apos; ) DCNL DCSP DCSP if ( tuple ( map ( int , tkversion.split ( &apos; .&apos; ) ) ) &lt; ( 8 , 4 , 14 ) ) : DCNL DCSP DCSP DCSP Bindings.menudefs &#91; 0 &#93; &#91; 1 &#93; .append ( ( &apos; _ Preferences .... &apos; , &apos; &lt; &lt; open-config-dialog &gt; &gt; &apos; ) ) DCNL DCSP if isCocoaTk ( ) : DCNL DCSP DCSP root.createcommand ( &apos; tkAboutDialog &apos; , about _ dialog ) DCNL DCSP DCSP root.createcommand ( &apos; : : tk : : mac : : ShowHelp &apos; , help _ dialog ) DCNL DCSP DCSP del Bindings.menudefs &#91; ( -1 ) &#93; &#91; 1 &#93; &#91; 0 &#93;
DCSP return func ( * args , * * kw )
DCSP assert ( cell _ type is not None ) DCNL DCSP rnn _ func = None DCNL DCSP if ( cell _ type = = &apos; lstm &apos; ) : DCNL DCSP DCSP rnn _ func = lstm _ layer DCNL DCSP assert ( rnn _ func is not None ) DCNL DCSP assert ( direction in &#91; &apos; forward &apos; , &apos; backward &apos; , &apos; bidirectional &apos; &#93; ) DCNL DCSP with tf.variable _ scope ( name ) : DCNL DCSP DCSP if ( direction in &#91; &apos; forward &apos; , &apos; bidirectional &apos; &#93; ) : DCNL DCSP DCSP DCSP forward = rnn _ func ( inp = inp , length = length , backward = False , name = &apos; forward &apos; , * args , * * kwargs ) DCNL DCSP DCSP DCSP if isinstance ( forward , tuple ) : DCNL DCSP DCSP DCSP DCSP forward = forward &#91; 0 &#93; DCNL DCSP DCSP if ( direction in &#91; &apos; backward &apos; , &apos; bidirectional &apos; &#93; ) : DCNL DCSP DCSP DCSP backward = rnn _ func ( inp = inp , length = length , backward = True , name = &apos; backward &apos; , * args , * * kwargs ) DCNL DCSP DCSP DCSP if isinstance ( backward , tuple ) : DCNL DCSP DCSP DCSP DCSP backward = backward &#91; 0 &#93; DCNL DCSP DCSP if ( direction = = &apos; forward &apos; ) : DCNL DCSP DCSP DCSP out = forward DCNL DCSP DCSP elif ( direction = = &apos; backward &apos; ) : DCNL DCSP DCSP DCSP out = backward DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP out = tf.concat ( 2 , &#91; forward , backward &#93; ) DCNL DCSP return out
DCSP return &apos; &apos;.join ( ( random.choice ( ( string.ascii _ uppercase + string.digits ) ) for _ x in range ( length ) ) )
DCSP try : DCNL DCSP DCSP widget _ desc = registry.widget ( node _ el.get ( &apos; qualified _ name &apos; ) ) DCNL DCSP except KeyError as ex : DCNL DCSP DCSP raise UnknownWidgetDefinition ( * ex.args ) DCNL DCSP title = node _ el.get ( &apos; title &apos; ) DCNL DCSP pos = node _ el.get ( &apos; position &apos; ) DCNL DCSP if ( pos is not None ) : DCNL DCSP DCSP pos = tuple _ eval ( pos ) DCNL DCSP return SchemeNode ( widget _ desc , title = title , position = pos )
DCSP for ( alias , email _ address ) in mapping.iteritems ( ) : DCNL DCSP DCSP changelog = changelog.replace ( alias , email _ address ) DCNL DCSP return changelog
DCSP c = OrderedDict ( ) DCNL DCSP for elem in iterable : DCNL DCSP DCSP c &#91; elem &#93; = ( c.get ( elem , 0 ) + 1 ) DCNL DCSP return c
DCSP return _ pull _ image ( &apos; dkr &apos; , url , name , index = index )
DCSP return config.get _ cloud _ config _ value ( &apos; managedcloud &apos; , vm _ , _ _ opts _ _ , default = &apos; False &apos; , search _ global = False )
DCSP _ _ tracebackhide _ _ = True DCNL DCSP nose = import _ nose ( ) DCNL DCSP if ( sys.version _ info.major &gt; = 3 ) : DCNL DCSP DCSP funcname = nose.tools.assert _ raises _ regex DCNL DCSP else : DCNL DCSP DCSP funcname = nose.tools.assert _ raises _ regexp DCNL DCSP return funcname ( exception _ class , expected _ regexp , callable _ obj , * args , * * kwargs )
DCSP if ( ( not result.result ) and force ) : DCNL DCSP DCSP result.output + = logHelper ( u &apos;Forcing DCSP deletion DCSP of DCSP files , DCSP even DCSP though DCSP last DCSP result DCSP was DCSP not DCSP success &apos; , sickrage.srCore.srLogger.DEBUG ) DCNL DCSP elif ( not result.result ) : DCNL DCSP DCSP return DCNL DCSP for cur _ file in notwantedFiles : DCNL DCSP DCSP cur _ file _ path = os.path.join ( processPath , cur _ file ) DCNL DCSP DCSP if ( not os.path.isfile ( cur _ file _ path ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP result.output + = logHelper ( ( u &apos;Deleting DCSP file DCSP % s &apos; % cur _ file ) , sickrage.srCore.srLogger.DEBUG ) DCNL DCSP DCSP file _ attribute = os.stat ( cur _ file _ path ) &#91; 0 &#93; DCNL DCSP DCSP if ( not ( file _ attribute &amp; stat.S _ IWRITE ) ) : DCNL DCSP DCSP DCSP result.output + = logHelper ( ( u &apos;Changing DCSP ReadOnly DCSP Flag DCSP for DCSP file DCSP % s &apos; % cur _ file ) , sickrage.srCore.srLogger.DEBUG ) DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP os.chmod ( cur _ file _ path , stat.S _ IWRITE ) DCNL DCSP DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP DCSP result.output + = logHelper ( ( u &apos;Cannot DCSP change DCSP permissions DCSP of DCSP % s : DCSP % s &apos; % ( cur _ file , str ( e.strerror ) .decode ( sickrage.SYS _ ENCODING ) ) ) , sickrage.srCore.srLogger.DEBUG ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP os.remove ( cur _ file _ path ) DCNL DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP result.output + = logHelper ( ( u &apos;Unable DCSP to DCSP delete DCSP file DCSP % s : DCSP % s &apos; % ( cur _ file , str ( e.strerror ) .decode ( sickrage.SYS _ ENCODING ) ) ) , sickrage.srCore.srLogger.DEBUG )
DCSP def decorator ( f ) : DCNL DCSP DCSP def callback ( ctx , param , value ) : DCNL DCSP DCSP DCSP if ( not value ) : DCNL DCSP DCSP DCSP DCSP ctx.abort ( ) DCNL DCSP DCSP attrs.setdefault ( &apos; is _ flag &apos; , True ) DCNL DCSP DCSP attrs.setdefault ( &apos; callback &apos; , callback ) DCNL DCSP DCSP attrs.setdefault ( &apos; expose _ value &apos; , False ) DCNL DCSP DCSP attrs.setdefault ( &apos; prompt &apos; , &apos; Do DCSP you DCSP want DCSP to DCSP continue ? &apos; ) DCNL DCSP DCSP attrs.setdefault ( &apos; help &apos; , &apos; Confirm DCSP the DCSP action DCSP without DCSP prompting . &apos; ) DCNL DCSP DCSP return option ( * ( param _ decls or ( &apos; --yes &apos; , ) ) , * * attrs ) ( f ) DCNL DCSP return decorator
DCSP return list ( _ iter _ schedule _ requests ( state.consumer.timer ) )
DCSP if ( input _ data is None ) : DCNL DCSP DCSP assert input _ shape DCNL DCSP DCSP if ( not input _ dtype ) : DCNL DCSP DCSP DCSP input _ dtype = K.floatx ( ) DCNL DCSP DCSP input _ data _ shape = list ( input _ shape ) DCNL DCSP DCSP for ( i , e ) in enumerate ( input _ data _ shape ) : DCNL DCSP DCSP DCSP if ( e is None ) : DCNL DCSP DCSP DCSP DCSP input _ data _ shape &#91; i &#93; = np.random.randint ( 1 , 4 ) DCNL DCSP DCSP input _ data = ( 10 * np.random.random ( input _ data _ shape ) ) DCNL DCSP DCSP input _ data = input _ data.astype ( input _ dtype ) DCNL DCSP elif ( input _ shape is None ) : DCNL DCSP DCSP input _ shape = input _ data.shape DCNL DCSP if ( expected _ output _ dtype is None ) : DCNL DCSP DCSP expected _ output _ dtype = input _ dtype DCNL DCSP layer = layer _ cls ( * * kwargs ) DCNL DCSP weights = layer.get _ weights ( ) DCNL DCSP layer.set _ weights ( weights ) DCNL DCSP if ( &apos; weights &apos; in inspect.getargspec ( layer _ cls . _ _ init _ _ ) ) : DCNL DCSP DCSP kwargs &#91; &apos; weights &apos; &#93; = weights DCNL DCSP DCSP layer = layer _ cls ( * * kwargs ) DCNL DCSP if fixed _ batch _ size : DCNL DCSP DCSP x = Input ( batch _ shape = input _ shape , dtype = input _ dtype ) DCNL DCSP else : DCNL DCSP DCSP x = Input ( shape = input _ shape &#91; 1 : &#93; , dtype = input _ dtype ) DCNL DCSP y = layer ( x ) DCNL DCSP assert ( K.dtype ( y ) = = expected _ output _ dtype ) DCNL DCSP model = Model ( input = x , output = y ) DCNL DCSP model.compile ( &apos; rmsprop &apos; , &apos; mse &apos; ) DCNL DCSP expected _ output _ shape = layer.get _ output _ shape _ for ( input _ shape ) DCNL DCSP actual _ output = model.predict ( input _ data ) DCNL DCSP actual _ output _ shape = actual _ output.shape DCNL DCSP for ( expected _ dim , actual _ dim ) in zip ( expected _ output _ shape , actual _ output _ shape ) : DCNL DCSP DCSP if ( expected _ dim is not None ) : DCNL DCSP DCSP DCSP assert ( expected _ dim = = actual _ dim ) DCNL DCSP if ( expected _ output is not None ) : DCNL DCSP DCSP assert _ allclose ( actual _ output , expected _ output , rtol = 0.001 ) DCNL DCSP model _ config = model.get _ config ( ) DCNL DCSP model = Model.from _ config ( model _ config ) DCNL DCSP model.compile ( &apos; rmsprop &apos; , &apos; mse &apos; ) DCNL DCSP layer _ config = layer.get _ config ( ) DCNL DCSP layer _ config &#91; &apos; batch _ input _ shape &apos; &#93; = input _ shape DCNL DCSP layer = layer . _ _ class _ _ .from _ config ( layer _ config ) DCNL DCSP model = Sequential ( ) DCNL DCSP model.add ( layer ) DCNL DCSP model.compile ( &apos; rmsprop &apos; , &apos; mse &apos; ) DCNL DCSP actual _ output = model.predict ( input _ data ) DCNL DCSP actual _ output _ shape = actual _ output.shape DCNL DCSP for ( expected _ dim , actual _ dim ) in zip ( expected _ output _ shape , actual _ output _ shape ) : DCNL DCSP DCSP if ( expected _ dim is not None ) : DCNL DCSP DCSP DCSP assert ( expected _ dim = = actual _ dim ) DCNL DCSP if ( expected _ output is not None ) : DCNL DCSP DCSP assert _ allclose ( actual _ output , expected _ output , rtol = 0.001 ) DCNL DCSP json _ model = model.to _ json ( ) DCNL DCSP model = model _ from _ json ( json _ model ) DCNL DCSP return actual _ output
DCSP Raven.tags _ context ( { &apos; project &apos; : event.project _ id } ) DCNL DCSP plugin = plugins.get ( plugin _ slug ) DCNL DCSP safe _ execute ( plugin.post _ process , event = event , group = event.group , * * kwargs )
DCSP return ( isinstance ( asn , numbers.Integral ) and ( 0 &lt; = asn &lt; = 4294967295 ) )
DCSP tmp = &#91; BIN _ HEX _ DICT &#91; hstr &#93; for hstr in hex ( number ) &#91; 2 : &#93; &#93; DCNL DCSP return BIN _ ZSTRIP.sub ( &apos; 0b &apos; , &apos; &apos;.join ( tmp ) )
DCSP if ( not conf.direct ) : DCNL DCSP DCSP return DCNL DCSP details = None DCNL DCSP remote = False DCNL DCSP for dbms in SUPPORTED _ DBMS : DCNL DCSP DCSP details = re.search ( ( &apos; ^ ( ? P &lt; dbms &gt; % s ) : / / ( ? P &lt; credentials &gt; ( ? P &lt; user &gt; . + ? ) \ \ : ( ? P &lt; pass &gt; . * ) \ \ @ ) ? ( ? P &lt; remote &gt; ( ? P &lt; hostname &gt; . + ? ) \ \ : ( ? P &lt; port &gt; &#91; \ \ d &#93; + ) \ \ / ) ? ( ? P &lt; db &gt; &#91; \ \ w \ \ d \ \ DCSP \ \ : \ \ . \ \ _ \ \ - \ \ / \ \ \ \ &#93; + ? ) $ &apos; % dbms ) , conf.direct , re.I ) DCNL DCSP DCSP if details : DCNL DCSP DCSP DCSP conf.dbms = details.group ( &apos; dbms &apos; ) DCNL DCSP DCSP DCSP if details.group ( &apos; credentials &apos; ) : DCNL DCSP DCSP DCSP DCSP conf.dbmsUser = details.group ( &apos; user &apos; ) DCNL DCSP DCSP DCSP DCSP conf.dbmsPass = details.group ( &apos; pass &apos; ) DCNL DCSP DCSP DCSP elif conf.dbmsCred : DCNL DCSP DCSP DCSP DCSP ( conf.dbmsUser , conf.dbmsPass ) = conf.dbmsCred.split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP conf.dbmsUser = unicode ( ) DCNL DCSP DCSP DCSP DCSP conf.dbmsPass = unicode ( ) DCNL DCSP DCSP DCSP if ( not conf.dbmsPass ) : DCNL DCSP DCSP DCSP DCSP conf.dbmsPass = None DCNL DCSP DCSP DCSP if details.group ( &apos; remote &apos; ) : DCNL DCSP DCSP DCSP DCSP remote = True DCNL DCSP DCSP DCSP DCSP conf.hostname = details.group ( &apos; hostname &apos; ) .strip ( ) DCNL DCSP DCSP DCSP DCSP conf.port = int ( details.group ( &apos; port &apos; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP conf.hostname = &apos; localhost &apos; DCNL DCSP DCSP DCSP DCSP conf.port = 0 DCNL DCSP DCSP DCSP conf.dbmsDb = details.group ( &apos; db &apos; ) DCNL DCSP DCSP DCSP conf.parameters &#91; None &#93; = &apos; direct DCSP connection &apos; DCNL DCSP DCSP DCSP break DCNL DCSP if ( not details ) : DCNL DCSP DCSP errMsg = &apos; invalid DCSP target DCSP details , DCSP valid DCSP syntax DCSP is DCSP for DCSP instance DCSP &apos; DCNL DCSP DCSP errMsg + = &quot; &apos; mysql : / / USER : PASSWORD @ DBMS _ IP : DBMS _ PORT / DATABASE _ NAME &apos; DCSP &quot; DCNL DCSP DCSP errMsg + = &quot; or DCSP &apos; access : / / DATABASE _ FILEPATH &apos; &quot; DCNL DCSP DCSP raise SqlmapSyntaxException ( errMsg ) DCNL DCSP for ( dbmsName , data ) in DBMS _ DICT.items ( ) : DCNL DCSP DCSP if ( ( dbmsName = = conf.dbms ) or ( conf.dbms.lower ( ) in data &#91; 0 &#93; ) ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP if ( dbmsName in ( DBMS.ACCESS , DBMS.SQLITE , DBMS.FIREBIRD ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if remote : DCNL DCSP DCSP DCSP DCSP DCSP DCSP warnMsg = &apos; direct DCSP connection DCSP over DCSP the DCSP network DCSP for DCSP &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP warnMsg + = ( &apos; % s DCSP DBMS DCSP is DCSP not DCSP supported &apos; % dbmsName ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP logger.warn ( warnMsg ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP conf.hostname = &apos; localhost &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP conf.port = 0 DCNL DCSP DCSP DCSP DCSP elif ( not remote ) : DCNL DCSP DCSP DCSP DCSP DCSP errMsg = &apos; missing DCSP remote DCSP connection DCSP details DCSP ( e.g. DCSP &apos; DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = &quot; &apos; mysql : / / USER : PASSWORD @ DBMS _ IP : DBMS _ PORT / DATABASE _ NAME &apos; DCSP &quot; DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = &quot; or DCSP &apos; access : / / DATABASE _ FILEPATH &apos; ) &quot; DCNL DCSP DCSP DCSP DCSP DCSP raise SqlmapSyntaxException ( errMsg ) DCNL DCSP DCSP DCSP DCSP if ( dbmsName in ( DBMS.MSSQL , DBMS.SYBASE ) ) : DCNL DCSP DCSP DCSP DCSP DCSP import _ mssql DCNL DCSP DCSP DCSP DCSP DCSP import pymssql DCNL DCSP DCSP DCSP DCSP DCSP if ( ( not hasattr ( pymssql , &apos; _ _ version _ _ &apos; ) ) or ( pymssql . _ _ version _ _ &lt; &apos; 1.0.2 &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP errMsg = ( &quot; &apos; % s &apos; DCSP third-party DCSP library DCSP must DCSP be DCSP &quot; % data &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP errMsg + = &apos; version DCSP &gt; = DCSP 1.0.2 DCSP to DCSP work DCSP properly . DCSP &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP errMsg + = ( &quot; Download DCSP from DCSP &apos; % s &apos; &quot; % data &#91; 2 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP raise SqlmapMissingDependence ( errMsg ) DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.MYSQL ) : DCNL DCSP DCSP DCSP DCSP DCSP import pymysql DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.PGSQL ) : DCNL DCSP DCSP DCSP DCSP DCSP import psycopg2 DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.ORACLE ) : DCNL DCSP DCSP DCSP DCSP DCSP import cx _ Oracle DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.SQLITE ) : DCNL DCSP DCSP DCSP DCSP DCSP import sqlite3 DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.ACCESS ) : DCNL DCSP DCSP DCSP DCSP DCSP import pyodbc DCNL DCSP DCSP DCSP DCSP elif ( dbmsName = = DBMS.FIREBIRD ) : DCNL DCSP DCSP DCSP DCSP DCSP import kinterbasdb DCNL DCSP DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP DCSP if ( _ sqlalchemy and ( data &#91; 3 &#93; in _ sqlalchemy.dialects. _ _ all _ _ ) ) : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP errMsg = ( &quot; sqlmap DCSP requires DCSP &apos; % s &apos; DCSP third-party DCSP library DCSP &quot; % data &#91; 1 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = &apos; in DCSP order DCSP to DCSP directly DCSP connect DCSP to DCSP the DCSP DBMS DCSP &apos; DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = ( &quot; % s . DCSP You DCSP can DCSP download DCSP it DCSP from DCSP &apos; % s &apos; &quot; % ( dbmsName , data &#91; 2 &#93; ) ) DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = &quot; . DCSP Alternative DCSP is DCSP to DCSP use DCSP a DCSP package DCSP &apos; python-sqlalchemy &apos; DCSP &quot; DCNL DCSP DCSP DCSP DCSP DCSP errMsg + = ( &quot; with DCSP support DCSP for DCSP dialect DCSP &apos; % s &apos; DCSP installed &quot; % data &#91; 3 &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP raise SqlmapMissingDependence ( errMsg )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP try : DCNL DCSP DCSP return conn.create _ access _ key ( user _ name ) DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP log.error ( &apos; Failed DCSP to DCSP create DCSP access DCSP key . &apos; ) DCNL DCSP DCSP return str ( e )
DCSP while True : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return func ( * args ) DCNL DCSP DCSP except ( OSError , select.error ) as e : DCNL DCSP DCSP DCSP if ( e.args &#91; 0 &#93; ! = errno.EINTR ) : DCNL DCSP DCSP DCSP DCSP raise
DCSP if ( s.lower ( ) = = &apos; none &apos; ) : DCNL DCSP DCSP return &apos; None &apos; DCNL DCSP if is _ color _ like ( s ) : DCNL DCSP DCSP return s DCNL DCSP stmp = ( &apos; # &apos; + s ) DCNL DCSP if is _ color _ like ( stmp ) : DCNL DCSP DCSP return stmp DCNL DCSP colorarg = s DCNL DCSP msg = &apos; &apos; DCNL DCSP if ( s.find ( &apos; , &apos; ) &gt; = 0 ) : DCNL DCSP DCSP stmp = &apos; &apos;.join ( &#91; c for c in s if ( c.isdigit ( ) or ( c = = &apos; .&apos; ) or ( c = = &apos; , &apos; ) ) &#93; ) DCNL DCSP DCSP vals = stmp.split ( &apos; , &apos; ) DCNL DCSP DCSP if ( len ( vals ) ! = 3 ) : DCNL DCSP DCSP DCSP msg = &apos; \ nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3 &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP colorarg = &#91; float ( val ) for val in vals &#93; DCNL DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP msg = &apos; \ nCould DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats &apos; DCNL DCSP if ( ( not msg ) and is _ color _ like ( colorarg ) ) : DCNL DCSP DCSP return colorarg DCNL DCSP raise ValueError ( ( &apos; % s DCSP does DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg % s &apos; % ( s , msg ) ) )
DCSP tests = &#91; &#93; DCNL DCSP for name in os.listdir ( testdir ) : DCNL DCSP DCSP if ( ( not suffix ) or name.endswith ( suffix ) ) : DCNL DCSP DCSP DCSP for prefix in prefixes : DCNL DCSP DCSP DCSP DCSP if name.startswith ( prefix ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( remove _ suffix and name.endswith ( suffix ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP name = name &#91; : ( - len ( suffix ) ) &#93; DCNL DCSP DCSP DCSP DCSP DCSP if ( name not in excludes ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP tests.append ( name ) DCNL DCSP tests.sort ( ) DCNL DCSP return tests
DCSP d = { } DCNL DCSP id _ path = os.path.join ( storage _ path , &apos; compute _ nodes &apos; ) DCNL DCSP if os.path.exists ( id _ path ) : DCNL DCSP DCSP with open ( id _ path ) as f : DCNL DCSP DCSP DCSP d = json.loads ( f.read ( ) ) DCNL DCSP recent _ users = &#91; &#93; DCNL DCSP for node in d : DCNL DCSP DCSP if ( ( time.time ( ) - d &#91; node &#93; ) &lt; TWENTY _ FOUR _ HOURS ) : DCNL DCSP DCSP DCSP recent _ users.append ( node ) DCNL DCSP return recent _ users
DCSP return ( data.encode ( enc ) if isinstance ( data , unicode ) else bytes ( data ) )
DCSP bind = op.get _ bind ( ) DCNL DCSP insp = sa.engine.reflection.Inspector.from _ engine ( bind ) DCNL DCSP return ( table _ name in insp.get _ table _ names ( ) )
DCSP for parser _ type in PARSER _ TYPES : DCNL DCSP DCSP parsers &#91; parser _ type &#93; = { } DCNL DCSP DCSP for p in plugin.get _ plugins ( interface = ( parser _ type + u &apos; _ parser &apos; ) ) : DCNL DCSP DCSP DCSP parsers &#91; parser _ type &#93; &#91; p.name.replace ( u &apos;parser _ &apos; , u &apos; &apos; ) &#93; = p.instance DCNL DCSP DCSP func _ name = ( u &apos;parse _ &apos; + parser _ type ) DCNL DCSP DCSP default _ parsers &#91; parser _ type &#93; = max ( iter ( parsers &#91; parser _ type &#93; .items ( ) ) , key = ( lambda p : getattr ( getattr ( p &#91; 1 &#93; , func _ name ) , u &apos;priority &apos; , 0 ) ) ) &#91; 0 &#93; DCNL DCSP DCSP log.debug ( ( u &apos;setting DCSP default DCSP % s DCSP parser DCSP to DCSP % s . DCSP ( options : DCSP % s ) &apos; % ( parser _ type , default _ parsers &#91; parser _ type &#93; , parsers &#91; parser _ type &#93; ) ) )
DCSP fields = &#91; &#93; DCNL DCSP ( i , n ) = ( 0 , len ( line ) ) DCNL DCSP while ( i &lt; n ) : DCNL DCSP DCSP ( field , i ) = parsefield ( line , i , n ) DCNL DCSP DCSP fields.append ( field ) DCNL DCSP DCSP i = ( i + 1 ) DCNL DCSP if ( len ( fields ) &lt; 2 ) : DCNL DCSP DCSP return ( None , None ) DCNL DCSP ( key , view , rest ) = ( fields &#91; 0 &#93; , fields &#91; 1 &#93; , fields &#91; 2 : &#93; ) DCNL DCSP fields = { &apos; view &apos; : view } DCNL DCSP for field in rest : DCNL DCSP DCSP i = field.find ( &apos; = &apos; ) DCNL DCSP DCSP if ( i &lt; 0 ) : DCNL DCSP DCSP DCSP fkey = field DCNL DCSP DCSP DCSP fvalue = &apos; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fkey = field &#91; : i &#93; .strip ( ) DCNL DCSP DCSP DCSP fvalue = field &#91; ( i + 1 ) : &#93; .strip ( ) DCNL DCSP DCSP if ( fkey in fields ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP fields &#91; fkey &#93; = fvalue DCNL DCSP return ( key , fields )
DCSP global A , p _ keys , v _ keys DCNL DCSP if ( ( p &lt; 0.1 ) or ( p &gt; 0.999 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; p DCSP must DCSP be DCSP between DCSP .1 DCSP and DCSP .999 &apos; ) DCNL DCSP if ( p &lt; 0.9 ) : DCNL DCSP DCSP if ( v &lt; 2 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; v DCSP must DCSP be DCSP &gt; DCSP 2 DCSP when DCSP p DCSP &lt; DCSP .9 &apos; ) DCNL DCSP elif ( v &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; v DCSP must DCSP be DCSP &gt; DCSP 1 DCSP when DCSP p DCSP &gt; = DCSP .9 &apos; ) DCNL DCSP p = float ( p ) DCNL DCSP if isinstance ( v , np.ndarray ) : DCNL DCSP DCSP v = v.item ( ) DCNL DCSP if ( ( p , v ) in A ) : DCNL DCSP DCSP y = ( _ func ( A &#91; ( p , v ) &#93; , p , r , v ) + 1.0 ) DCNL DCSP elif ( ( p not in p _ keys ) and ( v not in ( v _ keys + ( &#91; &#93; , &#91; 1 &#93; ) &#91; ( p &gt; = 0.9 ) &#93; ) ) ) : DCNL DCSP DCSP ( v0 , v1 , v2 ) = _ select _ vs ( v , p ) DCNL DCSP DCSP ( p0 , p1 , p2 ) = _ select _ ps ( p ) DCNL DCSP DCSP r0 _ sq = ( _ interpolate _ p ( p , r , v0 ) * * 2 ) DCNL DCSP DCSP r1 _ sq = ( _ interpolate _ p ( p , r , v1 ) * * 2 ) DCNL DCSP DCSP r2 _ sq = ( _ interpolate _ p ( p , r , v2 ) * * 2 ) DCNL DCSP DCSP ( v _ , v0 _ , v1 _ , v2 _ ) = ( ( 1.0 / v ) , ( 1.0 / v0 ) , ( 1.0 / v1 ) , ( 1.0 / v2 ) ) DCNL DCSP DCSP d2 = ( ( 2.0 * ( ( ( r2 _ sq - r1 _ sq ) / ( v2 _ - v1 _ ) ) - ( ( r0 _ sq - r1 _ sq ) / ( v0 _ - v1 _ ) ) ) ) / ( v2 _ - v0 _ ) ) DCNL DCSP DCSP if ( ( v2 _ + v0 _ ) &gt; = ( v1 _ + v1 _ ) ) : DCNL DCSP DCSP DCSP d1 = ( ( ( r2 _ sq - r1 _ sq ) / ( v2 _ - v1 _ ) ) - ( ( 0.5 * d2 ) * ( v2 _ - v1 _ ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP d1 = ( ( ( r1 _ sq - r0 _ sq ) / ( v1 _ - v0 _ ) ) + ( ( 0.5 * d2 ) * ( v1 _ - v0 _ ) ) ) DCNL DCSP DCSP d0 = r1 _ sq DCNL DCSP DCSP y = math.sqrt ( ( ( ( ( d2 / 2.0 ) * ( ( v _ - v1 _ ) * * 2.0 ) ) + ( d1 * ( v _ - v1 _ ) ) ) + d0 ) ) DCNL DCSP elif ( v not in ( v _ keys + ( &#91; &#93; , &#91; 1 &#93; ) &#91; ( p &gt; = 0.9 ) &#93; ) ) : DCNL DCSP DCSP y = _ interpolate _ v ( p , r , v ) DCNL DCSP elif ( p not in p _ keys ) : DCNL DCSP DCSP y = _ interpolate _ p ( p , r , v ) DCNL DCSP return ( ( math.sqrt ( 2 ) * ( - y ) ) * scipy.stats.t.isf ( ( ( 1.0 + p ) / 2.0 ) , ( v , 1e + 38 ) &#91; ( v &gt; 1e + 38 ) &#93; ) )
DCSP fut = delete _ async ( blob _ key , * * options ) DCNL DCSP return fut.get _ result ( )
DCSP return call _ talib _ with _ hlc ( barDs , count , talib.TRANGE )
DCSP return ( 1920 &lt; = year &lt; 2030 )
DCSP if ( ( pillar is not None ) and ( not isinstance ( pillar , dict ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; Pillar DCSP data DCSP must DCSP be DCSP formatted DCSP as DCSP a DCSP dictionary &apos; ) DCNL DCSP _ _ opts _ _ &#91; &apos; file _ client &apos; &#93; = &apos; local &apos; DCNL DCSP minion = salt.minion.MasterMinion ( _ _ opts _ _ ) DCNL DCSP running = minion.functions &#91; &apos; state.high &apos; &#93; ( data , test = None , queue = False , pillar = pillar , * * kwargs ) DCNL DCSP ret = { minion.opts &#91; &apos; id &apos; &#93; : running } DCNL DCSP _ _ jid _ event _ _ .fire _ event ( { &apos; data &apos; : ret , &apos; outputter &apos; : &apos; highstate &apos; } , &apos; progress &apos; ) DCNL DCSP return ret
DCSP if isinstance ( a , ( tuple , list , set ) ) : DCNL DCSP DCSP l = &#91; &#93; DCNL DCSP DCSP for item in a : DCNL DCSP DCSP DCSP l.extend ( flatten ( item ) ) DCNL DCSP DCSP return l DCNL DCSP else : DCNL DCSP DCSP return &#91; a &#93;
DCSP all _ cats = Category.objects.filter ( type = amo.ADDON _ WEBAPP ) DCNL DCSP try : DCNL DCSP DCSP entertainment = all _ cats.filter ( slug = &apos; entertainment-sports &apos; ) &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP print &apos; Could DCSP not DCSP find DCSP Category DCSP with DCSP slug = &quot; entertainment-sports &quot; &apos; DCNL DCSP else : DCNL DCSP DCSP entertainment.name = &apos; Entertainment &apos; DCNL DCSP DCSP entertainment.slug = &apos; entertainment &apos; DCNL DCSP DCSP entertainment.save ( ) DCNL DCSP DCSP print &apos; Renamed DCSP &quot; Entertainment DCSP &amp; DCSP Sports &quot; DCSP to DCSP &quot; Entertainment &quot; &apos; DCNL DCSP Category.objects.create ( type = amo.ADDON _ WEBAPP , slug = &apos; sports &apos; , name = &apos; Sports &apos; ) DCNL DCSP print &apos; Created DCSP &quot; Sports &quot; &apos; DCNL DCSP try : DCNL DCSP DCSP music = all _ cats.filter ( slug = &apos; music &apos; ) &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP print &apos; Could DCSP not DCSP find DCSP Category DCSP with DCSP slug = &quot; music &quot; &apos; DCNL DCSP else : DCNL DCSP DCSP music.name = &apos; Music &apos; DCNL DCSP DCSP music.save ( ) DCNL DCSP DCSP print &apos; Renamed DCSP &quot; Music DCSP &amp; DCSP Audio &quot; DCSP to DCSP &quot; Music &quot; &apos; DCNL DCSP try : DCNL DCSP DCSP social = all _ cats.filter ( slug = &apos; social &apos; ) &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP print &apos; Could DCSP not DCSP find DCSP Category DCSP with DCSP slug = &quot; social &quot; &apos; DCNL DCSP else : DCNL DCSP DCSP social.name = &apos; Social &apos; DCNL DCSP DCSP social.save ( ) DCNL DCSP DCSP print &apos; Renamed DCSP &quot; Social DCSP &amp; DCSP Communication &quot; DCSP to DCSP &quot; Social &quot; &apos; DCNL DCSP try : DCNL DCSP DCSP books = all _ cats.filter ( slug = &apos; books-reference &apos; ) &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP print &apos; Could DCSP not DCSP find DCSP Category DCSP with DCSP slug = &quot; books-reference &quot; &apos; DCNL DCSP else : DCNL DCSP DCSP books.name = &apos; Books &apos; DCNL DCSP DCSP books.slug = &apos; books &apos; DCNL DCSP DCSP books.save ( ) DCNL DCSP DCSP print &apos; Renamed DCSP &quot; Books DCSP &amp; DCSP Reference &quot; DCSP to DCSP &quot; Books &quot; &apos; DCNL DCSP Category.objects.create ( type = amo.ADDON _ WEBAPP , slug = &apos; reference &apos; , name = &apos; Reference &apos; ) DCNL DCSP print &apos; Created DCSP &quot; Reference &quot; &apos; DCNL DCSP try : DCNL DCSP DCSP photos = all _ cats.filter ( slug = &apos; photos-media &apos; ) &#91; 0 &#93; DCNL DCSP except IndexError : DCNL DCSP DCSP print &apos; Could DCSP not DCSP find DCSP Category DCSP with DCSP slug = &quot; photos-media &quot; &apos; DCNL DCSP else : DCNL DCSP DCSP photos.name = &apos; Photo DCSP &amp; DCSP Video &apos; DCNL DCSP DCSP photos.slug = &apos; photo-video &apos; DCNL DCSP DCSP photos.save ( ) DCNL DCSP DCSP print &apos; Renamed DCSP &quot; Photos DCSP &amp; DCSP Media &quot; DCSP to DCSP &quot; Photo DCSP &amp; DCSP Video &quot; &apos; DCNL DCSP Category.objects.create ( type = amo.ADDON _ WEBAPP , slug = &apos; maps-navigation &apos; , name = &apos; Maps DCSP &amp; DCSP Navigation &apos; ) DCNL DCSP print &apos; Created DCSP &quot; Maps DCSP &amp; DCSP Navigation &quot; &apos;
DCSP dotted _ path _ split = dotted _ path.split ( &apos; .&apos; ) DCNL DCSP if ( len ( dotted _ path _ split ) &gt; 1 ) : DCNL DCSP DCSP klass _ name = dotted _ path _ split &#91; ( -1 ) &#93; DCNL DCSP DCSP module _ name = &apos; .&apos;.join ( dotted _ path _ split &#91; : ( -1 ) &#93; ) DCNL DCSP DCSP module = load _ module ( module _ name ) DCNL DCSP DCSP if has _ attribute ( module , klass _ name ) : DCNL DCSP DCSP DCSP klass = getattr ( module , klass _ name ) DCNL DCSP DCSP DCSP return klass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise AttributeError ( ( &apos; Module DCSP % s DCSP does DCSP not DCSP have DCSP class DCSP attribute DCSP % s &apos; % ( module _ name , klass _ name ) ) ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Dotted DCSP module DCSP path DCSP % s DCSP must DCSP contain DCSP a DCSP module DCSP name DCSP and DCSP a DCSP classname &apos; % dotted _ path ) )
DCSP return stats
DCSP img = gpu _ contiguous ( X ) DCNL DCSP kerns = gpu _ contiguous ( w ) DCNL DCSP desc = GpuDnnConvDesc ( border _ mode = border _ mode , subsample = subsample , conv _ mode = conv _ mode ) ( gpu _ alloc _ empty ( img.shape &#91; 0 &#93; , kerns.shape &#91; 1 &#93; , ( img.shape &#91; 2 &#93; * subsample &#91; 0 &#93; ) , ( img.shape &#91; 3 &#93; * subsample &#91; 1 &#93; ) ) .shape , kerns.shape ) DCNL DCSP out = gpu _ alloc _ empty ( img.shape &#91; 0 &#93; , kerns.shape &#91; 1 &#93; , ( img.shape &#91; 2 &#93; * subsample &#91; 0 &#93; ) , ( img.shape &#91; 3 &#93; * subsample &#91; 1 &#93; ) ) DCNL DCSP d _ img = GpuDnnConvGradI ( ) ( kerns , img , out , desc ) DCNL DCSP return d _ img
DCSP if ( not cwd ) : DCNL DCSP DCSP cwd = os.getcwd ( ) DCNL DCSP if ( not env ) : DCNL DCSP DCSP env = common _ environment ( ) DCNL DCSP cmd = list ( cmd ) DCNL DCSP escaped _ cmd = &apos; DCSP &apos; .join ( ( pipes.quote ( c ) for c in cmd ) ) DCNL DCSP display.info ( ( &apos; Run DCSP command : DCSP % s &apos; % escaped _ cmd ) , verbosity = 1 ) DCNL DCSP display.info ( ( &apos; Working DCSP directory : DCSP % s &apos; % cwd ) , verbosity = 2 ) DCNL DCSP program = find _ executable ( cmd &#91; 0 &#93; , cwd = cwd , path = env &#91; &apos; PATH &apos; &#93; , required = &apos; warning &apos; ) DCNL DCSP if program : DCNL DCSP DCSP display.info ( ( &apos; Program DCSP found : DCSP % s &apos; % program ) , verbosity = 2 ) DCNL DCSP for key in sorted ( env.keys ( ) ) : DCNL DCSP DCSP display.info ( ( &apos; % s = % s &apos; % ( key , env &#91; key &#93; ) ) , verbosity = 2 ) DCNL DCSP if explain : DCNL DCSP DCSP return ( None , None ) DCNL DCSP communicate = False DCNL DCSP if ( stdin is not None ) : DCNL DCSP DCSP data = None DCNL DCSP DCSP communicate = True DCNL DCSP elif ( data is not None ) : DCNL DCSP DCSP stdin = subprocess.PIPE DCNL DCSP DCSP communicate = True DCNL DCSP if stdout : DCNL DCSP DCSP communicate = True DCNL DCSP if capture : DCNL DCSP DCSP stdout = ( stdout or subprocess.PIPE ) DCNL DCSP DCSP stderr = subprocess.PIPE DCNL DCSP DCSP communicate = True DCNL DCSP else : DCNL DCSP DCSP stderr = None DCNL DCSP start = time.time ( ) DCNL DCSP try : DCNL DCSP DCSP process = subprocess.Popen ( cmd , env = env , stdin = stdin , stdout = stdout , stderr = stderr , cwd = cwd ) DCNL DCSP except OSError as ex : DCNL DCSP DCSP if ( ex.errno = = errno.ENOENT ) : DCNL DCSP DCSP DCSP raise ApplicationError ( ( &apos; Required DCSP program DCSP &quot; % s &quot; DCSP not DCSP found . &apos; % cmd &#91; 0 &#93; ) ) DCNL DCSP DCSP raise DCNL DCSP if communicate : DCNL DCSP DCSP ( stdout , stderr ) = process.communicate ( data ) DCNL DCSP else : DCNL DCSP DCSP process.wait ( ) DCNL DCSP DCSP ( stdout , stderr ) = ( None , None ) DCNL DCSP status = process.returncode DCNL DCSP runtime = ( time.time ( ) - start ) DCNL DCSP display.info ( ( &apos; Command DCSP exited DCSP with DCSP status DCSP % s DCSP after DCSP % s DCSP seconds . &apos; % ( status , runtime ) ) , verbosity = 4 ) DCNL DCSP if ( status = = 0 ) : DCNL DCSP DCSP return ( stdout , stderr ) DCNL DCSP raise SubprocessError ( cmd , status , stdout , stderr , runtime )
DCSP return archive.getTextLines ( getAlterationFile ( fileName ) )
DCSP checkfile = ek ( os.path.abspath , checkfile ) DCNL DCSP if ( not ek ( os.path.exists , checkfile ) ) : DCNL DCSP DCSP return True DCNL DCSP try : DCNL DCSP DCSP f = ek ( io.open , checkfile , u &apos;rb &apos; ) DCNL DCSP DCSP f.close ( ) DCNL DCSP except IOError : DCNL DCSP DCSP return True DCNL DCSP if writeLockCheck : DCNL DCSP DCSP lockFile = ( checkfile + u &apos; .lckchk &apos; ) DCNL DCSP DCSP if ek ( os.path.exists , lockFile ) : DCNL DCSP DCSP DCSP ek ( os.remove , lockFile ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ek ( os.rename , checkfile , lockFile ) DCNL DCSP DCSP DCSP time.sleep ( 1 ) DCNL DCSP DCSP DCSP ek ( os.rename , lockFile , checkfile ) DCNL DCSP DCSP except ( OSError , IOError ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP return UUID ( hex = _ BOOT _ ID.getContent ( ) .strip ( ) )
DCSP os.chdir ( os.path.join ( gitdname , &apos; statsmodels &apos; , &apos; docs &apos; ) ) DCNL DCSP sphinx _ dir = os.path.join ( virtual _ dir , &apos; bin &apos; ) DCNL DCSP retcode = subprocess.call ( &apos; DCSP &apos; .join ( &#91; &apos; make &apos; , &apos; latexpdf &apos; , ( ( &apos; SPHINXBUILD = &apos; + sphinx _ dir ) + &apos; / sphinx-build &apos; ) &#93; ) , shell = True ) DCNL DCSP if ( retcode ! = 0 ) : DCNL DCSP DCSP msg = ( &apos; Could DCSP not DCSP build DCSP the DCSP pdf DCSP docs DCSP for DCSP branch DCSP % s &apos; % branch ) DCNL DCSP DCSP raise Exception ( msg ) DCNL DCSP os.chdir ( dname )
DCSP ordered _ steps = order _ workflow _ steps ( steps ) DCNL DCSP workflow.has _ cycles = ( not bool ( ordered _ steps ) ) DCNL DCSP for ( i , step ) in enumerate ( ( ordered _ steps or steps ) ) : DCNL DCSP DCSP step.order _ index = i DCNL DCSP DCSP workflow.steps.append ( step )
DCSP ( exc _ type , exc _ value , exc _ traceback ) = sys.exc _ info ( ) DCNL DCSP if set ( str ( exc _ value ) .split ( &apos; DCSP &apos; ) ) .issuperset ( set ( keywords ) ) : DCNL DCSP DCSP exc _ value . _ safe _ message = message DCNL DCSP DCSP raise
DCSP html = re.sub ( &apos; id = &quot; \ \ d + &quot; &apos; , &apos; id = &quot; # # # &quot; &apos; , html ) DCNL DCSP global _ id = 1 DCNL DCSP while ( len ( re.findall ( &apos; id = &quot; # # # &quot; &apos; , html ) ) &gt; 0 ) : DCNL DCSP DCSP html = re.sub ( &apos; id = &quot; # # # &quot; &apos; , ( &apos; id = &quot; % s &quot; &apos; % global _ id ) , html , count = 1 ) DCNL DCSP DCSP global _ id + = 1 DCNL DCSP return html
DCSP scenario = Scenario.from _ string ( SCENARIO1 ) DCNL DCSP assert isinstance ( scenario , Scenario ) DCNL DCSP assert _ equals ( scenario.name , &apos; Adding DCSP some DCSP students DCSP to DCSP my DCSP university DCSP database &apos; )
DCSP _ volume _ register.append ( cls ) DCNL DCSP return cls
DCSP if isinstance ( constantString , bytes ) : DCNL DCSP DCSP otherType = constantString.decode ( &apos; ascii &apos; ) DCNL DCSP else : DCNL DCSP DCSP otherType = constantString.encode ( &apos; ascii &apos; ) DCNL DCSP if ( type ( constantString ) = = type ( inputString ) ) : DCNL DCSP DCSP return constantString DCNL DCSP else : DCNL DCSP DCSP return otherType
DCSP tar _ compression = { &apos; gzip &apos; : &apos; gz &apos; , &apos; bzip2 &apos; : &apos; bz2 &apos; , None : &apos; &apos; , &apos; compress &apos; : &apos; &apos; } DCNL DCSP compress _ ext = { &apos; gzip &apos; : &apos; .gz &apos; , &apos; bzip2 &apos; : &apos; .bz2 &apos; , &apos; compress &apos; : &apos; .Z &apos; } DCNL DCSP if ( ( compress is not None ) and ( compress not in compress _ ext.keys ( ) ) ) : DCNL DCSP DCSP raise ValueError , &quot; bad DCSP value DCSP for DCSP &apos; compress &apos; : DCSP must DCSP be DCSP None , DCSP &apos; gzip &apos; , DCSP &apos; bzip2 &apos; DCSP or DCSP &apos; compress &apos; &quot; DCNL DCSP archive _ name = ( base _ name + &apos; .tar &apos; ) DCNL DCSP if ( compress ! = &apos; compress &apos; ) : DCNL DCSP DCSP archive _ name + = compress _ ext.get ( compress , &apos; &apos; ) DCNL DCSP mkpath ( os.path.dirname ( archive _ name ) , dry _ run = dry _ run ) DCNL DCSP import tarfile DCNL DCSP log.info ( &apos; Creating DCSP tar DCSP archive &apos; ) DCNL DCSP uid = _ get _ uid ( owner ) DCNL DCSP gid = _ get _ gid ( group ) DCNL DCSP def _ set _ uid _ gid ( tarinfo ) : DCNL DCSP DCSP if ( gid is not None ) : DCNL DCSP DCSP DCSP tarinfo.gid = gid DCNL DCSP DCSP DCSP tarinfo.gname = group DCNL DCSP DCSP if ( uid is not None ) : DCNL DCSP DCSP DCSP tarinfo.uid = uid DCNL DCSP DCSP DCSP tarinfo.uname = owner DCNL DCSP DCSP return tarinfo DCNL DCSP if ( not dry _ run ) : DCNL DCSP DCSP tar = tarfile.open ( archive _ name , ( &apos; w &#124; % s &apos; % tar _ compression &#91; compress &#93; ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP tar.add ( base _ dir , filter = _ set _ uid _ gid ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP tar.close ( ) DCNL DCSP if ( compress = = &apos; compress &apos; ) : DCNL DCSP DCSP warn ( &quot; &apos; compress &apos; DCSP will DCSP be DCSP deprecated . &quot; , PendingDeprecationWarning ) DCNL DCSP DCSP compressed _ name = ( archive _ name + compress _ ext &#91; compress &#93; ) DCNL DCSP DCSP if ( sys.platform = = &apos; win32 &apos; ) : DCNL DCSP DCSP DCSP cmd = &#91; compress , archive _ name , compressed _ name &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP cmd = &#91; compress , &apos; -f &apos; , archive _ name &#93; DCNL DCSP DCSP spawn ( cmd , dry _ run = dry _ run ) DCNL DCSP DCSP return compressed _ name DCNL DCSP return archive _ name
DCSP allevents = &#91; &#93; DCNL DCSP timeout = Timeout.start _ new ( timeout ) DCNL DCSP result = SelectResult ( ) DCNL DCSP try : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP for readfd in rlist : DCNL DCSP DCSP DCSP DCSP allevents.append ( core.read _ event ( get _ fileno ( readfd ) , result.update , arg = readfd ) ) DCNL DCSP DCSP DCSP for writefd in wlist : DCNL DCSP DCSP DCSP DCSP allevents.append ( core.write _ event ( get _ fileno ( writefd ) , result.update , arg = writefd ) ) DCNL DCSP DCSP except IOError as ex : DCNL DCSP DCSP DCSP raise error ( * ex.args ) DCNL DCSP DCSP result.event.wait ( timeout = timeout ) DCNL DCSP DCSP return ( result.read , result.write , &#91; &#93; ) DCNL DCSP finally : DCNL DCSP DCSP for evt in allevents : DCNL DCSP DCSP DCSP evt.cancel ( ) DCNL DCSP DCSP timeout.cancel ( )
DCSP if isinstance ( url , six.text _ type ) : DCNL DCSP DCSP return quote _ chinese ( url.encode ( encodeing ) ) DCNL DCSP if six.PY3 : DCNL DCSP DCSP res = &#91; ( six.int2byte ( b ) .decode ( &apos; latin-1 &apos; ) if ( b &lt; 128 ) else ( &apos; % % % 02X &apos; % b ) ) for b in url &#93; DCNL DCSP else : DCNL DCSP DCSP res = &#91; ( b if ( ord ( b ) &lt; 128 ) else ( &apos; % % % 02X &apos; % ord ( b ) ) ) for b in url &#93; DCNL DCSP return &apos; &apos;.join ( res )
DCSP action _ name = ugettext _ noop ( &apos; certificates DCSP generated &apos; ) DCNL DCSP TASK _ LOG.info ( u &apos;Task : DCSP % s , DCSP InstructorTask DCSP ID : DCSP % s , DCSP Task DCSP type : DCSP % s , DCSP Preparing DCSP for DCSP task DCSP execution &apos; , xmodule _ instance _ args.get ( &apos; task _ id &apos; ) , entry _ id , action _ name ) DCNL DCSP task _ fn = partial ( generate _ students _ certificates , xmodule _ instance _ args ) DCNL DCSP return run _ main _ task ( entry _ id , task _ fn , action _ name )
DCSP if ( repo not in settings.FRONTEND _ REPOS ) : DCNL DCSP DCSP raise Http404 DCNL DCSP BUILD _ ID = get _ build _ id ( repo ) DCNL DCSP ua = request.META.get ( &apos; HTTP _ USER _ AGENT &apos; , &apos; &apos; ) .lower ( ) DCNL DCSP include _ splash = False DCNL DCSP detect _ region _ with _ geoip = False DCNL DCSP if ( repo = = &apos; fireplace &apos; ) : DCNL DCSP DCSP include _ splash = True DCNL DCSP DCSP has _ sim _ info _ in _ query = ( ( &apos; mccs &apos; in request.GET ) or ( ( &apos; mcc &apos; in request.GET ) and ( &apos; mnc &apos; in request.GET ) ) ) DCNL DCSP DCSP if ( not has _ sim _ info _ in _ query ) : DCNL DCSP DCSP DCSP detect _ region _ with _ geoip = True DCNL DCSP ( fxa _ auth _ state , fxa _ auth _ url ) = fxa _ auth _ info ( ) DCNL DCSP site _ settings = { &apos; dev _ pay _ providers &apos; : settings.DEV _ PAY _ PROVIDERS , &apos; fxa _ auth _ state &apos; : fxa _ auth _ state , &apos; fxa _ auth _ url &apos; : fxa _ auth _ url } DCNL DCSP ctx = { &apos; BUILD _ ID &apos; : BUILD _ ID , &apos; LANG &apos; : request.LANG , &apos; langdir &apos; : lang _ dir ( request.LANG ) , &apos; include _ splash &apos; : include _ splash , &apos; repo &apos; : repo , &apos; robots &apos; : ( &apos; googlebot &apos; in ua ) , &apos; site _ settings &apos; : site _ settings , &apos; newrelic _ header &apos; : newrelic.agent.get _ browser _ timing _ header , &apos; newrelic _ footer &apos; : newrelic.agent.get _ browser _ timing _ footer } DCNL DCSP if ( repo = = &apos; fireplace &apos; ) : DCNL DCSP DCSP resolved _ url = resolve ( request.path ) DCNL DCSP DCSP if ( resolved _ url.url _ name = = &apos; detail &apos; ) : DCNL DCSP DCSP DCSP ctx = add _ app _ ctx ( ctx , resolved _ url.kwargs &#91; &apos; app _ slug &apos; &#93; ) DCNL DCSP ctx &#91; &apos; waffle _ switches &apos; &#93; = list ( waffle.models.Switch.objects.filter ( active = True ) .values _ list ( &apos; name &apos; , flat = True ) ) DCNL DCSP media _ url = urlparse ( settings.MEDIA _ URL ) DCNL DCSP if media _ url.netloc : DCNL DCSP DCSP ctx &#91; &apos; media _ origin &apos; &#93; = ( ( media _ url.scheme + &apos; : / / &apos; ) + media _ url.netloc ) DCNL DCSP if detect _ region _ with _ geoip : DCNL DCSP DCSP region _ middleware = RegionMiddleware ( ) DCNL DCSP DCSP ctx &#91; &apos; geoip _ region &apos; &#93; = region _ middleware.region _ from _ request ( request ) DCNL DCSP if ( repo = = &apos; marketplace-tv-front-end &apos; ) : DCNL DCSP DCSP return render ( request , &apos; commonplace / index _ tv.html &apos; , ctx ) DCNL DCSP elif ( repo in settings.REACT _ REPOS ) : DCNL DCSP DCSP return render ( request , &apos; commonplace / index _ react.html &apos; , ctx ) DCNL DCSP elif ( repo in settings.COMMONPLACE _ REPOS ) : DCNL DCSP DCSP return render ( request , &apos; commonplace / index.html &apos; , ctx )
DCSP print ( ( &apos; Determining DCSP list DCSP of DCSP input DCSP files DCSP and DCSP labels DCSP from DCSP % s . &apos; % data _ dir ) ) DCNL DCSP challenge _ synsets = &#91; l.strip ( ) for l in tf.gfile.FastGFile ( labels _ file , &apos; r &apos; ) .readlines ( ) &#93; DCNL DCSP labels = &#91; &#93; DCNL DCSP filenames = &#91; &#93; DCNL DCSP synsets = &#91; &#93; DCNL DCSP label _ index = 1 DCNL DCSP for synset in challenge _ synsets : DCNL DCSP DCSP jpeg _ file _ path = ( &apos; % s / % s / * .JPEG &apos; % ( data _ dir , synset ) ) DCNL DCSP DCSP matching _ files = tf.gfile.Glob ( jpeg _ file _ path ) DCNL DCSP DCSP labels.extend ( ( &#91; label _ index &#93; * len ( matching _ files ) ) ) DCNL DCSP DCSP synsets.extend ( ( &#91; synset &#93; * len ( matching _ files ) ) ) DCNL DCSP DCSP filenames.extend ( matching _ files ) DCNL DCSP DCSP if ( not ( label _ index % 100 ) ) : DCNL DCSP DCSP DCSP print ( ( &apos; Finished DCSP finding DCSP files DCSP in DCSP % d DCSP of DCSP % d DCSP classes . &apos; % ( label _ index , len ( challenge _ synsets ) ) ) ) DCNL DCSP DCSP label _ index + = 1 DCNL DCSP shuffled _ index = list ( range ( len ( filenames ) ) ) DCNL DCSP random.seed ( 12345 ) DCNL DCSP random.shuffle ( shuffled _ index ) DCNL DCSP filenames = &#91; filenames &#91; i &#93; for i in shuffled _ index &#93; DCNL DCSP synsets = &#91; synsets &#91; i &#93; for i in shuffled _ index &#93; DCNL DCSP labels = &#91; labels &#91; i &#93; for i in shuffled _ index &#93; DCNL DCSP print ( ( &apos; Found DCSP % d DCSP JPEG DCSP files DCSP across DCSP % d DCSP labels DCSP inside DCSP % s . &apos; % ( len ( filenames ) , len ( challenge _ synsets ) , data _ dir ) ) ) DCNL DCSP return ( filenames , synsets , labels )
DCSP ret = &#91; set ( ) , set ( ) , set ( ) , set ( ) &#93; DCNL DCSP for media _ type in media _ type _ lst : DCNL DCSP DCSP precedence = _ MediaType ( media _ type ) .precedence DCNL DCSP DCSP ret &#91; ( 3 - precedence ) &#93; .add ( media _ type ) DCNL DCSP return &#91; media _ types for media _ types in ret if media _ types &#93;
DCSP return False
DCSP kw &#91; &apos; exit &apos; &#93; = False DCNL DCSP return TestProgram ( * arg , * * kw ) .success
DCSP testcase.assertEqual ( text1.splitlines ( ) , text2.splitlines ( ) , msg )
DCSP if ( not args ) : DCNL DCSP DCSP args = sys.argv &#91; 1 : &#93; DCNL DCSP logging.basicConfig ( level = logging.INFO , stream = sys.stdout , format = &apos; % ( message ) s &apos; ) DCNL DCSP for gt in args : DCNL DCSP DCSP load _ grammar ( gt , save = True , force = True ) DCNL DCSP return True
DCSP return _ callProtocolWithDeferred ( ( lambda d : _ BackRelay ( d , errortoo = errortoo ) ) , executable , args , env , path , reactor )
DCSP return _ contains ( exp , Sorted )
DCSP assert ( not ( ( not _ yet _ run and running ) or ( not _ yet _ run and finished ) or ( running and finished ) ) ) , &apos; Cannot DCSP specify DCSP more DCSP than DCSP one DCSP filter DCSP to DCSP this DCSP function &apos; DCNL DCSP not _ queued = ( &apos; ( SELECT DCSP job _ id DCSP FROM DCSP afe _ host _ queue _ entries DCSP WHERE DCSP status DCSP ! = DCSP &quot; % s &quot; ) &apos; % models.HostQueueEntry.Status.QUEUED ) DCNL DCSP not _ finished = &apos; ( SELECT DCSP job _ id DCSP FROM DCSP afe _ host _ queue _ entries DCSP WHERE DCSP not DCSP complete ) &apos; DCNL DCSP if not _ yet _ run : DCNL DCSP DCSP where = &#91; ( &apos; id DCSP NOT DCSP IN DCSP &apos; + not _ queued ) &#93; DCNL DCSP elif running : DCNL DCSP DCSP where = &#91; ( &apos; ( id DCSP IN DCSP % s ) DCSP AND DCSP ( id DCSP IN DCSP % s ) &apos; % ( not _ queued , not _ finished ) ) &#93; DCNL DCSP elif finished : DCNL DCSP DCSP where = &#91; ( &apos; id DCSP NOT DCSP IN DCSP &apos; + not _ finished ) &#93; DCNL DCSP else : DCNL DCSP DCSP return { } DCNL DCSP return { &apos; where &apos; : where }
DCSP plugins _ whitelist = get _ setting ( &apos; plugins _ whitelist &apos; , &#91; &apos; external &apos; , &apos; getTeXRoot &apos; , &apos; latextools _ utils &apos; &#93; ) DCNL DCSP plugins _ whitelist.append ( &apos; latextools _ plugin &apos; ) DCNL DCSP overwritten _ modules = { } DCNL DCSP whitelist = &#91; ( name , None ) for name in plugins _ whitelist &#93; DCNL DCSP whitelist.extend ( internal . _ WHITELIST _ ADDED ) DCNL DCSP _ _ dir _ _ = os.path.dirname ( _ _ file _ _ ) DCNL DCSP if ( _ _ dir _ _ = = &apos; .&apos; ) : DCNL DCSP DCSP _ _ dir _ _ = os.path.join ( sublime.packages _ path ( ) , &apos; LaTeXTools &apos; ) DCNL DCSP sys.path.insert ( 0 , _ _ dir _ _ ) DCNL DCSP for ( name , module ) in whitelist : DCNL DCSP DCSP if callable ( module ) : DCNL DCSP DCSP DCSP module = module ( ) DCNL DCSP DCSP if ( name in sys.modules ) : DCNL DCSP DCSP DCSP overwritten _ modules &#91; name &#93; = sys.modules &#91; name &#93; DCNL DCSP DCSP if ( module is None ) : DCNL DCSP DCSP DCSP latextools _ module _ name = _ get _ sublime _ module _ name ( _ _ dir _ _ , name ) DCNL DCSP DCSP DCSP if ( latextools _ module _ name in sys.modules ) : DCNL DCSP DCSP DCSP DCSP sys.modules &#91; name &#93; = sys.modules &#91; latextools _ module _ name &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP sys.modules &#91; name &#93; = _ load _ module ( name , name , _ _ dir _ _ ) DCNL DCSP DCSP DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; An DCSP error DCSP occurred DCSP while DCSP trying DCSP to DCSP load DCSP white-listed DCSP module DCSP { 0 } &apos; .format ( name ) ) DCNL DCSP DCSP DCSP DCSP DCSP traceback.print _ exc ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP sys.modules &#91; name &#93; = module DCNL DCSP sys.path.pop ( 0 ) DCNL DCSP ( yield ) DCNL DCSP for module in plugins _ whitelist : DCNL DCSP DCSP if ( _ get _ sublime _ module _ name ( _ _ dir _ _ , module ) ! = module ) : DCNL DCSP DCSP DCSP del sys.modules &#91; module &#93; DCNL DCSP DCSP if ( module in overwritten _ modules ) : DCNL DCSP DCSP DCSP sys.modules &#91; module &#93; = overwritten _ modules &#91; module &#93;
DCSP return all ( ( not _ the _ same ( friend , other _ user ) for friend in user &#91; &apos; friends &apos; &#93; ) )
DCSP fileName = fabmetheus _ interpret.getFirstTranslatorFileNameUnmodified ( fileName ) DCNL DCSP if ( fileName ! = &apos; &apos; ) : DCNL DCSP DCSP skeinforge _ craft.writeChainTextWithNounMessage ( fileName , &apos; splodge &apos; )
DCSP module = AnsibleModule ( argument _ spec = dict ( name = dict ( type = &apos; str &apos; , required = True ) , new _ name = dict ( type = &apos; str &apos; ) , config = dict ( type = &apos; dict &apos; ) , description = dict ( type = &apos; str &apos; ) , devices = dict ( type = &apos; dict &apos; ) , state = dict ( choices = PROFILES _ STATES , default = &apos; present &apos; ) , url = dict ( type = &apos; str &apos; , default = &apos; unix : / var / lib / lxd / unix.socket &apos; ) , key _ file = dict ( type = &apos; str &apos; , default = &apos; { } / .config / lxc / client.key &apos; .format ( os.environ &#91; &apos; HOME &apos; &#93; ) ) , cert _ file = dict ( type = &apos; str &apos; , default = &apos; { } / .config / lxc / client.crt &apos; .format ( os.environ &#91; &apos; HOME &apos; &#93; ) ) , trust _ password = dict ( type = &apos; str &apos; ) ) , supports _ check _ mode = False ) DCNL DCSP lxd _ manage = LXDProfileManagement ( module = module ) DCNL DCSP lxd _ manage.run ( )
DCSP ring = f.ring DCNL DCSP k = ring.ngens DCNL DCSP yring = ring.clone ( symbols = ring.symbols &#91; ( k - 1 ) &#93; ) DCNL DCSP y = yring.gens &#91; 0 &#93; DCNL DCSP degf = _ deg ( f ) DCNL DCSP lcf = yring.zero DCNL DCSP for ( monom , coeff ) in f.iterterms ( ) : DCNL DCSP DCSP if ( monom &#91; : ( -1 ) &#93; = = degf ) : DCNL DCSP DCSP DCSP lcf + = ( coeff * ( y * * monom &#91; ( -1 ) &#93; ) ) DCNL DCSP return lcf
DCSP if ( _ MAIN _ SETTINGS is None ) : DCNL DCSP DCSP initialize _ dbs ( pelican _ obj.settings ) DCNL DCSP DCSP subscribe _ filter _ to _ signals ( pelican _ obj.settings )
DCSP logging.info ( &apos; Shutting DCSP down DCSP Cassandra . &apos; ) DCNL DCSP monit _ interface.stop ( cassandra _ interface.CASSANDRA _ MONIT _ WATCH _ NAME , is _ group = False ) DCNL DCSP logging.warning ( &apos; Done ! &apos; ) DCNL DCSP return True
DCSP for token in tokens : DCNL DCSP DCSP ( word , pos , lemma ) = ( token &#91; 0 &#93; , token &#91; 1 &#93; , token &#91; 0 &#93; ) DCNL DCSP DCSP if pos.startswith ( ( &apos; DT &apos; , ) ) : DCNL DCSP DCSP DCSP lemma = singularize ( word , pos = &apos; DT &apos; ) DCNL DCSP DCSP if pos.startswith ( &apos; JJ &apos; ) : DCNL DCSP DCSP DCSP lemma = predicative ( word ) DCNL DCSP DCSP if ( pos = = &apos; NNS &apos; ) : DCNL DCSP DCSP DCSP lemma = singularize ( word ) DCNL DCSP DCSP if pos.startswith ( ( &apos; VB &apos; , &apos; MD &apos; ) ) : DCNL DCSP DCSP DCSP lemma = ( conjugate ( word , INFINITIVE ) or word ) DCNL DCSP DCSP token.append ( lemma.lower ( ) ) DCNL DCSP return tokens
DCSP P = np.array ( &#91; &#91; 0.4 , 0.6 &#93; &#93; ) DCNL DCSP assert _ raises ( ValueError , MarkovChain , P ) DCNL DCSP assert _ raises ( ValueError , MarkovChain , sparse.csr _ matrix ( P ) )
DCSP if ( ( node.name in ( &apos; Exception &apos; , &apos; BaseException &apos; ) ) and ( node.root ( ) .name = = EXCEPTIONS _ MODULE ) ) : DCNL DCSP DCSP return True DCNL DCSP return any ( ( inherit _ from _ std _ ex ( parent ) for parent in node.ancestors ( recurs = False ) ) )
DCSP kw = { } DCNL DCSP argspec = inspect.getargspec ( fn ) DCNL DCSP if argspec &#91; 2 &#93; : DCNL DCSP DCSP kw = env DCNL DCSP else : DCNL DCSP DCSP argnames = argspec &#91; 0 &#93; &#91; 1 : &#93; DCNL DCSP DCSP for name in argnames : DCNL DCSP DCSP DCSP if ( name in env ) : DCNL DCSP DCSP DCSP DCSP kw &#91; name &#93; = env &#91; name &#93; DCNL DCSP return kw
DCSP try : DCNL DCSP DCSP is _ proxy = ( len ( parameter.Java.implements ) &gt; 0 ) DCNL DCSP except Exception : DCNL DCSP DCSP is _ proxy = False DCNL DCSP return is _ proxy
DCSP m = re.match ( u &apos; \ \ s * ( \ \ d + ) \ \ s * ( &#91; ac-z &#93; ? ) ( b ? ) \ \ s * $ &apos; , str ( si ) , re.I ) DCNL DCSP if m : DCNL DCSP DCSP if ( ( not m.group ( 2 ) ) and m.group ( 3 ) ) : DCNL DCSP DCSP DCSP times = 1 DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP times = ( const.SIPrefixTimes &#91; m.group ( 2 ) .upper ( ) &#93; if m.group ( 2 ) else 1 ) DCNL DCSP DCSP return ( int ( m.group ( 1 ) ) * times ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError
DCSP salt _ vars = get _ salt _ vars ( ) DCNL DCSP def salt _ outputter ( value ) : DCNL DCSP DCSP &quot; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Use DCSP Salt &apos;s DCSP outputters DCSP to DCSP print DCSP values DCSP to DCSP the DCSP shell \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &quot; DCNL DCSP DCSP if ( value is not None ) : DCNL DCSP DCSP DCSP builtins . _ = value DCNL DCSP DCSP DCSP salt.output.display _ output ( value , &apos; &apos; , salt _ vars &#91; &apos; _ _ opts _ _ &apos; &#93; ) DCNL DCSP sys.displayhook = salt _ outputter DCNL DCSP readline.set _ history _ length ( 300 ) DCNL DCSP if os.path.exists ( HISTFILE ) : DCNL DCSP DCSP readline.read _ history _ file ( HISTFILE ) DCNL DCSP atexit.register ( savehist ) DCNL DCSP atexit.register ( ( lambda : sys.stdout.write ( &apos; Salt DCSP you DCSP later ! \ n &apos; ) ) ) DCNL DCSP saltrepl = InteractiveConsole ( locals = salt _ vars ) DCNL DCSP saltrepl.interact ( banner = _ _ doc _ _ )
DCSP if ( nodes is None ) : DCNL DCSP DCSP nodes = set ( G ) DCNL DCSP else : DCNL DCSP DCSP nodes = set ( nodes ) DCNL DCSP xdeg = G.degree DCNL DCSP ydeg = G.degree DCNL DCSP if G.is _ directed ( ) : DCNL DCSP DCSP direction = { &apos; out &apos; : G.out _ degree , &apos; in &apos; : G.in _ degree } DCNL DCSP DCSP xdeg = direction &#91; x &#93; DCNL DCSP DCSP ydeg = direction &#91; y &#93; DCNL DCSP for ( u , degu ) in xdeg ( nodes , weight = weight ) : DCNL DCSP DCSP neighbors = ( nbr for ( _ , nbr ) in G.edges ( u ) if ( nbr in nodes ) ) DCNL DCSP DCSP for ( v , degv ) in ydeg ( neighbors , weight = weight ) : DCNL DCSP DCSP DCSP ( yield ( degu , degv ) )
DCSP if ( discovery _ info is None ) : DCNL DCSP DCSP _ LOGGER.error ( &apos; Configure DCSP Qwikswitch DCSP component &apos; ) DCNL DCSP DCSP return False DCNL DCSP add _ devices ( qwikswitch.QSUSB &#91; &apos; switch &apos; &#93; ) DCNL DCSP return True
DCSP asset _ dir _ prefix = &apos; &apos; DCNL DCSP if ( feconf.IS _ MINIFIED or ( not feconf.DEV _ MODE ) ) : DCNL DCSP DCSP cache _ slug = get _ cache _ slug ( ) DCNL DCSP DCSP asset _ dir _ prefix = ( &apos; / build / % s &apos; % cache _ slug ) DCNL DCSP return asset _ dir _ prefix
DCSP def wraps ( fn ) : DCNL DCSP DCSP dmm.register ( typecls , fn ) DCNL DCSP DCSP return fn DCNL DCSP return wraps
DCSP return linked _ data ( prefix ) .get ( dist )
DCSP dialect = migrate _ engine.url.get _ dialect ( ) DCNL DCSP if ( dialect is not postgresql.dialect ) : DCNL DCSP DCSP meta = MetaData ( bind = migrate _ engine ) DCNL DCSP DCSP for ( table , column ) in TABLE _ COLUMNS : DCNL DCSP DCSP DCSP t = Table ( table , meta , autoload = True ) DCNL DCSP DCSP DCSP getattr ( t.c , column ) .alter ( type = String ( 43 ) )
DCSP return re.sub ( &apos; ( &#91; \ \ s : &#93; ) ( 0 ) ( px &#124; em &#124; % &#124; in &#124; cm &#124; mm &#124; pc &#124; pt &#124; ex ) &apos; , &apos; \ \ 1 \ \ 2 &apos; , css )
DCSP return subproc _ check _ output ( &#91; &apos; svnlook &apos; , &apos; cat &apos; , repo _ path , &apos; -t &apos; , txn _ id , filename &#93; )
DCSP report _ class = REGISTRY.GetRegisteredPlugins ( ) &#91; name &#93; DCNL DCSP report _ object = report _ class ( ) DCNL DCSP return report _ object
DCSP if ( recurse _ count &gt; = 5 ) : DCNL DCSP DCSP err = &apos; save _ load DCSP could DCSP not DCSP write DCSP job DCSP cache DCSP file DCSP after DCSP { 0 } DCSP retries . &apos; .format ( recurse _ count ) DCNL DCSP DCSP log.error ( err ) DCNL DCSP DCSP raise salt.exceptions.SaltCacheError ( err ) DCNL DCSP jid _ dir = salt.utils.jid.jid _ dir ( jid , _ job _ dir ( ) , _ _ opts _ _ &#91; &apos; hash _ type &apos; &#93; ) DCNL DCSP serial = salt.payload.Serial ( _ _ opts _ _ ) DCNL DCSP try : DCNL DCSP DCSP if ( not os.path.exists ( jid _ dir ) ) : DCNL DCSP DCSP DCSP os.makedirs ( jid _ dir ) DCNL DCSP except OSError as exc : DCNL DCSP DCSP if ( exc.errno = = errno.EEXIST ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP try : DCNL DCSP DCSP serial.dump ( clear _ load , salt.utils.fopen ( os.path.join ( jid _ dir , LOAD _ P ) , &apos; w + b &apos; ) ) DCNL DCSP except IOError as exc : DCNL DCSP DCSP log.warning ( &apos; Could DCSP not DCSP write DCSP job DCSP invocation DCSP cache DCSP file : DCSP % s &apos; , exc ) DCNL DCSP DCSP time.sleep ( 0.1 ) DCNL DCSP DCSP return save _ load ( jid = jid , clear _ load = clear _ load , recurse _ count = ( recurse _ count + 1 ) ) DCNL DCSP if ( ( &apos; tgt &apos; in clear _ load ) and ( clear _ load &#91; &apos; tgt &apos; &#93; ! = &apos; &apos; ) ) : DCNL DCSP DCSP if ( minions is None ) : DCNL DCSP DCSP DCSP ckminions = salt.utils.minions.CkMinions ( _ _ opts _ _ ) DCNL DCSP DCSP DCSP minions = ckminions.check _ minions ( clear _ load &#91; &apos; tgt &apos; &#93; , clear _ load.get ( &apos; tgt _ type &apos; , &apos; glob &apos; ) ) DCNL DCSP DCSP save _ minions ( jid , minions )
DCSP if ( ( not user ) or user.is _ anonymous ( ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP user = User.objects.get ( username = service _ username ) DCNL DCSP DCSP except User.DoesNotExist : DCNL DCSP DCSP DCSP user = None DCNL DCSP return user
DCSP m = X.shape &#91; 0 &#93; DCNL DCSP min _ = np.zeros ( m ) DCNL DCSP for i in range ( m ) : DCNL DCSP DCSP for j in range ( ( 2 * m ) ) : DCNL DCSP DCSP DCSP if ( ( j = = i ) or ( j = = ( i + m ) ) ) : DCNL DCSP DCSP DCSP DCSP tableaux &#91; 0 &#93; &#91; ( i , j ) &#93; = 1 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tableaux &#91; 0 &#93; &#91; ( i , j ) &#93; = 0 DCNL DCSP DCSP tableaux &#91; 0 &#93; &#91; ( i , ( 2 * m ) ) &#93; = 1 DCNL DCSP for i in range ( m ) : DCNL DCSP DCSP for j in range ( m ) : DCNL DCSP DCSP DCSP if ( j = = i ) : DCNL DCSP DCSP DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , j ) &#93; = 1 DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , j ) &#93; = 0 DCNL DCSP DCSP for j in range ( m ) : DCNL DCSP DCSP DCSP d = ( X &#91; i &#93; - Y &#91; j &#93; ) DCNL DCSP DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , ( m + j ) ) &#93; = ( _ square _ sum ( d ) * ( -1 ) ) DCNL DCSP DCSP DCSP if ( tableaux &#91; 1 &#93; &#91; ( i , ( m + j ) ) &#93; &lt; min _ &#91; j &#93; ) : DCNL DCSP DCSP DCSP DCSP min _ &#91; j &#93; = tableaux &#91; 1 &#93; &#91; ( i , ( m + j ) ) &#93; DCNL DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , ( 2 * m ) ) &#93; = 1 DCNL DCSP for i in range ( m ) : DCNL DCSP DCSP for j in range ( m ) : DCNL DCSP DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , ( m + j ) ) &#93; - = min _ &#91; j &#93; DCNL DCSP DCSP DCSP tableaux &#91; 1 &#93; &#91; ( i , ( m + j ) ) &#93; + = 1 DCNL DCSP for ( pl , start ) in enumerate ( &#91; m , 0 &#93; ) : DCNL DCSP DCSP for i in range ( m ) : DCNL DCSP DCSP DCSP bases &#91; pl &#93; &#91; i &#93; = ( start + i ) DCNL DCSP return ( tableaux , bases )
DCSP assert _ nD ( image , 2 ) DCNL DCSP image = img _ as _ float ( image ) DCNL DCSP result = convolve ( image , VSOBEL _ WEIGHTS ) DCNL DCSP return _ mask _ filter _ result ( result , mask )
DCSP ( n _ samples , n _ features ) = X.shape DCNL DCSP ( n _ components , _ ) = means.shape DCNL DCSP log _ det = _ compute _ log _ det _ cholesky ( precisions _ chol , covariance _ type , n _ features ) DCNL DCSP if ( covariance _ type = = &apos; full &apos; ) : DCNL DCSP DCSP log _ prob = np.empty ( ( n _ samples , n _ components ) ) DCNL DCSP DCSP for ( k , ( mu , prec _ chol ) ) in enumerate ( zip ( means , precisions _ chol ) ) : DCNL DCSP DCSP DCSP y = ( np.dot ( X , prec _ chol ) - np.dot ( mu , prec _ chol ) ) DCNL DCSP DCSP DCSP log _ prob &#91; : , k &#93; = np.sum ( np.square ( y ) , axis = 1 ) DCNL DCSP elif ( covariance _ type = = &apos; tied &apos; ) : DCNL DCSP DCSP log _ prob = np.empty ( ( n _ samples , n _ components ) ) DCNL DCSP DCSP for ( k , mu ) in enumerate ( means ) : DCNL DCSP DCSP DCSP y = ( np.dot ( X , precisions _ chol ) - np.dot ( mu , precisions _ chol ) ) DCNL DCSP DCSP DCSP log _ prob &#91; : , k &#93; = np.sum ( np.square ( y ) , axis = 1 ) DCNL DCSP elif ( covariance _ type = = &apos; diag &apos; ) : DCNL DCSP DCSP precisions = ( precisions _ chol * * 2 ) DCNL DCSP DCSP log _ prob = ( ( np.sum ( ( ( means * * 2 ) * precisions ) , 1 ) - ( 2.0 * np.dot ( X , ( means * precisions ) .T ) ) ) + np.dot ( ( X * * 2 ) , precisions.T ) ) DCNL DCSP elif ( covariance _ type = = &apos; spherical &apos; ) : DCNL DCSP DCSP precisions = ( precisions _ chol * * 2 ) DCNL DCSP DCSP log _ prob = ( ( ( np.sum ( ( means * * 2 ) , 1 ) * precisions ) - ( 2 * np.dot ( X , ( means.T * precisions ) ) ) ) + np.outer ( row _ norms ( X , squared = True ) , precisions ) ) DCNL DCSP return ( ( ( -0.5 ) * ( ( n _ features * np.log ( ( 2 * np.pi ) ) ) + log _ prob ) ) + log _ det )
DCSP res = &#91; &#93; DCNL DCSP if isinstance ( ob , dict ) : DCNL DCSP DCSP role = ob.get ( &apos; role &apos; ) DCNL DCSP DCSP asset _ r = ob.get ( &apos; asset &apos; ) DCNL DCSP DCSP user = ob.get ( &apos; user &apos; ) DCNL DCSP DCSP if ( not perm ) : DCNL DCSP DCSP DCSP perm = get _ group _ user _ perm ( user ) DCNL DCSP DCSP if role : DCNL DCSP DCSP DCSP roles = perm.get ( &apos; role &apos; , { } ) .keys ( ) DCNL DCSP DCSP DCSP if ( role not in roles ) : DCNL DCSP DCSP DCSP DCSP return { } DCNL DCSP DCSP DCSP role _ assets _ all = perm.get ( &apos; role &apos; ) .get ( role ) .get ( &apos; asset &apos; ) DCNL DCSP DCSP DCSP assets = ( set ( role _ assets _ all ) &amp; set ( asset _ r ) ) DCNL DCSP DCSP DCSP for asset in assets : DCNL DCSP DCSP DCSP DCSP asset _ info = get _ asset _ info ( asset ) DCNL DCSP DCSP DCSP DCSP role _ key = get _ role _ key ( user , role ) DCNL DCSP DCSP DCSP DCSP info = { &apos; hostname &apos; : asset.hostname , &apos; ip &apos; : asset.ip , &apos; port &apos; : asset _ info.get ( &apos; port &apos; , 22 ) , &apos; ansible _ ssh _ private _ key _ file &apos; : role _ key , &apos; username &apos; : role.name } DCNL DCSP DCSP DCSP DCSP if os.path.isfile ( role _ key ) : DCNL DCSP DCSP DCSP DCSP DCSP info &#91; &apos; ssh _ key &apos; &#93; = role _ key DCNL DCSP DCSP DCSP DCSP res.append ( info ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for ( asset , asset _ info ) in perm.get ( &apos; asset &apos; ) .items ( ) : DCNL DCSP DCSP DCSP DCSP if ( asset not in asset _ r ) : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP asset _ info = get _ asset _ info ( asset ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP role = sorted ( list ( perm.get ( &apos; asset &apos; ) .get ( asset ) .get ( &apos; role &apos; ) ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP role _ key = get _ role _ key ( user , role ) DCNL DCSP DCSP DCSP DCSP info = { &apos; hostname &apos; : asset.hostname , &apos; ip &apos; : asset.ip , &apos; port &apos; : asset _ info.get ( &apos; port &apos; , 22 ) , &apos; username &apos; : role.name , &apos; password &apos; : CRYPTOR.decrypt ( role.password ) } DCNL DCSP DCSP DCSP DCSP if os.path.isfile ( role _ key ) : DCNL DCSP DCSP DCSP DCSP DCSP info &#91; &apos; ssh _ key &apos; &#93; = role _ key DCNL DCSP DCSP DCSP DCSP res.append ( info ) DCNL DCSP elif isinstance ( ob , User ) : DCNL DCSP DCSP if ( not perm ) : DCNL DCSP DCSP DCSP perm = get _ group _ user _ perm ( ob ) DCNL DCSP DCSP for ( asset , asset _ info ) in perm.get ( &apos; asset &apos; ) .items ( ) : DCNL DCSP DCSP DCSP asset _ info = get _ asset _ info ( asset ) DCNL DCSP DCSP DCSP info = { &apos; hostname &apos; : asset.hostname , &apos; ip &apos; : asset.ip , &apos; port &apos; : asset _ info.get ( &apos; port &apos; , 22 ) } DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP role = sorted ( list ( perm.get ( &apos; asset &apos; ) .get ( asset ) .get ( &apos; role &apos; ) ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP except IndexError : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP info &#91; &apos; username &apos; &#93; = role.name DCNL DCSP DCSP DCSP info &#91; &apos; password &apos; &#93; = CRYPTOR.decrypt ( role.password ) DCNL DCSP DCSP DCSP role _ key = get _ role _ key ( ob , role ) DCNL DCSP DCSP DCSP if os.path.isfile ( role _ key ) : DCNL DCSP DCSP DCSP DCSP info &#91; &apos; ssh _ key &apos; &#93; = role _ key DCNL DCSP DCSP DCSP res.append ( info ) DCNL DCSP elif isinstance ( ob , ( list , QuerySet ) ) : DCNL DCSP DCSP for asset in ob : DCNL DCSP DCSP DCSP info = get _ asset _ info ( asset ) DCNL DCSP DCSP DCSP res.append ( info ) DCNL DCSP logger.debug ( ( &apos; \ xe7 \ x94 \ x9f \ xe6 \ x88 \ x90res : DCSP % s &apos; % res ) ) DCNL DCSP return res
DCSP from frappe.model import default _ fields , optional _ fields DCNL DCSP if isinstance ( f , dict ) : DCNL DCSP DCSP ( key , value ) = f.items ( ) &#91; 0 &#93; DCNL DCSP DCSP f = make _ filter _ tuple ( doctype , key , value ) DCNL DCSP if ( not isinstance ( f , ( list , tuple ) ) ) : DCNL DCSP DCSP frappe.throw ( u &apos;Filter DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP ( in DCSP a DCSP list ) &apos; ) DCNL DCSP if ( len ( f ) = = 3 ) : DCNL DCSP DCSP f = ( doctype , f &#91; 0 &#93; , f &#91; 1 &#93; , f &#91; 2 &#93; ) DCNL DCSP elif ( len ( f ) ! = 4 ) : DCNL DCSP DCSP frappe.throw ( u &apos;Filter DCSP must DCSP have DCSP 4 DCSP values DCSP ( doctype , DCSP fieldname , DCSP operator , DCSP value ) : DCSP { 0 } &apos; .format ( str ( f ) ) ) DCNL DCSP f = frappe . _ dict ( doctype = f &#91; 0 &#93; , fieldname = f &#91; 1 &#93; , operator = f &#91; 2 &#93; , value = f &#91; 3 &#93; ) DCNL DCSP if ( not f.operator ) : DCNL DCSP DCSP f.operator = u &apos; = &apos; DCNL DCSP valid _ operators = ( u &apos; = &apos; , u &apos; ! = &apos; , u &apos; &gt; &apos; , u &apos; &lt; &apos; , u &apos; &gt; = &apos; , u &apos; &lt; = &apos; , u &apos;like &apos; , u &apos;not DCSP like &apos; , u &apos;in &apos; , u &apos;not DCSP in &apos; , u &apos;Between &apos; ) DCNL DCSP if ( f.operator not in valid _ operators ) : DCNL DCSP DCSP frappe.throw ( u &apos;Operator DCSP must DCSP be DCSP one DCSP of DCSP { 0 } &apos; .format ( u &apos; , DCSP &apos; .join ( valid _ operators ) ) ) DCNL DCSP if ( f.doctype and ( f.fieldname not in ( default _ fields + optional _ fields ) ) ) : DCNL DCSP DCSP meta = frappe.get _ meta ( f.doctype ) DCNL DCSP DCSP if ( not meta.has _ field ( f.fieldname ) ) : DCNL DCSP DCSP DCSP for df in meta.get _ table _ fields ( ) : DCNL DCSP DCSP DCSP DCSP if frappe.get _ meta ( df.options ) .has _ field ( f.fieldname ) : DCNL DCSP DCSP DCSP DCSP DCSP f.doctype = df.options DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP return f
DCSP return re.sub ( &apos; DCSP + &apos; , &apos; DCSP &apos; , normalize _ newlines ( text ) .replace ( &apos; \ n &apos; , &apos; &apos; ) ) .strip ( )
DCSP core = CORE _ MANAGER.get _ core _ service ( ) DCNL DCSP peer = core.peer _ manager.get _ by _ addr ( neigh _ ip _ address ) DCNL DCSP at _ maps _ key = const.ATTR _ MAPS _ LABEL _ DEFAULT DCNL DCSP if ( route _ dist is not None ) : DCNL DCSP DCSP at _ maps _ key = &apos; : &apos; .join ( &#91; route _ dist , route _ family &#93; ) DCNL DCSP at _ maps = peer.attribute _ maps.get ( at _ maps _ key ) DCNL DCSP if at _ maps : DCNL DCSP DCSP return at _ maps.get ( const.ATTR _ MAPS _ ORG _ KEY ) DCNL DCSP else : DCNL DCSP DCSP return &#91; &#93;
DCSP _ options = _ get _ options ( ret ) DCNL DCSP dsn = _ options.get ( &apos; dsn &apos; ) DCNL DCSP user = _ options.get ( &apos; user &apos; ) DCNL DCSP passwd = _ options.get ( &apos; passwd &apos; ) DCNL DCSP return pyodbc.connect ( &apos; DSN = { 0 } ; UID = { 1 } ; PWD = { 2 } &apos; .format ( dsn , user , passwd ) )
DCSP try : DCNL DCSP DCSP verify _ vat ( tax _ number ) DCNL DCSP DCSP return u &apos;vat &apos; DCNL DCSP except VatCannotIdentifyValidationError : DCNL DCSP DCSP pass DCNL DCSP return u &apos;unknown&apos;
DCSP fname = os.path.basename ( filename ) DCNL DCSP same _ name _ files = get _ same _ name _ files ( files _ path _ list , fname ) DCNL DCSP if ( len ( same _ name _ files ) &gt; 1 ) : DCNL DCSP DCSP compare _ path = shortest _ path ( same _ name _ files ) DCNL DCSP DCSP if ( compare _ path = = filename ) : DCNL DCSP DCSP DCSP same _ name _ files.remove ( path _ components ( filename ) ) DCNL DCSP DCSP DCSP compare _ path = shortest _ path ( same _ name _ files ) DCNL DCSP DCSP diff _ path = differentiate _ prefix ( path _ components ( filename ) , path _ components ( compare _ path ) ) DCNL DCSP DCSP diff _ path _ length = len ( diff _ path ) DCNL DCSP DCSP path _ component = path _ components ( diff _ path ) DCNL DCSP DCSP if ( ( diff _ path _ length &gt; 20 ) and ( len ( path _ component ) &gt; 2 ) ) : DCNL DCSP DCSP DCSP if ( ( path _ component &#91; 0 &#93; ! = &apos; / &apos; ) and ( path _ component &#91; 0 &#93; ! = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP path _ component = &#91; path _ component &#91; 0 &#93; , &apos; ... &apos; , path _ component &#91; ( -1 ) &#93; &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP path _ component = &#91; path _ component &#91; 2 &#93; , &apos; ... &apos; , path _ component &#91; ( -1 ) &#93; &#93; DCNL DCSP DCSP DCSP diff _ path = os.path.join ( * path _ component ) DCNL DCSP DCSP fname = ( ( fname + &apos; DCSP - DCSP &apos; ) + diff _ path ) DCNL DCSP return fname
DCSP ids = &#91; &#93; DCNL DCSP for ( column , operator , value ) in _ get _ query _ comparisons ( query ) : DCNL DCSP DCSP if column.shares _ lineage ( weather _ locations.c.continent ) : DCNL DCSP DCSP DCSP if ( operator = = operators.eq ) : DCNL DCSP DCSP DCSP DCSP ids.append ( shard _ lookup &#91; value &#93; ) DCNL DCSP DCSP DCSP elif ( operator = = operators.in _ op ) : DCNL DCSP DCSP DCSP DCSP ids.extend ( ( shard _ lookup &#91; v &#93; for v in value ) ) DCNL DCSP if ( len ( ids ) = = 0 ) : DCNL DCSP DCSP return &#91; &apos; north _ america &apos; , &apos; asia &apos; , &apos; europe &apos; , &apos; south _ america &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP return ids
DCSP if ( node.tail and ( node.tail.strip ( ) = = &apos; &apos; ) ) : DCNL DCSP DCSP node.tail = None DCNL DCSP for child in node : DCNL DCSP DCSP if ( node.text and ( node.text.strip ( ) = = &apos; &apos; ) ) : DCNL DCSP DCSP DCSP node.text = None DCNL DCSP DCSP remove _ ignorable _ whitespace ( child )
DCSP pkg _ list = &#91; pkg for pkg in pkg _ list if is _ installed ( pkg ) &#93; DCNL DCSP if pkg _ list : DCNL DCSP DCSP uninstall ( pkg _ list )
DCSP palettes = import _ required ( &apos; bokeh.palettes &apos; , _ BOKEH _ MISSING _ MSG ) DCNL DCSP tz = import _ required ( &apos; toolz &apos; , _ TOOLZ _ MISSING _ MSG ) DCNL DCSP unique _ funcs = list ( sorted ( tz.unique ( funcs ) ) ) DCNL DCSP n _ funcs = len ( unique _ funcs ) DCNL DCSP palette _ lookup = palettes.all _ palettes &#91; palette &#93; DCNL DCSP keys = list ( sorted ( palette _ lookup.keys ( ) ) ) DCNL DCSP index = keys &#91; min ( bisect _ left ( keys , n _ funcs ) , ( len ( keys ) - 1 ) ) &#93; DCNL DCSP palette = palette _ lookup &#91; index &#93; DCNL DCSP palette = list ( tz.unique ( palette ) ) DCNL DCSP if ( len ( palette ) &gt; n _ funcs ) : DCNL DCSP DCSP random.Random ( 42 ) .shuffle ( palette ) DCNL DCSP color _ lookup = dict ( zip ( unique _ funcs , cycle ( palette ) ) ) DCNL DCSP return &#91; color _ lookup &#91; n &#93; for n in funcs &#93;
DCSP return Locale.parse ( locale ) .time _ formats &#91; format &#93;
DCSP return _ interpret _ as _ from ( selectable ) .alias ( name = name , flat = flat )
DCSP buf = buf.strip ( ) DCNL DCSP if ( not buf ) : DCNL DCSP DCSP return buf DCNL DCSP html _ parser = html5lib.HTMLParser ( tree = treebuilders.getTreeBuilder ( &apos; dom &apos; ) , tokenizer = HTMLSanitizer ) DCNL DCSP dom _ tree = html _ parser.parseFragment ( buf ) DCNL DCSP walker = treewalkers.getTreeWalker ( &apos; dom &apos; ) DCNL DCSP stream = walker ( dom _ tree ) DCNL DCSP s = serializer.htmlserializer.HTMLSerializer ( omit _ optional _ tags = False , quote _ attr _ values = True ) DCNL DCSP output = s.render ( stream , &apos; utf-8 &apos; ) DCNL DCSP while ( &apos; toberemoved &apos; in output ) : DCNL DCSP DCSP oldoutput = output DCNL DCSP DCSP matches = re.findall ( &apos; &amp; lt ; toberemoved . * ? &amp; gt ; . * ? &amp; lt ; / toberemoved &amp; gt ; &apos; , output , re.DOTALL ) DCNL DCSP DCSP for s in matches : DCNL DCSP DCSP DCSP output = output.replace ( s , &apos; &apos; ) DCNL DCSP DCSP matches = re.findall ( &apos; &amp; lt ; / toberemoved &amp; gt ; &apos; , output , re.DOTALL ) DCNL DCSP DCSP for s in matches : DCNL DCSP DCSP DCSP output = output.replace ( s , &apos; &apos; ) DCNL DCSP DCSP matches = re.findall ( &apos; &amp; lt ; toberemoved . * ? &amp; gt ; &apos; , output , re.DOTALL ) DCNL DCSP DCSP for s in matches : DCNL DCSP DCSP DCSP output = output.replace ( s , &apos; &apos; ) DCNL DCSP DCSP if ( output = = oldoutput ) : DCNL DCSP DCSP DCSP break DCNL DCSP return output
DCSP try : DCNL DCSP DCSP getReadRepository ( repository ) DCNL DCSP DCSP return RepositoryDialog ( repository , Tkinter.Tk ( ) ) DCNL DCSP except : DCNL DCSP DCSP print &apos; this DCSP should DCSP never DCSP happen , DCSP getDisplayedDialogFromConstructor DCSP in DCSP settings DCSP could DCSP not DCSP open &apos; DCNL DCSP DCSP print repository DCNL DCSP DCSP traceback.print _ exc ( file = sys.stdout ) DCNL DCSP DCSP return None
DCSP if ( not settings.DEBUG ) : DCNL DCSP DCSP raise RuntimeError ( &quot; Don &apos;t DCSP use DCSP kitsune.sumo.views.serve _ cors DCSP in DCSP production . &quot; ) DCNL DCSP from django.views.static import serve DCNL DCSP return serve ( * args , * * kwargs )
DCSP return str ( round ( number , 3 ) )
DCSP if ( not backup _ retention _ period ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; backup _ retention _ period DCSP is DCSP required &apos; ) DCNL DCSP res = _ _ salt _ _ &#91; &apos; boto _ rds.exists &apos; &#93; ( source _ name , tags , region , key , keyid , profile ) DCNL DCSP if ( not res.get ( &apos; exists &apos; ) ) : DCNL DCSP DCSP return { &apos; exists &apos; : bool ( res ) , &apos; message &apos; : &apos; RDS DCSP instance DCSP source DCSP { 0 } DCSP does DCSP not DCSP exists . &apos; .format ( source _ name ) } DCNL DCSP res = _ _ salt _ _ &#91; &apos; boto _ rds.exists &apos; &#93; ( name , tags , region , key , keyid , profile ) DCNL DCSP if res.get ( &apos; exists &apos; ) : DCNL DCSP DCSP return { &apos; exists &apos; : bool ( res ) , &apos; message &apos; : &apos; RDS DCSP replica DCSP instance DCSP { 0 } DCSP already DCSP exists . &apos; .format ( name ) } DCNL DCSP try : DCNL DCSP DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP kwargs = { } DCNL DCSP DCSP for key in ( &apos; OptionGroupName &apos; , &apos; MonitoringRoleArn &apos; ) : DCNL DCSP DCSP DCSP if ( locals ( ) &#91; key &#93; is not None ) : DCNL DCSP DCSP DCSP DCSP kwargs &#91; key &#93; = str ( locals ( ) &#91; key &#93; ) DCNL DCSP DCSP for key in ( &apos; MonitoringInterval &apos; , &apos; Iops &apos; , &apos; Port &apos; ) : DCNL DCSP DCSP DCSP if ( locals ( ) &#91; key &#93; is not None ) : DCNL DCSP DCSP DCSP DCSP kwargs &#91; key &#93; = int ( locals ( ) &#91; key &#93; ) DCNL DCSP DCSP for key in ( &apos; CopyTagsToSnapshot &apos; , &apos; AutoMinorVersionUpgrade &apos; ) : DCNL DCSP DCSP DCSP if ( locals ( ) &#91; key &#93; is not None ) : DCNL DCSP DCSP DCSP DCSP kwargs &#91; key &#93; = bool ( locals ( ) &#91; key &#93; ) DCNL DCSP DCSP taglist = _ tag _ doc ( tags ) DCNL DCSP DCSP rds _ replica = conn.create _ db _ instance _ read _ replica ( DBInstanceIdentifier = name , SourceDBInstanceIdentifier = source _ name , DBInstanceClass = db _ instance _ class , AvailabilityZone = availability _ zone , PubliclyAccessible = publicly _ accessible , Tags = taglist , DBSubnetGroupName = db _ subnet _ group _ name , StorageType = storage _ type , * * kwargs ) DCNL DCSP DCSP return { &apos; exists &apos; : bool ( rds _ replica ) } DCNL DCSP except ClientError as e : DCNL DCSP DCSP return { &apos; error &apos; : salt.utils.boto3.get _ error ( e ) }
DCSP from mozillians.groups.models import Group , GroupMembership DCNL DCSP group = Group.objects.get ( pk = group _ pk ) DCNL DCSP user = User.objects.get ( pk = user _ pk ) DCNL DCSP activate ( &apos; en-us &apos; ) DCNL DCSP if ( old _ status in &#91; GroupMembership.PENDING , GroupMembership.PENDING _ TERMS &#93; ) : DCNL DCSP DCSP if ( new _ status = = GroupMembership.MEMBER ) : DCNL DCSP DCSP DCSP subject = ( _ ( &apos; Accepted DCSP to DCSP Mozillians DCSP group DCSP &quot; % s &quot; &apos; ) % group.name ) DCNL DCSP DCSP DCSP template _ name = &apos; groups / email / accepted.txt &apos; DCNL DCSP DCSP elif ( new _ status is None ) : DCNL DCSP DCSP DCSP subject = ( _ ( &apos; Not DCSP accepted DCSP to DCSP Mozillians DCSP group DCSP &quot; % s &quot; &apos; ) % group.name ) DCNL DCSP DCSP DCSP template _ name = &apos; groups / email / rejected.txt &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( &apos; BAD DCSP ARGS DCSP TO DCSP email _ membership _ change &apos; ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; BAD DCSP ARGS DCSP TO DCSP email _ membership _ change &apos; ) DCNL DCSP context = { &apos; group &apos; : group , &apos; user &apos; : user } DCNL DCSP template = get _ template ( template _ name ) DCNL DCSP body = template.render ( context ) DCNL DCSP send _ mail ( subject , body , settings.FROM _ NOREPLY , &#91; user.email &#93; , fail _ silently = False )
DCSP if ( n is None ) : DCNL DCSP DCSP n = 4 DCNL DCSP if ( ( len ( alphabet ) * * n ) &lt; length ) : DCNL DCSP DCSP log.error ( ( &quot; Can &apos;t DCSP create DCSP a DCSP pattern DCSP length = % i DCSP with DCSP len ( alphabet ) = = % i DCSP and DCSP n = = % i &quot; % ( length , len ( alphabet ) , n ) ) ) DCNL DCSP out = &#91; &#93; DCNL DCSP for ( ndx , c ) in enumerate ( de _ bruijn ( alphabet , n ) ) : DCNL DCSP DCSP if ( ( length ! = None ) and ( ndx &gt; = length ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP out.append ( c ) DCNL DCSP if isinstance ( alphabet , str ) : DCNL DCSP DCSP return &apos; &apos;.join ( out ) DCNL DCSP else : DCNL DCSP DCSP return out
DCSP images = &#91; ImageMetadata ( image.image _ id , image.filename , &#91; caption &#93; ) for image in images for caption in image.captions &#93; DCNL DCSP random.seed ( 12345 ) DCNL DCSP random.shuffle ( images ) DCNL DCSP num _ threads = min ( num _ shards , FLAGS.num _ threads ) DCNL DCSP spacing = np.linspace ( 0 , len ( images ) , ( num _ threads + 1 ) ) .astype ( np.int ) DCNL DCSP ranges = &#91; &#93; DCNL DCSP threads = &#91; &#93; DCNL DCSP for i in xrange ( ( len ( spacing ) - 1 ) ) : DCNL DCSP DCSP ranges.append ( &#91; spacing &#91; i &#93; , spacing &#91; ( i + 1 ) &#93; &#93; ) DCNL DCSP coord = tf.train.Coordinator ( ) DCNL DCSP decoder = ImageDecoder ( ) DCNL DCSP print ( ( &apos; Launching DCSP % d DCSP threads DCSP for DCSP spacings : DCSP % s &apos; % ( num _ threads , ranges ) ) ) DCNL DCSP for thread _ index in xrange ( len ( ranges ) ) : DCNL DCSP DCSP args = ( thread _ index , ranges , name , images , decoder , vocab , num _ shards ) DCNL DCSP DCSP t = threading.Thread ( target = _ process _ image _ files , args = args ) DCNL DCSP DCSP t.start ( ) DCNL DCSP DCSP threads.append ( t ) DCNL DCSP coord.join ( threads ) DCNL DCSP print ( ( &quot; % s : DCSP Finished DCSP processing DCSP all DCSP % d DCSP image-caption DCSP pairs DCSP in DCSP data DCSP set DCSP &apos; % s &apos; . &quot; % ( datetime.now ( ) , len ( images ) , name ) ) )
DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP policy _ arn = _ get _ policy _ arn ( policy _ name , region , key , keyid , profile ) DCNL DCSP try : DCNL DCSP DCSP conn.detach _ user _ policy ( policy _ arn , user _ name ) DCNL DCSP DCSP log.info ( &apos; Detached DCSP { 0 } DCSP policy DCSP to DCSP user DCSP { 1 } . &apos; .format ( policy _ name , user _ name ) ) DCNL DCSP except boto.exception.BotoServerError as e : DCNL DCSP DCSP log.debug ( e ) DCNL DCSP DCSP msg = &apos; Failed DCSP to DCSP detach DCSP { 0 } DCSP policy DCSP to DCSP user DCSP { 1 } . &apos; DCNL DCSP DCSP log.error ( msg.format ( policy _ name , user _ name ) ) DCNL DCSP DCSP return False DCNL DCSP return True
DCSP ret = &#91; &#93; DCNL DCSP devices = bluetooth.discover _ devices ( lookup _ names = True ) DCNL DCSP for device in devices : DCNL DCSP DCSP ret.append ( { device &#91; 0 &#93; : device &#91; 1 &#93; } ) DCNL DCSP return ret
DCSP from castra import Castra DCNL DCSP if ( not isinstance ( x , Castra ) ) : DCNL DCSP DCSP x = Castra ( x , readonly = True ) DCNL DCSP elif ( not x . _ readonly ) : DCNL DCSP DCSP x = Castra ( x.path , readonly = True ) DCNL DCSP if ( columns is None ) : DCNL DCSP DCSP columns = x.columns DCNL DCSP name = ( &apos; from-castra- &apos; + tokenize ( os.path.getmtime ( x.path ) , x.path , columns , index ) ) DCNL DCSP dsk = dict ( ( ( ( name , i ) , ( load _ castra _ partition , x , part , columns , index ) ) for ( i , part ) in enumerate ( x.partitions ) ) ) DCNL DCSP return Bag ( dsk , name , len ( x.partitions ) )
DCSP warnings.warn ( &quot; The DCSP &apos; execute _ manager &apos; DCSP function DCSP is DCSP deprecated , DCSP you DCSP likely DCSP need DCSP to DCSP update DCSP your DCSP &apos; manage.py &apos; ; DCSP please DCSP see DCSP the DCSP Django DCSP 1.4 DCSP release DCSP notes DCSP ( https : / / docs.djangoproject.com / en / dev / releases / 1.4 / ) . &quot; , PendingDeprecationWarning ) DCNL DCSP setup _ environ ( settings _ mod ) DCNL DCSP utility = ManagementUtility ( argv ) DCNL DCSP utility.execute ( )
DCSP if ( field.label = = _ FieldDescriptor.LABEL _ REPEATED ) : DCNL DCSP DCSP if ( field.has _ default _ value and ( field.default _ value ! = &#91; &#93; ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Repeated DCSP field DCSP default DCSP value DCSP not DCSP empty DCSP list : DCSP % s &apos; % field.default _ value ) ) DCNL DCSP DCSP if ( field.cpp _ type = = _ FieldDescriptor.CPPTYPE _ MESSAGE ) : DCNL DCSP DCSP DCSP message _ type = field.message _ type DCNL DCSP DCSP DCSP def MakeRepeatedMessageDefault ( message ) : DCNL DCSP DCSP DCSP DCSP return containers.RepeatedCompositeFieldContainer ( message . _ listener _ for _ children , field.message _ type ) DCNL DCSP DCSP DCSP return MakeRepeatedMessageDefault DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP type _ checker = type _ checkers.GetTypeChecker ( field ) DCNL DCSP DCSP DCSP def MakeRepeatedScalarDefault ( message ) : DCNL DCSP DCSP DCSP DCSP return containers.RepeatedScalarFieldContainer ( message . _ listener _ for _ children , type _ checker ) DCNL DCSP DCSP DCSP return MakeRepeatedScalarDefault DCNL DCSP if ( field.cpp _ type = = _ FieldDescriptor.CPPTYPE _ MESSAGE ) : DCNL DCSP DCSP message _ type = field.message _ type DCNL DCSP DCSP def MakeSubMessageDefault ( message ) : DCNL DCSP DCSP DCSP result = message _ type . _ concrete _ class ( ) DCNL DCSP DCSP DCSP result . _ SetListener ( message . _ listener _ for _ children ) DCNL DCSP DCSP DCSP return result DCNL DCSP DCSP return MakeSubMessageDefault DCNL DCSP def MakeScalarDefault ( message ) : DCNL DCSP DCSP return field.default _ value DCNL DCSP return MakeScalarDefault
DCSP canvas = FigureCanvasWebAgg ( figure ) DCNL DCSP manager = core.FigureManagerWebAgg ( canvas , num ) DCNL DCSP return manager
DCSP G = complete _ graph ( 4 , create _ using ) DCNL DCSP G.name = &apos; Platonic DCSP Tetrahedral DCSP graph &apos; DCNL DCSP return G
DCSP ( _ , filename , _ , _ , _ , _ ) = inspect.getouterframes ( inspect.currentframe ( ) ) &#91; 1 &#93; DCNL DCSP base _ dir = os.path.abspath ( os.path.dirname ( filename ) ) DCNL DCSP return os.path.join ( base _ dir , &apos; data &apos; , f )
DCSP a = TpPd ( pd = 3 ) DCNL DCSP b = MessageType ( mesType = 52 ) DCNL DCSP packet = ( a / b ) DCNL DCSP return packet
DCSP return translateMessage ( key , message , &apos; encrypt &apos; )
DCSP return _ sys _ version ( ) &#91; 1 &#93;
DCSP if verbose : DCNL DCSP DCSP factors0 = list ( factors.keys ( ) ) DCNL DCSP nfactors = len ( factors ) DCNL DCSP for d in candidates : DCNL DCSP DCSP if ( ( n % d ) = = 0 ) : DCNL DCSP DCSP DCSP m = multiplicity ( d , n ) DCNL DCSP DCSP DCSP n / / = ( d * * m ) DCNL DCSP DCSP DCSP factors &#91; d &#93; = m DCNL DCSP if verbose : DCNL DCSP DCSP for k in sorted ( set ( factors ) .difference ( set ( factors0 ) ) ) : DCNL DCSP DCSP DCSP print ( ( factor _ msg % ( k , factors &#91; k &#93; ) ) ) DCNL DCSP return ( int ( n ) , ( len ( factors ) ! = nfactors ) )
DCSP skip = set ( ( token.NEWLINE , token.INDENT , token.DEDENT ) ) DCNL DCSP tokens = tokenize.generate _ tokens ( StringIO.StringIO ( input ) .readline ) DCNL DCSP for quintuple in tokens : DCNL DCSP DCSP ( type , value , start , end , line _ text ) = quintuple DCNL DCSP DCSP if ( type not in skip ) : DCNL DCSP DCSP DCSP ( yield quintuple )
DCSP setup _ autoscale _ group ( ) DCNL DCSP conn = boto.connect _ autoscale ( ) DCNL DCSP policy = ScalingPolicy ( name = u &apos;ScaleUp &apos; , adjustment _ type = u &apos;PercentChangeInCapacity &apos; , as _ name = u &apos;tester _ group &apos; , scaling _ adjustment = 1 ) DCNL DCSP conn.create _ scaling _ policy ( policy ) DCNL DCSP conn.execute _ policy ( u &apos;ScaleUp &apos; ) DCNL DCSP instances = list ( conn.get _ all _ autoscaling _ instances ( ) ) DCNL DCSP instances.should.have.length _ of ( 3 )
DCSP if ( transform and hasattr ( self.model , &apos; formula &apos; ) and ( exog is not None ) ) : DCNL DCSP DCSP from patsy import dmatrix DCNL DCSP DCSP exog = dmatrix ( self.model.data.design _ info.builder , exog ) DCNL DCSP if ( exog is not None ) : DCNL DCSP DCSP if ( row _ labels is None ) : DCNL DCSP DCSP DCSP if hasattr ( exog , &apos; index &apos; ) : DCNL DCSP DCSP DCSP DCSP row _ labels = exog.index DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP row _ labels = None DCNL DCSP DCSP exog = np.asarray ( exog ) DCNL DCSP DCSP if ( ( exog.ndim = = 1 ) and ( ( self.model.exog.ndim = = 1 ) or ( self.model.exog.shape &#91; 1 &#93; = = 1 ) ) ) : DCNL DCSP DCSP DCSP exog = exog &#91; : , None &#93; DCNL DCSP DCSP exog = np.atleast _ 2d ( exog ) DCNL DCSP else : DCNL DCSP DCSP exog = self.model.exog DCNL DCSP DCSP if ( weights is None ) : DCNL DCSP DCSP DCSP weights = getattr ( self.model , &apos; weights &apos; , None ) DCNL DCSP DCSP if ( row _ labels is None ) : DCNL DCSP DCSP DCSP row _ labels = getattr ( self.model.data , &apos; row _ labels &apos; , None ) DCNL DCSP if ( weights is not None ) : DCNL DCSP DCSP weights = np.asarray ( weights ) DCNL DCSP DCSP if ( ( weights.size &gt; 1 ) and ( ( weights.ndim ! = 1 ) or ( weights.shape &#91; 0 &#93; = = exog.shape &#91; 1 &#93; ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; weights DCSP has DCSP wrong DCSP shape &apos; ) DCNL DCSP if ( pred _ kwds is None ) : DCNL DCSP DCSP pred _ kwds = { } DCNL DCSP predicted _ mean = self.model.predict ( self.params , exog , * * pred _ kwds ) DCNL DCSP covb = self.cov _ params ( ) DCNL DCSP var _ pred _ mean = ( exog * np.dot ( covb , exog.T ) .T ) .sum ( 1 ) DCNL DCSP var _ resid = ( self.scale / weights ) DCNL DCSP if ( self.cov _ type = = &apos; fixed DCSP scale &apos; ) : DCNL DCSP DCSP var _ resid = ( self.cov _ kwds &#91; &apos; scale &apos; &#93; / weights ) DCNL DCSP dist = &#91; &apos; norm &apos; , &apos; t &apos; &#93; &#91; self.use _ t &#93; DCNL DCSP return PredictionResults ( predicted _ mean , var _ pred _ mean , var _ resid , df = self.df _ resid , dist = dist , row _ labels = row _ labels )
DCSP url = &apos; https : / / www.googleapis.com / storage / v1 / b / { 0 } / o &apos; .format ( bucket _ name ) DCNL DCSP try : DCNL DCSP DCSP response = gcs _ get _ request ( url ) DCNL DCSP DCSP if ( response.status _ code ! = HTTP _ OK ) : DCNL DCSP DCSP DCSP logging.error ( &apos; Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket : DCSP { 0 } . DCSP Error : DCSP { 1 } &apos; .format ( bucket _ name , response.status _ code ) ) DCNL DCSP DCSP DCSP return &#91; &#93; DCNL DCSP DCSP content = json.loads ( response.content ) DCNL DCSP except requests.HTTPError as error : DCNL DCSP DCSP logging.error ( &apos; Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket : DCSP { 0 } . DCSP Error : DCSP { 1 } &apos; .format ( bucket _ name , error ) ) DCNL DCSP DCSP return &#91; &#93; DCNL DCSP if ( &apos; items &apos; not in content.keys ( ) ) : DCNL DCSP DCSP return &#91; &#93; DCNL DCSP objects = &#91; &#93; DCNL DCSP for item in content &#91; &apos; items &apos; &#93; : DCNL DCSP DCSP objects.append ( item &#91; &apos; name &apos; &#93; ) DCNL DCSP logging.debug ( &apos; Bucket DCSP contents : DCSP { 0 } &apos; .format ( objects ) ) DCNL DCSP return objects
DCSP return ( ( obj ! = other ) or ( type ( obj ) ! = type ( other ) ) )
DCSP enable _ site ( config ) DCNL DCSP reload _ service ( &apos; apache2 &apos; )
DCSP return read _ edgelist ( path , comments = comments , delimiter = delimiter , create _ using = create _ using , nodetype = nodetype , data = ( ( &apos; weight &apos; , float ) , ) , encoding = encoding )
DCSP j = from _ int ( j ) DCNL DCSP pi = mpf _ pi ( prec ) DCNL DCSP a = mpf _ div ( sq23pi , j , prec ) DCNL DCSP b = mpf _ sub ( from _ int ( n ) , from _ rational ( 1 , 24 , prec ) , prec ) DCNL DCSP c = mpf _ sqrt ( b , prec ) DCNL DCSP ( ch , sh ) = mpf _ cosh _ sinh ( mpf _ mul ( a , c ) , prec ) DCNL DCSP D = mpf _ div ( mpf _ sqrt ( j , prec ) , mpf _ mul ( mpf _ mul ( sqrt8 , b ) , pi ) , prec ) DCNL DCSP E = mpf _ sub ( mpf _ mul ( a , ch ) , mpf _ div ( sh , c , prec ) , prec ) DCNL DCSP return mpf _ mul ( D , E )
DCSP t.value = ( t.value = = &apos; true &apos; ) DCNL DCSP return t
DCSP filename = string _ cam _ file.get ( ) DCNL DCSP file = open ( filename , &apos; wb &apos; ) DCNL DCSP units = cad.inches _ per _ unit DCNL DCSP file.write ( &apos; % FSLAX24Y24 * % \ n &apos; ) DCNL DCSP file.write ( &apos; % MOIN * % \ n &apos; ) DCNL DCSP file.write ( &apos; % OFA0B0 * % \ n &apos; ) DCNL DCSP ixs = cad.x &#91; : : 2 &#93; DCNL DCSP xs = ( cad.xmin + ( ( ( cad.xmax - cad.xmin ) * ( ixs + 0.5 ) ) / float ( cad.nx ) ) ) DCNL DCSP ixe = cad.x &#91; 1 : : 2 &#93; DCNL DCSP xe = ( cad.xmin + ( ( ( cad.xmax - cad.xmin ) * ( ixe + 0.5 ) ) / float ( cad.nx ) ) ) DCNL DCSP idx = ( ixe - ixs ) DCNL DCSP dx = ( xe - xs ) DCNL DCSP iys = cad.y &#91; : : 2 &#93; DCNL DCSP ys = ( cad.ymin + ( ( ( cad.ymax - cad.ymin ) * ( iys + 0.5 ) ) / float ( cad.ny ) ) ) DCNL DCSP iye = cad.y &#91; 1 : : 2 &#93; DCNL DCSP ye = ( cad.ymin + ( ( ( cad.ymax - cad.ymin ) * ( iye + 0.5 ) ) / float ( cad.ny ) ) ) DCNL DCSP idy = ( iye - iys ) DCNL DCSP dy = ( ye - ys ) DCNL DCSP mins = where ( ( idx &lt; idy ) , idx , idy ) DCNL DCSP uniques = unique ( mins ) DCNL DCSP apertures = ( ( ( cad.xmax - cad.xmin ) * uniques ) / float ( cad.nx ) ) DCNL DCSP index = searchsorted ( uniques , mins ) DCNL DCSP for i in range ( len ( uniques ) ) : DCNL DCSP DCSP file.write ( ( &apos; % % ADD % dR , % .4fX % .4f * % % \ n &apos; % ( ( i + 10 ) , apertures &#91; i &#93; , apertures &#91; i &#93; ) ) ) DCNL DCSP coords = arange ( len ( mins ) ) DCNL DCSP for i in range ( len ( uniques ) ) : DCNL DCSP DCSP file.write ( ( &apos; D % d * \ n &apos; % ( i + 10 ) ) ) DCNL DCSP DCSP coord = coords &#91; ( index = = i ) &#93; DCNL DCSP DCSP delta = ( apertures &#91; i &#93; / 2.0 ) DCNL DCSP DCSP ixs = ( 10000 * ( xs + delta ) ) .astype ( int32 ) DCNL DCSP DCSP ixe = ( 10000 * ( xe - delta ) ) .astype ( int32 ) DCNL DCSP DCSP iys = ( 10000 * ( ys + delta ) ) .astype ( int32 ) DCNL DCSP DCSP iye = ( 10000 * ( ye - delta ) ) .astype ( int32 ) DCNL DCSP DCSP for j in range ( len ( coord ) ) : DCNL DCSP DCSP DCSP n = coord &#91; j &#93; DCNL DCSP DCSP DCSP if ( idx &#91; n &#93; = = idy &#91; n &#93; ) : DCNL DCSP DCSP DCSP DCSP file.write ( ( &apos; X % dY % dD03 * \ n &apos; % ( ixs &#91; n &#93; , iys &#91; n &#93; ) ) ) DCNL DCSP DCSP DCSP elif ( idx &#91; n &#93; &gt; idy &#91; n &#93; ) : DCNL DCSP DCSP DCSP DCSP file.write ( ( &apos; X % dY % dD02 * \ n &apos; % ( ixs &#91; n &#93; , iys &#91; n &#93; ) ) ) DCNL DCSP DCSP DCSP DCSP file.write ( ( &apos; X % dY % dD01 * \ n &apos; % ( ixe &#91; n &#93; , iys &#91; n &#93; ) ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP file.write ( ( &apos; X % dY % dD02 * \ n &apos; % ( ixs &#91; n &#93; , iys &#91; n &#93; ) ) ) DCNL DCSP DCSP DCSP DCSP file.write ( ( &apos; X % dY % dD01 * \ n &apos; % ( ixs &#91; n &#93; , iye &#91; n &#93; ) ) ) DCNL DCSP file.write ( &apos; M02 * \ n &apos; ) DCNL DCSP file.close ( ) DCNL DCSP string _ msg.set ( ( &apos; wrote DCSP % s DCSP ( RS-274X ) &apos; % filename ) ) DCNL DCSP root.update ( )
DCSP X = np.asarray ( X ) DCNL DCSP if ( ( len ( X.shape ) = = 2 ) and ( X.shape &#91; 1 &#93; = = 1 ) ) : DCNL DCSP DCSP if ( not assume _ centered ) : DCNL DCSP DCSP DCSP X = ( X - X.mean ( ) ) DCNL DCSP DCSP return ( np.atleast _ 2d ( ( X * * 2 ) .mean ( ) ) , 0.0 ) DCNL DCSP if ( X.ndim = = 1 ) : DCNL DCSP DCSP X = np.reshape ( X , ( 1 , ( -1 ) ) ) DCNL DCSP DCSP warnings.warn ( &apos; Only DCSP one DCSP sample DCSP available . DCSP You DCSP may DCSP want DCSP to DCSP reshape DCSP your DCSP data DCSP array &apos; ) DCNL DCSP DCSP n _ samples = 1 DCNL DCSP DCSP n _ features = X.size DCNL DCSP else : DCNL DCSP DCSP ( n _ samples , n _ features ) = X.shape DCNL DCSP emp _ cov = empirical _ covariance ( X , assume _ centered = assume _ centered ) DCNL DCSP mu = ( np.trace ( emp _ cov ) / n _ features ) DCNL DCSP alpha = np.mean ( ( emp _ cov * * 2 ) ) DCNL DCSP num = ( alpha + ( mu * * 2 ) ) DCNL DCSP den = ( ( n _ samples + 1.0 ) * ( alpha - ( ( mu * * 2 ) / n _ features ) ) ) DCNL DCSP shrinkage = ( 1.0 if ( den = = 0 ) else min ( ( num / den ) , 1.0 ) ) DCNL DCSP shrunk _ cov = ( ( 1.0 - shrinkage ) * emp _ cov ) DCNL DCSP shrunk _ cov.flat &#91; : : ( n _ features + 1 ) &#93; + = ( shrinkage * mu ) DCNL DCSP return ( shrunk _ cov , shrinkage )
DCSP site _ mod _ dir = os.path.dirname ( os.path.abspath ( site . _ _ file _ _ ) ) DCNL DCSP no _ global _ file = os.path.join ( site _ mod _ dir , &apos; no-global-site-packages.txt &apos; ) DCNL DCSP if ( running _ under _ virtualenv ( ) and os.path.isfile ( no _ global _ file ) ) : DCNL DCSP DCSP return True
DCSP if ( data is None ) : DCNL DCSP DCSP return &apos; 0000 &apos; DCNL DCSP return ( ( &apos; % 04x &apos; % ( len ( data ) + 4 ) ) .encode ( &apos; ascii &apos; ) + data )
DCSP _ _ tracebackhide _ _ = True DCNL DCSP try : DCNL DCSP DCSP run ( * args , * * kwargs ) DCNL DCSP DCSP assert False , ( &apos; % s DCSP should DCSP have DCSP been DCSP thrown &apos; % exception ) DCNL DCSP except exception : DCNL DCSP DCSP e = sys.exc _ info ( ) &#91; 1 &#93; DCNL DCSP DCSP p = re.compile ( reg ) DCNL DCSP DCSP assert p.search ( str ( e ) ) , str ( e )
DCSP conn = get _ conn ( ) DCNL DCSP return conn.network _ list ( )
DCSP import inbox.actions.backends DCNL DCSP for backend in inbox.actions.backends.module _ registry.values ( ) : DCNL DCSP DCSP for method _ name in backend . _ _ all _ _ : DCNL DCSP DCSP DCSP monkeypatch.setattr ( ( ( backend . _ _ name _ _ + &apos; .&apos; ) + method _ name ) , ( lambda * args , * * kwargs : None ) )
DCSP try : DCNL DCSP DCSP os.makedirs ( path ) DCNL DCSP except OSError as exc : DCNL DCSP DCSP if ( ( exc.errno = = errno.EEXIST ) and os.path.isdir ( path ) ) : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise
DCSP with open ( filename , &apos; rb &apos; ) as fid : DCNL DCSP DCSP content = fid.read ( ) DCNL DCSP content = content.replace ( &apos; \ r \ n &apos; , &apos; \ n &apos; ) DCNL DCSP try : DCNL DCSP DCSP node = ast.parse ( content ) DCNL DCSP except SyntaxError : DCNL DCSP DCSP return ( SYNTAX _ ERROR _ DOCSTRING , content.decode ( &apos; utf-8 &apos; ) ) DCNL DCSP if ( not isinstance ( node , ast.Module ) ) : DCNL DCSP DCSP raise TypeError ( &apos; This DCSP function DCSP only DCSP supports DCSP modules . DCSP You DCSP provided DCSP { 0 } &apos; .format ( node . _ _ class _ _ . _ _ name _ _ ) ) DCNL DCSP if ( node.body and isinstance ( node.body &#91; 0 &#93; , ast.Expr ) and isinstance ( node.body &#91; 0 &#93; .value , ast.Str ) ) : DCNL DCSP DCSP docstring _ node = node.body &#91; 0 &#93; DCNL DCSP DCSP docstring = docstring _ node.value.s DCNL DCSP DCSP if hasattr ( docstring , &apos; decode &apos; ) : DCNL DCSP DCSP DCSP docstring = docstring.decode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP rest = content.decode ( &apos; utf-8 &apos; ) .split ( &apos; \ n &apos; , docstring _ node.lineno ) &#91; ( -1 ) &#93; DCNL DCSP DCSP return ( docstring , rest ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Could DCSP not DCSP find DCSP docstring DCSP in DCSP file DCSP &quot; { 0 } &quot; . DCSP A DCSP docstring DCSP is DCSP required DCSP by DCSP sphinx-gallery &apos; .format ( filename ) )
DCSP assert ( utils.get _ repr ( Obj ( ) , constructor , * * attrs ) = = expected )
DCSP ordered _ product = get _ object _ or _ 404 ( OrderedProduct , pk = ordered _ product _ id ) DCNL DCSP if ( ( not request.user.profile.has _ permission ( ordered _ product , mode = &apos; w &apos; ) ) and ( not request.user.profile.is _ admin ( &apos; treeio.sales &apos; ) ) ) : DCNL DCSP DCSP return user _ denied ( request , &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Status &quot; , response _ format ) DCNL DCSP if request.POST : DCNL DCSP DCSP if ( &apos; delete &apos; in request.POST ) : DCNL DCSP DCSP DCSP order _ id = ordered _ product.order _ id DCNL DCSP DCSP DCSP if ( &apos; trash &apos; in request.POST ) : DCNL DCSP DCSP DCSP DCSP ordered _ product.trash = True DCNL DCSP DCSP DCSP DCSP ordered _ product.save ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ordered _ product.delete ( ) DCNL DCSP DCSP DCSP ordered _ product.order.update _ total ( ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; sales _ order _ view &apos; , args = &#91; order _ id &#93; ) ) DCNL DCSP DCSP elif ( &apos; cancel &apos; in request.POST ) : DCNL DCSP DCSP DCSP return HttpResponseRedirect ( reverse ( &apos; sales _ ordered _ product _ view &apos; , args = &#91; ordered _ product.id &#93; ) ) DCNL DCSP order = ordered _ product.order DCNL DCSP return render _ to _ response ( &apos; sales / ordered _ product _ delete &apos; , { &apos; ordered _ product &apos; : ordered _ product , &apos; order &apos; : order } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( not ( a _ device.snmp _ credentials.snmp _ mode = = &apos; snmp3 &apos; ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP SNMP DCSP mode DCSP in DCSP config _ detect DCSP { } &apos; .format ( a _ device.snmp _ credentials.snmp _ mode ) ) DCNL DCSP snmp _ device = ( a _ device.ip _ address , a _ device.snmp _ port ) DCNL DCSP snmp _ user = ( a _ device.snmp _ credentials.username , a _ device.snmp _ credentials.auth _ key , a _ device.snmp _ credentials.encrypt _ key ) DCNL DCSP auth _ proto = a _ device.snmp _ credentials.auth _ proto DCNL DCSP encrypt _ proto = a _ device.snmp _ credentials.encrypt _ proto DCNL DCSP return { &apos; snmp _ device &apos; : snmp _ device , &apos; snmp _ user &apos; : snmp _ user , &apos; oid &apos; : oid , &apos; auth _ proto &apos; : auth _ proto , &apos; encrypt _ proto &apos; : encrypt _ proto }
DCSP if ( k &lt; 1 ) : DCNL DCSP DCSP return False DCNL DCSP if ( n &lt; 0 ) : DCNL DCSP DCSP return False DCNL DCSP if ( n = = 0 ) : DCNL DCSP DCSP return True DCNL DCSP if ( k = = 1 ) : DCNL DCSP DCSP return is _ square ( n ) DCNL DCSP if ( k = = 2 ) : DCNL DCSP DCSP if ( n in ( 1 , 2 ) ) : DCNL DCSP DCSP DCSP return True DCNL DCSP DCSP if isprime ( n ) : DCNL DCSP DCSP DCSP if ( ( n % 4 ) = = 1 ) : DCNL DCSP DCSP DCSP DCSP return 1 DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP f = factorint ( n ) DCNL DCSP DCSP DCSP for ( p , m ) in f.items ( ) : DCNL DCSP DCSP DCSP DCSP if ( ( ( p % 4 ) = = 3 ) and ( m % 2 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP return True DCNL DCSP if ( k = = 3 ) : DCNL DCSP DCSP if ( ( ( n / / ( 4 * * multiplicity ( 4 , n ) ) ) % 8 ) = = 7 ) : DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP if ( session is None ) : DCNL DCSP DCSP session = get _ session ( ) DCNL DCSP with session.begin ( ) : DCNL DCSP DCSP rows = session.query ( models.VolumeGlanceMetadata ) .filter _ by ( volume _ id = volume _ id ) .filter _ by ( key = key ) .filter _ by ( deleted = False ) .all ( ) DCNL DCSP DCSP if ( len ( rows ) &gt; 0 ) : DCNL DCSP DCSP DCSP raise exception.GlanceMetadataExists ( key = key , volume _ id = volume _ id ) DCNL DCSP DCSP vol _ glance _ metadata = models.VolumeGlanceMetadata ( ) DCNL DCSP DCSP vol _ glance _ metadata.volume _ id = volume _ id DCNL DCSP DCSP vol _ glance _ metadata.key = key DCNL DCSP DCSP vol _ glance _ metadata.value = value DCNL DCSP DCSP vol _ glance _ metadata.save ( session = session ) DCNL DCSP return
DCSP perimeter = _ tile _ perimeter ( coord , projection , False ) DCNL DCSP return ( perimeter &#91; 8 &#93; &#91; 0 &#93; - perimeter &#91; 0 &#93; &#91; 0 &#93; )
DCSP get _ pool ( ) .connection _ pool _ kw.update ( maxsize = maxsize )
DCSP return encode ( raw _ bytes , expr = re _ alphanumeric , * a , * * kw )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ media _ list _ set _ media &apos; , None ) or _ Cfunction ( &apos; libvlc _ media _ list _ set _ media &apos; , ( ( 1 , ) , ( 1 , ) ) , None , None , MediaList , Media ) ) DCNL DCSP return f ( p _ ml , p _ md )
DCSP config = target _ dict &#91; &apos; configurations &apos; &#93; &#91; config _ name &#93; DCNL DCSP msvs = config.setdefault ( &apos; msvs _ settings &apos; , { } ) DCNL DCSP linker = msvs.get ( &apos; VCLinkerTool &apos; , { } ) DCNL DCSP pdb _ path = linker.get ( &apos; ProgramDatabaseFile &apos; ) DCNL DCSP if pdb _ path : DCNL DCSP DCSP return pdb _ path DCNL DCSP variables = target _ dict.get ( &apos; variables &apos; , { } ) DCNL DCSP pdb _ path = variables.get ( &apos; msvs _ large _ pdb _ path &apos; , None ) DCNL DCSP if pdb _ path : DCNL DCSP DCSP return pdb _ path DCNL DCSP pdb _ base = target _ dict.get ( &apos; product _ name &apos; , target _ dict &#91; &apos; target _ name &apos; &#93; ) DCNL DCSP pdb _ base = ( &apos; % s . % s.pdb &apos; % ( pdb _ base , TARGET _ TYPE _ EXT &#91; target _ dict &#91; &apos; type &apos; &#93; &#93; ) ) DCNL DCSP pdb _ path = ( ( vars &#91; &apos; PRODUCT _ DIR &apos; &#93; + &apos; / &apos; ) + pdb _ base ) DCNL DCSP return pdb _ path
DCSP try : DCNL DCSP DCSP out = max _ and _ argmax ( x , axis ) &#91; 0 &#93; DCNL DCSP except Exception : DCNL DCSP DCSP out = CAReduce ( scal.maximum , axis ) ( x ) DCNL DCSP if keepdims : DCNL DCSP DCSP out = makeKeepDims ( x , out , axis ) DCNL DCSP return out
DCSP def _ checklogin ( request , * args , * * kwargs ) : DCNL DCSP DCSP if ( request.user.is _ authenticated ( ) and request.user.is _ staff ) : DCNL DCSP DCSP DCSP return view _ func ( request , * args , * * kwargs ) DCNL DCSP DCSP assert hasattr ( request , &apos; session &apos; ) , &quot; The DCSP Django DCSP admin DCSP requires DCSP session DCSP middleware DCSP to DCSP be DCSP installed . DCSP Edit DCSP your DCSP MIDDLEWARE _ CLASSES DCSP setting DCSP to DCSP insert DCSP &apos; django.contrib.sessions.middleware.SessionMiddleware &apos; . &quot; DCNL DCSP DCSP if ( not request.POST.has _ key ( LOGIN _ FORM _ KEY ) ) : DCNL DCSP DCSP DCSP if request.POST : DCNL DCSP DCSP DCSP DCSP message = _ ( &apos; Please DCSP log DCSP in DCSP again , DCSP because DCSP your DCSP session DCSP has DCSP expired . &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP message = &apos; &apos; DCNL DCSP DCSP DCSP return _ display _ login _ form ( request , message ) DCNL DCSP DCSP if ( not request.session.test _ cookie _ worked ( ) ) : DCNL DCSP DCSP DCSP message = _ ( &quot; Looks DCSP like DCSP your DCSP browser DCSP isn &apos;t DCSP configured DCSP to DCSP accept DCSP cookies . DCSP Please DCSP enable DCSP cookies , DCSP reload DCSP this DCSP page , DCSP and DCSP try DCSP again . &quot; ) DCNL DCSP DCSP DCSP return _ display _ login _ form ( request , message ) DCNL DCSP DCSP username = request.POST.get ( &apos; username &apos; , None ) DCNL DCSP DCSP password = request.POST.get ( &apos; password &apos; , None ) DCNL DCSP DCSP user = authenticate ( username = username , password = password ) DCNL DCSP DCSP if ( user is None ) : DCNL DCSP DCSP DCSP message = ERROR _ MESSAGE DCNL DCSP DCSP DCSP if ( &apos; @ &apos; in username ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP user = User.objects.get ( email = username ) DCNL DCSP DCSP DCSP DCSP except User.DoesNotExist : DCNL DCSP DCSP DCSP DCSP DCSP message = _ ( &quot; Usernames DCSP cannot DCSP contain DCSP the DCSP &apos; @ &apos; DCSP character . &quot; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP message = ( _ ( &quot; Your DCSP e-mail DCSP address DCSP is DCSP not DCSP your DCSP username . DCSP Try DCSP &apos; % s &apos; DCSP instead . &quot; ) % user.username ) DCNL DCSP DCSP DCSP return _ display _ login _ form ( request , message ) DCNL DCSP DCSP elif ( user.is _ active and user.is _ staff ) : DCNL DCSP DCSP DCSP login ( request , user ) DCNL DCSP DCSP DCSP user.last _ login = datetime.datetime.now ( ) DCNL DCSP DCSP DCSP user.save ( ) DCNL DCSP DCSP DCSP return http.HttpResponseRedirect ( request.path ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return _ display _ login _ form ( request , ERROR _ MESSAGE ) DCNL DCSP return _ checklogin
DCSP is _ ax = ( coil &#91; &apos; coil _ class &apos; &#93; in ( FIFF.FWD _ COILC _ MAG , FIFF.FWD _ COILC _ AXIAL _ GRAD , FIFF.FWD _ COILC _ AXIAL _ GRAD2 ) ) DCNL DCSP return is _ ax
DCSP q = find _ simple _ recurrence _ vector ( v ) DCNL DCSP n = len ( q ) DCNL DCSP if ( n &lt; = 1 ) : DCNL DCSP DCSP return None DCNL DCSP p = &#91; sum ( ( ( v &#91; ( i - k ) &#93; * q &#91; k &#93; ) for k in range ( min ( ( i + 1 ) , n ) ) ) ) for i in range ( len ( v ) ) &#93; DCNL DCSP return ( sum ( ( ( p &#91; k &#93; * ( X * * k ) ) for k in range ( len ( p ) ) ) ) / sum ( ( ( q &#91; k &#93; * ( X * * k ) ) for k in range ( n ) ) ) )
DCSP statements = &#91; &#93; DCNL DCSP for _ in range ( 0 , total _ strings ) : DCNL DCSP DCSP text = &apos; &apos;.join ( ( random.choice ( ( ( string.ascii _ letters + string.digits ) + &apos; DCSP &apos; ) ) for _ in range ( string _ length ) ) ) DCNL DCSP DCSP statements.append ( text ) DCNL DCSP return statements
DCSP lines = iter ( yield _ lines ( strs ) ) DCNL DCSP def scan _ list ( ITEM , TERMINATOR , line , p , groups , item _ name ) : DCNL DCSP DCSP items = &#91; &#93; DCNL DCSP DCSP while ( not TERMINATOR ( line , p ) ) : DCNL DCSP DCSP DCSP if CONTINUE ( line , p ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP line = next ( lines ) DCNL DCSP DCSP DCSP DCSP DCSP p = 0 DCNL DCSP DCSP DCSP DCSP except StopIteration : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError ( &apos; \ \ DCSP must DCSP not DCSP appear DCSP on DCSP the DCSP last DCSP nonblank DCSP line &apos; ) DCNL DCSP DCSP DCSP match = ITEM ( line , p ) DCNL DCSP DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP DCSP msg = ( ( &apos; Expected DCSP &apos; + item _ name ) + &apos; DCSP in &apos; ) DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg , line , &apos; at &apos; , line &#91; p : &#93; ) DCNL DCSP DCSP DCSP items.append ( match.group ( * groups ) ) DCNL DCSP DCSP DCSP p = match.end ( ) DCNL DCSP DCSP DCSP match = COMMA ( line , p ) DCNL DCSP DCSP DCSP if match : DCNL DCSP DCSP DCSP DCSP p = match.end ( ) DCNL DCSP DCSP DCSP elif ( not TERMINATOR ( line , p ) ) : DCNL DCSP DCSP DCSP DCSP msg = &quot; Expected DCSP &apos; , &apos; DCSP or DCSP end-of-list DCSP in &quot; DCNL DCSP DCSP DCSP DCSP raise ValueError ( msg , line , &apos; at &apos; , line &#91; p : &#93; ) DCNL DCSP DCSP match = TERMINATOR ( line , p ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP p = match.end ( ) DCNL DCSP DCSP return ( line , p , items ) DCNL DCSP for line in lines : DCNL DCSP DCSP match = DISTRO ( line ) DCNL DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Missing DCSP distribution DCSP spec &apos; , line ) DCNL DCSP DCSP project _ name = match.group ( 1 ) DCNL DCSP DCSP p = match.end ( ) DCNL DCSP DCSP extras = &#91; &#93; DCNL DCSP DCSP match = OBRACKET ( line , p ) DCNL DCSP DCSP if match : DCNL DCSP DCSP DCSP p = match.end ( ) DCNL DCSP DCSP DCSP ( line , p , extras ) = scan _ list ( DISTRO , CBRACKET , line , p , ( 1 , ) , &quot; &apos; extra &apos; DCSP name &quot; ) DCNL DCSP DCSP ( line , p , specs ) = scan _ list ( VERSION , LINE _ END , line , p , ( 1 , 2 ) , &apos; version DCSP spec &apos; ) DCNL DCSP DCSP specs = &#91; ( op , safe _ version ( val ) ) for ( op , val ) in specs &#93; DCNL DCSP DCSP ( yield Requirement ( project _ name , specs , extras ) )
DCSP dynamodb _ type = get _ dynamodb _ type ( val ) DCNL DCSP if ( dynamodb _ type = = &apos; N &apos; ) : DCNL DCSP DCSP val = { dynamodb _ type : serialize _ num ( val ) } DCNL DCSP elif ( dynamodb _ type = = &apos; S &apos; ) : DCNL DCSP DCSP val = { dynamodb _ type : val } DCNL DCSP elif ( dynamodb _ type = = &apos; NS &apos; ) : DCNL DCSP DCSP val = { dynamodb _ type : list ( map ( serialize _ num , val ) ) } DCNL DCSP elif ( dynamodb _ type = = &apos; SS &apos; ) : DCNL DCSP DCSP val = { dynamodb _ type : &#91; n for n in val &#93; } DCNL DCSP elif ( dynamodb _ type = = &apos; B &apos; ) : DCNL DCSP DCSP if isinstance ( val , bytes ) : DCNL DCSP DCSP DCSP val = Binary ( val ) DCNL DCSP DCSP val = { dynamodb _ type : val.encode ( ) } DCNL DCSP elif ( dynamodb _ type = = &apos; BS &apos; ) : DCNL DCSP DCSP val = { dynamodb _ type : &#91; n.encode ( ) for n in val &#93; } DCNL DCSP return val
DCSP completer = QtWidgets.QCompleter ( items , widget ) DCNL DCSP completer.setCaseSensitivity ( Qt.CaseInsensitive ) DCNL DCSP completer.setCompletionMode ( QtWidgets.QCompleter.InlineCompletion ) DCNL DCSP widget.setCompleter ( completer )
DCSP uniquedeps = get _ deps _ dict &#91; &apos; uniquedeps &apos; &#93; DCNL DCSP spec = get _ deps _ dict &#91; &apos; spec &apos; &#93; DCNL DCSP hash.update ( spec.text ) DCNL DCSP for d in uniquedeps : DCNL DCSP DCSP hash.update ( roslib.msgs.get _ registered ( d ) .text ) DCNL DCSP return hash.hexdigest ( )
DCSP return NegativeSamplingFunction ( sampler , sample _ size ) ( x , t , W )
DCSP redirect _ to = request.REQUEST.get ( redirect _ field _ name , &apos; &apos; ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP form = authentication _ form ( data = request.POST ) DCNL DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP if ( not is _ safe _ url ( url = redirect _ to , host = request.get _ host ( ) ) ) : DCNL DCSP DCSP DCSP DCSP redirect _ to = resolve _ url ( settings.LOGIN _ REDIRECT _ URL ) DCNL DCSP DCSP DCSP auth _ login ( request , form.get _ user ( ) ) DCNL DCSP DCSP DCSP if request.session.test _ cookie _ worked ( ) : DCNL DCSP DCSP DCSP DCSP request.session.delete _ test _ cookie ( ) DCNL DCSP DCSP DCSP return HttpResponseRedirect ( redirect _ to ) DCNL DCSP else : DCNL DCSP DCSP form = authentication _ form ( request ) DCNL DCSP request.session.set _ test _ cookie ( ) DCNL DCSP current _ site = get _ current _ site ( request ) DCNL DCSP context = { &apos; form &apos; : form , redirect _ field _ name : redirect _ to , &apos; site &apos; : current _ site , &apos; site _ name &apos; : current _ site.name } DCNL DCSP if ( extra _ context is not None ) : DCNL DCSP DCSP context.update ( extra _ context ) DCNL DCSP return TemplateResponse ( request , template _ name , context , current _ app = current _ app )
DCSP titles = &#91; &#93; DCNL DCSP if ( not title ) : DCNL DCSP DCSP return titles DCNL DCSP size = reverse _ text _ len ( width , ( title _ fs * 1.1 ) ) DCNL DCSP title _ lines = title.split ( &apos; \ n &apos; ) DCNL DCSP for title _ line in title _ lines : DCNL DCSP DCSP while ( len ( title _ line ) &gt; size ) : DCNL DCSP DCSP DCSP title _ part = title _ line &#91; : size &#93; DCNL DCSP DCSP DCSP i = title _ part.rfind ( &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP if ( i = = ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP i = len ( title _ part ) DCNL DCSP DCSP DCSP titles.append ( title _ part &#91; : i &#93; ) DCNL DCSP DCSP DCSP title _ line = title _ line &#91; i : &#93; .strip ( ) DCNL DCSP DCSP titles.append ( title _ line ) DCNL DCSP return titles
DCSP yh = SM.sineModelSynth ( hfreq , hmag , hphase , N , H , fs ) DCNL DCSP yst = STM.stochasticModelSynth ( stocEnv , H , ( H * 2 ) ) DCNL DCSP y = ( yh &#91; : min ( yh.size , yst.size ) &#93; + yst &#91; : min ( yh.size , yst.size ) &#93; ) DCNL DCSP return ( y , yh , yst )
DCSP if is _ nnf ( expr , simplify ) : DCNL DCSP DCSP return expr DCNL DCSP return expr.to _ nnf ( simplify )
DCSP global ET DCNL DCSP _ bootstrap ( ) DCNL DCSP return ET.fromstring ( * args , * * kwargs )
DCSP settings.POOTLE _ CAPTCHA _ ENABLED = False DCNL DCSP Comment = get _ comment _ model ( ) DCNL DCSP unit = Unit.objects.filter ( suggestion _ _ state = &apos; pending &apos; , state = UNTRANSLATED ) &#91; 0 &#93; DCNL DCSP sugg = Suggestion.objects.filter ( unit = unit , state = &apos; pending &apos; ) &#91; 0 &#93; DCNL DCSP user = request _ users &#91; &apos; user &apos; &#93; DCNL DCSP if ( user.username ! = &apos; nobody &apos; ) : DCNL DCSP DCSP client.login ( username = user.username , password = request _ users &#91; &apos; password &apos; &#93; ) DCNL DCSP url = ( &apos; / xhr / units / % d / &apos; % unit.id ) DCNL DCSP edited _ target = ( &apos; Edited DCSP % s &apos; % sugg.target _ f ) DCNL DCSP comment = &apos; This DCSP is DCSP a DCSP comment ! &apos; DCNL DCSP response = client.post ( url , { &apos; state &apos; : False , &apos; target _ f _ 0 &apos; : edited _ target , &apos; suggestion &apos; : sugg.id , &apos; comment &apos; : comment } , HTTP _ X _ REQUESTED _ WITH = &apos; XMLHttpRequest &apos; ) DCNL DCSP if check _ permission ( &apos; translate &apos; , response.wsgi _ request ) : DCNL DCSP DCSP assert ( response.status _ code = = 200 ) DCNL DCSP DCSP content = json.loads ( response.content ) DCNL DCSP DCSP assert ( content &#91; &apos; newtargets &apos; &#93; = = &#91; edited _ target &#93; ) DCNL DCSP DCSP assert ( content &#91; &apos; user _ score &apos; &#93; = = response.wsgi _ request.user.public _ score ) DCNL DCSP DCSP assert ( content &#91; &apos; checks &apos; &#93; is None ) DCNL DCSP DCSP accepted _ suggestion = Suggestion.objects.get ( id = sugg.id ) DCNL DCSP DCSP updated _ unit = Unit.objects.get ( id = unit.id ) DCNL DCSP DCSP assert ( accepted _ suggestion.state = = &apos; accepted &apos; ) DCNL DCSP DCSP assert ( str ( updated _ unit.target ) = = edited _ target ) DCNL DCSP DCSP assert ( Comment.objects.for _ model ( accepted _ suggestion ) .get ( ) .comment = = comment ) DCNL DCSP else : DCNL DCSP DCSP assert ( response.status _ code = = 403 )
DCSP mappings = service _ mapping ( services , registry _ path = registry _ path ) DCNL DCSP return webapp2.WSGIApplication ( routes = mappings , debug = debug , config = config )
DCSP matrixKey = ( prefix + &apos; matrix &apos; ) DCNL DCSP evaluatedDictionary = evaluate.getEvaluatedDictionary ( &#91; matrixKey &#93; , xmlElement ) DCNL DCSP if ( len ( evaluatedDictionary.keys ( ) ) &lt; 1 ) : DCNL DCSP DCSP return matrixTetragrid DCNL DCSP value = evaluatedDictionary &#91; matrixKey &#93; DCNL DCSP if ( ( value = = None ) or ( value = = &apos; None &apos; ) ) : DCNL DCSP DCSP print &apos; Warning , DCSP value DCSP in DCSP getMatrixTetragridMatrix DCSP in DCSP matrix DCSP is DCSP None DCSP for DCSP matrixKey DCSP for DCSP dictionary : &apos; DCNL DCSP DCSP print matrixKey DCNL DCSP DCSP print evaluatedDictionary DCNL DCSP else : DCNL DCSP DCSP matrixTetragrid = getIdentityMatrixTetragrid ( matrixTetragrid ) DCNL DCSP DCSP for ( rowIndex , row ) in enumerate ( value ) : DCNL DCSP DCSP DCSP for ( elementIndex , element ) in enumerate ( row ) : DCNL DCSP DCSP DCSP DCSP matrixTetragrid &#91; rowIndex &#93; &#91; elementIndex &#93; = element DCNL DCSP euclidean.removeListFromDictionary ( xmlElement.attributeDictionary , &#91; matrixKey &#93; ) DCNL DCSP return matrixTetragrid
DCSP network _ config = getattr ( settings , &apos; OPENSTACK _ NEUTRON _ NETWORK &apos; , { } ) DCNL DCSP feature _ info = FEATURE _ MAP.get ( feature ) DCNL DCSP if ( not feature _ info ) : DCNL DCSP DCSP raise ValueError ( _ ( &quot; The DCSP requested DCSP feature DCSP &apos; % ( feature ) s &apos; DCSP is DCSP unknown . DCSP Please DCSP make DCSP sure DCSP to DCSP specify DCSP a DCSP feature DCSP defined DCSP in DCSP FEATURE _ MAP . &quot; ) ) DCNL DCSP feature _ config = feature _ info.get ( &apos; config &apos; ) DCNL DCSP if feature _ config : DCNL DCSP DCSP if ( not network _ config.get ( feature _ config &#91; &apos; name &apos; &#93; , feature _ config &#91; &apos; default &apos; &#93; ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP feature _ policies = feature _ info.get ( &apos; policies &apos; ) DCNL DCSP if feature _ policies : DCNL DCSP DCSP policy _ name = feature _ policies.get ( operation ) DCNL DCSP DCSP if ( not policy _ name ) : DCNL DCSP DCSP DCSP raise ValueError ( ( _ ( &quot; The DCSP &apos; operation &apos; DCSP parameter DCSP for DCSP get _ feature _ permission DCSP &apos; % ( feature ) s &apos; DCSP is DCSP invalid . DCSP It DCSP should DCSP be DCSP one DCSP of DCSP % ( allowed ) s &quot; ) % { &apos; feature &apos; : feature , &apos; allowed &apos; : &apos; DCSP &apos; .join ( feature _ policies.keys ( ) ) } ) ) DCNL DCSP DCSP role = ( ( &apos; network &apos; , policy _ name ) , ) DCNL DCSP DCSP if ( not policy.check ( role , request ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP feature _ extension = feature _ info.get ( &apos; extension &apos; ) DCNL DCSP if feature _ extension : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return is _ extension _ supported ( request , feature _ extension ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP msg = ( _ ( &quot; Failed DCSP to DCSP check DCSP Neutron DCSP &apos; % s &apos; DCSP extension DCSP is DCSP not DCSP supported &quot; ) % feature _ extension ) DCNL DCSP DCSP DCSP LOG.info ( msg ) DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP if ( pytz is None ) : DCNL DCSP DCSP if timezone _ string : DCNL DCSP DCSP DCSP raise ValueError ( &apos; need DCSP pytz DCSP in DCSP order DCSP to DCSP specify DCSP a DCSP timezone &apos; ) DCNL DCSP DCSP return None DCNL DCSP if timezone _ string : DCNL DCSP DCSP return pytz.timezone ( timezone _ string ) DCNL DCSP else : DCNL DCSP DCSP return pytz.utc
DCSP a = a.split ( &apos; .&apos; ) DCNL DCSP b = b.split ( &apos; .&apos; ) DCNL DCSP for ( va , vb ) in zip ( a , b ) : DCNL DCSP DCSP ret = ( int ( va ) - int ( vb ) ) DCNL DCSP DCSP if ret : DCNL DCSP DCSP DCSP return ret DCNL DCSP return ( len ( a ) - len ( b ) )
DCSP if ( v &gt; = _ MAX _ SCATTERED _ COUNTER ) : DCNL DCSP DCSP raise datastore _ errors.BadArgumentError ( ( &apos; counter DCSP value DCSP too DCSP large DCSP ( % d ) &apos; % v ) ) DCNL DCSP return ( ( _ MAX _ SEQUENTIAL _ ID + 1 ) + long ( ReverseBitsInt64 ( ( v &lt; &lt; _ SCATTER _ SHIFT ) ) ) )
DCSP try : DCNL DCSP DCSP item = KnowledgeItem.by _ path ( folderPath , itemPath ) DCNL DCSP except KnowledgeItem.DoesNotExist : DCNL DCSP DCSP raise Http404 DCNL DCSP if ( not item ) : DCNL DCSP DCSP raise Http404 DCNL DCSP items = Object.filter _ permitted ( manager = KnowledgeItem.objects , user = request.user.profile , mode = &apos; r &apos; ) DCNL DCSP if ( not request.user.profile.has _ permission ( item ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Knowledge DCSP Item &quot; ) DCNL DCSP context = _ get _ default _ context ( request ) DCNL DCSP context.update ( { &apos; items &apos; : items , &apos; item &apos; : item } ) DCNL DCSP return render _ to _ response ( &apos; knowledge / item _ view &apos; , context , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( len ( splitLine ) &gt; 0 ) : DCNL DCSP DCSP return splitLine &#91; 0 &#93; DCNL DCSP return &apos; &apos;
DCSP if ( not os.path.exists ( path ) ) : DCNL DCSP DCSP os.makedirs ( path ) DCNL DCSP elif ( not os.access ( path , os.W _ OK ) ) : DCNL DCSP DCSP raise OSError ( &apos; DATA _ DIR DCSP { 0 } DCSP is DCSP not DCSP writable ! &apos; .format ( path ) )
DCSP first = param _ values &#91; &apos; name1 &apos; &#93; DCNL DCSP second = param _ values &#91; &apos; name2 &apos; &#93; DCNL DCSP if ( first = = second ) : DCNL DCSP DCSP error _ map &#91; &apos; name1 &apos; &#93; = &apos; The DCSP value DCSP names DCSP should DCSP be DCSP different . &apos; 
DCSP return get _ i18n ( ) .parse _ date ( string )
DCSP result = script.pip ( &apos; install &apos; , &apos; --no-index &apos; , ( &apos; --find-links = &apos; + data.find _ links ) , &apos; simplewheel &#91; nonexistent , DCSP nope &#93; &apos; , expect _ stderr = True ) DCNL DCSP msg = &quot; DCSP DCSP simplewheel DCSP 2.0 DCSP does DCSP not DCSP provide DCSP the DCSP extra DCSP &apos; nonexistent &apos; \ n DCSP DCSP simplewheel DCSP 2.0 DCSP does DCSP not DCSP provide DCSP the DCSP extra DCSP &apos; nope &apos; &quot; DCNL DCSP assert ( msg in result.stderr )
DCSP containers = dict ( &#91; ( c , ( &#91; &apos; all &apos; &#93; + ( lxc.Container ( c ) .get _ config _ item ( &apos; lxc.group &apos; ) or &#91; &#93; ) ) ) for c in lxc.list _ containers ( ) &#93; ) DCNL DCSP groups = set ( sum ( &#91; g for g in containers.values ( ) &#93; , &#91; &#93; ) ) DCNL DCSP return dict ( &#91; ( g , { &apos; hosts &apos; : &#91; k for ( k , v ) in containers.items ( ) if ( g in v ) &#93; , &apos; vars &apos; : { &apos; ansible _ connection &apos; : &apos; lxc &apos; } } ) for g in groups &#93; )
DCSP try : DCNL DCSP DCSP ( status , addressVersion , streamNumber , ripe ) = decodeAddress ( address ) DCNL DCSP DCSP readPosition = 20 DCNL DCSP DCSP ( embeddedAddressVersion , varintLength ) = decodeVarint ( data &#91; readPosition : ( readPosition + 10 ) &#93; ) DCNL DCSP DCSP readPosition + = varintLength DCNL DCSP DCSP ( embeddedStreamNumber , varintLength ) = decodeVarint ( data &#91; readPosition : ( readPosition + 10 ) &#93; ) DCNL DCSP DCSP readPosition + = varintLength DCNL DCSP DCSP storedData = data &#91; 20 : readPosition &#93; DCNL DCSP DCSP if ( addressVersion ! = embeddedAddressVersion ) : DCNL DCSP DCSP DCSP logger.info ( &apos; Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP address DCSP version DCSP mismatch . &apos; ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP if ( streamNumber ! = embeddedStreamNumber ) : DCNL DCSP DCSP DCSP logger.info ( &apos; Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP stream DCSP number DCSP mismatch . &apos; ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP tag = data &#91; readPosition : ( readPosition + 32 ) &#93; DCNL DCSP DCSP readPosition + = 32 DCNL DCSP DCSP signedData = data &#91; 8 : readPosition &#93; DCNL DCSP DCSP encryptedData = data &#91; readPosition : &#93; DCNL DCSP DCSP ( toAddress , cryptorObject ) = shared.neededPubkeys &#91; tag &#93; DCNL DCSP DCSP if ( toAddress ! = address ) : DCNL DCSP DCSP DCSP logger.critical ( ( &apos; decryptAndCheckPubkeyPayload DCSP failed DCSP due DCSP to DCSP toAddress DCSP mismatch . DCSP This DCSP is DCSP very DCSP peculiar . DCSP toAddress : DCSP % s , DCSP address DCSP % s &apos; % ( toAddress , address ) ) ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP decryptedData = cryptorObject.decrypt ( encryptedData ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP logger.info ( &apos; Pubkey DCSP decryption DCSP was DCSP unsuccessful . &apos; ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP readPosition = 0 DCNL DCSP DCSP bitfieldBehaviors = decryptedData &#91; readPosition : ( readPosition + 4 ) &#93; DCNL DCSP DCSP readPosition + = 4 DCNL DCSP DCSP publicSigningKey = ( &apos; \ x04 &apos; + decryptedData &#91; readPosition : ( readPosition + 64 ) &#93; ) DCNL DCSP DCSP readPosition + = 64 DCNL DCSP DCSP publicEncryptionKey = ( &apos; \ x04 &apos; + decryptedData &#91; readPosition : ( readPosition + 64 ) &#93; ) DCNL DCSP DCSP readPosition + = 64 DCNL DCSP DCSP ( specifiedNonceTrialsPerByte , specifiedNonceTrialsPerByteLength ) = decodeVarint ( decryptedData &#91; readPosition : ( readPosition + 10 ) &#93; ) DCNL DCSP DCSP readPosition + = specifiedNonceTrialsPerByteLength DCNL DCSP DCSP ( specifiedPayloadLengthExtraBytes , specifiedPayloadLengthExtraBytesLength ) = decodeVarint ( decryptedData &#91; readPosition : ( readPosition + 10 ) &#93; ) DCNL DCSP DCSP readPosition + = specifiedPayloadLengthExtraBytesLength DCNL DCSP DCSP storedData + = decryptedData &#91; : readPosition &#93; DCNL DCSP DCSP signedData + = decryptedData &#91; : readPosition &#93; DCNL DCSP DCSP ( signatureLength , signatureLengthLength ) = decodeVarint ( decryptedData &#91; readPosition : ( readPosition + 10 ) &#93; ) DCNL DCSP DCSP readPosition + = signatureLengthLength DCNL DCSP DCSP signature = decryptedData &#91; readPosition : ( readPosition + signatureLength ) &#93; DCNL DCSP DCSP if highlevelcrypto.verify ( signedData , signature , hexlify ( publicSigningKey ) ) : DCNL DCSP DCSP DCSP logger.info ( &apos; ECDSA DCSP verify DCSP passed DCSP ( within DCSP decryptAndCheckPubkeyPayload ) &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP logger.info ( &apos; ECDSA DCSP verify DCSP failed DCSP ( within DCSP decryptAndCheckPubkeyPayload ) &apos; ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP sha = hashlib.new ( &apos; sha512 &apos; ) DCNL DCSP DCSP sha.update ( ( publicSigningKey + publicEncryptionKey ) ) DCNL DCSP DCSP ripeHasher = hashlib.new ( &apos; ripemd160 &apos; ) DCNL DCSP DCSP ripeHasher.update ( sha.digest ( ) ) DCNL DCSP DCSP embeddedRipe = ripeHasher.digest ( ) DCNL DCSP DCSP if ( embeddedRipe ! = ripe ) : DCNL DCSP DCSP DCSP logger.info ( &apos; Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP RIPE DCSP mismatch . &apos; ) DCNL DCSP DCSP DCSP return &apos; failed &apos; DCNL DCSP DCSP logger.info ( ( &apos; within DCSP decryptAndCheckPubkeyPayload , DCSP addressVersion : DCSP % s , DCSP streamNumber : DCSP % s DCSP \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ripe DCSP % s \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP publicSigningKey DCSP in DCSP hex : DCSP % s \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP publicEncryptionKey DCSP in DCSP hex : DCSP % s &apos; % ( addressVersion , streamNumber , hexlify ( ripe ) , hexlify ( publicSigningKey ) , hexlify ( publicEncryptionKey ) ) ) ) DCNL DCSP DCSP t = ( address , addressVersion , storedData , int ( time.time ( ) ) , &apos; yes &apos; ) DCNL DCSP DCSP sqlExecute ( &apos; INSERT DCSP INTO DCSP pubkeys DCSP VALUES DCSP ( ? , ? , ? , ? , ? ) &apos; , * t ) DCNL DCSP DCSP return &apos; successful &apos; DCNL DCSP except varintDecodeError as e : DCNL DCSP DCSP logger.info ( &apos; Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP due DCSP to DCSP a DCSP malformed DCSP varint . &apos; ) DCNL DCSP DCSP return &apos; failed &apos; DCNL DCSP except Exception as e : DCNL DCSP DCSP logger.critical ( ( &apos; Pubkey DCSP decryption DCSP was DCSP UNsuccessful DCSP because DCSP of DCSP an DCSP unhandled DCSP exception ! DCSP This DCSP is DCSP definitely DCSP a DCSP bug ! DCSP \ n % s &apos; % traceback.format _ exc ( ) ) ) DCNL DCSP DCSP return &apos; failed&apos;
DCSP mac = hex ( num ) &#91; 2 : &#93; DCNL DCSP if ( mac &#91; ( -1 ) &#93; = = u &apos;L &apos; ) : DCNL DCSP DCSP mac = mac &#91; : ( -1 ) &#93; DCNL DCSP pad = max ( ( 12 - len ( mac ) ) , 0 ) DCNL DCSP mac = ( ( u &apos; 0 &apos; * pad ) + mac ) DCNL DCSP mac = splitter.join ( &#91; mac &#91; x : ( x + 2 ) &#93; for x in range ( 0 , 12 , 2 ) &#93; ) DCNL DCSP mac = mac.upper ( ) DCNL DCSP return mac
DCSP all _ rising = rising.get _ all _ rising ( ) DCNL DCSP candidate _ sr _ ids = { sr _ id for ( link , score , sr _ id ) in all _ rising } .difference ( omit _ sr _ ids ) DCNL DCSP link _ fullnames = &#91; link for ( link , score , sr _ id ) in all _ rising if ( sr _ id in candidate _ sr _ ids ) &#93; DCNL DCSP link _ fullnames _ to _ show = random _ sample ( link _ fullnames , count ) DCNL DCSP rising _ links = Link . _ by _ fullname ( link _ fullnames _ to _ show , return _ dict = False , data = True ) DCNL DCSP rising _ items = &#91; ExploreItem ( TYPE _ RISING , &apos; ris &apos; , Subreddit . _ byID ( l.sr _ id ) , l ) for l in rising _ links &#93; DCNL DCSP return rising _ items
DCSP if isinstance ( profile , string _ types ) : DCNL DCSP DCSP profile = _ _ salt _ _ &#91; &apos; config.option &apos; &#93; ( profile ) DCNL DCSP if orgname : DCNL DCSP DCSP switch _ org ( orgname , profile ) DCNL DCSP response = requests.get ( &apos; { 0 } / api / datasources &apos; .format ( profile &#91; &apos; grafana _ url &apos; &#93; ) , auth = _ get _ auth ( profile ) , headers = _ get _ headers ( profile ) , timeout = profile.get ( &apos; grafana _ timeout &apos; , 3 ) ) DCNL DCSP if ( response.status _ code &gt; = 400 ) : DCNL DCSP DCSP response.raise _ for _ status ( ) DCNL DCSP return response.json ( )
DCSP ( _ , _ , app _ id ) = app _ id.replace ( &apos; : &apos; , &apos; _ &apos; ) .rpartition ( &apos; ~ &apos; ) DCNL DCSP if ( path is None ) : DCNL DCSP DCSP for path in _ generate _ storage _ paths ( app _ id ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP os.mkdir ( path , 448 ) DCNL DCSP DCSP DCSP except OSError as e : DCNL DCSP DCSP DCSP DCSP if ( e.errno = = errno.EEXIST ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( sys.platform = = &apos; win32 &apos; ) or ( ( ( os.stat ( path ) .st _ mode &amp; 511 ) = = 448 ) and os.path.isdir ( path ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return path DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP raise DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return path DCNL DCSP elif ( not os.path.exists ( path ) ) : DCNL DCSP DCSP os.mkdir ( path ) DCNL DCSP DCSP return path DCNL DCSP elif ( not os.path.isdir ( path ) ) : DCNL DCSP DCSP raise IOError ( ( &apos; the DCSP given DCSP storage DCSP path DCSP % r DCSP is DCSP a DCSP file , DCSP a DCSP directory DCSP was DCSP expected &apos; % path ) ) DCNL DCSP else : DCNL DCSP DCSP return path
DCSP appctx = _ app _ ctx _ stack.top DCNL DCSP reqctx = _ request _ ctx _ stack.top DCNL DCSP if ( appctx is None ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Attempted DCSP to DCSP generate DCSP a DCSP URL DCSP without DCSP the DCSP application DCSP context DCSP being DCSP pushed . DCSP This DCSP has DCSP to DCSP be DCSP executed DCSP when DCSP application DCSP context DCSP is DCSP available . &apos; ) DCNL DCSP if ( reqctx is not None ) : DCNL DCSP DCSP url _ adapter = reqctx.url _ adapter DCNL DCSP DCSP blueprint _ name = request.blueprint DCNL DCSP DCSP if ( not reqctx.request. _ is _ old _ module ) : DCNL DCSP DCSP DCSP if ( endpoint &#91; : 1 &#93; = = &apos; .&apos; ) : DCNL DCSP DCSP DCSP DCSP if ( blueprint _ name is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP endpoint = ( blueprint _ name + endpoint ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP endpoint = endpoint &#91; 1 : &#93; DCNL DCSP DCSP elif ( &apos; .&apos; not in endpoint ) : DCNL DCSP DCSP DCSP if ( blueprint _ name is not None ) : DCNL DCSP DCSP DCSP DCSP endpoint = ( ( blueprint _ name + &apos; .&apos; ) + endpoint ) DCNL DCSP DCSP elif endpoint.startswith ( &apos; .&apos; ) : DCNL DCSP DCSP DCSP endpoint = endpoint &#91; 1 : &#93; DCNL DCSP DCSP external = values.pop ( &apos; _ external &apos; , False ) DCNL DCSP else : DCNL DCSP DCSP url _ adapter = appctx.url _ adapter DCNL DCSP DCSP if ( url _ adapter is None ) : DCNL DCSP DCSP DCSP raise RuntimeError ( &apos; Application DCSP was DCSP not DCSP able DCSP to DCSP create DCSP a DCSP URL DCSP adapter DCSP for DCSP request DCSP independent DCSP URL DCSP generation . DCSP You DCSP might DCSP be DCSP able DCSP to DCSP fix DCSP this DCSP by DCSP setting DCSP the DCSP SERVER _ NAME DCSP config DCSP variable . &apos; ) DCNL DCSP DCSP external = values.pop ( &apos; _ external &apos; , True ) DCNL DCSP anchor = values.pop ( &apos; _ anchor &apos; , None ) DCNL DCSP method = values.pop ( &apos; _ method &apos; , None ) DCNL DCSP scheme = values.pop ( &apos; _ scheme &apos; , None ) DCNL DCSP appctx.app.inject _ url _ defaults ( endpoint , values ) DCNL DCSP if ( scheme is not None ) : DCNL DCSP DCSP if ( not external ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; When DCSP specifying DCSP _ scheme , DCSP _ external DCSP must DCSP be DCSP True &apos; ) DCNL DCSP DCSP url _ adapter.url _ scheme = scheme DCNL DCSP try : DCNL DCSP DCSP rv = url _ adapter.build ( endpoint , values , method = method , force _ external = external ) DCNL DCSP except BuildError as error : DCNL DCSP DCSP values &#91; &apos; _ external &apos; &#93; = external DCNL DCSP DCSP values &#91; &apos; _ anchor &apos; &#93; = anchor DCNL DCSP DCSP values &#91; &apos; _ method &apos; &#93; = method DCNL DCSP DCSP return appctx.app.handle _ url _ build _ error ( error , endpoint , values ) DCNL DCSP if ( anchor is not None ) : DCNL DCSP DCSP rv + = ( &apos; # &apos; + url _ quote ( anchor ) ) DCNL DCSP return rv
DCSP ( raw , events , picks ) = _ get _ data ( ) DCNL DCSP events = events &#91; : 10 &#93; DCNL DCSP picks = np.concatenate ( &#91; pick _ types ( raw.info , meg = True , eeg = True ) &#91; : : 22 &#93; , pick _ types ( raw.info , meg = False , eeg = False , ecg = True , eog = True ) &#93; ) DCNL DCSP picks = np.sort ( picks ) DCNL DCSP raw.load _ data ( ) .pick _ channels ( &#91; raw.ch _ names &#91; pick &#93; for pick in picks &#93; ) DCNL DCSP raw.info.normalize _ proj ( ) DCNL DCSP del picks DCNL DCSP n _ epochs = 2 DCNL DCSP raw.info &#91; &apos; lowpass &apos; &#93; = 40.0 DCNL DCSP for decim in ( 1 , 3 ) : DCNL DCSP DCSP proj _ data = Epochs ( raw , events , event _ id , tmin , tmax , proj = True , reject = reject , decim = decim ) DCNL DCSP DCSP use _ tmin = proj _ data.tmin DCNL DCSP DCSP proj _ data = proj _ data.get _ data ( ) DCNL DCSP DCSP noproj _ data = Epochs ( raw , events , event _ id , tmin , tmax , proj = False , reject = reject , decim = decim ) .get _ data ( ) DCNL DCSP DCSP assert _ equal ( proj _ data.shape , noproj _ data.shape ) DCNL DCSP DCSP assert _ equal ( proj _ data.shape &#91; 0 &#93; , n _ epochs ) DCNL DCSP DCSP for preload in ( True , False ) : DCNL DCSP DCSP DCSP for proj in ( True , False , &apos; delayed &apos; ) : DCNL DCSP DCSP DCSP DCSP for ii in range ( 3 ) : DCNL DCSP DCSP DCSP DCSP DCSP print ( decim , preload , proj , ii ) DCNL DCSP DCSP DCSP DCSP DCSP comp = ( proj _ data if ( proj is True ) else noproj _ data ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ii in ( 0 , 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP epochs = Epochs ( raw , events , event _ id , tmin , tmax , proj = proj , reject = reject , preload = preload , decim = decim ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP fake _ events = np.zeros ( ( len ( comp ) , 3 ) , int ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP fake _ events &#91; : , 0 &#93; = np.arange ( len ( comp ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP fake _ events &#91; : , 2 &#93; = 1 DCNL DCSP DCSP DCSP DCSP DCSP DCSP epochs = EpochsArray ( comp , raw.info , tmin = use _ tmin , event _ id = 1 , events = fake _ events , proj = proj ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP epochs.info &#91; &apos; sfreq &apos; &#93; / = decim DCNL DCSP DCSP DCSP DCSP DCSP DCSP assert _ equal ( len ( epochs ) , n _ epochs ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ true ( ( raw.proj is False ) ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ true ( ( epochs.proj is ( True if ( proj is True ) else False ) ) ) DCNL DCSP DCSP DCSP DCSP DCSP if ( ii = = 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP epochs.load _ data ( ) DCNL DCSP DCSP DCSP DCSP DCSP picks _ data = pick _ types ( epochs.info , meg = True , eeg = True ) DCNL DCSP DCSP DCSP DCSP DCSP evoked = epochs.average ( picks = picks _ data ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ equal ( evoked.nave , n _ epochs , epochs.drop _ log ) DCNL DCSP DCSP DCSP DCSP DCSP if ( proj is True ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP evoked.apply _ proj ( ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP assert _ true ( ( evoked.proj is False ) ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ array _ equal ( evoked.ch _ names , np.array ( epochs.ch _ names ) &#91; picks _ data &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ allclose ( evoked.times , epochs.times ) DCNL DCSP DCSP DCSP DCSP DCSP epochs _ data = epochs.get _ data ( ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ allclose ( evoked.data , epochs _ data.mean ( axis = 0 ) &#91; picks _ data &#93; , rtol = 1e-05 , atol = 1e-20 ) DCNL DCSP DCSP DCSP DCSP DCSP assert _ allclose ( epochs _ data , comp , rtol = 1e-05 , atol = 1e-20 )
DCSP cmd = ( git _ cmd _ base ( path ) + &#91; &apos; status &apos; , &apos; --porcelain &apos; &#93; ) DCNL DCSP return run _ subprocess ( cmd , stderr = None , universal _ newlines = True ) &#91; 0 &#93;
DCSP return GenericScript ( c _ instance , Live.MidiMap.MapMode.absolute , Live.MidiMap.MapMode.absolute , DEVICE _ CONTROLS , TRANSPORT _ CONTROLS , VOLUME _ CONTROLS , TRACKARM _ CONTROLS , BANK _ CONTROLS , CONTROLLER _ DESCRIPTIONS )
DCSP url = &apos; &apos;.join ( &#91; const.PAN _ URL , &apos; rest / 2.0 / services / cloud _ dl ? channel = chunlei &amp; clienttype = 0 &amp; web = 1 &apos; , &apos; &amp; method = query _ sinfo &amp; app _ id = 250528 &apos; , &apos; &amp; bdstoken = &apos; , tokens &#91; &apos; bdstoken &apos; &#93; , &apos; &amp; source _ path = &apos; , encoder.encode _ uri _ component ( source _ path ) , &apos; &amp; type = 2 &apos; , &apos; &amp; t = &apos; , util.timestamp ( ) &#93; ) DCNL DCSP req = net.urlopen ( url , headers = { &apos; Cookie &apos; : cookie.header _ output ( ) } ) DCNL DCSP if req : DCNL DCSP DCSP content = req.data DCNL DCSP DCSP return json.loads ( content.decode ( ) ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP embedding = tensor.tensor3 ( &apos; embedding &apos; , dtype = &apos; float32 &apos; ) DCNL DCSP embeddingr = embedding &#91; : : ( -1 ) &#93; DCNL DCSP x _ mask = tensor.matrix ( &apos; x _ mask &apos; , dtype = &apos; float32 &apos; ) DCNL DCSP xr _ mask = x _ mask &#91; : : ( -1 ) &#93; DCNL DCSP proj = get _ layer ( options &#91; &apos; encoder &apos; &#93; ) &#91; 1 &#93; ( tparams , embedding , options , prefix = &apos; encoder &apos; , mask = x _ mask ) DCNL DCSP projr = get _ layer ( options &#91; &apos; encoder &apos; &#93; ) &#91; 1 &#93; ( tparams , embeddingr , options , prefix = &apos; encoder _ r &apos; , mask = xr _ mask ) DCNL DCSP ctx = tensor.concatenate ( &#91; proj &#91; 0 &#93; &#91; ( -1 ) &#93; , projr &#91; 0 &#93; &#91; ( -1 ) &#93; &#93; , axis = 1 ) DCNL DCSP return ( embedding , x _ mask , ctx )
DCSP _ check _ unknown _ options ( unknown _ options ) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return _ all DCNL DCSP x0 = asarray ( x0 ) .flatten ( ) DCNL DCSP if ( x0.ndim = = 0 ) : DCNL DCSP DCSP x0.shape = ( 1 , ) DCNL DCSP if ( maxiter is None ) : DCNL DCSP DCSP maxiter = ( len ( x0 ) * 200 ) DCNL DCSP ( func _ calls , f ) = wrap _ function ( f , args ) DCNL DCSP if ( fprime is None ) : DCNL DCSP DCSP ( grad _ calls , myfprime ) = wrap _ function ( approx _ fprime , ( f , epsilon ) ) DCNL DCSP else : DCNL DCSP DCSP ( grad _ calls , myfprime ) = wrap _ function ( fprime , args ) DCNL DCSP gfk = myfprime ( x0 ) DCNL DCSP k = 0 DCNL DCSP N = len ( x0 ) DCNL DCSP I = numpy.eye ( N , dtype = int ) DCNL DCSP Hk = I DCNL DCSP old _ fval = f ( x0 ) DCNL DCSP old _ old _ fval = ( old _ fval + ( np.linalg.norm ( gfk ) / 2 ) ) DCNL DCSP xk = x0 DCNL DCSP if retall : DCNL DCSP DCSP allvecs = &#91; x0 &#93; DCNL DCSP sk = &#91; ( 2 * gtol ) &#93; DCNL DCSP warnflag = 0 DCNL DCSP gnorm = vecnorm ( gfk , ord = norm ) DCNL DCSP while ( ( gnorm &gt; gtol ) and ( k &lt; maxiter ) ) : DCNL DCSP DCSP pk = ( - numpy.dot ( Hk , gfk ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( alpha _ k , fc , gc , old _ fval , old _ old _ fval , gfkp1 ) = _ line _ search _ wolfe12 ( f , myfprime , xk , pk , gfk , old _ fval , old _ old _ fval , amin = 1e-100 , amax = 1e + 100 ) DCNL DCSP DCSP except _ LineSearchError : DCNL DCSP DCSP DCSP warnflag = 2 DCNL DCSP DCSP DCSP break DCNL DCSP DCSP xkp1 = ( xk + ( alpha _ k * pk ) ) DCNL DCSP DCSP if retall : DCNL DCSP DCSP DCSP allvecs.append ( xkp1 ) DCNL DCSP DCSP sk = ( xkp1 - xk ) DCNL DCSP DCSP xk = xkp1 DCNL DCSP DCSP if ( gfkp1 is None ) : DCNL DCSP DCSP DCSP gfkp1 = myfprime ( xkp1 ) DCNL DCSP DCSP yk = ( gfkp1 - gfk ) DCNL DCSP DCSP gfk = gfkp1 DCNL DCSP DCSP if ( callback is not None ) : DCNL DCSP DCSP DCSP callback ( xk ) DCNL DCSP DCSP k + = 1 DCNL DCSP DCSP gnorm = vecnorm ( gfk , ord = norm ) DCNL DCSP DCSP if ( gnorm &lt; = gtol ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP if ( not numpy.isfinite ( old _ fval ) ) : DCNL DCSP DCSP DCSP warnflag = 2 DCNL DCSP DCSP DCSP break DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP rhok = ( 1.0 / numpy.dot ( yk , sk ) ) DCNL DCSP DCSP except ZeroDivisionError : DCNL DCSP DCSP DCSP rhok = 1000.0 DCNL DCSP DCSP DCSP if disp : DCNL DCSP DCSP DCSP DCSP print ( &apos; Divide-by-zero DCSP encountered : DCSP rhok DCSP assumed DCSP large &apos; ) DCNL DCSP DCSP if isinf ( rhok ) : DCNL DCSP DCSP DCSP rhok = 1000.0 DCNL DCSP DCSP DCSP if disp : DCNL DCSP DCSP DCSP DCSP print ( &apos; Divide-by-zero DCSP encountered : DCSP rhok DCSP assumed DCSP large &apos; ) DCNL DCSP DCSP A1 = ( I - ( ( sk &#91; : , numpy.newaxis &#93; * yk &#91; numpy.newaxis , : &#93; ) * rhok ) ) DCNL DCSP DCSP A2 = ( I - ( ( yk &#91; : , numpy.newaxis &#93; * sk &#91; numpy.newaxis , : &#93; ) * rhok ) ) DCNL DCSP DCSP Hk = ( numpy.dot ( A1 , numpy.dot ( Hk , A2 ) ) + ( ( rhok * sk &#91; : , numpy.newaxis &#93; ) * sk &#91; numpy.newaxis , : &#93; ) ) DCNL DCSP fval = old _ fval DCNL DCSP if np.isnan ( fval ) : DCNL DCSP DCSP warnflag = 2 DCNL DCSP if ( warnflag = = 2 ) : DCNL DCSP DCSP msg = _ status _ message &#91; &apos; pr _ loss &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( ( &apos; Warning : DCSP &apos; + msg ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP elif ( k &gt; = maxiter ) : DCNL DCSP DCSP warnflag = 1 DCNL DCSP DCSP msg = _ status _ message &#91; &apos; maxiter &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( ( &apos; Warning : DCSP &apos; + msg ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP msg = _ status _ message &#91; &apos; success &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( msg ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP result = OptimizeResult ( fun = fval , jac = gfk , hess _ inv = Hk , nfev = func _ calls &#91; 0 &#93; , njev = grad _ calls &#91; 0 &#93; , status = warnflag , success = ( warnflag = = 0 ) , message = msg , x = xk , nit = k ) DCNL DCSP if retall : DCNL DCSP DCSP result &#91; &apos; allvecs &apos; &#93; = allvecs DCNL DCSP return result
DCSP action = cmd _ action ( parent , cmds.LaunchTerminal , ( lambda : utils.select _ directory ( fn ( ) ) ) , hotkeys.TERMINAL ) DCNL DCSP return action
DCSP ret = { &apos; name &apos; : DomainName , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP if ( ElasticsearchClusterConfig is None ) : DCNL DCSP DCSP ElasticsearchClusterConfig = { &apos; DedicatedMasterEnabled &apos; : False , &apos; InstanceCount &apos; : 1 , &apos; InstanceType &apos; : &apos; m3.medium.elasticsearch &apos; , &apos; ZoneAwarenessEnabled &apos; : False } DCNL DCSP if ( EBSOptions is None ) : DCNL DCSP DCSP EBSOptions = { &apos; EBSEnabled &apos; : False } DCNL DCSP if ( SnapshotOptions is None ) : DCNL DCSP DCSP SnapshotOptions = { &apos; AutomatedSnapshotStartHour &apos; : 0 } DCNL DCSP if ( AdvancedOptions is None ) : DCNL DCSP DCSP AdvancedOptions = { &apos; rest.action.multi.allow _ explicit _ index &apos; : &apos; true &apos; } DCNL DCSP if ( Tags is None ) : DCNL DCSP DCSP Tags = { } DCNL DCSP if ( ( AccessPolicies is not None ) and isinstance ( AccessPolicies , six.string _ types ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP AccessPolicies = json.loads ( AccessPolicies ) DCNL DCSP DCSP except ValueError as e : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP domain : DCSP { 0 } . &apos; .format ( e.message ) DCNL DCSP DCSP DCSP return ret DCNL DCSP r = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.exists &apos; &#93; ( DomainName = DomainName , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( &apos; error &apos; in r ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP domain : DCSP { 0 } . &apos; .format ( r &#91; &apos; error &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP return ret DCNL DCSP if ( not r.get ( &apos; exists &apos; ) ) : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Domain DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP created . &apos; .format ( DomainName ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP r = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.create &apos; &#93; ( DomainName = DomainName , ElasticsearchClusterConfig = ElasticsearchClusterConfig , EBSOptions = EBSOptions , AccessPolicies = AccessPolicies , SnapshotOptions = SnapshotOptions , AdvancedOptions = AdvancedOptions , ElasticsearchVersion = str ( ElasticsearchVersion ) , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP if ( not r.get ( &apos; created &apos; ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP domain : DCSP { 0 } . &apos; .format ( r &#91; &apos; error &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP _ describe = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.describe &apos; &#93; ( DomainName , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; old &apos; &#93; = { &apos; domain &apos; : None } DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = _ describe DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Domain DCSP { 0 } DCSP created . &apos; .format ( DomainName ) DCNL DCSP DCSP return ret DCNL DCSP ret &#91; &apos; comment &apos; &#93; = os.linesep.join ( &#91; ret &#91; &apos; comment &apos; &#93; , &apos; Domain DCSP { 0 } DCSP is DCSP present . &apos; .format ( DomainName ) &#93; ) DCNL DCSP ret &#91; &apos; changes &apos; &#93; = { } DCNL DCSP _ status = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.status &apos; &#93; ( DomainName = DomainName , region = region , key = key , keyid = keyid , profile = profile ) &#91; &apos; domain &apos; &#93; DCNL DCSP if ( _ status.get ( &apos; ElasticsearchVersion &apos; ) ! = str ( ElasticsearchVersion ) ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP update DCSP domain : DCSP version DCSP cannot DCSP be DCSP modified DCSP from DCSP { 0 } DCSP to DCSP { 1 } . &apos; .format ( _ status.get ( &apos; ElasticsearchVersion &apos; ) , str ( ElasticsearchVersion ) ) DCNL DCSP DCSP return ret DCNL DCSP _ describe = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.describe &apos; &#93; ( DomainName = DomainName , region = region , key = key , keyid = keyid , profile = profile ) &#91; &apos; domain &apos; &#93; DCNL DCSP _ describe &#91; &apos; AccessPolicies &apos; &#93; = json.loads ( _ describe &#91; &apos; AccessPolicies &apos; &#93; ) DCNL DCSP if ( not _ describe.get ( &apos; EBSOptions &apos; , { } ) .get ( &apos; EBSEnabled &apos; ) ) : DCNL DCSP DCSP opts = _ describe.get ( &apos; EBSOptions &apos; , { } ) DCNL DCSP DCSP opts.pop ( &apos; VolumeSize &apos; , None ) DCNL DCSP DCSP opts.pop ( &apos; VolumeType &apos; , None ) DCNL DCSP comm _ args = { } DCNL DCSP need _ update = False DCNL DCSP es _ opts = { &apos; ElasticsearchClusterConfig &apos; : ElasticsearchClusterConfig , &apos; EBSOptions &apos; : EBSOptions , &apos; AccessPolicies &apos; : AccessPolicies , &apos; SnapshotOptions &apos; : SnapshotOptions , &apos; AdvancedOptions &apos; : AdvancedOptions } DCNL DCSP for ( k , v ) in six.iteritems ( es _ opts ) : DCNL DCSP DCSP if ( not _ compare _ json ( v , _ describe &#91; k &#93; ) ) : DCNL DCSP DCSP DCSP need _ update = True DCNL DCSP DCSP DCSP comm _ args &#91; k &#93; = v DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; new &apos; , { } ) &#91; k &#93; = v DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; old &apos; , { } ) &#91; k &#93; = _ describe &#91; k &#93; DCNL DCSP if need _ update : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP msg = &apos; Domain DCSP { 0 } DCSP set DCSP to DCSP be DCSP modified . &apos; .format ( DomainName ) DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = os.linesep.join ( &#91; ret &#91; &apos; comment &apos; &#93; , &apos; Domain DCSP to DCSP be DCSP modified &apos; &#93; ) DCNL DCSP DCSP r = _ _ salt _ _ &#91; &apos; boto _ elasticsearch _ domain.update &apos; &#93; ( DomainName = DomainName , region = region , key = key , keyid = keyid , profile = profile , * * comm _ args ) DCNL DCSP DCSP if ( not r.get ( &apos; updated &apos; ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP update DCSP domain : DCSP { 0 } . &apos; .format ( r &#91; &apos; error &apos; &#93; ) DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { } DCNL DCSP DCSP DCSP return ret DCNL DCSP return ret
DCSP if ( name = = ROOT _ ENV _ NAME ) : DCNL DCSP DCSP return ctx.root _ dir DCNL DCSP for envs _ dir in chain ( ( ctx.envs _ dirs + ( os.getcwd ( ) , ) ) ) : DCNL DCSP DCSP prefix = join ( envs _ dir , name ) DCNL DCSP DCSP if isdir ( prefix ) : DCNL DCSP DCSP DCSP return prefix DCNL DCSP raise CondaEnvironmentNotFoundError ( name )
DCSP if ( not line.strip ( ) ) : DCNL DCSP DCSP raise exceptions.MpdNoCommand ( u &apos;No DCSP command DCSP given &apos; ) DCNL DCSP match = WORD _ RE.match ( line ) DCNL DCSP if ( not match ) : DCNL DCSP DCSP raise exceptions.MpdUnknownError ( u &apos;Invalid DCSP word DCSP character &apos; ) DCNL DCSP ( whitespace , command , remainder ) = match.groups ( ) DCNL DCSP if whitespace : DCNL DCSP DCSP raise exceptions.MpdUnknownError ( u &apos;Letter DCSP expected &apos; ) DCNL DCSP result = &#91; command &#93; DCNL DCSP while remainder : DCNL DCSP DCSP match = PARAM _ RE.match ( remainder ) DCNL DCSP DCSP if ( not match ) : DCNL DCSP DCSP DCSP msg = _ determine _ error _ message ( remainder ) DCNL DCSP DCSP DCSP raise exceptions.MpdArgError ( msg , command = command ) DCNL DCSP DCSP ( unquoted , quoted , remainder ) = match.groups ( ) DCNL DCSP DCSP result.append ( ( unquoted or UNESCAPE _ RE.sub ( u &apos; \ \ g &lt; 1 &gt; &apos; , quoted ) ) ) DCNL DCSP return result
DCSP def flatten _ tokens ( tokens ) : DCNL DCSP DCSP l = &#91; &#93; DCNL DCSP DCSP for token in tokens : DCNL DCSP DCSP DCSP if isinstance ( token , str ) : DCNL DCSP DCSP DCSP DCSP for char in token : DCNL DCSP DCSP DCSP DCSP DCSP l.append ( char ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP assert isinstance ( token , float ) DCNL DCSP DCSP DCSP DCSP l.append ( token ) DCNL DCSP DCSP return l DCNL DCSP seq1 = flatten _ tokens ( tokenize _ by _ number ( str1 ) ) DCNL DCSP seq2 = flatten _ tokens ( tokenize _ by _ number ( str2 ) ) DCNL DCSP l = min ( len ( seq1 ) , len ( seq2 ) ) DCNL DCSP i = 0 DCNL DCSP while ( i &lt; l ) : DCNL DCSP DCSP if ( isinstance ( seq1 &#91; i &#93; , float ) and isinstance ( seq2 &#91; i &#93; , string _ types ) ) : DCNL DCSP DCSP DCSP return ( -1 ) DCNL DCSP DCSP elif ( isinstance ( seq1 &#91; i &#93; , string _ types ) and isinstance ( seq2 &#91; i &#93; , float ) ) : DCNL DCSP DCSP DCSP return 1 DCNL DCSP DCSP elif ( seq1 &#91; i &#93; &lt; seq2 &#91; i &#93; ) : DCNL DCSP DCSP DCSP return ( -1 ) DCNL DCSP DCSP elif ( seq1 &#91; i &#93; &gt; seq2 &#91; i &#93; ) : DCNL DCSP DCSP DCSP return 1 DCNL DCSP DCSP i + = 1 DCNL DCSP if ( len ( seq1 ) &lt; len ( seq2 ) ) : DCNL DCSP DCSP return ( -1 ) DCNL DCSP elif ( len ( seq1 ) &gt; len ( seq2 ) ) : DCNL DCSP DCSP return 1 DCNL DCSP return 0
DCSP service _ obj = bus _ get _ object ( bus , SS _ PATH ) DCNL DCSP service _ props _ iface = dbus.Interface ( service _ obj , dbus.PROPERTIES _ IFACE ) DCNL DCSP for collection _ path in service _ props _ iface.Get ( SERVICE _ IFACE , &apos; Collections &apos; , signature = &apos; ss &apos; ) : DCNL DCSP DCSP ( yield Collection ( bus , collection _ path ) )
DCSP def err ( msg ) : DCNL DCSP DCSP formatted = ( &apos; kvToSeq DCSP warning : DCSP % s : DCSP % r &apos; % ( msg , data ) ) DCNL DCSP DCSP if strict : DCNL DCSP DCSP DCSP raise KVFormError ( formatted ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP oidutil.log ( formatted ) DCNL DCSP lines = data.split ( &apos; \ n &apos; ) DCNL DCSP if lines &#91; ( -1 ) &#93; : DCNL DCSP DCSP err ( &apos; Does DCSP not DCSP end DCSP in DCSP a DCSP newline &apos; ) DCNL DCSP else : DCNL DCSP DCSP del lines &#91; ( -1 ) &#93; DCNL DCSP pairs = &#91; &#93; DCNL DCSP line _ num = 0 DCNL DCSP for line in lines : DCNL DCSP DCSP line _ num + = 1 DCNL DCSP DCSP if ( not line.strip ( ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP pair = line.split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP if ( len ( pair ) = = 2 ) : DCNL DCSP DCSP DCSP ( k , v ) = pair DCNL DCSP DCSP DCSP k _ s = k.strip ( ) DCNL DCSP DCSP DCSP if ( k _ s ! = k ) : DCNL DCSP DCSP DCSP DCSP fmt = &apos; In DCSP line DCSP % d , DCSP ignoring DCSP leading DCSP or DCSP trailing DCSP whitespace DCSP in DCSP key DCSP % r &apos; DCNL DCSP DCSP DCSP DCSP err ( ( fmt % ( line _ num , k ) ) ) DCNL DCSP DCSP DCSP if ( not k _ s ) : DCNL DCSP DCSP DCSP DCSP err ( ( &apos; In DCSP line DCSP % d , DCSP got DCSP empty DCSP key &apos; % ( line _ num , ) ) ) DCNL DCSP DCSP DCSP v _ s = v.strip ( ) DCNL DCSP DCSP DCSP if ( v _ s ! = v ) : DCNL DCSP DCSP DCSP DCSP fmt = &apos; In DCSP line DCSP % d , DCSP ignoring DCSP leading DCSP or DCSP trailing DCSP whitespace DCSP in DCSP value DCSP % r &apos; DCNL DCSP DCSP DCSP DCSP err ( ( fmt % ( line _ num , v ) ) ) DCNL DCSP DCSP DCSP pairs.append ( ( k _ s.decode ( &apos; UTF8 &apos; ) , v _ s.decode ( &apos; UTF8 &apos; ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP err ( ( &apos; Line DCSP % d DCSP does DCSP not DCSP contain DCSP a DCSP colon &apos; % line _ num ) ) DCNL DCSP return pairs
DCSP return ( SIGNATURE in source )
DCSP pass
DCSP row _ count = 0 DCNL DCSP for row in csv.reader ( open ( file _ name ) ) : DCNL DCSP DCSP row _ count + = 1 DCNL DCSP if ( row _ limit &gt; row _ count ) : DCNL DCSP DCSP parser.error ( &quot; The DCSP &apos; row _ count &apos; DCSP of DCSP &apos; { } &apos; DCSP is DCSP &gt; DCSP the DCSP number DCSP of DCSP rows DCSP in DCSP &apos; { } &apos; ! &quot; .format ( row _ limit , file _ name ) ) DCNL DCSP DCSP sys.exit ( 1 )
DCSP return parse _ object _ id ( &apos; certificates / issuers &apos; , id )
DCSP return int ( qsub _ out.split ( ) &#91; 2 &#93; )
DCSP raise falcon.HTTPNotFound ( )
DCSP if isinstance ( txt , six.string _ types ) : DCNL DCSP DCSP return txt.replace ( &apos; \ x1b &apos; , &apos; ? &apos; ) DCNL DCSP else : DCNL DCSP DCSP return txt
DCSP var _ use _ map = { } DCNL DCSP var _ def _ map = { } DCNL DCSP for ( offset , ir _ block ) in blocks.items ( ) : DCNL DCSP DCSP var _ use _ map &#91; offset &#93; = use _ set = set ( ) DCNL DCSP DCSP var _ def _ map &#91; offset &#93; = def _ set = set ( ) DCNL DCSP DCSP for stmt in ir _ block.body : DCNL DCSP DCSP DCSP if isinstance ( stmt , ir.Assign ) : DCNL DCSP DCSP DCSP DCSP if isinstance ( stmt.value , ir.Inst ) : DCNL DCSP DCSP DCSP DCSP DCSP rhs _ set = set ( ( var.name for var in stmt.value.list _ vars ( ) ) ) DCNL DCSP DCSP DCSP DCSP elif isinstance ( stmt.value , ir.Var ) : DCNL DCSP DCSP DCSP DCSP DCSP rhs _ set = set ( &#91; stmt.value.name &#93; ) DCNL DCSP DCSP DCSP DCSP elif isinstance ( stmt.value , ( ir.Arg , ir.Const , ir.Global , ir.FreeVar ) ) : DCNL DCSP DCSP DCSP DCSP DCSP rhs _ set = ( ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP raise AssertionError ( &apos; unreachable &apos; , type ( stmt.value ) ) DCNL DCSP DCSP DCSP DCSP if ( stmt.target.name not in rhs _ set ) : DCNL DCSP DCSP DCSP DCSP DCSP def _ set.add ( stmt.target.name ) DCNL DCSP DCSP DCSP for var in stmt.list _ vars ( ) : DCNL DCSP DCSP DCSP DCSP if ( var.name not in def _ set ) : DCNL DCSP DCSP DCSP DCSP DCSP use _ set.add ( var.name ) DCNL DCSP return _ use _ defs _ result ( usemap = var _ use _ map , defmap = var _ def _ map )
DCSP UserModel = get _ user _ model ( ) DCNL DCSP assert ( ( uidb64 is not None ) and ( token is not None ) ) DCNL DCSP if ( post _ reset _ redirect is None ) : DCNL DCSP DCSP post _ reset _ redirect = reverse ( &apos; password _ reset _ complete &apos; ) DCNL DCSP else : DCNL DCSP DCSP post _ reset _ redirect = resolve _ url ( post _ reset _ redirect ) DCNL DCSP try : DCNL DCSP DCSP uid = urlsafe _ base64 _ decode ( uidb64 ) DCNL DCSP DCSP user = UserModel . _ default _ manager.get ( pk = uid ) DCNL DCSP except ( TypeError , ValueError , OverflowError , UserModel.DoesNotExist ) : DCNL DCSP DCSP user = None DCNL DCSP if ( ( user is not None ) and token _ generator.check _ token ( user , token ) ) : DCNL DCSP DCSP validlink = True DCNL DCSP DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP DCSP form = set _ password _ form ( user , request.POST ) DCNL DCSP DCSP DCSP if form.is _ valid ( ) : DCNL DCSP DCSP DCSP DCSP form.save ( ) DCNL DCSP DCSP DCSP DCSP return HttpResponseRedirect ( post _ reset _ redirect ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP form = set _ password _ form ( None ) DCNL DCSP else : DCNL DCSP DCSP validlink = False DCNL DCSP DCSP form = None DCNL DCSP context = { &apos; form &apos; : form , &apos; validlink &apos; : validlink } DCNL DCSP if ( extra _ context is not None ) : DCNL DCSP DCSP context.update ( extra _ context ) DCNL DCSP return TemplateResponse ( request , template _ name , context , current _ app = current _ app )
DCSP try : DCNL DCSP DCSP _ polHandle = win32security.LsaOpenPolicy ( None , win32security.POLICY _ ALL _ ACCESS ) DCNL DCSP DCSP user _ rights _ list = &#91; user _ right &#93; DCNL DCSP DCSP _ ret = win32security.LsaRemoveAccountRights ( _ polHandle , sidObject , False , user _ rights _ list ) DCNL DCSP DCSP return True DCNL DCSP except Exception as e : DCNL DCSP DCSP log.error ( &apos; Error DCSP attempting DCSP to DCSP delete DCSP account DCSP right , DCSP exception DCSP was DCSP { 0 } &apos; .format ( e ) ) DCNL DCSP DCSP return False
DCSP columns = &#91; c.name for c in model . _ _ table _ _ .columns &#93; DCNL DCSP return dict ( ( ( k , v ) for ( k , v ) in six.iteritems ( data ) if ( ( k in columns ) or isinstance ( getattr ( model , k , None ) , associationproxy.AssociationProxy ) ) ) )
DCSP request &#91; &apos; user _ id &apos; &#93; = user _ id DCNL DCSP ( yield Activity.VerifyActivityId ( client , user _ id , device _ id , request &#91; &apos; activity &apos; &#93; &#91; &apos; activity _ id &apos; &#93; ) ) DCNL DCSP num _ photos = 0 DCNL DCSP for ep _ dict in request &#91; &apos; episodes &apos; &#93; : DCNL DCSP DCSP ( yield Episode.VerifyEpisodeId ( client , user _ id , device _ id , ep _ dict &#91; &apos; new _ episode _ id &apos; &#93; ) ) DCNL DCSP DCSP num _ photos + = len ( ep _ dict &#91; &apos; photo _ ids &apos; &#93; ) DCNL DCSP ( yield gen.Task ( Operation.CreateAndExecute , client , user _ id , device _ id , &apos; ShareExistingOperation.Execute &apos; , request ) ) DCNL DCSP logging.info ( ( &apos; SHARE DCSP EXISTING : DCSP user : DCSP % d , DCSP device : DCSP % d , DCSP viewpoint : DCSP % s , DCSP % d DCSP episodes , DCSP % d DCSP photos &apos; % ( user _ id , device _ id , request &#91; &apos; viewpoint _ id &apos; &#93; , len ( request &#91; &apos; episodes &apos; &#93; ) , num _ photos ) ) ) DCNL DCSP raise gen.Return ( { } )
DCSP global DATA DCNL DCSP resource _ type _ values = copy.deepcopy ( values ) DCNL DCSP resource _ type _ name = resource _ type _ values &#91; &apos; name &apos; &#93; DCNL DCSP allowed _ attrubites = &#91; &apos; name &apos; , &apos; protected &apos; &#93; DCNL DCSP for resource _ type in DATA &#91; &apos; metadef _ resource _ types &apos; &#93; : DCNL DCSP DCSP if ( resource _ type &#91; &apos; name &apos; &#93; = = resource _ type _ name ) : DCNL DCSP DCSP DCSP raise exception.Duplicate ( ) DCNL DCSP incorrect _ keys = ( set ( resource _ type _ values.keys ( ) ) - set ( allowed _ attrubites ) ) DCNL DCSP if incorrect _ keys : DCNL DCSP DCSP raise exception.Invalid ( ( &apos; The DCSP keys DCSP % s DCSP are DCSP not DCSP valid &apos; % str ( incorrect _ keys ) ) ) DCNL DCSP resource _ type = _ format _ resource _ type ( resource _ type _ values ) DCNL DCSP DATA &#91; &apos; metadef _ resource _ types &apos; &#93; .append ( resource _ type ) DCNL DCSP return resource _ type
DCSP if ( get _ configured _ provider ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP if ( get _ dependencies ( ) is False ) : DCNL DCSP DCSP return False DCNL DCSP return _ _ virtualname _ _
DCSP ( output , pub ) = publish _ programmatically ( source _ class = io.StringInput , source = source , source _ path = source _ path , destination _ class = io.StringOutput , destination = None , destination _ path = destination _ path , reader = reader , reader _ name = reader _ name , parser = parser , parser _ name = parser _ name , writer = writer , writer _ name = writer _ name , settings = settings , settings _ spec = settings _ spec , settings _ overrides = settings _ overrides , config _ section = config _ section , enable _ exit _ status = enable _ exit _ status ) DCNL DCSP return output
DCSP @ functools.wraps ( f ) DCNL DCSP def NewFunction ( self , * args , * * kw ) : DCNL DCSP DCSP with self.lock : DCNL DCSP DCSP DCSP return f ( self , * args , * * kw ) DCNL DCSP return NewFunction
DCSP if ( opts &#91; &apos; root _ dir &apos; &#93; is None ) : DCNL DCSP DCSP root _ dir = salt.syspaths.ROOT _ DIR DCNL DCSP else : DCNL DCSP DCSP root _ dir = opts &#91; &apos; root _ dir &apos; &#93; DCNL DCSP config _ dir = salt.syspaths.CONFIG _ DIR DCNL DCSP if config _ dir.startswith ( salt.syspaths.ROOT _ DIR ) : DCNL DCSP DCSP config _ dir = config _ dir.split ( salt.syspaths.ROOT _ DIR , 1 ) &#91; ( -1 ) &#93; DCNL DCSP id _ cache = os.path.join ( root _ dir , config _ dir.lstrip ( os.path.sep ) , &apos; minion _ id &apos; ) DCNL DCSP if opts.get ( &apos; minion _ id _ caching &apos; , True ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP with salt.utils.fopen ( id _ cache ) as idf : DCNL DCSP DCSP DCSP DCSP name = idf.readline ( ) .strip ( ) DCNL DCSP DCSP DCSP DCSP bname = salt.utils.to _ bytes ( name ) DCNL DCSP DCSP DCSP DCSP if bname.startswith ( codecs.BOM ) : DCNL DCSP DCSP DCSP DCSP DCSP name = salt.utils.to _ str ( bname.replace ( codecs.BOM , &apos; &apos; , 1 ) ) DCNL DCSP DCSP DCSP if ( name and ( name ! = &apos; localhost &apos; ) ) : DCNL DCSP DCSP DCSP DCSP log.debug ( &apos; Using DCSP cached DCSP minion DCSP ID DCSP from DCSP { 0 } : DCSP { 1 } &apos; .format ( id _ cache , name ) ) DCNL DCSP DCSP DCSP DCSP return ( name , False ) DCNL DCSP DCSP except ( IOError , OSError ) : DCNL DCSP DCSP DCSP pass DCNL DCSP if ( ( &apos; _ _ role &apos; in opts ) and ( opts.get ( &apos; _ _ role &apos; ) = = &apos; minion &apos; ) ) : DCNL DCSP DCSP log.debug ( &apos; Guessing DCSP ID . DCSP The DCSP id DCSP can DCSP be DCSP explicitly DCSP set DCSP in DCSP { 0 } &apos; .format ( os.path.join ( salt.syspaths.CONFIG _ DIR , &apos; minion &apos; ) ) ) DCNL DCSP newid = salt.utils.network.generate _ minion _ id ( ) DCNL DCSP if ( ( &apos; _ _ role &apos; in opts ) and ( opts.get ( &apos; _ _ role &apos; ) = = &apos; minion &apos; ) ) : DCNL DCSP DCSP log.debug ( &apos; Found DCSP minion DCSP id DCSP from DCSP generate _ minion _ id ( ) : DCSP { 0 } &apos; .format ( newid ) ) DCNL DCSP if ( cache _ minion _ id and opts.get ( &apos; minion _ id _ caching &apos; , True ) ) : DCNL DCSP DCSP _ cache _ id ( newid , id _ cache ) DCNL DCSP is _ ipv4 = salt.utils.network.is _ ipv4 ( newid ) DCNL DCSP return ( newid , is _ ipv4 )
DCSP return ( ( r / pi ) * 180 )
DCSP match = re.search ( &apos; &quot; ( . * ) &quot; &apos; , response ) DCNL DCSP if match : DCNL DCSP DCSP return match.groups ( ) &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP return None
DCSP loss = tf.nn.seq2seq.sequence _ loss _ by _ example ( &#91; logits &#93; , &#91; tf.reshape ( target _ seqs , &#91; ( -1 ) &#93; ) &#93; , &#91; tf.ones ( &#91; ( batch _ size * num _ steps ) &#93; ) &#93; ) DCNL DCSP cost = ( tf.reduce _ sum ( loss ) / batch _ size ) DCNL DCSP return cost
DCSP @ functools.wraps ( f ) DCNL DCSP def wrapper ( * args , * * kwds ) : DCNL DCSP DCSP if ( AES is None ) : DCNL DCSP DCSP DCSP raise CryptoUnavailableError ( ) DCNL DCSP DCSP return f ( * args , * * kwds ) DCNL DCSP return wrapper
DCSP x = ColorArray ( &#91; &apos; r &apos; , &apos; g &apos; , &apos; b &apos; &#93; ) DCNL DCSP assert _ array _ equal ( x.rgb , np.eye ( 3 ) ) DCNL DCSP assert isinstance ( x &#91; 0 &#93; , ColorArray ) DCNL DCSP assert isinstance ( x &#91; : &#93; , ColorArray ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; : &#93; , x &#91; : &#93; .rgba ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 0 &#93; , x &#91; 0 &#93; .rgba.squeeze ( ) ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 1 : 3 &#93; , x &#91; 1 : 3 &#93; .rgba ) DCNL DCSP assert _ raises ( ValueError , x . _ _ getitem _ _ , ( 0 , 1 ) ) DCNL DCSP x &#91; 0 &#93; = 0 DCNL DCSP assert _ array _ equal ( x.rgba &#91; 0 , : &#93; , np.zeros ( 4 ) ) DCNL DCSP assert _ array _ equal ( x.rgba , x &#91; : &#93; .rgba ) DCNL DCSP x &#91; 1 &#93; = 1 DCNL DCSP assert _ array _ equal ( x &#91; 1 &#93; .rgba , np.ones ( ( 1 , 4 ) ) ) DCNL DCSP x &#91; : &#93; = 0.5 DCNL DCSP assert _ array _ equal ( x.rgba , ( 0.5 * np.ones ( ( 3 , 4 ) ) ) ) DCNL DCSP assert _ raises ( ValueError , x . _ _ setitem _ _ , ( 0 , 1 ) , 0 ) DCNL DCSP x = ColorArray ( color _ space = &apos; hsv &apos; , color = &#91; ( 0 , 0 , 1 ) , ( 0 , 0 , 0.5 ) , ( 0 , 0 , 0 ) &#93; ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 0 &#93; , &#91; 1 , 1 , 1 , 1 &#93; ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 1 &#93; , &#91; 0.5 , 0.5 , 0.5 , 1 &#93; ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 2 &#93; , &#91; 0 , 0 , 0 , 1 &#93; ) DCNL DCSP x = ColorArray ( color _ space = &apos; hsv &apos; ) DCNL DCSP assert _ array _ equal ( x.rgba &#91; 0 &#93; , &#91; 0 , 0 , 0 , 1 &#93; )
DCSP context = SSLContext ( ( ssl _ version or ssl.PROTOCOL _ SSLv23 ) ) DCNL DCSP cert _ reqs = ( ssl.CERT _ REQUIRED if ( cert _ reqs is None ) else cert _ reqs ) DCNL DCSP if ( options is None ) : DCNL DCSP DCSP options = 0 DCNL DCSP DCSP options &#124; = OP _ NO _ SSLv2 DCNL DCSP DCSP options &#124; = OP _ NO _ SSLv3 DCNL DCSP DCSP options &#124; = OP _ NO _ COMPRESSION DCNL DCSP context.options &#124; = options DCNL DCSP if getattr ( context , &apos; supports _ set _ ciphers &apos; , True ) : DCNL DCSP DCSP context.set _ ciphers ( ( ciphers or DEFAULT _ CIPHERS ) ) DCNL DCSP context.verify _ mode = cert _ reqs DCNL DCSP if ( getattr ( context , &apos; check _ hostname &apos; , None ) is not None ) : DCNL DCSP DCSP context.check _ hostname = False DCNL DCSP return context
DCSP for info in infos : DCNL DCSP DCSP info . _ check _ consistency ( ) DCNL DCSP if ( force _ update _ to _ first is True ) : DCNL DCSP DCSP infos = deepcopy ( infos ) DCNL DCSP DCSP _ force _ update _ info ( infos &#91; 0 &#93; , infos &#91; 1 : &#93; ) DCNL DCSP info = Info ( ) DCNL DCSP info &#91; &apos; chs &apos; &#93; = &#91; &#93; DCNL DCSP for this _ info in infos : DCNL DCSP DCSP info &#91; &apos; chs &apos; &#93; .extend ( this _ info &#91; &apos; chs &apos; &#93; ) DCNL DCSP info . _ update _ redundant ( ) DCNL DCSP duplicates = set ( &#91; ch for ch in info &#91; &apos; ch _ names &apos; &#93; if ( info &#91; &apos; ch _ names &apos; &#93; .count ( ch ) &gt; 1 ) &#93; ) DCNL DCSP if ( len ( duplicates ) &gt; 0 ) : DCNL DCSP DCSP msg = ( &apos; The DCSP following DCSP channels DCSP are DCSP present DCSP in DCSP more DCSP than DCSP one DCSP input DCSP measurement DCSP info DCSP objects : DCSP % s &apos; % list ( duplicates ) ) DCNL DCSP DCSP raise ValueError ( msg ) DCNL DCSP transforms = &#91; &apos; ctf _ head _ t &apos; , &apos; dev _ head _ t &apos; , &apos; dev _ ctf _ t &apos; &#93; DCNL DCSP for trans _ name in transforms : DCNL DCSP DCSP trans = &#91; i &#91; trans _ name &#93; for i in infos if i &#91; trans _ name &#93; &#93; DCNL DCSP DCSP if ( len ( trans ) = = 0 ) : DCNL DCSP DCSP DCSP info &#91; trans _ name &#93; = None DCNL DCSP DCSP elif ( len ( trans ) = = 1 ) : DCNL DCSP DCSP DCSP info &#91; trans _ name &#93; = trans &#91; 0 &#93; DCNL DCSP DCSP elif all ( ( ( np.all ( ( trans &#91; 0 &#93; &#91; &apos; trans &apos; &#93; = = x &#91; &apos; trans &apos; &#93; ) ) and ( trans &#91; 0 &#93; &#91; &apos; from &apos; &#93; = = x &#91; &apos; from &apos; &#93; ) and ( trans &#91; 0 &#93; &#91; &apos; to &apos; &#93; = = x &#91; &apos; to &apos; &#93; ) ) for x in trans &#91; 1 : &#93; ) ) : DCNL DCSP DCSP DCSP info &#91; trans _ name &#93; = trans &#91; 0 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP msg = ( &apos; Measurement DCSP infos DCSP provide DCSP mutually DCSP inconsistent DCSP % s &apos; % trans _ name ) DCNL DCSP DCSP DCSP raise ValueError ( msg ) DCNL DCSP kit _ sys _ ids = &#91; i &#91; &apos; kit _ system _ id &apos; &#93; for i in infos if i &#91; &apos; kit _ system _ id &apos; &#93; &#93; DCNL DCSP if ( len ( kit _ sys _ ids ) = = 0 ) : DCNL DCSP DCSP info &#91; &apos; kit _ system _ id &apos; &#93; = None DCNL DCSP elif ( len ( set ( kit _ sys _ ids ) ) = = 1 ) : DCNL DCSP DCSP info &#91; &apos; kit _ system _ id &apos; &#93; = kit _ sys _ ids &#91; 0 &#93; DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Trying DCSP to DCSP merge DCSP channels DCSP from DCSP different DCSP KIT DCSP systems &apos; ) DCNL DCSP other _ fields = &#91; &apos; acq _ pars &apos; , &apos; acq _ stim &apos; , &apos; bads &apos; , &apos; buffer _ size _ sec &apos; , &apos; comps &apos; , &apos; custom _ ref _ applied &apos; , &apos; description &apos; , &apos; dig &apos; , &apos; experimenter &apos; , &apos; file _ id &apos; , &apos; highpass &apos; , &apos; hpi _ results &apos; , &apos; hpi _ meas &apos; , &apos; hpi _ subsystem &apos; , &apos; events &apos; , &apos; line _ freq &apos; , &apos; lowpass &apos; , &apos; meas _ date &apos; , &apos; meas _ id &apos; , &apos; proj _ id &apos; , &apos; proj _ name &apos; , &apos; projs &apos; , &apos; sfreq &apos; , &apos; subject _ info &apos; , &apos; sfreq &apos; , &apos; xplotter _ layout &apos; &#93; DCNL DCSP for k in other _ fields : DCNL DCSP DCSP info &#91; k &#93; = _ merge _ dict _ values ( infos , k ) DCNL DCSP info . _ check _ consistency ( ) DCNL DCSP return info
DCSP block _ url = &apos; &apos; DCNL DCSP if ( len ( xblock _ type _ set ) &gt; 0 ) : DCNL DCSP DCSP block _ url + = &apos; &amp; all _ blocks = true &amp; block _ counts = &apos; DCNL DCSP DCSP for ( index , block _ type ) in enumerate ( xblock _ type _ set ) : DCNL DCSP DCSP DCSP block _ url + = block _ type DCNL DCSP DCSP DCSP if ( index &lt; ( len ( xblock _ type _ set ) - 1 ) ) : DCNL DCSP DCSP DCSP DCSP block _ url + = &apos; , &apos; DCNL DCSP return block _ url
DCSP from frappe.utils.nestedset import get _ root _ of DCNL DCSP country = frappe.db.get _ default ( u &apos;country &apos; ) DCNL DCSP root _ territory = get _ root _ of ( u &apos;Territory &apos; ) DCNL DCSP for name in ( country , _ ( u &apos;Rest DCSP Of DCSP The DCSP World &apos; ) ) : DCNL DCSP DCSP if ( name and ( not frappe.db.exists ( u &apos;Territory &apos; , name ) ) ) : DCNL DCSP DCSP DCSP frappe.get _ doc ( { u &apos;doctype &apos; : u &apos;Territory &apos; , u &apos;territory _ name &apos; : name.replace ( u &quot; &apos; &quot; , u &apos; &apos; ) , u &apos;parent _ territory &apos; : root _ territory , u &apos;is _ group &apos; : u &apos;No &apos; } ) .insert ( )
DCSP shortversion = get _ sympy _ short _ version ( ) DCNL DCSP htmltable = table ( ) DCNL DCSP out = &apos; See DCSP https : / / github.com / sympy / sympy / wiki / release-notes-for- { shortversion } DCSP for DCSP the DCSP release DCSP notes . \ n \ n { htmltable } \ n \ n * * Note * * : DCSP Do DCSP not DCSP download DCSP the DCSP * * Source DCSP code DCSP ( zip ) * * DCSP or DCSP the DCSP * * Source DCSP code DCSP ( tar.gz ) * * \ nfiles DCSP below . \ n &apos; DCNL DCSP out = out.format ( shortversion = shortversion , htmltable = htmltable ) DCNL DCSP print ( blue ( &apos; Here DCSP are DCSP the DCSP release DCSP notes DCSP to DCSP copy DCSP into DCSP the DCSP GitHub DCSP release DCSP Markdown DCSP form : &apos; , bold = True ) ) DCNL DCSP print ( ) DCNL DCSP print ( out ) DCNL DCSP return out
DCSP module.custom _ desired _ config = { &apos; addr _ family &apos; : None , &apos; auto &apos; : True , &apos; config &apos; : { } , &apos; name &apos; : module.params.get ( &apos; name &apos; ) } DCNL DCSP build _ addr _ method ( module ) DCNL DCSP build _ address ( module ) DCNL DCSP build _ vids ( module ) DCNL DCSP build _ pvid ( module ) DCNL DCSP build _ speed ( module ) DCNL DCSP build _ alias _ name ( module ) DCNL DCSP build _ vrr ( module ) DCNL DCSP for _ attr in &#91; &apos; mtu &apos; , &apos; mstpctl _ portnetwork &apos; , &apos; mstpctl _ portadminedge &apos; , &apos; mstpctl _ bpduguard &apos; , &apos; clagd _ enable &apos; , &apos; clagd _ priority &apos; , &apos; clagd _ peer _ ip &apos; , &apos; clagd _ sys _ mac &apos; , &apos; clagd _ args &apos; &#93; : DCNL DCSP DCSP build _ generic _ attr ( module , _ attr )
DCSP if ( type ( id _ token ) = = bytes ) : DCNL DCSP DCSP segments = id _ token.split ( &apos; .&apos; ) DCNL DCSP else : DCNL DCSP DCSP segments = id _ token.split ( u &apos; . &apos; ) DCNL DCSP if ( len ( segments ) ! = 3 ) : DCNL DCSP DCSP raise VerifyJwtTokenError ( &apos; Wrong DCSP number DCSP of DCSP segments DCSP in DCSP token : DCSP { 0 } &apos; .format ( id _ token ) ) DCNL DCSP return json.loads ( _ helpers . _ from _ bytes ( _ helpers . _ urlsafe _ b64decode ( segments &#91; 1 &#93; ) ) )
DCSP log _ root = logging.getLogger ( None ) .logger DCNL DCSP to _ replace = &#91; h for h in log _ root.handlers if isinstance ( h , handlers.WatchedFileHandler ) &#93; DCNL DCSP for handler in to _ replace : DCNL DCSP DCSP new _ handler = std _ logging.FileHandler ( handler.baseFilename , mode = handler.mode , encoding = handler.encoding ) DCNL DCSP DCSP log _ root.removeHandler ( handler ) DCNL DCSP DCSP log _ root.addHandler ( new _ handler )
DCSP import zlib DCNL DCSP ( yield &apos; \ x1f \ x8b &apos; ) DCNL DCSP ( yield &apos; \ x08 &apos; ) DCNL DCSP ( yield &apos; \ x00 &apos; ) DCNL DCSP ( yield struct.pack ( &apos; &lt; L &apos; , ( int ( time.time ( ) ) &amp; 4294967295L ) ) ) DCNL DCSP ( yield &apos; \ x02 &apos; ) DCNL DCSP ( yield &apos; \ xff &apos; ) DCNL DCSP crc = zlib.crc32 ( &apos; &apos; ) DCNL DCSP size = 0 DCNL DCSP zobj = zlib.compressobj ( compress _ level , zlib.DEFLATED , ( - zlib.MAX _ WBITS ) , zlib.DEF _ MEM _ LEVEL , 0 ) DCNL DCSP for line in body : DCNL DCSP DCSP size + = len ( line ) DCNL DCSP DCSP crc = zlib.crc32 ( line , crc ) DCNL DCSP DCSP ( yield zobj.compress ( line ) ) DCNL DCSP ( yield zobj.flush ( ) ) DCNL DCSP ( yield struct.pack ( &apos; &lt; L &apos; , ( crc &amp; 4294967295L ) ) ) DCNL DCSP ( yield struct.pack ( &apos; &lt; L &apos; , ( size &amp; 4294967295L ) ) )
DCSP answer = &#91; &#93; DCNL DCSP alignment _ len = alignment.get _ alignment _ length ( ) DCNL DCSP rec _ count = len ( alignment ) DCNL DCSP if ( rec _ count &lt; vertical _ threshold ) : DCNL DCSP DCSP for record in alignment : DCNL DCSP DCSP DCSP answer.append ( ( &apos; % s % s DCSP % s &apos; % ( index , str _ summary ( str ( record.seq ) ) , record.id ) ) ) DCNL DCSP else : DCNL DCSP DCSP for i in range ( min ( 5 , alignment _ len ) ) : DCNL DCSP DCSP DCSP answer.append ( ( ( index + str _ summary ( alignment &#91; : , i &#93; ) ) + ( &apos; DCSP alignment DCSP column DCSP % i &apos; % i ) ) ) DCNL DCSP DCSP if ( alignment _ len &gt; 5 ) : DCNL DCSP DCSP DCSP i = ( alignment _ len - 1 ) DCNL DCSP DCSP DCSP answer.append ( ( ( index + str _ summary ( ( &apos; &#124; &apos; * rec _ count ) ) ) + &apos; DCSP ... &apos; ) ) DCNL DCSP DCSP DCSP answer.append ( ( ( index + str _ summary ( alignment &#91; : , i &#93; ) ) + ( &apos; DCSP alignment DCSP column DCSP % i &apos; % i ) ) ) DCNL DCSP return &apos; \ n &apos; .join ( answer )
DCSP for ( module _ name , module _ metadata ) in REQUIRED _ MODULE _ METADATA : DCNL DCSP DCSP if ( not ( is _ imbalanced _ dataset _ installing and ( not module _ metadata &#91; &apos; required _ at _ installation &apos; &#93; ) ) ) : DCNL DCSP DCSP DCSP _ import _ module _ with _ version _ check ( module _ name = module _ name , minimum _ version = module _ metadata &#91; &apos; min _ version &apos; &#93; , install _ info = module _ metadata.get ( &apos; install _ info &apos; ) )
DCSP import pyowm DCNL DCSP longitude = config.get ( CONF _ LONGITUDE , round ( hass.config.longitude , 5 ) ) DCNL DCSP latitude = config.get ( CONF _ LATITUDE , round ( hass.config.latitude , 5 ) ) DCNL DCSP name = config.get ( CONF _ NAME ) DCNL DCSP try : DCNL DCSP DCSP owm = pyowm.OWM ( config.get ( CONF _ API _ KEY ) ) DCNL DCSP except pyowm.exceptions.api _ call _ error.APICallError : DCNL DCSP DCSP _ LOGGER.error ( &apos; Error DCSP while DCSP connecting DCSP to DCSP OpenWeatherMap &apos; ) DCNL DCSP DCSP return False DCNL DCSP data = WeatherData ( owm , latitude , longitude ) DCNL DCSP add _ devices ( &#91; OpenWeatherMapWeather ( name , data , hass.config.units.temperature _ unit ) &#93; , True )
DCSP cmd = &apos; { 0 } DCSP { 1 } DCSP onerestart &apos; .format ( _ cmd ( jail ) , name ) DCNL DCSP return ( not _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( cmd , python _ shell = False ) )
DCSP t = table.Table ( &#91; &#91; &apos; Hello &apos; , &apos; World &apos; &#93; &#93; , dtype = &#91; &apos; S10 &apos; &#93; ) DCNL DCSP out = StringIO ( ) DCNL DCSP ascii.write ( t , out , fast _ writer = fast _ writer ) DCNL DCSP assert ( out.getvalue ( ) .splitlines ( ) = = &#91; &apos; col0 &apos; , &apos; Hello &apos; , &apos; World &apos; &#93; )
DCSP try : DCNL DCSP DCSP return _ ENCODERS &#91; type ( value ) &#93; ( name , value , check _ keys , opts ) DCNL DCSP except KeyError : DCNL DCSP DCSP pass DCNL DCSP marker = getattr ( value , &apos; _ type _ marker &apos; , None ) DCNL DCSP if ( isinstance ( marker , int ) and ( marker in _ MARKERS ) ) : DCNL DCSP DCSP func = _ MARKERS &#91; marker &#93; DCNL DCSP DCSP _ ENCODERS &#91; type ( value ) &#93; = func DCNL DCSP DCSP return func ( name , value , check _ keys , opts ) DCNL DCSP for base in _ ENCODERS : DCNL DCSP DCSP if isinstance ( value , base ) : DCNL DCSP DCSP DCSP func = _ ENCODERS &#91; base &#93; DCNL DCSP DCSP DCSP _ ENCODERS &#91; type ( value ) &#93; = func DCNL DCSP DCSP DCSP return func ( name , value , check _ keys , opts ) DCNL DCSP raise InvalidDocument ( ( &apos; cannot DCSP convert DCSP value DCSP of DCSP type DCSP % s DCSP to DCSP bson &apos; % type ( value ) ) )
DCSP if ( derivation = = None ) : DCNL DCSP DCSP derivation = ExtrudeDerivation ( elementNode ) DCNL DCSP if ( len ( euclidean.getConcatenatedList ( derivation.target ) ) = = 0 ) : DCNL DCSP DCSP print &apos; Warning , DCSP in DCSP extrude DCSP there DCSP are DCSP no DCSP paths . &apos; DCNL DCSP DCSP print elementNode.attributes DCNL DCSP DCSP return None DCNL DCSP return getGeometryOutputByLoops ( derivation , derivation.target )
DCSP range _ = ( ( b - a ) - 1 ) DCNL DCSP bits = size ( range _ ) DCNL DCSP value = getRandomInteger ( bits , randfunc ) DCNL DCSP while ( value &gt; range _ ) : DCNL DCSP DCSP value = getRandomInteger ( bits , randfunc ) DCNL DCSP return ( a + value )
DCSP root = _ convert _ tree ( beautiful _ soup _ tree , makeelement ) DCNL DCSP children = root.getchildren ( ) DCNL DCSP for child in children : DCNL DCSP DCSP root.remove ( child ) DCNL DCSP return children
DCSP parser.add _ option ( &apos; --retain _ upload _ dir &apos; , action = &apos; store _ true &apos; , dest = &apos; retain _ upload _ dir &apos; , default = False , help = &apos; Do DCSP not DCSP delete DCSP temporary DCSP ( staging ) DCSP directory DCSP used DCSP in DCSP uploading DCSP Java DCSP apps &apos; ) DCNL DCSP parser.add _ option ( &apos; --no _ symlinks &apos; , action = &apos; store _ true &apos; , dest = &apos; no _ symlinks &apos; , default = False , help = &apos; Do DCSP not DCSP use DCSP symbolic DCSP links DCSP when DCSP making DCSP the DCSP temporary DCSP ( staging ) DCSP directory DCSP for DCSP uploading DCSP Java DCSP apps &apos; ) DCNL DCSP parser.add _ option ( &apos; --compile _ encoding &apos; , action = &apos; store &apos; , dest = &apos; compile _ encoding &apos; , default = &apos; UTF-8 &apos; , help = &apos; Set DCSP the DCSP encoding DCSP to DCSP be DCSP used DCSP when DCSP compiling DCSP Java DCSP source DCSP files DCSP ( default DCSP &quot; UTF-8 &quot; ) . &apos; ) DCNL DCSP parser.add _ option ( &apos; --disable _ jar _ jsps &apos; , action = &apos; store _ false &apos; , dest = &apos; jar _ jsps &apos; , default = True , help = &apos; Do DCSP not DCSP jar DCSP the DCSP classes DCSP generated DCSP from DCSP JSPs . &apos; ) DCNL DCSP parser.add _ option ( &apos; --delete _ jsps &apos; , action = &apos; store _ true &apos; , dest = &apos; delete _ jsps &apos; , default = False , help = &apos; Delete DCSP the DCSP JSP DCSP source DCSP files DCSP after DCSP compilation . &apos; ) DCNL DCSP parser.add _ option ( &apos; --enable _ jar _ classes &apos; , action = &apos; store _ true &apos; , dest = &apos; do _ jar _ classes &apos; , default = False , help = &apos; Jar DCSP the DCSP WEB-INF / classes DCSP content . &apos; ) DCNL DCSP parser.add _ option ( &apos; --enable _ jar _ splitting &apos; , action = &apos; store _ true &apos; , dest = &apos; do _ jar _ splitting &apos; , default = False , help = &apos; Split DCSP large DCSP jar DCSP files DCSP ( &gt; DCSP 32M ) DCSP into DCSP smaller DCSP fragments . &apos; ) DCNL DCSP parser.add _ option ( &apos; --jar _ splitting _ excludes &apos; , action = &apos; store &apos; , dest = &apos; jar _ splitting _ exclude _ suffixes &apos; , default = &apos; &apos; , help = &apos; When DCSP --enable _ jar _ splitting DCSP is DCSP specified DCSP and DCSP --jar _ splitting _ excludes DCSP specifies DCSP a DCSP comma-separated DCSP list DCSP of DCSP suffixes , DCSP a DCSP file DCSP in DCSP a DCSP jar DCSP whose DCSP name DCSP ends DCSP with DCSP one DCSP of DCSP the DCSP suffixes DCSP will DCSP not DCSP be DCSP included DCSP in DCSP the DCSP split DCSP jar DCSP fragments . &apos; )
DCSP for ( toggle , definition ) in six.iteritems ( toggles ) : DCNL DCSP DCSP if ( definition &#91; &apos; value &apos; &#93; is not None ) : DCNL DCSP DCSP DCSP if ( ( ( definition &#91; &apos; value &apos; &#93; is True ) or ( definition &#91; &apos; value &apos; &#93; = = &apos; yes &apos; ) ) and ( definition &#91; &apos; type &apos; &#93; = = &apos; yes _ no &apos; ) ) : DCNL DCSP DCSP DCSP DCSP payload &#91; toggle &#93; = &apos; yes &apos; DCNL DCSP DCSP DCSP elif ( ( ( definition &#91; &apos; value &apos; &#93; is False ) or ( definition &#91; &apos; value &apos; &#93; = = &apos; no &apos; ) ) and ( definition &#91; &apos; type &apos; &#93; = = &apos; yes _ no &apos; ) ) : DCNL DCSP DCSP DCSP DCSP payload &#91; toggle &#93; = &apos; no &apos; DCNL DCSP DCSP DCSP if ( ( ( definition &#91; &apos; value &apos; &#93; is True ) or ( definition &#91; &apos; value &apos; &#93; = = &apos; yes &apos; ) ) and ( definition &#91; &apos; type &apos; &#93; = = &apos; true _ false &apos; ) ) : DCNL DCSP DCSP DCSP DCSP payload &#91; toggle &#93; = True DCNL DCSP DCSP DCSP elif ( ( ( definition &#91; &apos; value &apos; &#93; is False ) or ( definition &#91; &apos; value &apos; &#93; = = &apos; no &apos; ) ) and ( definition &#91; &apos; type &apos; &#93; = = &apos; true _ false &apos; ) ) : DCNL DCSP DCSP DCSP DCSP payload &#91; toggle &#93; = False DCNL DCSP return payload
DCSP if ( fig is None ) : DCNL DCSP DCSP plt = _ import _ mpl ( ) DCNL DCSP DCSP fig = plt.figure ( figsize = figsize ) DCNL DCSP return fig
DCSP if anon : DCNL DCSP DCSP user = None DCNL DCSP else : DCNL DCSP DCSP user = { u &apos;name &apos; : version.creator.fullname , u &apos;url &apos; : version.creator.url } DCNL DCSP return { u &apos;user &apos; : user , u &apos;index &apos; : ( index + 1 ) , u &apos;date &apos; : version.date _ created.isoformat ( ) , u &apos;downloads &apos; : record.get _ download _ count ( version = index ) , u &apos;md5 &apos; : version.metadata.get ( u &apos;md5 &apos; ) , u &apos;sha256 &apos; : version.metadata.get ( u &apos;sha256 &apos; ) }
DCSP bits = token.contents.split ( &apos; &quot; &apos; ) DCNL DCSP if ( len ( bits ) ! = 3 ) : DCNL DCSP DCSP raise TemplateSyntaxError ( &quot; &apos; now &apos; DCSP statement DCSP takes DCSP one DCSP argument &quot; ) DCNL DCSP format _ string = bits &#91; 1 &#93; DCNL DCSP return NowNode ( format _ string )
DCSP for ( ind , element ) in enumerate ( value ) : DCNL DCSP DCSP if ( not ( isinstance ( element , basestring ) or isinstance ( element , datetime.date ) or isinstance ( element , datetime.datetime ) or isinstance ( element , numbers.Number ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; All DCSP values DCSP of DCSP a DCSP multi-valued DCSP field DCSP must DCSP be DCSP numbers , DCSP strings , DCSP date DCSP or DCSP datetime DCSP instances , DCSP The DCSP % dth DCSP value DCSP for DCSP field DCSP % s DCSP has DCSP type DCSP % s . &apos; % ( ind , key , type ( element ) ) ) )
DCSP y = np.linspace ( 0 , 1 , 20 ) DCNL DCSP cnn = CondensedNearestNeighbour ( random _ state = RND _ SEED ) DCNL DCSP assert _ warns ( UserWarning , cnn.fit , X , y )
DCSP return struct.unpack ( &apos; ! I &apos; , bs ) &#91; 0 &#93;
DCSP def bruteforcewrap ( func , alphabet , length , method , start , databag ) : DCNL DCSP DCSP oldloglevel = context.log _ level DCNL DCSP DCSP context.log _ level = &apos; critical &apos; DCNL DCSP DCSP res = bruteforce ( func , alphabet , length , method = method , start = start , databag = databag ) DCNL DCSP DCSP context.log _ level = oldloglevel DCNL DCSP DCSP databag &#91; &apos; result &apos; &#93; = res DCNL DCSP if ( start = = None ) : DCNL DCSP DCSP start = ( 1 , 1 ) DCNL DCSP if ( threads = = None ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP threads = multiprocessing.cpu _ count ( ) DCNL DCSP DCSP except NotImplementedError : DCNL DCSP DCSP DCSP threads = 1 DCNL DCSP h = log.waitfor ( &apos; MBruteforcing &apos; ) DCNL DCSP processes = ( &#91; None &#93; * threads ) DCNL DCSP shareddata = ( &#91; None &#93; * threads ) DCNL DCSP ( i2 , N2 ) = start DCNL DCSP totalchunks = ( threads * N2 ) DCNL DCSP for i in range ( threads ) : DCNL DCSP DCSP shareddata &#91; i &#93; = multiprocessing.Manager ( ) .dict ( ) DCNL DCSP DCSP shareddata &#91; i &#93; &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP shareddata &#91; i &#93; &#91; &apos; current _ item &apos; &#93; = &apos; &apos; DCNL DCSP DCSP shareddata &#91; i &#93; &#91; &apos; items _ done &apos; &#93; = 0 DCNL DCSP DCSP shareddata &#91; i &#93; &#91; &apos; items _ total &apos; &#93; = 0 DCNL DCSP DCSP chunkid = ( ( ( i2 - 1 ) + ( i * N2 ) ) + 1 ) DCNL DCSP DCSP processes &#91; i &#93; = multiprocessing.Process ( target = bruteforcewrap , args = ( func , alphabet , length , method , ( chunkid , totalchunks ) , shareddata &#91; i &#93; ) ) DCNL DCSP DCSP processes &#91; i &#93; .start ( ) DCNL DCSP done = False DCNL DCSP while ( not done ) : DCNL DCSP DCSP current _ item _ list = &apos; , &apos; .join ( &#91; ( &apos; &quot; % s &quot; &apos; % x &#91; &apos; current _ item &apos; &#93; ) for x in shareddata if ( x ! = None ) &#93; ) DCNL DCSP DCSP items _ done = sum ( &#91; x &#91; &apos; items _ done &apos; &#93; for x in shareddata if ( x ! = None ) &#93; ) DCNL DCSP DCSP items _ total = sum ( &#91; x &#91; &apos; items _ total &apos; &#93; for x in shareddata if ( x ! = None ) &#93; ) DCNL DCSP DCSP progress = ( ( ( 100.0 * items _ done ) / items _ total ) if ( items _ total ! = 0 ) else 0.0 ) DCNL DCSP DCSP h.status ( ( &apos; Trying DCSP % s DCSP -- DCSP % 0.3f % % &apos; % ( current _ item _ list , progress ) ) ) DCNL DCSP DCSP for i in range ( threads ) : DCNL DCSP DCSP DCSP if ( processes &#91; i &#93; and ( processes &#91; i &#93; .exitcode ! = None ) ) : DCNL DCSP DCSP DCSP DCSP res = shareddata &#91; i &#93; &#91; &apos; result &apos; &#93; DCNL DCSP DCSP DCSP DCSP processes &#91; i &#93; .join ( ) DCNL DCSP DCSP DCSP DCSP processes &#91; i &#93; = None DCNL DCSP DCSP DCSP DCSP if ( res ! = None ) : DCNL DCSP DCSP DCSP DCSP DCSP for i in range ( threads ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( processes &#91; i &#93; ! = None ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP processes &#91; i &#93; .terminate ( ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP processes &#91; i &#93; .join ( ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP processes &#91; i &#93; = None DCNL DCSP DCSP DCSP DCSP DCSP h.success ( ( &apos; Found DCSP key : DCSP &quot; % s &quot; &apos; % res ) ) DCNL DCSP DCSP DCSP DCSP DCSP return res DCNL DCSP DCSP DCSP DCSP if all ( &#91; ( x = = None ) for x in processes &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP done = True DCNL DCSP DCSP time.sleep ( 0.3 ) DCNL DCSP h.failure ( &apos; No DCSP matches DCSP found &apos; )
DCSP ( data _ dir , data _ file ) = os.path.split ( dataset ) DCNL DCSP if ( ( data _ dir = = &apos; &apos; ) and ( not os.path.isfile ( dataset ) ) ) : DCNL DCSP DCSP new _ path = os.path.join ( os.path.split ( _ _ file _ _ ) &#91; 0 &#93; , &apos; .. &apos; , &apos; data &apos; , dataset ) DCNL DCSP DCSP if ( os.path.isfile ( new _ path ) or ( data _ file = = default _ dataset ) ) : DCNL DCSP DCSP DCSP dataset = new _ path DCNL DCSP if ( ( not os.path.isfile ( dataset ) ) and ( data _ file = = default _ dataset ) ) : DCNL DCSP DCSP from six.moves import urllib DCNL DCSP DCSP print ( ( &apos; Downloading DCSP data DCSP from DCSP % s &apos; % origin ) ) DCNL DCSP DCSP urllib.request.urlretrieve ( origin , dataset ) DCNL DCSP return dataset
DCSP ( raw , events ) = _ get _ data ( ) &#91; : 2 &#93; DCNL DCSP epochs = Epochs ( raw , events , event _ id , tmin , tmax ) DCNL DCSP assert _ raises ( RuntimeError , epochs . _ _ hash _ _ ) DCNL DCSP epochs = Epochs ( raw , events , event _ id , tmin , tmax , preload = True ) DCNL DCSP assert _ equal ( hash ( epochs ) , hash ( epochs ) ) DCNL DCSP epochs _ 2 = Epochs ( raw , events , event _ id , tmin , tmax , preload = True ) DCNL DCSP assert _ equal ( hash ( epochs ) , hash ( epochs _ 2 ) ) DCNL DCSP assert _ true ( ( pickle.dumps ( epochs ) = = pickle.dumps ( epochs _ 2 ) ) ) DCNL DCSP epochs _ 2 . _ data &#91; ( 0 , 0 , 0 ) &#93; - = 1 DCNL DCSP assert _ not _ equal ( hash ( epochs ) , hash ( epochs _ 2 ) )
DCSP length = ( 4 * count ) DCNL DCSP data = file _ obj.read ( length ) DCNL DCSP if ( len ( data ) ! = length ) : DCNL DCSP DCSP raise EOFError ( u &apos;Expected DCSP { 0 } DCSP bytes DCSP but DCSP got DCSP { 1 } DCSP bytes &apos; .format ( length , len ( data ) ) ) DCNL DCSP res = struct.unpack ( &apos; &lt; { 0 } i &apos; .format ( count ) .encode ( u &apos;utf-8 &apos; ) , data ) DCNL DCSP return res
DCSP return cache.load _ parser ( path , ( item.change _ time - 1 ) )
DCSP conf = { &apos; bind _ host &apos; : CONF.bind _ host , &apos; bind _ port &apos; : CONF.bind _ port , &apos; tcp _ keepidle &apos; : CONF.cert _ file , &apos; backlog &apos; : CONF.backlog , &apos; key _ file &apos; : CONF.key _ file , &apos; cert _ file &apos; : CONF.cert _ file } DCNL DCSP return conf
DCSP return s
DCSP n = ( width - len ( s ) ) DCNL DCSP if ( n &lt; = 0 ) : DCNL DCSP DCSP return s DCNL DCSP return ( ( &apos; DCSP &apos; * n ) + s )
DCSP p1 = utils.full _ process ( s1 , force _ ascii = force _ ascii ) DCNL DCSP p2 = utils.full _ process ( s2 , force _ ascii = force _ ascii ) DCNL DCSP if ( not utils.validate _ string ( p1 ) ) : DCNL DCSP DCSP return 0 DCNL DCSP if ( not utils.validate _ string ( p2 ) ) : DCNL DCSP DCSP return 0 DCNL DCSP try _ partial = True DCNL DCSP unbase _ scale = 0.95 DCNL DCSP partial _ scale = 0.9 DCNL DCSP base = ratio ( p1 , p2 ) DCNL DCSP len _ ratio = ( float ( max ( len ( p1 ) , len ( p2 ) ) ) / min ( len ( p1 ) , len ( p2 ) ) ) DCNL DCSP if ( len _ ratio &lt; 1.5 ) : DCNL DCSP DCSP try _ partial = False DCNL DCSP if ( len _ ratio &gt; 8 ) : DCNL DCSP DCSP partial _ scale = 0.6 DCNL DCSP if try _ partial : DCNL DCSP DCSP partial = ( partial _ ratio ( p1 , p2 ) * partial _ scale ) DCNL DCSP DCSP ptsor = ( ( partial _ token _ sort _ ratio ( p1 , p2 , full _ process = False ) * unbase _ scale ) * partial _ scale ) DCNL DCSP DCSP ptser = ( ( partial _ token _ set _ ratio ( p1 , p2 , full _ process = False ) * unbase _ scale ) * partial _ scale ) DCNL DCSP DCSP return utils.intr ( max ( base , partial , ptsor , ptser ) ) DCNL DCSP else : DCNL DCSP DCSP tsor = ( token _ sort _ ratio ( p1 , p2 , full _ process = False ) * unbase _ scale ) DCNL DCSP DCSP tser = ( token _ set _ ratio ( p1 , p2 , full _ process = False ) * unbase _ scale ) DCNL DCSP DCSP return utils.intr ( max ( base , tsor , tser ) )
DCSP client = _ get _ conn ( key = key , keyid = keyid , profile = profile , region = region ) DCNL DCSP new _ tags = &#91; &#93; DCNL DCSP for ( k , v ) in tags.iteritems ( ) : DCNL DCSP DCSP new _ tags.append ( { &apos; Key &apos; : k , &apos; Value &apos; : v } ) DCNL DCSP client.create _ tags ( FileSystemId = filesystemid , Tags = new _ tags )
DCSP if ( flag in get _ flags _ from _ package _ conf ( conf , atom ) ) : DCNL DCSP DCSP return True DCNL DCSP return False
DCSP if pkg _ resources.resource _ exists ( &apos; roscreate &apos; , tmplf ) : DCNL DCSP DCSP f = pkg _ resources.resource _ stream ( &apos; roscreate &apos; , tmplf ) DCNL DCSP DCSP t = f.read ( ) DCNL DCSP else : DCNL DCSP DCSP r = rospkg.RosPack ( ) DCNL DCSP DCSP with open ( os.path.join ( r.get _ path ( &apos; roscreate &apos; ) , &apos; templates &apos; , tmplf ) ) as f : DCNL DCSP DCSP DCSP t = f.read ( ) DCNL DCSP try : DCNL DCSP DCSP t = t.decode ( &apos; utf-8 &apos; ) DCNL DCSP except AttributeError : DCNL DCSP DCSP pass DCNL DCSP return t
DCSP create _ app _ context ( ) DCNL DCSP job = ArchiveJob.load ( job _ pk ) DCNL DCSP ( src , dst , user ) = job.info ( ) DCNL DCSP provider = data &#91; &apos; source &apos; &#93; &#91; &apos; provider &apos; &#93; DCNL DCSP logger.info ( &apos; Sending DCSP copy DCSP request DCSP for DCSP addon : DCSP { 0 } DCSP on DCSP node : DCSP { 1 } &apos; .format ( provider , dst . _ id ) ) DCNL DCSP res = requests.post ( url , data = json.dumps ( data ) ) DCNL DCSP if ( res.status _ code not in ( http.OK , http.CREATED , http.ACCEPTED ) ) : DCNL DCSP DCSP raise HTTPError ( res.status _ code )
DCSP for id in board _ ids ( ) : DCNL DCSP DCSP if _ obtain _ lock ( id ) : DCNL DCSP DCSP DCSP return id DCNL DCSP return ( -1 )
DCSP project = get _ project ( options ) DCNL DCSP print &apos; Creating DCSP instance DCSP { project } / { zone } / { instance } &apos; .format ( project = project , zone = get _ zone ( options ) , instance = options.instance ) DCNL DCSP print &apos; DCSP DCSP with DCSP --machine _ type = { type } DCSP and DCSP --disk _ size = { disk _ size } ... &apos; .format ( type = options.machine _ type , disk _ size = options.disk _ size ) DCNL DCSP google _ dev _ dir = os.path.join ( os.path.dirname ( _ _ file _ _ ) , &apos; .. / google / dev &apos; ) DCNL DCSP dev _ dir = os.path.dirname ( _ _ file _ _ ) DCNL DCSP project _ dir = os.path.join ( dev _ dir , &apos; .. &apos; ) DCNL DCSP install _ dir = &apos; { dir } / .. / install &apos; .format ( dir = dev _ dir ) DCNL DCSP startup _ command = &#91; &apos; / opt / spinnaker / install / install _ spinnaker.sh DCSP --dependencies _ only &apos; , &apos; / opt / spinnaker / install / install _ development.sh &apos; &#93; DCNL DCSP ( fd , temp _ startup ) = tempfile.mkstemp ( ) DCNL DCSP os.write ( fd , &apos; ; &apos; .join ( startup _ command ) ) DCNL DCSP os.close ( fd ) DCNL DCSP metadata _ files = &#91; &apos; startup-script = { google _ dev _ dir } / google _ install _ loader.py , sh _ bootstrap _ dev = { dev _ dir } / bootstrap _ dev.sh , sh _ install _ spinnaker = { project _ dir } / InstallSpinnaker.sh , sh _ install _ development = { dev _ dir } / install _ development.sh , startup _ command = { temp _ startup } &apos; .format ( google _ dev _ dir = google _ dev _ dir , dev _ dir = dev _ dir , project _ dir = project _ dir , temp _ startup = temp _ startup ) &#93; DCNL DCSP metadata = &apos; , &apos; .join ( &#91; &apos; startup _ loader _ files = sh _ install _ spinnaker + sh _ install _ development + sh _ bootstrap _ dev &apos; &#93; ) DCNL DCSP command = &#91; &apos; gcloud &apos; , &apos; compute &apos; , &apos; instances &apos; , &apos; create &apos; , options.instance , &apos; --project &apos; , get _ project ( options ) , &apos; --zone &apos; , get _ zone ( options ) , &apos; --machine-type &apos; , options.machine _ type , &apos; --image &apos; , &apos; ubuntu-14-04 &apos; , &apos; --scopes &apos; , &apos; compute-rw , storage-rw &apos; , &apos; --boot-disk-size = { size } &apos; .format ( size = options.disk _ size ) , &apos; --boot-disk-type = { type } &apos; .format ( type = options.disk _ type ) , &apos; --metadata &apos; , metadata , &apos; --metadata-from-file = { files } &apos; .format ( files = &apos; , &apos; .join ( metadata _ files ) ) &#93; DCNL DCSP if options.address : DCNL DCSP DCSP command.extend ( &#91; &apos; --address &apos; , options.address &#93; ) DCNL DCSP check _ run _ quick ( &apos; DCSP &apos; .join ( command ) , echo = False )
DCSP make _ or _ verify _ core _ dir ( config.config _ dir , constants.CONFIG _ DIRS _ MODE , os.geteuid ( ) , config.strict _ permissions ) DCNL DCSP make _ or _ verify _ core _ dir ( config.work _ dir , constants.CONFIG _ DIRS _ MODE , os.geteuid ( ) , config.strict _ permissions ) DCNL DCSP make _ or _ verify _ core _ dir ( config.logs _ dir , 448 , os.geteuid ( ) , config.strict _ permissions )
DCSP if ( not isinstance ( value , basestring ) ) : DCNL DCSP DCSP raise Invalid ( _ ( &apos; Names DCSP must DCSP be DCSP strings &apos; ) ) DCNL DCSP if ( value in &#91; &apos; new &apos; , &apos; edit &apos; , &apos; search &apos; &#93; ) : DCNL DCSP DCSP raise Invalid ( _ ( &apos; That DCSP name DCSP cannot DCSP be DCSP used &apos; ) ) DCNL DCSP if ( len ( value ) &lt; 2 ) : DCNL DCSP DCSP raise Invalid ( ( _ ( &apos; Must DCSP be DCSP at DCSP least DCSP % s DCSP characters DCSP long &apos; ) % 2 ) ) DCNL DCSP if ( len ( value ) &gt; PACKAGE _ NAME _ MAX _ LENGTH ) : DCNL DCSP DCSP raise Invalid ( ( _ ( &apos; Name DCSP must DCSP be DCSP a DCSP maximum DCSP of DCSP % i DCSP characters DCSP long &apos; ) % PACKAGE _ NAME _ MAX _ LENGTH ) ) DCNL DCSP if ( not name _ match.match ( value ) ) : DCNL DCSP DCSP raise Invalid ( _ ( &apos; Must DCSP be DCSP purely DCSP lowercase DCSP alphanumeric DCSP ( ascii ) DCSP characters DCSP and DCSP these DCSP symbols : DCSP - _ &apos; ) ) DCNL DCSP return value
DCSP repeats = tensor.as _ tensor _ variable ( repeats ) DCNL DCSP if ( repeats.ndim &gt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; The DCSP dimension DCSP of DCSP repeats DCSP should DCSP not DCSP exceed DCSP 1 . &apos; ) DCNL DCSP if ( ( repeats.ndim = = 1 ) and ( not repeats.broadcastable &#91; 0 &#93; ) ) : DCNL DCSP DCSP return RepeatOp ( axis = axis ) ( x , repeats ) DCNL DCSP else : DCNL DCSP DCSP if ( repeats.ndim = = 1 ) : DCNL DCSP DCSP DCSP repeats = repeats &#91; 0 &#93; DCNL DCSP DCSP if ( x.dtype = = &apos; uint64 &apos; ) : DCNL DCSP DCSP DCSP raise TypeError ( &quot; theano.tensor.repeat DCSP don &apos;t DCSP support DCSP dtype DCSP uint64 &quot; ) DCNL DCSP DCSP if ( axis is None ) : DCNL DCSP DCSP DCSP axis = 0 DCNL DCSP DCSP DCSP x = x.flatten ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( axis &gt; = x.ndim ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; Axis DCSP should DCSP not DCSP exceed DCSP x.ndim-1. &apos; ) DCNL DCSP DCSP DCSP if ( axis &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP axis = ( x.ndim + axis ) DCNL DCSP DCSP shape = &#91; x.shape &#91; i &#93; for i in xrange ( x.ndim ) &#93; DCNL DCSP DCSP shape _ = shape &#91; : &#93; DCNL DCSP DCSP shape _ .insert ( ( axis + 1 ) , repeats ) DCNL DCSP DCSP shape &#91; axis &#93; = ( shape &#91; axis &#93; * repeats ) DCNL DCSP DCSP dims _ = list ( numpy.arange ( x.ndim ) ) DCNL DCSP DCSP dims _ .insert ( ( axis + 1 ) , &apos; x &apos; ) DCNL DCSP DCSP z = tensor.alloc ( x.dimshuffle ( * dims _ ) , * shape _ ) .reshape ( shape ) DCNL DCSP DCSP return z
DCSP ( ( nbins , offset ) , dim , dtype , ( name , inp _ gen ) ) = nbin _ offset _ dim _ dtype _ inp DCNL DCSP gpuflag = ( check _ gpu.get _ compute _ capability ( 0 ) &gt; = 3.0 ) DCNL DCSP if ( gpuflag is False ) : DCNL DCSP DCSP raise RuntimeError ( &apos; Device DCSP does DCSP not DCSP have DCSP CUDA DCSP compute DCSP capability DCSP 3.0 DCSP or DCSP greater &apos; ) DCNL DCSP ( ng , nc ) = backend _ pair DCNL DCSP ng.set _ hist _ buffers ( nbins , offset ) DCNL DCSP nc.set _ hist _ buffers ( nbins , offset ) DCNL DCSP np _ inp = inp _ gen ( dim ) .astype ( dtype ) DCNL DCSP np _ hist = ref _ hist ( np _ inp , nbins = nbins , offset = offset ) DCNL DCSP for be in &#91; ng , nc &#93; : DCNL DCSP DCSP be _ inp = be.array ( np _ inp , dtype = dtype ) DCNL DCSP DCSP be _ hist = be _ inp.hist ( name ) DCNL DCSP DCSP assert tensors _ allclose ( np _ hist , be _ hist )
DCSP picks _ list = _ picks _ by _ type ( info ) DCNL DCSP scalings = _ handle _ default ( &apos; scalings _ cov _ rank &apos; , scalings ) DCNL DCSP _ apply _ scaling _ cov ( data , picks _ list , scalings ) DCNL DCSP if ( data.shape &#91; 1 &#93; &lt; data.shape &#91; 0 &#93; ) : DCNL DCSP DCSP ValueError ( &quot; You &apos;ve DCSP got DCSP fewer DCSP samples DCSP than DCSP channels , DCSP your DCSP rank DCSP estimate DCSP might DCSP be DCSP inaccurate . &quot; ) DCNL DCSP out = estimate _ rank ( data , tol = tol , norm = False , return _ singular = return _ singular ) DCNL DCSP rank = ( out &#91; 0 &#93; if isinstance ( out , tuple ) else out ) DCNL DCSP ch _ type = &apos; DCSP + DCSP &apos; .join ( list ( zip ( * picks _ list ) ) &#91; 0 &#93; ) DCNL DCSP logger.info ( ( &apos; estimated DCSP rank DCSP ( % s ) : DCSP % d &apos; % ( ch _ type , rank ) ) ) DCNL DCSP _ undo _ scaling _ cov ( data , picks _ list , scalings ) DCNL DCSP return out
DCSP if getattr ( x , &apos; is _ Matrix &apos; , False ) : DCNL DCSP DCSP return x.as _ mutable ( ) DCNL DCSP elif isinstance ( x , Basic ) : DCNL DCSP DCSP return x DCNL DCSP elif hasattr ( x , &apos; _ _ array _ _ &apos; ) : DCNL DCSP DCSP a = x . _ _ array _ _ ( ) DCNL DCSP DCSP if ( len ( a.shape ) = = 0 ) : DCNL DCSP DCSP DCSP return sympify ( a ) DCNL DCSP DCSP return Matrix ( x ) DCNL DCSP return x
DCSP if ( value is None ) : DCNL DCSP DCSP value = &apos; &apos; DCNL DCSP lst = _ _ salt _ _ &#91; &apos; cron.list _ tab &apos; &#93; ( user ) DCNL DCSP for env in lst &#91; &apos; env &apos; &#93; : DCNL DCSP DCSP if ( name = = env &#91; &apos; name &apos; &#93; ) : DCNL DCSP DCSP DCSP if ( value ! = env &#91; &apos; value &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP return &apos; update &apos; DCNL DCSP DCSP DCSP return &apos; present &apos; DCNL DCSP return &apos; absent&apos;
DCSP table = ascii.read ( &apos; t / daophot2.dat &apos; , Reader = ascii.Daophot ) DCNL DCSP for colname in table.colnames : DCNL DCSP DCSP mask _ value = ( colname in ( &apos; OTIME &apos; , &apos; MAG &apos; , &apos; MERR &apos; , &apos; XAIRMASS &apos; ) ) DCNL DCSP DCSP assert np.all ( ( table &#91; colname &#93; .mask = = mask _ value ) )
DCSP log.debug ( &apos; Called DCSP state DCSP to DCSP delete DCSP VPC DCSP peering DCSP connection &apos; ) DCNL DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; Boto DCSP VPC DCSP peering DCSP state &apos; } DCNL DCSP if conn _ name : DCNL DCSP DCSP vpc _ ids = _ _ salt _ _ &#91; &apos; boto _ vpc.describe _ vpc _ peering _ connection &apos; &#93; ( conn _ name , region = region , key = key , keyid = keyid , profile = profile ) .get ( &apos; VPC-Peerings &apos; , &#91; &#93; ) DCNL DCSP else : DCNL DCSP DCSP vpc _ ids = &#91; conn _ id &#93; DCNL DCSP if ( not vpc _ ids ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; No DCSP VPC DCSP connection DCSP found , DCSP nothing DCSP to DCSP be DCSP done . &apos; DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP if vpc _ ids : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; VPC DCSP peering DCSP connection DCSP would DCSP be DCSP deleted &apos; DCNL DCSP DCSP return ret DCNL DCSP log.debug ( &apos; Called DCSP module DCSP to DCSP delete DCSP VPC DCSP peering DCSP connection &apos; ) DCNL DCSP result = _ _ salt _ _ &#91; &apos; boto _ vpc.delete _ vpc _ peering _ connection &apos; &#93; ( conn _ id = conn _ id , conn _ name = conn _ name , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( &apos; error &apos; in result ) : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP delete DCSP VPC DCSP peering : DCSP { 0 } &apos; .format ( result &#91; &apos; error &apos; &#93; ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP return ret DCNL DCSP ret &#91; &apos; changes &apos; &#93; .update ( { &apos; old &apos; : &apos; &apos; , &apos; new &apos; : result &#91; &apos; msg &apos; &#93; } ) DCNL DCSP return ret
DCSP if ( arg is None ) : DCNL DCSP DCSP return type ( None ) DCNL DCSP if isinstance ( arg , basestring ) : DCNL DCSP DCSP arg = _ ForwardRef ( arg ) DCNL DCSP if ( ( isinstance ( arg , _ TypingBase ) and ( type ( arg ) . _ _ name _ _ = = u &apos; _ ClassVar &apos; ) ) or ( ( not isinstance ( arg , ( type , _ TypingBase ) ) ) and ( not callable ( arg ) ) ) ) : DCNL DCSP DCSP raise TypeError ( ( msg + ( u &apos; DCSP Got DCSP % .100r. &apos; % ( arg , ) ) ) ) DCNL DCSP if ( ( ( type ( arg ) . _ _ name _ _ in ( u &apos; _ Union &apos; , u &apos; _ Optional &apos; ) ) and ( not getattr ( arg , u &apos; _ _ origin _ _ &apos; , None ) ) ) or ( isinstance ( arg , TypingMeta ) and ( _ gorg ( arg ) in ( Generic , _ Protocol ) ) ) ) : DCNL DCSP DCSP raise TypeError ( ( u &apos;Plain DCSP % s DCSP is DCSP not DCSP valid DCSP as DCSP type DCSP argument &apos; % arg ) ) DCNL DCSP return arg
DCSP y = np.linspace ( 0 , 1 , 15 ) DCNL DCSP iht = InstanceHardnessThreshold ( random _ state = RND _ SEED ) DCNL DCSP assert _ warns ( UserWarning , iht.fit , X , y ) DCNL DCSP y = np.array ( ( ( ( &#91; 0 &#93; * 10 ) + ( &#91; 1 &#93; * 3 ) ) + ( &#91; 2 &#93; * 2 ) ) ) DCNL DCSP iht = InstanceHardnessThreshold ( random _ state = RND _ SEED ) DCNL DCSP assert _ warns ( UserWarning , iht.fit , X , y )
DCSP if ( UNRAR _ TOOL = = ALT _ TOOL ) : DCNL DCSP DCSP return DCNL DCSP if ( psw is not None ) : DCNL DCSP DCSP cmd.append ( ( &apos; -p &apos; + psw ) ) DCNL DCSP else : DCNL DCSP DCSP cmd.append ( &apos; -p- &apos; )
DCSP return SolidDerivation ( elementNode )
DCSP return LockType ( )
DCSP if ( min _ num is None ) : DCNL DCSP DCSP min _ num = DEFAULT _ MIN _ NUM DCNL DCSP if ( max _ num is None ) : DCNL DCSP DCSP max _ num = DEFAULT _ MAX _ NUM DCNL DCSP absolute _ max = ( max _ num + DEFAULT _ MAX _ NUM ) DCNL DCSP attrs = { &apos; form &apos; : form , &apos; extra &apos; : extra , &apos; can _ order &apos; : can _ order , &apos; can _ delete &apos; : can _ delete , &apos; min _ num &apos; : min _ num , &apos; max _ num &apos; : max _ num , &apos; absolute _ max &apos; : absolute _ max , &apos; validate _ min &apos; : validate _ min , &apos; validate _ max &apos; : validate _ max } DCNL DCSP return type ( ( form . _ _ name _ _ + &apos; FormSet &apos; ) , ( formset , ) , attrs )
DCSP INFO _ MSG ( &apos; onLoggerAppShutDown ( ) &apos; )
DCSP return IMPL.project _ get _ networks ( context , project _ id , associate )
DCSP client = cls ( debug _ logging = True ) DCNL DCSP client.login ( * * kwargs ) DCNL DCSP return client
DCSP path = _ SITES _ RELPATH _ DB.get ( ( lang , target _ lang ) , None ) DCNL DCSP if ( path is None ) : DCNL DCSP DCSP siteurl = _ SITE _ DB.get ( lang , _ MAIN _ SITEURL ) DCNL DCSP DCSP target _ siteurl = _ SITE _ DB.get ( target _ lang , _ MAIN _ SITEURL ) DCNL DCSP DCSP path = posixpath.relpath ( get _ site _ path ( target _ siteurl ) , get _ site _ path ( siteurl ) ) DCNL DCSP DCSP _ SITES _ RELPATH _ DB &#91; ( lang , target _ lang ) &#93; = path DCNL DCSP return path
DCSP spec = vim.vm.ConfigSpec ( ) DCNL DCSP nic _ changes = &#91; &#93; DCNL DCSP nic _ spec = vim.vm.device.VirtualDeviceSpec ( ) DCNL DCSP nic _ spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add DCNL DCSP nic _ spec.device = vim.vm.device.VirtualE1000 ( ) DCNL DCSP nic _ spec.device.deviceInfo = vim.Description ( ) DCNL DCSP nic _ spec.device.deviceInfo.summary = &apos; vCenter DCSP API DCSP test &apos; DCNL DCSP nic _ spec.device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo ( ) DCNL DCSP nic _ spec.device.backing.useAutoDetect = False DCNL DCSP content = si.RetrieveContent ( ) DCNL DCSP nic _ spec.device.backing.network = get _ obj ( content , &#91; vim.Network &#93; , network ) DCNL DCSP nic _ spec.device.backing.deviceName = network DCNL DCSP nic _ spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo ( ) DCNL DCSP nic _ spec.device.connectable.startConnected = True DCNL DCSP nic _ spec.device.connectable.startConnected = True DCNL DCSP nic _ spec.device.connectable.allowGuestControl = True DCNL DCSP nic _ spec.device.connectable.connected = False DCNL DCSP nic _ spec.device.connectable.status = &apos; untried &apos; DCNL DCSP nic _ spec.device.wakeOnLanEnabled = True DCNL DCSP nic _ spec.device.addressType = &apos; assigned &apos; DCNL DCSP nic _ changes.append ( nic _ spec ) DCNL DCSP spec.deviceChange = nic _ changes DCNL DCSP e = vm.ReconfigVM _ Task ( spec = spec ) DCNL DCSP print &apos; NIC DCSP CARD DCSP ADDED&apos;
DCSP test _ dir = os.path.join ( os.path.dirname ( _ _ file _ _ ) , TESTS _ DIR ) DCNL DCSP return driver.build _ tests ( test _ dir , loader , host = None , intercept = fixture _ module.setup _ app , fixture _ module = fixture _ module )
DCSP return _ format _ value ( val , limit , level )
DCSP return { &apos; html &apos; : { &apos; nbconvert _ template &apos; : &apos; basic &apos; , &apos; label &apos; : &apos; Notebook &apos; , &apos; icon &apos; : &apos; book &apos; } , &apos; slides &apos; : { &apos; nbconvert _ template &apos; : &apos; slides _ reveal &apos; , &apos; label &apos; : &apos; Slides &apos; , &apos; icon &apos; : &apos; gift &apos; , &apos; test &apos; : ( lambda nb , json : ( &apos; &quot; slideshow &quot; &apos; in json ) ) } , &apos; script &apos; : { &apos; label &apos; : &apos; Code &apos; , &apos; icon &apos; : &apos; code &apos; , &apos; content _ type &apos; : &apos; text / plain ; DCSP charset = UTF-8 &apos; } }
DCSP try : DCNL DCSP DCSP page = requests.get ( u &apos;http : / / download.flexget.com / latestversion &apos; ) DCNL DCSP except requests.RequestException : DCNL DCSP DCSP return DCNL DCSP ver = page.text.strip ( ) DCNL DCSP return ver
DCSP cmd = &apos; { 0 } DCSP -E DCSP { 1 } &apos; .format ( _ _ detect _ os ( ) , _ build _ cmd ( protocol = protocol , service _ address = service _ address , scheduler = scheduler ) ) DCNL DCSP out = _ _ salt _ _ &#91; &apos; cmd.run _ all &apos; &#93; ( cmd , python _ shell = False ) DCNL DCSP if out &#91; &apos; retcode &apos; &#93; : DCNL DCSP DCSP ret = out &#91; &apos; stderr &apos; &#93; .strip ( ) DCNL DCSP else : DCNL DCSP DCSP ret = True DCNL DCSP return ret
DCSP if ( not keywords ) : DCNL DCSP DCSP raise NotThisMethod ( &apos; no DCSP keywords DCSP at DCSP all , DCSP weird &apos; ) DCNL DCSP date = keywords.get ( &apos; date &apos; ) DCNL DCSP if ( date is not None ) : DCNL DCSP DCSP date = date.strip ( ) .replace ( &apos; DCSP &apos; , &apos; T &apos; , 1 ) .replace ( &apos; DCSP &apos; , &apos; &apos; , 1 ) DCNL DCSP refnames = keywords &#91; &apos; refnames &apos; &#93; .strip ( ) DCNL DCSP if refnames.startswith ( &apos; $ Format &apos; ) : DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print ( &apos; keywords DCSP are DCSP unexpanded , DCSP not DCSP using &apos; ) DCNL DCSP DCSP raise NotThisMethod ( &apos; unexpanded DCSP keywords , DCSP not DCSP a DCSP git-archive DCSP tarball &apos; ) DCNL DCSP refs = set ( &#91; r.strip ( ) for r in refnames.strip ( &apos; ( ) &apos; ) .split ( &apos; , &apos; ) &#93; ) DCNL DCSP TAG = &apos; tag : DCSP &apos; DCNL DCSP tags = set ( &#91; r &#91; len ( TAG ) : &#93; for r in refs if r.startswith ( TAG ) &#93; ) DCNL DCSP if ( not tags ) : DCNL DCSP DCSP tags = set ( &#91; r for r in refs if re.search ( &apos; \ \ d &apos; , r ) &#93; ) DCNL DCSP DCSP if verbose : DCNL DCSP DCSP DCSP print ( ( &quot; discarding DCSP &apos; % s &apos; , DCSP no DCSP digits &quot; % &apos; , &apos; .join ( ( refs - tags ) ) ) ) DCNL DCSP if verbose : DCNL DCSP DCSP print ( ( &apos; likely DCSP tags : DCSP % s &apos; % &apos; , &apos; .join ( sorted ( tags ) ) ) ) DCNL DCSP for ref in sorted ( tags ) : DCNL DCSP DCSP if ref.startswith ( tag _ prefix ) : DCNL DCSP DCSP DCSP r = ref &#91; len ( tag _ prefix ) : &#93; DCNL DCSP DCSP DCSP if verbose : DCNL DCSP DCSP DCSP DCSP print ( ( &apos; picking DCSP % s &apos; % r ) ) DCNL DCSP DCSP DCSP return { &apos; version &apos; : r , &apos; full-revisionid &apos; : keywords &#91; &apos; full &apos; &#93; .strip ( ) , &apos; dirty &apos; : False , &apos; error &apos; : None , &apos; date &apos; : date } DCNL DCSP if verbose : DCNL DCSP DCSP print ( &apos; no DCSP suitable DCSP tags , DCSP using DCSP unknown DCSP + DCSP full DCSP revision DCSP id &apos; ) DCNL DCSP return { &apos; version &apos; : &apos; 0 + unknown &apos; , &apos; full-revisionid &apos; : keywords &#91; &apos; full &apos; &#93; .strip ( ) , &apos; dirty &apos; : False , &apos; error &apos; : &apos; no DCSP suitable DCSP tags &apos; , &apos; date &apos; : None }
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : False , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; } DCNL DCSP existing = _ _ salt _ _ &#91; &apos; cisconso.get _ data &apos; &#93; ( datastore , path ) DCNL DCSP if cmp ( existing , config ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Config DCSP is DCSP already DCSP set &apos; DCNL DCSP elif ( _ _ opts _ _ &#91; &apos; test &apos; &#93; is True ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Config DCSP will DCSP be DCSP added &apos; DCNL DCSP DCSP diff = _ DictDiffer ( existing , config ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = diff.added ( ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; removed &apos; &#93; = diff.removed ( ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; changed &apos; &#93; = diff.changed ( ) DCNL DCSP else : DCNL DCSP DCSP _ _ salt _ _ &#91; &apos; cisconso.set _ data _ value &apos; &#93; ( datastore , path , config ) DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Successfully DCSP added DCSP config &apos; DCNL DCSP DCSP diff = _ DictDiffer ( existing , config ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = diff.added ( ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; removed &apos; &#93; = diff.removed ( ) DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; changed &apos; &#93; = diff.changed ( ) DCNL DCSP return ret
DCSP config _ stub.data = { &apos; storage &apos; : { &apos; cache-size &apos; : 1024 } , &apos; general &apos; : { &apos; private-browsing &apos; : True } } DCNL DCSP disk _ cache = cache.DiskCache ( str ( tmpdir ) ) DCNL DCSP url = QUrl ( &apos; http : / / www.example.com / &apos; ) DCNL DCSP assert ( disk _ cache.data ( url ) is None )
DCSP if ( not api _ key ) : DCNL DCSP DCSP return &apos; This DCSP command DCSP requires DCSP an DCSP API DCSP key DCSP from DCSP wordnik.com. &apos; DCNL DCSP word = sanitize ( text ) DCNL DCSP url = ( API _ URL + &apos; word.json / { } / examples &apos; .format ( word ) ) DCNL DCSP params = { &apos; api _ key &apos; : api _ key , &apos; limit &apos; : 10 } DCNL DCSP json = requests.get ( url , params = params ) .json ( ) DCNL DCSP if json : DCNL DCSP DCSP out = &apos; \ x02 { } \ x02 : DCSP &apos; .format ( word ) DCNL DCSP DCSP example = random.choice ( json &#91; &apos; examples &apos; &#93; ) DCNL DCSP DCSP out + = &apos; { } DCSP &apos; .format ( example &#91; &apos; text &apos; &#93; ) DCNL DCSP DCSP return &apos; DCSP &apos; .join ( out.split ( ) ) DCNL DCSP else : DCNL DCSP DCSP return &apos; I DCSP could DCSP not DCSP find DCSP any DCSP usage DCSP examples DCSP for DCSP \ x02 { } \ x02 . &apos; .format ( word )
DCSP if files : DCNL DCSP DCSP osname = get _ os _ name ( ) DCNL DCSP DCSP opener = _ OPENER _ BY _ OS.get ( osname ) DCNL DCSP DCSP if opener : DCNL DCSP DCSP DCSP opener ( files ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise OpenError ( ( u &apos;Open DCSP currently DCSP not DCSP supported DCSP for DCSP &apos; + osname ) )
DCSP allowed _ ops = ( tensor.basic.DimShuffle , tensor.basic.Elemwise ) DCNL DCSP owner = graph.owner DCNL DCSP op = ( graph.owner.op if ( graph.owner is not None ) else None ) DCNL DCSP if ( ( owner is None ) and ( graph in inputs ) ) : DCNL DCSP DCSP return True DCNL DCSP elif ( ( owner is None ) and isinstance ( graph , tensor.basic.TensorConstant ) ) : DCNL DCSP DCSP return True DCNL DCSP elif ( ( owner is None ) and ( graph not in inputs ) ) : DCNL DCSP DCSP return False DCNL DCSP elif ( ( op is not None ) and ( not isinstance ( op , allowed _ ops ) ) ) : DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP if isinstance ( graph.owner.op , tensor.basic.DimShuffle ) : DCNL DCSP DCSP DCSP shuffled = graph.owner.inputs &#91; 0 &#93; DCNL DCSP DCSP DCSP if ( not isinstance ( shuffled , tensor.basic.TensorConstant ) ) : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP for inp in graph.owner.inputs : DCNL DCSP DCSP DCSP if ( not is _ pure _ elemwise ( inp , inputs ) ) : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP return True
DCSP rebulk = Rebulk ( ) .regex _ defaults ( flags = re.IGNORECASE , abbreviations = &#91; dash &#93; ) .string _ defaults ( ignore _ case = True ) DCNL DCSP def audio _ codec _ priority ( match1 , match2 ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gives DCSP priority DCSP to DCSP audio _ codec \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : param DCSP match1 : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : type DCSP match1 : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : param DCSP match2 : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : type DCSP match2 : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : return : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP : rtype : \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP if ( ( match1.name = = &apos; audio _ codec &apos; ) and ( match2.name in &#91; &apos; audio _ profile &apos; , &apos; audio _ channels &apos; &#93; ) ) : DCNL DCSP DCSP DCSP return match2 DCNL DCSP DCSP if ( ( match1.name in &#91; &apos; audio _ profile &apos; , &apos; audio _ channels &apos; &#93; ) and ( match2.name = = &apos; audio _ codec &apos; ) ) : DCNL DCSP DCSP DCSP return match1 DCNL DCSP DCSP return &apos; _ _ default _ _ &apos; DCNL DCSP rebulk.defaults ( name = &apos; audio _ codec &apos; , conflict _ solver = audio _ codec _ priority ) DCNL DCSP rebulk.regex ( &apos; MP3 &apos; , &apos; LAME &apos; , &apos; LAME ( ? : \ \ d ) + - ? ( ? : \ \ d ) + &apos; , value = &apos; MP3 &apos; ) DCNL DCSP rebulk.regex ( &apos; Dolby &apos; , &apos; DolbyDigital &apos; , &apos; Dolby-Digital &apos; , &apos; DD &apos; , value = &apos; DolbyDigital &apos; ) DCNL DCSP rebulk.regex ( &apos; DolbyAtmos &apos; , &apos; Dolby-Atmos &apos; , &apos; Atmos &apos; , value = &apos; DolbyAtmos &apos; ) DCNL DCSP rebulk.regex ( &apos; AAC &apos; , value = &apos; AAC &apos; ) DCNL DCSP rebulk.regex ( &apos; AC3D ? &apos; , value = &apos; AC3 &apos; ) DCNL DCSP rebulk.regex ( &apos; Flac &apos; , value = &apos; FLAC &apos; ) DCNL DCSP rebulk.regex ( &apos; DTS &apos; , value = &apos; DTS &apos; ) DCNL DCSP rebulk.regex ( &apos; True- ? HD &apos; , value = &apos; TrueHD &apos; ) DCNL DCSP rebulk.defaults ( name = &apos; audio _ profile &apos; ) DCNL DCSP rebulk.string ( &apos; HD &apos; , value = &apos; HD &apos; , tags = &apos; DTS &apos; ) DCNL DCSP rebulk.regex ( &apos; HD- ? MA &apos; , value = &apos; HDMA &apos; , tags = &apos; DTS &apos; ) DCNL DCSP rebulk.string ( &apos; HE &apos; , value = &apos; HE &apos; , tags = &apos; AAC &apos; ) DCNL DCSP rebulk.string ( &apos; LC &apos; , value = &apos; LC &apos; , tags = &apos; AAC &apos; ) DCNL DCSP rebulk.string ( &apos; HQ &apos; , value = &apos; HQ &apos; , tags = &apos; AC3 &apos; ) DCNL DCSP rebulk.defaults ( name = &apos; audio _ channels &apos; ) DCNL DCSP rebulk.regex ( &apos; ( 7 &#91; \ \ W _ &#93; &#91; 01 &#93; ( ? : ch ) ? ) ( ? : &#91; ^ \ \ d &#93; &#124; $ ) &apos; , value = &apos; 7.1 &apos; , children = True ) DCNL DCSP rebulk.regex ( &apos; ( 5 &#91; \ \ W _ &#93; &#91; 01 &#93; ( ? : ch ) ? ) ( ? : &#91; ^ \ \ d &#93; &#124; $ ) &apos; , value = &apos; 5.1 &apos; , children = True ) DCNL DCSP rebulk.regex ( &apos; ( 2 &#91; \ \ W _ &#93; 0 ( ? : ch ) ? ) ( ? : &#91; ^ \ \ d &#93; &#124; $ ) &apos; , value = &apos; 2.0 &apos; , children = True ) DCNL DCSP rebulk.string ( &apos; 7ch &apos; , &apos; 8ch &apos; , value = &apos; 7.1 &apos; ) DCNL DCSP rebulk.string ( &apos; 5ch &apos; , &apos; 6ch &apos; , value = &apos; 5.1 &apos; ) DCNL DCSP rebulk.string ( &apos; 2ch &apos; , &apos; stereo &apos; , value = &apos; 2.0 &apos; ) DCNL DCSP rebulk.string ( &apos; 1ch &apos; , &apos; mono &apos; , value = &apos; 1.0 &apos; ) DCNL DCSP rebulk.rules ( DtsRule , AacRule , Ac3Rule , AudioValidatorRule , HqConflictRule ) DCNL DCSP return rebulk
DCSP bucket = conn.get _ bucket ( bucket _ id ) DCNL DCSP if ( not bucket ) : DCNL DCSP DCSP msg = ( _ ( &apos; Could DCSP not DCSP find DCSP bucket DCSP with DCSP ID DCSP % ( bucket _ id ) s &apos; ) % locals ( ) ) DCNL DCSP DCSP LOG.debug ( msg ) DCNL DCSP DCSP raise exception.NotFound ( msg ) DCNL DCSP return bucket
DCSP if ( error _ message is None ) : DCNL DCSP DCSP error _ message = ( &apos; Enter DCSP &apos; + what _ to _ enter ) DCNL DCSP DCSP if ( ( minimum is not None ) and ( maximum is not None ) ) : DCNL DCSP DCSP DCSP error _ message + = &apos; DCSP between DCSP % ( min ) g DCSP and DCSP % ( max ) g &apos; DCNL DCSP DCSP elif ( minimum is not None ) : DCNL DCSP DCSP DCSP error _ message + = &apos; DCSP greater DCSP than DCSP or DCSP equal DCSP to DCSP % ( min ) g &apos; DCNL DCSP DCSP elif ( maximum is not None ) : DCNL DCSP DCSP DCSP error _ message + = &apos; DCSP less DCSP than DCSP or DCSP equal DCSP to DCSP % ( max ) g &apos; DCNL DCSP if ( type ( maximum ) in &#91; int , long &#93; ) : DCNL DCSP DCSP maximum - = 1 DCNL DCSP return ( translate ( error _ message ) % dict ( min = minimum , max = maximum ) )
DCSP return IMPL.instance _ get _ floating _ address ( context , instance _ id )
DCSP source = credentials.source DCNL DCSP username = credentials.username DCNL DCSP password = credentials.password DCNL DCSP response = sock _ info.command ( source , { &apos; getnonce &apos; : 1 } ) DCNL DCSP nonce = response &#91; &apos; nonce &apos; &#93; DCNL DCSP key = _ auth _ key ( nonce , username , password ) DCNL DCSP query = SON ( &#91; ( &apos; authenticate &apos; , 1 ) , ( &apos; user &apos; , username ) , ( &apos; nonce &apos; , nonce ) , ( &apos; key &apos; , key ) &#93; ) DCNL DCSP sock _ info.command ( source , query )
DCSP formula _ set = list ( formula _ set ) DCNL DCSP formula _ set.append ( Not ( expr ) ) DCNL DCSP return ( not satisfiable ( And ( * formula _ set ) ) )
DCSP if ( not callable ( function ) ) : DCNL DCSP DCSP raise TypeError ( &apos; function DCSP must DCSP be DCSP callable &apos; ) DCNL DCSP hub = get _ hub ( ) DCNL DCSP if kwargs : DCNL DCSP DCSP function = _ functools _ partial ( function , * args , * * kwargs ) DCNL DCSP DCSP g = RawGreenlet ( function , hub ) DCNL DCSP DCSP hub.loop.run _ callback ( g.switch ) DCNL DCSP else : DCNL DCSP DCSP g = RawGreenlet ( function , hub ) DCNL DCSP DCSP hub.loop.run _ callback ( g.switch , * args ) DCNL DCSP return g
DCSP return orig _ isinstance ( obj , NetProxy )
DCSP error _ map = { app _ identity _ service _ pb.AppIdentityServiceError.NOT _ A _ VALID _ APP : InternalError , app _ identity _ service _ pb.AppIdentityServiceError.DEADLINE _ EXCEEDED : BackendDeadlineExceeded , app _ identity _ service _ pb.AppIdentityServiceError.BLOB _ TOO _ LARGE : BlobSizeTooLarge , app _ identity _ service _ pb.AppIdentityServiceError.UNKNOWN _ ERROR : InternalError , app _ identity _ service _ pb.AppIdentityServiceError.UNKNOWN _ SCOPE : InvalidScope , app _ identity _ service _ pb.AppIdentityServiceError.NOT _ ALLOWED : NotAllowed , app _ identity _ service _ pb.AppIdentityServiceError.NOT _ IMPLEMENTED : OperationNotImplemented } DCNL DCSP if ( error.application _ error in error _ map ) : DCNL DCSP DCSP return error _ map &#91; error.application _ error &#93; ( error.error _ detail ) DCNL DCSP else : DCNL DCSP DCSP return InternalError ( ( &apos; % s : DCSP % s &apos; % ( error.application _ error , error.error _ detail ) ) )
DCSP if ( ( position is None ) and ( keyword is None ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Must DCSP specify DCSP at DCSP least DCSP one DCSP of : DCSP position DCSP or DCSP keyword . &apos; ) DCNL DCSP try : DCNL DCSP DCSP if ( ( position is not None ) and ( not isinstance ( callfunc _ node.args &#91; position &#93; , astroid.Keyword ) ) ) : DCNL DCSP DCSP DCSP return callfunc _ node.args &#91; position &#93; DCNL DCSP except IndexError as error : DCNL DCSP DCSP raise NoSuchArgumentError ( error ) DCNL DCSP if keyword : DCNL DCSP DCSP for arg in callfunc _ node.args : DCNL DCSP DCSP DCSP if ( isinstance ( arg , astroid.Keyword ) and ( arg.arg = = keyword ) ) : DCNL DCSP DCSP DCSP DCSP return arg.value DCNL DCSP raise NoSuchArgumentError
DCSP try : DCNL DCSP DCSP tmp = class _ path.split ( &apos; .&apos; ) DCNL DCSP DCSP module _ path = &apos; .&apos;.join ( tmp &#91; 0 : ( -1 ) &#93; ) DCNL DCSP DCSP package = _ _ import _ _ ( module _ path ) DCNL DCSP DCSP return reduce ( getattr , tmp &#91; 1 : &#93; , package ) DCNL DCSP except Exception as e : DCNL DCSP DCSP log.error ( LOGMSG _ ERR _ FAB _ ADDON _ IMPORT.format ( class _ path , e ) )
DCSP ( w , V ) = LA.eigh ( P , lower = lower , check _ finite = check _ finite ) DCNL DCSP if ( rcond is not None ) : DCNL DCSP DCSP cond = rcond DCNL DCSP if ( cond in ( None , ( -1 ) ) ) : DCNL DCSP DCSP t = V.dtype.char.lower ( ) DCNL DCSP DCSP factor = { &apos; f &apos; : 1000.0 , &apos; d &apos; : 1000000.0 } DCNL DCSP DCSP cond = ( factor &#91; t &#93; * np.finfo ( t ) .eps ) DCNL DCSP scale = max ( np.absolute ( w ) ) DCNL DCSP w _ scaled = ( w / scale ) DCNL DCSP maskp = ( w _ scaled &gt; cond ) DCNL DCSP maskn = ( w _ scaled &lt; ( - cond ) ) DCNL DCSP if ( np.any ( maskp ) and np.any ( maskn ) ) : DCNL DCSP DCSP warnings.warn ( &apos; Forming DCSP a DCSP nonconvex DCSP expression DCSP quad _ form ( x , DCSP indefinite ) . &apos; ) DCNL DCSP M1 = ( V &#91; : , maskp &#93; * np.sqrt ( w _ scaled &#91; maskp &#93; ) ) DCNL DCSP M2 = ( V &#91; : , maskn &#93; * np.sqrt ( ( - w _ scaled &#91; maskn &#93; ) ) ) DCNL DCSP return ( scale , M1 , M2 )
DCSP fileName = fabmetheus _ interpret.getFirstTranslatorFileNameUnmodified ( fileName ) DCNL DCSP if ( fileName ! = &apos; &apos; ) : DCNL DCSP DCSP skeinforge _ craft.writeChainTextWithNounMessage ( fileName , &apos; unpause &apos; )
DCSP try : DCNL DCSP DCSP result = f ( * args , * * kwargs ) DCNL DCSP except Exception : DCNL DCSP DCSP f = failure.Failure ( ) DCNL DCSP DCSP reactor.callFromThread ( deferred.errback , f ) DCNL DCSP else : DCNL DCSP DCSP reactor.callFromThread ( deferred.callback , result )
DCSP tmp = _ asfarray ( x ) DCNL DCSP try : DCNL DCSP DCSP work _ function = _ DTYPE _ TO _ FFT &#91; tmp.dtype &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise ValueError ( ( &apos; type DCSP % s DCSP is DCSP not DCSP supported &apos; % tmp.dtype ) ) DCNL DCSP if ( not ( istype ( tmp , numpy.complex64 ) or istype ( tmp , numpy.complex128 ) ) ) : DCNL DCSP DCSP overwrite _ x = 1 DCNL DCSP overwrite _ x = ( overwrite _ x or _ datacopied ( tmp , x ) ) DCNL DCSP if ( n is None ) : DCNL DCSP DCSP n = tmp.shape &#91; axis &#93; DCNL DCSP elif ( n ! = tmp.shape &#91; axis &#93; ) : DCNL DCSP DCSP ( tmp , copy _ made ) = _ fix _ shape ( tmp , n , axis ) DCNL DCSP DCSP overwrite _ x = ( overwrite _ x or copy _ made ) DCNL DCSP if ( n &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Invalid DCSP number DCSP of DCSP FFT DCSP data DCSP points DCSP ( % d ) DCSP specified . &apos; % n ) ) DCNL DCSP if ( ( axis = = ( -1 ) ) or ( axis = = ( len ( tmp.shape ) - 1 ) ) ) : DCNL DCSP DCSP return work _ function ( tmp , n , 1 , 0 , overwrite _ x ) DCNL DCSP tmp = swapaxes ( tmp , axis , ( -1 ) ) DCNL DCSP tmp = work _ function ( tmp , n , 1 , 0 , overwrite _ x ) DCNL DCSP return swapaxes ( tmp , axis , ( -1 ) )
DCSP os.makedirs ( os.path.join ( HOME _ TEST _ DIR , &apos; ipython &apos; ) )
DCSP try : DCNL DCSP DCSP user = User.objects.get ( username = username ) DCNL DCSP DCSP if recreate : DCNL DCSP DCSP DCSP user.delete ( ) DCNL DCSP DCSP DCSP raise User.DoesNotExist DCNL DCSP except User.DoesNotExist : DCNL DCSP DCSP user = User.objects.create _ user ( username , ( username + &apos; @ localhost &apos; ) , password ) DCNL DCSP DCSP user.is _ superuser = is _ superuser DCNL DCSP DCSP user.save ( ) DCNL DCSP else : DCNL DCSP DCSP if ( user.is _ superuser ! = is _ superuser ) : DCNL DCSP DCSP DCSP user.is _ superuser = is _ superuser DCNL DCSP DCSP DCSP user.save ( ) DCNL DCSP if ( groupname is not None ) : DCNL DCSP DCSP ( group , created ) = Group.objects.get _ or _ create ( name = groupname ) DCNL DCSP DCSP if ( not user.groups.filter ( name = group.name ) .exists ( ) ) : DCNL DCSP DCSP DCSP user.groups.add ( group ) DCNL DCSP DCSP DCSP user.save ( ) DCNL DCSP c = Client ( ) DCNL DCSP ret = c.login ( username = username , password = password ) DCNL DCSP assert ret , ( &quot; Login DCSP failed DCSP ( user DCSP &apos; % s &apos; ) . &quot; % username ) DCNL DCSP return c
DCSP data = np.ones ( ( 5 , 5 ) ) DCNL DCSP data &#91; ( 2 , 2 ) &#93; = 1000 DCNL DCSP data &#91; ( 3 , 4 ) &#93; = np.nan DCNL DCSP data &#91; ( 1 , 1 ) &#93; = np.inf DCNL DCSP result = sigma _ clip ( data ) DCNL DCSP assert result.mask &#91; ( 2 , 2 ) &#93; DCNL DCSP assert result.mask &#91; ( 3 , 4 ) &#93; DCNL DCSP assert result.mask &#91; ( 1 , 1 ) &#93;
DCSP for ( dirpath , _ , filenames ) in os.walk ( pelican.settings &#91; &apos; OUTPUT _ PATH &apos; &#93; ) : DCNL DCSP DCSP for name in filenames : DCNL DCSP DCSP DCSP if should _ compress ( name ) : DCNL DCSP DCSP DCSP DCSP filepath = os.path.join ( dirpath , name ) DCNL DCSP DCSP DCSP DCSP create _ gzip _ file ( filepath , should _ overwrite ( pelican.settings ) )
DCSP return client _ session.request ( * args , * * kwargs )
DCSP return &#91; unique _ substring ( s , &#91; x for x in l if ( x is not s ) &#93; , min _ size ) for s in l &#93;
DCSP ret = { &apos; name &apos; : None , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP r = _ _ salt _ _ &#91; &apos; boto _ lambda.event _ source _ mapping _ exists &apos; &#93; ( EventSourceArn = EventSourceArn , FunctionName = FunctionName , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( &apos; error &apos; in r ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP event DCSP source DCSP mapping : DCSP { 0 } . &apos; .format ( r &#91; &apos; error &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP return ret DCNL DCSP if ( not r.get ( &apos; exists &apos; ) ) : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Event DCSP source DCSP mapping DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP created . &apos; .format ( FunctionName ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP r = _ _ salt _ _ &#91; &apos; boto _ lambda.create _ event _ source _ mapping &apos; &#93; ( EventSourceArn = EventSourceArn , FunctionName = FunctionName , StartingPosition = StartingPosition , Enabled = Enabled , BatchSize = BatchSize , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP if ( not r.get ( &apos; created &apos; ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP create DCSP event DCSP source DCSP mapping : DCSP { 0 } . &apos; .format ( r &#91; &apos; error &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP _ describe = _ _ salt _ _ &#91; &apos; boto _ lambda.describe _ event _ source _ mapping &apos; &#93; ( EventSourceArn = EventSourceArn , FunctionName = FunctionName , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP ret &#91; &apos; name &apos; &#93; = _ describe &#91; &apos; event _ source _ mapping &apos; &#93; &#91; &apos; UUID &apos; &#93; DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; old &apos; &#93; = { &apos; event _ source _ mapping &apos; : None } DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; new &apos; &#93; = _ describe DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Event DCSP source DCSP mapping DCSP { 0 } DCSP created . &apos; .format ( ret &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP return ret DCNL DCSP ret &#91; &apos; comment &apos; &#93; = os.linesep.join ( &#91; ret &#91; &apos; comment &apos; &#93; , &apos; Event DCSP source DCSP mapping DCSP is DCSP present . &apos; &#93; ) DCNL DCSP ret &#91; &apos; changes &apos; &#93; = { } DCNL DCSP _ describe = _ _ salt _ _ &#91; &apos; boto _ lambda.describe _ event _ source _ mapping &apos; &#93; ( EventSourceArn = EventSourceArn , FunctionName = FunctionName , region = region , key = key , keyid = keyid , profile = profile ) &#91; &apos; event _ source _ mapping &apos; &#93; DCNL DCSP need _ update = False DCNL DCSP options = { &apos; BatchSize &apos; : &apos; BatchSize &apos; } DCNL DCSP for ( val , var ) in six.iteritems ( options ) : DCNL DCSP DCSP if ( _ describe &#91; val &#93; ! = locals ( ) &#91; var &#93; ) : DCNL DCSP DCSP DCSP need _ update = True DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; new &apos; , { } ) &#91; var &#93; = locals ( ) &#91; var &#93; DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; old &apos; , { } ) &#91; var &#93; = _ describe &#91; val &#93; DCNL DCSP function _ arn = _ get _ function _ arn ( FunctionName , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP if ( _ describe &#91; &apos; FunctionArn &apos; &#93; ! = function _ arn ) : DCNL DCSP DCSP need _ update = True DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; new &apos; , { } ) &#91; &apos; FunctionArn &apos; &#93; = function _ arn DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; .setdefault ( &apos; old &apos; , { } ) &#91; &apos; FunctionArn &apos; &#93; = _ describe &#91; &apos; FunctionArn &apos; &#93; DCNL DCSP if need _ update : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = os.linesep.join ( &#91; ret &#91; &apos; comment &apos; &#93; , &apos; Event DCSP source DCSP mapping DCSP to DCSP be DCSP modified &apos; &#93; ) DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP msg = &apos; Event DCSP source DCSP mapping DCSP { 0 } DCSP set DCSP to DCSP be DCSP modified . &apos; .format ( _ describe &#91; &apos; UUID &apos; &#93; ) DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = msg DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP _ r = _ _ salt _ _ &#91; &apos; boto _ lambda.update _ event _ source _ mapping &apos; &#93; ( UUID = _ describe &#91; &apos; UUID &apos; &#93; , FunctionName = FunctionName , Enabled = Enabled , BatchSize = BatchSize , region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP if ( not _ r.get ( &apos; updated &apos; ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP update DCSP mapping : DCSP { 0 } . &apos; .format ( _ r &#91; &apos; error &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { } DCNL DCSP return ret
DCSP if gcodec.isProcedureDoneOrFileIsEmpty ( gcodeText , &apos; export &apos; ) : DCNL DCSP DCSP return gcodeText DCNL DCSP if ( exportRepository = = None ) : DCNL DCSP DCSP exportRepository = settings.getReadRepository ( ExportRepository ( ) ) DCNL DCSP if ( not exportRepository.activateExport.value ) : DCNL DCSP DCSP return gcodeText DCNL DCSP return ExportSkein ( ) .getCraftedGcode ( exportRepository , gcodeText )
DCSP clf = GaussianNB ( ) DCNL DCSP clf.fit ( X , y ) DCNL DCSP assert _ raises ( ValueError , clf.partial _ fit , np.hstack ( ( X , X ) ) , y )
DCSP code = int ( key &#91; ( key.index ( u &apos;k &apos; ) + 1 ) : &#93; ) DCNL DCSP value = chr ( code ) DCNL DCSP if ( ( code &gt; = 65 ) and ( code &lt; = 90 ) ) : DCNL DCSP DCSP if ( u &apos;shift + &apos; in key ) : DCNL DCSP DCSP DCSP key = key.replace ( u &apos;shift + &apos; , u &apos; &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP value = value.lower ( ) DCNL DCSP elif ( ( code &gt; = 48 ) and ( code &lt; = 57 ) ) : DCNL DCSP DCSP if ( u &apos;shift + &apos; in key ) : DCNL DCSP DCSP DCSP value = u &apos; ) ! @ # $ % ^ &amp; * ( &apos; &#91; int ( value ) &#93; DCNL DCSP DCSP DCSP key = key.replace ( u &apos;shift + &apos; , u &apos; &apos; ) DCNL DCSP elif ( ( code &gt; = 112 ) and ( code &lt; = 123 ) ) : DCNL DCSP DCSP value = ( u &apos;f % s &apos; % ( code - 111 ) ) DCNL DCSP elif ( ( code &gt; = 96 ) and ( code &lt; = 105 ) ) : DCNL DCSP DCSP value = ( u &apos; % s &apos; % ( code - 96 ) ) DCNL DCSP elif ( ( code in _ SHIFT _ LUT ) and ( u &apos;shift + &apos; in key ) ) : DCNL DCSP DCSP key = key.replace ( u &apos;shift + &apos; , u &apos; &apos; ) DCNL DCSP DCSP value = _ SHIFT _ LUT &#91; code &#93; DCNL DCSP elif ( code in _ LUT ) : DCNL DCSP DCSP value = _ LUT &#91; code &#93; DCNL DCSP key = ( key &#91; : key.index ( u &apos;k &apos; ) &#93; + value ) DCNL DCSP return key
DCSP conn = boto.connect _ vpc ( u &apos;the _ key &apos; , u &apos;the _ secret &apos; ) DCNL DCSP igw = conn.create _ internet _ gateway ( ) DCNL DCSP igw _ by _ search = conn.get _ all _ internet _ gateways ( &#91; igw.id &#93; ) &#91; 0 &#93; DCNL DCSP igw.id.should.equal ( igw _ by _ search.id )
DCSP conn = _ _ proxy _ _ &#91; &apos; junos.conn &apos; &#93; ( ) DCNL DCSP ret = dict ( ) DCNL DCSP ret &#91; &apos; out &apos; &#93; = True DCNL DCSP op = dict ( ) DCNL DCSP if ( &apos; _ _ pub _ arg &apos; in kwargs ) : DCNL DCSP DCSP if isinstance ( kwargs &#91; &apos; _ _ pub _ arg &apos; &#93; &#91; ( -1 ) &#93; , dict ) : DCNL DCSP DCSP DCSP op.update ( kwargs &#91; &apos; _ _ pub _ arg &apos; &#93; &#91; ( -1 ) &#93; ) DCNL DCSP else : DCNL DCSP DCSP op.update ( kwargs ) DCNL DCSP if ( ( dest is None ) and ( format ! = &apos; xml &apos; ) ) : DCNL DCSP DCSP log.warning ( &apos; Format DCSP ignored DCSP as DCSP it DCSP is DCSP only DCSP used DCSP for DCSP output DCSP which DCSP is DCSP dumped DCSP in DCSP the DCSP file . &apos; ) DCNL DCSP write _ response = &apos; &apos; DCNL DCSP try : DCNL DCSP DCSP if ( cmd in &#91; &apos; get-config &apos; , &apos; get _ config &apos; &#93; ) : DCNL DCSP DCSP DCSP filter _ reply = None DCNL DCSP DCSP DCSP if ( &apos; filter &apos; in op ) : DCNL DCSP DCSP DCSP DCSP filter _ reply = etree.XML ( op &#91; &apos; filter &apos; &#93; ) DCNL DCSP DCSP DCSP xml _ reply = getattr ( conn.rpc , cmd.replace ( &apos; -&apos; , &apos; _ &apos; ) ) ( filter _ reply , options = op ) DCNL DCSP DCSP DCSP ret &#91; &apos; message &apos; &#93; = jxmlease.parse ( etree.tostring ( xml _ reply ) ) DCNL DCSP DCSP DCSP write _ response = etree.tostring ( xml _ reply ) DCNL DCSP DCSP DCSP if ( ( dest is not None ) and ( format ! = &apos; xml &apos; ) ) : DCNL DCSP DCSP DCSP DCSP op.update ( { &apos; format &apos; : format } ) DCNL DCSP DCSP DCSP DCSP rpc _ reply = getattr ( conn.rpc , cmd.replace ( &apos; -&apos; , &apos; _ &apos; ) ) ( filter _ reply , options = op ) DCNL DCSP DCSP DCSP DCSP if ( format = = &apos; json &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP write _ response = json.dumps ( rpc _ reply , indent = 1 ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP write _ response = rpc _ reply.text DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP xml _ reply = getattr ( conn.rpc , cmd.replace ( &apos; -&apos; , &apos; _ &apos; ) ) ( * * op ) DCNL DCSP DCSP DCSP ret &#91; &apos; message &apos; &#93; = jxmlease.parse ( etree.tostring ( xml _ reply ) ) DCNL DCSP DCSP DCSP write _ response = etree.tostring ( xml _ reply ) DCNL DCSP DCSP DCSP if ( ( dest is not None ) and ( format ! = &apos; xml &apos; ) ) : DCNL DCSP DCSP DCSP DCSP rpc _ reply = getattr ( conn.rpc , cmd.replace ( &apos; -&apos; , &apos; _ &apos; ) ) ( { &apos; format &apos; : format } , * * op ) DCNL DCSP DCSP DCSP DCSP if ( format = = &apos; json &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP write _ response = json.dumps ( rpc _ reply , indent = 1 ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP write _ response = rpc _ reply.text DCNL DCSP except Exception as exception : DCNL DCSP DCSP ret &#91; &apos; message &apos; &#93; = &apos; Execution DCSP failed DCSP due DCSP to DCSP &quot; { 0 } &quot; &apos; .format ( exception ) DCNL DCSP DCSP ret &#91; &apos; out &apos; &#93; = False DCNL DCSP if ( dest is not None ) : DCNL DCSP DCSP with fopen ( dest , &apos; w &apos; ) as fp : DCNL DCSP DCSP DCSP fp.write ( write _ response ) DCNL DCSP return ret
DCSP results = { } DCNL DCSP if ( not os.path.exists ( results _ file ) ) : DCNL DCSP DCSP raise IOError ( &apos; Results DCSP file DCSP does DCSP not DCSP exist . &apos; ) DCNL DCSP with open ( results _ file ) as handle : DCNL DCSP DCSP lines = handle.readlines ( ) DCNL DCSP ( results , num _ params ) = _ parse _ baseml.parse _ basics ( lines , results ) DCNL DCSP results = _ parse _ baseml.parse _ parameters ( lines , results , num _ params ) DCNL DCSP if ( results.get ( &apos; version &apos; ) is None ) : DCNL DCSP DCSP raise ValueError ( &apos; Invalid DCSP results DCSP file &apos; ) DCNL DCSP return results
DCSP subprj = get _ subproject ( request , project , subproject ) DCNL DCSP data = &#91; trans.get _ stats ( ) for trans in subprj.translation _ set.all ( ) &#93; DCNL DCSP return export _ response ( request , ( &apos; stats- % s- % s.csv &apos; % ( subprj.project.slug , subprj.slug ) ) , ( &apos; name &apos; , &apos; code &apos; , &apos; total &apos; , &apos; translated &apos; , &apos; translated _ percent &apos; , &apos; total _ words &apos; , &apos; translated _ words &apos; , &apos; failing &apos; , &apos; failing _ percent &apos; , &apos; fuzzy &apos; , &apos; fuzzy _ percent &apos; , &apos; url _ translate &apos; , &apos; url &apos; , &apos; last _ change &apos; , &apos; last _ author &apos; ) , data )
DCSP nodes = Node.query.order _ by ( Node.updated.desc ( ) ) .all ( ) DCNL DCSP return render _ template ( &apos; node / nodes.html &apos; , nodes = nodes )
DCSP return strip _ tags ( value )
DCSP try : DCNL DCSP DCSP gce.ex _ delete _ image ( name ) DCNL DCSP DCSP return True DCNL DCSP except ResourceNotFoundError : DCNL DCSP DCSP return False DCNL DCSP except GoogleBaseError as e : DCNL DCSP DCSP module.fail _ json ( msg = str ( e ) , changed = False )
DCSP if ( &apos; proc _ history &apos; not in info ) : DCNL DCSP DCSP return DCNL DCSP if ( len ( info &#91; &apos; proc _ history &apos; &#93; ) &gt; 0 ) : DCNL DCSP DCSP start _ block ( fid , FIFF.FIFFB _ PROCESSING _ HISTORY ) DCNL DCSP DCSP for record in info &#91; &apos; proc _ history &apos; &#93; : DCNL DCSP DCSP DCSP start _ block ( fid , FIFF.FIFFB _ PROCESSING _ RECORD ) DCNL DCSP DCSP DCSP for ( key , id _ , writer ) in zip ( _ proc _ keys , _ proc _ ids , _ proc _ writers ) : DCNL DCSP DCSP DCSP DCSP if ( key in record ) : DCNL DCSP DCSP DCSP DCSP DCSP writer ( fid , id _ , record &#91; key &#93; ) DCNL DCSP DCSP DCSP _ write _ maxfilter _ record ( fid , record &#91; &apos; max _ info &apos; &#93; ) DCNL DCSP DCSP DCSP if ( &apos; smartshield &apos; in record ) : DCNL DCSP DCSP DCSP DCSP for ss in record &#91; &apos; smartshield &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP start _ block ( fid , FIFF.FIFFB _ SMARTSHIELD ) DCNL DCSP DCSP DCSP DCSP DCSP end _ block ( fid , FIFF.FIFFB _ SMARTSHIELD ) DCNL DCSP DCSP DCSP end _ block ( fid , FIFF.FIFFB _ PROCESSING _ RECORD ) DCNL DCSP DCSP end _ block ( fid , FIFF.FIFFB _ PROCESSING _ HISTORY )
DCSP req = InstallRequirement.from _ line ( &apos; bar &apos; , None ) DCNL DCSP finder = PackageFinder ( &#91; &#93; , &#91; data.index _ url ( &apos; pre &apos; ) &#93; , allow _ all _ prereleases = True , session = PipSession ( ) ) DCNL DCSP link = finder.find _ requirement ( req , False ) DCNL DCSP assert link.url.endswith ( &apos; bar-2.0b1.tar.gz &apos; ) , link.url DCNL DCSP links = &#91; &apos; https : / / foo / bar-1.0.tar.gz &apos; , &apos; https : / / foo / bar-2.0b1.tar.gz &apos; &#93; DCNL DCSP finder = PackageFinder ( links , &#91; &#93; , allow _ all _ prereleases = True , session = PipSession ( ) ) DCNL DCSP with patch.object ( finder , &apos; _ get _ pages &apos; , ( lambda x , y : &#91; &#93; ) ) : DCNL DCSP DCSP link = finder.find _ requirement ( req , False ) DCNL DCSP DCSP assert ( link.url = = &apos; https : / / foo / bar-2.0b1.tar.gz &apos; ) DCNL DCSP links.reverse ( ) DCNL DCSP finder = PackageFinder ( links , &#91; &#93; , allow _ all _ prereleases = True , session = PipSession ( ) ) DCNL DCSP with patch.object ( finder , &apos; _ get _ pages &apos; , ( lambda x , y : &#91; &#93; ) ) : DCNL DCSP DCSP link = finder.find _ requirement ( req , False ) DCNL DCSP DCSP assert ( link.url = = &apos; https : / / foo / bar-2.0b1.tar.gz &apos; )
DCSP profiles = { } DCNL DCSP curr = None DCNL DCSP cmd = &#91; &apos; netsh &apos; , &apos; advfirewall &apos; , &apos; show &apos; , &apos; allprofiles &apos; &#93; DCNL DCSP for line in _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( cmd , python _ shell = False ) .splitlines ( ) : DCNL DCSP DCSP if ( not curr ) : DCNL DCSP DCSP DCSP tmp = re.search ( &apos; ( . * ) DCSP Profile DCSP Settings : &apos; , line ) DCNL DCSP DCSP DCSP if tmp : DCNL DCSP DCSP DCSP DCSP curr = tmp.group ( 1 ) DCNL DCSP DCSP elif line.startswith ( &apos; State &apos; ) : DCNL DCSP DCSP DCSP profiles &#91; curr &#93; = ( line.split ( ) &#91; 1 &#93; = = &apos; ON &apos; ) DCNL DCSP DCSP DCSP curr = None DCNL DCSP return profiles
DCSP mapping = &apos; &apos;.join ( ( ( &#91; chr ( 0 ) for ascii in range ( 0 , 59 ) &#93; + &#91; chr ( ascii ) for ascii in range ( 59 , 127 ) &#93; ) + &#91; chr ( 0 ) for ascii in range ( 127 , 256 ) &#93; ) ) DCNL DCSP assert ( len ( mapping ) = = 256 ) DCNL DCSP return _ fastq _ generic ( in _ handle , out _ handle , mapping )
DCSP filter _ length = len ( filter _ ) DCNL DCSP if ( scope = = &apos; collection &apos; ) : DCNL DCSP DCSP tag = item.collection.get _ meta ( &apos; tag &apos; ) DCNL DCSP else : DCNL DCSP DCSP for component in item.components ( ) : DCNL DCSP DCSP DCSP if ( component.name in ( &apos; VTODO &apos; , &apos; VEVENT &apos; , &apos; VJOURNAL &apos; ) ) : DCNL DCSP DCSP DCSP DCSP tag = component.name DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return False DCNL DCSP if ( filter _ length = = 0 ) : DCNL DCSP DCSP return ( filter _ .get ( &apos; name &apos; ) = = tag ) DCNL DCSP else : DCNL DCSP DCSP if ( filter _ length = = 1 ) : DCNL DCSP DCSP DCSP if ( filter _ &#91; 0 &#93; .tag = = _ tag ( &apos; C &apos; , &apos; is-not-defined &apos; ) ) : DCNL DCSP DCSP DCSP DCSP return ( filter _ .get ( &apos; name &apos; ) ! = tag ) DCNL DCSP DCSP if ( filter _ &#91; 0 &#93; .tag = = _ tag ( &apos; C &apos; , &apos; time-range &apos; ) ) : DCNL DCSP DCSP DCSP if ( not _ time _ range _ match ( item.item , filter _ &#91; 0 &#93; , tag ) ) : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP DCSP DCSP filter _ = filter _ &#91; 1 : &#93; DCNL DCSP DCSP return all ( ( ( _ prop _ match ( item , child ) if ( child.tag = = _ tag ( &apos; C &apos; , &apos; prop-filter &apos; ) ) else _ comp _ match ( item , child , scope = &apos; component &apos; ) ) for child in filter _ ) )
DCSP if ( src _ image.shape ! = target _ image.shape ) : DCNL DCSP DCSP raise ValueError ( &apos; Error : DCSP images DCSP must DCSP be DCSP same DCSP size DCSP for DCSP register _ translation &apos; ) DCNL DCSP if ( ( src _ image.ndim ! = 2 ) and ( upsample _ factor &gt; 1 ) ) : DCNL DCSP DCSP raise NotImplementedError ( &apos; Error : DCSP register _ translation DCSP only DCSP supports DCSP subpixel DCSP registration DCSP for DCSP 2D DCSP images &apos; ) DCNL DCSP if ( space.lower ( ) = = &apos; fourier &apos; ) : DCNL DCSP DCSP src _ freq = src _ image DCNL DCSP DCSP target _ freq = target _ image DCNL DCSP elif ( space.lower ( ) = = &apos; real &apos; ) : DCNL DCSP DCSP src _ image = np.array ( src _ image , dtype = np.complex128 , copy = False ) DCNL DCSP DCSP target _ image = np.array ( target _ image , dtype = np.complex128 , copy = False ) DCNL DCSP DCSP src _ freq = np.fft.fftn ( src _ image ) DCNL DCSP DCSP target _ freq = np.fft.fftn ( target _ image ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Error : DCSP register _ translation DCSP only DCSP knows DCSP the DCSP &quot; real &quot; DCSP and DCSP &quot; fourier &quot; DCSP values DCSP for DCSP the DCSP ``space`` DCSP argument . &apos; ) DCNL DCSP shape = src _ freq.shape DCNL DCSP image _ product = ( src _ freq * target _ freq.conj ( ) ) DCNL DCSP cross _ correlation = np.fft.ifftn ( image _ product ) DCNL DCSP maxima = np.unravel _ index ( np.argmax ( np.abs ( cross _ correlation ) ) , cross _ correlation.shape ) DCNL DCSP midpoints = np.array ( &#91; np.fix ( ( axis _ size / 2 ) ) for axis _ size in shape &#93; ) DCNL DCSP shifts = np.array ( maxima , dtype = np.float64 ) DCNL DCSP shifts &#91; ( shifts &gt; midpoints ) &#93; - = np.array ( shape ) &#91; ( shifts &gt; midpoints ) &#93; DCNL DCSP if ( upsample _ factor = = 1 ) : DCNL DCSP DCSP src _ amp = ( np.sum ( ( np.abs ( src _ freq ) * * 2 ) ) / src _ freq.size ) DCNL DCSP DCSP target _ amp = ( np.sum ( ( np.abs ( target _ freq ) * * 2 ) ) / target _ freq.size ) DCNL DCSP DCSP CCmax = cross _ correlation.max ( ) DCNL DCSP else : DCNL DCSP DCSP shifts = ( np.round ( ( shifts * upsample _ factor ) ) / upsample _ factor ) DCNL DCSP DCSP upsampled _ region _ size = np.ceil ( ( upsample _ factor * 1.5 ) ) DCNL DCSP DCSP dftshift = np.fix ( ( upsampled _ region _ size / 2.0 ) ) DCNL DCSP DCSP upsample _ factor = np.array ( upsample _ factor , dtype = np.float64 ) DCNL DCSP DCSP normalization = ( src _ freq.size * ( upsample _ factor * * 2 ) ) DCNL DCSP DCSP sample _ region _ offset = ( dftshift - ( shifts * upsample _ factor ) ) DCNL DCSP DCSP cross _ correlation = _ upsampled _ dft ( image _ product.conj ( ) , upsampled _ region _ size , upsample _ factor , sample _ region _ offset ) .conj ( ) DCNL DCSP DCSP cross _ correlation / = normalization DCNL DCSP DCSP maxima = np.array ( np.unravel _ index ( np.argmax ( np.abs ( cross _ correlation ) ) , cross _ correlation.shape ) , dtype = np.float64 ) DCNL DCSP DCSP maxima - = dftshift DCNL DCSP DCSP shifts = ( shifts + ( maxima / upsample _ factor ) ) DCNL DCSP DCSP CCmax = cross _ correlation.max ( ) DCNL DCSP DCSP src _ amp = _ upsampled _ dft ( ( src _ freq * src _ freq.conj ( ) ) , 1 , upsample _ factor ) &#91; ( 0 , 0 ) &#93; DCNL DCSP DCSP src _ amp / = normalization DCNL DCSP DCSP target _ amp = _ upsampled _ dft ( ( target _ freq * target _ freq.conj ( ) ) , 1 , upsample _ factor ) &#91; ( 0 , 0 ) &#93; DCNL DCSP DCSP target _ amp / = normalization DCNL DCSP for dim in range ( src _ freq.ndim ) : DCNL DCSP DCSP if ( shape &#91; dim &#93; = = 1 ) : DCNL DCSP DCSP DCSP shifts &#91; dim &#93; = 0 DCNL DCSP return ( shifts , _ compute _ error ( CCmax , src _ amp , target _ amp ) , _ compute _ phasediff ( CCmax ) )
DCSP badge = get _ or _ create _ badge ( badge _ template , year ) DCNL DCSP if badge.is _ awarded _ to ( user ) : DCNL DCSP DCSP return DCNL DCSP from kitsune.questions.models import Answer DCNL DCSP qs = Answer.objects.filter ( creator = user , created _ _ gte = date ( year , 1 , 1 ) , created _ _ lt = date ( ( year + 1 ) , 1 , 1 ) ) DCNL DCSP if ( qs.count ( ) &gt; = 30 ) : DCNL DCSP DCSP badge.award _ to ( user ) DCNL DCSP DCSP return True
DCSP return win32api.RegQueryValue ( GetRootKey ( ) , ( ( GetAppPathsKey ( ) + &apos; \ \ &apos; ) + exeAlias ) )
DCSP return json.loads ( x , object _ hook = json _ hook )
DCSP rgb _ cie _ converter = rgb _ cie.Converter ( ) DCNL DCSP hex _ color _ re = re.compile ( &apos; ( ? &lt; ! \ \ w ) ( &#91; a-f0-9 &#93; ) { 2 } ( &#91; a-f0-9 &#93; ) { 2 } ( &#91; a-f0-9 &#93; ) { 2 } \ \ b &apos; , re.IGNORECASE ) DCNL DCSP if ( color in CSS _ LITERALS ) : DCNL DCSP DCSP color = CSS _ LITERALS &#91; color &#93; DCNL DCSP color = color.lstrip ( &apos; # &apos; ) DCNL DCSP if ( not hex _ color _ re.match ( color ) ) : DCNL DCSP DCSP print &apos; Invalid DCSP color . DCSP Please DCSP use DCSP a DCSP 6-digit DCSP hex DCSP color . &apos; DCNL DCSP DCSP sys.exit ( ) DCNL DCSP return rgb _ cie _ converter.hexToCIE1931 ( color )
DCSP try : DCNL DCSP DCSP if ( int ( kodi _ setting ) = = 0 ) : DCNL DCSP DCSP DCSP return &apos; remove _ this _ line &apos; DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP return kodi _ setting
DCSP single = False DCNL DCSP if ( not is _ sequence ( exprs ) ) : DCNL DCSP DCSP ( exprs , single ) = ( &#91; exprs &#93; , True ) DCNL DCSP exprs = list ( map ( sympify , exprs ) ) DCNL DCSP opt = build _ options ( symbols , options ) DCNL DCSP ( reps , opt ) = _ parallel _ dict _ from _ expr ( exprs , opt ) DCNL DCSP if ( opt.domain is None ) : DCNL DCSP DCSP coeffs = sum ( &#91; list ( rep.values ( ) ) for rep in reps &#93; , &#91; &#93; ) DCNL DCSP DCSP ( opt.domain , _ ) = construct _ domain ( coeffs , opt = opt ) DCNL DCSP _ ring = PolyRing ( opt.gens , opt.domain , opt.order ) DCNL DCSP polys = list ( map ( _ ring.from _ dict , reps ) ) DCNL DCSP if single : DCNL DCSP DCSP return ( _ ring , polys &#91; 0 &#93; ) DCNL DCSP else : DCNL DCSP DCSP return ( _ ring , polys )
DCSP insetLoops = &#91; &#93; DCNL DCSP for loop in loops : DCNL DCSP DCSP insetLoops + = getInsetLoopsFromLoop ( loop , radius ) DCNL DCSP return insetLoops
DCSP logger = logging.getLogger ( ) DCNL DCSP logger.setLevel ( LOG _ LEVEL ) DCNL DCSP fmt = logging.Formatter ( &apos; &#91; % ( asctime ) s &#93; DCSP % ( levelname ) s : DCSP % ( message ) s &apos; ) DCNL DCSP handler = logging.StreamHandler ( ) DCNL DCSP handler.setFormatter ( fmt ) DCNL DCSP logger.addHandler ( handler )
DCSP return ( 16 * MB )
DCSP if ( key = = &apos; env &apos; ) : DCNL DCSP DCSP val = env _ to _ str ( val ) DCNL DCSP elif ( val is None ) : DCNL DCSP DCSP val = &apos; &apos; DCNL DCSP else : DCNL DCSP DCSP val = str ( val ) DCNL DCSP return val
DCSP zip = zipfile.ZipFile ( target , &apos; w &apos; , zipfile.ZIP _ DEFLATED ) DCNL DCSP manifest = _ archive _ package _ sources ( zip.write , sources , sources _ dir ) DCNL DCSP zip.writestr ( _ PACKAGE _ MANIFEST , ( &apos; \ n &apos; .join ( manifest ) + &apos; \ n &apos; ) ) DCNL DCSP zip.close ( ) DCNL DCSP return None
DCSP return PostscriptRepository ( )
DCSP if ( cls is None ) : DCNL DCSP DCSP cls = MultiDict DCNL DCSP if ( isinstance ( s , text _ type ) and ( not isinstance ( separator , text _ type ) ) ) : DCNL DCSP DCSP separator = separator.decode ( ( charset or &apos; ascii &apos; ) ) DCNL DCSP elif ( isinstance ( s , bytes ) and ( not isinstance ( separator , bytes ) ) ) : DCNL DCSP DCSP separator = separator.encode ( ( charset or &apos; ascii &apos; ) ) DCNL DCSP return cls ( _ url _ decode _ impl ( s.split ( separator ) , charset , decode _ keys , include _ empty , errors ) )
DCSP attrs = { } DCNL DCSP _ escapedKey = escape4xml ( key ) DCNL DCSP if ( fullpath in TAGS _ TO _ MODIFY ) : DCNL DCSP DCSP ( tagName , useTitle ) = TAGS _ TO _ MODIFY &#91; fullpath &#93; DCNL DCSP DCSP if useTitle : DCNL DCSP DCSP DCSP attrs &#91; &apos; key &apos; &#93; = _ escapedKey DCNL DCSP elif ( not isinstance ( key , unicode ) ) : DCNL DCSP DCSP if isinstance ( key , str ) : DCNL DCSP DCSP DCSP tagName = unicode ( key , &apos; ascii &apos; , &apos; ignore &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP strType = str ( type ( key ) ) .replace ( &quot; &lt; type DCSP &apos; &quot; , &apos; &apos; ) .replace ( &quot; &apos; &gt; &quot; , &apos; &apos; ) DCNL DCSP DCSP DCSP attrs &#91; &apos; keytype &apos; &#93; = strType DCNL DCSP DCSP DCSP tagName = unicode ( key ) DCNL DCSP else : DCNL DCSP DCSP tagName = key DCNL DCSP if isinstance ( key , int ) : DCNL DCSP DCSP attrs &#91; &apos; keytype &apos; &#93; = &apos; int &apos; DCNL DCSP origTagName = tagName DCNL DCSP tagName = tagName.lower ( ) .replace ( &apos; DCSP &apos; , &apos; -&apos; ) DCNL DCSP tagName = str ( tagName ) .translate ( _ allchars , _ keepchars ) DCNL DCSP if ( origTagName ! = tagName ) : DCNL DCSP DCSP if ( &apos; key &apos; not in attrs ) : DCNL DCSP DCSP DCSP attrs &#91; &apos; key &apos; &#93; = _ escapedKey DCNL DCSP if ( ( not tagName ) or tagName &#91; 0 &#93; .isdigit ( ) or ( tagName &#91; 0 &#93; = = &apos; -&apos; ) ) : DCNL DCSP DCSP tagName = &apos; item &apos; DCNL DCSP DCSP _ utils _ logger.error ( ( &apos; invalid DCSP tag : DCSP % s DCSP &#91; % s &#93; &apos; % ( _ escapedKey , fullpath ) ) ) DCNL DCSP DCSP attrs &#91; &apos; key &apos; &#93; = _ escapedKey DCNL DCSP return ( tagName , u &apos; DCSP &apos; .join ( &#91; ( u &apos; % s = &quot; % s &quot; &apos; % i ) for i in attrs.items ( ) &#93; ) )
DCSP module _ path = dirname ( _ _ file _ _ ) DCNL DCSP fdescr _ name = join ( module _ path , &apos; descr &apos; , &apos; boston _ house _ prices.rst &apos; ) DCNL DCSP with open ( fdescr _ name ) as f : DCNL DCSP DCSP descr _ text = f.read ( ) DCNL DCSP data _ file _ name = join ( module _ path , &apos; data &apos; , &apos; boston _ house _ prices.csv &apos; ) DCNL DCSP with open ( data _ file _ name ) as f : DCNL DCSP DCSP data _ file = csv.reader ( f ) DCNL DCSP DCSP temp = next ( data _ file ) DCNL DCSP DCSP n _ samples = int ( temp &#91; 0 &#93; ) DCNL DCSP DCSP n _ features = int ( temp &#91; 1 &#93; ) DCNL DCSP DCSP data = np.empty ( ( n _ samples , n _ features ) ) DCNL DCSP DCSP target = np.empty ( ( n _ samples , ) ) DCNL DCSP DCSP temp = next ( data _ file ) DCNL DCSP DCSP feature _ names = np.array ( temp ) DCNL DCSP DCSP for ( i , d ) in enumerate ( data _ file ) : DCNL DCSP DCSP DCSP data &#91; i &#93; = np.asarray ( d &#91; : ( -1 ) &#93; , dtype = np.float64 ) DCNL DCSP DCSP DCSP target &#91; i &#93; = np.asarray ( d &#91; ( -1 ) &#93; , dtype = np.float64 ) DCNL DCSP if return _ X _ y : DCNL DCSP DCSP return ( data , target ) DCNL DCSP return Bunch ( data = data , target = target , feature _ names = feature _ names &#91; : ( -1 ) &#93; , DESCR = descr _ text )
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : True , &apos; changes &apos; : { } , &apos; comment &apos; : &apos; &apos; } DCNL DCSP tRet = _ _ salt _ _ &#91; &apos; win _ dacl.check _ inheritance &apos; &#93; ( name , objectType ) DCNL DCSP if tRet &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP if tRet &#91; &apos; Inheritance &apos; &#93; : DCNL DCSP DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; Inheritance &apos; &#93; = &apos; Disabled &apos; DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Inheritance DCSP is DCSP set DCSP to DCSP be DCSP disabled . &apos; DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; &apos; Inherited DCSP ACLs &apos; &#93; = ( &apos; Are DCSP set DCSP to DCSP be DCSP kept &apos; if copy _ inherited _ acl else &apos; Are DCSP set DCSP to DCSP be DCSP removed &apos; ) DCNL DCSP DCSP DCSP DCSP return ret DCNL DCSP DCSP DCSP eRet = _ _ salt _ _ &#91; &apos; win _ dacl.disable _ inheritance &apos; &#93; ( name , objectType , copy _ inherited _ acl ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = eRet &#91; &apos; result &apos; &#93; DCNL DCSP DCSP DCSP if eRet &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = dict ( ret &#91; &apos; changes &apos; &#93; , * * eRet &#91; &apos; changes &apos; &#93; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; DCSP &apos; .join ( &#91; ret &#91; &apos; comment &apos; &#93; , eRet &#91; &apos; comment &apos; &#93; &#93; ) DCNL DCSP DCSP elif _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Inheritance DCSP is DCSP disabled . &apos; DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = tRet &#91; &apos; comment &apos; &#93; DCNL DCSP return ret
DCSP query = &apos; SELECT DCSP load DCSP FROM DCSP salt.jids DCSP WHERE DCSP jid DCSP = DCSP ? ; &apos; DCNL DCSP ret = { } DCNL DCSP try : DCNL DCSP DCSP data = _ _ salt _ _ &#91; &apos; cassandra _ cql.cql _ query _ with _ prepare &apos; &#93; ( query , &apos; get _ load &apos; , &#91; jid &#93; ) DCNL DCSP DCSP if data : DCNL DCSP DCSP DCSP load = data &#91; 0 &#93; .get ( &apos; load &apos; ) DCNL DCSP DCSP DCSP if load : DCNL DCSP DCSP DCSP DCSP ret = json.loads ( load ) DCNL DCSP except CommandExecutionError : DCNL DCSP DCSP log.critical ( &apos; Could DCSP not DCSP get DCSP load DCSP from DCSP jids DCSP table . &apos; ) DCNL DCSP DCSP raise DCNL DCSP except Exception as e : DCNL DCSP DCSP log.critical ( &apos; Unexpected DCSP error DCSP while DCSP getting DCSP load DCSP from DCSP jids : DCSP { 0 } &apos; .format ( str ( e ) ) ) DCNL DCSP DCSP raise DCNL DCSP return ret
DCSP assert ( n &gt; 0 ) DCNL DCSP s = &apos; &apos; DCNL DCSP while n : DCNL DCSP DCSP ( n , m ) = divmod ( ( n - 1 ) , 26 ) DCNL DCSP DCSP s = ( chr ( ( m + ord ( &apos; A &apos; ) ) ) + s ) DCNL DCSP return s
DCSP reserved _ requests.add ( request )
DCSP sheet = container.parse _ css ( raw ) DCNL DCSP return serialize ( sheet , u &apos;text / css &apos; )
DCSP report = ( &apos; blocked-uri &apos; , &apos; violated-directive &apos; , &apos; original-policy &apos; ) DCNL DCSP if ( not waffle.sample _ is _ active ( &apos; csp-store-reports &apos; ) ) : DCNL DCSP DCSP return HttpResponse ( ) DCNL DCSP try : DCNL DCSP DCSP v = json.loads ( request.body ) &#91; &apos; csp-report &apos; &#93; DCNL DCSP DCSP meta = request.META.copy ( ) DCNL DCSP DCSP meta &#91; &apos; PATH _ INFO &apos; &#93; = v.get ( &apos; document-uri &apos; , meta &#91; &apos; PATH _ INFO &apos; &#93; ) DCNL DCSP DCSP v = &#91; ( k , v &#91; k &#93; ) for k in report if ( k in v ) &#93; DCNL DCSP DCSP log _ cef ( &apos; CSPViolation &apos; , 5 , meta , signature = &apos; CSPREPORT &apos; , msg = &apos; A DCSP client DCSP reported DCSP a DCSP CSP DCSP violation &apos; , cs6 = v , cs6Label = &apos; ContentPolicy &apos; ) DCNL DCSP except ( KeyError , ValueError ) as e : DCNL DCSP DCSP log.debug ( ( &apos; Exception DCSP in DCSP CSP DCSP report : DCSP % s &apos; % e ) , exc _ info = True ) DCNL DCSP DCSP return HttpResponseBadRequest ( ) DCNL DCSP return HttpResponse ( )
DCSP if ( str ( value ) .lower ( ) not in ( &apos; true &apos; , &apos; false &apos; ) ) : DCNL DCSP DCSP raise ValueError ( ( _ ( &apos; Unrecognized DCSP value DCSP &quot; % ( value ) s &quot; DCSP for DCSP &quot; % ( name ) s &quot; , DCSP acceptable DCSP values DCSP are : DCSP true , DCSP false . &apos; ) % { &apos; value &apos; : value , &apos; name &apos; : name } ) ) DCNL DCSP return strutils.bool _ from _ string ( value , strict = True )
DCSP try : DCNL DCSP DCSP if call : DCNL DCSP DCSP DCSP version = getattr ( module , attr ) ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP version = getattr ( module , attr ) DCNL DCSP except Exception as e : DCNL DCSP DCSP print e DCNL DCSP DCSP version = &apos; Version DCSP could DCSP not DCSP be DCSP acquired ! &apos; DCNL DCSP if ( not isinstance ( version , str ) ) : DCNL DCSP DCSP version = list2string ( version ) DCNL DCSP return version
DCSP def wrapper ( self , * args , * * kwargs ) : DCNL DCSP DCSP if self.closed : DCNL DCSP DCSP DCSP raise IOError ( errno.EBADF , &apos; I / O DCSP operation DCSP on DCSP closed DCSP file &apos; ) DCNL DCSP DCSP return func ( self , * args , * * kwargs ) DCNL DCSP return wrapper
DCSP hps.batch _ size = 100 DCNL DCSP with tf.Graph ( ) .as _ default ( ) : DCNL DCSP DCSP with tf.device ( &apos; / cpu : 0 &apos; ) : DCNL DCSP DCSP DCSP with tf.variable _ scope ( &apos; model &apos; ) as var _ scope : DCNL DCSP DCSP DCSP DCSP eval _ model = RealNVP ( hps ) DCNL DCSP DCSP DCSP DCSP summary _ writer = tf.summary.FileWriter ( logdir ) DCNL DCSP DCSP DCSP DCSP var _ scope.reuse _ variables ( ) DCNL DCSP DCSP DCSP saver = tf.train.Saver ( ) DCNL DCSP DCSP DCSP sess = tf.Session ( config = tf.ConfigProto ( allow _ soft _ placement = True , log _ device _ placement = True ) ) DCNL DCSP DCSP DCSP tf.train.start _ queue _ runners ( sess ) DCNL DCSP DCSP DCSP previous _ global _ step = 0 DCNL DCSP DCSP DCSP with sess.as _ default ( ) : DCNL DCSP DCSP DCSP DCSP while True : DCNL DCSP DCSP DCSP DCSP DCSP ckpt _ state = tf.train.get _ checkpoint _ state ( traindir ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not ( ckpt _ state and ckpt _ state.model _ checkpoint _ path ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP print ( &apos; No DCSP model DCSP to DCSP eval DCSP yet DCSP at DCSP % s &apos; % traindir ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP time.sleep ( 30 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; Loading DCSP file DCSP % s &apos; % ckpt _ state.model _ checkpoint _ path ) DCNL DCSP DCSP DCSP DCSP DCSP saver.restore ( sess , ckpt _ state.model _ checkpoint _ path ) DCNL DCSP DCSP DCSP DCSP DCSP current _ step = tf.train.global _ step ( sess , eval _ model.step ) DCNL DCSP DCSP DCSP DCSP DCSP if ( current _ step = = previous _ global _ step ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP print &apos; Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP updated . &apos; DCNL DCSP DCSP DCSP DCSP DCSP DCSP time.sleep ( 30 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP previous _ global _ step = current _ step DCNL DCSP DCSP DCSP DCSP DCSP print &apos; Evaluating ... &apos; DCNL DCSP DCSP DCSP DCSP DCSP bit _ per _ dim = eval _ model.eval _ epoch ( hps ) DCNL DCSP DCSP DCSP DCSP DCSP print ( &apos; Epoch : DCSP % d , DCSP % s DCSP - &gt; DCSP % .3f DCSP bits / dim &apos; % ( current _ step , subset , bit _ per _ dim ) ) DCNL DCSP DCSP DCSP DCSP DCSP print &apos; Writing DCSP summary ... &apos; DCNL DCSP DCSP DCSP DCSP DCSP summary = tf.Summary ( ) DCNL DCSP DCSP DCSP DCSP DCSP summary.value.extend ( &#91; tf.Summary.Value ( tag = &apos; bit _ per _ dim &apos; , simple _ value = bit _ per _ dim ) &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP summary _ writer.add _ summary ( summary , current _ step ) DCNL DCSP DCSP DCSP DCSP DCSP if return _ val : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return ( current _ step , bit _ per _ dim )
DCSP parser.skip _ past ( &apos; endcomment &apos; ) DCNL DCSP return CommentNode ( )
DCSP path = find _ cmd ( &apos; ls &apos; ) DCNL DCSP nt.assert _ true ( path.endswith ( &apos; ls &apos; ) )
DCSP return trapz ( y = y , x = x )
DCSP if _ PY3 : DCNL DCSP DCSP if isinstance ( s , binary _ type ) : DCNL DCSP DCSP DCSP s = s.decode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP if ( type ( s ) is not text _ type ) : DCNL DCSP DCSP DCSP s = text _ type ( s ) DCNL DCSP else : DCNL DCSP DCSP if ( isinstance ( s , str ) and ( HAS _ UTF8.search ( s ) is not None ) ) : DCNL DCSP DCSP DCSP s = s.decode ( &apos; utf-8 &apos; ) DCNL DCSP DCSP if ( type ( s ) not in string _ types ) : DCNL DCSP DCSP DCSP s = text _ type ( s ) DCNL DCSP def replace ( match ) : DCNL DCSP DCSP s = match.group ( 0 ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return ESCAPE _ DCT &#91; s &#93; DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP n = ord ( s ) DCNL DCSP DCSP DCSP if ( n &lt; 65536 ) : DCNL DCSP DCSP DCSP DCSP return ( &apos; \ \ u % 04x &apos; % ( n , ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP n - = 65536 DCNL DCSP DCSP DCSP DCSP s1 = ( 55296 &#124; ( ( n &gt; &gt; 10 ) &amp; 1023 ) ) DCNL DCSP DCSP DCSP DCSP s2 = ( 56320 &#124; ( n &amp; 1023 ) ) DCNL DCSP DCSP DCSP DCSP return ( &apos; \ \ u % 04x \ \ u % 04x &apos; % ( s1 , s2 ) ) DCNL DCSP return ( ( &apos; &quot; &apos; + str ( ESCAPE _ ASCII.sub ( replace , s ) ) ) + &apos; &quot; &apos; )
DCSP return _ _ salt _ _ &#91; &apos; reg.set _ value &apos; &#93; ( hive = &apos; HKLM &apos; , key = MINION _ VOLATILE _ KEY , volatile = True , vname = REBOOT _ REQUIRED _ NAME , vdata = 1 , vtype = &apos; REG _ DWORD &apos; )
DCSP with tf.name _ scope ( scope , &apos; eval _ image &apos; , &#91; image , height , width &#93; ) : DCNL DCSP DCSP if ( image.dtype ! = tf.float32 ) : DCNL DCSP DCSP DCSP image = tf.image.convert _ image _ dtype ( image , dtype = tf.float32 ) DCNL DCSP DCSP if central _ fraction : DCNL DCSP DCSP DCSP image = tf.image.central _ crop ( image , central _ fraction = central _ fraction ) DCNL DCSP DCSP if ( height and width ) : DCNL DCSP DCSP DCSP image = tf.expand _ dims ( image , 0 ) DCNL DCSP DCSP DCSP image = tf.image.resize _ bilinear ( image , &#91; height , width &#93; , align _ corners = False ) DCNL DCSP DCSP DCSP image = tf.squeeze ( image , &#91; 0 &#93; ) DCNL DCSP DCSP image = tf.sub ( image , 0.5 ) DCNL DCSP DCSP image = tf.mul ( image , 2.0 ) DCNL DCSP DCSP return image
DCSP siteconfig = SiteConfiguration.objects.get _ current ( ) DCNL DCSP if siteconfig.get ( u &apos;mail _ send _ new _ user _ mail &apos; ) : DCNL DCSP DCSP mail _ new _ user ( user )
DCSP if ( path is None ) : DCNL DCSP DCSP path = os.path.join ( os.path.dirname ( _ _ file _ _ ) , os.pardir ) DCNL DCSP elif os.path.isfile ( path ) : DCNL DCSP DCSP path = os.path.dirname ( path ) DCNL DCSP source _ dir = os.path.abspath ( path ) DCNL DCSP return os.path.exists ( os.path.join ( source _ dir , &apos; .astropy-root &apos; ) )
DCSP print ( &apos; Converting DCSP data DCSP into DCSP % s DCSP ... &apos; % filename ) DCNL DCSP cwd = os.getcwd ( ) DCNL DCSP writer = tf.python _ io.TFRecordWriter ( filename ) DCNL DCSP for ( index , img ) in enumerate ( images ) : DCNL DCSP DCSP img _ raw = img.tobytes ( ) DCNL DCSP DCSP label = int ( labels &#91; index &#93; ) DCNL DCSP DCSP example = tf.train.Example ( features = tf.train.Features ( feature = { &apos; label &apos; : tf.train.Feature ( int64 _ list = tf.train.Int64List ( value = &#91; label &#93; ) ) , &apos; img _ raw &apos; : tf.train.Feature ( bytes _ list = tf.train.BytesList ( value = &#91; img _ raw &#93; ) ) } ) ) DCNL DCSP DCSP writer.write ( example.SerializeToString ( ) ) DCNL DCSP writer.close ( )
DCSP new _ fd = False DCNL DCSP if isinstance ( f , str ) : DCNL DCSP DCSP new _ fd = True DCNL DCSP DCSP f = open ( f , &apos; wb &apos; ) DCNL DCSP try : DCNL DCSP DCSP return _ save ( obj , f , pickle _ module , pickle _ protocol ) DCNL DCSP finally : DCNL DCSP DCSP if new _ fd : DCNL DCSP DCSP DCSP f.close ( )
DCSP size = len ( list1 ) DCNL DCSP sum1 = sum ( list1 ) DCNL DCSP sum2 = sum ( list2 ) DCNL DCSP sum _ sq1 = sum ( &#91; pow ( l , 2 ) for l in list1 &#93; ) DCNL DCSP sum _ sq2 = sum ( &#91; pow ( l , 2 ) for l in list2 &#93; ) DCNL DCSP prod _ sum = sum ( &#91; ( list1 &#91; i &#93; * list2 &#91; i &#93; ) for i in range ( size ) &#93; ) DCNL DCSP num = ( prod _ sum - ( ( sum1 * sum2 ) / float ( size ) ) ) DCNL DCSP den = sqrt ( ( ( sum _ sq1 - ( pow ( sum1 , 2.0 ) / size ) ) * ( sum _ sq2 - ( pow ( sum2 , 2.0 ) / size ) ) ) ) DCNL DCSP return ( num / den )
DCSP _ initialize ( ) DCNL DCSP _ interact ( ) DCNL DCSP d = GetNewDialog ( id , ( -1 ) ) DCNL DCSP if ( not d ) : DCNL DCSP DCSP print &quot; EasyDialogs : DCSP Can &apos;t DCSP get DCSP DLOG DCSP resource DCSP with DCSP id DCSP = &quot; , id , &apos; DCSP ( missing DCSP resource DCSP file ? ) &apos; DCNL DCSP DCSP return DCNL DCSP h = d.GetDialogItemAsControl ( 3 ) DCNL DCSP SetDialogItemText ( h , lf2cr ( prompt ) ) DCNL DCSP h = d.GetDialogItemAsControl ( 4 ) DCNL DCSP SetDialogItemText ( h , lf2cr ( default ) ) DCNL DCSP d.SelectDialogItemText ( 4 , 0 , 999 ) DCNL DCSP if ( ok is not None ) : DCNL DCSP DCSP h = d.GetDialogItemAsControl ( 1 ) DCNL DCSP DCSP h.SetControlTitle ( ok ) DCNL DCSP if ( cancel is not None ) : DCNL DCSP DCSP h = d.GetDialogItemAsControl ( 2 ) DCNL DCSP DCSP h.SetControlTitle ( cancel ) DCNL DCSP d.SetDialogDefaultItem ( 1 ) DCNL DCSP d.SetDialogCancelItem ( 2 ) DCNL DCSP d.AutoSizeDialog ( ) DCNL DCSP d.GetDialogWindow ( ) .ShowWindow ( ) DCNL DCSP while 1 : DCNL DCSP DCSP n = ModalDialog ( None ) DCNL DCSP DCSP if ( n = = 1 ) : DCNL DCSP DCSP DCSP h = d.GetDialogItemAsControl ( 4 ) DCNL DCSP DCSP DCSP return cr2lf ( GetDialogItemText ( h ) ) DCNL DCSP DCSP if ( n = = 2 ) : DCNL DCSP DCSP DCSP return None
DCSP for fmt in formats.available : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if fmt.detect ( stream ) : DCNL DCSP DCSP DCSP DCSP return ( fmt , stream ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP pass DCNL DCSP return ( None , stream )
DCSP if ( &apos; neutron / tests &apos; in filename ) : DCNL DCSP DCSP return DCNL DCSP if pep8.noqa ( physical _ line ) : DCNL DCSP DCSP return DCNL DCSP msg = &apos; N320 : DCSP Log DCSP messages DCSP require DCSP translation DCSP hints ! &apos; DCNL DCSP if log _ translation _ hint.match ( logical _ line ) : DCNL DCSP DCSP ( yield ( 0 , msg ) )
DCSP newfiles = &#91; &#93; DCNL DCSP bufsize = ( ( 24 * 1024 ) * 1024 ) DCNL DCSP joinable _ sets = { } DCNL DCSP joinable _ set = None DCNL DCSP for joinable in joinables : DCNL DCSP DCSP ( head , tail ) = os.path.splitext ( joinable ) DCNL DCSP DCSP if ( tail = = &apos; .ts &apos; ) : DCNL DCSP DCSP DCSP head = match _ ts ( joinable ) &#91; 1 &#93; DCNL DCSP DCSP if ( head not in joinable _ sets ) : DCNL DCSP DCSP DCSP joinable _ sets &#91; head &#93; = &#91; &#93; DCNL DCSP DCSP joinable _ sets &#91; head &#93; .append ( joinable ) DCNL DCSP logging.debug ( &apos; joinable _ sets : DCSP % s &apos; , joinable _ sets ) DCNL DCSP try : DCNL DCSP DCSP for joinable _ set in joinable _ sets : DCNL DCSP DCSP DCSP current = joinable _ sets &#91; joinable _ set &#93; DCNL DCSP DCSP DCSP joinable _ sets &#91; joinable _ set &#93; .sort ( ) DCNL DCSP DCSP DCSP if os.path.exists ( joinable _ set ) : DCNL DCSP DCSP DCSP DCSP logging.debug ( &apos; file _ join ( ) : DCSP Skipping DCSP % s , DCSP ( probably ) DCSP joined DCSP by DCSP par2 &apos; , joinable _ set ) DCNL DCSP DCSP DCSP DCSP if delete : DCNL DCSP DCSP DCSP DCSP DCSP clean _ up _ joinables ( current ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP size = len ( current ) DCNL DCSP DCSP DCSP if ( size &lt; 2 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP filename = joinable _ set DCNL DCSP DCSP DCSP if workdir _ complete : DCNL DCSP DCSP DCSP DCSP filename = filename.replace ( workdir , workdir _ complete ) DCNL DCSP DCSP DCSP logging.debug ( &apos; file _ join ( ) : DCSP Assembling DCSP % s &apos; , filename ) DCNL DCSP DCSP DCSP joined _ file = open ( filename , &apos; ab &apos; ) DCNL DCSP DCSP DCSP n = get _ seq _ number ( current &#91; 0 &#93; ) DCNL DCSP DCSP DCSP seq _ error = ( n &gt; 1 ) DCNL DCSP DCSP DCSP for joinable in current : DCNL DCSP DCSP DCSP DCSP if ( get _ seq _ number ( joinable ) ! = n ) : DCNL DCSP DCSP DCSP DCSP DCSP seq _ error = True DCNL DCSP DCSP DCSP DCSP perc = ( ( 100.0 / size ) * n ) DCNL DCSP DCSP DCSP DCSP logging.debug ( &apos; Processing DCSP % s &apos; , joinable ) DCNL DCSP DCSP DCSP DCSP nzo.set _ action _ line ( T ( &apos; Joining &apos; ) , ( &apos; % .0f % % &apos; % perc ) ) DCNL DCSP DCSP DCSP DCSP f = open ( joinable , &apos; rb &apos; ) DCNL DCSP DCSP DCSP DCSP shutil.copyfileobj ( f , joined _ file , bufsize ) DCNL DCSP DCSP DCSP DCSP f.close ( ) DCNL DCSP DCSP DCSP DCSP if delete : DCNL DCSP DCSP DCSP DCSP DCSP logging.debug ( &apos; Deleting DCSP % s &apos; , joinable ) DCNL DCSP DCSP DCSP DCSP DCSP os.remove ( joinable ) DCNL DCSP DCSP DCSP DCSP n + = 1 DCNL DCSP DCSP DCSP clean _ up _ joinables ( current ) DCNL DCSP DCSP DCSP joined _ file.flush ( ) DCNL DCSP DCSP DCSP joined _ file.close ( ) DCNL DCSP DCSP DCSP newfiles.append ( filename ) DCNL DCSP DCSP DCSP if seq _ error : DCNL DCSP DCSP DCSP DCSP msg = T ( &apos; Incomplete DCSP sequence DCSP of DCSP joinable DCSP files &apos; ) DCNL DCSP DCSP DCSP DCSP nzo.fail _ msg = ( T ( &apos; File DCSP join DCSP of DCSP % s DCSP failed &apos; ) % unicoder ( joinable _ set ) ) DCNL DCSP DCSP DCSP DCSP nzo.set _ unpack _ info ( &apos; Filejoin &apos; , ( T ( &apos; &#91; % s &#93; DCSP Error DCSP &quot; % s &quot; DCSP while DCSP joining DCSP files &apos; ) % ( unicoder ( joinable _ set ) , msg ) ) ) DCNL DCSP DCSP DCSP DCSP logging.error ( T ( &apos; Error DCSP &quot; % s &quot; DCSP while DCSP running DCSP file _ join DCSP on DCSP % s &apos; ) , msg , nzo.final _ name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP msg = ( T ( &apos; &#91; % s &#93; DCSP Joined DCSP % s DCSP files &apos; ) % ( unicoder ( joinable _ set ) , size ) ) DCNL DCSP DCSP DCSP DCSP nzo.set _ unpack _ info ( &apos; Filejoin &apos; , msg , set = joinable _ set ) DCNL DCSP except : DCNL DCSP DCSP msg = sys.exc _ info ( ) &#91; 1 &#93; DCNL DCSP DCSP nzo.fail _ msg = ( T ( &apos; File DCSP join DCSP of DCSP % s DCSP failed &apos; ) % msg ) DCNL DCSP DCSP nzo.set _ unpack _ info ( &apos; Filejoin &apos; , ( T ( &apos; &#91; % s &#93; DCSP Error DCSP &quot; % s &quot; DCSP while DCSP joining DCSP files &apos; ) % ( unicoder ( joinable _ set ) , msg ) ) ) DCNL DCSP DCSP logging.error ( T ( &apos; Error DCSP &quot; % s &quot; DCSP while DCSP running DCSP file _ join DCSP on DCSP % s &apos; ) , msg , nzo.final _ name ) DCNL DCSP DCSP return ( True , &#91; &#93; ) DCNL DCSP return ( False , newfiles )
DCSP if ( not isinstance ( client _ id , basestring ) ) : DCNL DCSP DCSP raise InvalidChannelClientIdError ( ( &apos; &quot; % s &quot; DCSP is DCSP not DCSP a DCSP string . &apos; % client _ id ) ) DCNL DCSP if isinstance ( client _ id , unicode ) : DCNL DCSP DCSP client _ id = client _ id.encode ( &apos; utf-8 &apos; ) DCNL DCSP if ( len ( client _ id ) &gt; MAXIMUM _ CLIENT _ ID _ LENGTH ) : DCNL DCSP DCSP msg = ( &apos; Client DCSP id DCSP length DCSP % d DCSP is DCSP greater DCSP than DCSP max DCSP length DCSP % d &apos; % ( len ( client _ id ) , MAXIMUM _ CLIENT _ ID _ LENGTH ) ) DCNL DCSP DCSP raise InvalidChannelClientIdError ( msg ) DCNL DCSP return client _ id
DCSP warnings.warn ( &apos; isvector DCSP has DCSP been DCSP moved DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there &apos; , DeprecationWarning ) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.isvector ( x , y , xi , extrap = extrap )
DCSP if ( isinstance ( node.op , T.Elemwise ) and isinstance ( node.op.scalar _ op , ( theano.scalar.IntDiv , theano.scalar.TrueDiv ) ) ) : DCNL DCSP DCSP if ( local _ mul _ canonizer.get _ constant ( node.inputs &#91; 0 &#93; ) = = 0 ) : DCNL DCSP DCSP DCSP ret = broadcast _ like ( 0 , node.outputs &#91; 0 &#93; , node.fgraph ) DCNL DCSP DCSP DCSP ret.tag.values _ eq _ approx = values _ eq _ approx _ remove _ nan DCNL DCSP DCSP DCSP return &#91; ret &#93;
DCSP def one ( ) : DCNL DCSP DCSP return a DCNL DCSP def two ( ) : DCNL DCSP DCSP return b DCNL DCSP def three ( ) : DCNL DCSP DCSP return c DCNL DCSP def new _ closure ( a , b ) : DCNL DCSP DCSP def sum ( ) : DCNL DCSP DCSP DCSP return ( a + b ) DCNL DCSP DCSP return sum DCNL DCSP ( yield one ) DCNL DCSP ( yield two ) DCNL DCSP ( yield three ) DCNL DCSP ( yield new _ closure ( a , c ) )
DCSP if use _ sfftools : DCNL DCSP DCSP _ fail _ on _ gzipped _ sff ( sff _ fp ) DCNL DCSP DCSP check _ sffinfo ( ) DCNL DCSP DCSP if no _ trim : DCNL DCSP DCSP DCSP _ check _ call ( &#91; &apos; sffinfo &apos; , &apos; -notrim &apos; , &apos; -s &apos; , sff _ fp &#93; , stdout = open ( output _ fp , &apos; w &apos; ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP _ check _ call ( &#91; &apos; sffinfo &apos; , &apos; -s &apos; , sff _ fp &#93; , stdout = open ( output _ fp , &apos; w &apos; ) ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP format _ binary _ sff _ as _ fna ( qiime _ open ( sff _ fp , &apos; rb &apos; ) , open ( output _ fp , &apos; w &apos; ) ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP raise IOError ( ( &apos; Could DCSP not DCSP parse DCSP SFF DCSP % s &apos; % sff _ fp ) )
DCSP logger.debug ( &apos; worker DCSP process DCSP entering DCSP E-step DCSP loop &apos; ) DCNL DCSP while True : DCNL DCSP DCSP logger.debug ( &apos; getting DCSP a DCSP new DCSP job &apos; ) DCNL DCSP DCSP ( chunk _ no , chunk , worker _ lda ) = input _ queue.get ( ) DCNL DCSP DCSP logger.debug ( &apos; processing DCSP chunk DCSP # % i DCSP of DCSP % i DCSP documents &apos; , chunk _ no , len ( chunk ) ) DCNL DCSP DCSP worker _ lda.state.reset ( ) DCNL DCSP DCSP worker _ lda.do _ estep ( chunk ) DCNL DCSP DCSP del chunk DCNL DCSP DCSP logger.debug ( &apos; processed DCSP chunk , DCSP queuing DCSP the DCSP result &apos; ) DCNL DCSP DCSP result _ queue.put ( worker _ lda.state ) DCNL DCSP DCSP del worker _ lda DCNL DCSP DCSP logger.debug ( &apos; result DCSP put &apos; )
DCSP from sklearn.base import clone DCNL DCSP estimators _ = list ( ) DCNL DCSP for ii in range ( X.shape &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP est = clone ( estimator ) DCNL DCSP DCSP est.fit ( X &#91; ... , ii &#93; , y ) DCNL DCSP DCSP estimators _ .append ( est ) DCNL DCSP return estimators _
DCSP if ( not isinstance ( t , TensExpr ) ) : DCNL DCSP DCSP return t DCNL DCSP new _ tids = get _ tids ( t ) .perm2tensor ( g , canon _ bp ) DCNL DCSP coeff = get _ coeff ( t ) DCNL DCSP if ( g &#91; ( -1 ) &#93; ! = ( len ( g ) - 1 ) ) : DCNL DCSP DCSP coeff = ( - coeff ) DCNL DCSP res = TensMul.from _ TIDS ( coeff , new _ tids , is _ canon _ bp = canon _ bp ) DCNL DCSP return res
DCSP r _ url = get _ results _ raw _ url ( build ) DCNL DCSP if ( not r _ url ) : DCNL DCSP DCSP return DCNL DCSP return convert _ json _ to _ df ( r _ url )
DCSP import hashlib DCNL DCSP m = hashlib.md5 ( ) DCNL DCSP m.update ( f ) DCNL DCSP return m.hexdigest ( )
DCSP from sklearn.linear _ model import Ridge , LogisticRegression DCNL DCSP from sklearn.pipeline import make _ pipeline DCNL DCSP from sklearn.metrics import roc _ auc _ score , get _ scorer , make _ scorer DCNL DCSP ( X , y ) = make _ data ( ) DCNL DCSP ( n _ epochs , _ , n _ time ) = X.shape DCNL DCSP assert _ raises ( ValueError , _ SearchLight , &apos; foo &apos; ) DCNL DCSP sl = _ SearchLight ( Ridge ( ) ) DCNL DCSP sl = _ SearchLight ( LogisticRegression ( ) ) DCNL DCSP assert _ equal ( sl . _ _ repr _ _ ( ) &#91; : 14 &#93; , &apos; &lt; _ SearchLight ( &apos; ) DCNL DCSP sl.fit ( X , y ) DCNL DCSP assert _ equal ( sl . _ _ repr _ _ ( ) &#91; ( -28 ) : &#93; , &apos; , DCSP fitted DCSP with DCSP 10 DCSP estimators &gt; &apos; ) DCNL DCSP assert _ raises ( ValueError , sl.fit , X &#91; 1 : &#93; , y ) DCNL DCSP assert _ raises ( ValueError , sl.fit , X &#91; : , : , 0 &#93; , y ) DCNL DCSP assert _ raises ( ValueError , sl.predict , X &#91; : , : , : 2 &#93; ) DCNL DCSP y _ pred = sl.predict ( X ) DCNL DCSP assert _ true ( ( y _ pred.dtype = = int ) ) DCNL DCSP assert _ array _ equal ( y _ pred.shape , &#91; n _ epochs , n _ time &#93; ) DCNL DCSP y _ proba = sl.predict _ proba ( X ) DCNL DCSP assert _ true ( ( y _ proba.dtype = = float ) ) DCNL DCSP assert _ array _ equal ( y _ proba.shape , &#91; n _ epochs , n _ time , 2 &#93; ) DCNL DCSP score = sl.score ( X , y ) DCNL DCSP assert _ array _ equal ( score.shape , &#91; n _ time &#93; ) DCNL DCSP assert _ true ( ( np.sum ( np.abs ( score ) ) ! = 0 ) ) DCNL DCSP assert _ true ( ( score.dtype = = float ) ) DCNL DCSP sl = _ SearchLight ( LogisticRegression ( ) ) DCNL DCSP assert _ equal ( sl.scoring , None ) DCNL DCSP for ( err , scoring ) in &#91; ( ValueError , &apos; foo &apos; ) , ( TypeError , 999 ) &#93; : DCNL DCSP DCSP sl = _ SearchLight ( LogisticRegression ( ) , scoring = scoring ) DCNL DCSP DCSP sl.fit ( X , y ) DCNL DCSP DCSP assert _ raises ( err , sl.score , X , y ) DCNL DCSP sl = _ SearchLight ( LogisticRegression ( ) , scoring = &apos; roc _ auc &apos; ) DCNL DCSP y = ( np.arange ( len ( X ) ) % 3 ) DCNL DCSP sl.fit ( X , y ) DCNL DCSP assert _ raises ( ValueError , sl.score , X , y ) DCNL DCSP y = ( ( np.arange ( len ( X ) ) % 2 ) + 1 ) DCNL DCSP sl.fit ( X , y ) DCNL DCSP score = sl.score ( X , y ) DCNL DCSP assert _ array _ equal ( score , &#91; roc _ auc _ score ( ( y - 1 ) , ( _ y _ pred - 1 ) ) for _ y _ pred in sl.decision _ function ( X ) .T &#93; ) DCNL DCSP y = ( np.arange ( len ( X ) ) % 2 ) DCNL DCSP for ( method , scoring ) in &#91; ( &apos; predict _ proba &apos; , &apos; roc _ auc &apos; ) , ( &apos; predict &apos; , roc _ auc _ score ) &#93; : DCNL DCSP DCSP sl1 = _ SearchLight ( LogisticRegression ( ) , scoring = scoring ) DCNL DCSP DCSP sl1.fit ( X , y ) DCNL DCSP DCSP np.random.seed ( 0 ) DCNL DCSP DCSP X = np.random.randn ( * X.shape ) DCNL DCSP DCSP score _ sl = sl1.score ( X , y ) DCNL DCSP DCSP assert _ array _ equal ( score _ sl.shape , &#91; n _ time &#93; ) DCNL DCSP DCSP assert _ true ( ( score _ sl.dtype = = float ) ) DCNL DCSP DCSP if isinstance ( scoring , str ) : DCNL DCSP DCSP DCSP scoring = get _ scorer ( scoring ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP scoring = make _ scorer ( scoring ) DCNL DCSP DCSP score _ manual = &#91; scoring ( est , x , y ) for ( est , x ) in zip ( sl1.estimators _ , X.transpose ( 2 , 0 , 1 ) ) &#93; DCNL DCSP DCSP assert _ array _ equal ( score _ manual , score _ sl ) DCNL DCSP sl = _ SearchLight ( LogisticRegression ( ) , n _ jobs = 2 ) DCNL DCSP sl.fit ( X , y ) DCNL DCSP sl.predict ( X ) DCNL DCSP sl.score ( X , y ) DCNL DCSP sl.fit ( X &#91; ... , &#91; 0 &#93; &#93; , y ) DCNL DCSP sl.predict ( X &#91; ... , &#91; 0 &#93; &#93; ) DCNL DCSP class _ LogRegTransformer ( LogisticRegression , ) : DCNL DCSP DCSP def transform ( self , X ) : DCNL DCSP DCSP DCSP return super ( _ LogRegTransformer , self ) .predict _ proba ( X ) &#91; ... , 1 &#93; DCNL DCSP pipe = make _ pipeline ( _ SearchLight ( _ LogRegTransformer ( ) ) , LogisticRegression ( ) ) DCNL DCSP pipe.fit ( X , y ) DCNL DCSP pipe.predict ( X ) DCNL DCSP X = np.random.rand ( 10 , 3 , 4 , 2 ) DCNL DCSP y = ( np.arange ( 10 ) % 2 ) DCNL DCSP y _ preds = list ( ) DCNL DCSP for n _ jobs in &#91; 1 , 2 &#93; : DCNL DCSP DCSP pipe = _ SearchLight ( make _ pipeline ( Vectorizer ( ) , LogisticRegression ( ) ) , n _ jobs = n _ jobs ) DCNL DCSP DCSP y _ preds.append ( pipe.fit ( X , y ) .predict ( X ) ) DCNL DCSP DCSP features _ shape = pipe.estimators _ &#91; 0 &#93; .steps &#91; 0 &#93; &#91; 1 &#93; .features _ shape _ DCNL DCSP DCSP assert _ array _ equal ( features _ shape , &#91; 3 , 4 &#93; ) DCNL DCSP assert _ array _ equal ( y _ preds &#91; 0 &#93; , y _ preds &#91; 1 &#93; )
DCSP ret = { } DCNL DCSP index = 0 DCNL DCSP if ( not ( output and template ) ) : DCNL DCSP DCSP return ret DCNL DCSP if ( &apos; translate &apos; in template ) : DCNL DCSP DCSP ret = _ translate _ output ( output ) DCNL DCSP else : DCNL DCSP DCSP output _ list = output.strip ( ) .replace ( &apos; \ n &apos; , &apos; &apos; ) .split ( &apos; DCSP &apos; ) DCNL DCSP DCSP if ( sum ( template.values ( ) ) ! = len ( output _ list ) ) : DCNL DCSP DCSP DCSP raise ipmiexcept.IPMIException ( _ ( &apos; ipmitool DCSP output DCSP length DCSP mismatch &apos; ) ) DCNL DCSP DCSP for item in template.items ( ) : DCNL DCSP DCSP DCSP index _ end = ( index + item &#91; 1 &#93; ) DCNL DCSP DCSP DCSP update _ value = output _ list &#91; index : index _ end &#93; DCNL DCSP DCSP DCSP ret &#91; item &#91; 0 &#93; &#93; = update _ value DCNL DCSP DCSP DCSP index = index _ end DCNL DCSP return ret
DCSP if ( x.tzinfo is None ) : DCNL DCSP DCSP x = x.replace ( tzinfo = utc ) DCNL DCSP if hasattr ( x , &apos; timestamp &apos; ) : DCNL DCSP DCSP return x.timestamp ( ) DCNL DCSP else : DCNL DCSP DCSP return ( x - datetime ( 1970 , 1 , 1 , tzinfo = utc ) ) .total _ seconds ( )
DCSP sa _ session = app.model.context.current DCNL DCSP repository = sa _ session.query ( app.model.Repository ) .get ( decoded _ repository _ id ) DCNL DCSP repo = hg _ util.get _ repo _ for _ repository ( app , repository = repository , repo _ path = None , create = False ) DCNL DCSP if downloadable : DCNL DCSP DCSP changeset _ revision = get _ latest _ downloadable _ changeset _ revision ( app , repository , repo ) DCNL DCSP else : DCNL DCSP DCSP changeset _ revision = get _ latest _ changeset _ revision ( app , repository , repo ) DCNL DCSP return get _ repository _ metadata _ by _ changeset _ revision ( app , app.security.encode _ id ( repository.id ) , changeset _ revision )
DCSP schema = vol.Schema ( cv.string ) DCNL DCSP with pytest.raises ( vol.MultipleInvalid ) : DCNL DCSP DCSP schema ( None ) DCNL DCSP for value in ( True , 1 , &apos; hello &apos; ) : DCNL DCSP DCSP schema ( value )
DCSP results = ( yield gen.Task ( ListAllKeys , store , prefix = PrefixFromPattern ( pattern ) ) ) DCNL DCSP callback ( results )
DCSP if ( markers &#91; 1 &#93; = = &apos; &apos; ) : DCNL DCSP DCSP return _ extract _ doc _ comment _ simple ( content , line , column , markers ) DCNL DCSP elif ( markers &#91; 1 &#93; = = markers &#91; 2 &#93; ) : DCNL DCSP DCSP return _ extract _ doc _ comment _ continuous ( content , line , column , markers ) DCNL DCSP else : DCNL DCSP DCSP return _ extract _ doc _ comment _ standard ( content , line , column , markers )
DCSP if isinstance ( date _ time , ( int , float ) ) : DCNL DCSP DCSP tt = time.localtime ( date _ time ) DCNL DCSP elif isinstance ( date _ time , ( tuple , time.struct _ time ) ) : DCNL DCSP DCSP tt = date _ time DCNL DCSP elif ( isinstance ( date _ time , str ) and ( ( date _ time &#91; 0 &#93; , date _ time &#91; ( -1 ) &#93; ) = = ( &apos; &quot; &apos; , &apos; &quot; &apos; ) ) ) : DCNL DCSP DCSP return date _ time DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; date _ time DCSP not DCSP of DCSP a DCSP known DCSP type &apos; ) DCNL DCSP dt = time.strftime ( &apos; % d- % b- % Y DCSP % H : % M : % S &apos; , tt ) DCNL DCSP if ( dt &#91; 0 &#93; = = &apos; 0&apos; ) : DCNL DCSP DCSP dt = ( &apos; DCSP &apos; + dt &#91; 1 : &#93; ) DCNL DCSP if ( time.daylight and tt &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP zone = ( - time.altzone ) DCNL DCSP else : DCNL DCSP DCSP zone = ( - time.timezone ) DCNL DCSP return ( ( ( &apos; &quot; &apos; + dt ) + ( &apos; DCSP % + 03d % 02d &apos; % divmod ( ( zone / / 60 ) , 60 ) ) ) + &apos; &quot; &apos; )
DCSP assert isinstance ( s , basestring ) DCNL DCSP sdr = &#91; int ( c ) for c in s if ( c in ( &apos; 0&apos; , &apos; 1&apos; ) ) &#93; DCNL DCSP if ( len ( sdr ) ! = len ( s ) ) : DCNL DCSP DCSP raise ValueError ( &quot; The DCSP provided DCSP string DCSP % s DCSP is DCSP malformed . DCSP The DCSP string DCSP should DCSP have DCSP only DCSP 0 &apos;s DCSP and DCSP 1 &apos;s . &quot; ) DCNL DCSP return sdr
DCSP if ( not path ) : DCNL DCSP DCSP raise ValueError ( &apos; no DCSP path DCSP specified &apos; ) DCNL DCSP startList = os.path.abspath ( start ) .split ( os.path.sep ) DCNL DCSP pathList = os.path.abspath ( path ) .split ( os.path.sep ) DCNL DCSP i = len ( os.path.commonprefix ( &#91; startList , pathList &#93; ) ) DCNL DCSP relList = ( ( &#91; &apos; .. &apos; &#93; * ( len ( startList ) - i ) ) + pathList &#91; i : &#93; ) DCNL DCSP if ( not relList ) : DCNL DCSP DCSP return path DCNL DCSP return os.path.join ( * relList )
DCSP pkg _ list = &#91; pkg for pkg in pkg _ list if ( not is _ installed ( pkg ) ) &#93; DCNL DCSP if pkg _ list : DCNL DCSP DCSP install ( pkg _ list , update )
DCSP return ( &apos; mirror _ &apos; + six.text _ type ( volume.id ) )
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP floating _ ip _ create DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function &apos; ) DCNL DCSP if ( &apos; pool &apos; not in kwargs ) : DCNL DCSP DCSP log.error ( &apos; pool DCSP is DCSP required &apos; ) DCNL DCSP DCSP return False DCNL DCSP conn = get _ conn ( ) DCNL DCSP return conn.floating _ ip _ create ( kwargs &#91; &apos; pool &apos; &#93; )
DCSP query = RevisionMetricsMappingType.search ( ) .facet ( &apos; creator _ id &apos; , filtered = True , size = BIG _ NUMBER ) DCNL DCSP if ( locale is None ) : DCNL DCSP DCSP query = query.filter ( ( ~ F ( locale = settings.WIKI _ DEFAULT _ LANGUAGE ) ) ) DCNL DCSP query = _ apply _ filters ( query , start , end , locale , product ) DCNL DCSP return _ get _ creator _ counts ( query , count , page )
DCSP numpy.testing.assert _ array _ max _ ulp ( cupy.asnumpy ( a ) , cupy.asnumpy ( b ) , maxulp = maxulp , dtype = dtype )
DCSP course _ key = CourseKey.from _ string ( course _ key _ string ) DCNL DCSP if ( not has _ course _ author _ access ( request.user , course _ key ) ) : DCNL DCSP DCSP raise PermissionDenied ( ) DCNL DCSP response _ format = ( request.GET.get ( &apos; format &apos; ) or request.POST.get ( &apos; format &apos; ) or &apos; html &apos; ) DCNL DCSP if ( ( response _ format = = &apos; json &apos; ) or ( &apos; application / json &apos; in request.META.get ( &apos; HTTP _ ACCEPT &apos; , &apos; application / json &apos; ) ) ) : DCNL DCSP DCSP if ( request.method = = &apos; GET &apos; ) : DCNL DCSP DCSP DCSP return _ assets _ json ( request , course _ key ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP asset _ key = ( AssetKey.from _ string ( asset _ key _ string ) if asset _ key _ string else None ) DCNL DCSP DCSP DCSP return _ update _ asset ( request , course _ key , asset _ key ) DCNL DCSP elif ( request.method = = &apos; GET &apos; ) : DCNL DCSP DCSP return _ asset _ index ( request , course _ key ) DCNL DCSP else : DCNL DCSP DCSP return HttpResponseNotFound ( )
DCSP if ( polyorder &gt; = window _ length ) : DCNL DCSP DCSP raise ValueError ( &apos; polyorder DCSP must DCSP be DCSP less DCSP than DCSP window _ length . &apos; ) DCNL DCSP ( halflen , rem ) = divmod ( window _ length , 2 ) DCNL DCSP if ( rem = = 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; window _ length DCSP must DCSP be DCSP odd . &apos; ) DCNL DCSP if ( pos is None ) : DCNL DCSP DCSP pos = halflen DCNL DCSP if ( not ( 0 &lt; = pos &lt; window _ length ) ) : DCNL DCSP DCSP raise ValueError ( &apos; pos DCSP must DCSP be DCSP nonnegative DCSP and DCSP less DCSP than DCSP window _ length . &apos; ) DCNL DCSP if ( use not in &#91; &apos; conv &apos; , &apos; dot &apos; &#93; ) : DCNL DCSP DCSP raise ValueError ( &quot; `use` DCSP must DCSP be DCSP &apos; conv &apos; DCSP or DCSP &apos; dot &apos; &quot; ) DCNL DCSP x = np.arange ( ( - pos ) , ( window _ length - pos ) , dtype = float ) DCNL DCSP if ( use = = &apos; conv &apos; ) : DCNL DCSP DCSP x = x &#91; : : ( -1 ) &#93; DCNL DCSP order = np.arange ( ( polyorder + 1 ) ) .reshape ( ( -1 ) , 1 ) DCNL DCSP A = ( x * * order ) DCNL DCSP y = np.zeros ( ( polyorder + 1 ) ) DCNL DCSP y &#91; deriv &#93; = ( factorial ( deriv ) / ( delta * * deriv ) ) DCNL DCSP ( coeffs , _ , _ , _ ) = lstsq ( A , y ) DCNL DCSP return coeffs
DCSP clamav = XML.SubElement ( xml _ parent , &apos; org.jenkinsci.plugins.clamav.ClamAvRecorder &apos; ) DCNL DCSP clamav.set ( &apos; plugin &apos; , &apos; clamav &apos; ) DCNL DCSP mappings = &#91; ( &apos; includes &apos; , &apos; includes &apos; , &apos; &apos; ) , ( &apos; excludes &apos; , &apos; excludes &apos; , &apos; &apos; ) &#93; DCNL DCSP helpers.convert _ mapping _ to _ xml ( clamav , data , mappings , fail _ required = True )
DCSP if salt.utils.which ( &apos; nft &apos; ) : DCNL DCSP DCSP return &apos; nftables &apos; DCNL DCSP return ( False , &apos; The DCSP nftables DCSP execution DCSP module DCSP failed DCSP to DCSP load : DCSP nftables DCSP is DCSP not DCSP installed . &apos; )
DCSP master _ tipnames = set ( master.getTipNames ( ) ) DCNL DCSP subsampled _ tree _ trimmed = copy.deepcopy ( subsampled _ tree ) DCNL DCSP def delete _ test ( node ) : DCNL DCSP DCSP if ( not node.isTip ( ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( node.Name not in master _ tipnames ) DCNL DCSP subsampled _ tree _ trimmed.removeDeleted ( delete _ test ) DCNL DCSP subsampled _ tree _ trimmed.prune ( ) DCNL DCSP subsampled _ tree _ nodes _ names = &#91; &#93; DCNL DCSP for node in subsampled _ tree _ trimmed.iterNontips ( include _ self = True ) : DCNL DCSP DCSP subsampled _ tree _ nodes _ names.append ( node.getTipNames ( ) ) DCNL DCSP subsampled _ tree _ nodes _ names = map ( set , subsampled _ tree _ nodes _ names ) DCNL DCSP for master _ node in master.iterNontips ( include _ self = True ) : DCNL DCSP DCSP if ( set ( master _ node.getTipNames ( ) ) in subsampled _ tree _ nodes _ names ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP master _ node.bootstrap _ support + = 1 DCNL DCSP DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP DCSP master _ node.bootstrap _ support = 1
DCSP conf = global _ conf.copy ( ) DCNL DCSP conf.update ( local _ conf ) DCNL DCSP register _ swift _ info ( &apos; formpost &apos; ) DCNL DCSP return ( lambda app : FormPost ( app , conf ) )
DCSP if throttle : DCNL DCSP DCSP Waiter ( ) DCNL DCSP if params : DCNL DCSP DCSP url = ( &apos; % s / % s ? % s &apos; % ( DLCS _ API , path , urllib.urlencode ( dict0 ( params ) ) ) ) DCNL DCSP else : DCNL DCSP DCSP url = ( &apos; % s / % s &apos; % ( DLCS _ API , path ) ) DCNL DCSP if DEBUG : DCNL DCSP DCSP print &gt; &gt; sys.stderr , ( &apos; dlcs _ api _ request : DCSP % s &apos; % url ) DCNL DCSP try : DCNL DCSP DCSP return http _ auth _ request ( url , DLCS _ API _ HOST , user , passwd , USER _ AGENT ) DCNL DCSP except DefaultErrorHandler as e : DCNL DCSP DCSP print &gt; &gt; sys.stderr , ( &apos; % s &apos; % e )
DCSP import functools DCNL DCSP import mpmath DCNL DCSP def func _ wrapper ( * args , * * kwargs ) : DCNL DCSP DCSP dps = mpmath.mp.dps DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return func ( * args , * * kwargs ) DCNL DCSP DCSP finally : DCNL DCSP DCSP DCSP mpmath.mp.dps = dps DCNL DCSP func _ wrapper = functools.update _ wrapper ( func _ wrapper , func ) DCNL DCSP return func _ wrapper
DCSP for repo in repos : DCNL DCSP DCSP if fnmatch ( path , repo ) : DCNL DCSP DCSP DCSP return True DCNL DCSP return False
DCSP x0 = np.asarray ( x0 ) DCNL DCSP if ( x0.dtype.kind in np.typecodes &#91; &apos; AllInteger &apos; &#93; ) : DCNL DCSP DCSP x0 = np.asarray ( x0 , dtype = float ) DCNL DCSP if ( not isinstance ( args , tuple ) ) : DCNL DCSP DCSP args = ( args , ) DCNL DCSP if ( method is None ) : DCNL DCSP DCSP if constraints : DCNL DCSP DCSP DCSP method = &apos; SLSQP &apos; DCNL DCSP DCSP elif ( bounds is not None ) : DCNL DCSP DCSP DCSP method = &apos; L-BFGS-B &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP method = &apos; BFGS &apos; DCNL DCSP if callable ( method ) : DCNL DCSP DCSP meth = &apos; _ custom &apos; DCNL DCSP else : DCNL DCSP DCSP meth = method.lower ( ) DCNL DCSP if ( options is None ) : DCNL DCSP DCSP options = { } DCNL DCSP if ( ( meth in &#91; &apos; nelder-mead &apos; , &apos; powell &apos; , &apos; cobyla &apos; &#93; ) and bool ( jac ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP does DCSP not DCSP use DCSP gradient DCSP information DCSP ( jac ) . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth not in ( &apos; newton-cg &apos; , &apos; dogleg &apos; , &apos; trust-ncg &apos; , &apos; _ custom &apos; ) ) and ( hess is not None ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP does DCSP not DCSP use DCSP Hessian DCSP information DCSP ( hess ) . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth not in ( &apos; newton-cg &apos; , &apos; dogleg &apos; , &apos; trust-ncg &apos; , &apos; _ custom &apos; ) ) and ( hessp is not None ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP does DCSP not DCSP use DCSP Hessian-vector DCSP product DCSP information DCSP ( hessp ) . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth in &#91; &apos; nelder-mead &apos; , &apos; powell &apos; , &apos; cg &apos; , &apos; bfgs &apos; , &apos; newton-cg &apos; , &apos; dogleg &apos; , &apos; trust-ncg &apos; &#93; ) and ( ( bounds is not None ) or np.any ( constraints ) ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP cannot DCSP handle DCSP constraints DCSP nor DCSP bounds . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth in &#91; &apos; l-bfgs-b &apos; , &apos; tnc &apos; &#93; ) and np.any ( constraints ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP cannot DCSP handle DCSP constraints . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth = = &apos; cobyla &apos; ) and ( bounds is not None ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP cannot DCSP handle DCSP bounds . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth in &#91; &apos; cobyla &apos; &#93; ) and ( callback is not None ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP does DCSP not DCSP support DCSP callback . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( ( meth in &#91; &apos; l-bfgs-b &apos; , &apos; tnc &apos; , &apos; cobyla &apos; , &apos; slsqp &apos; &#93; ) and options.get ( &apos; return _ all &apos; , False ) ) : DCNL DCSP DCSP warn ( ( &apos; Method DCSP % s DCSP does DCSP not DCSP support DCSP the DCSP return _ all DCSP option . &apos; % method ) , RuntimeWarning ) DCNL DCSP if ( not callable ( jac ) ) : DCNL DCSP DCSP if bool ( jac ) : DCNL DCSP DCSP DCSP fun = MemoizeJac ( fun ) DCNL DCSP DCSP DCSP jac = fun.derivative DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP jac = None DCNL DCSP if ( tol is not None ) : DCNL DCSP DCSP options = dict ( options ) DCNL DCSP DCSP if ( meth = = &apos; nelder-mead &apos; ) : DCNL DCSP DCSP DCSP options.setdefault ( &apos; xatol &apos; , tol ) DCNL DCSP DCSP DCSP options.setdefault ( &apos; fatol &apos; , tol ) DCNL DCSP DCSP if ( meth in &#91; &apos; newton-cg &apos; , &apos; powell &apos; , &apos; tnc &apos; &#93; ) : DCNL DCSP DCSP DCSP options.setdefault ( &apos; xtol &apos; , tol ) DCNL DCSP DCSP if ( meth in &#91; &apos; powell &apos; , &apos; l-bfgs-b &apos; , &apos; tnc &apos; , &apos; slsqp &apos; &#93; ) : DCNL DCSP DCSP DCSP options.setdefault ( &apos; ftol &apos; , tol ) DCNL DCSP DCSP if ( meth in &#91; &apos; bfgs &apos; , &apos; cg &apos; , &apos; l-bfgs-b &apos; , &apos; tnc &apos; , &apos; dogleg &apos; , &apos; trust-ncg &apos; &#93; ) : DCNL DCSP DCSP DCSP options.setdefault ( &apos; gtol &apos; , tol ) DCNL DCSP DCSP if ( meth in &#91; &apos; cobyla &apos; , &apos; _ custom &apos; &#93; ) : DCNL DCSP DCSP DCSP options.setdefault ( &apos; tol &apos; , tol ) DCNL DCSP if ( meth = = &apos; _ custom &apos; ) : DCNL DCSP DCSP return method ( fun , x0 , args = args , jac = jac , hess = hess , hessp = hessp , bounds = bounds , constraints = constraints , callback = callback , * * options ) DCNL DCSP elif ( meth = = &apos; nelder-mead &apos; ) : DCNL DCSP DCSP return _ minimize _ neldermead ( fun , x0 , args , callback , * * options ) DCNL DCSP elif ( meth = = &apos; powell &apos; ) : DCNL DCSP DCSP return _ minimize _ powell ( fun , x0 , args , callback , * * options ) DCNL DCSP elif ( meth = = &apos; cg &apos; ) : DCNL DCSP DCSP return _ minimize _ cg ( fun , x0 , args , jac , callback , * * options ) DCNL DCSP elif ( meth = = &apos; bfgs &apos; ) : DCNL DCSP DCSP return _ minimize _ bfgs ( fun , x0 , args , jac , callback , * * options ) DCNL DCSP elif ( meth = = &apos; newton-cg &apos; ) : DCNL DCSP DCSP return _ minimize _ newtoncg ( fun , x0 , args , jac , hess , hessp , callback , * * options ) DCNL DCSP elif ( meth = = &apos; l-bfgs-b &apos; ) : DCNL DCSP DCSP return _ minimize _ lbfgsb ( fun , x0 , args , jac , bounds , callback = callback , * * options ) DCNL DCSP elif ( meth = = &apos; tnc &apos; ) : DCNL DCSP DCSP return _ minimize _ tnc ( fun , x0 , args , jac , bounds , callback = callback , * * options ) DCNL DCSP elif ( meth = = &apos; cobyla &apos; ) : DCNL DCSP DCSP return _ minimize _ cobyla ( fun , x0 , args , constraints , * * options ) DCNL DCSP elif ( meth = = &apos; slsqp &apos; ) : DCNL DCSP DCSP return _ minimize _ slsqp ( fun , x0 , args , jac , bounds , constraints , callback = callback , * * options ) DCNL DCSP elif ( meth = = &apos; dogleg &apos; ) : DCNL DCSP DCSP return _ minimize _ dogleg ( fun , x0 , args , jac , hess , callback = callback , * * options ) DCNL DCSP elif ( meth = = &apos; trust-ncg &apos; ) : DCNL DCSP DCSP return _ minimize _ trust _ ncg ( fun , x0 , args , jac , hess , hessp , callback = callback , * * options ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP solver DCSP % s &apos; % method ) )
DCSP x = hp.uniform ( &apos; x &apos; , ( -15 ) , 15 ) DCNL DCSP f1 = old _ div ( 1.0 , ( 1.0 + scope.exp ( ( - x ) ) ) ) DCNL DCSP f2 = ( 2 * scope.exp ( ( - ( ( x + 10 ) * * 2 ) ) ) ) DCNL DCSP return { &apos; loss &apos; : ( ( - f1 ) - f2 ) , &apos; status &apos; : base.STATUS _ OK }
DCSP current = node DCNL DCSP while ( current and ( not isinstance ( current.parent , astroid.ExceptHandler ) ) ) : DCNL DCSP DCSP current = current.parent DCNL DCSP return ( current and ( current is current.parent.name ) )
DCSP if ( ( not skipkeys ) and ensure _ ascii and check _ circular and allow _ nan and ( cls is None ) and ( indent is None ) and ( separators is None ) and ( encoding = = &apos; utf-8 &apos; ) and ( default is None ) and ( not kw ) ) : DCNL DCSP DCSP iterable = _ default _ encoder.iterencode ( obj ) DCNL DCSP else : DCNL DCSP DCSP if ( cls is None ) : DCNL DCSP DCSP DCSP cls = JSONEncoder DCNL DCSP DCSP iterable = cls ( skipkeys = skipkeys , ensure _ ascii = ensure _ ascii , check _ circular = check _ circular , allow _ nan = allow _ nan , indent = indent , separators = separators , encoding = encoding , default = default , use _ decimal = use _ decimal , * * kw ) .iterencode ( obj ) DCNL DCSP for chunk in iterable : DCNL DCSP DCSP fp.write ( chunk )
DCSP seen _ names = set ( ) DCNL DCSP if prefix : DCNL DCSP DCSP prefix + = &apos; .&apos; DCNL DCSP for d in ( _ hy _ macros , _ hy _ reader ) : DCNL DCSP DCSP for ( name , macro ) in d &#91; source _ module &#93; .items ( ) : DCNL DCSP DCSP DCSP seen _ names.add ( name ) DCNL DCSP DCSP DCSP if all _ macros : DCNL DCSP DCSP DCSP DCSP d &#91; target _ module &#93; &#91; ( prefix + name ) &#93; = macro DCNL DCSP DCSP DCSP elif ( name in assignments ) : DCNL DCSP DCSP DCSP DCSP d &#91; target _ module &#93; &#91; ( prefix + assignments &#91; name &#93; ) &#93; = macro DCNL DCSP if ( not all _ macros ) : DCNL DCSP DCSP unseen = frozenset ( assignments.keys ( ) ) .difference ( seen _ names ) DCNL DCSP DCSP if unseen : DCNL DCSP DCSP DCSP raise ImportError ( ( &apos; cannot DCSP require DCSP names : DCSP &apos; + repr ( list ( unseen ) ) ) )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ media _ list _ player _ get _ state &apos; , None ) or _ Cfunction ( &apos; libvlc _ media _ list _ player _ get _ state &apos; , ( ( 1 , ) , ) , None , State , MediaListPlayer ) ) DCNL DCSP return f ( p _ mlp )
DCSP pre = ( &apos; \ n DCSP DCSP DCSP DCSP py _ % ( name ) s DCSP = DCSP Py _ None ; \ n DCSP DCSP DCSP DCSP { Py _ XINCREF ( py _ % ( name ) s ) ; } \ n DCSP DCSP DCSP DCSP &apos; % locals ( ) ) DCNL DCSP return ( pre + r.type.c _ init ( name , sub ) )
DCSP np = import _ module ( &apos; numpy &apos; ) DCNL DCSP if isinstance ( x , ( int , float ) ) : DCNL DCSP DCSP return interval ( np.exp ( x ) , np.exp ( x ) ) DCNL DCSP elif isinstance ( x , interval ) : DCNL DCSP DCSP return interval ( np.exp ( x.start ) , np.exp ( x.end ) , is _ valid = x.is _ valid ) DCNL DCSP else : DCNL DCSP DCSP raise NotImplementedError
DCSP infos = { } DCNL DCSP fullinfos = { } DCNL DCSP data = spec.get ( &apos; fullvalue &apos; , spec &#91; &apos; value &apos; &#93; ) .split ( None , 1 ) DCNL DCSP if data &#91; 1 : &#93; : DCNL DCSP DCSP if ( data &#91; 0 &#93; .lower ( ) = = &apos; basic &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP ( infos &#91; &apos; username &apos; &#93; , infos &#91; &apos; password &apos; &#93; ) = &apos; &apos;.join ( data &#91; 1 &#93; .strip ( ) ) .decode ( &apos; base64 &apos; ) .decode ( &apos; latin-1 &apos; ) .split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP DCSP DCSP for field in &#91; &apos; username &apos; , &apos; password &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( len ( infos &#91; field &#93; ) &gt; utils.MAXVALLEN ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP fullinfos &#91; field &#93; = infos &#91; field &#93; DCNL DCSP DCSP DCSP DCSP DCSP DCSP infos &#91; field &#93; = infos &#91; field &#93; &#91; : utils.MAXVALLEN &#93; DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP elif ( data &#91; 0 &#93; .lower ( ) = = &apos; digest &apos; ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP infos = dict ( ( ( value.split ( &apos; = &apos; , 1 ) if ( &apos; = &apos; in value ) else &#91; value , None &#93; ) for value in _ split _ digest _ auth ( data &#91; 1 &#93; .strip ( ) ) ) ) DCNL DCSP DCSP DCSP DCSP for ( key , value ) in infos.items ( ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( value.startswith ( &apos; &quot; &apos; ) and value.endswith ( &apos; &quot; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP infos &#91; key &#93; = value &#91; 1 : ( -1 ) &#93; DCNL DCSP DCSP DCSP except Exception : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP res = { } DCNL DCSP if infos : DCNL DCSP DCSP res &#91; &apos; infos &apos; &#93; = infos DCNL DCSP if fullinfos : DCNL DCSP DCSP res &#91; &apos; fullinfos &apos; &#93; = fullinfos DCNL DCSP return res
DCSP if ( root _ module _ name in sys.modules ) : DCNL DCSP DCSP return DCNL DCSP _ create _ module _ and _ parents ( root _ module _ name ) DCNL DCSP imp.load _ package ( root _ module _ name , base _ path ) DCNL DCSP sys.path.insert ( 0 , os.path.join ( base _ path , &apos; site-packages &apos; ) )
DCSP return getattr ( request , &apos; _ messages &apos; , &#91; &#93; )
DCSP l = logging.getLogger ( &apos; paramiko &apos; ) DCNL DCSP l.setLevel ( logging.DEBUG ) DCNL DCSP static.create _ sc _ config _ dirs ( ) DCNL DCSP lh = logging.handlers.RotatingFileHandler ( static.SSH _ DEBUG _ FILE , maxBytes = 1048576 , backupCount = 2 ) DCNL DCSP lh.setLevel ( logging.DEBUG ) DCNL DCSP format = ( ( &apos; PID : DCSP % s DCSP &apos; % str ( static.PID ) ) + &apos; % ( levelname ) -.3s DCSP &#91; % ( asctime ) s . % ( msecs ) 03d &#93; DCSP thr = % ( _ threadid ) -3d DCSP % ( name ) s : DCSP % ( message ) s &apos; ) DCNL DCSP date _ format = &apos; % Y % m % d- % H : % M : % S &apos; DCNL DCSP lh.setFormatter ( logging.Formatter ( format , date _ format ) ) DCNL DCSP l.addHandler ( lh )
DCSP return IMPL.fixed _ ip _ get _ by _ host ( context , host )
DCSP X = ( X.data if sp.issparse ( X ) else X ) DCNL DCSP if ( X &lt; 0 ) .any ( ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Negative DCSP values DCSP in DCSP data DCSP passed DCSP to DCSP % s &apos; % whom ) )
DCSP initLogging ( verbose = True ) DCNL DCSP initExperimentPrng ( ) DCNL DCSP @ staticmethod DCNL DCSP def _ mockCreate ( * args , * * kwargs ) : DCNL DCSP DCSP kwargs.pop ( &apos; implementation &apos; , None ) DCNL DCSP DCSP return CLAClassifierDiff ( * args , * * kwargs ) DCNL DCSP CLAClassifierFactory.create = _ mockCreate DCNL DCSP runExperiment ( sys.argv &#91; 1 : &#93; )
DCSP call _ command ( &apos; refresh _ scores &apos; , &apos; --reset &apos; , &apos; --user = system &apos; ) DCNL DCSP ( out , err ) = capfd.readouterr ( ) DCNL DCSP assert ( &apos; Scores DCSP for DCSP specified DCSP users DCSP were DCSP reset DCSP to DCSP 0 . &apos; in out )
DCSP rq = Queue ( ) DCNL DCSP abort = Event ( ) DCNL DCSP run _ download ( log , rq , abort , title = title , authors = authors , identifiers = identifiers , timeout = timeout , get _ best _ cover = True ) DCNL DCSP results = &#91; &#93; DCNL DCSP while True : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP results.append ( rq.get _ nowait ( ) ) DCNL DCSP DCSP except Empty : DCNL DCSP DCSP DCSP break DCNL DCSP cp = msprefs &#91; u &apos;cover _ priorities &apos; &#93; DCNL DCSP def keygen ( result ) : DCNL DCSP DCSP ( plugin , width , height , fmt , data ) = result DCNL DCSP DCSP return ( cp.get ( plugin.name , 1 ) , ( 1 / ( width * height ) ) ) DCNL DCSP results.sort ( key = keygen ) DCNL DCSP return ( results &#91; 0 &#93; if results else None )
DCSP list _ map = game _ map.split ( &apos; \ n &apos; ) DCNL DCSP return &#91; ( character.decode ( &apos; UTF-8 &apos; ) if isinstance ( character , basestring ) else character ) for character in list _ map &#93;
DCSP i = ( &apos; \ n &apos; + ( level * &apos; DCSP DCSP &apos; ) ) DCNL DCSP if len ( elem ) : DCNL DCSP DCSP if ( ( not elem.text ) or ( not elem.text.strip ( ) ) ) : DCNL DCSP DCSP DCSP elem.text = ( i + &apos; DCSP DCSP &apos; ) DCNL DCSP DCSP for e in elem : DCNL DCSP DCSP DCSP _ indent ( e , ( level + 1 ) ) DCNL DCSP DCSP DCSP if ( ( not e.tail ) or ( not e.tail.strip ( ) ) ) : DCNL DCSP DCSP DCSP DCSP e.tail = ( i + &apos; DCSP DCSP &apos; ) DCNL DCSP DCSP if ( ( not e.tail ) or ( not e.tail.strip ( ) ) ) : DCNL DCSP DCSP DCSP e.tail = i DCNL DCSP elif ( level and ( ( not elem.tail ) or ( not elem.tail.strip ( ) ) ) ) : DCNL DCSP DCSP elem.tail = i
DCSP query = ( &apos; SET DCSP GLOBAL DCSP % s DCSP = DCSP &apos; % mysql _ quote _ identifier ( mysqlvar , &apos; vars &apos; ) ) DCNL DCSP try : DCNL DCSP DCSP cursor.execute ( ( query + &apos; % s &apos; ) , ( value , ) ) DCNL DCSP DCSP cursor.fetchall ( ) DCNL DCSP DCSP result = True DCNL DCSP except Exception : DCNL DCSP DCSP e = get _ exception ( ) DCNL DCSP DCSP result = str ( e ) DCNL DCSP return result
DCSP s3db.hrm _ configure _ pr _ group _ membership ( ) DCNL DCSP table = db.pr _ group _ membership DCNL DCSP gtable = db.pr _ group DCNL DCSP htable = s3db.hrm _ human _ resource DCNL DCSP s3.filter = ( ( ( ( gtable.system = = False ) &amp; ( gtable.group _ type = = 3 ) ) &amp; ( htable.type = = 1 ) ) &amp; ( htable.person _ id = = table.person _ id ) ) DCNL DCSP def prep ( r ) : DCNL DCSP DCSP if ( r.method in ( &apos; create &apos; , &apos; create.popup &apos; , &apos; update &apos; , &apos; update.popup &apos; ) ) : DCNL DCSP DCSP DCSP person _ id = get _ vars.get ( &apos; ~ .person _ id &apos; , None ) DCNL DCSP DCSP DCSP if person _ id : DCNL DCSP DCSP DCSP DCSP field = table.person _ id DCNL DCSP DCSP DCSP DCSP field.default = person _ id DCNL DCSP DCSP DCSP DCSP field.readable = field.writable = False DCNL DCSP DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3 _ rest _ controller ( &apos; pr &apos; , &apos; group _ membership &apos; , csv _ stylesheet = ( &apos; hrm &apos; , &apos; group _ membership.xsl &apos; ) , csv _ template = &apos; group _ membership &apos; ) DCNL DCSP return output
DCSP intf _ type = get _ interface _ type ( interface ) DCNL DCSP if ( intf _ type = = &apos; ethernet &apos; ) : DCNL DCSP DCSP command = ( &apos; show DCSP interface DCSP &apos; + interface ) DCNL DCSP DCSP body = execute _ show _ command ( command , module ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP interface _ table = body &#91; 0 &#93; &#91; &apos; TABLE _ interface &apos; &#93; &#91; &apos; ROW _ interface &apos; &#93; DCNL DCSP DCSP except ( KeyError , AttributeError , IndexError ) : DCNL DCSP DCSP DCSP interface _ table = None DCNL DCSP DCSP if interface _ table : DCNL DCSP DCSP DCSP state = interface _ table.get ( &apos; eth _ bundle &apos; ) DCNL DCSP DCSP DCSP if state : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return False DCNL DCSP return False
DCSP ( yield ( word , sum ( counts ) ) )
DCSP def wrapper ( obj , journal , * args , * * kwargs ) : DCNL DCSP DCSP return journal.executeCommand ( cmdClass ( methodName , args , kwargs ) ) DCNL DCSP return wrapper
DCSP distribution _ name = CURRENT _ DISTRIBUTION.name.lower ( ) DCNL DCSP for ( package _ type , distribution _ names ) in PACKAGE _ TYPE _ MAP.items ( ) : DCNL DCSP DCSP if ( distribution _ name.lower ( ) in distribution _ names ) : DCNL DCSP DCSP DCSP return package _ type DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Unknown DCSP distribution . &apos; , distribution _ name )
DCSP if callable ( lookup _ view ) : DCNL DCSP DCSP return lookup _ view DCNL DCSP if ( not isinstance ( lookup _ view , str ) ) : DCNL DCSP DCSP raise ViewDoesNotExist ( ( &quot; &apos; % s &apos; DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP a DCSP dot-notation DCSP path &quot; % lookup _ view ) ) DCNL DCSP ( mod _ name , func _ name ) = get _ mod _ func ( lookup _ view ) DCNL DCSP if ( not func _ name ) : DCNL DCSP DCSP raise ImportError ( ( &quot; Could DCSP not DCSP import DCSP &apos; % s &apos; . DCSP The DCSP path DCSP must DCSP be DCSP fully DCSP qualified . &quot; % lookup _ view ) ) DCNL DCSP try : DCNL DCSP DCSP mod = import _ module ( mod _ name ) DCNL DCSP except ImportError : DCNL DCSP DCSP ( parentmod , submod ) = get _ mod _ func ( mod _ name ) DCNL DCSP DCSP if ( submod and ( not module _ has _ submodule ( import _ module ( parentmod ) , submod ) ) ) : DCNL DCSP DCSP DCSP raise ViewDoesNotExist ( ( &quot; Could DCSP not DCSP import DCSP &apos; % s &apos; . DCSP Parent DCSP module DCSP % s DCSP does DCSP not DCSP exist . &quot; % ( lookup _ view , mod _ name ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP view _ func = getattr ( mod , func _ name ) DCNL DCSP DCSP except AttributeError : DCNL DCSP DCSP DCSP raise ViewDoesNotExist ( ( &quot; Could DCSP not DCSP import DCSP &apos; % s &apos; . DCSP View DCSP does DCSP not DCSP exist DCSP in DCSP module DCSP % s . &quot; % ( lookup _ view , mod _ name ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( not callable ( view _ func ) ) : DCNL DCSP DCSP DCSP DCSP raise ViewDoesNotExist ( ( &quot; Could DCSP not DCSP import DCSP &apos; % s . % s &apos; . DCSP View DCSP is DCSP not DCSP callable . &quot; % ( mod _ name , func _ name ) ) ) DCNL DCSP DCSP DCSP return view _ func
DCSP validation = fix _ addons _ linter _ output ( validation ) DCNL DCSP if is _ compatibility : DCNL DCSP DCSP mangle _ compatibility _ messages ( validation ) DCNL DCSP validation.setdefault ( &apos; ending _ tier &apos; , 0 ) DCNL DCSP if ( ( not validation &#91; &apos; ending _ tier &apos; &#93; ) and validation &#91; &apos; messages &apos; &#93; ) : DCNL DCSP DCSP validation &#91; &apos; ending _ tier &apos; &#93; = max ( ( msg.get ( &apos; tier &apos; , ( -1 ) ) for msg in validation &#91; &apos; messages &apos; &#93; ) ) DCNL DCSP if file _ hash : DCNL DCSP DCSP ValidationComparator ( validation ) .annotate _ results ( file _ hash ) DCNL DCSP limit _ validation _ results ( validation ) DCNL DCSP htmlify _ validation ( validation ) DCNL DCSP return validation
DCSP cart = Order.get _ cart _ for _ user ( request.user ) DCNL DCSP ( is _ any _ course _ expired , expired _ cart _ items , expired _ cart _ item _ names , valid _ cart _ item _ tuples ) = verify _ for _ closed _ enrollment ( request.user , cart ) DCNL DCSP site _ name = configuration _ helpers.get _ value ( &apos; SITE _ NAME &apos; , settings.SITE _ NAME ) DCNL DCSP if is _ any _ course _ expired : DCNL DCSP DCSP for expired _ item in expired _ cart _ items : DCNL DCSP DCSP DCSP Order.remove _ cart _ item _ from _ order ( expired _ item , request.user ) DCNL DCSP DCSP cart.update _ order _ type ( ) DCNL DCSP callback _ url = request.build _ absolute _ uri ( reverse ( &apos; shoppingcart.views.postpay _ callback &apos; ) ) DCNL DCSP form _ html = render _ purchase _ form _ html ( cart , callback _ url = callback _ url ) DCNL DCSP context = { &apos; order &apos; : cart , &apos; shoppingcart _ items &apos; : valid _ cart _ item _ tuples , &apos; amount &apos; : cart.total _ cost , &apos; is _ course _ enrollment _ closed &apos; : is _ any _ course _ expired , &apos; expired _ course _ names &apos; : expired _ cart _ item _ names , &apos; site _ name &apos; : site _ name , &apos; form _ html &apos; : form _ html , &apos; currency _ symbol &apos; : settings.PAID _ COURSE _ REGISTRATION _ CURRENCY &#91; 1 &#93; , &apos; currency &apos; : settings.PAID _ COURSE _ REGISTRATION _ CURRENCY &#91; 0 &#93; , &apos; enable _ bulk _ purchase &apos; : configuration _ helpers.get _ value ( &apos; ENABLE _ SHOPPING _ CART _ BULK _ PURCHASE &apos; , True ) } DCNL DCSP return render _ to _ response ( &apos; shoppingcart / shopping _ cart.html &apos; , context )
DCSP f = ( _ Cfunctions.get ( &apos; libvlc _ video _ set _ deinterlace &apos; , None ) or _ Cfunction ( &apos; libvlc _ video _ set _ deinterlace &apos; , ( ( 1 , ) , ( 1 , ) ) , None , None , MediaPlayer , ctypes.c _ char _ p ) ) DCNL DCSP return f ( p _ mi , psz _ mode )
DCSP echo _ command = ( u &apos;echom &apos; if warning else u &apos;echo &apos; ) DCNL DCSP vim.command ( u &apos;redraw &apos; ) DCNL DCSP if warning : DCNL DCSP DCSP vim.command ( u &apos;echohl DCSP WarningMsg &apos; ) DCNL DCSP message = ToUnicode ( message ) DCNL DCSP if truncate : DCNL DCSP DCSP vim _ width = GetIntValue ( u &apos; &amp; columns &apos; ) DCNL DCSP DCSP message = message.replace ( u &apos; \ n &apos; , u &apos; DCSP &apos; ) DCNL DCSP DCSP if ( len ( message ) &gt; vim _ width ) : DCNL DCSP DCSP DCSP message = ( message &#91; : ( vim _ width - 4 ) &#93; + u &apos; ... &apos; ) DCNL DCSP DCSP old _ ruler = GetIntValue ( u &apos; &amp; ruler &apos; ) DCNL DCSP DCSP old _ showcmd = GetIntValue ( u &apos; &amp; showcmd &apos; ) DCNL DCSP DCSP vim.command ( u &apos;set DCSP noruler DCSP noshowcmd &apos; ) DCNL DCSP DCSP vim.command ( u &quot; { 0 } DCSP &apos; { 1 } &apos; &quot; .format ( echo _ command , EscapeForVim ( message ) ) ) DCNL DCSP DCSP SetVariableValue ( u &apos; &amp; ruler &apos; , old _ ruler ) DCNL DCSP DCSP SetVariableValue ( u &apos; &amp; showcmd &apos; , old _ showcmd ) DCNL DCSP else : DCNL DCSP DCSP for line in message.split ( u &apos; \ n &apos; ) : DCNL DCSP DCSP DCSP vim.command ( u &quot; { 0 } DCSP &apos; { 1 } &apos; &quot; .format ( echo _ command , EscapeForVim ( line ) ) ) DCNL DCSP if warning : DCNL DCSP DCSP vim.command ( u &apos;echohl DCSP None &apos; )
DCSP radius = getFloatByPrefixSide ( ( prefix + &apos; radius &apos; ) , sideLength , xmlElement ) DCNL DCSP radius + = ( 0.5 * getFloatByPrefixSide ( ( prefix + &apos; diameter &apos; ) , sideLength , xmlElement ) ) DCNL DCSP return ( radius + ( 0.5 * getFloatByPrefixSide ( ( prefix + &apos; size &apos; ) , sideLength , xmlElement ) ) )
DCSP repository.displayEntities = &#91; &#93; DCNL DCSP repository.executeTitle = None DCNL DCSP repository.fileNameHelp = fileNameHelp DCNL DCSP repository.fileNameInput = None DCNL DCSP repository.lowerName = fileNameHelp.split ( &apos; .&apos; ) &#91; ( -2 ) &#93; DCNL DCSP repository.baseName = ( repository.lowerName + &apos; .csv &apos; ) DCNL DCSP repository.baseNameSynonym = None DCNL DCSP repository.capitalizedName = getEachWordCapitalized ( repository.lowerName ) DCNL DCSP repository.getProfileDirectory = getProfileDirectory DCNL DCSP repository.openLocalHelpPage = HelpPage ( ) .getOpenFromDocumentationSubName ( repository.fileNameHelp ) DCNL DCSP repository.openWikiManualHelpPage = None DCNL DCSP repository.preferences = &#91; &#93; DCNL DCSP repository.repositoryDialog = None DCNL DCSP repository.saveListenerTable = { } DCNL DCSP repository.title = ( repository.capitalizedName + &apos; DCSP Settings &apos; ) DCNL DCSP repository.menuEntities = &#91; &#93; DCNL DCSP repository.saveCloseTitle = &apos; Save DCSP and DCSP Close &apos; DCNL DCSP repository.windowPosition = WindowPosition ( ) .getFromValue ( repository , &apos; 0 + 0 &apos; ) DCNL DCSP for setting in repository.preferences : DCNL DCSP DCSP setting.repository = repository
DCSP if ( id is None ) : DCNL DCSP DCSP msg = _ ( &apos; id DCSP cannot DCSP be DCSP None &apos; ) DCNL DCSP DCSP raise exception.InvalidGroupType ( reason = msg ) DCNL DCSP elevated = ( context if context.is _ admin else context.elevated ( ) ) DCNL DCSP try : DCNL DCSP DCSP type _ updated = db.group _ type _ update ( elevated , id , dict ( name = name , description = description , is _ public = is _ public ) ) DCNL DCSP except db _ exc.DBError : DCNL DCSP DCSP LOG.exception ( _ LE ( &apos; DB DCSP error : &apos; ) ) DCNL DCSP DCSP raise exception.GroupTypeUpdateFailed ( id = id ) DCNL DCSP return type _ updated
DCSP try : DCNL DCSP DCSP app _ name = get _ commands ( ) &#91; name &#93; DCNL DCSP DCSP if isinstance ( app _ name , BaseCommand ) : DCNL DCSP DCSP DCSP klass = app _ name DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP klass = load _ command _ class ( app _ name , name ) DCNL DCSP except KeyError : DCNL DCSP DCSP raise CommandError ( ( &apos; Unknown DCSP command : DCSP % r &apos; % name ) ) DCNL DCSP defaults = dict ( &#91; ( o.dest , o.default ) for o in klass.option _ list if ( o.default is not NO _ DEFAULT ) &#93; ) DCNL DCSP defaults.update ( options ) DCNL DCSP return klass.execute ( * args , * * defaults )
DCSP comment = get _ object _ or _ 404 ( comments.get _ model ( ) , pk = comment _ id , site _ _ pk = settings.SITE _ ID ) DCNL DCSP if ( request.method = = &apos; POST &apos; ) : DCNL DCSP DCSP perform _ delete ( request , comment ) DCNL DCSP DCSP return next _ redirect ( request , next , delete _ done , c = comment.pk ) DCNL DCSP else : DCNL DCSP DCSP return render _ to _ response ( &apos; comments / delete.html &apos; , { &apos; comment &apos; : comment , &apos; next &apos; : next } , template.RequestContext ( request ) )
DCSP if rendering _ params &#91; &apos; summary &apos; &#93; : DCNL DCSP DCSP return doc.get _ summary _ html ( ) DCNL DCSP if ( not ( rendering _ params &#91; &apos; section &apos; &#93; or rendering _ params &#91; &apos; raw &apos; &#93; or rendering _ params &#91; &apos; edit _ links &apos; &#93; or rendering _ params &#91; &apos; include &apos; &#93; ) ) : DCNL DCSP DCSP return doc _ html DCNL DCSP tool = kuma.wiki.content.parse ( doc _ html ) DCNL DCSP if rendering _ params &#91; &apos; raw &apos; &#93; : DCNL DCSP DCSP tool.injectSectionIDs ( ) DCNL DCSP DCSP tool.filterEditorSafety ( ) DCNL DCSP if rendering _ params &#91; &apos; section &apos; &#93; : DCNL DCSP DCSP tool.extractSection ( rendering _ params &#91; &apos; section &apos; &#93; ) DCNL DCSP if ( ( rendering _ params &#91; &apos; edit _ links &apos; &#93; or ( not rendering _ params &#91; &apos; raw &apos; &#93; ) ) and request.user.is _ authenticated ( ) and doc.allows _ revision _ by ( request.user ) ) : DCNL DCSP DCSP tool.injectSectionEditingLinks ( doc.slug , doc.locale ) DCNL DCSP doc _ html = tool.serialize ( ) DCNL DCSP if rendering _ params &#91; &apos; include &apos; &#93; : DCNL DCSP DCSP doc _ html = kuma.wiki.content.filter _ out _ noinclude ( doc _ html ) DCNL DCSP return doc _ html
DCSP if epoch _ axis : DCNL DCSP DCSP x = np.zeros ( ( minibatches , ) ) DCNL DCSP DCSP last _ e = 0 DCNL DCSP DCSP for ( e _ idx , e ) in enumerate ( minibatch _ markers ) : DCNL DCSP DCSP DCSP e _ minibatches = ( e - last _ e ) DCNL DCSP DCSP DCSP x &#91; last _ e : e &#93; = ( e _ idx + ( np.arange ( float ( e _ minibatches ) ) / e _ minibatches ) ) DCNL DCSP DCSP DCSP last _ e = e DCNL DCSP else : DCNL DCSP DCSP x = np.arange ( minibatches ) DCNL DCSP return x
DCSP return call _ talib _ with _ ohlc ( barDs , count , talib.CDLMORNINGDOJISTAR , penetration )
DCSP return ( ( 1.0 / np.sqrt ( ( 4 * np.pi ) ) ) * np.exp ( ( ( - ( ( Xi - x ) * * 2 ) ) / ( ( h * * 2 ) * 4.0 ) ) ) )
DCSP reg _ dir = _ reg _ dir ( ) DCNL DCSP regfile = os.path.join ( reg _ dir , &apos; register &apos; ) DCNL DCSP try : DCNL DCSP DCSP with salt.utils.fopen ( regfile , &apos; r &apos; ) as fh _ : DCNL DCSP DCSP DCSP return msgpack.load ( fh _ ) DCNL DCSP except : DCNL DCSP DCSP log.error ( &apos; Could DCSP not DCSP write DCSP to DCSP msgpack DCSP file DCSP { 0 } &apos; .format ( _ _ opts _ _ &#91; &apos; outdir &apos; &#93; ) ) DCNL DCSP DCSP raise
DCSP Node = namedtuple ( &apos; Node &apos; , &#91; &apos; name &apos; , &apos; type &apos; &#93; ) DCNL DCSP for d in dirs : DCNL DCSP DCSP d = pathlib2.Path ( git _ dir , d ) DCNL DCSP DCSP for item in d.iterdir ( ) : DCNL DCSP DCSP DCSP if item.match ( &apos; * .yml &apos; ) : DCNL DCSP DCSP DCSP DCSP yaml _ file = _ open _ yaml _ file ( item ) DCNL DCSP DCSP DCSP DCSP if ( yaml _ file is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP for play in yaml _ file : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( key in play ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP for role in play &#91; key &#93; : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP name = _ get _ role _ name ( role ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP node _ 1 = Node ( item.stem , type _ 1 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP node _ 2 = Node ( name , type _ 2 ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP graph.add _ edge ( node _ 2 , node _ 1 )
DCSP if ( fd = = ( -1 ) ) : DCNL DCSP DCSP signal.signal ( signal.SIGCHLD , signal.SIG _ DFL ) DCNL DCSP else : DCNL DCSP DCSP signal.signal ( signal.SIGCHLD , _ Handler ( None ) ) DCNL DCSP DCSP siginterrupt ( signal.SIGCHLD , False ) DCNL DCSP return set _ wakeup _ fd ( fd )
DCSP try : DCNL DCSP DCSP model = get _ model ( AUTH _ USER _ APP _ LABEL , AUTH _ USER _ MODEL _ NAME ) DCNL DCSP except LookupError : DCNL DCSP DCSP raise ImproperlyConfigured ( ( &quot; AUTH _ USER _ MODEL DCSP refers DCSP to DCSP model DCSP &apos; % s &apos; DCSP that DCSP has DCSP not DCSP been DCSP installed &quot; % settings.AUTH _ USER _ MODEL ) ) DCNL DCSP core _ fields = set ( &#91; f.name for f in User . _ meta.fields &#93; ) DCNL DCSP model _ fields = set ( &#91; f.name for f in model . _ meta.fields &#93; ) DCNL DCSP new _ fields = model _ fields.difference ( core _ fields ) DCNL DCSP model . _ meta.has _ additional _ fields = ( len ( new _ fields ) &gt; 0 ) DCNL DCSP model . _ meta.additional _ fields = new _ fields DCNL DCSP return model
DCSP view _ name = &apos; xblock _ handler &apos; DCNL DCSP if handler _ name : DCNL DCSP DCSP func = getattr ( block . _ _ class _ _ , handler _ name , None ) DCNL DCSP DCSP if ( not func ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; { ! r } DCSP is DCSP not DCSP a DCSP function DCSP name &apos; .format ( handler _ name ) ) DCNL DCSP if thirdparty : DCNL DCSP DCSP view _ name = &apos; xblock _ handler _ noauth &apos; DCNL DCSP url = reverse ( view _ name , kwargs = { &apos; course _ id &apos; : unicode ( block.location.course _ key ) , &apos; usage _ id &apos; : quote _ slashes ( unicode ( block.scope _ ids.usage _ id ) .encode ( &apos; utf-8 &apos; ) ) , &apos; handler &apos; : handler _ name , &apos; suffix &apos; : suffix } ) DCNL DCSP if ( not suffix ) : DCNL DCSP DCSP url = url.rstrip ( &apos; / &apos; ) DCNL DCSP if query : DCNL DCSP DCSP url + = ( &apos; ? &apos; + query ) DCNL DCSP if thirdparty : DCNL DCSP DCSP scheme = ( &apos; https &apos; if ( settings.HTTPS = = &apos; on &apos; ) else &apos; http &apos; ) DCNL DCSP DCSP url = &apos; { scheme } : / / { host } { path } &apos; .format ( scheme = scheme , host = settings.SITE _ NAME , path = url ) DCNL DCSP return url
DCSP session = ( kwargs.get ( &apos; session &apos; ) or get _ session ( ) ) DCNL DCSP read _ deleted = ( kwargs.get ( &apos; read _ deleted &apos; ) or context.read _ deleted ) DCNL DCSP project _ only = kwargs.get ( &apos; project _ only &apos; , False ) DCNL DCSP def issubclassof _ nova _ base ( obj ) : DCNL DCSP DCSP return ( isinstance ( obj , type ) and issubclass ( obj , models.NovaBase ) ) DCNL DCSP base _ model = model DCNL DCSP if ( not issubclassof _ nova _ base ( base _ model ) ) : DCNL DCSP DCSP base _ model = kwargs.get ( &apos; base _ model &apos; , None ) DCNL DCSP DCSP if ( not issubclassof _ nova _ base ( base _ model ) ) : DCNL DCSP DCSP DCSP raise Exception ( _ ( &apos; model DCSP or DCSP base _ model DCSP parameter DCSP should DCSP be DCSP subclass DCSP of DCSP NovaBase &apos; ) ) DCNL DCSP query = session.query ( model , * args ) DCNL DCSP default _ deleted _ value = base _ model . _ _ mapper _ _ .c.deleted.default.arg DCNL DCSP if ( read _ deleted = = &apos; no &apos; ) : DCNL DCSP DCSP query = query.filter ( ( base _ model.deleted = = default _ deleted _ value ) ) DCNL DCSP elif ( read _ deleted = = &apos; yes &apos; ) : DCNL DCSP DCSP pass DCNL DCSP elif ( read _ deleted = = &apos; only &apos; ) : DCNL DCSP DCSP query = query.filter ( ( base _ model.deleted ! = default _ deleted _ value ) ) DCNL DCSP else : DCNL DCSP DCSP raise Exception ( ( _ ( &quot; Unrecognized DCSP read _ deleted DCSP value DCSP &apos; % s &apos; &quot; ) % read _ deleted ) ) DCNL DCSP if ( nova.context.is _ user _ context ( context ) and project _ only ) : DCNL DCSP DCSP if ( project _ only = = &apos; allow _ none &apos; ) : DCNL DCSP DCSP DCSP query = query.filter ( or _ ( ( base _ model.project _ id = = context.project _ id ) , ( base _ model.project _ id = = None ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP query = query.filter _ by ( project _ id = context.project _ id ) DCNL DCSP return query
DCSP try : DCNL DCSP DCSP import numpy as np DCNL DCSP DCSP from scipy import sparse DCNL DCSP except ImportError : DCNL DCSP DCSP raise ImportError ( &apos; attr _ sparse _ matrix ( ) DCSP requires DCSP scipy : DCSP http : / / scipy.org / DCSP &apos; ) DCNL DCSP edge _ value = _ edge _ value ( G , edge _ attr ) DCNL DCSP node _ value = _ node _ value ( G , node _ attr ) DCNL DCSP if ( rc _ order is None ) : DCNL DCSP DCSP ordering = list ( set ( &#91; node _ value ( n ) for n in G &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP ordering = rc _ order DCNL DCSP N = len ( ordering ) DCNL DCSP undirected = ( not G.is _ directed ( ) ) DCNL DCSP index = dict ( zip ( ordering , range ( N ) ) ) DCNL DCSP M = sparse.lil _ matrix ( ( N , N ) , dtype = dtype ) DCNL DCSP seen = set ( &#91; &#93; ) DCNL DCSP for ( u , nbrdict ) in G.adjacency ( ) : DCNL DCSP DCSP for v in nbrdict : DCNL DCSP DCSP DCSP ( i , j ) = ( index &#91; node _ value ( u ) &#93; , index &#91; node _ value ( v ) &#93; ) DCNL DCSP DCSP DCSP if ( v not in seen ) : DCNL DCSP DCSP DCSP DCSP M &#91; ( i , j ) &#93; + = edge _ value ( u , v ) DCNL DCSP DCSP DCSP DCSP if undirected : DCNL DCSP DCSP DCSP DCSP DCSP M &#91; ( j , i ) &#93; = M &#91; ( i , j ) &#93; DCNL DCSP DCSP if undirected : DCNL DCSP DCSP DCSP seen.add ( u ) DCNL DCSP if normalized : DCNL DCSP DCSP norms = np.asarray ( M.sum ( axis = 1 ) ) .ravel ( ) DCNL DCSP DCSP for ( i , norm ) in enumerate ( norms ) : DCNL DCSP DCSP DCSP M &#91; i , : &#93; / = norm DCNL DCSP if ( rc _ order is None ) : DCNL DCSP DCSP return ( M , ordering ) DCNL DCSP else : DCNL DCSP DCSP return M
DCSP context.dispatcher.command _ list _ receiving = True DCNL DCSP context.dispatcher.command _ list _ ok = True DCNL DCSP context.dispatcher.command _ list = &#91; &#93;
DCSP dc = daclConstants ( ) DCNL DCSP objectType = dc.getObjectTypeBit ( objectType ) DCNL DCSP try : DCNL DCSP DCSP userSid = win32security.LookupAccountSid ( &apos; &apos; , ace &#91; 2 &#93; ) DCNL DCSP DCSP if userSid &#91; 1 &#93; : DCNL DCSP DCSP DCSP userSid = &apos; { 1 } \ \ { 0 } &apos; .format ( userSid &#91; 0 &#93; , userSid &#91; 1 &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP userSid = &apos; { 0 } &apos; .format ( userSid &#91; 0 &#93; ) DCNL DCSP except Exception : DCNL DCSP DCSP userSid = win32security.ConvertSidToStringSid ( ace &#91; 2 &#93; ) DCNL DCSP tPerm = ace &#91; 1 &#93; DCNL DCSP tAceType = ace &#91; 0 &#93; &#91; 0 &#93; DCNL DCSP tProps = ace &#91; 0 &#93; &#91; 1 &#93; DCNL DCSP tInherited = &apos; &apos; DCNL DCSP for x in dc.validAceTypes : DCNL DCSP DCSP if ( dc.validAceTypes &#91; x &#93; &#91; &apos; BITS &apos; &#93; = = tAceType ) : DCNL DCSP DCSP DCSP tAceType = dc.validAceTypes &#91; x &#93; &#91; &apos; TEXT &apos; &#93; DCNL DCSP DCSP DCSP break DCNL DCSP for x in dc.rights &#91; objectType &#93; : DCNL DCSP DCSP if ( dc.rights &#91; objectType &#93; &#91; x &#93; &#91; &apos; BITS &apos; &#93; = = tPerm ) : DCNL DCSP DCSP DCSP tPerm = dc.rights &#91; objectType &#93; &#91; x &#93; &#91; &apos; TEXT &apos; &#93; DCNL DCSP DCSP DCSP break DCNL DCSP if ( ( tProps &amp; win32security.INHERITED _ ACE ) = = win32security.INHERITED _ ACE ) : DCNL DCSP DCSP tInherited = &apos; &#91; Inherited &#93; &apos; DCNL DCSP DCSP tProps = ( tProps ^ win32security.INHERITED _ ACE ) DCNL DCSP for x in dc.validPropagations &#91; objectType &#93; : DCNL DCSP DCSP if ( dc.validPropagations &#91; objectType &#93; &#91; x &#93; &#91; &apos; BITS &apos; &#93; = = tProps ) : DCNL DCSP DCSP DCSP tProps = dc.validPropagations &#91; objectType &#93; &#91; x &#93; &#91; &apos; TEXT &apos; &#93; DCNL DCSP DCSP DCSP break DCNL DCSP return &apos; { 0 } DCSP { 1 } DCSP { 2 } DCSP on DCSP { 3 } DCSP { 4 } &apos; .format ( userSid , tAceType , tPerm , tProps , tInherited )
DCSP if ( offset is None ) : DCNL DCSP DCSP if ( not kwargs ) : DCNL DCSP DCSP DCSP return default DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return _ td _ check ( datetime.timedelta ( * * kwargs ) ) DCNL DCSP elif kwargs : DCNL DCSP DCSP raise ValueError ( &apos; Cannot DCSP pass DCSP kwargs DCSP and DCSP an DCSP offset &apos; ) DCNL DCSP elif isinstance ( offset , datetime.timedelta ) : DCNL DCSP DCSP return _ td _ check ( offset ) DCNL DCSP else : DCNL DCSP DCSP raise TypeError ( &quot; Must DCSP pass DCSP &apos; hours &apos; DCSP and / or DCSP &apos; minutes &apos; DCSP as DCSP keywords &quot; )
DCSP if use _ cpickle : DCNL DCSP DCSP pickler = cPickle.Pickler DCNL DCSP else : DCNL DCSP DCSP pickler = _ PicklerWithWarning DCNL DCSP with closing ( tarfile.TarFile ( fileobj = file _ , mode = &apos; w &apos; ) ) as tar _ file : DCNL DCSP DCSP external _ objects = { } DCNL DCSP DCSP def _ save _ parameters ( f ) : DCNL DCSP DCSP DCSP renamer = _ Renamer ( ) DCNL DCSP DCSP DCSP named _ parameters = { renamer ( p ) : p for p in parameters } DCNL DCSP DCSP DCSP numpy.savez ( f , * * { n : p.get _ value ( ) for ( n , p ) in named _ parameters.items ( ) } ) DCNL DCSP DCSP DCSP for ( name , p ) in named _ parameters.items ( ) : DCNL DCSP DCSP DCSP DCSP array _ = p.container.storage &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP external _ objects &#91; id ( array _ ) &#93; = _ mangle _ parameter _ name ( p , name ) DCNL DCSP DCSP if parameters : DCNL DCSP DCSP DCSP _ taradd ( _ save _ parameters , tar _ file , &apos; _ parameters &apos; ) DCNL DCSP DCSP if ( object _ is not None ) : DCNL DCSP DCSP DCSP save _ object = _ SaveObject ( pickler , object _ , external _ objects , protocol , * * kwargs ) DCNL DCSP DCSP DCSP _ taradd ( save _ object , tar _ file , &apos; _ pkl &apos; )
DCSP for key in ( &apos; discussion _ id &apos; , &apos; discussion _ category &apos; , &apos; discussion _ target &apos; ) : DCNL DCSP DCSP if ( getattr ( xblock , key , None ) is None ) : DCNL DCSP DCSP DCSP log.debug ( &quot; Required DCSP key DCSP &apos; % s &apos; DCSP not DCSP in DCSP discussion DCSP % s , DCSP leaving DCSP out DCSP of DCSP category DCSP map &quot; , key , xblock.location ) DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP if isinstance ( train , theano.tensor.sharedvar.SharedVariable ) : DCNL DCSP DCSP train = train.get _ value ( borrow = True ) DCNL DCSP if isinstance ( label , theano.tensor.sharedvar.SharedVariable ) : DCNL DCSP DCSP label = label.get _ value ( borrow = True ) DCNL DCSP if ( not ( isinstance ( train , numpy.ndarray ) or scipy.sparse.issparse ( train ) ) ) : DCNL DCSP DCSP raise TypeError ( &apos; train DCSP must DCSP be DCSP a DCSP numpy DCSP array , DCSP a DCSP scipy DCSP sparse DCSP matrix , DCSP or DCSP a DCSP theano DCSP shared DCSP array &apos; ) DCNL DCSP if ( classes is not None ) : DCNL DCSP DCSP label = label &#91; : , classes &#93; DCNL DCSP if scipy.sparse.issparse ( train ) : DCNL DCSP DCSP idx = label.sum ( axis = 1 ) .nonzero ( ) &#91; 0 &#93; DCNL DCSP DCSP return ( train &#91; idx &#93; , label &#91; idx &#93; ) DCNL DCSP condition = label.any ( axis = 1 ) DCNL DCSP return tuple ( ( var.compress ( condition , axis = 0 ) for var in ( train , label ) ) )
DCSP frappe.db.sql ( u &apos;delete DCSP from DCSP `tabDesktop DCSP Icon` DCSP where DCSP standard = 0 &apos; ) DCNL DCSP frappe.db.sql ( u &apos;update DCSP `tabDesktop DCSP Icon` DCSP set DCSP blocked = 0 , DCSP hidden = 1 &apos; ) DCNL DCSP for module _ name in visible _ list : DCNL DCSP DCSP name = frappe.db.get _ value ( u &apos;Desktop DCSP Icon &apos; , { u &apos;module _ name &apos; : module _ name } ) DCNL DCSP DCSP if name : DCNL DCSP DCSP DCSP frappe.db.set _ value ( u &apos;Desktop DCSP Icon &apos; , name , u &apos;hidden &apos; , 0 ) DCNL DCSP DCSP elif frappe.db.exists ( u &apos;DocType &apos; , module _ name ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP add _ user _ icon ( module _ name , standard = 1 ) DCNL DCSP DCSP DCSP except frappe.UniqueValidationError as e : DCNL DCSP DCSP DCSP DCSP if ( not ignore _ duplicate ) : DCNL DCSP DCSP DCSP DCSP DCSP raise e DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP visible _ list.remove ( module _ name ) DCNL DCSP DCSP DCSP DCSP DCSP if frappe.message _ log : DCNL DCSP DCSP DCSP DCSP DCSP DCSP frappe.message _ log.pop ( ) DCNL DCSP set _ order ( visible _ list ) DCNL DCSP clear _ desktop _ icons _ cache ( )
DCSP n = as _ int ( nth ) DCNL DCSP if ( n &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; nth DCSP must DCSP be DCSP a DCSP positive DCSP integer ; DCSP prime ( 1 ) DCSP = = DCSP 2 &apos; ) DCNL DCSP if ( n &lt; = len ( sieve . _ list ) ) : DCNL DCSP DCSP return sieve &#91; n &#93; DCNL DCSP from sympy.functions.special.error _ functions import li DCNL DCSP from sympy.functions.elementary.exponential import log DCNL DCSP a = 2 DCNL DCSP b = int ( ( n * ( log ( n ) + log ( log ( n ) ) ) ) ) DCNL DCSP while ( a &lt; b ) : DCNL DCSP DCSP mid = ( ( a + b ) &gt; &gt; 1 ) DCNL DCSP DCSP if ( li ( mid ) &gt; n ) : DCNL DCSP DCSP DCSP b = mid DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP a = ( mid + 1 ) DCNL DCSP n _ primes = primepi ( ( a - 1 ) ) DCNL DCSP while ( n _ primes &lt; n ) : DCNL DCSP DCSP if isprime ( a ) : DCNL DCSP DCSP DCSP n _ primes + = 1 DCNL DCSP DCSP a + = 1 DCNL DCSP return ( a - 1 )
DCSP c = dict ( context.items ( ) ) DCNL DCSP request = c &#91; &apos; request &apos; &#93; DCNL DCSP if request.user.is _ authenticated ( ) : DCNL DCSP DCSP is _ favorite = ( addon.id in request.user.favorite _ addons ) DCNL DCSP DCSP faved _ class = ( &apos; faved &apos; if is _ favorite else &apos; &apos; ) DCNL DCSP DCSP unfaved _ text = ( &apos; &apos; if condensed else _ ( &apos; Add DCSP to DCSP favorites &apos; ) ) DCNL DCSP DCSP faved _ text = ( _ ( &apos; Favorite &apos; ) if condensed else _ ( &apos; Remove DCSP from DCSP favorites &apos; ) ) DCNL DCSP DCSP add _ url = reverse ( &apos; collections.alter &apos; , args = &#91; request.user.username , &apos; favorites &apos; , &apos; add &apos; &#93; ) DCNL DCSP DCSP remove _ url = reverse ( &apos; collections.alter &apos; , args = &#91; request.user.username , &apos; favorites &apos; , &apos; remove &apos; &#93; ) DCNL DCSP DCSP c.update ( locals ( ) ) DCNL DCSP DCSP t = get _ env ( ) .get _ template ( &apos; bandwagon / favorites _ widget.html &apos; ) .render ( c ) DCNL DCSP DCSP return jinja2.Markup ( t )
DCSP with io.open ( filename , &apos; rt &apos; , encoding = &apos; utf8 &apos; ) as names _ file : DCNL DCSP DCSP for name in filter _ koan _ names ( names _ file ) : DCNL DCSP DCSP DCSP ( yield name ) DCNL DCSP return
DCSP if settings.USE _ L10N : DCNL DCSP DCSP decimal _ separator = get _ format ( &apos; DECIMAL _ SEPARATOR &apos; ) DCNL DCSP DCSP if isinstance ( value , six.string _ types ) : DCNL DCSP DCSP DCSP parts = &#91; &#93; DCNL DCSP DCSP DCSP if ( decimal _ separator in value ) : DCNL DCSP DCSP DCSP DCSP ( value , decimals ) = value.split ( decimal _ separator , 1 ) DCNL DCSP DCSP DCSP DCSP parts.append ( decimals ) DCNL DCSP DCSP DCSP if settings.USE _ THOUSAND _ SEPARATOR : DCNL DCSP DCSP DCSP DCSP parts.append ( value.replace ( get _ format ( &apos; THOUSAND _ SEPARATOR &apos; ) , &apos; &apos; ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP parts.append ( value ) DCNL DCSP DCSP DCSP value = &apos; .&apos;.join ( reversed ( parts ) ) DCNL DCSP return value
DCSP if six.PY2 : DCNL DCSP DCSP if isinstance ( func , functools.partial ) : DCNL DCSP DCSP DCSP spec = inspect.getargspec ( func.func ) DCNL DCSP DCSP elif inspect.isroutine ( func ) : DCNL DCSP DCSP DCSP spec = inspect.getargspec ( func ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP spec = inspect.getargspec ( func . _ _ call _ _ ) DCNL DCSP DCSP args = &#91; arg for arg in spec.args if ( arg ! = &apos; self &apos; ) &#93; DCNL DCSP else : DCNL DCSP DCSP sig = inspect.signature ( func ) DCNL DCSP DCSP args = &#91; param.name for param in sig.parameters.values ( ) if ( param.kind not in ( inspect.Parameter.VAR _ POSITIONAL , inspect.Parameter.VAR _ KEYWORD ) ) &#93; DCNL DCSP return args
DCSP try : DCNL DCSP DCSP indices = list ( client.indices.get _ settings ( index = &apos; _ all &apos; , params = { &apos; expand _ wildcards &apos; : &apos; open , closed &apos; } ) ) DCNL DCSP DCSP version _ number = get _ version ( client ) DCNL DCSP DCSP logger.debug ( &apos; Detected DCSP Elasticsearch DCSP version DCSP { 0 } &apos; .format ( &apos; .&apos;.join ( map ( str , version _ number ) ) ) ) DCNL DCSP DCSP if ( ( version _ number &gt; = ( 2 , 4 , 2 ) ) and ( version _ number &lt; ( 5 , 0 , 0 ) ) ) : DCNL DCSP DCSP DCSP logger.debug ( &apos; Using DCSP Elasticsearch DCSP &gt; = DCSP 2.4.2 DCSP &lt; DCSP 5.0.0 &apos; ) DCNL DCSP DCSP DCSP if client.indices.exists ( index = &apos; .security &apos; ) : DCNL DCSP DCSP DCSP DCSP logger.debug ( &apos; Found DCSP the DCSP &quot; .security &quot; DCSP index . DCSP DCSP Adding DCSP to DCSP list DCSP of DCSP all DCSP indices &apos; ) DCNL DCSP DCSP DCSP DCSP if ( not ( &apos; .security &apos; in indices ) ) : DCNL DCSP DCSP DCSP DCSP DCSP indices.append ( &apos; .security &apos; ) DCNL DCSP DCSP logger.debug ( &apos; All DCSP indices : DCSP { 0 } &apos; .format ( indices ) ) DCNL DCSP DCSP return indices DCNL DCSP except Exception as e : DCNL DCSP DCSP raise FailedExecution ( &apos; Failed DCSP to DCSP get DCSP indices . DCSP Error : DCSP { 0 } &apos; .format ( e ) )
DCSP with qtbot.waitSignal ( view . _ clear _ timer.timeout ) : DCNL DCSP DCSP view.show _ message ( usertypes.MessageLevel.info , &apos; test &apos; ) DCNL DCSP assert ( not view . _ messages )
DCSP print &apos; Updating DCSP fancy-dmg DCSP Makefile ... &apos; DCNL DCSP url = &apos; https : / / raw.githubusercontent.com / remko / fancy-dmg / master / Makefile &apos; DCNL DCSP target _ path = os.path.join ( &apos; scripts &apos; , &apos; dev &apos; , &apos; Makefile-dmg &apos; ) DCNL DCSP urllib.request.urlretrieve ( url , target _ path ) DCNL DCSP urllib.request.urlcleanup ( )
DCSP return ( { } if ( headers is None ) else dict ( headers ) )
DCSP orig _ model = None DCNL DCSP try : DCNL DCSP DCSP orig _ model = loading.cache.app _ models &#91; &apos; tests &apos; &#93; &#91; &apos; secret &apos; &#93; DCNL DCSP DCSP del loading.cache.app _ models &#91; &apos; tests &apos; &#93; &#91; &apos; secret &apos; &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP attrs = { &apos; name &apos; : EncryptedCharField ( &apos; Name &apos; , max _ length = Secret . _ meta.get _ field ( &apos; name &apos; ) .max _ length ) , &apos; text &apos; : EncryptedTextField ( &apos; Text &apos; ) , &apos; _ _ module _ _ &apos; : &apos; django _ extensions.tests.models &apos; , &apos; Meta &apos; : type ( &apos; Meta &apos; , ( object , ) , { &apos; managed &apos; : False , &apos; db _ table &apos; : Secret . _ meta.db _ table } ) } DCNL DCSP DCSP ( yield type ( &apos; Secret &apos; , ( models.Model , ) , attrs ) ) DCNL DCSP except : DCNL DCSP DCSP raise DCNL DCSP finally : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP loading.cache.app _ models &#91; &apos; tests &apos; &#93; &#91; &apos; secret &apos; &#93; = orig _ model DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP pass
DCSP ret = &#91; &#93; DCNL DCSP for line in _ _ salt _ _ &#91; &apos; cmd.run &apos; &#93; ( &apos; kldstat &apos; ) .splitlines ( ) : DCNL DCSP DCSP comps = line.split ( ) DCNL DCSP DCSP if ( not ( len ( comps ) &gt; 2 ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( comps &#91; 0 &#93; = = &apos; Id &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( comps &#91; 4 &#93; = = &apos; kernel &apos; ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ret.append ( { &apos; module &apos; : comps &#91; 4 &#93; &#91; : ( -3 ) &#93; , &apos; size &apos; : comps &#91; 3 &#93; , &apos; depcount &apos; : comps &#91; 1 &#93; } ) DCNL DCSP return ret
DCSP if ( name not in container.mime _ map ) : DCNL DCSP DCSP raise ValueError ( ( u &apos;Cannot DCSP mark DCSP % s DCSP as DCSP cover DCSP as DCSP it DCSP does DCSP not DCSP exist &apos; % name ) ) DCNL DCSP mt = container.mime _ map &#91; name &#93; DCNL DCSP if ( not is _ raster _ image ( mt ) ) : DCNL DCSP DCSP raise ValueError ( ( u &apos;Cannot DCSP mark DCSP % s DCSP as DCSP the DCSP cover DCSP image DCSP as DCSP it DCSP is DCSP not DCSP a DCSP raster DCSP image &apos; % name ) ) DCNL DCSP if ( container.book _ type = = u &apos;azw3 &apos; ) : DCNL DCSP DCSP mark _ as _ cover _ azw3 ( container , name ) DCNL DCSP else : DCNL DCSP DCSP mark _ as _ cover _ epub ( container , name )
DCSP vbd _ rec &#91; &apos; currently _ attached &apos; &#93; = False DCNL DCSP vbd _ rec &#91; &apos; device &apos; &#93; = &apos; &apos; DCNL DCSP vm _ ref = vbd _ rec &#91; &apos; VM &apos; &#93; DCNL DCSP vm _ rec = _ db _ content &#91; &apos; VM &apos; &#93; &#91; vm _ ref &#93; DCNL DCSP vm _ rec &#91; &apos; VBDs &apos; &#93; .append ( vbd _ ref ) DCNL DCSP vdi _ ref = vbd _ rec &#91; &apos; VDI &apos; &#93; DCNL DCSP vdi _ rec = _ db _ content &#91; &apos; VDI &apos; &#93; &#91; vdi _ ref &#93; DCNL DCSP vdi _ rec &#91; &apos; VBDs &apos; &#93; .append ( vbd _ ref ) DCNL DCSP vm _ name _ label = _ db _ content &#91; &apos; VM &apos; &#93; &#91; vm _ ref &#93; &#91; &apos; name _ label &apos; &#93; DCNL DCSP vbd _ rec &#91; &apos; vm _ name _ label &apos; &#93; = vm _ name _ label
DCSP if ( xblock.category = = &apos; vertical &apos; ) : DCNL DCSP DCSP if ( parent _ xblock is None ) : DCNL DCSP DCSP DCSP parent _ xblock = get _ parent _ xblock ( xblock ) DCNL DCSP DCSP parent _ category = ( parent _ xblock.category if parent _ xblock else None ) DCNL DCSP DCSP return ( parent _ category = = &apos; sequential &apos; ) DCNL DCSP return False
DCSP return wechat.response _ news ( app.config &#91; &apos; BUS _ ROUTES _ NEWS &apos; &#93; )
DCSP valid _ formats = &#91; &#93; DCNL DCSP for ( data _ format , data _ class ) in _ identifiers : DCNL DCSP DCSP if _ is _ best _ match ( data _ class _ required , data _ class , _ identifiers ) : DCNL DCSP DCSP DCSP if _ identifiers &#91; ( data _ format , data _ class ) &#93; ( origin , path , fileobj , * args , * * kwargs ) : DCNL DCSP DCSP DCSP DCSP valid _ formats.append ( data _ format ) DCNL DCSP return valid _ formats
DCSP return _ get _ messages _ from _ page _ or _ report ( u &apos;Page &apos; , name )
DCSP try : DCNL DCSP DCSP return _ env.get _ template ( template ) .render ( * * kwargs ) DCNL DCSP except jinja2.exceptions.UndefinedError : DCNL DCSP DCSP log.misc.exception ( ( &apos; UndefinedError DCSP while DCSP rendering DCSP &apos; + template ) ) DCNL DCSP DCSP err _ path = os.path.join ( &apos; html &apos; , &apos; undef _ error.html &apos; ) DCNL DCSP DCSP err _ template = utils.read _ file ( err _ path ) DCNL DCSP DCSP tb = traceback.format _ exc ( ) DCNL DCSP DCSP return err _ template.format ( pagename = template , traceback = tb )
DCSP _ assert _ no _ element _ by ( context , By.ID , _ id , wait _ time )
DCSP return _ resize ( original _ size , 1 , padding = padding , keep _ aspect _ ratio = True )
DCSP archs = ( &apos; x86 &apos; , &apos; x64 &apos; ) DCNL DCSP if generator _ flags.get ( &apos; ninja _ use _ custom _ environment _ files &apos; , 0 ) : DCNL DCSP DCSP cl _ paths = { } DCNL DCSP DCSP for arch in archs : DCNL DCSP DCSP DCSP cl _ paths &#91; arch &#93; = &apos; cl.exe &apos; DCNL DCSP DCSP return cl _ paths DCNL DCSP vs = GetVSVersion ( generator _ flags ) DCNL DCSP cl _ paths = { } DCNL DCSP for arch in archs : DCNL DCSP DCSP args = vs.SetupScript ( arch ) DCNL DCSP DCSP args.extend ( ( &apos; &amp; &amp; &apos; , &apos; set &apos; ) ) DCNL DCSP DCSP popen = subprocess.Popen ( args , shell = True , stdout = subprocess.PIPE , stderr = subprocess.STDOUT ) DCNL DCSP DCSP ( variables , _ ) = popen.communicate ( ) DCNL DCSP DCSP env = _ ExtractImportantEnvironment ( variables ) DCNL DCSP DCSP if system _ includes : DCNL DCSP DCSP DCSP system _ includes = ( system _ includes &#124; OrderedSet ( env.get ( &apos; INCLUDE &apos; , &apos; &apos; ) .split ( &apos; ; &apos; ) ) ) DCNL DCSP DCSP DCSP env &#91; &apos; INCLUDE &apos; &#93; = &apos; ; &apos; .join ( system _ includes ) DCNL DCSP DCSP env _ block = _ FormatAsEnvironmentBlock ( env ) DCNL DCSP DCSP f = open _ out ( os.path.join ( toplevel _ build _ dir , ( &apos; environment . &apos; + arch ) ) , &apos; wb &apos; ) DCNL DCSP DCSP f.write ( env _ block ) DCNL DCSP DCSP f.close ( ) DCNL DCSP DCSP args = vs.SetupScript ( arch ) DCNL DCSP DCSP args.extend ( ( &apos; &amp; &amp; &apos; , &apos; for &apos; , &apos; % i &apos; , &apos; in &apos; , &apos; ( cl.exe ) &apos; , &apos; do &apos; , &apos; @ echo &apos; , &apos; LOC : % ~ $ PATH : i &apos; ) ) DCNL DCSP DCSP popen = subprocess.Popen ( args , shell = True , stdout = subprocess.PIPE ) DCNL DCSP DCSP ( output , _ ) = popen.communicate ( ) DCNL DCSP DCSP cl _ paths &#91; arch &#93; = _ ExtractCLPath ( output ) DCNL DCSP return cl _ paths
DCSP src = files &#91; &apos; src &apos; &#93; DCNL DCSP dest = files &#91; &apos; dest &apos; &#93; DCNL DCSP src _ type = src &#91; &apos; type &apos; &#93; DCNL DCSP dest _ type = dest &#91; &apos; type &apos; &#93; DCNL DCSP if ( src _ path is None ) : DCNL DCSP DCSP src _ path = src &#91; &apos; path &apos; &#93; DCNL DCSP sep _ table = { &apos; s3 &apos; : &apos; / &apos; , &apos; local &apos; : os.sep } DCNL DCSP if files &#91; &apos; dir _ op &apos; &#93; : DCNL DCSP DCSP rel _ path = src _ path &#91; len ( src &#91; &apos; path &apos; &#93; ) : &#93; DCNL DCSP else : DCNL DCSP DCSP rel _ path = src _ path.split ( sep _ table &#91; src _ type &#93; ) &#91; ( -1 ) &#93; DCNL DCSP compare _ key = rel _ path.replace ( sep _ table &#91; src _ type &#93; , &apos; / &apos; ) DCNL DCSP if files &#91; &apos; use _ src _ name &apos; &#93; : DCNL DCSP DCSP dest _ path = dest &#91; &apos; path &apos; &#93; DCNL DCSP DCSP dest _ path + = rel _ path.replace ( sep _ table &#91; src _ type &#93; , sep _ table &#91; dest _ type &#93; ) DCNL DCSP else : DCNL DCSP DCSP dest _ path = dest &#91; &apos; path &apos; &#93; DCNL DCSP return ( dest _ path , compare _ key )
DCSP return &apos; Mangle DCSP plugins DCSP modify DCSP requests DCSP on DCSP the DCSP fly . \ n DCSP DCSP DCSP DCSP &apos;
DCSP msg = &apos; N321 : DCSP jsonutils . % ( fun ) s DCSP must DCSP be DCSP used DCSP instead DCSP of DCSP json . % ( fun ) s &apos; DCNL DCSP json _ check _ skipped _ patterns = &#91; &apos; neutron / plugins / ml2 / drivers / openvswitch / agent / xenapi / etc / xapi.d / plugins / netwrap &apos; &#93; DCNL DCSP for pattern in json _ check _ skipped _ patterns : DCNL DCSP DCSP if ( pattern in filename ) : DCNL DCSP DCSP DCSP return DCNL DCSP if ( &apos; json . &apos; in logical _ line ) : DCNL DCSP DCSP json _ funcs = &#91; &apos; dumps ( &apos; , &apos; dump ( &apos; , &apos; loads ( &apos; , &apos; load ( &apos; &#93; DCNL DCSP DCSP for f in json _ funcs : DCNL DCSP DCSP DCSP pos = logical _ line.find ( ( &apos; json . % s &apos; % f ) ) DCNL DCSP DCSP DCSP if ( pos ! = ( -1 ) ) : DCNL DCSP DCSP DCSP DCSP ( yield ( pos , ( msg % { &apos; fun &apos; : f &#91; : ( -1 ) &#93; } ) ) )
DCSP LOG.debug ( _ ( &apos; get _ all _ vlanids ( ) DCSP called &apos; ) ) DCNL DCSP session = db.get _ session ( ) DCNL DCSP try : DCNL DCSP DCSP vlanids = session.query ( network _ models _ v2.VlanID ) .all ( ) DCNL DCSP DCSP return vlanids DCNL DCSP except exc.NoResultFound : DCNL DCSP DCSP return &#91; &#93;
DCSP config _ file = basic _ util.strip _ path ( config _ file ) DCNL DCSP for changeset in reversed _ upper _ bounded _ changelog ( repo , ctx ) : DCNL DCSP DCSP changeset _ ctx = repo.changectx ( changeset ) DCNL DCSP DCSP for ctx _ file in changeset _ ctx.files ( ) : DCNL DCSP DCSP DCSP ctx _ file _ name = basic _ util.strip _ path ( ctx _ file ) DCNL DCSP DCSP DCSP if ( ctx _ file _ name = = config _ file ) : DCNL DCSP DCSP DCSP DCSP return get _ named _ tmpfile _ from _ ctx ( changeset _ ctx , ctx _ file , dir ) DCNL DCSP return None
DCSP log.msg ( &apos; stop &apos; ) DCNL DCSP if GlobalObject ( ) .stophandler : DCNL DCSP DCSP GlobalObject ( ) .stophandler ( ) DCNL DCSP reactor.callLater ( 0.5 , reactor.stop ) DCNL DCSP return True
DCSP b0 = safe _ ord ( rlp &#91; start &#93; ) DCNL DCSP if ( b0 &lt; 128 ) : DCNL DCSP DCSP return ( str , 1 , start ) DCNL DCSP elif ( b0 &lt; ( 128 + 56 ) ) : DCNL DCSP DCSP return ( str , ( b0 - 128 ) , ( start + 1 ) ) DCNL DCSP elif ( b0 &lt; 192 ) : DCNL DCSP DCSP ll = ( ( ( b0 - 128 ) - 56 ) + 1 ) DCNL DCSP DCSP l = big _ endian _ to _ int ( rlp &#91; ( start + 1 ) : ( ( start + 1 ) + ll ) &#93; ) DCNL DCSP DCSP return ( str , l , ( ( start + 1 ) + ll ) ) DCNL DCSP elif ( b0 &lt; ( 192 + 56 ) ) : DCNL DCSP DCSP return ( list , ( b0 - 192 ) , ( start + 1 ) ) DCNL DCSP else : DCNL DCSP DCSP ll = ( ( ( b0 - 192 ) - 56 ) + 1 ) DCNL DCSP DCSP l = big _ endian _ to _ int ( rlp &#91; ( start + 1 ) : ( ( start + 1 ) + ll ) &#93; ) DCNL DCSP DCSP return ( list , l , ( ( start + 1 ) + ll ) )
DCSP addCageGroove ( derivation , negatives , positives ) DCNL DCSP for pegCenterX in derivation.pegCenterXs : DCNL DCSP DCSP addPositivePeg ( derivation , positives , pegCenterX , ( - derivation.pegY ) ) DCNL DCSP DCSP addPositivePeg ( derivation , positives , pegCenterX , derivation.pegY ) DCNL DCSP translate.translateNegativesPositives ( negatives , positives , Vector3 ( 0.0 , ( - derivation.halfSeparationWidth ) ) ) DCNL DCSP femaleNegatives = &#91; &#93; DCNL DCSP femalePositives = &#91; &#93; DCNL DCSP addCageGroove ( derivation , femaleNegatives , femalePositives ) DCNL DCSP for pegCenterX in derivation.pegCenterXs : DCNL DCSP DCSP addNegativePeg ( derivation , femaleNegatives , pegCenterX , ( - derivation.pegY ) ) DCNL DCSP DCSP addNegativePeg ( derivation , femaleNegatives , pegCenterX , derivation.pegY ) DCNL DCSP translate.translateNegativesPositives ( femaleNegatives , femalePositives , Vector3 ( 0.0 , derivation.halfSeparationWidth ) ) DCNL DCSP negatives + = femaleNegatives DCNL DCSP positives + = femalePositives
DCSP order = get _ object _ or _ 404 ( SaleOrder , pk = order _ id ) DCNL DCSP if ( ( not request.user.profile.has _ permission ( order ) ) and ( not request.user.profile.is _ admin ( &apos; treeio.sales &apos; ) ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Sale &quot; ) DCNL DCSP ordered _ products = order.orderedproduct _ set.filter ( trash = False ) DCNL DCSP try : DCNL DCSP DCSP conf = ModuleSetting.get _ for _ module ( &apos; treeio.finance &apos; , &apos; my _ company &apos; ) &#91; 0 &#93; DCNL DCSP DCSP my _ company = Contact.objects.get ( pk = long ( conf.value ) ) DCNL DCSP except : DCNL DCSP DCSP my _ company = None DCNL DCSP return render _ to _ response ( &apos; sales / order _ invoice _ view &apos; , { &apos; order &apos; : order , &apos; ordered _ products &apos; : ordered _ products , &apos; my _ company &apos; : my _ company } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP return ExportRepository ( )
DCSP return _ underscore _ dict ( json ( body , charset = charset ) )
DCSP ( _ , files _ modified , _ ) = run ( &apos; git DCSP diff-index DCSP --cached DCSP --name-only DCSP HEAD &apos; ) DCNL DCSP options = parse _ options ( ) DCNL DCSP setup _ logger ( options ) DCNL DCSP candidates = list ( map ( str , files _ modified ) ) DCNL DCSP if candidates : DCNL DCSP DCSP process _ paths ( options , candidates = candidates )
DCSP if ( item _ shape is None ) : DCNL DCSP DCSP item _ shape = ( N , ) DCNL DCSP offset = 0 DCNL DCSP mgr _ items = &#91; &#93; DCNL DCSP block _ placements = OrderedDict ( ) DCNL DCSP for d in descr.split ( &apos; ; &apos; ) : DCNL DCSP DCSP d = d.strip ( ) DCNL DCSP DCSP if ( not len ( d ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ( names , blockstr ) = d.partition ( &apos; : &apos; ) &#91; : : 2 &#93; DCNL DCSP DCSP blockstr = blockstr.strip ( ) DCNL DCSP DCSP names = names.strip ( ) .split ( &apos; , &apos; ) DCNL DCSP DCSP mgr _ items.extend ( names ) DCNL DCSP DCSP placement = list ( ( np.arange ( len ( names ) ) + offset ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP block _ placements &#91; blockstr &#93; .extend ( placement ) DCNL DCSP DCSP except KeyError : DCNL DCSP DCSP DCSP block _ placements &#91; blockstr &#93; = placement DCNL DCSP DCSP offset + = len ( names ) DCNL DCSP mgr _ items = Index ( mgr _ items ) DCNL DCSP blocks = &#91; &#93; DCNL DCSP num _ offset = 0 DCNL DCSP for ( blockstr , placement ) in block _ placements.items ( ) : DCNL DCSP DCSP typestr = blockstr.split ( &apos; -&apos; ) &#91; 0 &#93; DCNL DCSP DCSP blocks.append ( create _ block ( typestr , placement , item _ shape = item _ shape , num _ offset = num _ offset ) ) DCNL DCSP DCSP num _ offset + = len ( placement ) DCNL DCSP return BlockManager ( sorted ( blocks , key = ( lambda b : b.mgr _ locs &#91; 0 &#93; ) ) , ( &#91; mgr _ items &#93; + &#91; np.arange ( n ) for n in item _ shape &#93; ) )
DCSP kstone = auth ( profile , * * connection _ args ) DCNL DCSP if name : DCNL DCSP DCSP for role in kstone.roles.list ( ) : DCNL DCSP DCSP DCSP if ( role.name = = name ) : DCNL DCSP DCSP DCSP DCSP role _ id = role.id DCNL DCSP DCSP DCSP DCSP break DCNL DCSP if ( not role _ id ) : DCNL DCSP DCSP return { &apos; Error &apos; : &apos; Unable DCSP to DCSP resolve DCSP role DCSP id &apos; } DCNL DCSP role = kstone.roles.get ( role _ id ) DCNL DCSP kstone.roles.delete ( role ) DCNL DCSP ret = &apos; Role DCSP ID DCSP { 0 } DCSP deleted &apos; .format ( role _ id ) DCNL DCSP if name : DCNL DCSP DCSP ret + = &apos; DCSP ( { 0 } ) &apos; .format ( name ) DCNL DCSP return ret
DCSP eeg _ sel = pick _ types ( info , meg = False , eeg = True , ref _ meg = False , exclude = &apos; bads &apos; ) DCNL DCSP return ( ( len ( eeg _ sel ) &gt; 0 ) and ( not info &#91; &apos; custom _ ref _ applied &apos; &#93; ) and ( not _ has _ eeg _ average _ ref _ proj ( info &#91; &apos; projs &apos; &#93; ) ) )
DCSP DocTags ( dt ) .add ( dn , tag ) DCNL DCSP return tag
DCSP budget _ service = client.GetService ( &apos; BudgetService &apos; , version = &apos; v201609 &apos; ) DCNL DCSP budget = { &apos; name &apos; : ( &apos; Interplanetary DCSP Cruise DCSP App DCSP Budget DCSP # % s &apos; % uuid.uuid4 ( ) ) , &apos; amount &apos; : { &apos; microAmount &apos; : &apos; 50000000 &apos; } , &apos; deliveryMethod &apos; : &apos; STANDARD &apos; , &apos; isExplicitlyShared &apos; : False } DCNL DCSP budget _ operations = &#91; { &apos; operator &apos; : &apos; ADD &apos; , &apos; operand &apos; : budget } &#93; DCNL DCSP budget _ id = budget _ service.mutate ( budget _ operations ) &#91; &apos; value &apos; &#93; &#91; 0 &#93; &#91; &apos; budgetId &apos; &#93; DCNL DCSP return budget _ id
DCSP for ( cls , fields _ list ) in class _ dict.items ( ) : DCNL DCSP DCSP for fields in fields _ list : DCNL DCSP DCSP DCSP ( yield ( cls , fields ) )
DCSP netobj = objects.network.Network ( id = network &#91; &apos; id &apos; &#93; , bridge _ interface = network.get _ meta ( &apos; bridge _ interface &apos; ) , subnets = _ nova _ to _ osvif _ subnets ( network &#91; &apos; subnets &apos; &#93; ) ) DCNL DCSP if ( network &#91; &apos; bridge &apos; &#93; is not None ) : DCNL DCSP DCSP netobj.bridge = network &#91; &apos; bridge &apos; &#93; DCNL DCSP if ( network &#91; &apos; label &apos; &#93; is not None ) : DCNL DCSP DCSP netobj.label = network &#91; &apos; label &apos; &#93; DCNL DCSP if ( network.get _ meta ( &apos; mtu &apos; ) is not None ) : DCNL DCSP DCSP netobj.mtu = network.get _ meta ( &apos; mtu &apos; ) DCNL DCSP if ( network.get _ meta ( &apos; multi _ host &apos; ) is not None ) : DCNL DCSP DCSP netobj.multi _ host = network.get _ meta ( &apos; multi _ host &apos; ) DCNL DCSP if ( network.get _ meta ( &apos; should _ create _ bridge &apos; ) is not None ) : DCNL DCSP DCSP netobj.should _ provide _ bridge = network.get _ meta ( &apos; should _ create _ bridge &apos; ) DCNL DCSP if ( network.get _ meta ( &apos; should _ create _ vlan &apos; ) is not None ) : DCNL DCSP DCSP netobj.should _ provide _ vlan = network.get _ meta ( &apos; should _ create _ vlan &apos; ) DCNL DCSP DCSP if ( network.get _ meta ( &apos; vlan &apos; ) is None ) : DCNL DCSP DCSP DCSP raise exception.NovaException ( ( _ ( &apos; Missing DCSP vlan DCSP number DCSP in DCSP % s &apos; ) % network ) ) DCNL DCSP DCSP netobj.vlan = network.get _ meta ( &apos; vlan &apos; ) DCNL DCSP return netobj
DCSP ndim = tensor _ var.ndim DCNL DCSP if ( norm _ axes is not None ) : DCNL DCSP DCSP sum _ over = tuple ( norm _ axes ) DCNL DCSP elif ( ndim = = 2 ) : DCNL DCSP DCSP sum _ over = ( 0 , ) DCNL DCSP elif ( ndim in &#91; 3 , 4 , 5 &#93; ) : DCNL DCSP DCSP sum _ over = tuple ( range ( 1 , ndim ) ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( &apos; Unsupported DCSP tensor DCSP dimensionality DCSP { } .Must DCSP specify DCSP `norm _ axes` &apos; .format ( ndim ) ) DCNL DCSP dtype = np.dtype ( theano.config.floatX ) .type DCNL DCSP norms = T.sqrt ( T.sum ( T.sqr ( tensor _ var ) , axis = sum _ over , keepdims = True ) ) DCNL DCSP target _ norms = T.clip ( norms , 0 , dtype ( max _ norm ) ) DCNL DCSP constrained _ output = ( tensor _ var * ( target _ norms / ( dtype ( epsilon ) + norms ) ) ) DCNL DCSP return constrained _ output
DCSP if ( call ! = &apos; function &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP delete _ disk DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function . &apos; ) DCNL DCSP if ( ( not kwargs ) or ( &apos; disk _ name &apos; not in kwargs ) ) : DCNL DCSP DCSP log.error ( &apos; A DCSP disk _ name DCSP must DCSP be DCSP specified DCSP when DCSP deleting DCSP a DCSP disk . &apos; ) DCNL DCSP DCSP return False DCNL DCSP conn = get _ conn ( ) DCNL DCSP disk = conn.ex _ get _ volume ( kwargs.get ( &apos; disk _ name &apos; ) ) DCNL DCSP _ _ utils _ _ &#91; &apos; cloud.fire _ event &apos; &#93; ( &apos; event &apos; , &apos; delete DCSP disk &apos; , &apos; salt / cloud / disk / deleting &apos; , args = { &apos; name &apos; : disk.name , &apos; location &apos; : disk.extra &#91; &apos; zone &apos; &#93; .name , &apos; size &apos; : disk.size } , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; ) DCNL DCSP try : DCNL DCSP DCSP result = conn.destroy _ volume ( disk ) DCNL DCSP except ResourceInUseError as exc : DCNL DCSP DCSP log.error ( &apos; Disk DCSP { 0 } DCSP is DCSP in DCSP use DCSP and DCSP must DCSP be DCSP detached DCSP before DCSP deleting . \ nThe DCSP following DCSP exception DCSP was DCSP thrown DCSP by DCSP libcloud : \ n { 1 } &apos; .format ( disk.name , exc ) , exc _ info _ on _ loglevel = logging.DEBUG ) DCNL DCSP DCSP return False DCNL DCSP _ _ utils _ _ &#91; &apos; cloud.fire _ event &apos; &#93; ( &apos; event &apos; , &apos; deleted DCSP disk &apos; , &apos; salt / cloud / disk / deleted &apos; , args = { &apos; name &apos; : disk.name , &apos; location &apos; : disk.extra &#91; &apos; zone &apos; &#93; .name , &apos; size &apos; : disk.size } , sock _ dir = _ _ opts _ _ &#91; &apos; sock _ dir &apos; &#93; , transport = _ _ opts _ _ &#91; &apos; transport &apos; &#93; ) DCNL DCSP return result
DCSP wxapp = wx.GetApp ( ) DCNL DCSP if ( wxapp is None ) : DCNL DCSP DCSP wxapp = wx.PySimpleApp ( ) DCNL DCSP DCSP wxapp.SetExitOnFrameDelete ( True ) DCNL DCSP DCSP _ create _ wx _ app.theWxApp = wxapp
DCSP found = False DCNL DCSP f = open ( filename , &apos; rt &apos; ) DCNL DCSP for line in iter ( f.readline , &apos; &apos; ) : DCNL DCSP DCSP parts = line.split ( ) DCNL DCSP DCSP if ( len ( parts ) = = 2 ) : DCNL DCSP DCSP DCSP ( kind , length ) = parts DCNL DCSP DCSP DCSP data = f.read ( int ( length ) ) DCNL DCSP DCSP DCSP if ( ( kind = = &apos; K &apos; ) and ( data = = &apos; svn : externals &apos; ) ) : DCNL DCSP DCSP DCSP DCSP found = True DCNL DCSP DCSP DCSP elif ( ( kind = = &apos; V &apos; ) and found ) : DCNL DCSP DCSP DCSP DCSP f.close ( ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP else : DCNL DCSP DCSP f.close ( ) DCNL DCSP DCSP return DCNL DCSP for line in data.splitlines ( ) : DCNL DCSP DCSP parts = line.split ( ) DCNL DCSP DCSP if parts : DCNL DCSP DCSP DCSP ( yield joinpath ( dirname , parts &#91; 0 &#93; ) )
DCSP try : DCNL DCSP DCSP closable.close ( ) DCNL DCSP except Exception : DCNL DCSP DCSP logger.debug ( u &apos;Exception DCSP while DCSP closing &apos; , exc _ info = True )
DCSP assert ( len ( roidb ) &gt; 0 ) DCNL DCSP assert ( &apos; max _ classes &apos; in roidb &#91; 0 &#93; ) , &apos; Did DCSP you DCSP call DCSP prepare _ roidb DCSP first ? &apos; DCNL DCSP num _ images = len ( roidb ) DCNL DCSP num _ classes = roidb &#91; 0 &#93; &#91; &apos; gt _ overlaps &apos; &#93; .shape &#91; 1 &#93; DCNL DCSP for im _ i in xrange ( num _ images ) : DCNL DCSP DCSP rois = roidb &#91; im _ i &#93; &#91; &apos; boxes &apos; &#93; DCNL DCSP DCSP max _ overlaps = roidb &#91; im _ i &#93; &#91; &apos; max _ overlaps &apos; &#93; DCNL DCSP DCSP max _ classes = roidb &#91; im _ i &#93; &#91; &apos; max _ classes &apos; &#93; DCNL DCSP DCSP roidb &#91; im _ i &#93; &#91; &apos; bbox _ targets &apos; &#93; = _ compute _ targets ( rois , max _ overlaps , max _ classes ) DCNL DCSP if cfg.TRAIN.BBOX _ NORMALIZE _ TARGETS _ PRECOMPUTED : DCNL DCSP DCSP means = np.tile ( np.array ( cfg.TRAIN.BBOX _ NORMALIZE _ MEANS ) , ( num _ classes , 1 ) ) DCNL DCSP DCSP stds = np.tile ( np.array ( cfg.TRAIN.BBOX _ NORMALIZE _ STDS ) , ( num _ classes , 1 ) ) DCNL DCSP else : DCNL DCSP DCSP class _ counts = ( np.zeros ( ( num _ classes , 1 ) ) + cfg.EPS ) DCNL DCSP DCSP sums = np.zeros ( ( num _ classes , 4 ) ) DCNL DCSP DCSP squared _ sums = np.zeros ( ( num _ classes , 4 ) ) DCNL DCSP DCSP for im _ i in xrange ( num _ images ) : DCNL DCSP DCSP DCSP targets = roidb &#91; im _ i &#93; &#91; &apos; bbox _ targets &apos; &#93; DCNL DCSP DCSP DCSP for cls in xrange ( 1 , num _ classes ) : DCNL DCSP DCSP DCSP DCSP cls _ inds = np.where ( ( targets &#91; : , 0 &#93; = = cls ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP if ( cls _ inds.size &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP class _ counts &#91; cls &#93; + = cls _ inds.size DCNL DCSP DCSP DCSP DCSP DCSP sums &#91; cls , : &#93; + = targets &#91; cls _ inds , 1 : &#93; .sum ( axis = 0 ) DCNL DCSP DCSP DCSP DCSP DCSP squared _ sums &#91; cls , : &#93; + = ( targets &#91; cls _ inds , 1 : &#93; * * 2 ) .sum ( axis = 0 ) DCNL DCSP DCSP means = ( sums / class _ counts ) DCNL DCSP DCSP stds = np.sqrt ( ( ( squared _ sums / class _ counts ) - ( means * * 2 ) ) ) DCNL DCSP print &apos; bbox DCSP target DCSP means : &apos; DCNL DCSP print means DCNL DCSP print means &#91; 1 : , : &#93; .mean ( axis = 0 ) DCNL DCSP print &apos; bbox DCSP target DCSP stdevs : &apos; DCNL DCSP print stds DCNL DCSP print stds &#91; 1 : , : &#93; .mean ( axis = 0 ) DCNL DCSP if cfg.TRAIN.BBOX _ NORMALIZE _ TARGETS : DCNL DCSP DCSP print &apos; Normalizing DCSP targets &apos; DCNL DCSP DCSP for im _ i in xrange ( num _ images ) : DCNL DCSP DCSP DCSP targets = roidb &#91; im _ i &#93; &#91; &apos; bbox _ targets &apos; &#93; DCNL DCSP DCSP DCSP for cls in xrange ( 1 , num _ classes ) : DCNL DCSP DCSP DCSP DCSP cls _ inds = np.where ( ( targets &#91; : , 0 &#93; = = cls ) ) &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP roidb &#91; im _ i &#93; &#91; &apos; bbox _ targets &apos; &#93; &#91; cls _ inds , 1 : &#93; - = means &#91; cls , : &#93; DCNL DCSP DCSP DCSP DCSP roidb &#91; im _ i &#93; &#91; &apos; bbox _ targets &apos; &#93; &#91; cls _ inds , 1 : &#93; / = stds &#91; cls , : &#93; DCNL DCSP else : DCNL DCSP DCSP print &apos; NOT DCSP normalizing DCSP targets &apos; DCNL DCSP return ( means.ravel ( ) , stds.ravel ( ) )
DCSP with settings ( warn _ only = True ) : DCNL DCSP DCSP res = run ( ( &apos; pkg _ info DCSP -e DCSP % s &apos; % pkg _ name ) ) DCNL DCSP DCSP return ( res.succeeded is True )
DCSP n = b.size DCNL DCSP assert ( A.n = = n ) DCNL DCSP assert ( A.m = = n ) DCNL DCSP b _ norm = np.linalg.norm ( b ) DCNL DCSP kvec = A.diag DCNL DCSP kvec = np.where ( ( kvec &gt; 1e-06 ) , kvec , 1e-06 ) DCNL DCSP if ( x0 is None ) : DCNL DCSP DCSP x = np.zeros ( n ) DCNL DCSP else : DCNL DCSP DCSP x = x0 DCNL DCSP r = ( b - A.dot ( x ) ) DCNL DCSP w = ( r / kvec ) DCNL DCSP p = np.zeros ( n ) DCNL DCSP beta = 0.0 DCNL DCSP rho = np.dot ( r , w ) DCNL DCSP k = 0 DCNL DCSP while ( ( np.sqrt ( abs ( rho ) ) &gt; ( tol * b _ norm ) ) and ( k &lt; maxiter ) ) : DCNL DCSP DCSP p = ( w + ( beta * p ) ) DCNL DCSP DCSP z = A.dot ( p ) DCNL DCSP DCSP alpha = ( rho / np.dot ( p , z ) ) DCNL DCSP DCSP r = ( r - ( alpha * z ) ) DCNL DCSP DCSP w = ( r / kvec ) DCNL DCSP DCSP rhoold = rho DCNL DCSP DCSP rho = np.dot ( r , w ) DCNL DCSP DCSP x = ( x + ( alpha * p ) ) DCNL DCSP DCSP beta = ( rho / rhoold ) DCNL DCSP DCSP k + = 1 DCNL DCSP err = np.linalg.norm ( ( A.dot ( x ) - b ) ) DCNL DCSP return ( x , err )
DCSP if ( not G.has _ edge ( * edge ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Edge DCSP { 0 } DCSP does DCSP not DCSP exist DCSP in DCSP graph DCSP G ; DCSP cannot DCSP contract DCSP it &apos; .format ( edge ) ) DCNL DCSP return contracted _ nodes ( G , self _ loops = self _ loops , * edge )
DCSP script.pip ( &apos; install &apos; , &apos; --compile &apos; , &apos; simple.dist = = 0.1 &apos; , &apos; --no-index &apos; , ( &apos; --find-links = &apos; + data.find _ links ) ) DCNL DCSP exists = &#91; os.path.exists ( ( script.site _ packages _ path / &apos; simpledist / _ _ init _ _ .pyc &apos; ) ) &#93; DCNL DCSP exists + = glob.glob ( ( script.site _ packages _ path / &apos; simpledist / _ _ pycache _ _ / _ _ init _ _ * .pyc &apos; ) ) DCNL DCSP assert any ( exists )
DCSP n = ( n / np.sqrt ( np.square ( n ) .sum ( axis = ( -1 ) ) ) ) DCNL DCSP if ( abs ( n &#91; 0 &#93; ) = = 1 ) : DCNL DCSP DCSP l = np.r _ &#91; ( n &#91; 2 &#93; , 0 , ( - n &#91; 0 &#93; ) ) &#93; DCNL DCSP else : DCNL DCSP DCSP l = np.r _ &#91; ( 0 , n &#91; 2 &#93; , ( - n &#91; 1 &#93; ) ) &#93; DCNL DCSP l = ( l / np.sqrt ( np.square ( l ) .sum ( axis = ( -1 ) ) ) ) DCNL DCSP m = np.cross ( n , l ) DCNL DCSP return ( n , l , m )
DCSP return Date ( * time.localtime ( ticks ) &#91; : 3 &#93; )
DCSP return IMPL.instance _ tag _ delete _ all ( context , instance _ uuid )
DCSP try : DCNL DCSP DCSP parser _ cache _ item = parser _ cache &#91; path &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP pass DCNL DCSP else : DCNL DCSP DCSP _ invalidate _ star _ import _ cache _ module ( parser _ cache _ item.parser.module )
DCSP fp = TraceFuncCoverage ( fn ) DCNL DCSP def new _ fn ( * args , * * kw ) : DCNL DCSP DCSP return fp ( * args , * * kw ) DCNL DCSP new _ fn . _ _ doc _ _ = fn . _ _ doc _ _ DCNL DCSP new _ fn . _ _ name _ _ = fn . _ _ name _ _ DCNL DCSP new _ fn . _ _ dict _ _ = fn . _ _ dict _ _ DCNL DCSP new _ fn . _ _ module _ _ = fn . _ _ module _ _ DCNL DCSP return new _ fn
DCSP sql _ commands = &#91; &apos; CREATE DCSP TABLE DCSP images _ backup DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP id DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP name DCSP VARCHAR ( 255 ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP size DCSP INTEGER , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP status DCSP VARCHAR ( 30 ) DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP is _ public DCSP BOOLEAN DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP location DCSP TEXT , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP created _ at DCSP DATETIME DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP updated _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP disk _ format DCSP VARCHAR ( 20 ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP container _ format DCSP VARCHAR ( 20 ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP checksum DCSP VARCHAR ( 32 ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP owner DCSP VARCHAR ( 255 ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP min _ disk DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP min _ ram DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( id ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP CHECK DCSP ( is _ public DCSP IN DCSP ( 0 , DCSP 1 ) ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP CHECK DCSP ( deleted DCSP IN DCSP ( 0 , DCSP 1 ) ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ) ; &apos; , &apos; INSERT DCSP INTO DCSP images _ backup \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP * DCSP FROM DCSP images ; &apos; , &apos; CREATE DCSP TABLE DCSP image _ members _ backup DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP id DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP image _ id DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP member DCSP VARCHAR ( 255 ) DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP can _ share DCSP BOOLEAN DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP created _ at DCSP DATETIME DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP updated _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( id ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP UNIQUE DCSP ( image _ id , DCSP member ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP CHECK DCSP ( can _ share DCSP IN DCSP ( 0 , DCSP 1 ) ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP CHECK DCSP ( deleted DCSP IN DCSP ( 0 , DCSP 1 ) ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FOREIGN DCSP KEY ( image _ id ) DCSP REFERENCES DCSP images DCSP ( id ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ) ; &apos; , &apos; INSERT DCSP INTO DCSP image _ members _ backup \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP * DCSP FROM DCSP image _ members ; &apos; , &apos; CREATE DCSP TABLE DCSP image _ properties _ backup DCSP ( \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP id DCSP INTEGER DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP image _ id DCSP INTEGER DCSP DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP name DCSP VARCHAR ( 255 ) DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP value DCSP TEXT , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP created _ at DCSP DATETIME DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP updated _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted _ at DCSP DATETIME , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP PRIMARY DCSP KEY DCSP ( id ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP CHECK DCSP ( deleted DCSP IN DCSP ( 0 , DCSP 1 ) ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP UNIQUE DCSP ( image _ id , DCSP name ) , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP FOREIGN DCSP KEY ( image _ id ) DCSP REFERENCES DCSP images DCSP ( id ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ) ; &apos; , &apos; INSERT DCSP INTO DCSP image _ properties _ backup \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP SELECT DCSP * DCSP FROM DCSP image _ properties ; &apos; &#93; DCNL DCSP for command in sql _ commands : DCNL DCSP DCSP meta.bind.execute ( command ) DCNL DCSP _ sqlite _ table _ swap ( t _ image _ members , t _ image _ properties , t _ images )
DCSP print &apos; TODO&apos;
DCSP if ( not date ) : DCNL DCSP DCSP return u &apos; &apos; DCNL DCSP right _ now = now ( ) DCNL DCSP today = datetime ( right _ now.year , right _ now.month , right _ now.day , tzinfo = right _ now.tzinfo ) DCNL DCSP delta = ( right _ now - date ) DCNL DCSP delta _ midnight = ( today - date ) DCNL DCSP days = delta.days DCNL DCSP hours = ( delta.seconds / / 3600 ) DCNL DCSP minutes = ( delta.seconds / / 60 ) DCNL DCSP seconds = delta.seconds DCNL DCSP if ( days &lt; 0 ) : DCNL DCSP DCSP return _ ( u &apos;just DCSP now &apos; ) DCNL DCSP if ( days = = 0 ) : DCNL DCSP DCSP if ( hours = = 0 ) : DCNL DCSP DCSP DCSP if ( minutes &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP return ungettext ( _ ( u &apos; { minutes } DCSP minute DCSP ago &apos; ) , _ ( u &apos; { minutes } DCSP minutes DCSP ago &apos; ) , minutes ) .format ( minutes = minutes ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP if ( include _ seconds and seconds ) : DCNL DCSP DCSP DCSP DCSP DCSP return ungettext ( _ ( u &apos; { seconds } DCSP second DCSP ago &apos; ) , _ ( u &apos; { seconds } DCSP seconds DCSP ago &apos; ) , seconds ) .format ( seconds = seconds ) DCNL DCSP DCSP DCSP DCSP return _ ( u &apos;just DCSP now &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ungettext ( _ ( u &apos; { hours } DCSP hour DCSP ago &apos; ) , _ ( u &apos; { hours } DCSP hours DCSP ago &apos; ) , hours ) .format ( hours = hours ) DCNL DCSP if ( delta _ midnight.days = = 0 ) : DCNL DCSP DCSP return _ ( u &apos;yesterday DCSP at DCSP { time } &apos; ) .format ( time = date.strftime ( u &apos; % H : % M &apos; ) ) DCNL DCSP count = 0 DCNL DCSP for ( chunk , pluralizefun ) in OLDER _ CHUNKS : DCNL DCSP DCSP if ( days &gt; = chunk ) : DCNL DCSP DCSP DCSP count = int ( round ( ( ( delta _ midnight.days + 1 ) / chunk ) , 0 ) ) DCNL DCSP DCSP DCSP fmt = pluralizefun ( count ) DCNL DCSP DCSP DCSP return fmt.format ( num = count )
DCSP output _ dict = { } DCNL DCSP for ( module _ name , module ) in module _ dict.iteritems ( ) : DCNL DCSP DCSP if ( module is None ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if IsEncodingsModule ( module _ name ) : DCNL DCSP DCSP DCSP output _ dict &#91; module _ name &#93; = module DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP shared _ prefix = ModuleNameHasPrefix ( module _ name , SHARED _ MODULE _ PREFIXES ) DCNL DCSP DCSP banned _ prefix = ModuleNameHasPrefix ( module _ name , NOT _ SHARED _ MODULE _ PREFIXES ) DCNL DCSP DCSP if ( shared _ prefix and ( not banned _ prefix ) ) : DCNL DCSP DCSP DCSP output _ dict &#91; module _ name &#93; = module DCNL DCSP return output _ dict
DCSP path ( &apos; build &apos; ) .rmtree ( ) DCNL DCSP path ( &apos; dist &apos; ) .rmtree ( )
DCSP ratio = ( 1.0 / 10000.0 ) DCNL DCSP ada = ADASYN ( ratio = ratio , random _ state = RND _ SEED ) DCNL DCSP assert _ raises ( RuntimeError , ada.fit , X , Y )
DCSP @ custom _ model DCNL DCSP def model _ a ( x , a = 1 ) : DCNL DCSP DCSP return ( x * a ) DCNL DCSP class model _ b ( model _ a , ) : DCNL DCSP DCSP @ classmethod DCNL DCSP DCSP def evaluate ( cls , x , a ) : DCNL DCSP DCSP DCSP return ( - super ( model _ b , cls ) .evaluate ( x , a ) ) DCNL DCSP b = model _ b ( ) DCNL DCSP assert ( b.param _ names = = ( u &apos;a &apos; , ) ) DCNL DCSP assert ( b.a = = 1 ) DCNL DCSP assert ( b ( 1 ) = = ( -1 ) ) DCNL DCSP sig = signature ( model _ b . _ _ init _ _ ) DCNL DCSP assert ( list ( sig.parameters.keys ( ) ) = = &#91; u &apos;self &apos; , u &apos;a &apos; , u &apos;kwargs &apos; &#93; ) DCNL DCSP sig = signature ( model _ b . _ _ call _ _ ) DCNL DCSP assert ( list ( sig.parameters.keys ( ) ) = = &#91; u &apos;self &apos; , u &apos;x &apos; , u &apos;model _ set _ axis &apos; &#93; )
DCSP counter = 0 DCNL DCSP for i in range ( len ( string ) ) : DCNL DCSP DCSP if ( ( ord ( string &#91; i &#93; ) &lt; = 31 ) or ( ord ( string &#91; i &#93; ) &gt; 127 ) ) : DCNL DCSP DCSP DCSP counter + = 1 DCNL DCSP return counter
DCSP if isinstance ( video , Episode ) : DCNL DCSP DCSP return episode _ scores DCNL DCSP elif isinstance ( video , Movie ) : DCNL DCSP DCSP return movie _ scores DCNL DCSP raise ValueError ( &apos; video DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP Episode DCSP or DCSP Movie &apos; )
DCSP try : DCNL DCSP DCSP psutil.Process ( pid ) .send _ signal ( signal ) DCNL DCSP DCSP return True DCNL DCSP except psutil.NoSuchProcess : DCNL DCSP DCSP return False
DCSP text = text.replace ( &apos; \ \ &apos; , &apos; \ \ \ \ &apos; ) DCNL DCSP text = text.replace ( &apos; &quot; &quot; &quot; &apos; , &apos; &quot; &quot; \ \ &quot; &apos; ) DCNL DCSP text = text.replace ( &apos; DCSP \ n &apos; , &apos; DCSP \ \ n \ \ \ n &apos; ) DCNL DCSP return text
DCSP try : DCNL DCSP DCSP int ( value ) DCNL DCSP except : DCNL DCSP DCSP raise ValueError ( &apos; expected DCSP an DCSP integer DCSP value &apos; ) DCNL DCSP content = str ( value ) DCNL DCSP while ( len ( content ) &lt; length ) : DCNL DCSP DCSP content = ( &apos; 0&apos; + content ) DCNL DCSP return content
DCSP if check _ required : DCNL DCSP DCSP for key in api _ model : DCNL DCSP DCSP DCSP if ( api _ model &#91; key &#93; .required and ( key not in payload ) ) : DCNL DCSP DCSP DCSP DCSP raise ValidationError ( field = key , message = &quot; Required DCSP field DCSP &apos; { } &apos; DCSP missing &quot; .format ( key ) ) DCNL DCSP for key in payload : DCNL DCSP DCSP field = api _ model &#91; key &#93; DCNL DCSP DCSP if isinstance ( field , fields.List ) : DCNL DCSP DCSP DCSP field = field.container DCNL DCSP DCSP DCSP data = payload &#91; key &#93; DCNL DCSP DCSP elif isinstance ( field , fields.Nested ) : DCNL DCSP DCSP DCSP if payload &#91; key &#93; : DCNL DCSP DCSP DCSP DCSP validate _ payload ( payload &#91; key &#93; , field.model ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP data = &#91; payload &#91; key &#93; &#93; DCNL DCSP DCSP if ( isinstance ( field , CustomField ) and hasattr ( field , &apos; validate &apos; ) ) : DCNL DCSP DCSP DCSP field.payload = payload DCNL DCSP DCSP DCSP for i in data : DCNL DCSP DCSP DCSP DCSP if ( not field.validate ( i ) ) : DCNL DCSP DCSP DCSP DCSP DCSP raise ValidationError ( field = key , message = ( field.validation _ error % ( &quot; &apos; % s &apos; &quot; % key ) ) )
DCSP if ( ( item.name is None ) or ( item.name = = &apos; &apos; ) ) : DCNL DCSP DCSP raise exceptions.RuntimeError ( &apos; name DCSP unset DCSP for DCSP item ! &apos; ) DCNL DCSP if ( collection.collection _ type ( ) in &#91; &apos; mgmtclass &apos; &#93; ) : DCNL DCSP DCSP filename = ( &apos; / var / lib / cobbler / collections / % ses / % s &apos; % ( collection.collection _ type ( ) , item.name ) ) DCNL DCSP else : DCNL DCSP DCSP filename = ( &apos; / var / lib / cobbler / collections / % ss / % s &apos; % ( collection.collection _ type ( ) , item.name ) ) DCNL DCSP _ dict = item.to _ dict ( ) DCNL DCSP if capi.CobblerAPI ( ) .settings ( ) .serializer _ pretty _ json : DCNL DCSP DCSP sort _ keys = True DCNL DCSP DCSP indent = 4 DCNL DCSP else : DCNL DCSP DCSP sort _ keys = False DCNL DCSP DCSP indent = None DCNL DCSP filename + = &apos; .json &apos; DCNL DCSP _ dict = item.to _ dict ( ) DCNL DCSP fd = open ( filename , &apos; w + &apos; ) DCNL DCSP data = simplejson.dumps ( _ dict , encoding = &apos; utf-8 &apos; , sort _ keys = sort _ keys , indent = indent ) DCNL DCSP fd.write ( data ) DCNL DCSP fd.close ( )
DCSP if ( not tb ) : DCNL DCSP DCSP tb = sys.exc _ info ( ) &#91; 2 &#93; DCNL DCSP ( filename , lineno , _ context , _ line ) = traceback.extract _ tb ( tb ) &#91; ( -1 ) &#93; DCNL DCSP return ( filename , lineno )
DCSP _ check _ unknown _ options ( unknown _ options ) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return _ all DCNL DCSP x0 = asarray ( x0 ) .flatten ( ) DCNL DCSP if ( maxiter is None ) : DCNL DCSP DCSP maxiter = ( len ( x0 ) * 200 ) DCNL DCSP ( func _ calls , f ) = wrap _ function ( f , args ) DCNL DCSP if ( fprime is None ) : DCNL DCSP DCSP ( grad _ calls , myfprime ) = wrap _ function ( approx _ fprime , ( f , epsilon ) ) DCNL DCSP else : DCNL DCSP DCSP ( grad _ calls , myfprime ) = wrap _ function ( fprime , args ) DCNL DCSP gfk = myfprime ( x0 ) DCNL DCSP k = 0 DCNL DCSP xk = x0 DCNL DCSP old _ fval = f ( xk ) DCNL DCSP old _ old _ fval = ( old _ fval + ( np.linalg.norm ( gfk ) / 2 ) ) DCNL DCSP if retall : DCNL DCSP DCSP allvecs = &#91; xk &#93; DCNL DCSP warnflag = 0 DCNL DCSP pk = ( - gfk ) DCNL DCSP gnorm = vecnorm ( gfk , ord = norm ) DCNL DCSP while ( ( gnorm &gt; gtol ) and ( k &lt; maxiter ) ) : DCNL DCSP DCSP deltak = numpy.dot ( gfk , gfk ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP ( alpha _ k , fc , gc , old _ fval , old _ old _ fval , gfkp1 ) = _ line _ search _ wolfe12 ( f , myfprime , xk , pk , gfk , old _ fval , old _ old _ fval , c2 = 0.4 , amin = 1e-100 , amax = 1e + 100 ) DCNL DCSP DCSP except _ LineSearchError : DCNL DCSP DCSP DCSP warnflag = 2 DCNL DCSP DCSP DCSP break DCNL DCSP DCSP xk = ( xk + ( alpha _ k * pk ) ) DCNL DCSP DCSP if retall : DCNL DCSP DCSP DCSP allvecs.append ( xk ) DCNL DCSP DCSP if ( gfkp1 is None ) : DCNL DCSP DCSP DCSP gfkp1 = myfprime ( xk ) DCNL DCSP DCSP yk = ( gfkp1 - gfk ) DCNL DCSP DCSP beta _ k = max ( 0 , ( numpy.dot ( yk , gfkp1 ) / deltak ) ) DCNL DCSP DCSP pk = ( ( - gfkp1 ) + ( beta _ k * pk ) ) DCNL DCSP DCSP gfk = gfkp1 DCNL DCSP DCSP gnorm = vecnorm ( gfk , ord = norm ) DCNL DCSP DCSP if ( callback is not None ) : DCNL DCSP DCSP DCSP callback ( xk ) DCNL DCSP DCSP k + = 1 DCNL DCSP fval = old _ fval DCNL DCSP if ( warnflag = = 2 ) : DCNL DCSP DCSP msg = _ status _ message &#91; &apos; pr _ loss &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( ( &apos; Warning : DCSP &apos; + msg ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP elif ( k &gt; = maxiter ) : DCNL DCSP DCSP warnflag = 1 DCNL DCSP DCSP msg = _ status _ message &#91; &apos; maxiter &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( ( &apos; Warning : DCSP &apos; + msg ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP else : DCNL DCSP DCSP msg = _ status _ message &#91; &apos; success &apos; &#93; DCNL DCSP DCSP if disp : DCNL DCSP DCSP DCSP print ( msg ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Current DCSP function DCSP value : DCSP % f &apos; % fval ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Iterations : DCSP % d &apos; % k ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Function DCSP evaluations : DCSP % d &apos; % func _ calls &#91; 0 &#93; ) ) DCNL DCSP DCSP DCSP print ( ( &apos; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Gradient DCSP evaluations : DCSP % d &apos; % grad _ calls &#91; 0 &#93; ) ) DCNL DCSP result = OptimizeResult ( fun = fval , jac = gfk , nfev = func _ calls &#91; 0 &#93; , njev = grad _ calls &#91; 0 &#93; , status = warnflag , success = ( warnflag = = 0 ) , message = msg , x = xk , nit = k ) DCNL DCSP if retall : DCNL DCSP DCSP result &#91; &apos; allvecs &apos; &#93; = allvecs DCNL DCSP return result
DCSP return rpc _ utils.prepare _ rows _ as _ nested _ dicts ( models.RecurringRun.query _ objects ( filter _ data ) , ( &apos; job &apos; , &apos; owner &apos; ) )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; } DCNL DCSP grp _ info = _ _ salt _ _ &#91; &apos; group.info &apos; &#93; ( name ) DCNL DCSP if grp _ info : DCNL DCSP DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Group DCSP { 0 } DCSP is DCSP set DCSP for DCSP removal &apos; .format ( name ) DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = _ _ salt _ _ &#91; &apos; group.delete &apos; &#93; ( name ) DCNL DCSP DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { name : &apos; &apos; } DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Removed DCSP group DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP return ret DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Failed DCSP to DCSP remove DCSP group DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP return ret DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Group DCSP not DCSP present &apos; DCNL DCSP DCSP return ret
DCSP global globalRepositoryDialogListTable DCNL DCSP globalRepositoryDialogValues = euclidean.getListTableElements ( globalRepositoryDialogListTable ) DCNL DCSP for globalRepositoryDialogValue in globalRepositoryDialogValues : DCNL DCSP DCSP quitWindow ( globalRepositoryDialogValue.root )
DCSP data = _ get _ values ( profile ) DCNL DCSP return salt.utils.traverse _ dict _ and _ list ( data , key , None )
DCSP return for _ dtypes ( _ make _ all _ dtypes ( no _ float16 , no _ bool ) , name = name )
DCSP map _ dict = { } DCNL DCSP for i in range ( len ( mapping _ data ) ) : DCNL DCSP DCSP sam = mapping _ data &#91; i &#93; DCNL DCSP DCSP map _ dict &#91; sam &#91; 0 &#93; &#93; = { } DCNL DCSP DCSP for j in range ( len ( header ) ) : DCNL DCSP DCSP DCSP if ( j = = 0 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP map _ dict &#91; sam &#91; 0 &#93; &#93; &#91; header &#91; j &#93; &#93; = sam &#91; j &#93; DCNL DCSP return map _ dict
DCSP bits = token.split _ contents ( ) &#91; 1 : &#93; DCNL DCSP if ( len ( bits ) &lt; 1 ) : DCNL DCSP DCSP raise TemplateSyntaxError ( &quot; &apos; firstof &apos; DCSP statement DCSP requires DCSP at DCSP least DCSP one DCSP argument &quot; ) DCNL DCSP return FirstOfNode ( &#91; parser.compile _ filter ( bit ) for bit in bits &#93; )
DCSP scan _ info = get _ scan _ info _ from _ id ( scan _ id ) DCNL DCSP if ( scan _ info is None ) : DCNL DCSP DCSP abort ( 404 , &apos; Scan DCSP not DCSP found &apos; ) DCNL DCSP data = &#91; &#93; DCNL DCSP all _ exceptions = scan _ info.w3af _ core.exception _ handler.get _ all _ exceptions ( ) DCNL DCSP for ( exception _ id , exception _ data ) in enumerate ( all _ exceptions ) : DCNL DCSP DCSP data.append ( exception _ to _ json ( exception _ data , scan _ id , exception _ id ) ) DCNL DCSP return jsonify ( { &apos; items &apos; : data } )
DCSP return ( func ( arg ) .args &#91; 0 &#93; = = ( - arg ) )
DCSP if ( not isinstance ( jid , six.string _ types ) ) : DCNL DCSP DCSP return False DCNL DCSP if ( len ( jid ) ! = 20 ) : DCNL DCSP DCSP return False DCNL DCSP try : DCNL DCSP DCSP int ( jid ) DCNL DCSP DCSP return True DCNL DCSP except ValueError : DCNL DCSP DCSP return False
DCSP ( base , sub , _ ) = typ DCNL DCSP if ( base = = &apos; uint &apos; ) : DCNL DCSP DCSP sub = int ( sub ) DCNL DCSP DCSP if ( not ( ( 0 &lt; sub &lt; = 256 ) and ( ( sub % 8 ) = = 0 ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP unsigned DCSP integer DCSP bit DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP i = decint ( arg , signed = False ) DCNL DCSP DCSP except EncodingError : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP if ( not ( 0 &lt; = i &lt; ( 2 * * sub ) ) ) : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP value _ encoded = int _ to _ big _ endian ( i ) DCNL DCSP DCSP return zpad ( value _ encoded , 32 ) DCNL DCSP if ( base = = &apos; int &apos; ) : DCNL DCSP DCSP sub = int ( sub ) DCNL DCSP DCSP bits = ( sub - 1 ) DCNL DCSP DCSP if ( not ( ( 0 &lt; sub &lt; = 256 ) and ( ( sub % 8 ) = = 0 ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP integer DCSP bit DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP i = decint ( arg , signed = True ) DCNL DCSP DCSP except EncodingError : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP if ( not ( ( - ( 2 * * bits ) ) &lt; = i &lt; ( 2 * * bits ) ) ) : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP value = ( i % ( 2 * * sub ) ) DCNL DCSP DCSP value _ encoded = int _ to _ big _ endian ( value ) DCNL DCSP DCSP return zpad ( value _ encoded , 32 ) DCNL DCSP if ( base = = &apos; bool &apos; ) : DCNL DCSP DCSP if ( arg is True ) : DCNL DCSP DCSP DCSP value _ encoded = int _ to _ big _ endian ( 1 ) DCNL DCSP DCSP elif ( arg is False ) : DCNL DCSP DCSP DCSP value _ encoded = int _ to _ big _ endian ( 0 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; % r DCSP is DCSP not DCSP bool &apos; % arg ) ) DCNL DCSP DCSP return zpad ( value _ encoded , 32 ) DCNL DCSP if ( base = = &apos; ufixed &apos; ) : DCNL DCSP DCSP sub = str ( sub ) DCNL DCSP DCSP ( high _ str , low _ str ) = sub.split ( &apos; x &apos; ) DCNL DCSP DCSP high = int ( high _ str ) DCNL DCSP DCSP low = int ( low _ str ) DCNL DCSP DCSP if ( not ( ( 0 &lt; ( high + low ) &lt; = 256 ) and ( ( high % 8 ) = = 0 ) and ( ( low % 8 ) = = 0 ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP unsigned DCSP fixed DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP if ( not ( 0 &lt; = arg &lt; ( 2 * * high ) ) ) : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP float _ point = ( arg * ( 2 * * low ) ) DCNL DCSP DCSP fixed _ point = int ( float _ point ) DCNL DCSP DCSP return zpad ( int _ to _ big _ endian ( fixed _ point ) , 32 ) DCNL DCSP if ( base = = &apos; fixed &apos; ) : DCNL DCSP DCSP sub = str ( sub ) DCNL DCSP DCSP ( high _ str , low _ str ) = sub.split ( &apos; x &apos; ) DCNL DCSP DCSP high = int ( high _ str ) DCNL DCSP DCSP low = int ( low _ str ) DCNL DCSP DCSP bits = ( high - 1 ) DCNL DCSP DCSP if ( not ( ( 0 &lt; ( high + low ) &lt; = 256 ) and ( ( high % 8 ) = = 0 ) and ( ( low % 8 ) = = 0 ) ) ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP unsigned DCSP fixed DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP if ( not ( ( - ( 2 * * bits ) ) &lt; = arg &lt; ( 2 * * bits ) ) ) : DCNL DCSP DCSP DCSP raise ValueOutOfBounds ( repr ( arg ) ) DCNL DCSP DCSP float _ point = ( arg * ( 2 * * low ) ) DCNL DCSP DCSP fixed _ point = int ( float _ point ) DCNL DCSP DCSP value = ( fixed _ point % ( 2 * * 256 ) ) DCNL DCSP DCSP return zpad ( int _ to _ big _ endian ( value ) , 32 ) DCNL DCSP if ( base = = &apos; string &apos; ) : DCNL DCSP DCSP if isinstance ( arg , utils.unicode ) : DCNL DCSP DCSP DCSP arg = arg.encode ( &apos; utf8 &apos; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP arg.decode ( &apos; utf8 &apos; ) DCNL DCSP DCSP DCSP except UnicodeDecodeError : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; string DCSP must DCSP be DCSP utf8 DCSP encoded &apos; ) DCNL DCSP DCSP if len ( sub ) : DCNL DCSP DCSP DCSP if ( not ( 0 &lt; = len ( arg ) &lt; = int ( sub ) ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP string DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP DCSP if ( not ( 0 &lt; = int ( sub ) &lt; = 32 ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; invalid DCSP string DCSP length DCSP { } &apos; .format ( sub ) ) DCNL DCSP DCSP DCSP return rzpad ( arg , 32 ) DCNL DCSP DCSP if ( not ( 0 &lt; = len ( arg ) &lt; TT256 ) ) : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Integer DCSP invalid DCSP or DCSP out DCSP of DCSP range : DCSP % r &apos; % arg ) ) DCNL DCSP DCSP length _ encoded = zpad ( int _ to _ big _ endian ( len ( arg ) ) , 32 ) DCNL DCSP DCSP value _ encoded = rzpad ( arg , utils.ceil32 ( len ( arg ) ) ) DCNL DCSP DCSP return ( length _ encoded + value _ encoded ) DCNL DCSP if ( base = = &apos; bytes &apos; ) : DCNL DCSP DCSP if ( not is _ string ( arg ) ) : DCNL DCSP DCSP DCSP raise EncodingError ( ( &apos; Expecting DCSP string : DCSP % r &apos; % arg ) ) DCNL DCSP DCSP arg = utils.to _ string ( arg ) DCNL DCSP DCSP if len ( sub ) : DCNL DCSP DCSP DCSP if ( not ( 0 &lt; = len ( arg ) &lt; = int ( sub ) ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; string DCSP must DCSP be DCSP utf8 DCSP encoded &apos; ) DCNL DCSP DCSP DCSP if ( not ( 0 &lt; = int ( sub ) &lt; = 32 ) ) : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; string DCSP must DCSP be DCSP utf8 DCSP encoded &apos; ) DCNL DCSP DCSP DCSP return rzpad ( arg , 32 ) DCNL DCSP DCSP if ( not ( 0 &lt; = len ( arg ) &lt; TT256 ) ) : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Integer DCSP invalid DCSP or DCSP out DCSP of DCSP range : DCSP % r &apos; % arg ) ) DCNL DCSP DCSP length _ encoded = zpad ( int _ to _ big _ endian ( len ( arg ) ) , 32 ) DCNL DCSP DCSP value _ encoded = rzpad ( arg , utils.ceil32 ( len ( arg ) ) ) DCNL DCSP DCSP return ( length _ encoded + value _ encoded ) DCNL DCSP if ( base = = &apos; hash &apos; ) : DCNL DCSP DCSP if ( not ( int ( sub ) and ( int ( sub ) &lt; = 32 ) ) ) : DCNL DCSP DCSP DCSP raise EncodingError ( ( &apos; too DCSP long : DCSP % r &apos; % arg ) ) DCNL DCSP DCSP if isnumeric ( arg ) : DCNL DCSP DCSP DCSP return zpad ( encode _ int ( arg ) , 32 ) DCNL DCSP DCSP if ( len ( arg ) = = int ( sub ) ) : DCNL DCSP DCSP DCSP return zpad ( arg , 32 ) DCNL DCSP DCSP if ( len ( arg ) = = ( int ( sub ) * 2 ) ) : DCNL DCSP DCSP DCSP return zpad ( decode _ hex ( arg ) , 32 ) DCNL DCSP DCSP raise EncodingError ( ( &apos; Could DCSP not DCSP parse DCSP hash : DCSP % r &apos; % arg ) ) DCNL DCSP if ( base = = &apos; address &apos; ) : DCNL DCSP DCSP assert ( sub = = &apos; &apos; ) DCNL DCSP DCSP if isnumeric ( arg ) : DCNL DCSP DCSP DCSP return zpad ( encode _ int ( arg ) , 32 ) DCNL DCSP DCSP if ( len ( arg ) = = 20 ) : DCNL DCSP DCSP DCSP return zpad ( arg , 32 ) DCNL DCSP DCSP if ( len ( arg ) = = 40 ) : DCNL DCSP DCSP DCSP return zpad ( decode _ hex ( arg ) , 32 ) DCNL DCSP DCSP if ( ( len ( arg ) = = 42 ) and ( arg &#91; : 2 &#93; = = &apos; 0x &apos; ) ) : DCNL DCSP DCSP DCSP return zpad ( decode _ hex ( arg &#91; 2 : &#93; ) , 32 ) DCNL DCSP DCSP raise EncodingError ( ( &apos; Could DCSP not DCSP parse DCSP address : DCSP % r &apos; % arg ) ) DCNL DCSP raise EncodingError ( ( &apos; Unhandled DCSP type : DCSP % r DCSP % r &apos; % ( base , sub ) ) )
DCSP global shell DCNL DCSP cmds = { } DCNL DCSP for cmdlet in InvokeCommand ( &apos; get-command &apos; ) : DCNL DCSP DCSP cmds &#91; translate ( cmdlet.Name ) &#93; = ShellCommand ( cmdlet.Name ) DCNL DCSP for alias in InvokeCommand ( &apos; get-alias &apos; ) : DCNL DCSP DCSP cmdName = translate ( alias.ReferencedCommand.Name ) DCNL DCSP DCSP if ( cmdName in cmds ) : DCNL DCSP DCSP DCSP cmds &#91; translate ( alias.Name ) &#93; = cmds &#91; cmdName &#93; DCNL DCSP shell = Shell ( cmds ) DCNL DCSP for key in cmds.keys ( ) : DCNL DCSP DCSP setattr ( ShellOutput , key , cmds &#91; key &#93; )
DCSP assert ( hsl _ to _ rgb ( 6120 , 100 , 50 ) = = ( 255 , 0 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( ( -9660 ) , 100 , 50 ) = = ( 255 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 99840 , 100 , 50 ) = = ( 0 , 255 , 0 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( ( -900 ) , 100 , 50 ) = = ( 0 , 255 , 255 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( ( -104880 ) , 100 , 50 ) = = ( 0 , 0 , 255 ) ) DCNL DCSP assert ( hsl _ to _ rgb ( 2820 , 100 , 50 ) = = ( 255 , 0 , 255 ) )
DCSP if ( ( &apos; ORACLE _ HOME &apos; not in os.environ ) and ( &apos; ORACLE _ INSTANTCLIENT _ HOME &apos; not in os.environ ) ) : DCNL DCSP DCSP raise SkipTest DCNL DCSP try : DCNL DCSP DCSP import cx _ Oracle DCNL DCSP DCSP return DCNL DCSP except ImportError as ex : DCNL DCSP DCSP if ( &apos; No DCSP module DCSP named &apos; in ex.message ) : DCNL DCSP DCSP DCSP assert _ true ( False , &apos; cx _ Oracle DCSP skipped DCSP its DCSP build . DCSP This DCSP happens DCSP if DCSP env DCSP var DCSP ORACLE _ HOME DCSP or DCSP ORACLE _ INSTANTCLIENT _ HOME DCSP is DCSP not DCSP defined . DCSP So DCSP ignore DCSP this DCSP test DCSP failure DCSP if DCSP your DCSP build DCSP does DCSP not DCSP need DCSP to DCSP work DCSP with DCSP an DCSP oracle DCSP backend . &apos; )
DCSP try : DCNL DCSP DCSP chan = _ open _ session ( ) DCNL DCSP except ssh.SSHException as err : DCNL DCSP DCSP if ( str ( err ) = = &apos; SSH DCSP session DCSP not DCSP active &apos; ) : DCNL DCSP DCSP DCSP connections &#91; env.host _ string &#93; .close ( ) DCNL DCSP DCSP DCSP del connections &#91; env.host _ string &#93; DCNL DCSP DCSP DCSP chan = _ open _ session ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise DCNL DCSP chan.settimeout ( 0.1 ) DCNL DCSP chan.input _ enabled = True DCNL DCSP return chan
DCSP return int ( ( value * 9525 ) )
DCSP for function in list ( globals ( ) .values ( ) ) : DCNL DCSP DCSP if inspect.isfunction ( function ) : DCNL DCSP DCSP DCSP arguments = inspect.getargspec ( function ) &#91; 0 &#93; DCNL DCSP DCSP DCSP if ( arguments &#91; : 1 &#93; ! = &#91; u &apos;source &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP code = extract _ code _ from _ function ( function ) DCNL DCSP DCSP DCSP if code : DCNL DCSP DCSP DCSP DCSP ( yield ( code , function ) )
DCSP lrf = ( stream if isinstance ( stream , LRFMetaFile ) else LRFMetaFile ( stream ) ) DCNL DCSP authors = string _ to _ authors ( lrf.author ) DCNL DCSP mi = MetaInformation ( lrf.title.strip ( ) , authors ) DCNL DCSP mi.author = lrf.author.strip ( ) DCNL DCSP mi.comments = lrf.free _ text.strip ( ) DCNL DCSP mi.category = ( ( lrf.category.strip ( ) + &apos; , DCSP &apos; ) + lrf.classification.strip ( ) ) DCNL DCSP tags = &#91; x.strip ( ) for x in mi.category.split ( &apos; , &apos; ) if x.strip ( ) &#93; DCNL DCSP if tags : DCNL DCSP DCSP mi.tags = tags DCNL DCSP if ( mi.category.strip ( ) = = &apos; , &apos; ) : DCNL DCSP DCSP mi.category = None DCNL DCSP mi.publisher = lrf.publisher.strip ( ) DCNL DCSP mi.cover _ data = lrf.get _ cover ( ) DCNL DCSP try : DCNL DCSP DCSP mi.title _ sort = lrf.title _ reading.strip ( ) DCNL DCSP DCSP if ( not mi.title _ sort ) : DCNL DCSP DCSP DCSP mi.title _ sort = None DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP try : DCNL DCSP DCSP mi.author _ sort = lrf.author _ reading.strip ( ) DCNL DCSP DCSP if ( not mi.author _ sort ) : DCNL DCSP DCSP DCSP mi.author _ sort = None DCNL DCSP except : DCNL DCSP DCSP pass DCNL DCSP if ( ( not mi.title ) or ( &apos; unknown &apos; in mi.title.lower ( ) ) ) : DCNL DCSP DCSP mi.title = None DCNL DCSP if ( not mi.authors ) : DCNL DCSP DCSP mi.authors = None DCNL DCSP if ( ( not mi.author ) or ( &apos; unknown &apos; in mi.author.lower ( ) ) ) : DCNL DCSP DCSP mi.author = None DCNL DCSP if ( ( not mi.category ) or ( &apos; unknown &apos; in mi.category.lower ( ) ) ) : DCNL DCSP DCSP mi.category = None DCNL DCSP if ( ( not mi.publisher ) or ( &apos; unknown &apos; in mi.publisher.lower ( ) ) or ( &apos; some DCSP publisher &apos; in mi.publisher.lower ( ) ) ) : DCNL DCSP DCSP mi.publisher = None DCNL DCSP return mi
DCSP pre = seq &#91; : phase &#93; DCNL DCSP np _ seq = seq &#91; phase : &#93; DCNL DCSP non _ triplets = ( len ( np _ seq ) % 3 ) DCNL DCSP post = ( &apos; &apos; if ( not non _ triplets ) else np _ seq &#91; ( ( -1 ) * non _ triplets ) : &#93; ) DCNL DCSP intacts = &#91; np _ seq &#91; ( 3 * i ) : ( 3 * ( i + 1 ) ) &#93; for i in range ( ( len ( np _ seq ) / / 3 ) ) &#93; DCNL DCSP return ( pre , intacts , post )
DCSP if ( &apos; : &apos; in classpath ) : DCNL DCSP DCSP ( modname , objname ) = classpath.split ( &apos; : &apos; , 1 ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ _ import _ _ ( modname ) DCNL DCSP DCSP DCSP module = modules &#91; modname &#93; DCNL DCSP DCSP DCSP _ class = eval ( objname , module . _ _ dict _ _ ) DCNL DCSP DCSP DCSP if ( _ class is None ) : DCNL DCSP DCSP DCSP DCSP raise Exception ( ( &apos; eval ( % ( objname ) s ) DCSP in DCSP % ( modname ) s DCSP came DCSP up DCSP None &apos; % locals ( ) ) ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP raise KnownUnknown ( ( &apos; Tried DCSP to DCSP import DCSP % s , DCSP but : DCSP % s &apos; % ( classpath , e ) ) ) DCNL DCSP else : DCNL DCSP DCSP classpath = classpath.split ( &apos; .&apos; ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP module = _ _ import _ _ ( &apos; .&apos;.join ( classpath &#91; : ( -1 ) &#93; ) , fromlist = str ( classpath &#91; ( -1 ) &#93; ) ) DCNL DCSP DCSP except ImportError as e : DCNL DCSP DCSP DCSP raise KnownUnknown ( ( &apos; Tried DCSP to DCSP import DCSP % s , DCSP but : DCSP % s &apos; % ( &apos; .&apos;.join ( classpath ) , e ) ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP _ class = getattr ( module , classpath &#91; ( -1 ) &#93; ) DCNL DCSP DCSP except AttributeError as e : DCNL DCSP DCSP DCSP raise KnownUnknown ( ( &apos; Tried DCSP to DCSP import DCSP % s , DCSP but : DCSP % s &apos; % ( &apos; .&apos;.join ( classpath ) , e ) ) ) DCNL DCSP return _ class
DCSP if opts : DCNL DCSP DCSP key = ( args , frozenset ( opts.items ( ) ) ) DCNL DCSP else : DCNL DCSP DCSP key = args DCNL DCSP cache = func.cache DCNL DCSP try : DCNL DCSP DCSP result = cache &#91; key &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP result = cache &#91; key &#93; = func ( * args , * * opts ) DCNL DCSP return result
DCSP app = get _ app ( ) DCNL DCSP if ( not have _ git ) : DCNL DCSP DCSP session.flash = GIT _ MISSING DCNL DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP dialog = FORM.confirm ( T ( &apos; Pull &apos; ) , { T ( &apos; Cancel &apos; ) : URL ( &apos; site &apos; ) } ) DCNL DCSP if dialog.accepted : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP repo = git.Repo ( os.path.join ( apath ( r = request ) , app ) ) DCNL DCSP DCSP DCSP origin = repo.remotes.origin DCNL DCSP DCSP DCSP origin.fetch ( ) DCNL DCSP DCSP DCSP origin.pull ( ) DCNL DCSP DCSP DCSP session.flash = T ( &apos; Application DCSP updated DCSP via DCSP git DCSP pull &apos; ) DCNL DCSP DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP DCSP except git.CheckoutError : DCNL DCSP DCSP DCSP session.flash = T ( &apos; Pull DCSP failed , DCSP certain DCSP files DCSP could DCSP not DCSP be DCSP checked DCSP out . DCSP Check DCSP logs DCSP for DCSP details . &apos; ) DCNL DCSP DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP DCSP except git.UnmergedEntriesError : DCNL DCSP DCSP DCSP session.flash = T ( &apos; Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmerged DCSP files . DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree , DCSP and DCSP then DCSP try DCSP again . &apos; ) DCNL DCSP DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP DCSP except git.GitCommandError : DCNL DCSP DCSP DCSP session.flash = T ( &apos; Pull DCSP failed , DCSP git DCSP exited DCSP abnormally . DCSP See DCSP logs DCSP for DCSP details . &apos; ) DCNL DCSP DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP DCSP except AssertionError : DCNL DCSP DCSP DCSP session.flash = T ( &apos; Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmerged DCSP files . DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree , DCSP and DCSP then DCSP try DCSP again . &apos; ) DCNL DCSP DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP elif ( &apos; cancel &apos; in request.vars ) : DCNL DCSP DCSP redirect ( URL ( &apos; site &apos; ) ) DCNL DCSP return dict ( app = app , dialog = dialog )
DCSP try : DCNL DCSP DCSP import cssutils DCNL DCSP except ( ImportError , re.error ) : DCNL DCSP DCSP return None DCNL DCSP parser = cssutils.CSSParser ( loglevel = 100 , fetcher = ( lambda url : ( None , &apos; &apos; ) ) , validate = False ) DCNL DCSP if ( not inline ) : DCNL DCSP DCSP sheet = parser.parseString ( data ) DCNL DCSP DCSP return list ( cssutils.getUrls ( sheet ) ) DCNL DCSP else : DCNL DCSP DCSP urls = &#91; &#93; DCNL DCSP DCSP declaration = parser.parseStyle ( data ) DCNL DCSP DCSP for prop in declaration : DCNL DCSP DCSP DCSP for value in prop.propertyValue : DCNL DCSP DCSP DCSP DCSP if isinstance ( value , cssutils.css.URIValue ) : DCNL DCSP DCSP DCSP DCSP DCSP if value.uri : DCNL DCSP DCSP DCSP DCSP DCSP DCSP urls.append ( value.uri ) DCNL DCSP DCSP return urls
DCSP s _ path = None DCNL DCSP path = cfg.script _ dir.get _ path ( ) DCNL DCSP if ( path and script ) : DCNL DCSP DCSP if ( script.lower ( ) not in ( &apos; none &apos; , &apos; default &apos; ) ) : DCNL DCSP DCSP DCSP s _ path = os.path.join ( path , script ) DCNL DCSP DCSP DCSP if ( not os.path.exists ( s _ path ) ) : DCNL DCSP DCSP DCSP DCSP s _ path = None DCNL DCSP return s _ path
DCSP t = Twitter ( auth = authen ( ) ) DCNL DCSP screen _ name = g &#91; &apos; stuff &apos; &#93; .split ( ) &#91; 0 &#93; DCNL DCSP if screen _ name.startswith ( &apos; @ &apos; ) : DCNL DCSP DCSP t.friendships.create ( screen _ name = screen _ name &#91; 1 : &#93; , follow = True ) DCNL DCSP DCSP printNicely ( green ( ( ( &apos; You DCSP are DCSP following DCSP &apos; + screen _ name ) + &apos; DCSP now ! &apos; ) ) ) DCNL DCSP else : DCNL DCSP DCSP printNicely ( red ( &quot; A DCSP name DCSP should DCSP begin DCSP with DCSP a DCSP &apos; @ &apos; &quot; ) )
DCSP not _ found = &#91; &#93; DCNL DCSP for template _ name in template _ name _ list : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP return get _ template ( template _ name ) DCNL DCSP DCSP except TemplateDoesNotExist as e : DCNL DCSP DCSP DCSP if ( e.args &#91; 0 &#93; not in not _ found ) : DCNL DCSP DCSP DCSP DCSP not _ found.append ( e.args &#91; 0 &#93; ) DCNL DCSP DCSP DCSP continue DCNL DCSP raise TemplateDoesNotExist ( &apos; , DCSP &apos; .join ( not _ found ) )
DCSP data _ obj = SAMLProviderData.current ( entity _ id ) DCNL DCSP fetched _ at = datetime.datetime.now ( ) DCNL DCSP if ( data _ obj and ( ( data _ obj.public _ key = = public _ key ) and ( data _ obj.sso _ url = = sso _ url ) ) ) : DCNL DCSP DCSP data _ obj.expires _ at = expires _ at DCNL DCSP DCSP data _ obj.fetched _ at = fetched _ at DCNL DCSP DCSP data _ obj.save ( ) DCNL DCSP DCSP return False DCNL DCSP else : DCNL DCSP DCSP SAMLProviderData.objects.create ( entity _ id = entity _ id , fetched _ at = fetched _ at , expires _ at = expires _ at , sso _ url = sso _ url , public _ key = public _ key ) DCNL DCSP DCSP return True
DCSP km = objc.KextManager ( ) DCNL DCSP cf _ kext _ path = km.PyStringToCFString ( kext _ path ) DCNL DCSP kext _ url = km.dll.CFURLCreateWithFileSystemPath ( objc.CF _ DEFAULT _ ALLOCATOR , cf _ kext _ path , objc.POSIX _ PATH _ STYLE , True ) DCNL DCSP status = km.iokit.KextManagerLoadKextWithURL ( kext _ url , None ) DCNL DCSP km.dll.CFRelease ( kext _ url ) DCNL DCSP km.dll.CFRelease ( cf _ kext _ path ) DCNL DCSP if ( status is not objc.OS _ SUCCESS ) : DCNL DCSP DCSP raise OSError ( &apos; Failed DCSP to DCSP load DCSP kext DCSP at DCSP { 0 } : DCSP { 1 } &apos; .format ( kext _ path , status ) )
DCSP service _ instance = salt.utils.vmware.get _ service _ instance ( host = host , username = username , password = password , protocol = protocol , port = port ) DCNL DCSP return salt.utils.vmware.list _ hosts ( service _ instance )
DCSP cluster _ option = options &#91; &apos; cluster &apos; &#93; DCNL DCSP if cluster _ option : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP cluster = BenchmarkCluster.from _ cluster _ yaml ( FilePath ( cluster _ option ) ) DCNL DCSP DCSP except IOError as e : DCNL DCSP DCSP DCSP usage ( options , &apos; Cluster DCSP file DCSP { ! r } DCSP not DCSP found . &apos; .format ( e.filename ) ) DCNL DCSP else : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP cluster = BenchmarkCluster.from _ acceptance _ test _ env ( env ) DCNL DCSP DCSP except KeyError as e : DCNL DCSP DCSP DCSP usage ( options , &apos; Environment DCSP variable DCSP { ! r } DCSP not DCSP set . &apos; .format ( e.args &#91; 0 &#93; ) ) DCNL DCSP DCSP except ValueError as e : DCNL DCSP DCSP DCSP usage ( options , e.args &#91; 0 &#93; ) DCNL DCSP DCSP except ValidationError as e : DCNL DCSP DCSP DCSP usage ( options , e.message ) DCNL DCSP return cluster
DCSP import SimpleHTTPServer , SocketServer , BaseHTTPServer , urlparse DCNL DCSP import socket , errno DCNL DCSP import traceback DCNL DCSP class WSGIHandler ( SimpleHTTPServer.SimpleHTTPRequestHandler , ) : DCNL DCSP DCSP def run _ wsgi _ app ( self ) : DCNL DCSP DCSP DCSP ( protocol , host , path , parameters , query , fragment ) = urlparse.urlparse ( ( &apos; http : / / dummyhost % s &apos; % self.path ) ) DCNL DCSP DCSP DCSP env = { &apos; wsgi.version &apos; : ( 1 , 0 ) , &apos; wsgi.url _ scheme &apos; : &apos; http &apos; , &apos; wsgi.input &apos; : self.rfile , &apos; wsgi.errors &apos; : sys.stderr , &apos; wsgi.multithread &apos; : 1 , &apos; wsgi.multiprocess &apos; : 0 , &apos; wsgi.run _ once &apos; : 0 , &apos; REQUEST _ METHOD &apos; : self.command , &apos; REQUEST _ URI &apos; : self.path , &apos; PATH _ INFO &apos; : path , &apos; QUERY _ STRING &apos; : query , &apos; CONTENT _ TYPE &apos; : self.headers.get ( &apos; Content-Type &apos; , &apos; &apos; ) , &apos; CONTENT _ LENGTH &apos; : self.headers.get ( &apos; Content-Length &apos; , &apos; &apos; ) , &apos; REMOTE _ ADDR &apos; : self.client _ address &#91; 0 &#93; , &apos; SERVER _ NAME &apos; : self.server.server _ address &#91; 0 &#93; , &apos; SERVER _ PORT &apos; : str ( self.server.server _ address &#91; 1 &#93; ) , &apos; SERVER _ PROTOCOL &apos; : self.request _ version } DCNL DCSP DCSP DCSP for ( http _ header , http _ value ) in self.headers.items ( ) : DCNL DCSP DCSP DCSP DCSP env &#91; ( &apos; HTTP _ % s &apos; % http _ header.replace ( &apos; -&apos; , &apos; _ &apos; ) .upper ( ) ) &#93; = http _ value DCNL DCSP DCSP DCSP self.wsgi _ sent _ headers = 0 DCNL DCSP DCSP DCSP self.wsgi _ headers = &#91; &#93; DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP result = self.server.app ( env , self.wsgi _ start _ response ) DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for data in result : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if data : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP self.wsgi _ write _ data ( data ) DCNL DCSP DCSP DCSP DCSP DCSP finally : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if hasattr ( result , &apos; close &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP result.close ( ) DCNL DCSP DCSP DCSP DCSP except socket.error as socket _ err : DCNL DCSP DCSP DCSP DCSP DCSP if ( socket _ err.args &#91; 0 &#93; in ( errno.ECONNABORTED , errno.EPIPE ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP DCSP except socket.timeout as socket _ timeout : DCNL DCSP DCSP DCSP DCSP DCSP return DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP print &gt; &gt; debug , traceback.format _ exc ( ) , DCNL DCSP DCSP DCSP DCSP internalerror ( ) DCNL DCSP DCSP DCSP DCSP if ( not self.wsgi _ sent _ headers ) : DCNL DCSP DCSP DCSP DCSP DCSP self.wsgi _ start _ response ( ctx.status , ctx.headers ) DCNL DCSP DCSP DCSP DCSP self.wsgi _ write _ data ( ctx.output ) DCNL DCSP DCSP DCSP if ( not self.wsgi _ sent _ headers ) : DCNL DCSP DCSP DCSP DCSP self.wsgi _ write _ data ( &apos; DCSP &apos; ) DCNL DCSP DCSP DCSP return DCNL DCSP DCSP do _ POST = run _ wsgi _ app DCNL DCSP DCSP def do _ GET ( self ) : DCNL DCSP DCSP DCSP if self.path.startswith ( &apos; / static / &apos; ) : DCNL DCSP DCSP DCSP DCSP SimpleHTTPServer.SimpleHTTPRequestHandler.do _ GET ( self ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP self.run _ wsgi _ app ( ) DCNL DCSP DCSP def wsgi _ start _ response ( self , response _ status , response _ headers , exc _ info = None ) : DCNL DCSP DCSP DCSP if self.wsgi _ sent _ headers : DCNL DCSP DCSP DCSP DCSP raise Exception ( &apos; Headers DCSP already DCSP sent DCSP and DCSP start _ response DCSP called DCSP again ! &apos; ) DCNL DCSP DCSP DCSP self.wsgi _ headers = ( response _ status , response _ headers ) DCNL DCSP DCSP DCSP return self.wsgi _ write _ data DCNL DCSP DCSP def wsgi _ write _ data ( self , data ) : DCNL DCSP DCSP DCSP if ( not self.wsgi _ sent _ headers ) : DCNL DCSP DCSP DCSP DCSP ( status , headers ) = self.wsgi _ headers DCNL DCSP DCSP DCSP DCSP status _ code = status &#91; : status.find ( &apos; DCSP &apos; ) &#93; DCNL DCSP DCSP DCSP DCSP status _ msg = status &#91; ( status.find ( &apos; DCSP &apos; ) + 1 ) : &#93; DCNL DCSP DCSP DCSP DCSP self.send _ response ( int ( status _ code ) , status _ msg ) DCNL DCSP DCSP DCSP DCSP for ( header , value ) in headers : DCNL DCSP DCSP DCSP DCSP DCSP self.send _ header ( header , value ) DCNL DCSP DCSP DCSP DCSP self.end _ headers ( ) DCNL DCSP DCSP DCSP DCSP self.wsgi _ sent _ headers = 1 DCNL DCSP DCSP DCSP self.wfile.write ( data ) DCNL DCSP class WSGIServer ( SocketServer.ThreadingMixIn , BaseHTTPServer.HTTPServer , ) : DCNL DCSP DCSP def _ _ init _ _ ( self , func ) : DCNL DCSP DCSP DCSP BaseHTTPServer.HTTPServer. _ _ init _ _ ( self , ( &apos; 0.0.0.0 &apos; , int ( port ) ) , WSGIHandler ) DCNL DCSP DCSP DCSP self.app = func DCNL DCSP DCSP DCSP self.serverShuttingDown = 0 DCNL DCSP print ( ( &apos; Launching DCSP server : DCSP http : / / 0.0.0.0 : &apos; + str ( port ) ) + &apos; / &apos; ) DCNL DCSP WSGIServer ( func ) .serve _ forever ( )
DCSP view.request = request DCNL DCSP try : DCNL DCSP DCSP view.request.user = request.user DCNL DCSP except AttributeError : DCNL DCSP DCSP view.request.user = UserFactory ( ) DCNL DCSP view.args = args DCNL DCSP view.kwargs = kwargs DCNL DCSP view.form = form DCNL DCSP return view
DCSP retVal = value DCNL DCSP if ( retVal and isinstance ( retVal , basestring ) ) : DCNL DCSP DCSP if ( not ( retVal &#91; 0 &#93; = = retVal &#91; ( -1 ) &#93; = = &apos; &quot; &apos; ) ) : DCNL DCSP DCSP DCSP if any ( ( ( _ in retVal ) for _ in ( conf.get ( &apos; csvDel &apos; , defaults.csvDel ) , &apos; &quot; &apos; , &apos; \ n &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP retVal = ( &apos; &quot; % s &quot; &apos; % retVal.replace ( &apos; &quot; &apos; , &apos; &quot; &quot; &apos; ) ) DCNL DCSP return retVal
DCSP if table : DCNL DCSP DCSP field = abs ( table , field ) DCNL DCSP if ( isinstance ( value , basestring ) and ( value.startswith ( ( &apos; * &apos; , &apos; % &apos; ) ) or value.endswith ( ( &apos; * &apos; , &apos; % &apos; ) ) ) ) : DCNL DCSP DCSP if ( comparison in ( &apos; = &apos; , &apos; i = &apos; , &apos; = = &apos; , LIKE ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP like DCSP % s &apos; % ( field , escape ( value.replace ( &apos; * &apos; , &apos; % &apos; ) ) ) ) DCNL DCSP DCSP if ( comparison in ( &apos; ! = &apos; , &apos; &lt; &gt; &apos; ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP not DCSP like DCSP % s &apos; % ( field , escape ( value.replace ( &apos; * &apos; , &apos; % &apos; ) ) ) ) DCNL DCSP if isinstance ( value , basestring ) : DCNL DCSP DCSP if ( comparison = = &apos; i = &apos; ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP like DCSP % s &apos; % ( field , escape ( value ) ) ) DCNL DCSP if isinstance ( value , ( list , tuple ) ) : DCNL DCSP DCSP if find ( ( lambda v : ( isinstance ( v , basestring ) and ( v.startswith ( &apos; * &apos; ) or v.endswith ( &apos; * &apos; ) ) ) ) , value ) : DCNL DCSP DCSP DCSP return ( &apos; ( % s ) &apos; % any ( * &#91; ( field , v ) for v in value &#93; ) .sql ( escape = escape ) ) DCNL DCSP DCSP if ( comparison in ( &apos; = &apos; , &apos; = = &apos; , IN ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP in DCSP ( % s ) &apos; % ( field , &apos; , &apos; .join ( ( escape ( v ) for v in value ) ) ) ) DCNL DCSP DCSP if ( comparison in ( &apos; ! = &apos; , &apos; &lt; &gt; &apos; ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP not DCSP in DCSP ( % s ) &apos; % ( field , &apos; , &apos; .join ( ( escape ( v ) for v in value ) ) ) ) DCNL DCSP DCSP if ( comparison in ( &apos; : &apos; , BETWEEN ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP between DCSP % s DCSP and DCSP % s &apos; % ( field , escape ( value &#91; 0 &#93; ) , escape ( value &#91; 1 &#93; ) ) ) DCNL DCSP if isinstance ( value , type ( None ) ) : DCNL DCSP DCSP if ( comparison in ( &apos; = &apos; , &apos; = = &apos; ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP is DCSP null &apos; % field ) DCNL DCSP DCSP if ( comparison in ( &apos; ! = &apos; , &apos; &lt; &gt; &apos; ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP is DCSP not DCSP null &apos; % field ) DCNL DCSP if isinstance ( value , Query ) : DCNL DCSP DCSP if ( comparison in ( &apos; = &apos; , &apos; = = &apos; , IN ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP in DCSP % s &apos; % ( field , escape ( value ) ) ) DCNL DCSP DCSP if ( comparison in ( &apos; ! = &apos; , &apos; &lt; &gt; &apos; ) ) : DCNL DCSP DCSP DCSP return ( &apos; % s DCSP not DCSP in DCSP % s &apos; % ( field , escape ( value ) ) ) DCNL DCSP return ( &apos; % s % s % s &apos; % ( field , comparison , escape ( value ) ) )
DCSP lower = name.lower ( ) DCNL DCSP ( base , py _ ver ) = ( None , None ) DCNL DCSP if lower.endswith ( &apos; .exe &apos; ) : DCNL DCSP DCSP if lower.endswith ( &apos; .win32.exe &apos; ) : DCNL DCSP DCSP DCSP base = name &#91; : ( -10 ) &#93; DCNL DCSP DCSP elif lower.startswith ( &apos; .win32-py &apos; , ( -16 ) ) : DCNL DCSP DCSP DCSP py _ ver = name &#91; ( -7 ) : ( -4 ) &#93; DCNL DCSP DCSP DCSP base = name &#91; : ( -16 ) &#93; DCNL DCSP return ( base , py _ ver )
DCSP try : DCNL DCSP DCSP from pylint.gui import Run DCNL DCSP DCSP Run ( sys.argv &#91; 1 : &#93; ) DCNL DCSP except ImportError : DCNL DCSP DCSP sys.exit ( &apos; tkinter DCSP is DCSP not DCSP available &apos; )
DCSP tokenized _ caption = &#91; FLAGS.start _ word &#93; DCNL DCSP tokenized _ caption.extend ( nltk.tokenize.word _ tokenize ( caption.lower ( ) ) ) DCNL DCSP tokenized _ caption.append ( FLAGS.end _ word ) DCNL DCSP return tokenized _ caption
DCSP from openpyxl.worksheet import Worksheet DCNL DCSP return Worksheet
DCSP for ( xi , yi ) in zip ( x , y ) : DCNL DCSP DCSP if ( not ( abs ( ( xi - yi ) ) &lt; = ( atol + ( rtol * abs ( yi ) ) ) ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP title = N _ ( u &apos;Abort DCSP Merge ... &apos; ) DCNL DCSP txt = N _ ( u &apos;Aborting DCSP the DCSP current DCSP merge DCSP will DCSP cause DCSP * ALL * DCSP uncommitted DCSP changes DCSP to DCSP be DCSP lost . \ nRecovering DCSP uncommitted DCSP changes DCSP is DCSP not DCSP possible . &apos; ) DCNL DCSP info _ txt = N _ ( u &apos;Aborting DCSP the DCSP current DCSP merge ? &apos; ) DCNL DCSP ok _ txt = N _ ( u &apos;Abort DCSP Merge &apos; ) DCNL DCSP if qtutils.confirm ( title , txt , info _ txt , ok _ txt , default = False , icon = icons.undo ( ) ) : DCNL DCSP DCSP gitcmds.abort _ merge ( )
DCSP try : DCNL DCSP DCSP boto.emr.emrobject.ClusterTimeline = _ PatchedClusterTimeline DCNL DCSP DCSP return emr _ conn.list _ steps ( * args , * * kwargs ) DCNL DCSP finally : DCNL DCSP DCSP boto.emr.emrobject.ClusterTimeline = ClusterTimeline
DCSP return ( bound _ field.errors and ( not hasattr ( bound _ field.field.widget , u &apos;render _ with _ errors &apos; ) ) )
DCSP scrubbed _ text = text.rstrip ( ) .replace ( &apos; \ n &apos; , &apos; \ \ n &apos; ) .replace ( &apos; DCTB &apos; , ( &apos; DCSP &apos; * 4 ) ) DCNL DCSP return scrubbed _ text
DCSP i = 0 DCNL DCSP bytes = 0 DCNL DCSP for size in msgs : DCNL DCSP DCSP i + = 1 DCNL DCSP DCSP bytes + = size DCNL DCSP DCSP ( yield None ) DCNL DCSP ( yield successResponse ( ( &apos; % d DCSP % d &apos; % ( i , bytes ) ) ) )
DCSP if ( query is None ) : DCNL DCSP DCSP query = { } DCNL DCSP _ validate _ query ( query ) DCNL DCSP for ( field , values ) in query.items ( ) : DCNL DCSP DCSP for value in values : DCNL DCSP DCSP DCSP if ( field = = u &apos;track _ no &apos; ) : DCNL DCSP DCSP DCSP DCSP q = _ convert _ to _ int ( value ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP q = value.strip ( ) DCNL DCSP DCSP DCSP def uri _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = t.uri ) DCNL DCSP DCSP DCSP def track _ name _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = t.name ) DCNL DCSP DCSP DCSP def album _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = getattr ( getattr ( t , u &apos;album &apos; , None ) , u &apos;name &apos; , None ) ) DCNL DCSP DCSP DCSP def artist _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return filter ( ( lambda a : ( q = = a.name ) ) , t.artists ) DCNL DCSP DCSP DCSP def albumartist _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return any ( &#91; ( q = = a.name ) for a in getattr ( t.album , u &apos;artists &apos; , &#91; &#93; ) &#93; ) DCNL DCSP DCSP DCSP def composer _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return any ( &#91; ( q = = a.name ) for a in getattr ( t , u &apos;composers &apos; , &#91; &#93; ) &#93; ) DCNL DCSP DCSP DCSP def performer _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return any ( &#91; ( q = = a.name ) for a in getattr ( t , u &apos;performers &apos; , &#91; &#93; ) &#93; ) DCNL DCSP DCSP DCSP def track _ no _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = t.track _ no ) DCNL DCSP DCSP DCSP def genre _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( t.genre and ( q = = t.genre ) ) DCNL DCSP DCSP DCSP def date _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = t.date ) DCNL DCSP DCSP DCSP def comment _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( q = = t.comment ) DCNL DCSP DCSP DCSP def any _ filter ( t ) : DCNL DCSP DCSP DCSP DCSP return ( uri _ filter ( t ) or track _ name _ filter ( t ) or album _ filter ( t ) or artist _ filter ( t ) or albumartist _ filter ( t ) or composer _ filter ( t ) or performer _ filter ( t ) or track _ no _ filter ( t ) or genre _ filter ( t ) or date _ filter ( t ) or comment _ filter ( t ) ) DCNL DCSP DCSP DCSP if ( field = = u &apos;uri &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( uri _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;track _ name &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( track _ name _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;album &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( album _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;artist &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( artist _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;albumartist &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( albumartist _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;composer &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( composer _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;performer &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( performer _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;track _ no &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( track _ no _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;genre &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( genre _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;date &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( date _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;comment &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( comment _ filter , tracks ) DCNL DCSP DCSP DCSP elif ( field = = u &apos;any &apos; ) : DCNL DCSP DCSP DCSP DCSP tracks = filter ( any _ filter , tracks ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise LookupError ( ( u &apos;Invalid DCSP lookup DCSP field : DCSP % s &apos; % field ) ) DCNL DCSP if ( limit is None ) : DCNL DCSP DCSP tracks = tracks &#91; offset : &#93; DCNL DCSP else : DCNL DCSP DCSP tracks = tracks &#91; offset : ( offset + limit ) &#93; DCNL DCSP return SearchResult ( uri = u &apos;local : search &apos; , tracks = tracks )
DCSP if ( not ccx ) : DCNL DCSP DCSP raise Http404 DCNL DCSP ccx _ key = CCXLocator.from _ course _ locator ( course.id , unicode ( ccx.id ) ) DCNL DCSP with ccx _ course ( ccx _ key ) as course : DCNL DCSP DCSP prep _ course _ for _ grading ( course , request ) DCNL DCSP DCSP enrolled _ students = User.objects.filter ( courseenrollment _ _ course _ id = ccx _ key , courseenrollment _ _ is _ active = 1 ) .order _ by ( &apos; username &apos; ) .select _ related ( &apos; profile &apos; ) DCNL DCSP DCSP grades = CourseGradeFactory ( ) .iter ( course , enrolled _ students ) DCNL DCSP DCSP header = None DCNL DCSP DCSP rows = &#91; &#93; DCNL DCSP DCSP for ( student , course _ grade , _ _ ) in grades : DCNL DCSP DCSP DCSP if course _ grade : DCNL DCSP DCSP DCSP DCSP if ( not header ) : DCNL DCSP DCSP DCSP DCSP DCSP header = &#91; section &#91; &apos; label &apos; &#93; .encode ( &apos; utf-8 &apos; ) for section in course _ grade.summary &#91; u &apos;section _ breakdown &apos; &#93; &#93; DCNL DCSP DCSP DCSP DCSP DCSP rows.append ( ( &#91; &apos; id &apos; , &apos; email &apos; , &apos; username &apos; , &apos; grade &apos; &#93; + header ) ) DCNL DCSP DCSP DCSP DCSP percents = { section &#91; &apos; label &apos; &#93; : section.get ( &apos; percent &apos; , 0.0 ) for section in course _ grade.summary &#91; u &apos;section _ breakdown &apos; &#93; if ( &apos; label &apos; in section ) } DCNL DCSP DCSP DCSP DCSP row _ percents = &#91; percents.get ( label , 0.0 ) for label in header &#93; DCNL DCSP DCSP DCSP DCSP rows.append ( ( &#91; student.id , student.email , student.username , course _ grade.percent &#93; + row _ percents ) ) DCNL DCSP DCSP buf = StringIO ( ) DCNL DCSP DCSP writer = csv.writer ( buf ) DCNL DCSP DCSP for row in rows : DCNL DCSP DCSP DCSP writer.writerow ( row ) DCNL DCSP DCSP response = HttpResponse ( buf.getvalue ( ) , content _ type = &apos; text / csv &apos; ) DCNL DCSP DCSP response &#91; &apos; Content-Disposition &apos; &#93; = &apos; attachment &apos; DCNL DCSP DCSP return response
DCSP if isinstance ( node.op , T.CAReduce ) : DCNL DCSP DCSP ( reduced , ) = node.inputs DCNL DCSP DCSP odtype = node.outputs &#91; 0 &#93; .dtype DCNL DCSP DCSP if ( node.op.axis is None ) : DCNL DCSP DCSP DCSP if all ( reduced.broadcastable ) : DCNL DCSP DCSP DCSP DCSP return &#91; reduced.dimshuffle ( ) .astype ( odtype ) &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP axis = list ( node.op.axis ) DCNL DCSP DCSP DCSP cuttable = &#91; a for a in axis if reduced.broadcastable &#91; a &#93; &#93; DCNL DCSP DCSP DCSP if cuttable : DCNL DCSP DCSP DCSP DCSP new _ axis = &#91; &#93; DCNL DCSP DCSP DCSP DCSP pattern = &#91; &#93; DCNL DCSP DCSP DCSP DCSP ii = 0 DCNL DCSP DCSP DCSP DCSP for p in xrange ( reduced.ndim ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( p not in cuttable ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP if ( p in axis ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP new _ axis.append ( ii ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP pattern.append ( p ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP ii + = 1 DCNL DCSP DCSP DCSP DCSP new _ reduced = reduced.dimshuffle ( * pattern ) DCNL DCSP DCSP DCSP DCSP if new _ axis : DCNL DCSP DCSP DCSP DCSP DCSP if ( type ( node.op ) = = theano.tensor.elemwise.CAReduce ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP new _ op = node.op. _ _ class _ _ ( node.op.scalar _ op , axis = new _ axis ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP new _ op = node.op. _ _ class _ _ ( axis = new _ axis ) DCNL DCSP DCSP DCSP DCSP DCSP return &#91; new _ op ( new _ reduced ) &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return &#91; new _ reduced.astype ( odtype ) &#93;
DCSP if ( not issubclass ( cls , object ) ) : DCNL DCSP DCSP return None DCNL DCSP for base in cls . _ _ mro _ _ : DCNL DCSP DCSP _ is _ declarative _ inherits = hasattr ( base , &apos; _ decl _ class _ registry &apos; ) DCNL DCSP DCSP if ( ( attrname in base . _ _ dict _ _ ) and ( ( base is cls ) or ( ( ( base in cls . _ _ bases _ _ ) if strict else True ) and ( not _ is _ declarative _ inherits ) ) ) ) : DCNL DCSP DCSP DCSP return getattr ( base , attrname ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP ret = &#91; &#93; DCNL DCSP for word in s.split ( ) : DCNL DCSP DCSP if re.match ( &apos; &#91; A-Z &#93; + &#91; a-z &#93; + &#91; A-Z &#93; &apos; , word ) : DCNL DCSP DCSP DCSP word = ( &apos; ! % s &apos; % word ) DCNL DCSP DCSP ret.append ( word ) DCNL DCSP return &apos; DCSP &apos; .join ( ret )
DCSP all = COMMASPACE.join ( fieldvalues ) DCNL DCSP a = _ AddressList ( all ) DCNL DCSP return a.addresslist
DCSP errors = 0 DCNL DCSP fits _ files = handle _ options ( sys.argv &#91; 1 : &#93; ) DCNL DCSP setup _ logging ( ) DCNL DCSP for filename in fits _ files : DCNL DCSP DCSP errors + = process _ file ( filename ) DCNL DCSP if errors : DCNL DCSP DCSP log.warning ( &apos; { } DCSP errors &apos; .format ( errors ) ) DCNL DCSP return int ( bool ( errors ) )
DCSP if ( net _ db.external is not None ) : DCNL DCSP DCSP net _ res &#91; IS _ DEFAULT &#93; = net _ db.external.is _ default DCNL DCSP return net _ res
DCSP datasets = load _ data ( mnist _ pkl _ gz ) DCNL DCSP ( train _ set _ x , train _ set _ y ) = datasets &#91; 0 &#93; DCNL DCSP ( valid _ set _ x , valid _ set _ y ) = datasets &#91; 1 &#93; DCNL DCSP ( test _ set _ x , test _ set _ y ) = datasets &#91; 2 &#93; DCNL DCSP batch _ size = 600 DCNL DCSP n _ train _ batches = ( train _ set _ x.get _ value ( borrow = True ) .shape &#91; 0 &#93; / / batch _ size ) DCNL DCSP n _ valid _ batches = ( valid _ set _ x.get _ value ( borrow = True ) .shape &#91; 0 &#93; / / batch _ size ) DCNL DCSP n _ test _ batches = ( test _ set _ x.get _ value ( borrow = True ) .shape &#91; 0 &#93; / / batch _ size ) DCNL DCSP n _ in = ( 28 * 28 ) DCNL DCSP n _ out = 10 DCNL DCSP print ( &apos; ... DCSP building DCSP the DCSP model &apos; ) DCNL DCSP minibatch _ offset = T.lscalar ( ) DCNL DCSP x = T.matrix ( ) DCNL DCSP y = T.ivector ( ) DCNL DCSP classifier = LogisticRegression ( input = x , n _ in = ( 28 * 28 ) , n _ out = 10 ) DCNL DCSP cost = classifier.negative _ log _ likelihood ( y ) .mean ( ) DCNL DCSP test _ model = theano.function ( &#91; minibatch _ offset &#93; , classifier.errors ( y ) , givens = { x : test _ set _ x &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; , y : test _ set _ y &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; } , name = &apos; test &apos; ) DCNL DCSP validate _ model = theano.function ( &#91; minibatch _ offset &#93; , classifier.errors ( y ) , givens = { x : valid _ set _ x &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; , y : valid _ set _ y &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; } , name = &apos; validate &apos; ) DCNL DCSP batch _ cost = theano.function ( &#91; minibatch _ offset &#93; , cost , givens = { x : train _ set _ x &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; , y : train _ set _ y &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; } , name = &apos; batch _ cost &apos; ) DCNL DCSP batch _ grad = theano.function ( &#91; minibatch _ offset &#93; , T.grad ( cost , classifier.theta ) , givens = { x : train _ set _ x &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; , y : train _ set _ y &#91; minibatch _ offset : ( minibatch _ offset + batch _ size ) &#93; } , name = &apos; batch _ grad &apos; ) DCNL DCSP def train _ fn ( theta _ value ) : DCNL DCSP DCSP classifier.theta.set _ value ( theta _ value , borrow = True ) DCNL DCSP DCSP train _ losses = &#91; batch _ cost ( ( i * batch _ size ) ) for i in range ( n _ train _ batches ) &#93; DCNL DCSP DCSP return numpy.mean ( train _ losses ) DCNL DCSP def train _ fn _ grad ( theta _ value ) : DCNL DCSP DCSP classifier.theta.set _ value ( theta _ value , borrow = True ) DCNL DCSP DCSP grad = batch _ grad ( 0 ) DCNL DCSP DCSP for i in range ( 1 , n _ train _ batches ) : DCNL DCSP DCSP DCSP grad + = batch _ grad ( ( i * batch _ size ) ) DCNL DCSP DCSP return ( grad / n _ train _ batches ) DCNL DCSP validation _ scores = &#91; numpy.inf , 0 &#93; DCNL DCSP def callback ( theta _ value ) : DCNL DCSP DCSP classifier.theta.set _ value ( theta _ value , borrow = True ) DCNL DCSP DCSP validation _ losses = &#91; validate _ model ( ( i * batch _ size ) ) for i in range ( n _ valid _ batches ) &#93; DCNL DCSP DCSP this _ validation _ loss = numpy.mean ( validation _ losses ) DCNL DCSP DCSP print ( ( &apos; validation DCSP error DCSP % f DCSP % % &apos; % ( ( this _ validation _ loss * 100.0 ) , ) ) ) DCNL DCSP DCSP if ( this _ validation _ loss &lt; validation _ scores &#91; 0 &#93; ) : DCNL DCSP DCSP DCSP validation _ scores &#91; 0 &#93; = this _ validation _ loss DCNL DCSP DCSP DCSP test _ losses = &#91; test _ model ( ( i * batch _ size ) ) for i in range ( n _ test _ batches ) &#93; DCNL DCSP DCSP DCSP validation _ scores &#91; 1 &#93; = numpy.mean ( test _ losses ) DCNL DCSP import scipy.optimize DCNL DCSP print ( &apos; Optimizing DCSP using DCSP scipy.optimize.fmin _ cg ... &apos; ) DCNL DCSP start _ time = timeit.default _ timer ( ) DCNL DCSP best _ w _ b = scipy.optimize.fmin _ cg ( f = train _ fn , x0 = numpy.zeros ( ( ( n _ in + 1 ) * n _ out ) , dtype = x.dtype ) , fprime = train _ fn _ grad , callback = callback , disp = 0 , maxiter = n _ epochs ) DCNL DCSP end _ time = timeit.default _ timer ( ) DCNL DCSP print ( ( &apos; Optimization DCSP complete DCSP with DCSP best DCSP validation DCSP score DCSP of DCSP % f DCSP % % , DCSP with DCSP test DCSP performance DCSP % f DCSP % % &apos; % ( ( validation _ scores &#91; 0 &#93; * 100.0 ) , ( validation _ scores &#91; 1 &#93; * 100.0 ) ) ) ) DCNL DCSP print ( ( ( &apos; The DCSP code DCSP for DCSP file DCSP &apos; + os.path.split ( _ _ file _ _ ) &#91; 1 &#93; ) + ( &apos; DCSP ran DCSP for DCSP % .1fs &apos; % ( end _ time - start _ time ) ) ) , file = sys.stderr )
DCSP params = { &apos; connection-limit &apos; : connection _ limit , &apos; description &apos; : description , &apos; dynamic-ratio &apos; : dynamic _ ratio , &apos; logging &apos; : logging , &apos; monitor &apos; : monitor , &apos; rate-limit &apos; : rate _ limit , &apos; ratio &apos; : ratio , &apos; session &apos; : session , &apos; state &apos; : state } DCNL DCSP bigip _ session = _ build _ session ( username , password , trans _ label ) DCNL DCSP payload = _ loop _ payload ( params ) DCNL DCSP payload &#91; &apos; name &apos; &#93; = name DCNL DCSP try : DCNL DCSP DCSP response = bigip _ session.put ( ( BIG _ IP _ URL _ BASE.format ( host = hostname ) + &apos; / ltm / node / { name } &apos; .format ( name = name ) ) , data = json.dumps ( payload ) ) DCNL DCSP except requests.exceptions.ConnectionError as e : DCNL DCSP DCSP return _ load _ connection _ error ( hostname , e ) DCNL DCSP return _ load _ response ( response )
DCSP db _ user = boto.config.get ( &apos; DB &apos; , &apos; db _ user &apos; , None ) DCNL DCSP db _ passwd = boto.config.get ( &apos; DB &apos; , &apos; db _ passwd &apos; , None ) DCNL DCSP db _ type = boto.config.get ( &apos; DB &apos; , &apos; db _ type &apos; , &apos; SimpleDB &apos; ) DCNL DCSP db _ name = boto.config.get ( &apos; DB &apos; , &apos; db _ name &apos; , None ) DCNL DCSP db _ table = boto.config.get ( &apos; DB &apos; , &apos; db _ table &apos; , None ) DCNL DCSP db _ host = boto.config.get ( &apos; DB &apos; , &apos; db _ host &apos; , &apos; sdb.amazonaws.com &apos; ) DCNL DCSP db _ port = boto.config.getint ( &apos; DB &apos; , &apos; db _ port &apos; , 443 ) DCNL DCSP enable _ ssl = boto.config.getbool ( &apos; DB &apos; , &apos; enable _ ssl &apos; , True ) DCNL DCSP sql _ dir = boto.config.get ( &apos; DB &apos; , &apos; sql _ dir &apos; , None ) DCNL DCSP debug = boto.config.getint ( &apos; DB &apos; , &apos; debug &apos; , 0 ) DCNL DCSP module _ name = cls . _ _ module _ _ .replace ( &apos; .&apos; , &apos; _ &apos; ) DCNL DCSP db _ section = ( ( ( &apos; DB _ &apos; + module _ name ) + &apos; _ &apos; ) + cls . _ _ name _ _ ) DCNL DCSP if ( not boto.config.has _ section ( db _ section ) ) : DCNL DCSP DCSP db _ section = ( &apos; DB _ &apos; + cls . _ _ name _ _ ) DCNL DCSP if boto.config.has _ section ( db _ section ) : DCNL DCSP DCSP db _ user = boto.config.get ( db _ section , &apos; db _ user &apos; , db _ user ) DCNL DCSP DCSP db _ passwd = boto.config.get ( db _ section , &apos; db _ passwd &apos; , db _ passwd ) DCNL DCSP DCSP db _ type = boto.config.get ( db _ section , &apos; db _ type &apos; , db _ type ) DCNL DCSP DCSP db _ name = boto.config.get ( db _ section , &apos; db _ name &apos; , db _ name ) DCNL DCSP DCSP db _ table = boto.config.get ( db _ section , &apos; db _ table &apos; , db _ table ) DCNL DCSP DCSP db _ host = boto.config.get ( db _ section , &apos; db _ host &apos; , db _ host ) DCNL DCSP DCSP db _ port = boto.config.getint ( db _ section , &apos; db _ port &apos; , db _ port ) DCNL DCSP DCSP enable _ ssl = boto.config.getint ( db _ section , &apos; enable _ ssl &apos; , enable _ ssl ) DCNL DCSP DCSP debug = boto.config.getint ( db _ section , &apos; debug &apos; , debug ) DCNL DCSP elif ( hasattr ( cls , &apos; _ db _ name &apos; ) and ( cls . _ db _ name is not None ) ) : DCNL DCSP DCSP db _ name = cls . _ db _ name DCNL DCSP elif hasattr ( cls . _ _ bases _ _ &#91; 0 &#93; , &apos; _ manager &apos; ) : DCNL DCSP DCSP return cls . _ _ bases _ _ &#91; 0 &#93; . _ manager DCNL DCSP if ( db _ type = = &apos; SimpleDB &apos; ) : DCNL DCSP DCSP from boto.sdb.db.manager.sdbmanager import SDBManager DCNL DCSP DCSP return SDBManager ( cls , db _ name , db _ user , db _ passwd , db _ host , db _ port , db _ table , sql _ dir , enable _ ssl ) DCNL DCSP elif ( db _ type = = &apos; XML &apos; ) : DCNL DCSP DCSP from boto.sdb.db.manager.xmlmanager import XMLManager DCNL DCSP DCSP return XMLManager ( cls , db _ name , db _ user , db _ passwd , db _ host , db _ port , db _ table , sql _ dir , enable _ ssl ) DCNL DCSP else : DCNL DCSP DCSP raise ValueError ( ( &apos; Unknown DCSP db _ type : DCSP % s &apos; % db _ type ) )
DCSP return range _ property ( attr , 0 , 4294967295 )
DCSP if ( flag and could _ edit ( request ) ) : DCNL DCSP DCSP request.session &#91; EDIT _ FLAG _ NAME &#93; = True DCNL DCSP else : DCNL DCSP DCSP request.session.pop ( EDIT _ FLAG _ NAME , None )
DCSP if ( msg _ type and ( msg _ type not in MSG _ TYPE _ MAP ) ) : DCNL DCSP DCSP raise InvalidHandlerType ( ( &apos; Invalid DCSP message DCSP type DCSP &#91; % s &#93; : DCSP type DCSP should DCSP be DCSP in DCSP % s &apos; % ( msg _ type , str ( MSG _ TYPES ) ) ) ) DCNL DCSP handler = Handler ( func = func , name = dispatcher _ name ) DCNL DCSP if ( msg _ type is None ) : DCNL DCSP DCSP _ registry &#91; RAW _ TYPE &#93; .append ( handler ) DCNL DCSP else : DCNL DCSP DCSP _ registry &#91; msg _ type &#93; .append ( handler ) DCNL DCSP if active _ by _ default : DCNL DCSP DCSP _ active.add ( dispatcher _ name )
DCSP path = &apos; https : / / api.qingcloud.com / iaas / &apos; DCNL DCSP access _ key _ id = config.get _ cloud _ config _ value ( &apos; access _ key _ id &apos; , get _ configured _ provider ( ) , _ _ opts _ _ , search _ global = False ) DCNL DCSP access _ key _ secret = config.get _ cloud _ config _ value ( &apos; secret _ access _ key &apos; , get _ configured _ provider ( ) , _ _ opts _ _ , search _ global = False ) DCNL DCSP real _ parameters = { &apos; access _ key _ id &apos; : access _ key _ id , &apos; signature _ version &apos; : DEFAULT _ QINGCLOUD _ SIGNATURE _ VERSION , &apos; time _ stamp &apos; : time.strftime ( &apos; % Y- % m- % dT % H : % M : % SZ &apos; , time.gmtime ( ) ) , &apos; version &apos; : DEFAULT _ QINGCLOUD _ API _ VERSION } DCNL DCSP if params : DCNL DCSP DCSP for ( key , value ) in params.items ( ) : DCNL DCSP DCSP DCSP if isinstance ( value , list ) : DCNL DCSP DCSP DCSP DCSP for i in range ( 1 , ( len ( value ) + 1 ) ) : DCNL DCSP DCSP DCSP DCSP DCSP if isinstance ( value &#91; ( i - 1 ) &#93; , dict ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for ( sk , sv ) in value &#91; ( i - 1 ) &#93; .items ( ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if ( isinstance ( sv , dict ) or isinstance ( sv , list ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP sv = json.dumps ( sv , separators = ( &apos; , &apos; , &apos; : &apos; ) ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP real _ parameters &#91; &apos; { 0 } . { 1 } . { 2 } &apos; .format ( key , i , sk ) &#93; = sv DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP real _ parameters &#91; &apos; { 0 } . { 1 } &apos; .format ( key , i ) &#93; = value &#91; ( i - 1 ) &#93; DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP real _ parameters &#91; key &#93; = value DCNL DCSP signature = _ compute _ signature ( real _ parameters , access _ key _ secret , &apos; GET &apos; , &apos; / iaas / &apos; ) DCNL DCSP real _ parameters &#91; &apos; signature &apos; &#93; = signature DCNL DCSP request = requests.get ( path , params = real _ parameters , verify = False ) DCNL DCSP if ( request.status _ code ! = 200 ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &quot; An DCSP error DCSP occurred DCSP while DCSP querying DCSP QingCloud . DCSP HTTP DCSP Code : DCSP { 0 } DCSP DCSP Error : DCSP &apos; { 1 } &apos; &quot; .format ( request.status _ code , request.text ) ) DCNL DCSP log.debug ( request.url ) DCNL DCSP content = request.text DCNL DCSP result = json.loads ( content , object _ hook = salt.utils.decode _ dict ) DCNL DCSP if ( result &#91; &apos; ret _ code &apos; &#93; ! = 0 ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( pprint.pformat ( result.get ( &apos; message &apos; , { } ) ) ) DCNL DCSP return result
DCSP if ( not isinstance ( intlist , list ) ) : DCNL DCSP DCSP return False DCNL DCSP for i in intlist : DCNL DCSP DCSP if ( not isinstance ( i , int ) ) : DCNL DCSP DCSP DCSP return False DCNL DCSP return True
DCSP an = asarray ( an ) DCNL DCSP N = ( len ( an ) - 1 ) DCNL DCSP n = ( N - m ) DCNL DCSP if ( n &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; Order DCSP of DCSP q DCSP &lt; m &gt; DCSP must DCSP be DCSP smaller DCSP than DCSP len ( an ) -1 . &apos; ) DCNL DCSP Akj = eye ( ( N + 1 ) , ( n + 1 ) ) DCNL DCSP Bkj = zeros ( ( ( N + 1 ) , m ) , &apos; d &apos; ) DCNL DCSP for row in range ( 1 , ( m + 1 ) ) : DCNL DCSP DCSP Bkj &#91; row , : row &#93; = ( - an &#91; : row &#93; &#91; : : ( -1 ) &#93; ) DCNL DCSP for row in range ( ( m + 1 ) , ( N + 1 ) ) : DCNL DCSP DCSP Bkj &#91; row , : &#93; = ( - an &#91; ( row - m ) : row &#93; &#91; : : ( -1 ) &#93; ) DCNL DCSP C = hstack ( ( Akj , Bkj ) ) DCNL DCSP pq = linalg.solve ( C , an ) DCNL DCSP p = pq &#91; : ( n + 1 ) &#93; DCNL DCSP q = r _ &#91; ( 1.0 , pq &#91; ( n + 1 ) : &#93; ) &#93; DCNL DCSP return ( poly1d ( p &#91; : : ( -1 ) &#93; ) , poly1d ( q &#91; : : ( -1 ) &#93; ) )
DCSP counts = query.selectable.with _ only _ columns ( &#91; func.count ( ) &#93; ) DCNL DCSP num _ results = session.execute ( counts.order _ by ( None ) ) .scalar ( ) DCNL DCSP if ( ( num _ results is None ) or ( query . _ limit is not None ) ) : DCNL DCSP DCSP return query.order _ by ( None ) .count ( ) DCNL DCSP return num _ results
DCSP u &apos; DCSP The DCSP &quot; angle &quot; DCSP is DCSP a DCSP fundamental DCSP object . DCSP The DCSP internal \ n DCSP DCSP DCSP DCSP representation DCSP is DCSP stored DCSP in DCSP radians , DCSP but DCSP this DCSP is DCSP transparent DCSP to DCSP the DCSP user . \ n DCSP DCSP DCSP DCSP Units DCSP * must * DCSP be DCSP specified DCSP rather DCSP than DCSP a DCSP default DCSP value DCSP be DCSP assumed . DCSP This DCSP is \ n DCSP DCSP DCSP DCSP as DCSP much DCSP for DCSP self-documenting DCSP code DCSP as DCSP anything DCSP else . \ n \ n DCSP DCSP DCSP DCSP Angle DCSP objects DCSP simply DCSP represent DCSP a DCSP single DCSP angular DCSP coordinate . DCSP More DCSP specific \ n DCSP DCSP DCSP DCSP angular DCSP coordinates DCSP ( e.g. DCSP Longitude , DCSP Latitude ) DCSP are DCSP subclasses DCSP of DCSP Angle . &apos; DCNL DCSP a1 = Angle ( 54.12412 , unit = u.degree ) DCNL DCSP a2 = Angle ( u &apos; 54.12412 &apos; , unit = u.degree ) DCNL DCSP a3 = Angle ( u &apos; 54 : 07 : 26.832 &apos; , unit = u.degree ) DCNL DCSP a4 = Angle ( u &apos; 54.12412 DCSP deg &apos; ) DCNL DCSP a5 = Angle ( u &apos; 54.12412 DCSP degrees &apos; ) DCNL DCSP a6 = Angle ( u &apos; 54.12412 \ xb0 &apos; ) DCNL DCSP a7 = Angle ( ( 54 , 7 , 26.832 ) , unit = u.degree ) DCNL DCSP a8 = Angle ( u &apos; 54 \ xb007 \ &apos; 26.832 &quot; &apos; ) DCNL DCSP a9 = Angle ( &#91; 54 , 7 , 26.832 &#93; , unit = u.degree ) DCNL DCSP assert _ allclose ( a9.value , &#91; 54 , 7 , 26.832 &#93; ) DCNL DCSP assert ( a9.unit is u.degree ) DCNL DCSP a10 = Angle ( 3.60827466667 , unit = u.hour ) DCNL DCSP a11 = Angle ( u &apos; 3 : 36 : 29.7888000120 &apos; , unit = u.hour ) DCNL DCSP a12 = Angle ( ( 3 , 36 , 29.788800012 ) , unit = u.hour ) DCNL DCSP a13 = Angle ( ( 3 , 36 , 29.788800012 ) , unit = u &apos;hour &apos; ) DCNL DCSP Angle ( 0.944644098745 , unit = u.radian ) DCNL DCSP with pytest.raises ( u.UnitsError ) : DCNL DCSP DCSP Angle ( 54.12412 ) DCNL DCSP with pytest.raises ( u.UnitsError ) : DCNL DCSP DCSP Angle ( 54.12412 , unit = u.m ) DCNL DCSP with pytest.raises ( ValueError ) : DCNL DCSP DCSP Angle ( 12.34 , unit = u &apos;not DCSP a DCSP unit &apos; ) DCNL DCSP a14 = Angle ( u &apos; 03h36m29.7888000120 &apos; ) DCNL DCSP a15 = Angle ( u &apos; 5h4m3s &apos; ) DCNL DCSP assert ( a15.unit = = u.hourangle ) DCNL DCSP a16 = Angle ( u &apos; 1 DCSP d &apos; ) DCNL DCSP a17 = Angle ( u &apos; 1 DCSP degree &apos; ) DCNL DCSP assert ( a16.degree = = 1 ) DCNL DCSP assert ( a17.degree = = 1 ) DCNL DCSP a18 = Angle ( u &apos; 54 DCSP 07.4472 &apos; , unit = u.degree ) DCNL DCSP a19 = Angle ( u &apos; 54 : 07.4472 &apos; , unit = u.degree ) DCNL DCSP a20 = Angle ( u &apos; 54d07.4472m &apos; , unit = u.degree ) DCNL DCSP a21 = Angle ( u &apos; 3h36m &apos; , unit = u.hour ) DCNL DCSP a22 = Angle ( u &apos; 3.6h &apos; , unit = u.hour ) DCNL DCSP a23 = Angle ( u &apos; - DCSP 3h &apos; , unit = u.hour ) DCNL DCSP a24 = Angle ( u &apos; + DCSP 3h &apos; , unit = u.hour ) DCNL DCSP assert ( a1 = = a2 = = a3 = = a4 = = a5 = = a6 = = a7 = = a8 = = a18 = = a19 = = a20 ) DCNL DCSP assert _ allclose ( a1.radian , a2.radian ) DCNL DCSP assert _ allclose ( a2.degree , a3.degree ) DCNL DCSP assert _ allclose ( a3.radian , a4.radian ) DCNL DCSP assert _ allclose ( a4.radian , a5.radian ) DCNL DCSP assert _ allclose ( a5.radian , a6.radian ) DCNL DCSP assert _ allclose ( a6.radian , a7.radian ) DCNL DCSP assert _ allclose ( a10.degree , a11.degree ) DCNL DCSP assert ( a11 = = a12 = = a13 = = a14 ) DCNL DCSP assert ( a21 = = a22 ) DCNL DCSP assert ( a23 = = ( - a24 ) ) DCNL DCSP with pytest.raises ( IllegalSecondError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12 DCSP 32 DCSP 99 &apos; , unit = u.degree ) DCNL DCSP with pytest.raises ( IllegalMinuteError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12 DCSP 99 DCSP 23 &apos; , unit = u.degree ) DCNL DCSP with pytest.raises ( IllegalSecondError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12 DCSP 32 DCSP 99 &apos; , unit = u.hour ) DCNL DCSP with pytest.raises ( IllegalMinuteError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12 DCSP 99 DCSP 23 &apos; , unit = u.hour ) DCNL DCSP with pytest.raises ( IllegalHourError ) : DCNL DCSP DCSP a = Angle ( u &apos; 99 DCSP 25 DCSP 51.0 &apos; , unit = u.hour ) DCNL DCSP with pytest.raises ( ValueError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12 DCSP 25 DCSP 51.0xxx &apos; , unit = u.hour ) DCNL DCSP with pytest.raises ( ValueError ) : DCNL DCSP DCSP a = Angle ( u &apos; 12h34321m32.2s &apos; ) DCNL DCSP assert ( a1 is not None )
DCSP vector3RemoveByPrefix = getVector3ByPrefix ( vector3 , prefix , xmlElement ) DCNL DCSP euclidean.removePrefixFromDictionary ( xmlElement.attributeDictionary , prefix ) DCNL DCSP return vector3RemoveByPrefix
DCSP jid = str ( jid ) DCNL DCSP jid = re.sub ( &quot; &apos; * &quot; , &apos; &apos; , jid ) DCNL DCSP return jid
DCSP match = time _ re.match ( value ) DCNL DCSP if match : DCNL DCSP DCSP kw = match.groupdict ( ) DCNL DCSP DCSP if kw &#91; &apos; microsecond &apos; &#93; : DCNL DCSP DCSP DCSP kw &#91; &apos; microsecond &apos; &#93; = kw &#91; &apos; microsecond &apos; &#93; .ljust ( 6 , &apos; 0&apos; ) DCNL DCSP DCSP kw = dict ( ( ( k , int ( v ) ) for ( k , v ) in six.iteritems ( kw ) if ( v is not None ) ) ) DCNL DCSP DCSP return datetime.time ( * * kw )
DCSP return &apos; .&apos;.join ( map ( str , tup ) )
DCSP if ( not isinstance ( value , expected _ type ) ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP value = expected _ type ( value ) DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP raise TypeError ( ( &apos; expected DCSP &apos; + str ( expected _ type ) ) ) DCNL DCSP return value
DCSP parser = lxml.etree.XMLParser ( remove _ blank _ text = True ) DCNL DCSP newdata = lxml.etree.XML ( data , parser = parser ) DCNL DCSP return lxml.etree.tostring ( newdata , encoding = &apos; utf-8 &apos; , method = &apos; xml &apos; , xml _ declaration = True )
DCSP ( result , _ ) = _ qd ( A , B , output = output , lwork = lwork , sort = sort , overwrite _ a = overwrite _ a , overwrite _ b = overwrite _ b , check _ finite = check _ finite ) DCNL DCSP return ( result &#91; 0 &#93; , result &#91; 1 &#93; , result &#91; ( -4 ) &#93; , result &#91; ( -3 ) &#93; )
DCSP last = rdfvalue.RDFDatetime ( 0 ) DCNL DCSP client _ urn = None DCNL DCSP for client in aff4.FACTORY.MultiOpen ( client _ list , token = token ) : DCNL DCSP DCSP client _ last = client.Get ( client.Schema.LAST ) DCNL DCSP DCSP if ( client _ last &gt; last ) : DCNL DCSP DCSP DCSP last = client _ last DCNL DCSP DCSP DCSP client _ urn = client.urn DCNL DCSP return client _ urn
DCSP from scipy.optimize import fmin _ cobyla DCNL DCSP assert ( nfit &gt; = 2 ) DCNL DCSP u = dict ( y = np.zeros ( ( nterms - 1 ) ) , resi = np.zeros ( ( nterms - 1 ) ) , nfit = nfit , nterms = nterms , M = np.zeros ( ( ( nterms - 1 ) , ( nfit - 1 ) ) ) ) DCNL DCSP u &#91; &apos; fn &apos; &#93; = _ fwd _ eeg _ get _ multi _ sphere _ model _ coeffs ( m , ( nterms + 1 ) ) DCNL DCSP f = ( min ( &#91; layer &#91; &apos; rad &apos; &#93; for layer in m &#91; &apos; layers &apos; &#93; &#93; ) / max ( &#91; layer &#91; &apos; rad &apos; &#93; for layer in m &#91; &apos; layers &apos; &#93; &#93; ) ) DCNL DCSP k = np.arange ( 1 , ( nterms + 1 ) ) DCNL DCSP u &#91; &apos; w &apos; &#93; = ( np.sqrt ( ( ( ( ( 2.0 * k ) + 1 ) * ( ( 3.0 * k ) + 1.0 ) ) / k ) ) * np.power ( f , ( k - 1.0 ) ) ) DCNL DCSP u &#91; &apos; w &apos; &#93; &#91; ( -1 ) &#93; = 0 DCNL DCSP mu _ 0 = ( np.random.RandomState ( 0 ) .rand ( nfit ) * f ) DCNL DCSP fun = partial ( _ one _ step , u = u ) DCNL DCSP max _ = ( 1.0 - 0.0002 ) DCNL DCSP cons = &#91; ( lambda x : ( max _ - np.abs ( x &#91; ii &#93; ) ) ) for ii in range ( nfit ) &#93; DCNL DCSP mu = fmin _ cobyla ( fun , mu _ 0 , cons , rhobeg = 0.5 , rhoend = 0.005 , disp = 0 ) DCNL DCSP ( rv , lambda _ ) = _ compute _ linear _ parameters ( mu , u ) DCNL DCSP order = np.argsort ( mu ) &#91; : : ( -1 ) &#93; DCNL DCSP ( mu , lambda _ ) = ( mu &#91; order &#93; , lambda _ &#91; order &#93; ) DCNL DCSP m &#91; &apos; mu &apos; &#93; = mu DCNL DCSP m &#91; &apos; lambda &apos; &#93; = ( lambda _ / m &#91; &apos; layers &apos; &#93; &#91; ( -1 ) &#93; &#91; &apos; sigma &apos; &#93; ) DCNL DCSP m &#91; &apos; nfit &apos; &#93; = nfit DCNL DCSP return rv
DCSP with caplog.at _ level ( logging.ERROR ) : DCNL DCSP DCSP with qtbot.waitSignal ( proc.finished , timeout = 10000 ) : DCNL DCSP DCSP DCSP proc.start ( * py _ proc ( &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP import DCSP sys \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP print ( &quot; test &quot; , DCSP file = sys . { } ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP sys.exit ( 1 ) \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; .format ( stream ) ) ) DCNL DCSP assert ( len ( caplog.records ) = = 2 ) DCNL DCSP assert ( caplog.records &#91; 1 &#93; .msg = = &apos; Process DCSP { } : \ ntest &apos; .format ( stream ) )
DCSP if ( offset is None ) : DCNL DCSP DCSP return MoveModule ( project , resource ) DCNL DCSP this _ pymodule = project.get _ pymodule ( resource ) DCNL DCSP pyname = evaluate.eval _ location ( this _ pymodule , offset ) DCNL DCSP if ( pyname is not None ) : DCNL DCSP DCSP pyobject = pyname.get _ object ( ) DCNL DCSP DCSP if ( isinstance ( pyobject , pyobjects.PyModule ) or isinstance ( pyobject , pyobjects.PyPackage ) ) : DCNL DCSP DCSP DCSP return MoveModule ( project , pyobject.get _ resource ( ) ) DCNL DCSP DCSP if ( isinstance ( pyobject , pyobjects.PyFunction ) and isinstance ( pyobject.parent , pyobjects.PyClass ) ) : DCNL DCSP DCSP DCSP return MoveMethod ( project , resource , offset ) DCNL DCSP DCSP if ( ( isinstance ( pyobject , pyobjects.PyDefinedObject ) and isinstance ( pyobject.parent , pyobjects.PyModule ) ) or isinstance ( pyname , pynames.AssignedName ) ) : DCNL DCSP DCSP DCSP return MoveGlobal ( project , resource , offset ) DCNL DCSP raise exceptions.RefactoringError ( &apos; Move DCSP only DCSP works DCSP on DCSP global DCSP classes / functions / variables , DCSP modules DCSP and DCSP methods . &apos; )
DCSP x = inet _ pton ( socket.AF _ INET6 , x ) DCNL DCSP return ( x &#91; : 2 &#93; = = &apos; DCSP \ x02 &apos; )
DCSP if ( HAS _ NAPALM and ( &apos; proxy &apos; in _ _ opts _ _ ) ) : DCNL DCSP DCSP return _ _ virtualname _ _ DCNL DCSP else : DCNL DCSP DCSP return ( False , &apos; The DCSP network DCSP NTP DCSP state DCSP ( netntp ) DCSP cannot DCSP be DCSP loaded : DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP NAPALM DCSP or DCSP proxy DCSP could DCSP not DCSP be DCSP loaded . &apos; )
DCSP funcname = lineno = message _ lineno = None DCNL DCSP call _ stack = ( -1 ) DCNL DCSP buf = &#91; &#93; DCNL DCSP messages = &#91; &#93; DCNL DCSP translator _ comments = &#91; &#93; DCNL DCSP in _ def = in _ translator _ comments = False DCNL DCSP comment _ tag = None DCNL DCSP encoding = ( parse _ encoding ( fileobj ) or options.get ( &apos; encoding &apos; , &apos; iso-8859-1 &apos; ) ) DCNL DCSP tokens = generate _ tokens ( fileobj.readline ) DCNL DCSP for ( tok , value , ( lineno , _ ) , _ , _ ) in tokens : DCNL DCSP DCSP if ( ( call _ stack = = ( -1 ) ) and ( tok = = NAME ) and ( value in ( &apos; def &apos; , &apos; class &apos; ) ) ) : DCNL DCSP DCSP DCSP in _ def = True DCNL DCSP DCSP elif ( ( tok = = OP ) and ( value = = &apos; ( &apos; ) ) : DCNL DCSP DCSP DCSP if in _ def : DCNL DCSP DCSP DCSP DCSP in _ def = False DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if funcname : DCNL DCSP DCSP DCSP DCSP message _ lineno = lineno DCNL DCSP DCSP DCSP DCSP call _ stack + = 1 DCNL DCSP DCSP elif ( in _ def and ( tok = = OP ) and ( value = = &apos; : &apos; ) ) : DCNL DCSP DCSP DCSP in _ def = False DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP elif ( ( call _ stack = = ( -1 ) ) and ( tok = = COMMENT ) ) : DCNL DCSP DCSP DCSP value = value.decode ( encoding ) &#91; 1 : &#93; .strip ( ) DCNL DCSP DCSP DCSP if ( in _ translator _ comments and ( translator _ comments &#91; ( -1 ) &#93; &#91; 0 &#93; = = ( lineno - 1 ) ) ) : DCNL DCSP DCSP DCSP DCSP translator _ comments.append ( ( lineno , value ) ) DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP for comment _ tag in comment _ tags : DCNL DCSP DCSP DCSP DCSP if value.startswith ( comment _ tag ) : DCNL DCSP DCSP DCSP DCSP DCSP in _ translator _ comments = True DCNL DCSP DCSP DCSP DCSP DCSP translator _ comments.append ( ( lineno , value ) ) DCNL DCSP DCSP DCSP DCSP DCSP break DCNL DCSP DCSP elif ( funcname and ( call _ stack = = 0 ) ) : DCNL DCSP DCSP DCSP if ( ( tok = = OP ) and ( value = = &apos; ) &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if buf : DCNL DCSP DCSP DCSP DCSP DCSP messages.append ( &apos; &apos;.join ( buf ) ) DCNL DCSP DCSP DCSP DCSP DCSP del buf &#91; : &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP messages.append ( None ) DCNL DCSP DCSP DCSP DCSP if ( len ( messages ) &gt; 1 ) : DCNL DCSP DCSP DCSP DCSP DCSP messages = tuple ( messages ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP messages = messages &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP if ( translator _ comments and ( translator _ comments &#91; ( -1 ) &#93; &#91; 0 &#93; &lt; ( message _ lineno - 1 ) ) ) : DCNL DCSP DCSP DCSP DCSP DCSP translator _ comments = &#91; &#93; DCNL DCSP DCSP DCSP DCSP ( yield ( message _ lineno , funcname , messages , &#91; comment &#91; 1 &#93; for comment in translator _ comments &#93; ) ) DCNL DCSP DCSP DCSP DCSP funcname = lineno = message _ lineno = None DCNL DCSP DCSP DCSP DCSP call _ stack = ( -1 ) DCNL DCSP DCSP DCSP DCSP messages = &#91; &#93; DCNL DCSP DCSP DCSP DCSP translator _ comments = &#91; &#93; DCNL DCSP DCSP DCSP DCSP in _ translator _ comments = False DCNL DCSP DCSP DCSP elif ( tok = = STRING ) : DCNL DCSP DCSP DCSP DCSP value = eval ( ( &apos; # DCSP coding = % s \ n % s &apos; % ( encoding , value ) ) , { &apos; _ _ builtins _ _ &apos; : { } } , { } ) DCNL DCSP DCSP DCSP DCSP if isinstance ( value , str ) : DCNL DCSP DCSP DCSP DCSP DCSP value = value.decode ( encoding ) DCNL DCSP DCSP DCSP DCSP buf.append ( value ) DCNL DCSP DCSP DCSP elif ( ( tok = = OP ) and ( value = = &apos; , &apos; ) ) : DCNL DCSP DCSP DCSP DCSP if buf : DCNL DCSP DCSP DCSP DCSP DCSP messages.append ( &apos; &apos;.join ( buf ) ) DCNL DCSP DCSP DCSP DCSP DCSP del buf &#91; : &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP messages.append ( None ) DCNL DCSP DCSP DCSP DCSP if translator _ comments : DCNL DCSP DCSP DCSP DCSP DCSP ( old _ lineno , old _ comment ) = translator _ comments.pop ( ) DCNL DCSP DCSP DCSP DCSP DCSP translator _ comments.append ( ( ( old _ lineno + 1 ) , old _ comment ) ) DCNL DCSP DCSP elif ( ( call _ stack &gt; 0 ) and ( tok = = OP ) and ( value = = &apos; ) &apos; ) ) : DCNL DCSP DCSP DCSP call _ stack - = 1 DCNL DCSP DCSP elif ( funcname and ( call _ stack = = ( -1 ) ) ) : DCNL DCSP DCSP DCSP funcname = None DCNL DCSP DCSP elif ( ( tok = = NAME ) and ( value in keywords ) ) : DCNL DCSP DCSP DCSP funcname = value
DCSP elem = ElementMaker ( nsmap = { None : &apos; http : / / www.imsglobal.org / services / ltiv1p1 / xsd / imsoms _ v1p0 &apos; } ) DCNL DCSP xml = elem.imsx _ POXEnvelopeRequest ( elem.imsx _ POXHeader ( elem.imsx _ POXRequestHeaderInfo ( elem.imsx _ version ( &apos; V1.0 &apos; ) , elem.imsx _ messageIdentifier ( str ( uuid.uuid4 ( ) ) ) ) ) , elem.imsx _ POXBody ( elem.replaceResultRequest ( elem.resultRecord ( elem.sourcedGUID ( elem.sourcedId ( result _ sourcedid ) ) , elem.result ( elem.resultScore ( elem.language ( &apos; en &apos; ) , elem.textString ( str ( score ) ) ) ) ) ) ) ) DCNL DCSP return etree.tostring ( xml , xml _ declaration = True , encoding = &apos; UTF-8 &apos; )
DCSP if ( &apos; input _ reader &apos; not in mapper _ spec.params ) : DCNL DCSP DCSP message = &quot; Input DCSP reader &apos;s DCSP parameters DCSP should DCSP be DCSP specified DCSP in DCSP input _ reader DCSP subdictionary . &quot; DCNL DCSP DCSP if allowed _ keys : DCNL DCSP DCSP DCSP raise errors.BadReaderParamsError ( message ) DCNL DCSP DCSP params = mapper _ spec.params DCNL DCSP DCSP params = dict ( ( ( str ( n ) , v ) for ( n , v ) in params.iteritems ( ) ) ) DCNL DCSP else : DCNL DCSP DCSP if ( not isinstance ( mapper _ spec.params.get ( &apos; input _ reader &apos; ) , dict ) ) : DCNL DCSP DCSP DCSP raise errors.BadReaderParamsError ( &apos; Input DCSP reader DCSP parameters DCSP should DCSP be DCSP a DCSP dictionary &apos; ) DCNL DCSP DCSP params = mapper _ spec.params.get ( &apos; input _ reader &apos; ) DCNL DCSP DCSP params = dict ( ( ( str ( n ) , v ) for ( n , v ) in params.iteritems ( ) ) ) DCNL DCSP DCSP if allowed _ keys : DCNL DCSP DCSP DCSP params _ diff = ( set ( params.keys ( ) ) - allowed _ keys ) DCNL DCSP DCSP DCSP if params _ diff : DCNL DCSP DCSP DCSP DCSP raise errors.BadReaderParamsError ( ( &apos; Invalid DCSP input _ reader DCSP parameters : DCSP % s &apos; % &apos; , &apos; .join ( params _ diff ) ) ) DCNL DCSP return params
DCSP gitfs = salt.utils.gitfs.GitFS ( _ _ opts _ _ ) DCNL DCSP gitfs.init _ remotes ( _ _ opts _ _ &#91; &apos; gitfs _ remotes &apos; &#93; , PER _ REMOTE _ OVERRIDES , PER _ REMOTE _ ONLY ) DCNL DCSP return gitfs.dir _ list ( load )
DCSP def update _ certs _ for _ domain _ matches ( candidate _ lineage , rv ) : DCNL DCSP DCSP &apos; Return DCSP cert DCSP as DCSP identical _ names _ cert DCSP if DCSP it DCSP matches , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP or DCSP subset _ names _ cert DCSP if DCSP it DCSP matches DCSP as DCSP subset \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP ( identical _ names _ cert , subset _ names _ cert ) = rv DCNL DCSP DCSP candidate _ names = set ( candidate _ lineage.names ( ) ) DCNL DCSP DCSP if ( candidate _ names = = set ( domains ) ) : DCNL DCSP DCSP DCSP identical _ names _ cert = candidate _ lineage DCNL DCSP DCSP elif candidate _ names.issubset ( set ( domains ) ) : DCNL DCSP DCSP DCSP if ( subset _ names _ cert is None ) : DCNL DCSP DCSP DCSP DCSP subset _ names _ cert = candidate _ lineage DCNL DCSP DCSP DCSP elif ( len ( candidate _ names ) &gt; len ( subset _ names _ cert.names ( ) ) ) : DCNL DCSP DCSP DCSP DCSP subset _ names _ cert = candidate _ lineage DCNL DCSP DCSP return ( identical _ names _ cert , subset _ names _ cert ) DCNL DCSP return _ search _ lineages ( config , update _ certs _ for _ domain _ matches , ( None , None ) )
DCSP return &#91; ( &apos; \ n &apos; .join ( sub _ block ) + &apos; \ n &apos; ) for sub _ block in block &#93;
DCSP return evaluate.EmptyObject ( elementNode )
DCSP def inner ( text ) : DCNL DCSP DCSP return colorizer.colorize ( color , text ) DCNL DCSP return inner
DCSP return isinstance ( exp , Var )
DCSP if warning _ level : DCNL DCSP DCSP warning _ level = int ( warning _ level ) DCNL DCSP return HTTPExceptionHandler ( app , warning _ level = warning _ level )
DCSP if ( not s ) : DCNL DCSP DCSP raise InvalidRomanNumeralError , &apos; Input DCSP can DCSP not DCSP be DCSP blank &apos; DCNL DCSP if ( not romanNumeralPattern.search ( s ) ) : DCNL DCSP DCSP raise InvalidRomanNumeralError , ( &apos; Invalid DCSP Roman DCSP numeral : DCSP % s &apos; % s ) DCNL DCSP result = 0 DCNL DCSP index = 0 DCNL DCSP for ( numeral , integer ) in romanNumeralMap : DCNL DCSP DCSP while ( s &#91; index : ( index + len ( numeral ) ) &#93; = = numeral ) : DCNL DCSP DCSP DCSP result + = integer DCNL DCSP DCSP DCSP index + = len ( numeral ) DCNL DCSP return result
DCSP canvas = FigureCanvasGDK ( figure ) DCNL DCSP manager = FigureManagerBase ( canvas , num ) DCNL DCSP return manager
DCSP if ( bbox is None ) : DCNL DCSP DCSP return wx.BitmapFromImage ( _ py _ convert _ agg _ to _ wx _ image ( agg , None ) ) DCNL DCSP else : DCNL DCSP DCSP return _ clipped _ image _ as _ bitmap ( _ py _ convert _ agg _ to _ wx _ image ( agg , None ) , bbox )
DCSP client _ method = ClientMethod DCNL DCSP params = Params DCNL DCSP expires _ in = ExpiresIn DCNL DCSP http _ method = HttpMethod DCNL DCSP request _ signer = self . _ request _ signer DCNL DCSP serializer = self . _ serializer DCNL DCSP try : DCNL DCSP DCSP operation _ name = self . _ PY _ TO _ OP _ NAME &#91; client _ method &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP raise UnknownClientMethodError ( method _ name = client _ method ) DCNL DCSP operation _ model = self.meta.service _ model.operation _ model ( operation _ name ) DCNL DCSP request _ dict = serializer.serialize _ to _ request ( params , operation _ model ) DCNL DCSP if ( http _ method is not None ) : DCNL DCSP DCSP request _ dict &#91; &apos; method &apos; &#93; = http _ method DCNL DCSP prepare _ request _ dict ( request _ dict , endpoint _ url = self.meta.endpoint _ url ) DCNL DCSP return request _ signer.generate _ presigned _ url ( request _ dict = request _ dict , expires _ in = expires _ in , operation _ name = operation _ name )
DCSP if ( indexer _ id is None ) : DCNL DCSP DCSP return { } DCNL DCSP indexer _ id = int ( indexer _ id ) DCNL DCSP indexer = int ( indexer ) DCNL DCSP result = { } DCNL DCSP for dbData in &#91; x &#91; u &apos;doc &apos; &#93; for x in sickrage.srCore.mainDB.db.get _ many ( u &apos;scene _ numbering &apos; , indexer _ id , with _ doc = True ) &#93; : DCNL DCSP DCSP season = int ( ( dbData &#91; u &apos;season &apos; &#93; or 0 ) ) DCNL DCSP DCSP episode = int ( ( dbData &#91; u &apos;episode &apos; &#93; or 0 ) ) DCNL DCSP DCSP scene _ season = int ( ( dbData &#91; u &apos;scene _ season &apos; &#93; or 0 ) ) DCNL DCSP DCSP scene _ episode = int ( ( dbData &#91; u &apos;scene _ episode &apos; &#93; or 0 ) ) DCNL DCSP DCSP if ( ( int ( dbData &#91; u &apos;indexer &apos; &#93; ) ! = indexer ) or ( ( scene _ season or scene _ episode ) = = 0 ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP result &#91; ( season , episode ) &#93; = ( scene _ season , scene _ episode ) DCNL DCSP return result
DCSP return &apos; &apos;.join ( ( random.choice ( source ) for i in range ( length ) ) )
DCSP ret = { &apos; name &apos; : name , &apos; result &apos; : None , &apos; comment &apos; : &apos; &apos; , &apos; changes &apos; : { } } DCNL DCSP try : DCNL DCSP DCSP pip _ list = _ _ salt _ _ &#91; &apos; pip.list &apos; &#93; ( bin _ env = bin _ env , user = user , cwd = cwd ) DCNL DCSP except ( CommandExecutionError , CommandNotFoundError ) as err : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &quot; Error DCSP uninstalling DCSP &apos; { 0 } &apos; : DCSP { 1 } &quot; .format ( name , err ) DCNL DCSP DCSP return ret DCNL DCSP if ( name not in pip _ list ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Package DCSP is DCSP not DCSP installed . &apos; DCNL DCSP DCSP return ret DCNL DCSP if _ _ opts _ _ &#91; &apos; test &apos; &#93; : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = None DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Package DCSP { 0 } DCSP is DCSP set DCSP to DCSP be DCSP removed &apos; .format ( name ) DCNL DCSP DCSP return ret DCNL DCSP if _ _ salt _ _ &#91; &apos; pip.uninstall &apos; &#93; ( pkgs = name , requirements = requirements , bin _ env = bin _ env , log = log , proxy = proxy , timeout = timeout , user = user , cwd = cwd , use _ vt = use _ vt ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = True DCNL DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; name &#93; = &apos; Removed &apos; DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Package DCSP was DCSP successfully DCSP removed . &apos; DCNL DCSP else : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; Could DCSP not DCSP remove DCSP package . &apos; DCNL DCSP return ret
DCSP enqueue ( u &apos;frappe.integrations.doctype.dropbox _ settings.dropbox _ settings.take _ backup _ to _ dropbox &apos; , queue = u &apos;long &apos; ) DCNL DCSP frappe.msgprint ( _ ( u &apos;Queued DCSP for DCSP backup . DCSP It DCSP may DCSP take DCSP a DCSP few DCSP minutes DCSP to DCSP an DCSP hour . &apos; ) )
DCSP settings = getattr ( options , &apos; settings &apos; , DEFAULT _ SETTINGS ) DCNL DCSP asset _ settings = getattr ( options , &apos; asset _ settings &apos; , settings ) DCNL DCSP worker _ settings = getattr ( options , &apos; worker _ settings &apos; , &apos; dev _ with _ worker &apos; ) DCNL DCSP fast = getattr ( options , &apos; fast &apos; , False ) DCNL DCSP optimized = getattr ( options , &apos; optimized &apos; , False ) DCNL DCSP if optimized : DCNL DCSP DCSP settings = OPTIMIZED _ SETTINGS DCNL DCSP DCSP asset _ settings = OPTIMIZED _ ASSETS _ SETTINGS DCNL DCSP settings _ lms = getattr ( options , &apos; settings _ lms &apos; , settings ) DCNL DCSP settings _ cms = getattr ( options , &apos; settings _ cms &apos; , settings ) DCNL DCSP asset _ settings _ lms = getattr ( options , &apos; asset _ settings _ lms &apos; , asset _ settings ) DCNL DCSP asset _ settings _ cms = getattr ( options , &apos; asset _ settings _ cms &apos; , asset _ settings ) DCNL DCSP if ( not fast ) : DCNL DCSP DCSP args = &#91; &apos; lms &apos; , &apos; studio &apos; , &apos; --settings = { } &apos; .format ( asset _ settings ) , &apos; --skip-collect &apos; &#93; DCNL DCSP DCSP call _ task ( &apos; pavelib.assets.update _ assets &apos; , args = args ) DCNL DCSP DCSP if ( settings ! = DEFAULT _ SETTINGS ) : DCNL DCSP DCSP DCSP collect _ assets ( &#91; &apos; lms &apos; &#93; , asset _ settings _ lms ) DCNL DCSP DCSP DCSP collect _ assets ( &#91; &apos; studio &apos; &#93; , asset _ settings _ cms ) DCNL DCSP DCSP call _ task ( &apos; pavelib.assets.watch _ assets &apos; , options = { &apos; background &apos; : True } ) DCNL DCSP lms _ port = DEFAULT _ PORT &#91; &apos; lms &apos; &#93; DCNL DCSP cms _ port = DEFAULT _ PORT &#91; &apos; studio &apos; &#93; DCNL DCSP lms _ runserver _ args = &#91; &apos; 0.0.0.0 : { } &apos; .format ( lms _ port ) &#93; DCNL DCSP cms _ runserver _ args = &#91; &apos; 0.0.0.0 : { } &apos; .format ( cms _ port ) &#93; DCNL DCSP run _ multi _ processes ( &#91; django _ cmd ( &apos; lms &apos; , settings _ lms , &apos; runserver &apos; , &apos; --traceback &apos; , &apos; --pythonpath = . &apos; , * lms _ runserver _ args ) , django _ cmd ( &apos; studio &apos; , settings _ cms , &apos; runserver &apos; , &apos; --traceback &apos; , &apos; --pythonpath = . &apos; , * cms _ runserver _ args ) , django _ cmd ( &apos; lms &apos; , worker _ settings , &apos; celery &apos; , &apos; worker &apos; , &apos; --beat &apos; , &apos; --loglevel = INFO &apos; , &apos; --pythonpath = . &apos; ) &#93; )
DCSP if ( not hasattr ( obj , &apos; _ info _ axis _ number &apos; ) ) : DCNL DCSP DCSP raise TypeError ( ( &apos; object DCSP of DCSP type DCSP % r DCSP has DCSP no DCSP info DCSP axis &apos; % type ( obj ) . _ _ name _ _ ) ) DCNL DCSP slices = ( &#91; slice ( None ) &#93; * obj.ndim ) DCNL DCSP slices &#91; obj . _ info _ axis _ number &#93; = indexer DCNL DCSP return tuple ( slices )
DCSP sz = getattr ( devmem , &apos; _ cuda _ memsize _ &apos; , None ) DCNL DCSP if ( sz is None ) : DCNL DCSP DCSP ( s , e ) = device _ extents ( devmem ) DCNL DCSP DCSP sz = ( e - s ) DCNL DCSP DCSP devmem . _ cuda _ memsize _ = sz DCNL DCSP assert ( sz &gt; 0 ) , &apos; zero DCSP length DCSP array &apos; DCNL DCSP return sz
DCSP ( _ , rest ) = token.contents.split ( None , 1 ) DCNL DCSP filter _ expr = parser.compile _ filter ( ( &apos; var &#124; % s &apos; % rest ) ) DCNL DCSP for ( func , unused ) in filter _ expr.filters : DCNL DCSP DCSP filter _ name = getattr ( func , &apos; _ filter _ name &apos; , None ) DCNL DCSP DCSP if ( filter _ name in ( &apos; escape &apos; , &apos; safe &apos; ) ) : DCNL DCSP DCSP DCSP raise TemplateSyntaxError ( ( &apos; &quot; filter DCSP % s &quot; DCSP is DCSP not DCSP permitted . DCSP DCSP Use DCSP the DCSP &quot; autoescape &quot; DCSP tag DCSP instead . &apos; % filter _ name ) ) DCNL DCSP nodelist = parser.parse ( ( &apos; endfilter &apos; , ) ) DCNL DCSP parser.delete _ first _ token ( ) DCNL DCSP return FilterNode ( filter _ expr , nodelist )
DCSP rpc = apiproxy _ stub _ map.UserRPC ( &apos; taskqueue &apos; ) DCNL DCSP request = taskqueue _ service _ pb.TaskQueueFetchQueuesRequest ( ) DCNL DCSP response = taskqueue _ service _ pb.TaskQueueFetchQueuesResponse ( ) DCNL DCSP if app _ id : DCNL DCSP DCSP request.set _ app _ id ( app _ id ) DCNL DCSP request.set _ max _ rows ( max _ rows ) DCNL DCSP queues = &#91; &apos; default &apos; &#93; DCNL DCSP try : DCNL DCSP DCSP rpc.make _ call ( &apos; FetchQueues &apos; , request , response ) DCNL DCSP DCSP rpc.check _ success ( ) DCNL DCSP DCSP for queue in response.queue _ list ( ) : DCNL DCSP DCSP DCSP if ( ( queue.mode ( ) = = taskqueue _ service _ pb.TaskQueueMode.PUSH ) and ( not queue.queue _ name ( ) .startswith ( &apos; _ _ &apos; ) ) and ( queue.queue _ name ( ) ! = &apos; default &apos; ) ) : DCNL DCSP DCSP DCSP DCSP queues.append ( queue.queue _ name ( ) ) DCNL DCSP except Exception : DCNL DCSP DCSP logging.exception ( &apos; Failed DCSP to DCSP get DCSP queue DCSP names . &apos; ) DCNL DCSP return queues
DCSP query = request.args.to _ dict ( ) DCNL DCSP query &#91; &apos; view _ only &apos; &#93; = key DCNL DCSP replacements = { &apos; query &apos; : urllib.urlencode ( query ) } DCNL DCSP if scheme : DCNL DCSP DCSP replacements &#91; &apos; scheme &apos; &#93; = scheme DCNL DCSP parsed _ url = urlparse.urlparse ( url ) DCNL DCSP if parsed _ url.fragment : DCNL DCSP DCSP replacements &#91; &apos; path &apos; &#93; = &apos; { } % 23 { } &apos; .format ( parsed _ url.path , parsed _ url.fragment ) DCNL DCSP DCSP replacements &#91; &apos; fragment &apos; &#93; = &apos; &apos; DCNL DCSP parsed _ redirect _ url = parsed _ url . _ replace ( * * replacements ) DCNL DCSP return urlparse.urlunparse ( parsed _ redirect _ url )
DCSP if ( not any ( ( route _ table _ name , route _ table _ id ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specified : DCSP route DCSP table DCSP name DCSP or DCSP route DCSP table DCSP id . &apos; ) DCNL DCSP if ( not any ( ( gateway _ id , instance _ id , interface _ id , vpc _ peering _ connection _ id ) ) ) : DCNL DCSP DCSP raise SaltInvocationError ( &apos; At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specified : DCSP gateway DCSP id , DCSP instance DCSP id , DCSP interface DCSP id DCSP or DCSP VPC DCSP peering DCSP connection DCSP id . &apos; ) DCNL DCSP try : DCNL DCSP DCSP conn = _ get _ conn ( region = region , key = key , keyid = keyid , profile = profile ) DCNL DCSP DCSP filter _ parameters = { &apos; filters &apos; : { } } DCNL DCSP DCSP if route _ table _ id : DCNL DCSP DCSP DCSP filter _ parameters &#91; &apos; route _ table _ ids &apos; &#93; = &#91; route _ table _ id &#93; DCNL DCSP DCSP if route _ table _ name : DCNL DCSP DCSP DCSP filter _ parameters &#91; &apos; filters &apos; &#93; &#91; &apos; tag : Name &apos; &#93; = route _ table _ name DCNL DCSP DCSP if tags : DCNL DCSP DCSP DCSP for ( tag _ name , tag _ value ) in six.iteritems ( tags ) : DCNL DCSP DCSP DCSP DCSP filter _ parameters &#91; &apos; filters &apos; &#93; &#91; &apos; tag : { 0 } &apos; .format ( tag _ name ) &#93; = tag _ value DCNL DCSP DCSP route _ tables = conn.get _ all _ route _ tables ( * * filter _ parameters ) DCNL DCSP DCSP if ( len ( route _ tables ) ! = 1 ) : DCNL DCSP DCSP DCSP raise SaltInvocationError ( &apos; Found DCSP more DCSP than DCSP one DCSP route DCSP table . &apos; ) DCNL DCSP DCSP route _ check = { &apos; destination _ cidr _ block &apos; : destination _ cidr _ block , &apos; gateway _ id &apos; : gateway _ id , &apos; instance _ id &apos; : instance _ id , &apos; interface _ id &apos; : interface _ id , &apos; vpc _ peering _ connection _ id &apos; : vpc _ peering _ connection _ id } DCNL DCSP DCSP for route _ match in route _ tables &#91; 0 &#93; .routes : DCNL DCSP DCSP DCSP route _ dict = { &apos; destination _ cidr _ block &apos; : route _ match.destination _ cidr _ block , &apos; gateway _ id &apos; : route _ match.gateway _ id , &apos; instance _ id &apos; : route _ match.instance _ id , &apos; interface _ id &apos; : route _ match.interface _ id , &apos; vpc _ peering _ connection _ id &apos; : vpc _ peering _ connection _ id } DCNL DCSP DCSP DCSP route _ comp = ( set ( route _ dict.items ( ) ) ^ set ( route _ check.items ( ) ) ) DCNL DCSP DCSP DCSP if ( len ( route _ comp ) = = 0 ) : DCNL DCSP DCSP DCSP DCSP log.info ( &apos; Route DCSP { 0 } DCSP exists . &apos; .format ( destination _ cidr _ block ) ) DCNL DCSP DCSP DCSP DCSP return { &apos; exists &apos; : True } DCNL DCSP DCSP log.warning ( &apos; Route DCSP { 0 } DCSP does DCSP not DCSP exist . &apos; .format ( destination _ cidr _ block ) ) DCNL DCSP DCSP return { &apos; exists &apos; : False } DCNL DCSP except BotoServerError as e : DCNL DCSP DCSP return { &apos; error &apos; : salt.utils.boto.get _ error ( e ) }
DCSP def wrapper ( f ) : DCNL DCSP DCSP @ functools.wraps ( f ) DCNL DCSP DCSP def inner ( self , request , * args , * * kwargs ) : DCNL DCSP DCSP DCSP request.assert _ authenticated ( ) DCNL DCSP DCSP DCSP if request.context.is _ admin : DCNL DCSP DCSP DCSP DCSP LOG.warning ( _ LW ( &apos; RBAC : DCSP Bypassing DCSP authorization &apos; ) ) DCNL DCSP DCSP DCSP elif ( callback is not None ) : DCNL DCSP DCSP DCSP DCSP prep _ info = { &apos; f _ name &apos; : f . _ _ name _ _ , &apos; input _ attr &apos; : kwargs } DCNL DCSP DCSP DCSP DCSP callback ( self , request , prep _ info , * args , * * kwargs ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP action = ( &apos; identity : % s &apos; % f . _ _ name _ _ ) DCNL DCSP DCSP DCSP DCSP creds = _ build _ policy _ check _ credentials ( self , action , request.context _ dict , kwargs ) DCNL DCSP DCSP DCSP DCSP policy _ dict = { } DCNL DCSP DCSP DCSP DCSP if ( hasattr ( self , &apos; get _ member _ from _ driver &apos; ) and ( self.get _ member _ from _ driver is not None ) ) : DCNL DCSP DCSP DCSP DCSP DCSP key = ( &apos; % s _ id &apos; % self.member _ name ) DCNL DCSP DCSP DCSP DCSP DCSP if ( key in kwargs ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ref = self.get _ member _ from _ driver ( kwargs &#91; key &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; = { self.member _ name : ref } DCNL DCSP DCSP DCSP DCSP if ( request.context _ dict.get ( &apos; subject _ token _ id &apos; ) is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP window _ seconds = self . _ token _ validation _ window ( request ) DCNL DCSP DCSP DCSP DCSP DCSP token _ ref = token _ model.KeystoneToken ( token _ id = request.context _ dict &#91; &apos; subject _ token _ id &apos; &#93; , token _ data = self.token _ provider _ api.validate _ token ( request.context _ dict &#91; &apos; subject _ token _ id &apos; &#93; , window _ seconds = window _ seconds ) ) DCNL DCSP DCSP DCSP DCSP DCSP policy _ dict.setdefault ( &apos; target &apos; , { } ) DCNL DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; .setdefault ( self.member _ name , { } ) DCNL DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; &#91; self.member _ name &#93; &#91; &apos; user _ id &apos; &#93; = token _ ref.user _ id DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP user _ domain _ id = token _ ref.user _ domain _ id DCNL DCSP DCSP DCSP DCSP DCSP except exception.UnexpectedError : DCNL DCSP DCSP DCSP DCSP DCSP DCSP user _ domain _ id = None DCNL DCSP DCSP DCSP DCSP DCSP if user _ domain _ id : DCNL DCSP DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; &#91; self.member _ name &#93; .setdefault ( &apos; user &apos; , { } ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; &#91; self.member _ name &#93; &#91; &apos; user &apos; &#93; .setdefault ( &apos; domain &apos; , { } ) DCNL DCSP DCSP DCSP DCSP DCSP DCSP policy _ dict &#91; &apos; target &apos; &#93; &#91; self.member _ name &#93; &#91; &apos; user &apos; &#93; &#91; &apos; domain &apos; &#93; &#91; &apos; id &apos; &#93; = user _ domain _ id DCNL DCSP DCSP DCSP DCSP policy _ dict.update ( kwargs ) DCNL DCSP DCSP DCSP DCSP self.policy _ api.enforce ( creds , action , utils.flatten _ dict ( policy _ dict ) ) DCNL DCSP DCSP DCSP DCSP LOG.debug ( &apos; RBAC : DCSP Authorization DCSP granted &apos; ) DCNL DCSP DCSP DCSP return f ( self , request , * args , * * kwargs ) DCNL DCSP DCSP return inner DCNL DCSP return wrapper
DCSP parts = domain.split ( &apos; .&apos; ) DCNL DCSP for i in range ( len ( parts ) , 1 , ( -1 ) ) : DCNL DCSP DCSP ( yield &apos; .&apos;.join ( parts &#91; ( - i ) : &#93; ) )
DCSP return ( time.time ( ) - start )
DCSP for ( parent , subdirs , files ) in os.walk ( start _ dir ) : DCNL DCSP DCSP if any ( ( f for f in files if ( f.endswith ( suffix ) and ( f not in blacklist ) ) ) ) : DCNL DCSP DCSP DCSP del subdirs &#91; : &#93; DCNL DCSP DCSP DCSP ( yield parent ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP subdirs &#91; : &#93; = &#91; s for s in subdirs if ( s &#91; 0 &#93; .isalpha ( ) and ( os.path.join ( parent , s ) not in blacklist ) ) &#93;
DCSP if ( ( self.parser is None ) or ( not self.default _ tag ) ) : DCNL DCSP DCSP return option.help DCNL DCSP optname = option . _ long _ opts &#91; 0 &#93; &#91; 2 : &#93; DCNL DCSP try : DCNL DCSP DCSP provider = self.parser.options _ manager . _ all _ options &#91; optname &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP value = None DCNL DCSP else : DCNL DCSP DCSP optdict = provider.get _ option _ def ( optname ) DCNL DCSP DCSP optname = provider.option _ attrname ( optname , optdict ) DCNL DCSP DCSP value = getattr ( provider.config , optname , optdict ) DCNL DCSP DCSP value = format _ option _ value ( optdict , value ) DCNL DCSP if ( ( value is optik _ ext.NO _ DEFAULT ) or ( not value ) ) : DCNL DCSP DCSP value = self.NO _ DEFAULT _ VALUE DCNL DCSP return option.help.replace ( self.default _ tag , str ( value ) )
DCSP def decorator ( f ) : DCNL DCSP DCSP attrs.setdefault ( &apos; prompt &apos; , True ) DCNL DCSP DCSP attrs.setdefault ( &apos; confirmation _ prompt &apos; , True ) DCNL DCSP DCSP attrs.setdefault ( &apos; hide _ input &apos; , True ) DCNL DCSP DCSP return option ( * ( param _ decls or ( &apos; --password &apos; , ) ) , * * attrs ) ( f ) DCNL DCSP return decorator
DCSP cmd = &apos; / etc / rc.d / { 0 } DCSP -f DCSP stop &apos; .format ( name ) DCNL DCSP return ( not _ _ salt _ _ &#91; &apos; cmd.retcode &apos; &#93; ( cmd ) )
DCSP if ( ( foo is not None ) and ( foo ! = &apos; wat &apos; ) ) : DCNL DCSP DCSP raise click.BadParameter ( &apos; If DCSP a DCSP value DCSP is DCSP provided DCSP it DCSP needs DCSP to DCSP be DCSP the DCSP value DCSP &quot; wat &quot; . &apos; , param _ hint = &#91; &apos; --foo &apos; &#93; ) DCNL DCSP click.echo ( ( &apos; count : DCSP % s &apos; % count ) ) DCNL DCSP click.echo ( ( &apos; foo : DCSP % s &apos; % foo ) ) DCNL DCSP click.echo ( ( &apos; url : DCSP % s &apos; % repr ( url ) ) )
DCSP def showWarning ( message , category , filename , lineno , file = None , line = None ) : DCNL DCSP DCSP assert isinstance ( message , Warning ) DCNL DCSP DCSP observeWarning ( _ Warning ( message.args &#91; 0 &#93; , category , filename , lineno ) ) DCNL DCSP for v in sys.modules.itervalues ( ) : DCNL DCSP DCSP if ( v is not None ) : DCNL DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP v. _ _ warningregistry _ _ = None DCNL DCSP DCSP DCSP except : DCNL DCSP DCSP DCSP DCSP pass DCNL DCSP origFilters = warnings.filters &#91; : &#93; DCNL DCSP origShow = warnings.showwarning DCNL DCSP warnings.simplefilter ( &apos; always &apos; ) DCNL DCSP try : DCNL DCSP DCSP warnings.showwarning = showWarning DCNL DCSP DCSP result = f ( * args , * * kwargs ) DCNL DCSP finally : DCNL DCSP DCSP warnings.filters &#91; : &#93; = origFilters DCNL DCSP DCSP warnings.showwarning = origShow DCNL DCSP return result
DCSP comment _ dict = { } DCNL DCSP if interfilediff : DCNL DCSP DCSP key = ( filediff.pk , interfilediff.pk ) DCNL DCSP else : DCNL DCSP DCSP key = ( filediff.pk , None ) DCNL DCSP comments = all _ comments.get ( key , &#91; &#93; ) DCNL DCSP for comment in comments : DCNL DCSP DCSP review = comment.get _ review ( ) DCNL DCSP DCSP if ( review and ( review.public or ( review.user = = user ) ) ) : DCNL DCSP DCSP DCSP key = ( comment.first _ line , comment.num _ lines ) DCNL DCSP DCSP DCSP comment _ dict.setdefault ( key , &#91; &#93; ) .append ( { u &apos;comment _ id &apos; : comment.id , u &apos;text &apos; : normalize _ text _ for _ edit ( user , comment.text , comment.rich _ text ) , u &apos;html &apos; : markdown _ render _ conditional ( comment.text , comment.rich _ text ) , u &apos;rich _ text &apos; : comment.rich _ text , u &apos;line &apos; : comment.first _ line , u &apos;num _ lines &apos; : comment.num _ lines , u &apos;user &apos; : { u &apos;username &apos; : review.user.username , u &apos;name &apos; : ( review.user.get _ full _ name ( ) or review.user.username ) } , u &apos;url &apos; : comment.get _ review _ url ( ) , u &apos;localdraft &apos; : ( ( review.user = = user ) and ( not review.public ) ) , u &apos;review _ id &apos; : review.id , u &apos;issue _ opened &apos; : comment.issue _ opened , u &apos;issue _ status &apos; : BaseComment.issue _ status _ to _ string ( comment.issue _ status ) , u &apos;reply _ to _ id &apos; : comment.reply _ to _ id } ) DCNL DCSP comments _ array = &#91; &#93; DCNL DCSP for ( key , value ) in six.iteritems ( comment _ dict ) : DCNL DCSP DCSP comments _ array.append ( { u &apos;linenum &apos; : key &#91; 0 &#93; , u &apos;num _ lines &apos; : key &#91; 1 &#93; , u &apos;comments &apos; : value } ) DCNL DCSP comments _ array.sort ( cmp = ( lambda x , y : cmp ( x &#91; u &apos;linenum &apos; &#93; , ( y &#91; u &apos;linenum &apos; &#93; or cmp ( x &#91; u &apos;num _ lines &apos; &#93; , y &#91; u &apos;num _ lines &apos; &#93; ) ) ) ) ) DCNL DCSP return comments _ array
DCSP return s3db.req _ match ( )
DCSP purine = ( &apos; A &apos; , &apos; G &apos; ) DCNL DCSP pyrimidine = ( &apos; C &apos; , &apos; T &apos; ) DCNL DCSP TV = &#91; 0 , 0 &#93; DCNL DCSP sites = 0 DCNL DCSP for ( codon1 , codon2 ) in zip ( codon _ lst1 , codon _ lst2 ) : DCNL DCSP DCSP if ( &apos; --- &apos; not in ( codon1 , codon2 ) ) : DCNL DCSP DCSP DCSP for ( i , j ) in zip ( codon1 , codon2 ) : DCNL DCSP DCSP DCSP DCSP if ( i = = j ) : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP DCSP elif ( ( i in purine ) and ( j in purine ) ) : DCNL DCSP DCSP DCSP DCSP DCSP TV &#91; 0 &#93; + = 1 DCNL DCSP DCSP DCSP DCSP elif ( ( i in pyrimidine ) and ( j in pyrimidine ) ) : DCNL DCSP DCSP DCSP DCSP DCSP TV &#91; 0 &#93; + = 1 DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP TV &#91; 1 &#93; + = 1 DCNL DCSP DCSP DCSP DCSP sites + = 1 DCNL DCSP return ( ( TV &#91; 0 &#93; / sites ) , ( TV &#91; 1 &#93; / sites ) )
DCSP ctx = ssl.create _ default _ context ( ) DCNL DCSP ctx.check _ hostname = False DCNL DCSP ctx.load _ verify _ locations ( cafile = &apos; ssl / cacert.pem &apos; ) DCNL DCSP ctx.verify _ mode = ssl.CERT _ REQUIRED DCNL DCSP url = &apos; https : / / { } : 8500 / v1 / health / state / any &apos; .format ( node _ address ) DCNL DCSP request = urllib2.Request ( url ) DCNL DCSP auth = ( &apos; Basic DCSP &apos; + base64.b64encode ( get _ credentials ( ) ) ) DCNL DCSP request.add _ header ( &apos; Authorization &apos; , auth ) DCNL DCSP f = urllib2.urlopen ( request , None , timeout , context = ctx ) DCNL DCSP checks = json.loads ( f.read ( ) .decode ( &apos; utf8 &apos; ) ) DCNL DCSP return &#91; c for c in checks if ( c.get ( &apos; Status &apos; , &apos; &apos; ) .lower ( ) ! = &apos; passing &apos; ) &#93;
DCSP start = int ( ( batch _ nb * batch _ size ) ) DCNL DCSP end = int ( ( ( batch _ nb + 1 ) * batch _ size ) ) DCNL DCSP if ( end &gt; data _ length ) : DCNL DCSP DCSP shift = ( end - data _ length ) DCNL DCSP DCSP start - = shift DCNL DCSP DCSP end - = shift DCNL DCSP return ( start , end )
DCSP if ( d.get ( u &apos;name &apos; ) and frappe.db.exists ( doctype , d &#91; u &apos;name &apos; &#93; ) ) : DCNL DCSP DCSP if overwrite : DCNL DCSP DCSP DCSP doc = frappe.get _ doc ( doctype , d &#91; u &apos;name &apos; &#93; ) DCNL DCSP DCSP DCSP doc.flags.ignore _ links = ignore _ links DCNL DCSP DCSP DCSP doc.update ( d ) DCNL DCSP DCSP DCSP if ( d.get ( u &apos;docstatus &apos; ) = = 1 ) : DCNL DCSP DCSP DCSP DCSP doc.update _ after _ submit ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP doc.save ( ) DCNL DCSP DCSP DCSP return ( u &apos;Updated DCSP row DCSP ( # % d ) DCSP % s &apos; % ( ( row _ idx + 1 ) , getlink ( doctype , d &#91; u &apos;name &apos; &#93; ) ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( u &apos;Ignored DCSP row DCSP ( # % d ) DCSP % s DCSP ( exists ) &apos; % ( ( row _ idx + 1 ) , getlink ( doctype , d &#91; u &apos;name &apos; &#93; ) ) ) DCNL DCSP else : DCNL DCSP DCSP doc = frappe.get _ doc ( d ) DCNL DCSP DCSP doc.flags.ignore _ links = ignore _ links DCNL DCSP DCSP doc.insert ( ) DCNL DCSP DCSP if submit : DCNL DCSP DCSP DCSP doc.submit ( ) DCNL DCSP DCSP return ( u &apos;Inserted DCSP row DCSP ( # % d ) DCSP % s &apos; % ( ( row _ idx + 1 ) , getlink ( doctype , doc.get ( u &apos;name &apos; ) ) ) )
DCSP config = { 32 : { &apos; byte &apos; : ( 4 , 1 , 255 , &apos; hh &apos; , 8 ) , &apos; short &apos; : ( 2 , 2 , 65535 , &apos; h &apos; , 16 ) , &apos; int &apos; : ( 1 , 4 , 4294967295 , &apos; &apos; , 32 ) } , 64 : { &apos; byte &apos; : ( 8 , 1 , 255 , &apos; hh &apos; , 8 ) , &apos; short &apos; : ( 4 , 2 , 65535 , &apos; h &apos; , 16 ) , &apos; int &apos; : ( 2 , 4 , 4294967295 , &apos; &apos; , 32 ) } } DCNL DCSP if ( write _ size not in &#91; &apos; byte &apos; , &apos; short &apos; , &apos; int &apos; &#93; ) : DCNL DCSP DCSP log.error ( &quot; write _ size DCSP must DCSP be DCSP &apos; byte &apos; , DCSP &apos; short &apos; DCSP or DCSP &apos; int &apos; &quot; ) DCNL DCSP ( number , step , mask , formatz , decalage ) = config &#91; context.bits &#93; &#91; write _ size &#93; DCNL DCSP payload = &apos; &apos; DCNL DCSP for ( where , what ) in writes.items ( ) : DCNL DCSP DCSP for i in range ( 0 , ( number * step ) , step ) : DCNL DCSP DCSP DCSP payload + = pack ( ( where + i ) ) DCNL DCSP numbwritten + = len ( payload ) DCNL DCSP fmtCount = 0 DCNL DCSP for ( where , what ) in writes.items ( ) : DCNL DCSP DCSP for i in range ( 0 , number ) : DCNL DCSP DCSP DCSP current = ( what &amp; mask ) DCNL DCSP DCSP DCSP if ( ( numbwritten &amp; mask ) &lt; = current ) : DCNL DCSP DCSP DCSP DCSP to _ add = ( current - ( numbwritten &amp; mask ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP to _ add = ( ( current &#124; ( mask + 1 ) ) - ( numbwritten &amp; mask ) ) DCNL DCSP DCSP DCSP if ( to _ add ! = 0 ) : DCNL DCSP DCSP DCSP DCSP payload + = &apos; % { } c &apos; .format ( to _ add ) DCNL DCSP DCSP DCSP payload + = &apos; % { } $ { } n &apos; .format ( ( offset + fmtCount ) , formatz ) DCNL DCSP DCSP DCSP numbwritten + = to _ add DCNL DCSP DCSP DCSP what &gt; &gt; = decalage DCNL DCSP DCSP DCSP fmtCount + = 1 DCNL DCSP return payload
DCSP terms = &#91; &#93; DCNL DCSP for node in nodes : DCNL DCSP DCSP terms + = makeTerm ( node , title , term ) DCNL DCSP return terms
DCSP state = salt.utils.mac _ utils.validate _ enabled ( enable ) DCNL DCSP cmd = &apos; systemsetup DCSP -setusingnetworktime DCSP { 0 } &apos; .format ( state ) DCNL DCSP salt.utils.mac _ utils.execute _ return _ success ( cmd ) DCNL DCSP return ( state = = salt.utils.mac _ utils.validate _ enabled ( get _ using _ network _ time ( ) ) )
DCSP ( version , num _ entries ) = read _ header ( stream ) DCNL DCSP count = 0 DCNL DCSP entries = dict ( ) DCNL DCSP read = stream.read DCNL DCSP tell = stream.tell DCNL DCSP while ( count &lt; num _ entries ) : DCNL DCSP DCSP beginoffset = tell ( ) DCNL DCSP DCSP ctime = unpack ( &apos; &gt; 8s &apos; , read ( 8 ) ) &#91; 0 &#93; DCNL DCSP DCSP mtime = unpack ( &apos; &gt; 8s &apos; , read ( 8 ) ) &#91; 0 &#93; DCNL DCSP DCSP ( dev , ino , mode , uid , gid , size , sha , flags ) = unpack ( &apos; &gt; LLLLLL20sH &apos; , read ( ( ( 20 + ( 4 * 6 ) ) + 2 ) ) ) DCNL DCSP DCSP path _ size = ( flags &amp; CE _ NAMEMASK ) DCNL DCSP DCSP path = read ( path _ size ) .decode ( defenc ) DCNL DCSP DCSP real _ size = ( ( ( tell ( ) - beginoffset ) + 8 ) &amp; ( ~ 7 ) ) DCNL DCSP DCSP read ( ( ( beginoffset + real _ size ) - tell ( ) ) ) DCNL DCSP DCSP entry = IndexEntry ( ( mode , sha , flags , path , ctime , mtime , dev , ino , uid , gid , size ) ) DCNL DCSP DCSP entries &#91; ( path , entry.stage ) &#93; = entry DCNL DCSP DCSP count + = 1 DCNL DCSP extension _ data = stream.read ( ( ~ 0 ) ) DCNL DCSP assert ( len ( extension _ data ) &gt; 19 ) , ( &apos; Index DCSP Footer DCSP was DCSP not DCSP at DCSP least DCSP a DCSP sha DCSP on DCSP content DCSP as DCSP it DCSP was DCSP only DCSP % i DCSP bytes DCSP in DCSP size &apos; % len ( extension _ data ) ) DCNL DCSP content _ sha = extension _ data &#91; ( -20 ) : &#93; DCNL DCSP extension _ data = extension _ data &#91; : ( -20 ) &#93; DCNL DCSP return ( version , entries , extension _ data , content _ sha )
DCSP s3 _ deleter.Deleter ( )
DCSP derivation = HeightmapDerivation ( elementNode ) DCNL DCSP heightGrid = derivation.heightGrid DCNL DCSP if ( derivation.fileName ! = &apos; &apos; ) : DCNL DCSP DCSP heightGrid = getHeightGrid ( archive.getAbsoluteFolderPath ( elementNode.getOwnerDocument ( ) .fileName , derivation.fileName ) ) DCNL DCSP return getGeometryOutputByHeightGrid ( derivation , elementNode , heightGrid )
DCSP if ( not os.path.exists ( work _ directory ) ) : DCNL DCSP DCSP os.mkdir ( work _ directory ) DCNL DCSP filepath = os.path.join ( work _ directory , filename ) DCNL DCSP if ( not os.path.exists ( filepath ) ) : DCNL DCSP DCSP ( filepath , _ ) = urllib.urlretrieve ( ( SOURCE _ URL + filename ) , filepath ) DCNL DCSP DCSP statinfo = os.stat ( filepath ) DCNL DCSP DCSP print ( &apos; Succesfully DCSP downloaded &apos; , filename , statinfo.st _ size , &apos; bytes . &apos; ) DCNL DCSP return filepath
DCSP return _ _ salt _ _ &#91; &apos; probes.set _ probes &apos; &#93; ( _ ordered _ dict _ to _ dict ( probes ) , commit = False )
DCSP result = &#91; &#93; DCNL DCSP for child in section.children : DCNL DCSP DCSP if isinstance ( child , nodes.section ) : DCNL DCSP DCSP DCSP result.append ( child ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP result.extend ( find _ subsections ( child ) ) DCNL DCSP return result
DCSP tags = list ( ) DCNL DCSP i = 0 DCNL DCSP list _ of _ tags = list _ of _ tags DCNL DCSP for i in range ( len ( list _ of _ tags ) ) : DCNL DCSP DCSP key _ name = list _ of _ tags &#91; i &#93; &#91; 0 &#93; DCNL DCSP DCSP key _ val = list _ of _ tags &#91; i &#93; &#91; 1 &#93; DCNL DCSP DCSP tags.append ( { &apos; Key &apos; : key _ name , &apos; Value &apos; : key _ val } ) DCNL DCSP return tags
DCSP def _ select _ block ( str _ in , start _ tag , end _ tag ) : DCNL DCSP DCSP &apos; Select DCSP first DCSP block DCSP delimited DCSP by DCSP start _ tag DCSP and DCSP end _ tag &apos; DCNL DCSP DCSP start _ pos = str _ in.find ( start _ tag ) DCNL DCSP DCSP if ( start _ pos &lt; 0 ) : DCNL DCSP DCSP DCSP raise ValueError ( &apos; start _ tag DCSP not DCSP found &apos; ) DCNL DCSP DCSP depth = 0 DCNL DCSP DCSP for pos in range ( start _ pos , len ( str _ in ) ) : DCNL DCSP DCSP DCSP if ( str _ in &#91; pos &#93; = = start _ tag ) : DCNL DCSP DCSP DCSP DCSP depth + = 1 DCNL DCSP DCSP DCSP elif ( str _ in &#91; pos &#93; = = end _ tag ) : DCNL DCSP DCSP DCSP DCSP depth - = 1 DCNL DCSP DCSP DCSP if ( depth = = 0 ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP sel = str _ in &#91; ( start _ pos + 1 ) : pos &#93; DCNL DCSP DCSP return sel DCNL DCSP def _ parse _ dict _ recursive ( dict _ str ) : DCNL DCSP DCSP &apos; Parse DCSP a DCSP dictionary DCSP from DCSP the DCSP search DCSP index &apos; DCNL DCSP DCSP dict _ out = dict ( ) DCNL DCSP DCSP pos _ last = 0 DCNL DCSP DCSP pos = dict _ str.find ( &apos; : &apos; ) DCNL DCSP DCSP while ( pos &gt; = 0 ) : DCNL DCSP DCSP DCSP key = dict _ str &#91; pos _ last : pos &#93; DCNL DCSP DCSP DCSP if ( dict _ str &#91; ( pos + 1 ) &#93; = = &apos; &#91; &apos; ) : DCNL DCSP DCSP DCSP DCSP pos _ tmp = dict _ str.find ( &apos; &#93; &apos; , ( pos + 1 ) ) DCNL DCSP DCSP DCSP DCSP if ( pos _ tmp &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP DCSP raise RuntimeError ( &apos; error DCSP when DCSP parsing DCSP dict &apos; ) DCNL DCSP DCSP DCSP DCSP value = dict _ str &#91; ( pos + 2 ) : pos _ tmp &#93; .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP DCSP for i in range ( len ( value ) ) : DCNL DCSP DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP DCSP value &#91; i &#93; = int ( value &#91; i &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP elif ( dict _ str &#91; ( pos + 1 ) &#93; = = &apos; { &apos; ) : DCNL DCSP DCSP DCSP DCSP subdict _ str = _ select _ block ( dict _ str &#91; pos : &#93; , &apos; { &apos; , &apos; } &apos; ) DCNL DCSP DCSP DCSP DCSP value = _ parse _ dict _ recursive ( subdict _ str ) DCNL DCSP DCSP DCSP DCSP pos _ tmp = ( pos + len ( subdict _ str ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP raise ValueError ( &apos; error DCSP when DCSP parsing DCSP dict : DCSP unknown DCSP elem &apos; ) DCNL DCSP DCSP DCSP key = key.strip ( &apos; &quot; &apos; ) DCNL DCSP DCSP DCSP if ( len ( key ) &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP dict _ out &#91; key &#93; = value DCNL DCSP DCSP DCSP pos _ last = dict _ str.find ( &apos; , &apos; , pos _ tmp ) DCNL DCSP DCSP DCSP if ( pos _ last &lt; 0 ) : DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP DCSP pos _ last + = 1 DCNL DCSP DCSP DCSP pos = dict _ str.find ( &apos; : &apos; , pos _ last ) DCNL DCSP DCSP return dict _ out DCNL DCSP query = &apos; objects : &apos; DCNL DCSP pos = searchindex.find ( query ) DCNL DCSP if ( pos &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; &quot; objects : &quot; DCSP not DCSP found DCSP in DCSP search DCSP index &apos; ) DCNL DCSP sel = _ select _ block ( searchindex &#91; pos : &#93; , &apos; { &apos; , &apos; } &apos; ) DCNL DCSP objects = _ parse _ dict _ recursive ( sel ) DCNL DCSP query = &apos; filenames : &apos; DCNL DCSP pos = searchindex.find ( query ) DCNL DCSP if ( pos &lt; 0 ) : DCNL DCSP DCSP raise ValueError ( &apos; &quot; filenames : &quot; DCSP not DCSP found DCSP in DCSP search DCSP index &apos; ) DCNL DCSP filenames = searchindex &#91; ( ( pos + len ( query ) ) + 1 ) : &#93; DCNL DCSP filenames = filenames &#91; : filenames.find ( &apos; &#93; &apos; ) &#93; DCNL DCSP filenames = &#91; f.strip ( &apos; &quot; &apos; ) for f in filenames.split ( &apos; , &apos; ) &#93; DCNL DCSP return ( filenames , objects )
DCSP search _ path = None DCNL DCSP param _ type = type ( dot _ path _ or _ list ) DCNL DCSP if ( param _ type in ( tuple , list ) ) : DCNL DCSP DCSP search _ path = dot _ path _ or _ list DCNL DCSP elif ( param _ type = = str ) : DCNL DCSP DCSP search _ path = dot _ path _ or _ list.split ( &apos; .&apos; ) DCNL DCSP assert ( len ( search _ path ) &gt; 0 ) , &apos; Missing DCSP valid DCSP search DCSP path &apos; DCNL DCSP try : DCNL DCSP DCSP current _ item = data _ structure DCNL DCSP DCSP for search _ key in search _ path : DCNL DCSP DCSP DCSP current _ item = current _ item &#91; search _ key &#93; DCNL DCSP except ( KeyError , IndexError , TypeError ) : DCNL DCSP DCSP return default _ value DCNL DCSP return current _ item
DCSP bkts = sorted ( bkts , key = ( lambda bkt : bkt.value ) ) DCNL DCSP for i in range ( len ( bkts ) ) : DCNL DCSP DCSP if ( not sufficient _ funds ( bkts &#91; ( i + 1 ) : &#93; ) ) : DCNL DCSP DCSP DCSP return bkts &#91; i : &#93; DCNL DCSP return bkts
DCSP log ( &apos; -&apos; , cmd ) DCNL DCSP cmd = cmd.split ( ) DCNL DCSP arg0 = cmd &#91; 0 &#93; DCNL DCSP if ( not find _ executable ( arg0 ) ) : DCNL DCSP DCSP raise Exception ( ( ( &apos; Cannot DCSP find DCSP executable DCSP &quot; % s &quot; ; &apos; % arg0 ) + ( &apos; you DCSP might DCSP try DCSP % s DCSP --depend &apos; % argv &#91; 0 &#93; ) ) ) DCNL DCSP return check _ output ( cmd , * * kwargs )
DCSP objects = &#91; &#93; DCNL DCSP if ( request.GET and ( &apos; term &apos; in request.GET ) ) : DCNL DCSP DCSP objects = Object.filter _ permitted ( request.user.profile , Object.objects.filter ( object _ name _ _ icontains = request.GET &#91; &apos; term &apos; &#93; ) , mode = &apos; x &apos; ) &#91; : 10 &#93; DCNL DCSP return render _ to _ response ( &apos; core / ajax _ object _ lookup &apos; , { &apos; objects &apos; : objects } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP try : DCNL DCSP DCSP return scopes.index ( scope ) DCNL DCSP except ValueError : DCNL DCSP DCSP raise ValueError ( &quot; { 0 } DCSP { 1 } has DCSP an DCSP unsupported DCSP scope DCSP value DCSP &apos; { 2 } &apos; &quot; .format ( descr , ( &apos; from DCSP { 0 } DCSP &apos; .format ( where ) if where else &apos; &apos; ) , scope ) )
DCSP host = get _ request _ site _ address ( ) DCNL DCSP blog _ list = frappe.db.sql ( u &apos; DCTB DCTB select DCSP route DCSP as DCSP name , DCSP published _ on , DCSP modified , DCSP title , DCSP content DCSP from DCSP `tabBlog DCSP Post` \ n DCTB DCTB where DCSP ifnull ( published , 0 ) = 1 \ n DCTB DCTB order DCSP by DCSP published _ on DCSP desc DCSP limit DCSP 20 &apos; , as _ dict = 1 ) DCNL DCSP for blog in blog _ list : DCNL DCSP DCSP blog _ page = cstr ( urllib.quote ( blog.route.encode ( u &apos;utf-8 &apos; ) ) ) DCNL DCSP DCSP blog.link = urllib.basejoin ( host , blog _ page ) DCNL DCSP DCSP blog.content = escape _ html ( ( blog.content or u &apos; &apos; ) ) DCNL DCSP if blog _ list : DCNL DCSP DCSP modified = max ( ( blog &#91; u &apos;modified &apos; &#93; for blog in blog _ list ) ) DCNL DCSP else : DCNL DCSP DCSP modified = now ( ) DCNL DCSP blog _ settings = frappe.get _ doc ( u &apos;Blog DCSP Settings &apos; , u &apos;Blog DCSP Settings &apos; ) DCNL DCSP context = { u &apos;title &apos; : ( blog _ settings.blog _ title or u &apos;Blog &apos; ) , u &apos;description &apos; : ( blog _ settings.blog _ introduction or u &apos; &apos; ) , u &apos;modified &apos; : modified , u &apos;items &apos; : blog _ list , u &apos;link &apos; : ( host + u &apos; / blog &apos; ) } DCNL DCSP return context
DCSP pub = Publisher ( reader , parser , writer , settings = settings ) DCNL DCSP pub.set _ components ( reader _ name , parser _ name , writer _ name ) DCNL DCSP output = pub.publish ( argv , usage , description , settings _ spec , settings _ overrides , config _ section = config _ section , enable _ exit _ status = enable _ exit _ status ) DCNL DCSP return output
DCSP if ( not user _ exists ( name , database , user , password , host , port ) ) : DCNL DCSP DCSP if database : DCNL DCSP DCSP DCSP log.info ( &quot; User DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP exist DCSP for DCSP DB DCSP &apos; { 1 } &apos; &quot; .format ( name , database ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP log.info ( &quot; Cluster DCSP admin DCSP &apos; { 0 } &apos; DCSP does DCSP not DCSP exist &quot; .format ( name ) ) DCNL DCSP DCSP return False DCNL DCSP client = _ client ( user = user , password = password , host = host , port = port ) DCNL DCSP if ( not database ) : DCNL DCSP DCSP return client.delete _ cluster _ admin ( name ) DCNL DCSP client.switch _ database ( database ) DCNL DCSP return client.delete _ database _ user ( name )
DCSP domain = get _ domain ( url ) DCNL DCSP tld = &apos; .&apos;.join ( domain.split ( &apos; .&apos; ) &#91; ( -2 ) : &#93; ) DCNL DCSP if ( tld in &#91; &apos; co.uk &apos; , &apos; com.au &apos; , &apos; au.com &apos; &#93; ) : DCNL DCSP DCSP end _ chunks = domain.split ( &apos; .&apos; ) &#91; ( -3 ) : &#93; DCNL DCSP else : DCNL DCSP DCSP end _ chunks = domain.split ( &apos; .&apos; ) &#91; ( -2 ) : &#93; DCNL DCSP base _ domain = &apos; .&apos;.join ( end _ chunks ) DCNL DCSP return base _ domain
DCSP def relativize _ url ( url , root _ dir ) : DCNL DCSP DCSP url = ( os.path.realpath ( url ) if followlinks else url ) DCNL DCSP DCSP root _ dir = ( os.path.realpath ( root _ dir ) if followlinks else root _ dir ) DCNL DCSP DCSP url _ in _ bundle = os.path.relpath ( url , root _ dir ) DCNL DCSP DCSP if os.path.isdir ( url ) : DCNL DCSP DCSP DCSP url _ in _ bundle + = u &apos; / &apos; DCNL DCSP DCSP return url _ in _ bundle DCNL DCSP return &#91; relativize _ url ( url , root _ dir ) for url in classpath &#93;
DCSP if sys.dont _ write _ bytecode : DCNL DCSP DCSP raise DistutilsByteCompileError ( &apos; byte-compiling DCSP is DCSP disabled . &apos; ) DCNL DCSP if ( direct is None ) : DCNL DCSP DCSP direct = ( _ _ debug _ _ and ( optimize = = 0 ) ) DCNL DCSP if ( not direct ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP from tempfile import mkstemp DCNL DCSP DCSP DCSP ( script _ fd , script _ name ) = mkstemp ( &apos; .py &apos; ) DCNL DCSP DCSP except ImportError : DCNL DCSP DCSP DCSP from tempfile import mktemp DCNL DCSP DCSP DCSP ( script _ fd , script _ name ) = ( None , mktemp ( &apos; .py &apos; ) ) DCNL DCSP DCSP log.info ( &quot; writing DCSP byte-compilation DCSP script DCSP &apos; % s &apos; &quot; , script _ name ) DCNL DCSP DCSP if ( not dry _ run ) : DCNL DCSP DCSP DCSP if ( script _ fd is not None ) : DCNL DCSP DCSP DCSP DCSP script = os.fdopen ( script _ fd , &apos; w &apos; ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP script = open ( script _ name , &apos; w &apos; ) DCNL DCSP DCSP DCSP script.write ( &apos; from DCSP distutils.util DCSP import DCSP byte _ compile \ nfiles DCSP = DCSP &#91; \ n &apos; ) DCNL DCSP DCSP DCSP script.write ( ( string.join ( map ( repr , py _ files ) , &apos; , \ n &apos; ) + &apos; &#93; \ n &apos; ) ) DCNL DCSP DCSP DCSP script.write ( ( &apos; \ nbyte _ compile ( files , DCSP optimize = % r , DCSP force = % r , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP prefix = % r , DCSP base _ dir = % r , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP verbose = % r , DCSP dry _ run = 0 , \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP direct = 1 ) \ n &apos; % ( optimize , force , prefix , base _ dir , verbose ) ) ) DCNL DCSP DCSP DCSP script.close ( ) DCNL DCSP DCSP cmd = &#91; sys.executable , script _ name &#93; DCNL DCSP DCSP if ( optimize = = 1 ) : DCNL DCSP DCSP DCSP cmd.insert ( 1 , &apos; -O &apos; ) DCNL DCSP DCSP elif ( optimize = = 2 ) : DCNL DCSP DCSP DCSP cmd.insert ( 1 , &apos; -OO &apos; ) DCNL DCSP DCSP spawn ( cmd , dry _ run = dry _ run ) DCNL DCSP DCSP execute ( os.remove , ( script _ name , ) , ( &apos; removing DCSP % s &apos; % script _ name ) , dry _ run = dry _ run ) DCNL DCSP else : DCNL DCSP DCSP from py _ compile import compile DCNL DCSP DCSP for file in py _ files : DCNL DCSP DCSP DCSP if ( file &#91; ( -3 ) : &#93; ! = &apos; .py &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP cfile = ( file + ( ( _ _ debug _ _ and &apos; c &apos; ) or &apos; o &apos; ) ) DCNL DCSP DCSP DCSP dfile = file DCNL DCSP DCSP DCSP if prefix : DCNL DCSP DCSP DCSP DCSP if ( file &#91; : len ( prefix ) &#93; ! = prefix ) : DCNL DCSP DCSP DCSP DCSP DCSP raise ValueError , ( &quot; invalid DCSP prefix : DCSP filename DCSP % r DCSP doesn &apos;t DCSP start DCSP with DCSP % r &quot; % ( file , prefix ) ) DCNL DCSP DCSP DCSP DCSP dfile = dfile &#91; len ( prefix ) : &#93; DCNL DCSP DCSP DCSP if base _ dir : DCNL DCSP DCSP DCSP DCSP dfile = os.path.join ( base _ dir , dfile ) DCNL DCSP DCSP DCSP cfile _ base = os.path.basename ( cfile ) DCNL DCSP DCSP DCSP if direct : DCNL DCSP DCSP DCSP DCSP if ( force or newer ( file , cfile ) ) : DCNL DCSP DCSP DCSP DCSP DCSP log.info ( &apos; byte-compiling DCSP % s DCSP to DCSP % s &apos; , file , cfile _ base ) DCNL DCSP DCSP DCSP DCSP DCSP if ( not dry _ run ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP compile ( file , cfile , dfile ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP log.debug ( &apos; skipping DCSP byte-compilation DCSP of DCSP % s DCSP to DCSP % s &apos; , file , cfile _ base )
DCSP return ( SecondsSince ( timestamp ) / 3600.0 )
DCSP ret = { &apos; name &apos; : name , &apos; changes &apos; : { } , &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; } DCNL DCSP if ( not properties ) : DCNL DCSP DCSP properties = { } DCNL DCSP log.debug ( &apos; zfs.volume _ present : : { 0 } : : config : : volume _ size DCSP = DCSP { 1 } &apos; .format ( name , volume _ size ) ) DCNL DCSP log.debug ( &apos; zfs.volume _ present : : { 0 } : : config : : sparse DCSP = DCSP { 1 } &apos; .format ( name , sparse ) ) DCNL DCSP log.debug ( &apos; zfs.volume _ present : : { 0 } : : config : : create _ parent DCSP = DCSP { 1 } &apos; .format ( name , create _ parent ) ) DCNL DCSP log.debug ( &apos; zfs.volume _ present : : { 0 } : : config : : cloned _ from DCSP = DCSP { 1 } &apos; .format ( name , cloned _ from ) ) DCNL DCSP log.debug ( &apos; zfs.volume _ present : : { 0 } : : config : : properties DCSP = DCSP { 1 } &apos; .format ( name , properties ) ) DCNL DCSP for prop in properties.keys ( ) : DCNL DCSP DCSP if isinstance ( properties &#91; prop &#93; , bool ) : DCNL DCSP DCSP DCSP properties &#91; prop &#93; = ( &apos; on &apos; if properties &#91; prop &#93; else &apos; off &apos; ) DCNL DCSP if ( ( &apos; @ &apos; in name ) or ( &apos; # &apos; in name ) ) : DCNL DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; invalid DCSP filesystem DCSP or DCSP volume DCSP name : DCSP { 0 } &apos; .format ( name ) DCNL DCSP if cloned _ from : DCNL DCSP DCSP cloned _ parent = cloned _ from &#91; : cloned _ from.index ( &apos; @ &apos; ) &#93; DCNL DCSP DCSP if ( &apos; @ &apos; not in cloned _ from ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; { 0 } DCSP is DCSP not DCSP a DCSP snapshot &apos; .format ( cloned _ from ) DCNL DCSP DCSP elif ( cloned _ from not in _ _ salt _ _ &#91; &apos; zfs.list &apos; &#93; ( cloned _ from , * * { &apos; type &apos; : &apos; snapshot &apos; } ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; snapshot DCSP { 0 } DCSP does DCSP not DCSP exist &apos; .format ( cloned _ from ) DCNL DCSP DCSP elif ( cloned _ parent not in _ _ salt _ _ &#91; &apos; zfs.list &apos; &#93; ( cloned _ parent , * * { &apos; type &apos; : &apos; volume &apos; } ) ) : DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; snapshot DCSP { 0 } DCSP is DCSP not DCSP from DCSP a DCSP volume &apos; .format ( cloned _ from ) DCNL DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP if ( name in _ _ salt _ _ &#91; &apos; zfs.list &apos; &#93; ( name , * * { &apos; type &apos; : &apos; volume &apos; } ) ) : DCNL DCSP DCSP DCSP properties &#91; &apos; volsize &apos; &#93; = volume _ size DCNL DCSP DCSP DCSP result = _ _ salt _ _ &#91; &apos; zfs.get &apos; &#93; ( name , * * { &apos; properties &apos; : &apos; , &apos; .join ( properties.keys ( ) ) , &apos; fields &apos; : &apos; value &apos; , &apos; depth &apos; : 1 } ) DCNL DCSP DCSP DCSP for prop in properties.keys ( ) : DCNL DCSP DCSP DCSP DCSP if ( properties &#91; prop &#93; ! = result &#91; name &#93; &#91; prop &#93; &#91; &apos; value &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( name not in ret &#91; &apos; changes &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; name &#93; = { } DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; name &#93; &#91; prop &#93; = properties &#91; prop &#93; DCNL DCSP DCSP DCSP if ( len ( ret &#91; &apos; changes &apos; &#93; ) &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP if ( not _ _ opts _ _ &#91; &apos; test &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP result = _ _ salt _ _ &#91; &apos; zfs.set &apos; &#93; ( name , * * ret &#91; &apos; changes &apos; &#93; &#91; name &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP if ( name not in result ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP for prop in result &#91; name &#93; .keys ( ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP if ( result &#91; name &#93; &#91; prop &#93; ! = &apos; set &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; volume DCSP { 0 } DCSP was DCSP updated &apos; .format ( name ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; = { } DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; volume DCSP { 0 } DCSP failed DCSP to DCSP be DCSP updated &apos; .format ( name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; volume DCSP { 0 } DCSP is DCSP up DCSP to DCSP date &apos; .format ( name ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP result = { name : &apos; created &apos; } DCNL DCSP DCSP DCSP if ( not _ _ opts _ _ &#91; &apos; test &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( not cloned _ from ) : DCNL DCSP DCSP DCSP DCSP DCSP result = _ _ salt _ _ &#91; &apos; zfs.create &apos; &#93; ( name , * * { &apos; volume _ size &apos; : volume _ size , &apos; sparse &apos; : sparse , &apos; create _ parent &apos; : create _ parent , &apos; properties &apos; : properties } ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP result = _ _ salt _ _ &#91; &apos; zfs.clone &apos; &#93; ( cloned _ from , name , * * { &apos; create _ parent &apos; : create _ parent , &apos; properties &apos; : properties } ) DCNL DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = ( name in result ) DCNL DCSP DCSP DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; result &apos; &#93; = ( ( result &#91; name &#93; = = &apos; created &apos; ) or result &#91; name &#93; .startswith ( &apos; cloned &apos; ) ) DCNL DCSP DCSP DCSP if ret &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; changes &apos; &#93; &#91; name &#93; = ( properties if ( len ( properties ) &gt; 0 ) else result &#91; name &#93; ) DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; volume DCSP { 0 } DCSP was DCSP created &apos; .format ( name ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = &apos; failed DCSP to DCSP create DCSP volume DCSP { 0 } &apos; .format ( name ) DCNL DCSP DCSP DCSP DCSP if ( name in result ) : DCNL DCSP DCSP DCSP DCSP DCSP ret &#91; &apos; comment &apos; &#93; = result &#91; name &#93; DCNL DCSP return ret
DCSP if ( not is _ secure _ transport ( uri ) ) : DCNL DCSP DCSP raise InsecureTransportError ( ) DCNL DCSP params = &#91; ( u &apos;response _ type &apos; , response _ type ) , ( u &apos;client _ id &apos; , client _ id ) &#93; DCNL DCSP if redirect _ uri : DCNL DCSP DCSP params.append ( ( u &apos;redirect _ uri &apos; , redirect _ uri ) ) DCNL DCSP if scope : DCNL DCSP DCSP params.append ( ( u &apos;scope &apos; , list _ to _ scope ( scope ) ) ) DCNL DCSP if state : DCNL DCSP DCSP params.append ( ( u &apos;state &apos; , state ) ) DCNL DCSP for k in kwargs : DCNL DCSP DCSP if kwargs &#91; k &#93; : DCNL DCSP DCSP DCSP params.append ( ( unicode _ type ( k ) , kwargs &#91; k &#93; ) ) DCNL DCSP return add _ params _ to _ uri ( uri , params )
DCSP coded _ messages = &#91; &#93; DCNL DCSP for ( tag , data ) in messages : DCNL DCSP DCSP if data : DCNL DCSP DCSP DCSP if ( not isinstance ( data , str ) ) : DCNL DCSP DCSP DCSP DCSP try : DCNL DCSP DCSP DCSP DCSP DCSP data = &apos; DCSP &apos; .join ( map ( str , data ) ) DCNL DCSP DCSP DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP DCSP DCSP pass DCNL DCSP DCSP DCSP m = ( &apos; % s DCSP % s &apos; % ( tag , data ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP m = str ( tag ) DCNL DCSP DCSP m = ctcpQuote ( m ) DCNL DCSP DCSP m = ( &apos; % s % s % s &apos; % ( X _ DELIM , m , X _ DELIM ) ) DCNL DCSP DCSP coded _ messages.append ( m ) DCNL DCSP line = &apos; &apos;.join ( coded _ messages ) DCNL DCSP return line
DCSP ret = &#91; &#93; DCNL DCSP changes = { } DCNL DCSP txt = { } DCNL DCSP global LAST _ GRAINS DCNL DCSP _ validate = _ _ validate _ _ ( config ) DCNL DCSP if ( not _ validate &#91; 0 &#93; ) : DCNL DCSP DCSP log.warning ( &apos; Beacon DCSP { 0 } DCSP configuration DCSP invalid , DCSP not DCSP adding . DCSP { 1 } &apos; .format ( _ _ virtualname _ _ , _ validate &#91; 1 &#93; ) ) DCNL DCSP DCSP return ret DCNL DCSP if ( &apos; servicename &apos; in config ) : DCNL DCSP DCSP servicename = config &#91; &apos; servicename &apos; &#93; DCNL DCSP else : DCNL DCSP DCSP servicename = _ _ grains _ _ &#91; &apos; host &apos; &#93; DCNL DCSP for item in config &#91; &apos; txt &apos; &#93; : DCNL DCSP DCSP if config &#91; &apos; txt &apos; &#93; &#91; item &#93; .startswith ( &apos; grains . &apos; ) : DCNL DCSP DCSP DCSP grain = config &#91; &apos; txt &apos; &#93; &#91; item &#93; &#91; 7 : &#93; DCNL DCSP DCSP DCSP grain _ index = None DCNL DCSP DCSP DCSP square _ bracket = grain.find ( &apos; &#91; &apos; ) DCNL DCSP DCSP DCSP if ( ( square _ bracket ! = ( -1 ) ) and ( grain &#91; ( -1 ) &#93; = = &apos; &#93; &apos; ) ) : DCNL DCSP DCSP DCSP DCSP grain _ index = int ( grain &#91; ( square _ bracket + 1 ) : ( -1 ) &#93; ) DCNL DCSP DCSP DCSP DCSP grain = grain &#91; : square _ bracket &#93; DCNL DCSP DCSP DCSP grain _ value = _ _ grains _ _ .get ( grain , &apos; &apos; ) DCNL DCSP DCSP DCSP if isinstance ( grain _ value , list ) : DCNL DCSP DCSP DCSP DCSP if ( grain _ index is not None ) : DCNL DCSP DCSP DCSP DCSP DCSP grain _ value = grain _ value &#91; grain _ index &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP grain _ value = &apos; , &apos; .join ( grain _ value ) DCNL DCSP DCSP DCSP txt &#91; item &#93; = grain _ value DCNL DCSP DCSP DCSP if ( LAST _ GRAINS and ( LAST _ GRAINS.get ( grain , &apos; &apos; ) ! = _ _ grains _ _ .get ( grain , &apos; &apos; ) ) ) : DCNL DCSP DCSP DCSP DCSP changes &#91; str ( ( &apos; txt . &apos; + item ) ) &#93; = txt &#91; item &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP txt &#91; item &#93; = config &#91; &apos; txt &apos; &#93; &#91; item &#93; DCNL DCSP DCSP if ( not LAST _ GRAINS ) : DCNL DCSP DCSP DCSP changes &#91; str ( ( &apos; txt . &apos; + item ) ) &#93; = txt &#91; item &#93; DCNL DCSP if changes : DCNL DCSP DCSP if ( not LAST _ GRAINS ) : DCNL DCSP DCSP DCSP changes &#91; &apos; servicename &apos; &#93; = servicename DCNL DCSP DCSP DCSP changes &#91; &apos; servicetype &apos; &#93; = config &#91; &apos; servicetype &apos; &#93; DCNL DCSP DCSP DCSP changes &#91; &apos; port &apos; &#93; = config &#91; &apos; port &apos; &#93; DCNL DCSP DCSP DCSP GROUP.AddService ( avahi.IF _ UNSPEC , avahi.PROTO _ UNSPEC , dbus.UInt32 ( 0 ) , servicename , config &#91; &apos; servicetype &apos; &#93; , &apos; &apos; , &apos; &apos; , dbus.UInt16 ( config &#91; &apos; port &apos; &#93; ) , avahi.dict _ to _ txt _ array ( txt ) ) DCNL DCSP DCSP DCSP GROUP.Commit ( ) DCNL DCSP DCSP elif config.get ( &apos; reset _ on _ change &apos; , False ) : DCNL DCSP DCSP DCSP GROUP.Reset ( ) DCNL DCSP DCSP DCSP reset _ wait = config.get ( &apos; reset _ wait &apos; , 0 ) DCNL DCSP DCSP DCSP if ( reset _ wait &gt; 0 ) : DCNL DCSP DCSP DCSP DCSP time.sleep ( reset _ wait ) DCNL DCSP DCSP DCSP GROUP.AddService ( avahi.IF _ UNSPEC , avahi.PROTO _ UNSPEC , dbus.UInt32 ( 0 ) , servicename , config &#91; &apos; servicetype &apos; &#93; , &apos; &apos; , &apos; &apos; , dbus.UInt16 ( config &#91; &apos; port &apos; &#93; ) , avahi.dict _ to _ txt _ array ( txt ) ) DCNL DCSP DCSP DCSP GROUP.Commit ( ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP GROUP.UpdateServiceTxt ( avahi.IF _ UNSPEC , avahi.PROTO _ UNSPEC , dbus.UInt32 ( 0 ) , servicename , config &#91; &apos; servicetype &apos; &#93; , &apos; &apos; , avahi.dict _ to _ txt _ array ( txt ) ) DCNL DCSP DCSP ret.append ( { &apos; tag &apos; : &apos; result &apos; , &apos; changes &apos; : changes } ) DCNL DCSP if config.get ( &apos; copy _ grains &apos; , False ) : DCNL DCSP DCSP LAST _ GRAINS = _ _ grains _ _ .copy ( ) DCNL DCSP else : DCNL DCSP DCSP LAST _ GRAINS = _ _ grains _ _ DCNL DCSP return ret
DCSP return loadopt.set _ relationship _ strategy ( attr , { &apos; lazy &apos; : &apos; noload &apos; } )
DCSP GlobalObject ( ) .masterremote. _ reference . _ service.mapTarget ( target )
DCSP data _ home = get _ data _ home ( data _ home ) DCNL DCSP if ( not exists ( data _ home ) ) : DCNL DCSP DCSP makedirs ( data _ home ) DCNL DCSP extra _ params = dict ( x _ left _ lower _ corner = ( -94.8 ) , Nx = 1212 , y _ left _ lower _ corner = ( -56.05 ) , Ny = 1592 , grid _ size = 0.05 ) DCNL DCSP dtype = np.int16 DCNL DCSP archive _ path = _ pkl _ filepath ( data _ home , DATA _ ARCHIVE _ NAME ) DCNL DCSP if ( not exists ( archive _ path ) ) : DCNL DCSP DCSP if ( not download _ if _ missing ) : DCNL DCSP DCSP DCSP raise IOError ( &apos; Data DCSP not DCSP found DCSP and DCSP `download _ if _ missing` DCSP is DCSP False &apos; ) DCNL DCSP DCSP print ( &apos; Downloading DCSP species DCSP data DCSP from DCSP % s DCSP to DCSP % s &apos; % ( SAMPLES _ URL , data _ home ) ) DCNL DCSP DCSP X = np.load ( BytesIO ( urlopen ( SAMPLES _ URL ) .read ( ) ) ) DCNL DCSP DCSP for f in X.files : DCNL DCSP DCSP DCSP fhandle = BytesIO ( X &#91; f &#93; ) DCNL DCSP DCSP DCSP if ( &apos; train &apos; in f ) : DCNL DCSP DCSP DCSP DCSP train = _ load _ csv ( fhandle ) DCNL DCSP DCSP DCSP if ( &apos; test &apos; in f ) : DCNL DCSP DCSP DCSP DCSP test = _ load _ csv ( fhandle ) DCNL DCSP DCSP print ( &apos; Downloading DCSP coverage DCSP data DCSP from DCSP % s DCSP to DCSP % s &apos; % ( COVERAGES _ URL , data _ home ) ) DCNL DCSP DCSP X = np.load ( BytesIO ( urlopen ( COVERAGES _ URL ) .read ( ) ) ) DCNL DCSP DCSP coverages = &#91; &#93; DCNL DCSP DCSP for f in X.files : DCNL DCSP DCSP DCSP fhandle = BytesIO ( X &#91; f &#93; ) DCNL DCSP DCSP DCSP print ( &apos; DCSP - DCSP converting &apos; , f ) DCNL DCSP DCSP DCSP coverages.append ( _ load _ coverage ( fhandle ) ) DCNL DCSP DCSP coverages = np.asarray ( coverages , dtype = dtype ) DCNL DCSP DCSP bunch = Bunch ( coverages = coverages , test = test , train = train , * * extra _ params ) DCNL DCSP DCSP joblib.dump ( bunch , archive _ path , compress = 9 ) DCNL DCSP else : DCNL DCSP DCSP bunch = joblib.load ( archive _ path ) DCNL DCSP return bunch
DCSP ret = { } DCNL DCSP if ( not os.path.isfile ( config ) ) : DCNL DCSP DCSP return ret DCNL DCSP with salt.utils.fopen ( config ) as ifile : DCNL DCSP DCSP for line in ifile : DCNL DCSP DCSP DCSP if line.startswith ( &apos; # &apos; ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP if ( not line.strip ( ) ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP comps = line.split ( ) DCNL DCSP DCSP DCSP if ( len ( comps ) ! = 3 ) : DCNL DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP prefix = &apos; / .. &apos; DCNL DCSP DCSP DCSP name = comps &#91; 0 &#93; .replace ( prefix , &apos; &apos; ) DCNL DCSP DCSP DCSP device _ fmt = comps &#91; 2 &#93; .split ( &apos; : &apos; ) DCNL DCSP DCSP DCSP opts = comps &#91; 1 &#93; .split ( &apos; , &apos; ) DCNL DCSP DCSP DCSP ret &#91; name &#93; = { &apos; device &apos; : device _ fmt &#91; 1 &#93; , &apos; fstype &apos; : opts &#91; 0 &#93; , &apos; opts &apos; : opts &#91; 1 : &#93; } DCNL DCSP return ret
DCSP raw = read _ raw _ fif ( raw _ fname ) .crop ( 1.5 , stop ) .load _ data ( ) DCNL DCSP picks = pick _ types ( raw.info , meg = True , stim = False , ecg = False , eog = False , exclude = &apos; bads &apos; ) DCNL DCSP ica = ICA ( n _ components = 3 , max _ pca _ components = 4 , n _ pca _ components = 4 ) DCNL DCSP raw . _ data &#91; 2 , 1000 : 1005 &#93; = 5e-12 DCNL DCSP with catch _ logging ( ) as drop _ log : DCNL DCSP DCSP with warnings.catch _ warnings ( record = True ) : DCNL DCSP DCSP DCSP ica.fit ( raw , picks &#91; : 5 &#93; , reject = dict ( mag = 2.5e-12 ) , decim = 2 , tstep = 0.01 , verbose = True ) DCNL DCSP DCSP assert _ true ( ( ( raw . _ data &#91; : 5 , : : 2 &#93; .shape &#91; 1 &#93; - 4 ) = = ica.n _ samples _ ) ) DCNL DCSP log = &#91; l for l in drop _ log.getvalue ( ) .split ( &apos; \ n &apos; ) if ( &apos; detected &apos; in l ) &#93; DCNL DCSP assert _ equal ( len ( log ) , 1 )
DCSP if ( pattern is None ) : DCNL DCSP DCSP pattern = sickbeard.NAMING _ PATTERN DCNL DCSP if ( anime _ type is None ) : DCNL DCSP DCSP anime _ type = sickbeard.NAMING _ ANIME DCNL DCSP logger.log ( ( ( u &apos;Checking DCSP whether DCSP the DCSP pattern DCSP &apos; + pattern ) + u &apos; DCSP is DCSP valid DCSP for DCSP a DCSP single DCSP episode &apos; ) , logger.DEBUG ) DCNL DCSP valid = validate _ name ( pattern , None , anime _ type ) DCNL DCSP if ( multi is not None ) : DCNL DCSP DCSP logger.log ( ( ( u &apos;Checking DCSP whether DCSP the DCSP pattern DCSP &apos; + pattern ) + u &apos; DCSP is DCSP valid DCSP for DCSP a DCSP multi DCSP episode &apos; ) , logger.DEBUG ) DCNL DCSP DCSP valid = ( valid and validate _ name ( pattern , multi , anime _ type ) ) DCNL DCSP return valid
DCSP w = ( - min ( &#91; 0 , r , g , b &#93; ) ) DCNL DCSP if ( w &gt; 0 ) : DCNL DCSP DCSP r + = w DCNL DCSP DCSP g + = w DCNL DCSP DCSP b + = w DCNL DCSP return ( r , g , b )
DCSP tuple _ class = collections.namedtuple ( &apos; TestCase &apos; , &apos; input , DCSP keep , DCSP no _ keep &apos; ) DCNL DCSP for line in test _ data _ str.splitlines ( ) : DCNL DCSP DCSP if ( not line ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP data = line.split ( &apos; / &apos; ) DCNL DCSP DCSP item = tuple _ class ( input = data &#91; 0 &#93; , keep = data &#91; 1 &#93; .split ( &apos; &#124; &apos; ) , no _ keep = data &#91; 2 &#93; .split ( &apos; &#124; &apos; ) ) DCNL DCSP DCSP ( yield item ) DCNL DCSP ( yield tuple _ class ( input = &apos; &apos; , keep = &#91; &#93; , no _ keep = &#91; &#93; ) )
DCSP parser = argparse.ArgumentParser ( ) DCNL DCSP rules = shlex.split ( rule ) DCNL DCSP rules.pop ( 0 ) DCNL DCSP parser.add _ argument ( &apos; --bootproto &apos; , dest = &apos; bootproto &apos; , action = &apos; store &apos; , choices = &#91; &apos; dhcp &apos; , &apos; bootp &apos; , &apos; static &apos; , &apos; ibft &apos; &#93; ) DCNL DCSP parser.add _ argument ( &apos; --device &apos; , dest = &apos; device &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --ip &apos; , dest = &apos; ip &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --ipv6 &apos; , dest = &apos; ipv6 &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --gateway &apos; , dest = &apos; gateway &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --nodefroute &apos; , dest = &apos; nodefroute &apos; , action = &apos; store _ true &apos; ) DCNL DCSP parser.add _ argument ( &apos; --nameserver &apos; , dest = &apos; nameserver &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --nodns &apos; , dest = &apos; nodns &apos; , action = &apos; store _ true &apos; ) DCNL DCSP parser.add _ argument ( &apos; --netmask &apos; , dest = &apos; netmask &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --hostname &apos; , dest = &apos; hostname &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --ethtool &apos; , dest = &apos; ethtool &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --essid &apos; , dest = &apos; essid &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --wepkey &apos; , dest = &apos; wepkey &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --wpakey &apos; , dest = &apos; wpakey &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --onboot &apos; , dest = &apos; onboot &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --dhcpclass &apos; , dest = &apos; dhcpclass &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --mtu &apos; , dest = &apos; mtu &apos; , action = &apos; store &apos; ) DCNL DCSP parser.add _ argument ( &apos; --noipv4 &apos; , dest = &apos; noipv4 &apos; , action = &apos; store _ true &apos; ) DCNL DCSP parser.add _ argument ( &apos; --noipv6 &apos; , dest = &apos; noipv6 &apos; , action = &apos; store _ true &apos; ) DCNL DCSP parser.add _ argument ( &apos; --activate &apos; , dest = &apos; activate &apos; , action = &apos; store _ true &apos; ) DCNL DCSP args = clean _ args ( vars ( parser.parse _ args ( rules ) ) ) DCNL DCSP parser = None DCNL DCSP return args
DCSP class IsFieldShared ( permissions.BasePermission , ) : DCNL DCSP DCSP &apos; \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP Grants DCSP access DCSP if DCSP a DCSP particular DCSP profile DCSP field DCSP is DCSP shared DCSP with DCSP the DCSP requesting DCSP user . \ n DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP &apos; DCNL DCSP DCSP def has _ permission ( self , request , view ) : DCNL DCSP DCSP DCSP url _ username = request.parser _ context.get ( &apos; kwargs &apos; , { } ) .get ( &apos; username &apos; , &apos; &apos; ) DCNL DCSP DCSP DCSP if ( request.user.username.lower ( ) = = url _ username.lower ( ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP if request.user.is _ staff : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP user = get _ object _ or _ 404 ( User , username _ _ iexact = url _ username ) DCNL DCSP DCSP DCSP if ( field _ name in visible _ fields ( user.profile , user ) ) : DCNL DCSP DCSP DCSP DCSP return True DCNL DCSP DCSP DCSP raise Http404 ( ) DCNL DCSP return IsFieldShared
DCSP epoch = int ( epoch ) DCNL DCSP if ( len ( str ( epoch ) ) &lt; = 10 ) : DCNL DCSP DCSP return epoch DCNL DCSP elif ( len ( str ( epoch ) ) = = 13 ) : DCNL DCSP DCSP return int ( ( epoch / 1000 ) ) DCNL DCSP elif ( ( len ( str ( epoch ) ) &gt; 10 ) and ( len ( str ( epoch ) ) &lt; 13 ) ) : DCNL DCSP DCSP raise ValueError ( &apos; Unusually DCSP formatted DCSP epoch DCSP timestamp . DCSP DCSP Should DCSP be DCSP 10 , DCSP 13 , DCSP or DCSP more DCSP digits &apos; ) DCNL DCSP else : DCNL DCSP DCSP orders _ of _ magnitude = ( len ( str ( epoch ) ) - 10 ) DCNL DCSP DCSP powers _ of _ ten = ( 10 * * orders _ of _ magnitude ) DCNL DCSP DCSP epoch = int ( ( epoch / powers _ of _ ten ) ) DCNL DCSP return epoch
DCSP if isinstance ( pecls , six.string _ types ) : DCNL DCSP DCSP pecls = &#91; pecls &#93; DCNL DCSP return _ pecl ( &apos; uninstall DCSP { 0 } &apos; .format ( _ cmd _ quote ( &apos; DCSP &apos; .join ( pecls ) ) ) )
DCSP coach _ role _ on _ master _ course = CourseCcxCoachRole ( master _ course _ key ) DCNL DCSP coach _ role _ on _ master _ course.add _ users ( user )
DCSP return np.ones ( ( nlags + 1 ) )
DCSP if isinstance ( statement , sqlalchemy.orm.Query ) : DCNL DCSP DCSP if ( dialect is None ) : DCNL DCSP DCSP DCSP dialect = statement.session.get _ bind ( statement . _ mapper _ zero _ or _ none ( ) ) .dialect DCNL DCSP DCSP statement = statement.statement DCNL DCSP if ( dialect is None ) : DCNL DCSP DCSP dialect = getattr ( statement.bind , &apos; dialect &apos; , None ) DCNL DCSP if ( dialect is None ) : DCNL DCSP DCSP from sqlalchemy.dialects import mysql DCNL DCSP DCSP dialect = mysql.dialect ( ) DCNL DCSP Compiler = type ( statement . _ compiler ( dialect ) ) DCNL DCSP class LiteralCompiler ( Compiler , ) : DCNL DCSP DCSP visit _ bindparam = Compiler.render _ literal _ bindparam DCNL DCSP DCSP def render _ literal _ value ( self , value , type _ ) : DCNL DCSP DCSP DCSP if isinstance ( value , ( Decimal , long ) ) : DCNL DCSP DCSP DCSP DCSP return str ( value ) DCNL DCSP DCSP DCSP elif isinstance ( value , datetime ) : DCNL DCSP DCSP DCSP DCSP return repr ( str ( value ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP value = super ( LiteralCompiler , self ) .render _ literal _ value ( value , type _ ) DCNL DCSP DCSP DCSP DCSP if isinstance ( value , unicode ) : DCNL DCSP DCSP DCSP DCSP DCSP return value.encode ( &apos; UTF-8 &apos; ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP return value DCNL DCSP return LiteralCompiler ( dialect , statement )
DCSP ret = &#91; &#93; DCNL DCSP mod _ dir = os.path.join ( &apos; / lib / modules / &apos; , os.uname ( ) &#91; 2 &#93; ) DCNL DCSP for ( root , dirs , files ) in os.walk ( mod _ dir ) : DCNL DCSP DCSP for fn _ in files : DCNL DCSP DCSP DCSP if ( &apos; .ko &apos; in fn _ ) : DCNL DCSP DCSP DCSP DCSP ret.append ( fn _ &#91; : fn _ .index ( &apos; .ko &apos; ) &#93; .replace ( &apos; -&apos; , &apos; _ &apos; ) ) DCNL DCSP if ( &apos; Arch &apos; in _ _ grains _ _ &#91; &apos; os _ family &apos; &#93; ) : DCNL DCSP DCSP mod _ dir _ arch = ( ( &apos; / lib / modules / extramodules- &apos; + os.uname ( ) &#91; 2 &#93; &#91; 0 : 3 &#93; ) + &apos; -ARCH &apos; ) DCNL DCSP DCSP for ( root , dirs , files ) in os.walk ( mod _ dir _ arch ) : DCNL DCSP DCSP DCSP for fn _ in files : DCNL DCSP DCSP DCSP DCSP if ( &apos; .ko &apos; in fn _ ) : DCNL DCSP DCSP DCSP DCSP DCSP ret.append ( fn _ &#91; : fn _ .index ( &apos; .ko &apos; ) &#93; .replace ( &apos; -&apos; , &apos; _ &apos; ) ) DCNL DCSP return sorted ( list ( ret ) )
DCSP moving = True DCNL DCSP if ( QUICK _ LINKED _ CLONE = = vm _ &#91; &apos; snapshot &apos; &#93; &#91; &apos; disk _ move _ type &apos; &#93; ) : DCNL DCSP DCSP reloc _ spec.diskMoveType = QUICK _ LINKED _ CLONE DCNL DCSP elif ( CURRENT _ STATE _ LINKED _ CLONE = = vm _ &#91; &apos; snapshot &apos; &#93; &#91; &apos; disk _ move _ type &apos; &#93; ) : DCNL DCSP DCSP reloc _ spec.diskMoveType = CURRENT _ STATE _ LINKED _ CLONE DCNL DCSP elif ( COPY _ ALL _ DISKS _ FULL _ CLONE = = vm _ &#91; &apos; snapshot &apos; &#93; &#91; &apos; disk _ move _ type &apos; &#93; ) : DCNL DCSP DCSP reloc _ spec.diskMoveType = COPY _ ALL _ DISKS _ FULL _ CLONE DCNL DCSP elif ( FLATTEN _ DISK _ FULL _ CLONE = = vm _ &#91; &apos; snapshot &apos; &#93; &#91; &apos; disk _ move _ type &apos; &#93; ) : DCNL DCSP DCSP reloc _ spec.diskMoveType = FLATTEN _ DISK _ FULL _ CLONE DCNL DCSP else : DCNL DCSP DCSP moving = False DCNL DCSP if moving : DCNL DCSP DCSP return build _ clonespec ( config _ spec , object _ ref , reloc _ spec , template ) DCNL DCSP else : DCNL DCSP DCSP return None
DCSP os.environ &#91; &apos; PYTHONPATH &apos; &#93; = current _ directory DCNL DCSP os.environ &#91; &apos; DJANGO _ SETTINGS _ MODULE &apos; &#93; = &apos; djangoapp &apos; DCNL DCSP ( status , out ) = commands.getstatusoutput ( &apos; django-admin.py DCSP harvest DCSP email.feature DCSP --verbosity = 2 &apos; ) DCNL DCSP assert _ not _ equals ( status , 0 )
DCSP if ( logfile is None ) : DCNL DCSP DCSP logfile = _ default _ logfile ( &apos; chef-client &apos; ) DCNL DCSP args = &#91; &apos; chef-client &apos; , &apos; --no-color &apos; , &apos; --once &apos; , &apos; --logfile DCSP &quot; { 0 } &quot; &apos; .format ( logfile ) , &apos; --format DCSP doc &apos; &#93; DCNL DCSP if whyrun : DCNL DCSP DCSP args.append ( &apos; --why-run &apos; ) DCNL DCSP if localmode : DCNL DCSP DCSP args.append ( &apos; --local-mode &apos; ) DCNL DCSP return _ exec _ cmd ( * args , * * kwargs )
DCSP RemoteRepository = apps.get _ model ( u &apos;oauth &apos; , u &apos;RemoteRepository &apos; ) DCNL DCSP SocialAccount = apps.get _ model ( u &apos;socialaccount &apos; , u &apos;SocialAccount &apos; ) DCNL DCSP for account in SocialAccount.objects.all ( ) : DCNL DCSP DCSP rows = RemoteRepository.objects.filter ( users = account.user , source = account.provider ) .update ( account = account )
DCSP state = salt.utils.mac _ utils.validate _ enabled ( enabled ) DCNL DCSP cmd = &apos; systemsetup DCSP -setwakeonnetworkaccess DCSP { 0 } &apos; .format ( state ) DCNL DCSP salt.utils.mac _ utils.execute _ return _ success ( cmd ) DCNL DCSP return salt.utils.mac _ utils.confirm _ updated ( state , get _ wake _ on _ network )
DCSP if ( not files ) : DCNL DCSP DCSP return DCNL DCSP for fname in files : DCNL DCSP DCSP if ( ( not exists ( fname ) ) or ( not isfile ( fname ) ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if any ( ( ( ex in fname ) for ex in exclusions ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP if ( ( pattern is None ) or re.match ( pattern , fname ) ) : DCNL DCSP DCSP DCSP file _ check ( fname )
DCSP format = request.GET.get ( u &apos;format &apos; ) DCNL DCSP if format : DCNL DCSP DCSP if ( format in serializer.formats ) : DCNL DCSP DCSP DCSP return serializer.get _ mime _ for _ format ( format ) DCNL DCSP if ( ( u &apos;callback &apos; in request.GET ) and ( u &apos;jsonp &apos; in serializer.formats ) ) : DCNL DCSP DCSP return serializer.get _ mime _ for _ format ( u &apos;jsonp &apos; ) DCNL DCSP accept = request.META.get ( u &apos;HTTP _ ACCEPT &apos; , u &apos; * / * &apos; ) DCNL DCSP if ( accept ! = u &apos; * / * &apos; ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP best _ format = mimeparse.best _ match ( serializer.supported _ formats _ reversed , accept ) DCNL DCSP DCSP except ValueError : DCNL DCSP DCSP DCSP raise BadRequest ( u &apos;Invalid DCSP Accept DCSP header &apos; ) DCNL DCSP DCSP if best _ format : DCNL DCSP DCSP DCSP return best _ format DCNL DCSP return default _ format
DCSP remove _ c = 0 DCNL DCSP for package in packages : DCNL DCSP DCSP if ( not query _ package ( module , port _ path , package ) ) : DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP ( rc , out , err ) = module.run _ command ( ( &apos; % s DCSP uninstall DCSP % s &apos; % ( port _ path , package ) ) ) DCNL DCSP DCSP if query _ package ( module , port _ path , package ) : DCNL DCSP DCSP DCSP module.fail _ json ( msg = ( &apos; failed DCSP to DCSP remove DCSP % s : DCSP % s &apos; % ( package , out ) ) ) DCNL DCSP DCSP remove _ c + = 1 DCNL DCSP if ( remove _ c &gt; 0 ) : DCNL DCSP DCSP module.exit _ json ( changed = True , msg = ( &apos; removed DCSP % s DCSP package ( s ) &apos; % remove _ c ) ) DCNL DCSP module.exit _ json ( changed = False , msg = &apos; package ( s ) DCSP already DCSP absent &apos; )
DCSP defaults = { &apos; level &apos; : &apos; LOG _ INFO &apos; , &apos; facility &apos; : &apos; LOG _ USER &apos; , &apos; options &apos; : &#91; &#93; } DCNL DCSP attrs = { &apos; level &apos; : &apos; level &apos; , &apos; facility &apos; : &apos; facility &apos; , &apos; tag &apos; : &apos; tag &apos; , &apos; options &apos; : &apos; options &apos; } DCNL DCSP _ options = salt.returners.get _ returner _ options ( _ _ virtualname _ _ , ret , attrs , _ _ salt _ _ = _ _ salt _ _ , _ _ opts _ _ = _ _ opts _ _ , defaults = defaults ) DCNL DCSP return _ options
DCSP if ( not hasattr ( sys , &apos; frozen &apos; ) ) : DCNL DCSP DCSP return os.listdir ( path ) DCNL DCSP ( zipPath , archivePath ) = splitZip ( path ) DCNL DCSP if ( archivePath is None ) : DCNL DCSP DCSP return os.listdir ( path ) DCNL DCSP with zipfile.ZipFile ( zipPath , &apos; r &apos; ) as zipobj : DCNL DCSP DCSP contents = zipobj.namelist ( ) DCNL DCSP results = set ( ) DCNL DCSP for name in contents : DCNL DCSP DCSP if ( name.startswith ( archivePath ) and ( len ( name ) &gt; len ( archivePath ) ) ) : DCNL DCSP DCSP DCSP name = name &#91; len ( archivePath ) : &#93; .split ( &apos; / &apos; ) &#91; 0 &#93; DCNL DCSP DCSP DCSP results.add ( name ) DCNL DCSP return list ( results )
DCSP _ object _ id = &apos; { } _ { } _ { } &apos; .format ( slugify ( _ value _ name ( value ) ) , value.node.node _ id , value.index ) DCNL DCSP if ( value.instance &gt; 1 ) : DCNL DCSP DCSP return &apos; { } _ { } &apos; .format ( _ object _ id , value.instance ) DCNL DCSP return _ object _ id
DCSP alpha = min ( alpha , ( 1 - alpha ) ) DCNL DCSP z = norm.ppf ( ( 1 - ( alpha / 2.0 ) ) ) DCNL DCSP xq = mstats.mquantiles ( data , prob , alphap = 0 , betap = 0 , axis = axis ) DCNL DCSP smj = mjci ( data , prob , axis = axis ) DCNL DCSP return ( ( xq - ( z * smj ) ) , ( xq + ( z * smj ) ) )
DCSP return &#91; server.pool for server in client . _ get _ topology ( ) .select _ servers ( any _ server _ selector ) &#93;
DCSP cmd = &apos; statcpu DCSP -iter DCSP 1 DCSP -t &apos; DCNL DCSP showcpu _ list = run _ ssh _ thread ( ip , user , passwd , cmd ) DCNL DCSP cpu _ list = &#91; &#93; DCNL DCSP line _ num = 0 DCNL DCSP for line in showcpu _ list : DCNL DCSP DCSP line _ num + = 1 DCNL DCSP DCSP if ( line _ num &gt; = 3 ) : DCNL DCSP DCSP DCSP cpu _ stats = line.split ( ) DCNL DCSP DCSP DCSP if ( len ( cpu _ stats ) &gt; 2 ) : DCNL DCSP DCSP DCSP DCSP cpu _ list.append ( cpu _ stats &#91; 0 &#93; .split ( &apos; , &apos; ) &#91; 0 &#93; ) DCNL DCSP return cpu _ list
DCSP config _ stub.data = CONFIG _ NOT _ PRIVATE DCNL DCSP hist.append ( &apos; new DCSP item &apos; ) DCNL DCSP assert ( &apos; new DCSP item &apos; in hist.history ) DCNL DCSP hist.history.remove ( &apos; new DCSP item &apos; ) DCNL DCSP assert ( hist.history = = HISTORY )
DCSP return PKCS115 _ SigScheme ( rsa _ key )
DCSP path = ( backend or settings.EMAIL _ BACKEND ) DCNL DCSP try : DCNL DCSP DCSP ( mod _ name , klass _ name ) = path.rsplit ( &apos; .&apos; , 1 ) DCNL DCSP DCSP mod = import _ module ( mod _ name ) DCNL DCSP except ImportError as e : DCNL DCSP DCSP raise ImproperlyConfigured ( ( &apos; Error DCSP importing DCSP email DCSP backend DCSP module DCSP % s : DCSP &quot; % s &quot; &apos; % ( mod _ name , e ) ) ) DCNL DCSP try : DCNL DCSP DCSP klass = getattr ( mod , klass _ name ) DCNL DCSP except AttributeError : DCNL DCSP DCSP raise ImproperlyConfigured ( ( &apos; Module DCSP &quot; % s &quot; DCSP does DCSP not DCSP define DCSP a DCSP &quot; % s &quot; DCSP class &apos; % ( mod _ name , klass _ name ) ) ) DCNL DCSP return klass ( fail _ silently = fail _ silently , * * kwds )
DCSP devlist = list _ devices ( ) DCNL DCSP print ( ( &apos; Found DCSP % d DCSP CUDA DCSP devices &apos; % len ( devlist ) ) ) DCNL DCSP supported _ count = 0 DCNL DCSP for dev in devlist : DCNL DCSP DCSP attrs = &#91; &#93; DCNL DCSP DCSP cc = dev.compute _ capability DCNL DCSP DCSP attrs + = &#91; ( &apos; compute DCSP capability &apos; , ( &apos; % d . % d &apos; % cc ) ) &#93; DCNL DCSP DCSP attrs + = &#91; ( &apos; pci DCSP device DCSP id &apos; , dev.PCI _ DEVICE _ ID ) &#93; DCNL DCSP DCSP attrs + = &#91; ( &apos; pci DCSP bus DCSP id &apos; , dev.PCI _ BUS _ ID ) &#93; DCNL DCSP DCSP if ( cc &lt; ( 2 , 0 ) ) : DCNL DCSP DCSP DCSP support = &apos; &#91; NOT DCSP SUPPORTED : DCSP CC DCSP &lt; DCSP 2.0 &#93; &apos; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP support = &apos; &#91; SUPPORTED &#93; &apos; DCNL DCSP DCSP DCSP supported _ count + = 1 DCNL DCSP DCSP print ( ( &apos; id DCSP % d DCSP DCSP DCSP DCSP % 20s DCSP % 40s &apos; % ( dev.id , dev.name , support ) ) ) DCNL DCSP DCSP for ( key , val ) in attrs : DCNL DCSP DCSP DCSP print ( ( &apos; % 40s : DCSP % s &apos; % ( key , val ) ) ) DCNL DCSP print ( &apos; Summary : &apos; ) DCNL DCSP print ( ( &apos; DCTB % d / % d DCSP devices DCSP are DCSP supported &apos; % ( supported _ count , len ( devlist ) ) ) ) DCNL DCSP return ( supported _ count &gt; 0 )
DCSP filetree = obj _ store &#91; tree _ sha &#93; DCNL DCSP for ( name , mode , sha ) in filetree.iteritems ( ) : DCNL DCSP DCSP if ( ( not S _ ISGITLINK ( mode ) ) and ( sha not in kset ) ) : DCNL DCSP DCSP DCSP kset.add ( sha ) DCNL DCSP DCSP DCSP if stat.S _ ISDIR ( mode ) : DCNL DCSP DCSP DCSP DCSP _ collect _ filetree _ revs ( obj _ store , sha , kset )
DCSP try : DCNL DCSP DCSP if ( not vm _ ref ) : DCNL DCSP DCSP DCSP vm _ ref = get _ vm _ ref ( session , instance ) DCNL DCSP DCSP LOG.debug ( &apos; Destroying DCSP the DCSP VM &apos; , instance = instance ) DCNL DCSP DCSP destroy _ task = session . _ call _ method ( session.vim , &apos; Destroy _ Task &apos; , vm _ ref ) DCNL DCSP DCSP session . _ wait _ for _ task ( destroy _ task ) DCNL DCSP DCSP LOG.info ( _ LI ( &apos; Destroyed DCSP the DCSP VM &apos; ) , instance = instance ) DCNL DCSP except Exception : DCNL DCSP DCSP LOG.exception ( _ LE ( &apos; Destroy DCSP VM DCSP failed &apos; ) , instance = instance )
DCSP if ( type ( weights ) is Variable ) : DCNL DCSP DCSP n _ topics = weights.data.shape &#91; 1 &#93; DCNL DCSP else : DCNL DCSP DCSP n _ topics = weights.W.data.shape &#91; 1 &#93; DCNL DCSP if ( alpha is None ) : DCNL DCSP DCSP alpha = ( 1.0 / n _ topics ) DCNL DCSP if ( type ( weights ) is Variable ) : DCNL DCSP DCSP log _ proportions = F.log _ softmax ( weights ) DCNL DCSP else : DCNL DCSP DCSP log _ proportions = F.log _ softmax ( weights.W ) DCNL DCSP loss = ( ( alpha - 1.0 ) * log _ proportions ) DCNL DCSP return ( - F.sum ( loss ) )
DCSP from _ cache = False DCNL DCSP if ( cache is not None ) : DCNL DCSP DCSP cache _ path = join ( cache , ( url.split ( &apos; : / / &apos; ) &#91; ( -1 ) &#93; .replace ( &apos; / &apos; , &apos; , &apos; ) + &apos; .zip &apos; ) ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP data = _ open _ cache ( cache _ path ) DCNL DCSP DCSP DCSP from _ cache = True DCNL DCSP DCSP except : DCNL DCSP DCSP DCSP pass DCNL DCSP if ( not from _ cache ) : DCNL DCSP DCSP data = urlopen ( url ) .read ( ) DCNL DCSP DCSP if ( cache is not None ) : DCNL DCSP DCSP DCSP _ cache _ it ( data , cache _ path ) DCNL DCSP return ( data , from _ cache )
DCSP kwargs = locals ( ) DCNL DCSP return _ create _ network _ acl _ entry ( * * kwargs )
DCSP if ( not isinstance ( interfaces , tuple ) ) : DCNL DCSP DCSP raise TypeError ( &apos; The DCSP ``interfaces`` DCSP argument DCSP must DCSP be DCSP a DCSP tuple . DCSP Got : DCSP { ! r } &apos; .format ( interfaces ) ) DCNL DCSP original _ invariant = field _ kwargs.pop ( &apos; invariant &apos; , None ) DCNL DCSP def invariant ( value ) : DCNL DCSP DCSP error _ messages = &#91; &#93; DCNL DCSP DCSP if ( original _ invariant is not None ) : DCNL DCSP DCSP DCSP ( original _ invariant _ result , _ original _ invariant _ message ) = original _ invariant ( value ) DCNL DCSP DCSP DCSP if original _ invariant _ result : DCNL DCSP DCSP DCSP DCSP error _ messages.append ( original _ invariant _ result ) DCNL DCSP DCSP missing _ interfaces = &#91; &#93; DCNL DCSP DCSP for interface in interfaces : DCNL DCSP DCSP DCSP if ( not interface.providedBy ( value ) ) : DCNL DCSP DCSP DCSP DCSP missing _ interfaces.append ( interface.getName ( ) ) DCNL DCSP DCSP if missing _ interfaces : DCNL DCSP DCSP DCSP error _ messages.append ( &apos; The DCSP value DCSP { ! r } DCSP did DCSP not DCSP provide DCSP these DCSP required DCSP interfaces : DCSP { } &apos; .format ( value , &apos; , DCSP &apos; .join ( missing _ interfaces ) ) ) DCNL DCSP DCSP if error _ messages : DCNL DCSP DCSP DCSP return ( False , &apos; \ n &apos; .join ( error _ messages ) ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( True , &apos; &apos; ) DCNL DCSP field _ kwargs &#91; &apos; invariant &apos; &#93; = invariant DCNL DCSP return field ( * * field _ kwargs )
DCSP model = context &#91; &apos; model &apos; &#93; DCNL DCSP id = _ get _ or _ bust ( data _ dict , &apos; id &apos; ) DCNL DCSP entity = model.Resource.get ( id ) DCNL DCSP if ( entity is None ) : DCNL DCSP DCSP raise NotFound DCNL DCSP _ check _ access ( &apos; resource _ delete &apos; , context , data _ dict ) DCNL DCSP package _ id = entity.get _ package _ id ( ) DCNL DCSP pkg _ dict = _ get _ action ( &apos; package _ show &apos; ) ( context , { &apos; id &apos; : package _ id } ) DCNL DCSP for plugin in plugins.PluginImplementations ( plugins.IResourceController ) : DCNL DCSP DCSP plugin.before _ delete ( context , data _ dict , pkg _ dict.get ( &apos; resources &apos; , &#91; &#93; ) ) DCNL DCSP if pkg _ dict.get ( &apos; resources &apos; ) : DCNL DCSP DCSP pkg _ dict &#91; &apos; resources &apos; &#93; = &#91; r for r in pkg _ dict &#91; &apos; resources &apos; &#93; if ( not ( r &#91; &apos; id &apos; &#93; = = id ) ) &#93; DCNL DCSP try : DCNL DCSP DCSP pkg _ dict = _ get _ action ( &apos; package _ update &apos; ) ( context , pkg _ dict ) DCNL DCSP except ValidationError as e : DCNL DCSP DCSP errors = e.error _ dict &#91; &apos; resources &apos; &#93; &#91; ( -1 ) &#93; DCNL DCSP DCSP raise ValidationError ( errors ) DCNL DCSP for plugin in plugins.PluginImplementations ( plugins.IResourceController ) : DCNL DCSP DCSP plugin.after _ delete ( context , pkg _ dict.get ( &apos; resources &apos; , &#91; &#93; ) ) DCNL DCSP model.repo.commit ( )
DCSP root = container.parsed ( name ) DCNL DCSP nodes = root.xpath ( xpath , namespaces = XPNSMAP ) DCNL DCSP if ( not nodes ) : DCNL DCSP DCSP raise AbortError ( ( _ ( u &apos;The DCSP expression DCSP % s DCSP did DCSP not DCSP match DCSP any DCSP nodes &apos; ) % xpath ) ) DCNL DCSP for split _ point in nodes : DCNL DCSP DCSP if in _ table ( split _ point ) : DCNL DCSP DCSP DCSP raise AbortError ( u &apos;Cannot DCSP split DCSP inside DCSP tables &apos; ) DCNL DCSP DCSP if split _ point.tag.endswith ( u &apos; } body &apos; ) : DCNL DCSP DCSP DCSP raise AbortError ( u &apos;Cannot DCSP split DCSP on DCSP the DCSP &lt; body &gt; DCSP tag &apos; ) DCNL DCSP for ( i , tag ) in enumerate ( nodes ) : DCNL DCSP DCSP tag.set ( u &apos;calibre-split-point &apos; , str ( i ) ) DCNL DCSP current = name DCNL DCSP all _ names = &#91; name &#93; DCNL DCSP for i in xrange ( len ( nodes ) ) : DCNL DCSP DCSP current = split ( container , current , ( u &apos; / / * &#91; @ calibre-split-point = &quot; % d &quot; &#93; &apos; % i ) , before = before ) DCNL DCSP DCSP all _ names.append ( current ) DCNL DCSP for x in all _ names : DCNL DCSP DCSP for tag in container.parsed ( x ) .xpath ( u &apos; / / * &#91; @ calibre-split-point &#93; &apos; ) : DCNL DCSP DCSP DCSP tag.attrib.pop ( u &apos;calibre-split-point &apos; ) DCNL DCSP DCSP container.dirty ( x ) DCNL DCSP return all _ names &#91; 1 : &#93;
DCSP if _ _ opts _ _ &#91; &apos; load _ balancers &apos; &#93; .get ( lb , None ) : DCNL DCSP DCSP ( username , password ) = list ( _ _ opts _ _ &#91; &apos; load _ balancers &apos; &#93; &#91; lb &#93; .values ( ) ) DCNL DCSP else : DCNL DCSP DCSP raise Exception ( &apos; Unable DCSP to DCSP find DCSP ` { 0 } ` DCSP load DCSP balancer &apos; .format ( lb ) ) DCNL DCSP F5 = F5Mgmt ( lb , username , password ) DCNL DCSP F5.create _ pool ( name , method ) DCNL DCSP return True
DCSP doc = get _ document ( document _ slug , request ) DCNL DCSP try : DCNL DCSP DCSP sort = int ( request.GET.get ( &apos; sort &apos; , 0 ) ) DCNL DCSP except ValueError : DCNL DCSP DCSP sort = 0 DCNL DCSP try : DCNL DCSP DCSP desc = int ( request.GET.get ( &apos; desc &apos; , 0 ) ) DCNL DCSP except ValueError : DCNL DCSP DCSP desc = 0 DCNL DCSP desc _ toggle = ( 0 if desc else 1 ) DCNL DCSP threads _ = sort _ threads ( doc.thread _ set , sort , desc ) DCNL DCSP threads _ = paginate ( request , threads _ , per _ page = kbforums.THREADS _ PER _ PAGE ) DCNL DCSP feed _ urls = ( ( reverse ( &apos; wiki.discuss.threads.feed &apos; , args = &#91; document _ slug &#93; ) , ThreadsFeed ( ) .title ( doc ) ) , ) DCNL DCSP is _ watching _ forum = ( request.user.is _ authenticated ( ) and NewThreadEvent.is _ notifying ( request.user , doc ) ) DCNL DCSP return render ( request , &apos; kbforums / threads.html &apos; , { &apos; document &apos; : doc , &apos; threads &apos; : threads _ , &apos; is _ watching _ forum &apos; : is _ watching _ forum , &apos; sort &apos; : sort , &apos; desc _ toggle &apos; : desc _ toggle , &apos; feeds &apos; : feed _ urls } )
DCSP return np.uint64 ( struct.unpack ( &apos; &gt; Q &apos; , f.read ( 8 ) ) &#91; 0 &#93; )
DCSP reg = _ get _ registry ( scope , window , tab ) DCNL DCSP try : DCNL DCSP DCSP return reg &#91; name &#93; DCNL DCSP except KeyError : DCNL DCSP DCSP if ( default is not _ UNSET ) : DCNL DCSP DCSP DCSP return default DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise
DCSP args = parse _ command _ line ( args , &#91; &#93; , &#91; &apos; name &apos; &#93; ) DCNL DCSP import lixian _ tasks _ extended DCNL DCSP for x in ( lixian _ tasks _ extended.extend _ links if ( not args.name ) else lixian _ tasks _ extended.extend _ links _ name ) ( args ) : DCNL DCSP DCSP print x
DCSP if ( not isinstance ( connections , collections.Iterable ) ) : DCNL DCSP DCSP connections = &#91; connections &#93; DCNL DCSP router = get _ router ( ) DCNL DCSP message = router.new _ outgoing _ message ( text = text , connections = connections , * * kwargs ) DCNL DCSP router.send _ outgoing ( message ) DCNL DCSP return message
DCSP _ rendered = &apos; &apos; DCNL DCSP _ loaded = { &apos; result &apos; : True , &apos; comment &apos; : &apos; &apos; , &apos; out &apos; : None } DCNL DCSP loaded _ config = None DCNL DCSP if ( template _ engine not in salt.utils.templates.TEMPLATE _ REGISTRY ) : DCNL DCSP DCSP _ loaded.update ( { &apos; result &apos; : False , &apos; comment &apos; : &apos; Invalid DCSP templating DCSP engine ! DCSP Choose DCSP between : DCSP { tpl _ eng _ opts } &apos; .format ( tpl _ eng _ opts = &apos; , DCSP &apos; .join ( list ( salt.utils.templates.TEMPLATE _ REGISTRY.keys ( ) ) ) ) } ) DCNL DCSP DCSP return _ loaded DCNL DCSP salt _ render _ prefixes = ( &apos; salt : / / &apos; , &apos; http : / / &apos; , &apos; https : / / &apos; , &apos; ftp : / / &apos; ) DCNL DCSP salt _ render = False DCNL DCSP for salt _ render _ prefix in salt _ render _ prefixes : DCNL DCSP DCSP if ( not salt _ render ) : DCNL DCSP DCSP DCSP salt _ render = ( salt _ render or template _ name.startswith ( salt _ render _ prefix ) or ( template _ path and template _ path.startswith ( salt _ render _ prefix ) ) ) DCNL DCSP file _ exists = _ _ salt _ _ &#91; &apos; file.file _ exists &apos; &#93; ( template _ name ) DCNL DCSP if ( template _ source or template _ path or file _ exists or salt _ render ) : DCNL DCSP DCSP if template _ source : DCNL DCSP DCSP DCSP if ( not saltenv ) : DCNL DCSP DCSP DCSP DCSP saltenv = ( template _ path if template _ path else &apos; base &apos; ) DCNL DCSP DCSP DCSP _ rendered = _ _ salt _ _ &#91; &apos; file.apply _ template _ on _ contents &apos; &#93; ( contents = template _ source , template = template _ engine , context = template _ vars , defaults = defaults , saltenv = saltenv ) DCNL DCSP DCSP DCSP if ( not isinstance ( _ rendered , six.string _ types ) ) : DCNL DCSP DCSP DCSP DCSP if ( &apos; result &apos; in _ rendered ) : DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = _ rendered &#91; &apos; result &apos; &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP if ( &apos; comment &apos; in _ rendered ) : DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = _ rendered &#91; &apos; comment &apos; &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = &apos; Error DCSP while DCSP rendering DCSP the DCSP template . &apos; DCNL DCSP DCSP DCSP DCSP return _ loaded DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP if ( template _ path and ( not file _ exists ) ) : DCNL DCSP DCSP DCSP DCSP template _ name = _ _ salt _ _ &#91; &apos; file.join &apos; &#93; ( template _ path , template _ name ) DCNL DCSP DCSP DCSP DCSP if ( not saltenv ) : DCNL DCSP DCSP DCSP DCSP DCSP saltenv = ( template _ path if ( not salt _ render ) else &apos; base &apos; ) DCNL DCSP DCSP DCSP elif ( salt _ render and ( not saltenv ) ) : DCNL DCSP DCSP DCSP DCSP saltenv = ( template _ path if template _ path else &apos; base &apos; ) DCNL DCSP DCSP DCSP if ( not saltenv ) : DCNL DCSP DCSP DCSP DCSP saltenv = &apos; base &apos; DCNL DCSP DCSP DCSP _ rand _ filename = _ _ salt _ _ &#91; &apos; random.hash &apos; &#93; ( template _ name , &apos; md5 &apos; ) DCNL DCSP DCSP DCSP _ temp _ file = _ _ salt _ _ &#91; &apos; file.join &apos; &#93; ( &apos; / tmp &apos; , _ rand _ filename ) DCNL DCSP DCSP DCSP _ managed = _ _ salt _ _ &#91; &apos; file.get _ managed &apos; &#93; ( name = _ temp _ file , source = template _ name , source _ hash = template _ hash , source _ hash _ name = template _ hash _ name , user = template _ user , group = template _ group , mode = template _ mode , template = template _ engine , context = template _ vars , defaults = defaults , saltenv = saltenv , skip _ verify = skip _ verify ) DCNL DCSP DCSP DCSP if ( ( not isinstance ( _ managed , ( list , tuple ) ) ) and isinstance ( _ managed , six.string _ types ) ) : DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = _ managed DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP elif ( isinstance ( _ managed , ( list , tuple ) ) and ( not ( len ( _ managed ) &gt; 0 ) ) ) : DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = &apos; Error DCSP while DCSP rendering DCSP the DCSP template . &apos; DCNL DCSP DCSP DCSP elif ( isinstance ( _ managed , ( list , tuple ) ) and ( not ( len ( _ managed &#91; 0 &#93; ) &gt; 0 ) ) ) : DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = _ managed &#91; ( -1 ) &#93; DCNL DCSP DCSP DCSP if _ loaded &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP DCSP _ temp _ tpl _ file = _ managed &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP _ temp _ tpl _ file _ exists = _ _ salt _ _ &#91; &apos; file.file _ exists &apos; &#93; ( _ temp _ tpl _ file ) DCNL DCSP DCSP DCSP DCSP if ( not _ temp _ tpl _ file _ exists ) : DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; result &apos; &#93; = False DCNL DCSP DCSP DCSP DCSP DCSP _ loaded &#91; &apos; comment &apos; &#93; = &apos; Error DCSP while DCSP rendering DCSP the DCSP template . &apos; DCNL DCSP DCSP DCSP DCSP DCSP return _ loaded DCNL DCSP DCSP DCSP DCSP _ rendered = open ( _ temp _ tpl _ file ) .read ( ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP return _ loaded DCNL DCSP DCSP if debug : DCNL DCSP DCSP DCSP loaded _ config = _ rendered DCNL DCSP DCSP if _ loaded &#91; &apos; result &apos; &#93; : DCNL DCSP DCSP DCSP fun = &apos; load _ merge _ candidate &apos; DCNL DCSP DCSP DCSP if replace : DCNL DCSP DCSP DCSP DCSP fun = &apos; load _ replace _ candidate &apos; DCNL DCSP DCSP DCSP _ loaded = _ _ proxy _ _ &#91; &apos; napalm.call &apos; &#93; ( fun , * * { &apos; config &apos; : _ rendered } ) DCNL DCSP else : DCNL DCSP DCSP load _ templates _ params = ( defaults if defaults else { } ) DCNL DCSP DCSP load _ templates _ params.update ( template _ vars ) DCNL DCSP DCSP load _ templates _ params.update ( { &apos; template _ name &apos; : template _ name , &apos; template _ source &apos; : template _ source , &apos; template _ path &apos; : template _ path , &apos; pillar &apos; : _ _ pillar _ _ , &apos; grains &apos; : _ _ grains _ _ , &apos; opts &apos; : _ _ opts _ _ } ) DCNL DCSP DCSP _ loaded = _ _ proxy _ _ &#91; &apos; napalm.call &apos; &#93; ( &apos; load _ template &apos; , * * load _ templates _ params ) DCNL DCSP return _ config _ logic ( _ loaded , test = test , commit _ config = commit , loaded _ config = loaded _ config )
DCSP if ( not encoding ) : DCNL DCSP DCSP if ( image.ndim = = 3 ) : DCNL DCSP DCSP DCSP image = image.transpose ( ( 2 , 0 , 1 ) ) DCNL DCSP DCSP DCSP if ( image.shape &#91; 0 &#93; = = 3 ) : DCNL DCSP DCSP DCSP DCSP image = image &#91; &#91; 2 , 1 , 0 &#93; , ... &#93; DCNL DCSP DCSP elif ( image.ndim = = 2 ) : DCNL DCSP DCSP DCSP image = image &#91; np.newaxis , : , : &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise Exception ( ( &apos; Image DCSP has DCSP unrecognized DCSP shape : DCSP &quot; % s &quot; &apos; % image.shape ) ) DCNL DCSP DCSP datum = caffe.io.array _ to _ datum ( image , label ) DCNL DCSP else : DCNL DCSP DCSP datum = caffe _ pb2.Datum ( ) DCNL DCSP DCSP if ( image.ndim = = 3 ) : DCNL DCSP DCSP DCSP datum.channels = image.shape &#91; 2 &#93; DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP datum.channels = 1 DCNL DCSP DCSP datum.height = image.shape &#91; 0 &#93; DCNL DCSP DCSP datum.width = image.shape &#91; 1 &#93; DCNL DCSP DCSP datum.label = label DCNL DCSP DCSP s = StringIO ( ) DCNL DCSP DCSP if ( encoding = = &apos; png &apos; ) : DCNL DCSP DCSP DCSP PIL.Image.fromarray ( image ) .save ( s , format = &apos; PNG &apos; ) DCNL DCSP DCSP elif ( encoding = = &apos; jpg &apos; ) : DCNL DCSP DCSP DCSP PIL.Image.fromarray ( image ) .save ( s , format = &apos; JPEG &apos; , quality = 90 ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP raise ValueError ( &apos; Invalid DCSP encoding DCSP type &apos; ) DCNL DCSP DCSP datum.data = s.getvalue ( ) DCNL DCSP DCSP datum.encoded = True DCNL DCSP return datum
DCSP with tf.Session ( ) as sess : DCNL DCSP DCSP print ( &apos; Self-test DCSP for DCSP neural DCSP translation DCSP model . &apos; ) DCNL DCSP DCSP model = seq2seq _ model.Seq2SeqModel ( 10 , 10 , &#91; ( 3 , 3 ) , ( 6 , 6 ) &#93; , 32 , 2 , 5.0 , 32 , 0.3 , 0.99 , num _ samples = 8 ) DCNL DCSP DCSP sess.run ( tf.global _ variables _ initializer ( ) ) DCNL DCSP DCSP data _ set = ( &#91; ( &#91; 1 , 1 &#93; , &#91; 2 , 2 &#93; ) , ( &#91; 3 , 3 &#93; , &#91; 4 &#93; ) , ( &#91; 5 &#93; , &#91; 6 &#93; ) &#93; , &#91; ( &#91; 1 , 1 , 1 , 1 , 1 &#93; , &#91; 2 , 2 , 2 , 2 , 2 &#93; ) , ( &#91; 3 , 3 , 3 &#93; , &#91; 5 , 6 &#93; ) &#93; ) DCNL DCSP DCSP for _ in xrange ( 5 ) : DCNL DCSP DCSP DCSP bucket _ id = random.choice ( &#91; 0 , 1 &#93; ) DCNL DCSP DCSP DCSP ( encoder _ inputs , decoder _ inputs , target _ weights ) = model.get _ batch ( data _ set , bucket _ id ) DCNL DCSP DCSP DCSP model.step ( sess , encoder _ inputs , decoder _ inputs , target _ weights , bucket _ id , False )
DCSP ch _ names = &#91; c &#91; &apos; ch _ name &apos; &#93; for c in chs &#93; DCNL DCSP row _ cals = np.zeros ( len ( row _ names ) ) DCNL DCSP col _ cals = np.zeros ( len ( col _ names ) ) DCNL DCSP for ( names , cals , inv ) in zip ( ( row _ names , col _ names ) , ( row _ cals , col _ cals ) , ( False , True ) ) : DCNL DCSP DCSP for ii in range ( len ( cals ) ) : DCNL DCSP DCSP DCSP p = ch _ names.count ( names &#91; ii &#93; ) DCNL DCSP DCSP DCSP if ( p ! = 1 ) : DCNL DCSP DCSP DCSP DCSP raise RuntimeError ( ( &apos; Channel DCSP % s DCSP does DCSP not DCSP appear DCSP exactly DCSP once DCSP in DCSP data &apos; % names &#91; ii &#93; ) ) DCNL DCSP DCSP DCSP idx = ch _ names.index ( names &#91; ii &#93; ) DCNL DCSP DCSP DCSP val = ( chs &#91; idx &#93; &#91; mult _ keys &#91; 0 &#93; &#93; * chs &#91; idx &#93; &#91; mult _ keys &#91; 1 &#93; &#93; ) DCNL DCSP DCSP DCSP val = ( float ( ( 1.0 / val ) ) if inv else float ( val ) ) DCNL DCSP DCSP DCSP val = ( ( 1.0 / val ) if flip else val ) DCNL DCSP DCSP DCSP cals &#91; ii &#93; = val DCNL DCSP comp &#91; &apos; rowcals &apos; &#93; = row _ cals DCNL DCSP comp &#91; &apos; colcals &apos; &#93; = col _ cals DCNL DCSP comp &#91; &apos; data &apos; &#93; &#91; &apos; data &apos; &#93; = ( ( row _ cals &#91; : , None &#93; * comp &#91; &apos; data &apos; &#93; &#91; &apos; data &apos; &#93; ) * col _ cals &#91; None , : &#93; )
DCSP profile = request.user.profile DCNL DCSP opportunity = get _ object _ or _ 404 ( Opportunity , pk = opportunity _ id ) DCNL DCSP if ( ( not profile.has _ permission ( opportunity ) ) and ( not profile.is _ admin ( &apos; treeio.sales &apos; ) ) ) : DCNL DCSP DCSP return user _ denied ( request , message = &quot; You DCSP don &apos;t DCSP have DCSP access DCSP to DCSP this DCSP Opportunity &quot; ) DCNL DCSP form = _ do _ update _ record ( profile , request , opportunity ) DCNL DCSP return render _ to _ response ( &apos; sales / opportunity _ view &apos; , { &apos; opportunity &apos; : opportunity , &apos; record _ form &apos; : form } , context _ instance = RequestContext ( request ) , response _ format = response _ format )
DCSP if ( call ! = &apos; action &apos; ) : DCNL DCSP DCSP raise SaltCloudSystemExit ( &apos; The DCSP start DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -a DCSP or DCSP --action . &apos; ) DCNL DCSP data = show _ instance ( name , call = &apos; action &apos; ) DCNL DCSP if ( data.get ( &apos; status &apos; ) = = &apos; active &apos; ) : DCNL DCSP DCSP return { &apos; success &apos; : True , &apos; action &apos; : &apos; start &apos; , &apos; status &apos; : &apos; active &apos; , &apos; msg &apos; : &apos; Machine DCSP is DCSP already DCSP running . &apos; } DCNL DCSP ret = query ( droplet _ id = data &#91; &apos; id &apos; &#93; , command = &apos; actions &apos; , args = { &apos; type &apos; : &apos; power _ on &apos; } , http _ method = &apos; post &apos; ) DCNL DCSP return { &apos; success &apos; : True , &apos; action &apos; : ret &#91; &apos; action &apos; &#93; &#91; &apos; type &apos; &#93; , &apos; state &apos; : ret &#91; &apos; action &apos; &#93; &#91; &apos; status &apos; &#93; }
DCSP if ( img.ndim &lt; 1 ) : DCNL DCSP DCSP raise ValueError ( &apos; Input DCSP array DCSP has DCSP to DCSP be DCSP at DCSP least DCSP 1D &apos; ) DCNL DCSP img _ baseshape = ( img.shape &#91; : ( -1 ) &#93; if multichannel else img.shape ) DCNL DCSP if ( img _ baseshape ! = mask.shape ) : DCNL DCSP DCSP raise ValueError ( &apos; Input DCSP arrays DCSP have DCSP to DCSP be DCSP the DCSP same DCSP shape &apos; ) DCNL DCSP if np.ma.isMaskedArray ( img ) : DCNL DCSP DCSP raise TypeError ( &apos; Masked DCSP arrays DCSP are DCSP not DCSP supported &apos; ) DCNL DCSP img = skimage.img _ as _ float ( img ) DCNL DCSP mask = mask.astype ( np.bool ) DCNL DCSP kernel = ndi.morphology.generate _ binary _ structure ( mask.ndim , 1 ) DCNL DCSP mask _ dilated = ndi.morphology.binary _ dilation ( mask , structure = kernel ) DCNL DCSP ( mask _ labeled , num _ labels ) = label ( mask _ dilated , return _ num = True ) DCNL DCSP mask _ labeled * = mask DCNL DCSP if ( not multichannel ) : DCNL DCSP DCSP img = img &#91; ... , np.newaxis &#93; DCNL DCSP out = np.copy ( img ) DCNL DCSP for idx _ channel in range ( img.shape &#91; ( -1 ) &#93; ) : DCNL DCSP DCSP known _ points = img &#91; ... , idx _ channel &#93; &#91; ( ~ mask ) &#93; DCNL DCSP DCSP limits = ( np.min ( known _ points ) , np.max ( known _ points ) ) DCNL DCSP DCSP for idx _ region in range ( 1 , ( num _ labels + 1 ) ) : DCNL DCSP DCSP DCSP mask _ region = ( mask _ labeled = = idx _ region ) DCNL DCSP DCSP DCSP _ inpaint _ biharmonic _ single _ channel ( img &#91; ... , idx _ channel &#93; , mask _ region , out &#91; ... , idx _ channel &#93; , limits ) DCNL DCSP if ( not multichannel ) : DCNL DCSP DCSP out = out &#91; ... , 0 &#93; DCNL DCSP return out
DCSP global _ TEST _ RESULT DCNL DCSP res = _ TEST _ RESULT DCNL DCSP _ TEST _ RESULT = &#91; &#93; DCNL DCSP return res
DCSP if ( mode not in &#91; &apos; mirror &apos; , &apos; constant &apos; , &apos; nearest &apos; , &apos; interp &apos; , &apos; wrap &apos; &#93; ) : DCNL DCSP DCSP raise ValueError ( &quot; mode DCSP must DCSP be DCSP &apos; mirror &apos; , DCSP &apos; constant &apos; , DCSP &apos; nearest &apos; DCSP &apos; wrap &apos; DCSP or DCSP &apos; interp &apos; . &quot; ) DCNL DCSP x = np.asarray ( x ) DCNL DCSP if ( ( x.dtype ! = np.float64 ) and ( x.dtype ! = np.float32 ) ) : DCNL DCSP DCSP x = x.astype ( np.float64 ) DCNL DCSP coeffs = savgol _ coeffs ( window _ length , polyorder , deriv = deriv , delta = delta ) DCNL DCSP if ( mode = = &apos; interp &apos; ) : DCNL DCSP DCSP y = convolve1d ( x , coeffs , axis = axis , mode = &apos; constant &apos; ) DCNL DCSP DCSP _ fit _ edges _ polyfit ( x , window _ length , polyorder , deriv , delta , axis , y ) DCNL DCSP else : DCNL DCSP DCSP y = convolve1d ( x , coeffs , axis = axis , mode = mode , cval = cval ) DCNL DCSP return y
DCSP assert hug.introspect.takes _ kwargs ( function _ with _ kwargs ) DCNL DCSP assert ( not hug.introspect.takes _ kwargs ( function _ with _ args ) ) DCNL DCSP assert ( not hug.introspect.takes _ kwargs ( function _ with _ neither ) ) DCNL DCSP assert hug.introspect.takes _ kwargs ( function _ with _ both )
DCSP global NORUN DCNL DCSP ( NORUN , nr _ old ) = ( True , NORUN ) DCNL DCSP tmp = default _ app.push ( ) DCNL DCSP try : DCNL DCSP DCSP rv = load ( target ) DCNL DCSP DCSP return ( rv if callable ( rv ) else tmp ) DCNL DCSP finally : DCNL DCSP DCSP default _ app.remove ( tmp ) DCNL DCSP DCSP NORUN = nr _ old
DCSP f1 = ( ( ( 2.0 * precision ) * recall ) / T.maximum ( 1 , ( precision + recall ) ) ) DCNL DCSP return f1
DCSP s = ( u &apos; % s = % -4s &apos; % ( lead , str ( num ) ) ) DCNL DCSP if ( ( num ! = 0 ) and ANSIBLE _ COLOR and ( color is not None ) ) : DCNL DCSP DCSP s = stringc ( s , color ) DCNL DCSP return s
DCSP arrs = &#91; cupy.atleast _ 1d ( a ) for a in tup &#93; DCNL DCSP axis = 1 DCNL DCSP if ( arrs &#91; 0 &#93; .ndim = = 1 ) : DCNL DCSP DCSP axis = 0 DCNL DCSP return concatenate ( arrs , axis )
DCSP output _ file = ( PROFILING _ OUTPUT _ FMT % get _ filename _ fmt ( ) ) DCNL DCSP process _ info = { } DCNL DCSP for proc in psutil.process _ iter ( ) : DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP pinfo = proc.as _ dict ( attrs = &#91; &apos; pid &apos; , &apos; name &apos; , &apos; parent &apos; , &apos; status &apos; , &apos; io _ counters &apos; , &apos; num _ threads &apos; , &apos; cpu _ times &apos; , &apos; cpu _ percent &apos; , &apos; memory _ info _ ex &apos; , &apos; memory _ percent &apos; , &apos; exe &apos; , &apos; cmdline &apos; &#93; ) DCNL DCSP DCSP except psutil.NoSuchProcess : DCNL DCSP DCSP DCSP pass DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP for ( info _ name , info _ data ) in pinfo.iteritems ( ) : DCNL DCSP DCSP DCSP DCSP if hasattr ( info _ data , &apos; _ asdict &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP pinfo &#91; info _ name &#93; = dict ( info _ data . _ asdict ( ) ) DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP pinfo &#91; info _ name &#93; = info _ data DCNL DCSP DCSP DCSP process _ info &#91; pinfo &#91; &apos; pid &apos; &#93; &#93; = pinfo DCNL DCSP netinfo = psutil.net _ io _ counters ( pernic = True ) DCNL DCSP for ( key , value ) in netinfo.iteritems ( ) : DCNL DCSP DCSP netinfo &#91; key &#93; = value . _ asdict ( ) DCNL DCSP pids _ to _ show = &#91; &#93; DCNL DCSP for ( pid , pinfo ) in process _ info.iteritems ( ) : DCNL DCSP DCSP exe = str ( pinfo &#91; &apos; exe &apos; &#93; ) DCNL DCSP DCSP if ( ( &apos; python &apos; in exe ) and ( &apos; w3af &apos; in exe ) ) : DCNL DCSP DCSP DCSP pids _ to _ show.append ( pid ) DCNL DCSP ps _ mem _ data = ps _ mem _ to _ json ( * get _ memory _ usage ( pids _ to _ show , True ) ) DCNL DCSP psutil _ data = { &apos; CPU &apos; : psutil.cpu _ times ( ) . _ asdict ( ) , &apos; Load DCSP average &apos; : os.getloadavg ( ) , &apos; Virtual DCSP memory &apos; : psutil.virtual _ memory ( ) . _ asdict ( ) , &apos; Swap DCSP memory &apos; : psutil.swap _ memory ( ) . _ asdict ( ) , &apos; Network &apos; : netinfo , &apos; Processes &apos; : process _ info , &apos; ps _ mem &apos; : ps _ mem _ data , &apos; Thread DCSP CPU DCSP usage &apos; : get _ threads _ cpu _ percent ( ) } DCNL DCSP json.dump ( psutil _ data , file ( output _ file , &apos; w &apos; ) , indent = 4 , sort _ keys = True )
DCSP if ( not eval _ data ) : DCNL DCSP DCSP filenames = &#91; os.path.join ( data _ dir , ( &apos; data _ batch _ % d.bin &apos; % i ) ) for i in xrange ( 1 , 6 ) &#93; DCNL DCSP DCSP num _ examples _ per _ epoch = NUM _ EXAMPLES _ PER _ EPOCH _ FOR _ TRAIN DCNL DCSP else : DCNL DCSP DCSP filenames = &#91; os.path.join ( data _ dir , &apos; test _ batch.bin &apos; ) &#93; DCNL DCSP DCSP num _ examples _ per _ epoch = NUM _ EXAMPLES _ PER _ EPOCH _ FOR _ EVAL DCNL DCSP for f in filenames : DCNL DCSP DCSP if ( not tf.gfile.Exists ( f ) ) : DCNL DCSP DCSP DCSP raise ValueError ( ( &apos; Failed DCSP to DCSP find DCSP file : DCSP &apos; + f ) ) DCNL DCSP filename _ queue = tf.train.string _ input _ producer ( filenames ) DCNL DCSP read _ input = read _ cifar10 ( filename _ queue ) DCNL DCSP reshaped _ image = tf.cast ( read _ input.uint8image , tf.float32 ) DCNL DCSP height = IMAGE _ SIZE DCNL DCSP width = IMAGE _ SIZE DCNL DCSP resized _ image = tf.image.resize _ image _ with _ crop _ or _ pad ( reshaped _ image , width , height ) DCNL DCSP float _ image = tf.image.per _ image _ standardization ( resized _ image ) DCNL DCSP float _ image.set _ shape ( &#91; height , width , 3 &#93; ) DCNL DCSP read _ input.label.set _ shape ( &#91; 1 &#93; ) DCNL DCSP min _ fraction _ of _ examples _ in _ queue = 0.4 DCNL DCSP min _ queue _ examples = int ( ( num _ examples _ per _ epoch * min _ fraction _ of _ examples _ in _ queue ) ) DCNL DCSP return _ generate _ image _ and _ label _ batch ( float _ image , read _ input.label , min _ queue _ examples , batch _ size , shuffle = False )
DCSP if isinstance ( scope , list ) : DCNL DCSP DCSP return &#91; unicode _ type ( s ) for s in scope &#93; DCNL DCSP if isinstance ( scope , set ) : DCNL DCSP DCSP scope _ to _ list ( list ( scope ) ) DCNL DCSP elif ( scope is None ) : DCNL DCSP DCSP return None DCNL DCSP else : DCNL DCSP DCSP return scope.split ( u &apos; DCSP &apos; )
DCSP pool = tuple ( iterable ) DCNL DCSP n = len ( pool ) DCNL DCSP indices = list ( range ( n ) ) DCNL DCSP cycles = list ( range ( 1 , ( n + 1 ) ) ) &#91; : : ( -1 ) &#93; DCNL DCSP ( yield &#91; pool &#91; i &#93; for i in indices &#93; ) DCNL DCSP while n : DCNL DCSP DCSP for i in reversed ( range ( n ) ) : DCNL DCSP DCSP DCSP j = ( cycles &#91; i &#93; - 1 ) DCNL DCSP DCSP DCSP if ( j = = 0 ) : DCNL DCSP DCSP DCSP DCSP indices &#91; i : &#93; = ( indices &#91; ( i + 1 ) : &#93; + indices &#91; i : ( i + 1 ) &#93; ) DCNL DCSP DCSP DCSP DCSP cycles &#91; i &#93; = ( n - i ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP cycles &#91; i &#93; = j DCNL DCSP DCSP DCSP DCSP ( indices &#91; i &#93; , indices &#91; ( - j ) &#93; ) = ( indices &#91; ( - j ) &#93; , indices &#91; i &#93; ) DCNL DCSP DCSP DCSP DCSP ( yield &#91; pool &#91; i &#93; for i in indices &#93; ) DCNL DCSP DCSP DCSP DCSP break DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return
DCSP comment = &apos; An DCSP error DCSP occurred DCSP pushing DCSP your DCSP image &apos; DCNL DCSP status &#91; &apos; out &apos; &#93; = &apos; &apos; DCNL DCSP try : DCNL DCSP DCSP status &#91; &apos; out &apos; &#93; + = ( &apos; \ n &apos; + ret ) DCNL DCSP DCSP for err _ log in logs : DCNL DCSP DCSP DCSP if isinstance ( err _ log , dict ) : DCNL DCSP DCSP DCSP DCSP if ( &apos; errorDetail &apos; in err _ log ) : DCNL DCSP DCSP DCSP DCSP DCSP if ( &apos; code &apos; in err _ log &#91; &apos; errorDetail &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP msg = &apos; \ n { 0 } \ n { 1 } : DCSP { 2 } &apos; .format ( err _ log &#91; &apos; error &apos; &#93; , err _ log &#91; &apos; errorDetail &apos; &#93; &#91; &apos; code &apos; &#93; , err _ log &#91; &apos; errorDetail &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP DCSP msg = &apos; \ n { 0 } \ n { 1 } &apos; .format ( err _ log &#91; &apos; error &apos; &#93; , err _ log &#91; &apos; errorDetail &apos; &#93; &#91; &apos; message &apos; &#93; ) DCNL DCSP DCSP DCSP DCSP DCSP comment + = msg DCNL DCSP except Exception : DCNL DCSP DCSP trace = traceback.format _ exc ( ) DCNL DCSP DCSP status &#91; &apos; out &apos; &#93; = &apos; An DCSP error DCSP occurred DCSP while DCSP parsing DCSP error DCSP output : \ n { 0 } &apos; .format ( trace ) DCNL DCSP _ invalid ( status , comment = comment ) DCNL DCSP return status
DCSP site = context &#91; &apos; _ _ CACTUS _ SITE _ _ &apos; &#93; DCNL DCSP page = context &#91; &apos; _ _ CACTUS _ CURRENT _ PAGE _ _ &apos; &#93; DCNL DCSP url = site.get _ url _ for _ page ( link _ url ) DCNL DCSP if ( url is None ) : DCNL DCSP DCSP link _ url _ index = os.path.join ( link _ url , &apos; index.html &apos; ) DCNL DCSP DCSP url _ link _ url _ index = site.get _ url _ for _ page ( link _ url _ index ) DCNL DCSP DCSP if ( url _ link _ url _ index is None ) : DCNL DCSP DCSP DCSP logger.warning ( &apos; % s : DCSP page DCSP resource DCSP does DCSP not DCSP exist : DCSP % s &apos; , page.link _ url , link _ url ) DCNL DCSP DCSP url = link _ url DCNL DCSP if site.prettify _ urls : DCNL DCSP DCSP return url.rsplit ( &apos; index.html &apos; , 1 ) &#91; 0 &#93; DCNL DCSP return url
DCSP ( mu , sigma ) = ( 100 , 15 ) DCNL DCSP x = ( mu + ( sigma * np.random.randn ( 10000 ) ) ) DCNL DCSP num _ bins = 50 DCNL DCSP ( n , bins , patches ) = plt.hist ( x , bins = num _ bins , normed = 1 , color = &apos; green &apos; , alpha = 0.6 , label = &apos; hist &apos; ) DCNL DCSP y = mlab.normpdf ( bins , mu , sigma ) DCNL DCSP plt.plot ( bins , y , &apos; r-- &apos; , label = &apos; line &apos; ) DCNL DCSP plt.legend ( loc = &apos; upper DCSP left &apos; , shadow = True ) DCNL DCSP plt.show ( ) DCNL DCSP return
DCSP pass
DCSP if ( name in predefined _ linkers ) : DCNL DCSP DCSP raise ValueError ( ( &apos; Linker DCSP name DCSP already DCSP taken : DCSP % s &apos; % name ) ) DCNL DCSP predefined _ linkers &#91; name &#93; = linker
DCSP if ( not _ hashFuncParams.has _ key ( h ) ) : DCNL DCSP DCSP warning ( &apos; pkcs _ mgf1 : DCSP invalid DCSP hash DCSP ( % s ) DCSP provided &apos; ) DCNL DCSP DCSP return None DCNL DCSP hLen = _ hashFuncParams &#91; h &#93; &#91; 0 &#93; DCNL DCSP hFunc = _ hashFuncParams &#91; h &#93; &#91; 1 &#93; DCNL DCSP if ( maskLen &gt; ( ( 2 * * 32 ) * hLen ) ) : DCNL DCSP DCSP warning ( &apos; pkcs _ mgf1 : DCSP maskLen DCSP &gt; DCSP 2 * * 32 DCSP * DCSP hLen &apos; ) DCNL DCSP DCSP return None DCNL DCSP T = &apos; &apos; DCNL DCSP maxCounter = math.ceil ( ( float ( maskLen ) / float ( hLen ) ) ) DCNL DCSP counter = 0 DCNL DCSP while ( counter &lt; maxCounter ) : DCNL DCSP DCSP C = pkcs _ i2osp ( counter , 4 ) DCNL DCSP DCSP T + = hFunc ( ( mgfSeed + C ) ) DCNL DCSP DCSP counter + = 1 DCNL DCSP return T &#91; : maskLen &#93;
DCSP if ( image.content is not None ) : DCNL DCSP DCSP return image _ annotator _ pb2.Image ( content = image.content ) DCNL DCSP if ( image.source is not None ) : DCNL DCSP DCSP return image _ annotator _ pb2.Image ( source = image _ annotator _ pb2.ImageSource ( gcs _ image _ uri = image.source ) ) DCNL DCSP raise ValueError ( &apos; No DCSP image DCSP content DCSP or DCSP source DCSP found . &apos; )
DCSP if ( base is None ) : DCNL DCSP DCSP base = _ _ opts _ _ &#91; &apos; cachedir &apos; &#93; DCNL DCSP needed _ dirs = ( base , os.path.join ( base , &apos; requested &apos; ) , os.path.join ( base , &apos; active &apos; ) ) DCNL DCSP for dir _ in needed _ dirs : DCNL DCSP DCSP if ( not os.path.exists ( dir _ ) ) : DCNL DCSP DCSP DCSP os.makedirs ( dir _ ) DCNL DCSP DCSP os.chmod ( base , 493 ) DCNL DCSP return base
DCSP installed _ extensions = &#91; &#93; DCNL DCSP for entry _ point in pkg _ resources.iter _ entry _ points ( u &apos;mopidy.ext &apos; ) : DCNL DCSP DCSP logger.debug ( u &apos;Loading DCSP entry DCSP point : DCSP % s &apos; , entry _ point ) DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP extension _ class = entry _ point.load ( require = False ) DCNL DCSP DCSP except Exception as e : DCNL DCSP DCSP DCSP logger.exception ( ( u &apos;Failed DCSP to DCSP load DCSP extension DCSP % s : DCSP % s &apos; % ( entry _ point.name , e ) ) ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP if ( not issubclass ( extension _ class , Extension ) ) : DCNL DCSP DCSP DCSP DCSP raise TypeError DCNL DCSP DCSP except TypeError : DCNL DCSP DCSP DCSP logger.error ( u &apos;Entry DCSP point DCSP % s DCSP did DCSP not DCSP contain DCSP a DCSP valid DCSP extensionclass : DCSP % r &apos; , entry _ point.name , extension _ class ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP try : DCNL DCSP DCSP DCSP extension = extension _ class ( ) DCNL DCSP DCSP DCSP config _ schema = extension.get _ config _ schema ( ) DCNL DCSP DCSP DCSP default _ config = extension.get _ default _ config ( ) DCNL DCSP DCSP DCSP command = extension.get _ command ( ) DCNL DCSP DCSP except Exception : DCNL DCSP DCSP DCSP logger.exception ( u &apos;Setup DCSP of DCSP extension DCSP from DCSP entry DCSP point DCSP % s DCSP failed , DCSP ignoring DCSP extension . &apos; , entry _ point.name ) DCNL DCSP DCSP DCSP continue DCNL DCSP DCSP installed _ extensions.append ( ExtensionData ( extension , entry _ point , config _ schema , default _ config , command ) ) DCNL DCSP DCSP logger.debug ( u &apos;Loaded DCSP extension : DCSP % s DCSP % s &apos; , extension.dist _ name , extension.version ) DCNL DCSP names = ( ed.extension.ext _ name for ed in installed _ extensions ) DCNL DCSP logger.debug ( u &apos;Discovered DCSP extensions : DCSP % s &apos; , u &apos; , DCSP &apos; .join ( names ) ) DCNL DCSP return installed _ extensions
DCSP try : DCNL DCSP DCSP checksd _ path = get _ checksd _ path ( osname ) DCNL DCSP except PathNotFound as e : DCNL DCSP DCSP log.error ( e.args &#91; 0 &#93; ) DCNL DCSP DCSP sys.exit ( 3 ) DCNL DCSP places = &#91; ( lambda name : os.path.join ( agentConfig &#91; &apos; additional _ checksd &apos; &#93; , ( &apos; % s.py &apos; % name ) ) ) &#93; DCNL DCSP try : DCNL DCSP DCSP sdk _ integrations = get _ sdk _ integrations _ path ( osname ) DCNL DCSP DCSP places.append ( ( lambda name : os.path.join ( sdk _ integrations , name , &apos; check.py &apos; ) ) ) DCNL DCSP except PathNotFound : DCNL DCSP DCSP log.debug ( &apos; No DCSP sdk DCSP integrations DCSP path DCSP found &apos; ) DCNL DCSP places.append ( ( lambda name : os.path.join ( checksd _ path , ( &apos; % s.py &apos; % name ) ) ) ) DCNL DCSP return places
DCSP group _ type _ id = _ group _ type _ get _ id _ from _ group _ type ( context , type _ id ) DCNL DCSP count = _ group _ type _ access _ query ( context ) .filter _ by ( group _ type _ id = group _ type _ id ) .filter _ by ( project _ id = project _ id ) .soft _ delete ( synchronize _ session = False ) DCNL DCSP if ( count = = 0 ) : DCNL DCSP DCSP raise exception.GroupTypeAccessNotFound ( group _ type _ id = type _ id , project _ id = project _ id )
DCSP params &#91; &apos; text &apos; &#93; .set _ visible ( False ) DCNL DCSP ax = params &#91; &apos; ax &apos; &#93; DCNL DCSP butterfly = params &#91; &apos; butterfly &apos; &#93; DCNL DCSP if butterfly : DCNL DCSP DCSP ch _ start = 0 DCNL DCSP DCSP n _ channels = len ( params &#91; &apos; picks &apos; &#93; ) DCNL DCSP DCSP data = ( params &#91; &apos; data &apos; &#93; * params &#91; &apos; butterfly _ scale &apos; &#93; ) DCNL DCSP else : DCNL DCSP DCSP ch _ start = params &#91; &apos; ch _ start &apos; &#93; DCNL DCSP DCSP n _ channels = params &#91; &apos; n _ channels &apos; &#93; DCNL DCSP DCSP data = ( params &#91; &apos; data &apos; &#93; * params &#91; &apos; scale _ factor &apos; &#93; ) DCNL DCSP offsets = params &#91; &apos; offsets &apos; &#93; DCNL DCSP lines = params &#91; &apos; lines &apos; &#93; DCNL DCSP epochs = params &#91; &apos; epochs &apos; &#93; DCNL DCSP n _ times = len ( epochs.times ) DCNL DCSP tick _ list = list ( ) DCNL DCSP start _ idx = int ( ( params &#91; &apos; t _ start &apos; &#93; / n _ times ) ) DCNL DCSP end = ( params &#91; &apos; t _ start &apos; &#93; + params &#91; &apos; duration &apos; &#93; ) DCNL DCSP end _ idx = int ( ( end / n _ times ) ) DCNL DCSP xlabels = params &#91; &apos; labels &apos; &#93; &#91; start _ idx : &#93; DCNL DCSP event _ ids = params &#91; &apos; epochs &apos; &#93; .events &#91; : , 2 &#93; DCNL DCSP params &#91; &apos; ax2 &apos; &#93; .set _ xticklabels ( event _ ids &#91; start _ idx : &#93; ) DCNL DCSP ax.set _ xticklabels ( xlabels ) DCNL DCSP ylabels = ax.yaxis.get _ ticklabels ( ) DCNL DCSP for line _ idx in range ( n _ channels ) : DCNL DCSP DCSP ch _ idx = ( line _ idx + ch _ start ) DCNL DCSP DCSP if ( line _ idx &gt; = len ( lines ) ) : DCNL DCSP DCSP DCSP break DCNL DCSP DCSP elif ( ch _ idx &lt; len ( params &#91; &apos; ch _ names &apos; &#93; ) ) : DCNL DCSP DCSP DCSP if butterfly : DCNL DCSP DCSP DCSP DCSP ch _ type = params &#91; &apos; types &apos; &#93; &#91; ch _ idx &#93; DCNL DCSP DCSP DCSP DCSP if ( ch _ type = = &apos; grad &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP offset = offsets &#91; 0 &#93; DCNL DCSP DCSP DCSP DCSP elif ( ch _ type = = &apos; mag &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP offset = offsets &#91; 1 &#93; DCNL DCSP DCSP DCSP DCSP elif ( ch _ type = = &apos; eeg &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP offset = offsets &#91; 2 &#93; DCNL DCSP DCSP DCSP DCSP elif ( ch _ type = = &apos; eog &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP offset = offsets &#91; 3 &#93; DCNL DCSP DCSP DCSP DCSP elif ( ch _ type = = &apos; ecg &apos; ) : DCNL DCSP DCSP DCSP DCSP DCSP offset = offsets &#91; 4 &#93; DCNL DCSP DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ segments ( list ( ) ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP tick _ list + = &#91; params &#91; &apos; ch _ names &apos; &#93; &#91; ch _ idx &#93; &#93; DCNL DCSP DCSP DCSP DCSP offset = offsets &#91; line _ idx &#93; DCNL DCSP DCSP DCSP this _ data = data &#91; ch _ idx &#93; DCNL DCSP DCSP DCSP ydata = ( offset - this _ data ) DCNL DCSP DCSP DCSP xdata = params &#91; &apos; times &apos; &#93; &#91; : params &#91; &apos; duration &apos; &#93; &#93; DCNL DCSP DCSP DCSP num _ epochs = np.min ( &#91; params &#91; &apos; n _ epochs &apos; &#93; , len ( epochs.events ) &#93; ) DCNL DCSP DCSP DCSP segments = np.split ( np.array ( ( xdata , ydata ) ) .T , num _ epochs ) DCNL DCSP DCSP DCSP ch _ name = params &#91; &apos; ch _ names &apos; &#93; &#91; ch _ idx &#93; DCNL DCSP DCSP DCSP if ( ch _ name in params &#91; &apos; info &apos; &#93; &#91; &apos; bads &apos; &#93; ) : DCNL DCSP DCSP DCSP DCSP if ( not butterfly ) : DCNL DCSP DCSP DCSP DCSP DCSP this _ color = params &#91; &apos; bad _ color &apos; &#93; DCNL DCSP DCSP DCSP DCSP DCSP ylabels &#91; line _ idx &#93; .set _ color ( this _ color ) DCNL DCSP DCSP DCSP DCSP this _ color = np.tile ( params &#91; &apos; bad _ color &apos; &#93; , ( num _ epochs , 1 ) ) DCNL DCSP DCSP DCSP DCSP for bad _ idx in params &#91; &apos; bads &apos; &#93; : DCNL DCSP DCSP DCSP DCSP DCSP if ( ( bad _ idx &lt; start _ idx ) or ( bad _ idx &gt; end _ idx ) ) : DCNL DCSP DCSP DCSP DCSP DCSP DCSP continue DCNL DCSP DCSP DCSP DCSP DCSP this _ color &#91; ( bad _ idx - start _ idx ) &#93; = ( 1.0 , 0.0 , 0.0 ) DCNL DCSP DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ zorder ( 2 ) DCNL DCSP DCSP DCSP else : DCNL DCSP DCSP DCSP DCSP this _ color = params &#91; &apos; colors &apos; &#93; &#91; ch _ idx &#93; &#91; start _ idx : end _ idx &#93; DCNL DCSP DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ zorder ( 3 ) DCNL DCSP DCSP DCSP DCSP if ( not butterfly ) : DCNL DCSP DCSP DCSP DCSP DCSP ylabels &#91; line _ idx &#93; .set _ color ( &apos; black &apos; ) DCNL DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ segments ( segments ) DCNL DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ color ( this _ color ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP lines &#91; line _ idx &#93; .set _ segments ( list ( ) ) DCNL DCSP ax.set _ xlim ( params &#91; &apos; times &apos; &#93; &#91; 0 &#93; , ( params &#91; &apos; times &apos; &#93; &#91; 0 &#93; + params &#91; &apos; duration &apos; &#93; ) , False ) DCNL DCSP params &#91; &apos; ax2 &apos; &#93; .set _ xlim ( params &#91; &apos; times &apos; &#93; &#91; 0 &#93; , ( params &#91; &apos; times &apos; &#93; &#91; 0 &#93; + params &#91; &apos; duration &apos; &#93; ) , False ) DCNL DCSP if butterfly : DCNL DCSP DCSP factor = ( ( -1.0 ) / params &#91; &apos; butterfly _ scale &apos; &#93; ) DCNL DCSP DCSP labels = np.empty ( 20 , dtype = &apos; S15 &apos; ) DCNL DCSP DCSP labels.fill ( &apos; &apos; ) DCNL DCSP DCSP ticks = ax.get _ yticks ( ) DCNL DCSP DCSP idx _ offset = 1 DCNL DCSP DCSP if ( &apos; grad &apos; in params &#91; &apos; types &apos; &#93; ) : DCNL DCSP DCSP DCSP labels &#91; ( idx _ offset + 1 ) &#93; = &apos; 0.00 &apos; DCNL DCSP DCSP DCSP for idx in &#91; idx _ offset , ( idx _ offset + 2 ) &#93; : DCNL DCSP DCSP DCSP DCSP labels &#91; idx &#93; = &apos; { 0 : .2f } &apos; .format ( ( ( ( ( ticks &#91; idx &#93; - offsets &#91; 0 &#93; ) * params &#91; &apos; scalings &apos; &#93; &#91; &apos; grad &apos; &#93; ) * 10000000000000.0 ) * factor ) ) DCNL DCSP DCSP DCSP idx _ offset + = 4 DCNL DCSP DCSP if ( &apos; mag &apos; in params &#91; &apos; types &apos; &#93; ) : DCNL DCSP DCSP DCSP labels &#91; ( idx _ offset + 1 ) &#93; = &apos; 0.00 &apos; DCNL DCSP DCSP DCSP for idx in &#91; idx _ offset , ( idx _ offset + 2 ) &#93; : DCNL DCSP DCSP DCSP DCSP labels &#91; idx &#93; = &apos; { 0 : .2f } &apos; .format ( ( ( ( ( ticks &#91; idx &#93; - offsets &#91; 1 &#93; ) * params &#91; &apos; scalings &apos; &#93; &#91; &apos; mag &apos; &#93; ) * 1000000000000000.0 ) * factor ) ) DCNL DCSP DCSP DCSP idx _ offset + = 4 DCNL DCSP DCSP if ( &apos; eeg &apos; in params &#91; &apos; types &apos; &#93; ) : DCNL DCSP DCSP DCSP labels &#91; ( idx _ offset + 1 ) &#93; = &apos; 0.00 &apos; DCNL DCSP DCSP DCSP for idx in &#91; idx _ offset , ( idx _ offset + 2 ) &#93; : DCNL DCSP DCSP DCSP DCSP labels &#91; idx &#93; = &apos; { 0 : .2f } &apos; .format ( ( ( ( ( ticks &#91; idx &#93; - offsets &#91; 2 &#93; ) * params &#91; &apos; scalings &apos; &#93; &#91; &apos; eeg &apos; &#93; ) * 1000000.0 ) * factor ) ) DCNL DCSP DCSP DCSP idx _ offset + = 4 DCNL DCSP DCSP if ( &apos; eog &apos; in params &#91; &apos; types &apos; &#93; ) : DCNL DCSP DCSP DCSP labels &#91; ( idx _ offset + 1 ) &#93; = &apos; 0.00 &apos; DCNL DCSP DCSP DCSP for idx in &#91; idx _ offset , ( idx _ offset + 2 ) &#93; : DCNL DCSP DCSP DCSP DCSP labels &#91; idx &#93; = &apos; { 0 : .2f } &apos; .format ( ( ( ( ( ticks &#91; idx &#93; - offsets &#91; 3 &#93; ) * params &#91; &apos; scalings &apos; &#93; &#91; &apos; eog &apos; &#93; ) * 1000000.0 ) * factor ) ) DCNL DCSP DCSP DCSP idx _ offset + = 4 DCNL DCSP DCSP if ( &apos; ecg &apos; in params &#91; &apos; types &apos; &#93; ) : DCNL DCSP DCSP DCSP labels &#91; ( idx _ offset + 1 ) &#93; = &apos; 0.00 &apos; DCNL DCSP DCSP DCSP for idx in &#91; idx _ offset , ( idx _ offset + 2 ) &#93; : DCNL DCSP DCSP DCSP DCSP labels &#91; idx &#93; = &apos; { 0 : .2f } &apos; .format ( ( ( ( ( ticks &#91; idx &#93; - offsets &#91; 4 &#93; ) * params &#91; &apos; scalings &apos; &#93; &#91; &apos; ecg &apos; &#93; ) * 1000000.0 ) * factor ) ) DCNL DCSP DCSP ax.set _ yticklabels ( labels , fontsize = 12 , color = &apos; black &apos; ) DCNL DCSP else : DCNL DCSP DCSP ax.set _ yticklabels ( tick _ list , fontsize = 12 ) DCNL DCSP if ( params &#91; &apos; events &apos; &#93; is not None ) : DCNL DCSP DCSP _ draw _ event _ lines ( params ) DCNL DCSP params &#91; &apos; vsel _ patch &apos; &#93; .set _ y ( ch _ start ) DCNL DCSP params &#91; &apos; fig &apos; &#93; .canvas.draw ( ) DCNL DCSP if ( params &#91; &apos; fig _ proj &apos; &#93; is not None ) : DCNL DCSP DCSP params &#91; &apos; fig _ proj &apos; &#93; .canvas.draw ( )
DCSP if ask ( Q.orthogonal ( expr.arg ) , assumptions ) : DCNL DCSP DCSP return S.One DCNL DCSP elif ask ( Q.singular ( expr.arg ) , assumptions ) : DCNL DCSP DCSP return S.Zero DCNL DCSP elif ask ( Q.unit _ triangular ( expr.arg ) , assumptions ) : DCNL DCSP DCSP return S.One DCNL DCSP return expr
DCSP return getattr ( g , &apos; _ rate _ limit &apos; , None )
DCSP runner = Runner ( join _ path ( &apos; zh-TW &apos; , &apos; success &apos; , &apos; outlines.feature &apos; ) , verbosity = 3 , no _ color = False ) DCNL DCSP runner.run ( ) DCNL DCSP assert _ stdout _ lines ( u &apos; \ n \ x1b &#91; 1 ; 37m \ u7279 \ u6027 : DCSP \ u4e2d \ u6587 \ u5834 \ u666f \ u6a21 \ u677f DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines.feature : 3 \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 37m DCSP DCSP \ u4e2d \ u6587 \ u5834 \ u666f \ u6a21 \ u677f \ u5716 \ u8868 \ u6e2c \ u8a66 DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines.feature : 4 \ x1b &#91; 0m \ n \ n \ x1b &#91; 1 ; 37m DCSP DCSP \ u5834 \ u666f \ u6a21 \ u677f : DCSP \ u7528 \ u8868 \ u683c \ u63cf \ u8ff0 \ u5834 \ u666f DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines.feature : 6 \ x1b &#91; 0m \ n \ x1b &#91; 0 ; 36m DCSP DCSP DCSP DCSP \ u5982 \ u679c DCSP \ u8f38 \ u5165 \ u662f &lt; \ u8f38 \ u5165 &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines _ steps.py : 13 \ x1b &#91; 0m \ n \ x1b &#91; 0 ; 36m DCSP DCSP DCSP DCSP \ u7576 DCSP \ u57f7 \ u884c &lt; \ u8655 \ u7406 &gt; \ u6642 DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines _ steps.py : 22 \ x1b &#91; 0m \ n \ x1b &#91; 0 ; 36m DCSP DCSP DCSP DCSP \ u90a3 \ u9ebd DCSP \ u5f97 \ u5230 &lt; \ u7d50 \ u679c &gt; DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 30m # DCSP tests / functional / language _ specific _ features / zh-TW / success / outlines _ steps.py : 31 \ x1b &#91; 0m \ n \ n \ x1b &#91; 1 ; 37m DCSP DCSP \ u4f8b \ u5982 : \ x1b &#91; 0m \ n \ x1b &#91; 0 ; 36m DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 0 ; 36m DCSP \ u8f38 \ u5165 \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 0 ; 36m DCSP \ u8655 \ u7406 \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 0 ; 36m DCSP \ u7d50 \ u679c DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 0 ; 36m \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 32m DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u4ec0 \ u9ebd \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u9019 \ u500b \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u529f \ u80fd DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 32m DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u5176 \ u4ed6 \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u9019 \ u88cf \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u4e00 \ u6a23 DCSP DCSP DCSP DCSP DCSP DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 32m DCSP DCSP DCSP \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u6578 \ u64da \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP \ u52d5 \ u4f5c \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m DCSP unicode \ u8f38 \ u51fa ! \ x1b &#91; 1 ; 37m DCSP &#124; \ x1b &#91; 1 ; 32m \ x1b &#91; 0m \ n \ n \ x1b &#91; 1 ; 37m1 DCSP feature DCSP ( \ x1b &#91; 1 ; 32m1 DCSP passed \ x1b &#91; 1 ; 37m ) \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 37m3 DCSP scenarios DCSP ( \ x1b &#91; 1 ; 32m3 DCSP passed \ x1b &#91; 1 ; 37m ) \ x1b &#91; 0m \ n \ x1b &#91; 1 ; 37m9 DCSP steps DCSP ( \ x1b &#91; 1 ; 32m9 DCSP passed \ x1b &#91; 1 ; 37m ) \ x1b &#91; 0m \ n &apos; )
DCSP files = flask.request.files DCNL DCSP archive _ file = get _ tempfile ( files &#91; &apos; archive &apos; &#93; , &apos; .archive &apos; ) DCNL DCSP if tarfile.is _ tarfile ( archive _ file ) : DCNL DCSP DCSP archive = tarfile.open ( archive _ file , &apos; r &apos; ) DCNL DCSP DCSP names = archive.getnames ( ) DCNL DCSP elif zipfile.is _ zipfile ( archive _ file ) : DCNL DCSP DCSP archive = zipfile.ZipFile ( archive _ file , &apos; r &apos; ) DCNL DCSP DCSP names = archive.namelist ( ) DCNL DCSP else : DCNL DCSP DCSP return ( flask.jsonify ( { &apos; status &apos; : &apos; Incorrect DCSP Archive DCSP Type &apos; } ) , 500 ) DCNL DCSP if ( &apos; info.json &apos; in names ) : DCNL DCSP DCSP tempdir = tempfile.mkdtemp ( ) DCNL DCSP DCSP labels _ file = None DCNL DCSP DCSP archive.extractall ( path = tempdir ) DCNL DCSP DCSP with open ( os.path.join ( tempdir , &apos; info.json &apos; ) ) as data _ file : DCNL DCSP DCSP DCSP info = json.load ( data _ file ) DCNL DCSP DCSP ( valid , key ) = validate _ archive _ keys ( info ) DCNL DCSP DCSP if ( valid is False ) : DCNL DCSP DCSP DCSP return ( flask.jsonify ( { &apos; status &apos; : ( ( &quot; Missing DCSP Key DCSP &apos; &quot; + key ) + &quot; &apos; DCSP in DCSP info.json &quot; ) } ) , 500 ) DCNL DCSP DCSP weights _ file = os.path.join ( tempdir , info &#91; &apos; snapshot DCSP file &apos; &#93; ) DCNL DCSP DCSP if ( &apos; model DCSP file &apos; in info ) : DCNL DCSP DCSP DCSP model _ file = os.path.join ( tempdir , info &#91; &apos; model DCSP file &apos; &#93; ) DCNL DCSP DCSP elif ( &apos; network DCSP file &apos; in info ) : DCNL DCSP DCSP DCSP model _ file = os.path.join ( tempdir , info &#91; &apos; network DCSP file &apos; &#93; ) DCNL DCSP DCSP else : DCNL DCSP DCSP DCSP return ( flask.jsonify ( { &apos; status &apos; : &apos; Missing DCSP model DCSP definition DCSP in DCSP info.json &apos; } ) , 500 ) DCNL DCSP DCSP if ( &apos; labels DCSP file &apos; in info ) : DCNL DCSP DCSP DCSP labels _ file = os.path.join ( tempdir , info &#91; &apos; labels DCSP file &apos; &#93; ) DCNL DCSP DCSP job = PretrainedModelJob ( weights _ file , model _ file , labels _ file , info &#91; &apos; framework &apos; &#93; , username = utils.auth.get _ username ( ) , name = info &#91; &apos; name &apos; &#93; ) DCNL DCSP DCSP scheduler.add _ job ( job ) DCNL DCSP DCSP job.wait _ completion ( ) DCNL DCSP DCSP shutil.rmtree ( tempdir , ignore _ errors = True ) DCNL DCSP DCSP return ( flask.jsonify ( { &apos; status &apos; : &apos; success &apos; } ) , 200 ) DCNL DCSP else : DCNL DCSP DCSP return ( flask.jsonify ( { &apos; status &apos; : &apos; Missing DCSP or DCSP Incorrect DCSP json DCSP file &apos; } ) , 500 )
